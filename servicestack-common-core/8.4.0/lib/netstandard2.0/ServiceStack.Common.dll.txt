[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class ServiceStack.ActionExecExtensions : object {
    [ExtensionAttribute]
public static void ExecAllAndWait(ICollection`1<Action> actions, TimeSpan timeout);
    [ExtensionAttribute]
public static List`1<WaitHandle> ExecAsync(IEnumerable`1<Action> actions);
    [ExtensionAttribute]
public static bool WaitAll(List`1<WaitHandle> waitHandles, int timeoutMs);
    [ExtensionAttribute]
public static bool WaitAll(ICollection`1<WaitHandle> waitHandles, int timeoutMs);
    [ExtensionAttribute]
public static bool WaitAll(ICollection`1<WaitHandle> waitHandles, TimeSpan timeout);
    [ExtensionAttribute]
public static bool WaitAll(List`1<IAsyncResult> asyncResults, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles, int timeOutMs);
}
public class ServiceStack.ActionInvoker : MulticastDelegate {
    public ActionInvoker(object object, IntPtr method);
    public virtual void Invoke(object instance, Object[] args);
    public virtual IAsyncResult BeginInvoke(object instance, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.AiUtils : object {
    [AsyncStateMachineAttribute("ServiceStack.AiUtils/<GetPhraseWeightsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<ValueTuple`2<string, int>>> GetPhraseWeightsAsync(IPromptProvider provider, Nullable`1<int> defaultWeight, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ServiceStack.AppTaskResult : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <TypesCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IAppTask> <TasksRun>k__BackingField;
    [NullableAttribute("2")]
public Exception Error { get; public set; }
    public List`1<Type> TypesCompleted { get; }
    public List`1<IAppTask> TasksRun { get; }
    public bool Succeeded { get; }
    public AppTaskResult(List`1<IAppTask> tasksRun);
    public string GetLogs();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_TypesCompleted();
    [CompilerGeneratedAttribute]
public List`1<IAppTask> get_TasksRun();
    public bool get_Succeeded();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ServiceStack.AppTasks : object {
    [CompilerGeneratedAttribute]
private static AppTasks <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ILog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Action`1<String[]>> <Tasks>k__BackingField;
    public static AppTasks Instance { get; public set; }
    public ILog Log { get; public set; }
    public Dictionary`2<string, Action`1<String[]>> Tasks { get; }
    private static AppTasks();
    [CompilerGeneratedAttribute]
public static AppTasks get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(AppTasks value);
    [CompilerGeneratedAttribute]
public ILog get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILog value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Action`1<String[]>> get_Tasks();
    public static void Register(string taskName, Action`1<String[]> appTask);
    [NullableContextAttribute("2")]
public static string GetAppTaskCommands();
    public static string GetAppTaskCommands(String[] args);
    public static bool IsRunAsAppTask();
    public static Nullable`1<int> RanAsTask();
    [NullableContextAttribute("2")]
public static void Run(Action onExit);
    public static string GetDescFmt(Type nextRun);
    public static string GetDesc(Type nextRun);
}
[ExtensionAttribute]
public static class ServiceStack.AssertExtensions : object {
    public static void ThrowOnFirstNull(Object[] objs);
    [ExtensionAttribute]
public static void ThrowIfNull(object obj);
    [ExtensionAttribute]
public static void ThrowIfNull(object obj, string varName);
    [ExtensionAttribute]
public static T ThrowIfNull(T obj, string varName);
    [ExtensionAttribute]
public static string ThrowIfNullOrEmpty(string strValue);
    [ExtensionAttribute]
public static string ThrowIfNullOrEmpty(string strValue, string varName);
    [ExtensionAttribute]
public static ICollection ThrowIfNullOrEmpty(ICollection collection);
    [ExtensionAttribute]
public static ICollection ThrowIfNullOrEmpty(ICollection collection, string varName);
    [ExtensionAttribute]
public static ICollection`1<T> ThrowIfNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static ICollection`1<T> ThrowIfNullOrEmpty(ICollection`1<T> collection, string varName);
}
public static class ServiceStack.AssertUtils : object {
    public static void AreNotNull(T[] fields);
    public static void AreNotNull(IDictionary`2<string, object> fieldMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Id = {Id}, IsSet = {GetStateForDebugger}")]
[DebuggerTypeProxyAttribute("ServiceStack.AsyncEx.AsyncManualResetEvent/DebugView")]
public class ServiceStack.AsyncEx.AsyncManualResetEvent : object {
    private object _mutex;
    private TaskCompletionSource`1<object> _tcs;
    private int _id;
    [DebuggerNonUserCodeAttribute]
private bool GetStateForDebugger { get; }
    public int Id { get; }
    public bool IsSet { get; }
    public AsyncManualResetEvent(bool set);
    private bool get_GetStateForDebugger();
    public int get_Id();
    public bool get_IsSet();
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public void Set();
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ServiceStack.AsyncEx.CancellationTokenTaskSource`1 : object {
    [NullableAttribute("2")]
private IDisposable _registration;
    [CompilerGeneratedAttribute]
private Task`1<T> <Task>k__BackingField;
    public Task`1<T> Task { get; private set; }
    public CancellationTokenTaskSource`1(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Task`1<T> get_Task();
    [CompilerGeneratedAttribute]
private void set_Task(Task`1<T> value);
    public sealed virtual void Dispose();
}
internal static class ServiceStack.AsyncEx.ExceptionHelpers : object {
    [NullableContextAttribute("1")]
public static Exception PrepareForRethrow(Exception exception);
}
internal static class ServiceStack.AsyncEx.IdManager`1 : object {
    private static int _lastId;
    public static int GetId(Int32& id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ServiceStack.AsyncEx.TaskCompletionSourceExtensions : object {
    [ExtensionAttribute]
public static bool TryCompleteFromCompletedTask(TaskCompletionSource`1<TResult> this, Task`1<TSourceResult> task);
    [ExtensionAttribute]
public static bool TryCompleteFromCompletedTask(TaskCompletionSource`1<TResult> this, Task task, Func`1<TResult> resultFunc);
    public static TaskCompletionSource`1<TResult> CreateAsyncTaskSource();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ServiceStack.AsyncEx.TaskExtensions : object {
    [ExtensionAttribute]
public static Task WaitAsync(Task this, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ServiceStack.AsyncEx.TaskExtensions/<DoWaitAsync>d__1")]
private static Task DoWaitAsync(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WaitAndUnwrapException(Task task);
    [ExtensionAttribute]
public static void WaitAndUnwrapException(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TResult WaitAndUnwrapException(Task`1<TResult> task);
    [ExtensionAttribute]
public static TResult WaitAndUnwrapException(Task`1<TResult> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WaitWithoutException(Task task);
    [ExtensionAttribute]
public static void WaitWithoutException(Task task, CancellationToken cancellationToken);
}
public class ServiceStack.BundleOptions : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputWebPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Minify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveToDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Bundle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegisterModuleInAmd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IIFE>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Defer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Module>k__BackingField;
    public List`1<string> Sources { get; public set; }
    public string OutputTo { get; public set; }
    public string OutputWebPath { get; public set; }
    public string PathBase { get; public set; }
    public bool Minify { get; public set; }
    public bool SaveToDisk { get; public set; }
    public bool Cache { get; public set; }
    public bool Bundle { get; public set; }
    public bool RegisterModuleInAmd { get; public set; }
    public bool IIFE { get; public set; }
    public bool Async { get; public set; }
    public bool Defer { get; public set; }
    public bool Module { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_OutputTo();
    [CompilerGeneratedAttribute]
public void set_OutputTo(string value);
    [CompilerGeneratedAttribute]
public string get_OutputWebPath();
    [CompilerGeneratedAttribute]
public void set_OutputWebPath(string value);
    [CompilerGeneratedAttribute]
public string get_PathBase();
    [CompilerGeneratedAttribute]
public void set_PathBase(string value);
    [CompilerGeneratedAttribute]
public bool get_Minify();
    [CompilerGeneratedAttribute]
public void set_Minify(bool value);
    [CompilerGeneratedAttribute]
public bool get_SaveToDisk();
    [CompilerGeneratedAttribute]
public void set_SaveToDisk(bool value);
    [CompilerGeneratedAttribute]
public bool get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(bool value);
    [CompilerGeneratedAttribute]
public bool get_Bundle();
    [CompilerGeneratedAttribute]
public void set_Bundle(bool value);
    [CompilerGeneratedAttribute]
public bool get_RegisterModuleInAmd();
    [CompilerGeneratedAttribute]
public void set_RegisterModuleInAmd(bool value);
    [CompilerGeneratedAttribute]
public bool get_IIFE();
    [CompilerGeneratedAttribute]
public void set_IIFE(bool value);
    [CompilerGeneratedAttribute]
public bool get_Async();
    [CompilerGeneratedAttribute]
public void set_Async(bool value);
    [CompilerGeneratedAttribute]
public bool get_Defer();
    [CompilerGeneratedAttribute]
public void set_Defer(bool value);
    [CompilerGeneratedAttribute]
public bool get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(bool value);
}
public class ServiceStack.ByteArrayComparer : object {
    public static ByteArrayComparer Instance;
    private static ByteArrayComparer();
    public sealed virtual bool Equals(Byte[] left, Byte[] right);
    public sealed virtual int GetHashCode(Byte[] key);
}
[ExtensionAttribute]
public static class ServiceStack.ByteArrayExtensions : object {
    [ExtensionAttribute]
public static bool AreEqual(Byte[] b1, Byte[] b2);
    [ExtensionAttribute]
public static Byte[] ToSha1Hash(Byte[] bytes);
}
[ExtensionAttribute]
public static class ServiceStack.CachedExpressionCompiler : object {
    private static ParameterExpression _unusedParameterExpr;
    private static CachedExpressionCompiler();
    [ExtensionAttribute]
public static Func`2<TModel, TValue> Compile(Expression`1<Func`2<TModel, TValue>> lambdaExpression);
    public static object Evaluate(Expression arg);
    private static Func`2<object, object> Wrap(Expression arg);
}
public class ServiceStack.Command : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Original>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReadOnlyMemory`1<char>> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Suffix>k__BackingField;
    public string Name { get; public set; }
    public ReadOnlyMemory`1<char> Original { get; public set; }
    public List`1<ReadOnlyMemory`1<char>> Args { get; internal set; }
    public ReadOnlyMemory`1<char> Suffix { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Original();
    [CompilerGeneratedAttribute]
public void set_Original(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public List`1<ReadOnlyMemory`1<char>> get_Args();
    [CompilerGeneratedAttribute]
internal void set_Args(List`1<ReadOnlyMemory`1<char>> value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(ReadOnlyMemory`1<char> value);
    public int IndexOfMethodEnd(ReadOnlyMemory`1<char> commandsString, int pos);
    public virtual string ToDebugString();
    public virtual string ToString();
    public ReadOnlyMemory`1<char> AsMemory();
}
public class ServiceStack.CommandsUtils : object {
    public static List`1<T> ExecuteAsyncCommandList(TimeSpan timeout, ICommandList`1[] commands);
    public static List`1<T> ExecuteAsyncCommandList(TimeSpan timeout, IEnumerable`1<ICommandList`1<T>> commands);
    public static void WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    private static void ExecuteCommandList(object state);
    private static void ExecuteCommandExec(object state);
    public static void ExecuteAsyncCommandExec(TimeSpan timeout, IEnumerable`1<ICommandExec> commands);
    public static List`1<WaitHandle> ExecuteAsyncCommandExec(IEnumerable`1<ICommandExec> commands);
}
[ExtensionAttribute]
public static class ServiceStack.CommonDiagnosticUtils : object {
    [ExtensionAttribute]
public static void Init(DiagnosticListener listener, IMessage msg);
}
public class ServiceStack.ConnectionInfo : object {
    [CompilerGeneratedAttribute]
private string <NamedConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    public string NamedConnection { get; public set; }
    public string ConnectionString { get; public set; }
    public string ProviderName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NamedConnection();
    [CompilerGeneratedAttribute]
public void set_NamedConnection(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public void set_ProviderName(string value);
}
[ExtensionAttribute]
public static class ServiceStack.ContainerExtensions : object {
    [ExtensionAttribute]
public static T Resolve(IResolver container);
    [ExtensionAttribute]
public static T Resolve(IContainer container);
    [ExtensionAttribute]
public static bool Exists(IContainer container);
    [ExtensionAttribute]
public static IContainer AddTransient(IContainer container);
    [ExtensionAttribute]
public static IContainer AddTransient(IContainer container, Func`1<TService> factory);
    [ExtensionAttribute]
public static IContainer AddTransient(IContainer container);
    [ExtensionAttribute]
public static IContainer AddTransient(IContainer container, Type type);
    [ExtensionAttribute]
public static IContainer AddSingleton(IContainer container);
    [ExtensionAttribute]
public static IContainer AddSingleton(IContainer container, Func`1<TService> factory);
    [ExtensionAttribute]
public static IContainer AddSingleton(IContainer container);
    [ExtensionAttribute]
public static IContainer AddSingleton(IContainer container, Type type);
}
public class ServiceStack.Data.DbConnectionFactory : object {
    private Func`1<IDbConnection> connectionFactoryFn;
    public DbConnectionFactory(Func`1<IDbConnection> connectionFactoryFn);
    public sealed virtual IDbConnection OpenDbConnection();
    public sealed virtual IDbConnection CreateDbConnection();
}
public interface ServiceStack.Data.IDbConnectionFactory {
    public abstract virtual IDbConnection OpenDbConnection();
    public abstract virtual IDbConnection CreateDbConnection();
}
public interface ServiceStack.Data.IDbConnectionFactoryExtended {
    public abstract virtual IDbConnection OpenDbConnection(string namedConnection);
    public abstract virtual IDbConnection OpenDbConnectionString(string connectionString);
    public abstract virtual IDbConnection OpenDbConnectionString(string connectionString, string providerName);
}
public interface ServiceStack.Data.IHasDbCommand {
    public IDbCommand DbCommand { get; }
    public abstract virtual IDbCommand get_DbCommand();
}
public interface ServiceStack.Data.IHasDbConnection {
    public IDbConnection DbConnection { get; }
    public abstract virtual IDbConnection get_DbConnection();
}
public interface ServiceStack.Data.IHasDbTransaction {
    public IDbTransaction DbTransaction { get; }
    public abstract virtual IDbTransaction get_DbTransaction();
}
[ExtensionAttribute]
public static class ServiceStack.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValue(Dictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> defaultValue);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IDictionary dictionary);
    [ExtensionAttribute]
public static void ForEach(Dictionary`2<TKey, TValue> dictionary, Action`2<TKey, TValue> onEachFn);
    [ExtensionAttribute]
public static bool UnorderedEquivalentTo(IDictionary`2<K, V> thisMap, IDictionary`2<K, V> otherMap);
    public static List`1<T> ConvertAll(IDictionary`2<K, V> map, Func`3<K, V, T> createFn);
    [ExtensionAttribute]
public static V GetOrAdd(Dictionary`2<K, V> map, K key, Func`2<K, V> createFn);
    [ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> PairWith(TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(ConcurrentDictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static ConcurrentDictionary`2<TKey, TValue> ToConcurrentDictionary(IDictionary`2<TKey, TValue> from);
    [ExtensionAttribute]
public static bool TryRemove(Dictionary`2<TKey, TValue> map, TKey key, TValue& value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> RemoveKey(Dictionary`2<TKey, TValue> map, TKey key);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> MoveKey(Dictionary`2<TKey, TValue> map, TKey oldKey, TKey newKey, Func`2<TValue, TValue> valueFilter);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> Merge(IDictionary`2<TKey, TValue> initial, IEnumerable`1[] withSources);
}
[ExtensionAttribute]
public static class ServiceStack.DirectoryInfoExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetMatchingFiles(DirectoryInfo rootDirPath, string fileSearchPattern);
    [IteratorStateMachineAttribute("ServiceStack.DirectoryInfoExtensions/<GetMatchingFiles>d__1")]
public static IEnumerable`1<string> GetMatchingFiles(string rootDirPath, string fileSearchPattern);
}
[ExtensionAttribute]
public static class ServiceStack.DisposableExtensions : object {
    [ExtensionAttribute]
public static void Dispose(IEnumerable`1<IDisposable> resources, ILog log);
    [ExtensionAttribute]
public static void Dispose(IEnumerable`1<IDisposable> resources);
    public static void Dispose(IDisposable[] disposables);
    [ExtensionAttribute]
public static void Run(T disposable, Action`1<T> runActionThenDispose);
}
[ExtensionAttribute]
public static class ServiceStack.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool IsEmpty(T[] collection);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ToSet() or 'using System.Linq;'")]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static HashSet`1<T> ToSet(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static HashSet`1<T> ToSet(IEnumerable`1<T> items, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void Each(IEnumerable`1<T> values, Action`1<T> action);
    [ExtensionAttribute]
public static void Each(IEnumerable`1<T> values, Action`2<int, T> action);
    [ExtensionAttribute]
public static void Each(IDictionary`2<TKey, TValue> map, Action`2<TKey, TValue> action);
    [ExtensionAttribute]
public static List`1<To> Map(IEnumerable`1<From> items, Func`2<From, To> converter);
    [ExtensionAttribute]
public static List`1<To> Map(IEnumerable items, Func`2<object, To> converter);
    [ExtensionAttribute]
public static List`1<object> ToObjects(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static string FirstNonDefaultOrEmpty(IEnumerable`1<string> values);
    [ExtensionAttribute]
public static T FirstNonDefault(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool EquivalentTo(Byte[] bytes, Byte[] other);
    [ExtensionAttribute]
public static bool EquivalentTo(T[] array, T[] otherArray, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static bool EquivalentTo(IEnumerable`1<T> thisList, IEnumerable`1<T> otherList, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static bool EquivalentTo(IDictionary`2<K, V> a, IDictionary`2<K, V> b, Func`3<V, V, bool> comparer);
    [IteratorStateMachineAttribute("ServiceStack.EnumerableExtensions/<BatchesOf>d__17`1")]
[ExtensionAttribute]
public static IEnumerable`1<T[]> BatchesOf(IEnumerable`1<T> sequence, int batchSize);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToSafeDictionary(IEnumerable`1<T> list, Func`2<T, TKey> expr);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<T> list, Func`2<T, KeyValuePair`2<TKey, TValue>> map);
    [ExtensionAttribute]
public static IEnumerable`1<T> Safe(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static IEnumerable Safe(IEnumerable enumerable);
    [AsyncStateMachineAttribute("ServiceStack.EnumerableExtensions/<AllAsync>d__22`1")]
[ExtensionAttribute]
public static Task`1<bool> AllAsync(IEnumerable`1<T> source, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("ServiceStack.EnumerableExtensions/<AllAsync>d__23`1")]
[ExtensionAttribute]
public static Task`1<bool> AllAsync(IEnumerable`1<Task`1<T>> source, Func`2<T, bool> predicate);
    [AsyncStateMachineAttribute("ServiceStack.EnumerableExtensions/<AnyAsync>d__24`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(IEnumerable`1<T> source, Func`2<T, Task`1<bool>> predicate);
    [AsyncStateMachineAttribute("ServiceStack.EnumerableExtensions/<AnyAsync>d__25`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(IEnumerable`1<Task`1<T>> source, Func`2<T, bool> predicate);
    public static List`1<string> AllKeysWithDefaultValues(IEnumerable collection);
    public static Type FirstElementType(IEnumerable collection, string key);
    [ExtensionAttribute]
public static T[] CombineDistinct(T[] original, T[][] others);
    [ExtensionAttribute]
public static HashSet`1<T> CombineSet(T[] original, T[][] others);
}
public static class ServiceStack.EnumerableUtils : object {
    public static object FirstOrDefault(IEnumerable items);
    public static object ElementAt(IEnumerable items, int index);
    public static List`1<object> Skip(IEnumerable items, int count);
    public static List`1<object> SplitOnFirst(IEnumerable items, Object& first);
    public static List`1<object> Take(IEnumerable items, int count);
    public static int Count(IEnumerable items);
    public static List`1<object> ToList(IEnumerable items);
    public static IEnumerable NullIfEmpty(IEnumerable items);
    public static bool IsEmpty(IEnumerable items);
}
[ExtensionAttribute]
public static class ServiceStack.EnumExtensions : object {
    [ExtensionAttribute]
public static string ToDescription(Enum enum);
    [ExtensionAttribute]
public static List`1<KeyValuePair`2<string, string>> ToKeyValuePairs(IEnumerable`1<T> enums);
    [ExtensionAttribute]
public static List`1<string> ToList(Enum enum);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Enum enum);
    [ExtensionAttribute]
public static bool Has(Enum enum, T value);
    [ExtensionAttribute]
public static bool Is(Enum enum, T value);
    [ExtensionAttribute]
public static T Add(Enum enum, T value);
    [ExtensionAttribute]
public static T Remove(Enum enum, T value);
}
[ExtensionAttribute]
public static class ServiceStack.EnumUtils : object {
    public static IEnumerable`1<T> GetValues();
    public static FieldInfo GetEnumMember(Type type, string name);
    [ExtensionAttribute]
public static List`1<string> ToEnumFlagsList(Enum enumValue);
    public static object FromEnumFlagsList(Type enumType, List`1<string> enums);
    public static T FromEnumFlagsList(List`1<string> enums);
}
[ExtensionAttribute]
public static class ServiceStack.ExecUtils : object {
    [CompilerGeneratedAttribute]
private static int <BaseDelayMs>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <MaxBackOffMs>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <MaxRetries>k__BackingField;
    public static int BaseDelayMs { get; public set; }
    public static int MaxBackOffMs { get; public set; }
    public static int MaxRetries { get; public set; }
    private static ExecUtils();
    public static void LogError(Type declaringType, string clientMethodName, Exception ex);
    [ExtensionAttribute]
public static void ExecAll(IEnumerable`1<T> instances, Action`1<T> action);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<ExecAllAsync>d__2`1")]
[ExtensionAttribute]
public static Task ExecAllAsync(IEnumerable`1<T> instances, Func`2<T, Task> action);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<ExecAllReturnFirstAsync>d__3`2")]
[ExtensionAttribute]
public static Task`1<TReturn> ExecAllReturnFirstAsync(IEnumerable`1<T> instances, Func`2<T, Task`1<TReturn>> action);
    [ExtensionAttribute]
public static void ExecAllWithFirstOut(IEnumerable`1<T> instances, Func`2<T, TReturn> action, TReturn& firstResult);
    [ExtensionAttribute]
public static TReturn ExecReturnFirstWithResult(IEnumerable`1<T> instances, Func`2<T, TReturn> action);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<ExecReturnFirstWithResultAsync>d__6`2")]
[ExtensionAttribute]
public static Task`1<TReturn> ExecReturnFirstWithResultAsync(IEnumerable`1<T> instances, Func`2<T, Task`1<TReturn>> action);
    public static void RetryUntilTrue(Func`1<bool> action, Nullable`1<TimeSpan> timeOut);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<RetryUntilTrueAsync>d__8")]
public static Task RetryUntilTrueAsync(Func`1<Task`1<bool>> action, Nullable`1<TimeSpan> timeOut);
    public static bool WaitUntilTrue(Func`1<bool> action, Nullable`1<TimeSpan> timeOut);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<WaitUntilTrueAsync>d__10")]
public static Task`1<bool> WaitUntilTrueAsync(Func`1<bool> action, Nullable`1<TimeSpan> timeOut);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<WaitUntilTrueAsync>d__11")]
public static Task`1<bool> WaitUntilTrueAsync(Func`1<Task`1<bool>> action, Nullable`1<TimeSpan> timeOut);
    public static void RetryOnException(Action action, Nullable`1<TimeSpan> timeOut);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<RetryOnExceptionAsync>d__13")]
public static Task RetryOnExceptionAsync(Func`1<Task> action, Nullable`1<TimeSpan> timeOut);
    public static void RetryOnException(Action action, int maxRetries);
    public static T RetryOnException(Func`1<T> action, int maxRetries);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<RetryOnExceptionAsync>d__16")]
public static Task RetryOnExceptionAsync(Func`1<Task> action, int maxRetries);
    [AsyncStateMachineAttribute("ServiceStack.ExecUtils/<RetryOnExceptionAsync>d__17`1")]
public static Task`1<T> RetryOnExceptionAsync(Func`1<Task`1<T>> action, int maxRetries);
    [CompilerGeneratedAttribute]
public static int get_BaseDelayMs();
    [CompilerGeneratedAttribute]
public static void set_BaseDelayMs(int value);
    [CompilerGeneratedAttribute]
public static int get_MaxBackOffMs();
    [CompilerGeneratedAttribute]
public static void set_MaxBackOffMs(int value);
    [CompilerGeneratedAttribute]
public static int get_MaxRetries();
    [CompilerGeneratedAttribute]
public static void set_MaxRetries(int value);
    public static void SleepBackOffMultiplier(int retriesAttempted);
    public static Task DelayBackOffMultiplierAsync(int retriesAttempted);
    public static int CalculateFullJitterBackOffDelay(int retriesAttempted);
    public static int CalculateFullJitterBackOffDelay(int retriesAttempted, int baseDelay, int maxBackOffMs);
    public static int CalculateExponentialDelay(int retriesAttempted);
    public static int CalculateExponentialDelay(int retriesAttempted, int baseDelay, int maxBackOffMs);
    public static int CalculateRetryDelayMs(int retryAttempt, RetryPolicy retry);
    public static int CalculateMemoryLockDelay(int retries);
    public static string ShellExec(string command, Dictionary`2<string, object> args);
}
internal class ServiceStack.ExpressionUtil.BinaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; private set; }
    public BinaryExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal static class ServiceStack.ExpressionUtil.CachedExpressionCompiler : object {
    public static Func`2<TModel, TValue> Process(Expression`1<Func`2<TModel, TValue>> lambdaExpression);
}
internal class ServiceStack.ExpressionUtil.ConditionalExpressionFingerprint : ExpressionFingerprint {
    public ConditionalExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ServiceStack.ExpressionUtil.ConstantExpressionFingerprint : ExpressionFingerprint {
    public ConstantExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ServiceStack.ExpressionUtil.DefaultExpressionFingerprint : ExpressionFingerprint {
    public DefaultExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class ServiceStack.ExpressionUtil.ExpressionFingerprint : object {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; private set; }
    public Type Type { get; private set; }
    protected ExpressionFingerprint(ExpressionType nodeType, Type type);
    [CompilerGeneratedAttribute]
public ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
private void set_NodeType(ExpressionType value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
    protected bool Equals(ExpressionFingerprint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ServiceStack.ExpressionUtil.ExpressionFingerprintChain : object {
    public List`1<ExpressionFingerprint> Elements;
    public sealed virtual bool Equals(ExpressionFingerprintChain other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ServiceStack.ExpressionUtil.FingerprintingExpressionVisitor : ExpressionVisitor {
    private List`1<object> _seenConstants;
    private List`1<ParameterExpression> _seenParameters;
    private ExpressionFingerprintChain _currentChain;
    private bool _gaveUp;
    private T GiveUp(T node);
    public static ExpressionFingerprintChain GetFingerprintChain(Expression expr, List`1& capturedConstants);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected virtual Expression VisitDefault(DefaultExpression node);
    protected virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitIndex(IndexExpression node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitLabel(LabelExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitListInit(ListInitExpression node);
    protected virtual Expression VisitLoop(LoopExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected virtual Expression VisitTry(TryExpression node);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
}
internal class ServiceStack.ExpressionUtil.HashCodeCombiner : object {
    private long _combinedHash64;
    public int CombinedHash { get; }
    public int get_CombinedHash();
    public void AddFingerprint(ExpressionFingerprint fingerprint);
    public void AddEnumerable(IEnumerable e);
    public void AddInt32(int i);
    public void AddObject(object o);
}
internal class ServiceStack.ExpressionUtil.Hoisted`2 : MulticastDelegate {
    public Hoisted`2(object object, IntPtr method);
    public virtual TValue Invoke(TModel model, List`1<object> capturedConstants);
    public virtual IAsyncResult BeginInvoke(TModel model, List`1<object> capturedConstants, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
internal class ServiceStack.ExpressionUtil.HoistingExpressionVisitor`2 : ExpressionVisitor {
    private static ParameterExpression _hoistedConstantsParamExpr;
    private int _numConstantsProcessed;
    private static HoistingExpressionVisitor`2();
    public static Expression`1<Hoisted`2<TIn, TOut>> Hoist(Expression`1<Func`2<TIn, TOut>> expr);
    protected virtual Expression VisitConstant(ConstantExpression node);
}
internal class ServiceStack.ExpressionUtil.IndexExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public PropertyInfo Indexer { get; private set; }
    public IndexExpressionFingerprint(ExpressionType nodeType, Type type, PropertyInfo indexer);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Indexer();
    [CompilerGeneratedAttribute]
private void set_Indexer(PropertyInfo value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal class ServiceStack.ExpressionUtil.LambdaExpressionFingerprint : ExpressionFingerprint {
    public LambdaExpressionFingerprint(ExpressionType nodeType, Type type);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class ServiceStack.ExpressionUtil.MemberExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public MemberInfo Member { get; private set; }
    public MemberExpressionFingerprint(ExpressionType nodeType, Type type, MemberInfo member);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(MemberInfo value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal class ServiceStack.ExpressionUtil.MethodCallExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; private set; }
    public MethodCallExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal class ServiceStack.ExpressionUtil.ParameterExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private int <ParameterIndex>k__BackingField;
    public int ParameterIndex { get; private set; }
    public ParameterExpressionFingerprint(ExpressionType nodeType, Type type, int parameterIndex);
    [CompilerGeneratedAttribute]
public int get_ParameterIndex();
    [CompilerGeneratedAttribute]
private void set_ParameterIndex(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal class ServiceStack.ExpressionUtil.TypeBinaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private Type <TypeOperand>k__BackingField;
    public Type TypeOperand { get; private set; }
    public TypeBinaryExpressionFingerprint(ExpressionType nodeType, Type type, Type typeOperand);
    [CompilerGeneratedAttribute]
public Type get_TypeOperand();
    [CompilerGeneratedAttribute]
private void set_TypeOperand(Type value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
internal class ServiceStack.ExpressionUtil.UnaryExpressionFingerprint : ExpressionFingerprint {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; private set; }
    public UnaryExpressionFingerprint(ExpressionType nodeType, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void AddToHashCodeCombiner(HashCodeCombiner combiner);
}
[ExtensionAttribute]
public static class ServiceStack.ExpressionUtils : object {
    private static ILog Log;
    private static ExpressionUtils();
    [ExtensionAttribute]
public static PropertyInfo ToPropertyInfo(Expression fieldExpr);
    public static PropertyInfo ToPropertyInfo(LambdaExpression lambda);
    public static PropertyInfo ToPropertyInfo(MemberExpression m);
    public static string GetMemberName(Expression`1<Func`2<T, object>> fieldExpr);
    public static MemberExpression GetMemberExpression(Expression`1<Func`2<T, object>> expr);
    [ExtensionAttribute]
public static Dictionary`2<string, object> AssignedValues(Expression`1<Func`1<T>> expr);
    [ExtensionAttribute]
public static String[] GetFieldNames(Expression`1<Func`2<T, object>> expr);
    [ExtensionAttribute]
public static object GetValue(MemberBinding binding);
}
public static class ServiceStack.Extensions.UtilExtensions : object {
}
public static class ServiceStack.FuncUtils : object {
    private static ILog Log;
    private static FuncUtils();
    public static bool TryExec(Action action);
    public static T TryExec(Func`1<T> func);
    public static T TryExec(Func`1<T> func, T defaultValue);
    public static void WaitWhile(Func`1<bool> condition, int millisecondTimeout, int millisecondPollPeriod);
}
public class ServiceStack.Gist : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Html_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, GistFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Public>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created_At>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Updated_At>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    public string Id { get; public set; }
    public string Url { get; public set; }
    public string Html_Url { get; public set; }
    public Dictionary`2<string, GistFile> Files { get; public set; }
    public bool Public { get; public set; }
    public DateTime Created_At { get; public set; }
    public Nullable`1<DateTime> Updated_At { get; public set; }
    public string Description { get; public set; }
    public string UserId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Html_Url();
    [CompilerGeneratedAttribute]
public void set_Html_Url(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, GistFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(Dictionary`2<string, GistFile> value);
    [CompilerGeneratedAttribute]
public bool get_Public();
    [CompilerGeneratedAttribute]
public void set_Public(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_Created_At();
    [CompilerGeneratedAttribute]
public void set_Created_At(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Updated_At();
    [CompilerGeneratedAttribute]
public void set_Updated_At(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
}
public class ServiceStack.GistChangeStatus : object {
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Additions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Deletions>k__BackingField;
    public int Total { get; public set; }
    public int Additions { get; public set; }
    public int Deletions { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
    [CompilerGeneratedAttribute]
public int get_Additions();
    [CompilerGeneratedAttribute]
public void set_Additions(int value);
    [CompilerGeneratedAttribute]
public int get_Deletions();
    [CompilerGeneratedAttribute]
public void set_Deletions(int value);
}
public class ServiceStack.GistFile : object {
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Truncated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Filename { get; public set; }
    public string Type { get; public set; }
    public string Language { get; public set; }
    public string Raw_Url { get; public set; }
    public int Size { get; public set; }
    public bool Truncated { get; public set; }
    public string Content { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public void set_Filename(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_Raw_Url();
    [CompilerGeneratedAttribute]
public void set_Raw_Url(string value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public bool get_Truncated();
    [CompilerGeneratedAttribute]
public void set_Truncated(bool value);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
}
public class ServiceStack.GistHistory : object {
    [CompilerGeneratedAttribute]
private GithubUser <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Committed_At>k__BackingField;
    [CompilerGeneratedAttribute]
private GistChangeStatus <Change_Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public GithubUser User { get; public set; }
    public string Version { get; public set; }
    public DateTime Committed_At { get; public set; }
    public GistChangeStatus Change_Status { get; public set; }
    public string Url { get; public set; }
    [CompilerGeneratedAttribute]
public GithubUser get_User();
    [CompilerGeneratedAttribute]
public void set_User(GithubUser value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Committed_At();
    [CompilerGeneratedAttribute]
public void set_Committed_At(DateTime value);
    [CompilerGeneratedAttribute]
public GistChangeStatus get_Change_Status();
    [CompilerGeneratedAttribute]
public void set_Change_Status(GistChangeStatus value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
public class ServiceStack.GistLink : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <To>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GistId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Repo>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Modifiers>k__BackingField;
    public string Name { get; public set; }
    public string Url { get; public set; }
    public string User { get; public set; }
    public string To { get; public set; }
    public string Description { get; public set; }
    public String[] Tags { get; public set; }
    public string GistId { get; public set; }
    public string Repo { get; public set; }
    public Dictionary`2<string, object> Modifiers { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
    [CompilerGeneratedAttribute]
public string get_To();
    [CompilerGeneratedAttribute]
public void set_To(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public string get_GistId();
    [CompilerGeneratedAttribute]
public void set_GistId(string value);
    [CompilerGeneratedAttribute]
public string get_Repo();
    [CompilerGeneratedAttribute]
public void set_Repo(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Modifiers();
    [CompilerGeneratedAttribute]
public void set_Modifiers(Dictionary`2<string, object> value);
    public string ToTagsString();
    public virtual string ToString();
    public string ToListItem();
    public static string RenderLinks(List`1<GistLink> links);
    public static List`1<GistLink> Parse(string md);
    public static bool TryParseGitHubUrl(string url, String& gistId, String& user, String& repo);
    public static GistLink Get(List`1<GistLink> links, string gistAlias);
    public bool MatchesTag(string tagName);
}
public class ServiceStack.GistUser : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Login>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Avatar_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Gravatar_Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Html_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Gists_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Site_Admin>k__BackingField;
    public long Id { get; public set; }
    public string Login { get; public set; }
    public string Avatar_Url { get; public set; }
    public string Gravatar_Id { get; public set; }
    public string Url { get; public set; }
    public string Html_Url { get; public set; }
    public string Gists_Url { get; public set; }
    public string Type { get; public set; }
    public bool Site_Admin { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public string get_Login();
    [CompilerGeneratedAttribute]
public void set_Login(string value);
    [CompilerGeneratedAttribute]
public string get_Avatar_Url();
    [CompilerGeneratedAttribute]
public void set_Avatar_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Gravatar_Id();
    [CompilerGeneratedAttribute]
public void set_Gravatar_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Html_Url();
    [CompilerGeneratedAttribute]
public void set_Html_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Gists_Url();
    [CompilerGeneratedAttribute]
public void set_Gists_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public bool get_Site_Admin();
    [CompilerGeneratedAttribute]
public void set_Site_Admin(bool value);
}
public class ServiceStack.GitHubGateway : object {
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    public static string ApiBaseUrl;
    [CompilerGeneratedAttribute]
private string <BaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <GetJsonFilter>k__BackingField;
    public string UserAgent { get; public set; }
    public string BaseUrl { get; public set; }
    public string AccessToken { get; public set; }
    public Func`2<string, string> GetJsonFilter { get; public set; }
    public GitHubGateway(string accessToken);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_BaseUrl();
    [CompilerGeneratedAttribute]
public void set_BaseUrl(string value);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_GetJsonFilter();
    [CompilerGeneratedAttribute]
public void set_GetJsonFilter(Func`2<string, string> value);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetRateLimitsAsync>d__19")]
public Task`1<GithubRateLimits> GetRateLimitsAsync();
    public GithubRateLimits GetRateLimits();
    internal string UnwrapRepoFullName(string orgName, string name, bool useFork);
    public virtual Tuple`2<string, string> AssertRepo(String[] orgs, string name, bool useFork);
    public virtual Tuple`2<string, string> FindRepo(String[] orgs, string name, bool useFork);
    public virtual string GetSourceZipUrl(string user, string repo);
    public virtual string GetSourceZipUrl(string user, string repo, string tag);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetSourceZipUrlAsync>d__26")]
public virtual Task`1<string> GetSourceZipUrlAsync(string user, string repo);
    private static string GetSourceZipReleaseUrl(string user, string repo, string json);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetSourceReposAsync>d__28")]
public virtual Task`1<List`1<GithubRepo>> GetSourceReposAsync(string orgName);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetUserAndOrgReposAsync>d__29")]
public virtual Task`1<List`1<GithubRepo>> GetUserAndOrgReposAsync(string githubOrgOrUser);
    public virtual GithubRepo GetRepo(string userOrOrg, string repo);
    public virtual Task`1<GithubRepo> GetRepoAsync(string userOrOrg, string repo);
    public virtual List`1<GithubRepo> GetUserRepos(string githubUser);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetUserReposAsync>d__33")]
public virtual Task`1<List`1<GithubRepo>> GetUserReposAsync(string githubUser);
    public virtual List`1<GithubRepo> GetOrgRepos(string githubOrg);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetOrgReposAsync>d__35")]
public virtual Task`1<List`1<GithubRepo>> GetOrgReposAsync(string githubOrg);
    public virtual string GetJson(string route);
    public virtual T GetJson(string route);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetJsonAsync>d__38")]
public virtual Task`1<string> GetJsonAsync(string route);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetJsonAsync>d__39`1")]
public virtual Task`1<T> GetJsonAsync(string route);
    [IteratorStateMachineAttribute("ServiceStack.GitHubGateway/<StreamJsonCollection>d__40`1")]
public virtual IEnumerable`1<T> StreamJsonCollection(string route);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetJsonCollectionAsync>d__41`1")]
public virtual Task`1<List`1<T>> GetJsonCollectionAsync(string route);
    public virtual Dictionary`2<string, string> ParseLinkUrls(string linkHeader);
    public virtual void DownloadFile(string downloadUrl, string fileName);
    public virtual GithubGist GetGithubGist(string gistId);
    public virtual GithubGist GetGithubGist(string gistId, string version);
    public virtual Gist GetGist(string gistId);
    public sealed virtual Gist GetGist(string gistId, string version);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetGistAsync>d__48")]
public sealed virtual Task`1<Gist> GetGistAsync(string gistId);
    [AsyncStateMachineAttribute("ServiceStack.GitHubGateway/<GetGistAsync>d__49")]
public sealed virtual Task`1<Gist> GetGistAsync(string gistId, string version);
    private GithubGist PopulateGist(GithubGist response);
    public virtual Gist CreateGist(string description, bool isPublic, Dictionary`2<string, object> files);
    public virtual Gist CreateGist(string description, bool isPublic, Dictionary`2<string, string> textFiles);
    public virtual GithubGist CreateGithubGist(string description, bool isPublic, Dictionary`2<string, object> files);
    public virtual GithubGist CreateGithubGist(string description, bool isPublic, Dictionary`2<string, string> textFiles);
    public static bool IsDirSep(char c);
    internal static string SanitizePath(string filePath);
    internal static string ToBase64(ReadOnlyMemory`1<byte> bytes);
    internal static string ToBase64(Byte[] bytes);
    internal static string ToBase64(Stream stream);
    public static Dictionary`2<string, string> ToTextFiles(Dictionary`2<string, object> files);
    internal static NotSupportedException CreateContentNotSupportedException(object value);
    public virtual void WriteGistFiles(string gistId, Dictionary`2<string, object> files, string description, bool deleteMissing);
    public virtual void WriteGistFiles(string gistId, Dictionary`2<string, string> textFiles, string description, bool deleteMissing);
    public virtual void CreateGistFile(string gistId, string filePath, string contents);
    public virtual void WriteGistFile(string gistId, string filePath, string contents);
    protected virtual void AssertAccessToken();
    public virtual void DeleteGistFiles(string gistId, String[] filePaths);
    public virtual void ApplyRequestFilters(HttpWebRequest req);
    [CompilerGeneratedAttribute]
internal static string <ToTextFiles>g__ToBase64ThenDispose|60_0(Stream stream);
}
[ExtensionAttribute]
internal static class ServiceStack.GithubGatewayExtensions : object {
    [ExtensionAttribute]
public static bool IsUrl(string gistId);
}
public class ServiceStack.GithubGist : Gist {
    [CompilerGeneratedAttribute]
private string <Node_Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Git_Pull_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Git_Push_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Forks_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Commits_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Comments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comments_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Truncated>k__BackingField;
    [CompilerGeneratedAttribute]
private GithubUser <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private GistHistory[] <History>k__BackingField;
    public string Node_Id { get; public set; }
    public string Git_Pull_Url { get; public set; }
    public string Git_Push_Url { get; public set; }
    public string Forks_Url { get; public set; }
    public string Commits_Url { get; public set; }
    public int Comments { get; public set; }
    public string Comments_Url { get; public set; }
    public bool Truncated { get; public set; }
    public GithubUser Owner { get; public set; }
    public GistHistory[] History { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Node_Id();
    [CompilerGeneratedAttribute]
public void set_Node_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Git_Pull_Url();
    [CompilerGeneratedAttribute]
public void set_Git_Pull_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Git_Push_Url();
    [CompilerGeneratedAttribute]
public void set_Git_Push_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Forks_Url();
    [CompilerGeneratedAttribute]
public void set_Forks_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Commits_Url();
    [CompilerGeneratedAttribute]
public void set_Commits_Url(string value);
    [CompilerGeneratedAttribute]
public int get_Comments();
    [CompilerGeneratedAttribute]
public void set_Comments(int value);
    [CompilerGeneratedAttribute]
public string get_Comments_Url();
    [CompilerGeneratedAttribute]
public void set_Comments_Url(string value);
    [CompilerGeneratedAttribute]
public bool get_Truncated();
    [CompilerGeneratedAttribute]
public void set_Truncated(bool value);
    [CompilerGeneratedAttribute]
public GithubUser get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(GithubUser value);
    [CompilerGeneratedAttribute]
public GistHistory[] get_History();
    [CompilerGeneratedAttribute]
public void set_History(GistHistory[] value);
}
public class ServiceStack.GithubRateLimit : object {
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Remaining>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Reset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Used>k__BackingField;
    public int Limit { get; public set; }
    public int Remaining { get; public set; }
    public long Reset { get; public set; }
    public int Used { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public int get_Remaining();
    [CompilerGeneratedAttribute]
public void set_Remaining(int value);
    [CompilerGeneratedAttribute]
public long get_Reset();
    [CompilerGeneratedAttribute]
public void set_Reset(long value);
    [CompilerGeneratedAttribute]
public int get_Used();
    [CompilerGeneratedAttribute]
public void set_Used(int value);
}
public class ServiceStack.GithubRateLimits : object {
    [CompilerGeneratedAttribute]
private GithubResourcesRateLimits <Resources>k__BackingField;
    public GithubResourcesRateLimits Resources { get; public set; }
    [CompilerGeneratedAttribute]
public GithubResourcesRateLimits get_Resources();
    [CompilerGeneratedAttribute]
public void set_Resources(GithubResourcesRateLimits value);
}
public class ServiceStack.GithubRepo : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Homepage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Watchers_Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Stargazers_Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Full_Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created_At>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Updated_At>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Has_Downloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Html_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Private>k__BackingField;
    [CompilerGeneratedAttribute]
private GithubRepo <Parent>k__BackingField;
    public int Id { get; public set; }
    public string Name { get; public set; }
    public string Description { get; public set; }
    public string Homepage { get; public set; }
    public int Watchers_Count { get; public set; }
    public int Stargazers_Count { get; public set; }
    public int Size { get; public set; }
    public string Full_Name { get; public set; }
    public DateTime Created_At { get; public set; }
    public Nullable`1<DateTime> Updated_At { get; public set; }
    public bool Has_Downloads { get; public set; }
    public bool Fork { get; public set; }
    public string Url { get; public set; }
    public string Html_Url { get; public set; }
    public bool Private { get; public set; }
    public GithubRepo Parent { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Homepage();
    [CompilerGeneratedAttribute]
public void set_Homepage(string value);
    [CompilerGeneratedAttribute]
public int get_Watchers_Count();
    [CompilerGeneratedAttribute]
public void set_Watchers_Count(int value);
    [CompilerGeneratedAttribute]
public int get_Stargazers_Count();
    [CompilerGeneratedAttribute]
public void set_Stargazers_Count(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public string get_Full_Name();
    [CompilerGeneratedAttribute]
public void set_Full_Name(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Created_At();
    [CompilerGeneratedAttribute]
public void set_Created_At(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Updated_At();
    [CompilerGeneratedAttribute]
public void set_Updated_At(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Has_Downloads();
    [CompilerGeneratedAttribute]
public void set_Has_Downloads(bool value);
    [CompilerGeneratedAttribute]
public bool get_Fork();
    [CompilerGeneratedAttribute]
public void set_Fork(bool value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Html_Url();
    [CompilerGeneratedAttribute]
public void set_Html_Url(string value);
    [CompilerGeneratedAttribute]
public bool get_Private();
    [CompilerGeneratedAttribute]
public void set_Private(bool value);
    [CompilerGeneratedAttribute]
public GithubRepo get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(GithubRepo value);
}
public class ServiceStack.GithubResourcesRateLimits : object {
    [CompilerGeneratedAttribute]
private GithubRateLimit <Core>k__BackingField;
    [CompilerGeneratedAttribute]
private GithubRateLimit <Graphql>k__BackingField;
    [CompilerGeneratedAttribute]
private GithubRateLimit <Integration_Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private GithubRateLimit <Search>k__BackingField;
    public GithubRateLimit Core { get; public set; }
    public GithubRateLimit Graphql { get; public set; }
    public GithubRateLimit Integration_Manifest { get; public set; }
    public GithubRateLimit Search { get; public set; }
    [CompilerGeneratedAttribute]
public GithubRateLimit get_Core();
    [CompilerGeneratedAttribute]
public void set_Core(GithubRateLimit value);
    [CompilerGeneratedAttribute]
public GithubRateLimit get_Graphql();
    [CompilerGeneratedAttribute]
public void set_Graphql(GithubRateLimit value);
    [CompilerGeneratedAttribute]
public GithubRateLimit get_Integration_Manifest();
    [CompilerGeneratedAttribute]
public void set_Integration_Manifest(GithubRateLimit value);
    [CompilerGeneratedAttribute]
public GithubRateLimit get_Search();
    [CompilerGeneratedAttribute]
public void set_Search(GithubRateLimit value);
}
public class ServiceStack.GithubUser : GistUser {
    [CompilerGeneratedAttribute]
private string <Node_Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Followers_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Following_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Starred_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subscriptions_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Organizations_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Repos_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Events_Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Received_Events_Url>k__BackingField;
    public string Node_Id { get; public set; }
    public string Followers_Url { get; public set; }
    public string Following_Url { get; public set; }
    public string Starred_Url { get; public set; }
    public string Subscriptions_Url { get; public set; }
    public string Organizations_Url { get; public set; }
    public string Repos_Url { get; public set; }
    public string Events_Url { get; public set; }
    public string Received_Events_Url { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Node_Id();
    [CompilerGeneratedAttribute]
public void set_Node_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Followers_Url();
    [CompilerGeneratedAttribute]
public void set_Followers_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Following_Url();
    [CompilerGeneratedAttribute]
public void set_Following_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Starred_Url();
    [CompilerGeneratedAttribute]
public void set_Starred_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Subscriptions_Url();
    [CompilerGeneratedAttribute]
public void set_Subscriptions_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Organizations_Url();
    [CompilerGeneratedAttribute]
public void set_Organizations_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Repos_Url();
    [CompilerGeneratedAttribute]
public void set_Repos_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Events_Url();
    [CompilerGeneratedAttribute]
public void set_Events_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Received_Events_Url();
    [CompilerGeneratedAttribute]
public void set_Received_Events_Url(string value);
}
internal static class ServiceStack.HasId`1 : object {
    private static Func`2<TEntity, object> GetIdFn;
    private static HasId`1();
    public static object GetId(TEntity entity);
}
internal class ServiceStack.HasIdGetter`2 : object {
    public static object GetId(TEntity entity);
}
internal static class ServiceStack.HasPropertyId`1 : object {
    private static GetMemberDelegate`1<TEntity> GetIdFn;
    private static HasPropertyId`1();
    public static object GetId(TEntity entity);
}
public class ServiceStack.HtmlDumpOptions : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildClass>k__BackingField;
    [CompilerGeneratedAttribute]
private TextStyle <HeaderStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Caption>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CaptionIfEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultScripts <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Display>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChildDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCaption>k__BackingField;
    public string Id { get; public set; }
    public string ClassName { get; public set; }
    public string ChildClass { get; public set; }
    public TextStyle HeaderStyle { get; public set; }
    public string HeaderTag { get; public set; }
    public string Caption { get; public set; }
    public string CaptionIfEmpty { get; public set; }
    public String[] Headers { get; public set; }
    public DefaultScripts Defaults { get; public set; }
    public string Display { get; public set; }
    internal int Depth { get; internal set; }
    internal int ChildDepth { get; internal set; }
    internal bool HasCaption { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_ChildClass();
    [CompilerGeneratedAttribute]
public void set_ChildClass(string value);
    [CompilerGeneratedAttribute]
public TextStyle get_HeaderStyle();
    [CompilerGeneratedAttribute]
public void set_HeaderStyle(TextStyle value);
    [CompilerGeneratedAttribute]
public string get_HeaderTag();
    [CompilerGeneratedAttribute]
public void set_HeaderTag(string value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public string get_CaptionIfEmpty();
    [CompilerGeneratedAttribute]
public void set_CaptionIfEmpty(string value);
    [CompilerGeneratedAttribute]
public String[] get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(String[] value);
    [CompilerGeneratedAttribute]
public DefaultScripts get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(DefaultScripts value);
    [CompilerGeneratedAttribute]
public string get_Display();
    [CompilerGeneratedAttribute]
public void set_Display(string value);
    [CompilerGeneratedAttribute]
internal int get_Depth();
    [CompilerGeneratedAttribute]
internal void set_Depth(int value);
    [CompilerGeneratedAttribute]
internal int get_ChildDepth();
    [CompilerGeneratedAttribute]
internal void set_ChildDepth(int value);
    [CompilerGeneratedAttribute]
internal bool get_HasCaption();
    [CompilerGeneratedAttribute]
internal void set_HasCaption(bool value);
    public static HtmlDumpOptions Parse(Dictionary`2<string, object> options, DefaultScripts defaults);
}
[NullableContextAttribute("2")]
public interface ServiceStack.IAppTask {
    public string Log { get; public set; }
    public Nullable`1<DateTime> StartedAt { get; public set; }
    public Nullable`1<DateTime> CompletedDate { get; public set; }
    public Exception Error { get; public set; }
    public abstract virtual string get_Log();
    public abstract virtual void set_Log(string value);
    public abstract virtual Nullable`1<DateTime> get_StartedAt();
    public abstract virtual void set_StartedAt(Nullable`1<DateTime> value);
    public abstract virtual Nullable`1<DateTime> get_CompletedDate();
    public abstract virtual void set_CompletedDate(Nullable`1<DateTime> value);
    public abstract virtual Exception get_Error();
    public abstract virtual void set_Error(Exception value);
}
[ExtensionAttribute]
public static class ServiceStack.IdUtils : object {
    public static string IdField;
    [ExtensionAttribute]
public static object GetObjectId(object entity);
    [ExtensionAttribute]
public static object ToId(T entity);
    [ExtensionAttribute]
public static string ToUrn(T entity);
    [ExtensionAttribute]
public static string ToSafePathCacheKey(string idValue);
    [ExtensionAttribute]
public static string ToUrn(object id);
    [ExtensionAttribute]
public static object GetId(T entity);
    public static string CreateUrn(object id);
    public static string CreateUrn(Type type, object id);
    public static string CreateUrn(string type, object id);
    [ExtensionAttribute]
public static string CreateUrn(T entity);
    public static string CreateCacheKeyPath(string idValue);
    [ExtensionAttribute]
public static PropertyInfo GetIdProperty(Type type);
}
public static class ServiceStack.IdUtils`1 : object {
    internal static GetMemberDelegate`1<T> CanGetId;
    private static IdUtils`1();
    public static object GetId(T entity);
}
public interface ServiceStack.IGistGateway {
    public abstract virtual Gist CreateGist(string description, bool isPublic, Dictionary`2<string, object> files);
    public abstract virtual Gist CreateGist(string description, bool isPublic, Dictionary`2<string, string> textFiles);
    public abstract virtual Gist GetGist(string gistId);
    public abstract virtual Gist GetGist(string gistId, string version);
    public abstract virtual Task`1<Gist> GetGistAsync(string gistId);
    public abstract virtual Task`1<Gist> GetGistAsync(string gistId, string version);
    public abstract virtual void WriteGistFiles(string gistId, Dictionary`2<string, object> files, string description, bool deleteMissing);
    public abstract virtual void WriteGistFiles(string gistId, Dictionary`2<string, string> textFiles, string description, bool deleteMissing);
    public abstract virtual void CreateGistFile(string gistId, string filePath, string contents);
    public abstract virtual void WriteGistFile(string gistId, string filePath, string contents);
    public abstract virtual void DeleteGistFiles(string gistId, String[] filePaths);
}
public interface ServiceStack.IGitHubGateway {
    public abstract virtual Tuple`2<string, string> FindRepo(String[] orgs, string name, bool useFork);
    public abstract virtual string GetSourceZipUrl(string user, string repo);
    public abstract virtual Task`1<string> GetSourceZipUrlAsync(string user, string repo);
    public abstract virtual Task`1<List`1<GithubRepo>> GetSourceReposAsync(string orgName);
    public abstract virtual Task`1<List`1<GithubRepo>> GetUserAndOrgReposAsync(string githubOrgOrUser);
    public abstract virtual GithubRepo GetRepo(string userOrOrg, string repo);
    public abstract virtual Task`1<GithubRepo> GetRepoAsync(string userOrOrg, string repo);
    public abstract virtual List`1<GithubRepo> GetUserRepos(string githubUser);
    public abstract virtual Task`1<List`1<GithubRepo>> GetUserReposAsync(string githubUser);
    public abstract virtual List`1<GithubRepo> GetOrgRepos(string githubOrg);
    public abstract virtual Task`1<List`1<GithubRepo>> GetOrgReposAsync(string githubOrg);
    public abstract virtual string GetJson(string route);
    public abstract virtual T GetJson(string route);
    public abstract virtual Task`1<string> GetJsonAsync(string route);
    public abstract virtual Task`1<T> GetJsonAsync(string route);
    public abstract virtual IEnumerable`1<T> StreamJsonCollection(string route);
    public abstract virtual Task`1<List`1<T>> GetJsonCollectionAsync(string route);
    public abstract virtual void DownloadFile(string downloadUrl, string fileName);
}
public class ServiceStack.InputOptions : object {
    [CompilerGeneratedAttribute]
private bool <Inline>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LabelClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowErrors>k__BackingField;
    public bool Inline { get; public set; }
    public string Label { get; public set; }
    public string LabelClass { get; public set; }
    public string ErrorClass { get; public set; }
    public string Help { get; public set; }
    public string Size { get; public set; }
    public object Values { get; public set; }
    unknown IEnumerable`1<KeyValuePair`2<string, string>> InputValues {public set; }
    public bool PreserveValue { get; public set; }
    public bool ShowErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Inline();
    [CompilerGeneratedAttribute]
public void set_Inline(bool value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public string get_LabelClass();
    [CompilerGeneratedAttribute]
public void set_LabelClass(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorClass();
    [CompilerGeneratedAttribute]
public void set_ErrorClass(string value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
public void set_Help(string value);
    [CompilerGeneratedAttribute]
public string get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(string value);
    [CompilerGeneratedAttribute]
public object get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(object value);
    public void set_InputValues(IEnumerable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
public bool get_PreserveValue();
    [CompilerGeneratedAttribute]
public void set_PreserveValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowErrors();
    [CompilerGeneratedAttribute]
public void set_ShowErrors(bool value);
}
[ExtensionAttribute]
public static class ServiceStack.Inspect : object {
    public static void vars(object anonArgs);
    public static string dump(T instance);
    private static object UseType(T instance);
    public static void printDump(T instance);
    public static string dumpTable(object instance);
    public static string dumpTable(object instance, TextDumpOptions options);
    public static string dumpTable(object instance, String[] headers);
    public static void printDumpTable(object instance);
    public static void printDumpTable(object instance, String[] headers);
    public static string htmlDump(object target);
    public static string htmlDump(object target, HtmlDumpOptions options);
    public static string htmlDump(object target, String[] headers);
    public static void printHtmlDump(object instance);
    public static void printHtmlDump(object instance, String[] headers);
    private static string dumpInternal(object instance);
    [ExtensionAttribute]
private static StringBuilder AppendOneNewLine(StringBuilder sb);
}
public class ServiceStack.InstanceMapper : MulticastDelegate {
    public InstanceMapper(object object, IntPtr method);
    public virtual object Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.IntExtensions : object {
    [IteratorStateMachineAttribute("ServiceStack.IntExtensions/<Times>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<int> Times(int times);
    [ExtensionAttribute]
public static void Times(int times, Action`1<int> actionFn);
    [ExtensionAttribute]
public static void Times(int times, Action actionFn);
    [ExtensionAttribute]
public static List`1<T> Times(int times, Func`1<T> actionFn);
    [ExtensionAttribute]
public static List`1<T> Times(int times, Func`2<int, T> actionFn);
    [AsyncStateMachineAttribute("ServiceStack.IntExtensions/<TimesAsync>d__5")]
[ExtensionAttribute]
public static Task TimesAsync(int times, Func`2<int, Task> actionFn, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IntExtensions/<TimesAsync>d__6`1")]
[ExtensionAttribute]
public static Task`1<List`1<T>> TimesAsync(int times, Func`2<int, Task`1<T>> actionFn, CancellationToken token);
    [ExtensionAttribute]
public static List`1<IAsyncResult> TimesAsync(int times, Action`1<int> actionFn);
    [ExtensionAttribute]
public static List`1<IAsyncResult> TimesAsync(int times, Action actionFn);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ServiceStack.IO.FileContents : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public Stream Stream { get; }
    public string Text { get; }
    public FileContents(Stream stream);
    public FileContents(string text);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public string get_Text();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("ServiceStack.IO.FileContents/<GetAsync>d__8")]
public static Task`1<FileContents> GetAsync(object contents, bool buffer);
}
public class ServiceStack.IO.FileSystemVirtualFiles : AbstractVirtualPathProviderBase {
    [CompilerGeneratedAttribute]
private DirectoryInfo <RootDirInfo>k__BackingField;
    protected FileSystemVirtualDirectory RootDir;
    public DirectoryInfo RootDirInfo { get; protected set; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public FileSystemVirtualFiles(string rootDirectoryPath);
    public FileSystemVirtualFiles(DirectoryInfo rootDirInfo);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_RootDirInfo();
    [CompilerGeneratedAttribute]
protected void set_RootDirInfo(DirectoryInfo value);
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    protected sealed virtual void Initialize();
    public virtual bool DirectoryExists(string virtualPath);
    public virtual bool FileExists(string virtualPath);
    public string EnsureDirectory(string dirPath);
    public sealed virtual void WriteFile(string filePath, string textContents);
    public sealed virtual void WriteFile(string filePath, Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.IO.FileSystemVirtualFiles/<WriteFileAsync>d__19")]
public virtual Task WriteFileAsync(string filePath, object contents, CancellationToken token);
    public sealed virtual void WriteFiles(IEnumerable`1<IVirtualFile> files, Func`2<IVirtualFile, string> toPath);
    public sealed virtual void AppendFile(string filePath, string textContents);
    public sealed virtual void AppendFile(string filePath, Stream stream);
    public sealed virtual void DeleteFile(string filePath);
    public sealed virtual void DeleteFiles(IEnumerable`1<string> filePaths);
    public sealed virtual void DeleteFolder(string dirPath);
    public static void DeleteDirectory(string path);
    public static void CopyAll(DirectoryInfo source, DirectoryInfo target);
    public static string AssertDirectory(string dirPath, int timeoutMs);
    public static void RecreateDirectory(string dirPath, int timeoutMs);
}
public class ServiceStack.IO.GistVirtualDirectory : AbstractVirtualDirectoryBase {
    [CompilerGeneratedAttribute]
private GistVirtualFiles <PathProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DirLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirPath>k__BackingField;
    internal GistVirtualFiles PathProvider { get; private set; }
    public DateTime DirLastModified { get; public set; }
    public DateTime LastModified { get; }
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public IGistGateway Gateway { get; }
    public string GistId { get; }
    public string DirPath { get; public set; }
    public string VirtualPath { get; }
    public string Name { get; }
    public GistVirtualDirectory(GistVirtualFiles pathProvider, string dirPath, GistVirtualDirectory parentDir);
    [CompilerGeneratedAttribute]
internal GistVirtualFiles get_PathProvider();
    [CompilerGeneratedAttribute]
private void set_PathProvider(GistVirtualFiles value);
    [CompilerGeneratedAttribute]
public DateTime get_DirLastModified();
    [CompilerGeneratedAttribute]
public void set_DirLastModified(DateTime value);
    public virtual DateTime get_LastModified();
    public virtual IEnumerable`1<IVirtualFile> get_Files();
    public virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    public IGistGateway get_Gateway();
    public string get_GistId();
    [CompilerGeneratedAttribute]
public string get_DirPath();
    [CompilerGeneratedAttribute]
public void set_DirPath(string value);
    public virtual string get_VirtualPath();
    public virtual string get_Name();
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    protected virtual IVirtualFile GetFileFromBackingDirectoryOrDefault(string fileName);
    protected virtual IEnumerable`1<IVirtualFile> GetMatchingFilesInDir(string globPattern);
    [IteratorStateMachineAttribute("ServiceStack.IO.GistVirtualDirectory/<EnumerateFiles>d__31")]
public IEnumerable`1<GistVirtualFile> EnumerateFiles(string pattern);
    protected virtual IVirtualDirectory GetDirectoryFromBackingDirectoryOrDefault(string directoryName);
    public void AddFile(string virtualPath, string contents);
    public void AddFile(string virtualPath, Stream stream);
    private static string StripDirSeparatorPrefix(string filePath);
    public virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
}
public class ServiceStack.IO.GistVirtualFile : AbstractVirtualFileBase {
    [CompilerGeneratedAttribute]
private GistVirtualFiles <PathProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FileLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    private GistVirtualFiles PathProvider { get; private set; }
    public IGistGateway Client { get; }
    public string GistId { get; }
    public string Extension { get; }
    public string DirPath { get; }
    public string FilePath { get; public set; }
    public string ContentType { get; public set; }
    public string Name { get; }
    public string VirtualPath { get; }
    public DateTime FileLastModified { get; public set; }
    public DateTime LastModified { get; }
    public long Length { get; }
    public long ContentLength { get; public set; }
    public string Text { get; public set; }
    public Stream Stream { get; public set; }
    public GistVirtualFile(GistVirtualFiles pathProvider, IVirtualDirectory directory);
    [CompilerGeneratedAttribute]
private GistVirtualFiles get_PathProvider();
    [CompilerGeneratedAttribute]
private void set_PathProvider(GistVirtualFiles value);
    public IGistGateway get_Client();
    public string get_GistId();
    public virtual string get_Extension();
    public string get_DirPath();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    public virtual string get_Name();
    public virtual string get_VirtualPath();
    [CompilerGeneratedAttribute]
public DateTime get_FileLastModified();
    [CompilerGeneratedAttribute]
public void set_FileLastModified(DateTime value);
    public virtual DateTime get_LastModified();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public long get_ContentLength();
    [CompilerGeneratedAttribute]
public void set_ContentLength(long value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
    public GistVirtualFile Init(string filePath, DateTime lastModified, string text, MemoryStream stream);
    public virtual Stream OpenRead();
    public virtual object GetContents();
    public virtual Byte[] ReadAllBytes();
    public virtual void Refresh();
}
public class ServiceStack.IO.GistVirtualFiles : AbstractVirtualPathProviderBase {
    [CompilerGeneratedAttribute]
private IGistGateway <Gateway>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GistId>k__BackingField;
    private GistVirtualDirectory rootDirectory;
    [CompilerGeneratedAttribute]
private DateTime <LastRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RefreshAfter>k__BackingField;
    public static char DirSep;
    public static string Base64Modifier;
    private Gist gistCache;
    public IGistGateway Gateway { get; }
    public string GistId { get; private set; }
    public DateTime LastRefresh { get; private set; }
    public TimeSpan RefreshAfter { get; public set; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public GistVirtualFiles(string gistId);
    public GistVirtualFiles(string gistId, string accessToken);
    public GistVirtualFiles(string gistId, IGistGateway gateway);
    public GistVirtualFiles(Gist gist);
    public GistVirtualFiles(Gist gist, string accessToken);
    public GistVirtualFiles(Gist gist, IGistGateway gateway);
    [CompilerGeneratedAttribute]
public IGistGateway get_Gateway();
    [CompilerGeneratedAttribute]
public string get_GistId();
    [CompilerGeneratedAttribute]
private void set_GistId(string value);
    private void InitGist(Gist gist);
    [CompilerGeneratedAttribute]
public DateTime get_LastRefresh();
    [CompilerGeneratedAttribute]
private void set_LastRefresh(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RefreshAfter();
    [CompilerGeneratedAttribute]
public void set_RefreshAfter(TimeSpan value);
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    protected virtual void Initialize();
    public static bool IsDirSep(char c);
    private static Byte[] FromBase64String(string path, string base64String);
    public static bool GetGistTextContents(string filePath, Gist gist, String& text);
    public static bool GetGistContents(string filePath, Gist gist, String& text, MemoryStream& stream);
    public Gist GetGist(bool refresh);
    [AsyncStateMachineAttribute("ServiceStack.IO.GistVirtualFiles/<GetGistAsync>d__38")]
public Task`1<Gist> GetGistAsync(bool refresh);
    [AsyncStateMachineAttribute("ServiceStack.IO.GistVirtualFiles/<LoadAllTruncatedFilesAsync>d__39")]
public Task LoadAllTruncatedFilesAsync();
    public void ClearGist();
    public virtual IVirtualFile GetFile(string virtualPath);
    private GistVirtualDirectory GetParentDirectory(string dirPath);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public virtual bool DirectoryExists(string virtualPath);
    public virtual bool FileExists(string virtualPath);
    public virtual void WriteFiles(Dictionary`2<string, string> textFiles);
    public virtual void WriteFiles(Dictionary`2<string, object> files);
    public sealed virtual void WriteFile(string virtualPath, string contents);
    public sealed virtual void WriteFile(string virtualPath, Stream stream);
    public static string ToBase64(Stream stream);
    public static string ToBase64(Byte[] bytes);
    public sealed virtual void WriteFiles(IEnumerable`1<IVirtualFile> files, Func`2<IVirtualFile, string> toPath);
    public sealed virtual void AppendFile(string filePath, string textContents);
    public sealed virtual void AppendFile(string filePath, Stream stream);
    public string ResolveGistFileName(string filePath);
    public sealed virtual void DeleteFile(string filePath);
    public sealed virtual void DeleteFiles(IEnumerable`1<string> virtualFilePaths);
    public sealed virtual void DeleteFolder(string dirPath);
    [IteratorStateMachineAttribute("ServiceStack.IO.GistVirtualFiles/<EnumerateFiles>d__59")]
public IEnumerable`1<GistVirtualFile> EnumerateFiles(string prefix);
    public virtual IEnumerable`1<IVirtualFile> GetAllFiles();
    public IEnumerable`1<GistVirtualDirectory> GetImmediateDirectories(string fromDirPath);
    public IEnumerable`1<GistVirtualFile> GetImmediateFiles(string fromDirPath);
    public string GetDirPath(string filePath);
    public string GetImmediateSubDirPath(string fromDirPath, string subDirPath);
    public virtual string SanitizePath(string filePath);
    public static string GetFileName(string filePath);
    [CompilerGeneratedAttribute]
private string <DeleteFiles>b__57_0(string x);
}
public class ServiceStack.IO.InMemoryVirtualDirectory : AbstractVirtualDirectoryBase {
    private MemoryVirtualFiles pathProvider;
    [CompilerGeneratedAttribute]
private DateTime <DirLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirPath>k__BackingField;
    public DateTime DirLastModified { get; public set; }
    public DateTime LastModified { get; }
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public string DirPath { get; public set; }
    public string VirtualPath { get; }
    public string Name { get; }
    public InMemoryVirtualDirectory(MemoryVirtualFiles pathProvider, string dirPath, IVirtualDirectory parentDir);
    [CompilerGeneratedAttribute]
public DateTime get_DirLastModified();
    [CompilerGeneratedAttribute]
public void set_DirLastModified(DateTime value);
    public virtual DateTime get_LastModified();
    public virtual IEnumerable`1<IVirtualFile> get_Files();
    public virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    [CompilerGeneratedAttribute]
public string get_DirPath();
    [CompilerGeneratedAttribute]
public void set_DirPath(string value);
    public virtual string get_VirtualPath();
    public virtual string get_Name();
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    protected virtual IVirtualFile GetFileFromBackingDirectoryOrDefault(string fileName);
    protected virtual IEnumerable`1<IVirtualFile> GetMatchingFilesInDir(string globPattern);
    [IteratorStateMachineAttribute("ServiceStack.IO.InMemoryVirtualDirectory/<EnumerateFiles>d__24")]
public IEnumerable`1<InMemoryVirtualFile> EnumerateFiles(string pattern);
    protected virtual IVirtualDirectory GetDirectoryFromBackingDirectoryOrDefault(string directoryName);
    public void AddFile(string filePath, string contents);
    public void AddFile(string filePath, Stream stream);
    public bool HasFiles();
    public virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
    [CompilerGeneratedAttribute]
private bool <HasFiles>b__28_0(InMemoryVirtualFile x);
}
public class ServiceStack.IO.InMemoryVirtualFile : AbstractVirtualFileBase {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FileLastModified>k__BackingField;
    private string textContents;
    [CompilerGeneratedAttribute]
private Byte[] <ByteContents>k__BackingField;
    public string DirPath { get; }
    public string FilePath { get; public set; }
    public string Name { get; }
    public string VirtualPath { get; }
    public DateTime FileLastModified { get; public set; }
    public DateTime LastModified { get; }
    public long Length { get; }
    public string TextContents { get; public set; }
    public Byte[] ByteContents { get; public set; }
    public InMemoryVirtualFile(IVirtualPathProvider owningProvider, IVirtualDirectory directory);
    public string get_DirPath();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public virtual string get_Name();
    public virtual string get_VirtualPath();
    [CompilerGeneratedAttribute]
public DateTime get_FileLastModified();
    [CompilerGeneratedAttribute]
public void set_FileLastModified(DateTime value);
    public virtual DateTime get_LastModified();
    public virtual long get_Length();
    public string get_TextContents();
    public void set_TextContents(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_ByteContents();
    [CompilerGeneratedAttribute]
public void set_ByteContents(Byte[] value);
    public void SetContents(string text, Byte[] bytes);
    public virtual Stream OpenRead();
    public virtual object GetContents();
    public virtual Byte[] ReadAllBytes();
    public virtual void Refresh();
}
public class ServiceStack.IO.MemoryVirtualFiles : AbstractVirtualPathProviderBase {
    public static char DirSep;
    private List`1<InMemoryVirtualFile> files;
    private InMemoryVirtualDirectory rootDirectory;
    public List`1<InMemoryVirtualFile> Files { get; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public List`1<InMemoryVirtualFile> get_Files();
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    protected virtual void Initialize();
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public IVirtualDirectory GetDirectory(string virtualPath, bool forceDir);
    public IVirtualDirectory GetParentDirectory(string dirPath);
    public virtual bool DirectoryExists(string virtualPath);
    private IVirtualDirectory CreateDirectory(string dirPath);
    public sealed virtual void WriteFile(string filePath, string textContents);
    public sealed virtual void WriteFile(string filePath, Stream stream);
    public sealed virtual void WriteFiles(IEnumerable`1<IVirtualFile> files, Func`2<IVirtualFile, string> toPath);
    public sealed virtual void AppendFile(string filePath, string textContents);
    public sealed virtual void AppendFile(string filePath, Stream stream);
    public void AddFile(InMemoryVirtualFile file);
    public sealed virtual void DeleteFile(string filePath);
    public sealed virtual void DeleteFiles(IEnumerable`1<string> filePaths);
    public sealed virtual void DeleteFolder(string dirPath);
    public IEnumerable`1<InMemoryVirtualDirectory> GetImmediateDirectories(string fromDirPath);
    public IEnumerable`1<InMemoryVirtualFile> GetImmediateFiles(string fromDirPath);
    public virtual IEnumerable`1<IVirtualFile> GetAllFiles();
    public string GetDirPath(string filePath);
    public string GetImmediateSubDirPath(string fromDirPath, string subDirPath);
    public void Clear();
}
public class ServiceStack.IO.MultiVirtualDirectory : object {
    private IVirtualDirectory[] dirs;
    public IVirtualDirectory Directory { get; }
    public string Name { get; }
    public string VirtualPath { get; }
    public string RealPath { get; }
    public bool IsDirectory { get; }
    public DateTime LastModified { get; }
    public bool IsRoot { get; }
    public IVirtualDirectory ParentDirectory { get; }
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public MultiVirtualDirectory(IVirtualDirectory[] dirs);
    public static IVirtualDirectory ToVirtualDirectory(IEnumerable`1<IVirtualDirectory> dirs);
    public sealed virtual IVirtualDirectory get_Directory();
    public sealed virtual string get_Name();
    public sealed virtual string get_VirtualPath();
    public sealed virtual string get_RealPath();
    public sealed virtual bool get_IsDirectory();
    public sealed virtual DateTime get_LastModified();
    public sealed virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsRoot();
    public sealed virtual IVirtualDirectory get_ParentDirectory();
    public sealed virtual IEnumerable`1<IVirtualFile> get_Files();
    public sealed virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    public sealed virtual IVirtualFile GetFile(string virtualPath);
    public sealed virtual IVirtualFile GetFile(Stack`1<string> virtualPath);
    public sealed virtual IVirtualDirectory GetDirectory(string virtualPath);
    public sealed virtual IVirtualDirectory GetDirectory(Stack`1<string> virtualPath);
    [IteratorStateMachineAttribute("ServiceStack.IO.MultiVirtualDirectory/<GetAllMatchingFiles>d__29")]
public sealed virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
}
public class ServiceStack.IO.MultiVirtualFiles : AbstractVirtualPathProviderBase {
    [CompilerGeneratedAttribute]
private List`1<IVirtualPathProvider> <ChildProviders>k__BackingField;
    public List`1<IVirtualPathProvider> ChildProviders { get; public set; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public IEnumerable`1<IVirtualPathProvider> ChildVirtualFiles { get; }
    public MultiVirtualFiles(IVirtualPathProvider[] childProviders);
    [CompilerGeneratedAttribute]
public List`1<IVirtualPathProvider> get_ChildProviders();
    [CompilerGeneratedAttribute]
public void set_ChildProviders(List`1<IVirtualPathProvider> value);
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    protected sealed virtual void Initialize();
    public virtual string CombineVirtualPath(string basePath, string relativePath);
    public virtual bool DirectoryExists(string virtualPath);
    public virtual bool FileExists(string virtualPath);
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
    public virtual IEnumerable`1<IVirtualFile> GetAllFiles();
    public virtual IEnumerable`1<IVirtualFile> GetRootFiles();
    public virtual IEnumerable`1<IVirtualDirectory> GetRootDirectories();
    public virtual bool IsSharedFile(IVirtualFile virtualFile);
    public virtual bool IsViewFile(IVirtualFile virtualFile);
    public virtual string ToString();
    public IEnumerable`1<IVirtualPathProvider> get_ChildVirtualFiles();
    public sealed virtual void WriteFile(string filePath, string textContents);
    public sealed virtual void WriteFile(string filePath, Stream stream);
    public sealed virtual void WriteFiles(IEnumerable`1<IVirtualFile> files, Func`2<IVirtualFile, string> toPath);
    public sealed virtual void AppendFile(string filePath, string textContents);
    public sealed virtual void AppendFile(string filePath, Stream stream);
    public sealed virtual void DeleteFile(string filePath);
    public sealed virtual void DeleteFiles(IEnumerable`1<string> filePaths);
    public sealed virtual void DeleteFolder(string dirPath);
}
public class ServiceStack.IO.ResourceVirtualFiles : AbstractVirtualPathProviderBase {
    protected ResourceVirtualDirectory RootDir;
    [CompilerGeneratedAttribute]
private Assembly <BackingAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    private static Char[] NamespaceSpecialChars;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <PartialFileNames>k__BackingField;
    public Assembly BackingAssembly { get; }
    public string RootNamespace { get; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public DateTime LastModified { get; public set; }
    public static HashSet`1<string> PartialFileNames { get; public set; }
    public ResourceVirtualFiles(Type baseTypeInAssembly);
    public ResourceVirtualFiles(Assembly backingAssembly, string rootNamespace);
    private static ResourceVirtualFiles();
    [CompilerGeneratedAttribute]
public Assembly get_BackingAssembly();
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
    private static DateTime GetAssemblyLastModified(Assembly asm);
    private static string CleanChars(string name);
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_PartialFileNames();
    [CompilerGeneratedAttribute]
public static void set_PartialFileNames(HashSet`1<string> value);
    public string CleanPath(string filePath);
    public virtual IVirtualFile GetFile(string virtualPath);
    private static string GetNamespace(Type type);
    protected sealed virtual void Initialize();
    public virtual string CombineVirtualPath(string basePath, string relativePath);
}
[ExtensionAttribute]
public static class ServiceStack.IO.VirtualDirectoryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IVirtualFile> GetFiles(IVirtualDirectory dir);
    [ExtensionAttribute]
public static IEnumerable`1<IVirtualDirectory> GetDirectories(IVirtualDirectory dir);
    [IteratorStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<GetAllFiles>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IVirtualFile> GetAllFiles(IVirtualDirectory dir);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__3")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, IVirtualFile file, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__4")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, string textContents, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__5")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, ReadOnlyMemory`1<char> textContents, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__6")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, Byte[] binaryContents, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__7")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, ReadOnlyMemory`1<byte> romBytes, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.IO.VirtualDirectoryExtensions/<WriteFileAsync>d__8")]
[ExtensionAttribute]
public static Task WriteFileAsync(IVirtualFiles vfs, string filePath, Stream stream, CancellationToken token);
}
[ExtensionAttribute]
public static class ServiceStack.IO.VirtualFilesExtensions : object {
    private static string ErrorNotWritable;
    [ExtensionAttribute]
public static bool IsFile(IVirtualPathProvider pathProvider, string filePath);
    [ExtensionAttribute]
public static bool IsDirectory(IVirtualPathProvider pathProvider, string filePath);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, string textContents);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, Stream stream);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, Byte[] bytes);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, ReadOnlyMemory`1<char> text);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, ReadOnlyMemory`1<byte> bytes);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, string filePath, object contents);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, string textContents);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, Stream stream);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, Byte[] bytes);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, object contents);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, ReadOnlyMemory`1<char> text);
    [ExtensionAttribute]
public static void AppendFile(IVirtualPathProvider pathProvider, string filePath, ReadOnlyMemory`1<byte> bytes);
    [ExtensionAttribute]
public static void WriteFile(IVirtualPathProvider pathProvider, IVirtualFile file, string filePath);
    [ExtensionAttribute]
public static void DeleteFile(IVirtualPathProvider pathProvider, string filePath);
    [ExtensionAttribute]
public static void DeleteFile(IVirtualPathProvider pathProvider, IVirtualFile file);
    [ExtensionAttribute]
public static void DeleteFiles(IVirtualPathProvider pathProvider, IEnumerable`1<string> filePaths);
    [ExtensionAttribute]
public static void DeleteFiles(IVirtualPathProvider pathProvider, IEnumerable`1<IVirtualFile> files);
    [ExtensionAttribute]
public static void DeleteFolder(IVirtualPathProvider pathProvider, string dirPath);
    [ExtensionAttribute]
public static void WriteFiles(IVirtualPathProvider pathProvider, Dictionary`2<string, string> textFiles);
    [ExtensionAttribute]
public static void WriteFiles(IVirtualPathProvider pathProvider, Dictionary`2<string, object> files);
    [ExtensionAttribute]
public static void WriteFiles(IVirtualPathProvider pathProvider, IEnumerable`1<IVirtualFile> srcFiles, Func`2<IVirtualFile, string> toPath);
    [ExtensionAttribute]
public static void CopyFrom(IVirtualPathProvider pathProvider, IEnumerable`1<IVirtualFile> srcFiles, Func`2<IVirtualFile, string> toPath);
}
[ExtensionAttribute]
public static class ServiceStack.IPAddressExtensions : object {
    [ExtensionAttribute]
public static IPAddress GetBroadcastAddress(IPAddress address, IPAddress subnetMask);
    [ExtensionAttribute]
public static IPAddress GetNetworkAddress(IPAddress address, IPAddress subnetMask);
    public static Byte[] GetNetworkAddressBytes(Byte[] ipAddressBytes, Byte[] subnetMaskBytes);
    [ExtensionAttribute]
public static bool IsInSameIpv6Subnet(IPAddress address2, IPAddress address);
    [ExtensionAttribute]
public static bool IsInSameIpv6Subnet(Byte[] address1Bytes, Byte[] address2Bytes);
    [ExtensionAttribute]
public static bool IsInSameIpv4Subnet(IPAddress address2, IPAddress address, IPAddress subnetMask);
    [ExtensionAttribute]
public static bool IsInSameIpv4Subnet(Byte[] address1Bytes, Byte[] address2Bytes, Byte[] subnetMaskBytes);
    public static Dictionary`2<IPAddress, IPAddress> GetAllNetworkInterfaceIpv4Addresses();
    public static List`1<IPAddress> GetAllNetworkInterfaceIpv6Addresses();
}
public static class ServiceStack.JS : object {
    public static string EvalCacheKeyPrefix;
    public static string EvalScriptCacheKeyPrefix;
    public static string EvalAstCacheKeyPrefix;
    public static void Configure();
    public static void UnConfigure();
    public static ScriptScopeContext CreateScope(Dictionary`2<string, object> args, ScriptMethods functions);
    public static JsToken expression(string js);
    public static JsToken expressionCached(ScriptContext context, string expr);
    public static SharpPage scriptCached(ScriptContext context, string evalCode);
    public static object eval(string js);
    public static object eval(string js, ScriptScopeContext scope);
    public static object eval(ReadOnlySpan`1<char> js, ScriptScopeContext scope);
    public static object eval(ScriptContext context, string expr, Dictionary`2<string, object> args);
    public static object eval(ScriptContext context, ReadOnlySpan`1<char> expr, Dictionary`2<string, object> args);
    public static object eval(ScriptContext context, JsToken token, Dictionary`2<string, object> args);
    public static object evalCached(ScriptContext context, string expr);
    public static Dictionary`2<string, object> ParseObject(string js);
}
public static class ServiceStack.JSON : object {
    public static object parse(string json);
    public static object parseSpan(ReadOnlySpan`1<char> json);
    public static string stringify(object value);
    [CompilerGeneratedAttribute]
internal static bool <parseSpan>g__isEscapedJsonString|1_0(ReadOnlySpan`1<char> js);
}
public class ServiceStack.Logging.ConsoleLogFactory : object {
    private bool debugEnabled;
    public ConsoleLogFactory(bool debugEnabled);
    public sealed virtual ILog GetLogger(Type type);
    public sealed virtual ILog GetLogger(string typeName);
    public static void Configure(bool debugEnabled);
}
public class ServiceStack.Logging.ConsoleLogger : object {
    private static string DEBUG;
    private static string ERROR;
    private static string FATAL;
    private static string WARN;
    [CompilerGeneratedAttribute]
private bool <IsDebugEnabled>k__BackingField;
    public bool IsDebugEnabled { get; public set; }
    public ConsoleLogger(string type);
    public ConsoleLogger(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDebugEnabled();
    [CompilerGeneratedAttribute]
public void set_IsDebugEnabled(bool value);
    private static void Log(object message, Exception exception);
    private static void LogFormat(object message, Object[] args);
    private static void Log(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void Debug(object message);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void Error(object message);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void Fatal(object message);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void Info(object message);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void Warn(object message);
    public sealed virtual void WarnFormat(string format, Object[] args);
}
public class ServiceStack.Logging.DebugLogFactory : object {
    private bool debugEnabled;
    public DebugLogFactory(bool debugEnabled);
    public sealed virtual ILog GetLogger(Type type);
    public sealed virtual ILog GetLogger(string typeName);
}
public class ServiceStack.Logging.DebugLogger : object {
    private static string DEBUG;
    private static string ERROR;
    private static string FATAL;
    private static string INFO;
    private static string WARN;
    [CompilerGeneratedAttribute]
private bool <IsDebugEnabled>k__BackingField;
    public bool IsDebugEnabled { get; public set; }
    public DebugLogger(string type);
    public DebugLogger(Type type);
    private static void Log(object message, Exception exception);
    private static void LogFormat(object message, Object[] args);
    private static void Log(object message);
    public sealed virtual void Debug(object message, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDebugEnabled();
    [CompilerGeneratedAttribute]
public void set_IsDebugEnabled(bool value);
    public sealed virtual void Debug(object message);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void Error(object message);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void Fatal(object message);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void Info(object message);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void Warn(object message);
    public sealed virtual void WarnFormat(string format, Object[] args);
}
public class ServiceStack.MethodInvoker : MulticastDelegate {
    public MethodInvoker(object object, IntPtr method);
    public virtual object Invoke(object instance, Object[] args);
    public virtual IAsyncResult BeginInvoke(object instance, Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum ServiceStack.MiniProfiler.Data.ExecuteType : Enum {
    public byte value__;
    public static ExecuteType None;
    public static ExecuteType NonQuery;
    public static ExecuteType Scalar;
    public static ExecuteType Reader;
}
public interface ServiceStack.MiniProfiler.Data.IDbProfiler {
    public bool IsActive { get; }
    public abstract virtual void ExecuteStart(DbCommand profiledDbCommand, ExecuteType executeType);
    public abstract virtual void ExecuteFinish(DbCommand profiledDbCommand, ExecuteType executeType, DbDataReader reader);
    public abstract virtual void ReaderFinish(DbDataReader reader);
    public abstract virtual void OnError(DbCommand profiledDbCommand, ExecuteType executeType, Exception exception);
    public abstract virtual bool get_IsActive();
}
public class ServiceStack.MiniProfiler.Data.ProfiledCommand : DbCommand {
    private DbCommand _cmd;
    private DbConnection _conn;
    private DbTransaction _tran;
    private IDbProfiler _profiler;
    public string CommandText { get; public set; }
    public int CommandTimeout { get; public set; }
    public CommandType CommandType { get; public set; }
    public DbCommand DbCommand { get; protected set; }
    private IDbCommand ServiceStack.Data.IHasDbCommand.DbCommand { get; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbParameterCollection DbParameterCollection { get; }
    protected DbTransaction DbTransaction { get; protected set; }
    protected IDbProfiler DbProfiler { get; protected set; }
    public bool DesignTimeVisible { get; public set; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    public ProfiledCommand(DbCommand cmd, DbConnection conn, IDbProfiler profiler);
    public virtual string get_CommandText();
    public virtual void set_CommandText(string value);
    public virtual int get_CommandTimeout();
    public virtual void set_CommandTimeout(int value);
    public virtual CommandType get_CommandType();
    public virtual void set_CommandType(CommandType value);
    public DbCommand get_DbCommand();
    protected void set_DbCommand(DbCommand value);
    private sealed virtual override IDbCommand ServiceStack.Data.IHasDbCommand.get_DbCommand();
    protected virtual DbConnection get_DbConnection();
    protected virtual void set_DbConnection(DbConnection value);
    protected virtual DbParameterCollection get_DbParameterCollection();
    protected virtual DbTransaction get_DbTransaction();
    protected virtual void set_DbTransaction(DbTransaction value);
    protected IDbProfiler get_DbProfiler();
    protected void set_DbProfiler(IDbProfiler value);
    public virtual bool get_DesignTimeVisible();
    public virtual void set_DesignTimeVisible(bool value);
    public virtual UpdateRowSource get_UpdatedRowSource();
    public virtual void set_UpdatedRowSource(UpdateRowSource value);
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    public virtual int ExecuteNonQuery();
    public virtual object ExecuteScalar();
    public virtual void Cancel();
    public virtual void Prepare();
    protected virtual DbParameter CreateDbParameter();
    protected virtual void Dispose(bool disposing);
}
public class ServiceStack.MiniProfiler.Data.ProfiledConnection : DbConnection {
    private DbConnection _conn;
    private IDbProfiler _profiler;
    [CompilerGeneratedAttribute]
private bool <AutoDisposeConnection>k__BackingField;
    public DbConnection InnerConnection { get; protected set; }
    public IDbConnection DbConnection { get; }
    public IDbProfiler Profiler { get; protected set; }
    public DbConnection WrappedConnection { get; }
    protected bool CanRaiseEvents { get; }
    public string ConnectionString { get; public set; }
    public int ConnectionTimeout { get; }
    public string Database { get; }
    public string DataSource { get; }
    public string ServerVersion { get; }
    public ConnectionState State { get; }
    protected bool AutoDisposeConnection { get; protected set; }
    public ProfiledConnection(DbConnection connection, IDbProfiler profiler, bool autoDisposeConnection);
    public ProfiledConnection(IDbConnection connection, IDbProfiler profiler, bool autoDisposeConnection);
    private void Init(DbConnection connection, IDbProfiler profiler, bool autoDisposeConnection);
    public DbConnection get_InnerConnection();
    protected void set_InnerConnection(DbConnection value);
    public sealed virtual IDbConnection get_DbConnection();
    public IDbProfiler get_Profiler();
    protected void set_Profiler(IDbProfiler value);
    public DbConnection get_WrappedConnection();
    protected virtual bool get_CanRaiseEvents();
    public virtual string get_ConnectionString();
    public virtual void set_ConnectionString(string value);
    public virtual int get_ConnectionTimeout();
    public virtual string get_Database();
    public virtual string get_DataSource();
    public virtual string get_ServerVersion();
    public virtual ConnectionState get_State();
    [CompilerGeneratedAttribute]
protected bool get_AutoDisposeConnection();
    [CompilerGeneratedAttribute]
protected void set_AutoDisposeConnection(bool value);
    public virtual void ChangeDatabase(string databaseName);
    public virtual void Close();
    public virtual void Open();
    protected virtual DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    protected virtual DbCommand CreateDbCommand();
    protected virtual void Dispose(bool disposing);
    private void StateChangeHandler(object sender, StateChangeEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class ServiceStack.MiniProfiler.Data.ProfiledDbDataReader : DbDataReader {
    private DbConnection db;
    private DbDataReader reader;
    private IDbProfiler profiler;
    public int Depth { get; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public bool IsClosed { get; }
    public int RecordsAffected { get; }
    public object Item { get; }
    public object Item { get; }
    public ProfiledDbDataReader(DbDataReader reader, DbConnection connection, IDbProfiler profiler);
    public virtual int get_Depth();
    public virtual int get_FieldCount();
    public virtual bool get_HasRows();
    public virtual bool get_IsClosed();
    public virtual int get_RecordsAffected();
    public virtual object get_Item(string name);
    public virtual object get_Item(int ordinal);
    public virtual void Close();
    public virtual bool GetBoolean(int ordinal);
    public virtual byte GetByte(int ordinal);
    public virtual long GetBytes(int ordinal, long dataOffset, Byte[] buffer, int bufferOffset, int length);
    public virtual char GetChar(int ordinal);
    public virtual long GetChars(int ordinal, long dataOffset, Char[] buffer, int bufferOffset, int length);
    public virtual string GetDataTypeName(int ordinal);
    public virtual DateTime GetDateTime(int ordinal);
    public virtual decimal GetDecimal(int ordinal);
    public virtual double GetDouble(int ordinal);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int ordinal);
    public virtual float GetFloat(int ordinal);
    public virtual Guid GetGuid(int ordinal);
    public virtual short GetInt16(int ordinal);
    public virtual int GetInt32(int ordinal);
    public virtual long GetInt64(int ordinal);
    public virtual string GetName(int ordinal);
    public virtual int GetOrdinal(string name);
    public virtual string GetString(int ordinal);
    public virtual object GetValue(int ordinal);
    public virtual int GetValues(Object[] values);
    public virtual bool IsDBNull(int ordinal);
    public virtual bool NextResult();
    public virtual bool Read();
}
public class ServiceStack.MiniProfiler.Data.ProfiledDbTransaction : DbTransaction {
    private ProfiledConnection db;
    private DbTransaction trans;
    protected DbConnection DbConnection { get; }
    public IDbTransaction DbTransaction { get; }
    public IsolationLevel IsolationLevel { get; }
    public ProfiledDbTransaction(DbTransaction transaction, ProfiledConnection connection);
    protected virtual DbConnection get_DbConnection();
    public sealed virtual IDbTransaction get_DbTransaction();
    public virtual IsolationLevel get_IsolationLevel();
    public virtual void Commit();
    public virtual void Rollback();
    protected virtual void Dispose(bool disposing);
}
public class ServiceStack.MiniProfiler.Data.ProfiledProviderFactory : DbProviderFactory {
    public static ProfiledProviderFactory Instance;
    [CompilerGeneratedAttribute]
private IDbProfiler <Profiler>k__BackingField;
    [CompilerGeneratedAttribute]
private DbProviderFactory <WrappedFactory>k__BackingField;
    protected IDbProfiler Profiler { get; private set; }
    protected DbProviderFactory WrappedFactory { get; private set; }
    public ProfiledProviderFactory(IDbProfiler profiler, DbProviderFactory wrappedFactory);
    private static ProfiledProviderFactory();
    [CompilerGeneratedAttribute]
protected IDbProfiler get_Profiler();
    [CompilerGeneratedAttribute]
private void set_Profiler(IDbProfiler value);
    [CompilerGeneratedAttribute]
protected DbProviderFactory get_WrappedFactory();
    [CompilerGeneratedAttribute]
private void set_WrappedFactory(DbProviderFactory value);
    public void InitProfiledDbProviderFactory(IDbProfiler profiler, DbProviderFactory wrappedFactory);
    public virtual DbCommand CreateCommand();
    public virtual DbConnection CreateConnection();
    public virtual DbParameter CreateParameter();
    public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();
}
public class ServiceStack.ModelConfig`1 : object {
    public static void Id(GetMemberDelegate`1<T> getIdFn);
}
[ExtensionAttribute]
public static class ServiceStack.NavbarDefaults : object {
    [CompilerGeneratedAttribute]
private static string <NavClass>k__BackingField;
    public static string NavClass { get; public set; }
    private static NavbarDefaults();
    [CompilerGeneratedAttribute]
public static string get_NavClass();
    [CompilerGeneratedAttribute]
public static void set_NavClass(string value);
    public static NavOptions Create();
    [ExtensionAttribute]
public static NavOptions ForNavbar(NavOptions options);
}
[ExtensionAttribute]
public static class ServiceStack.NavButtonGroupDefaults : object {
    [CompilerGeneratedAttribute]
private static string <NavClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NavItemClass>k__BackingField;
    public static string NavClass { get; public set; }
    public static string NavItemClass { get; public set; }
    private static NavButtonGroupDefaults();
    [CompilerGeneratedAttribute]
public static string get_NavClass();
    [CompilerGeneratedAttribute]
public static void set_NavClass(string value);
    [CompilerGeneratedAttribute]
public static string get_NavItemClass();
    [CompilerGeneratedAttribute]
public static void set_NavItemClass(string value);
    public static NavOptions Create();
    [ExtensionAttribute]
public static NavOptions ForNavButtonGroup(NavOptions options);
}
[ExtensionAttribute]
public static class ServiceStack.NavDefaults : object {
    [CompilerGeneratedAttribute]
private static string <NavClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NavItemClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NavLinkClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ActiveClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ChildNavItemClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ChildNavLinkClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ChildNavMenuClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ChildNavMenuItemClass>k__BackingField;
    public static string NavClass { get; public set; }
    public static string NavItemClass { get; public set; }
    public static string NavLinkClass { get; public set; }
    public static string ActiveClass { get; public set; }
    public static string ChildNavItemClass { get; public set; }
    public static string ChildNavLinkClass { get; public set; }
    public static string ChildNavMenuClass { get; public set; }
    public static string ChildNavMenuItemClass { get; public set; }
    private static NavDefaults();
    [CompilerGeneratedAttribute]
public static string get_NavClass();
    [CompilerGeneratedAttribute]
public static void set_NavClass(string value);
    [CompilerGeneratedAttribute]
public static string get_NavItemClass();
    [CompilerGeneratedAttribute]
public static void set_NavItemClass(string value);
    [CompilerGeneratedAttribute]
public static string get_NavLinkClass();
    [CompilerGeneratedAttribute]
public static void set_NavLinkClass(string value);
    [CompilerGeneratedAttribute]
public static string get_ActiveClass();
    [CompilerGeneratedAttribute]
public static void set_ActiveClass(string value);
    [CompilerGeneratedAttribute]
public static string get_ChildNavItemClass();
    [CompilerGeneratedAttribute]
public static void set_ChildNavItemClass(string value);
    [CompilerGeneratedAttribute]
public static string get_ChildNavLinkClass();
    [CompilerGeneratedAttribute]
public static void set_ChildNavLinkClass(string value);
    [CompilerGeneratedAttribute]
public static string get_ChildNavMenuClass();
    [CompilerGeneratedAttribute]
public static void set_ChildNavMenuClass(string value);
    [CompilerGeneratedAttribute]
public static string get_ChildNavMenuItemClass();
    [CompilerGeneratedAttribute]
public static void set_ChildNavMenuItemClass(string value);
    public static NavOptions Create();
    [ExtensionAttribute]
public static NavOptions ForNav(NavOptions options);
    public static NavOptions OverrideDefaults(NavOptions targets, NavOptions source);
}
[ExtensionAttribute]
public static class ServiceStack.NavLinkDefaults : object {
    [ExtensionAttribute]
public static NavOptions ForNavLink(NavOptions options);
}
public class ServiceStack.NavOptions : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseHref>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavItemClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavLinkClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActiveClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildNavItemClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildNavLinkClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildNavMenuClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildNavMenuItemClass>k__BackingField;
    public HashSet`1<string> Attributes { get; public set; }
    public string ActivePath { get; public set; }
    public string BaseHref { get; public set; }
    public string NavClass { get; public set; }
    public string NavItemClass { get; public set; }
    public string NavLinkClass { get; public set; }
    public string ActiveClass { get; public set; }
    public string ChildNavItemClass { get; public set; }
    public string ChildNavLinkClass { get; public set; }
    public string ChildNavMenuClass { get; public set; }
    public string ChildNavMenuItemClass { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ActivePath();
    [CompilerGeneratedAttribute]
public void set_ActivePath(string value);
    [CompilerGeneratedAttribute]
public string get_BaseHref();
    [CompilerGeneratedAttribute]
public void set_BaseHref(string value);
    [CompilerGeneratedAttribute]
public string get_NavClass();
    [CompilerGeneratedAttribute]
public void set_NavClass(string value);
    [CompilerGeneratedAttribute]
public string get_NavItemClass();
    [CompilerGeneratedAttribute]
public void set_NavItemClass(string value);
    [CompilerGeneratedAttribute]
public string get_NavLinkClass();
    [CompilerGeneratedAttribute]
public void set_NavLinkClass(string value);
    [CompilerGeneratedAttribute]
public string get_ActiveClass();
    [CompilerGeneratedAttribute]
public void set_ActiveClass(string value);
    [CompilerGeneratedAttribute]
public string get_ChildNavItemClass();
    [CompilerGeneratedAttribute]
public void set_ChildNavItemClass(string value);
    [CompilerGeneratedAttribute]
public string get_ChildNavLinkClass();
    [CompilerGeneratedAttribute]
public void set_ChildNavLinkClass(string value);
    [CompilerGeneratedAttribute]
public string get_ChildNavMenuClass();
    [CompilerGeneratedAttribute]
public void set_ChildNavMenuClass(string value);
    [CompilerGeneratedAttribute]
public string get_ChildNavMenuItemClass();
    [CompilerGeneratedAttribute]
public void set_ChildNavMenuItemClass(string value);
}
[ExtensionAttribute]
public static class ServiceStack.NetCoreExtensions : object {
    [ExtensionAttribute]
public static void Close(Socket socket);
    [ExtensionAttribute]
public static void Close(DbDataReader reader);
}
public class ServiceStack.ObjectActivator : MulticastDelegate {
    public ObjectActivator(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class ServiceStack.PerfUtils : object {
    [ExtensionAttribute]
public static TimeSpan ToTimeSpan(long fromTicks);
    public static double MeasureFor(Action fn, int runForMs);
    public static double Measure(Action fn, int times, int runForMs, Action setup, Action warmup, Action teardown);
}
public class ServiceStack.ProcessResult : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdErr>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdOut>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartAt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndAt>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <CallbackDurationMs>k__BackingField;
    public Nullable`1<int> ExitCode { get; public set; }
    public string StdErr { get; public set; }
    public string StdOut { get; public set; }
    public DateTime StartAt { get; public set; }
    public DateTime EndAt { get; public set; }
    public long DurationMs { get; public set; }
    public Nullable`1<long> CallbackDurationMs { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_StdErr();
    [CompilerGeneratedAttribute]
public void set_StdErr(string value);
    [CompilerGeneratedAttribute]
public string get_StdOut();
    [CompilerGeneratedAttribute]
public void set_StdOut(string value);
    [CompilerGeneratedAttribute]
public DateTime get_StartAt();
    [CompilerGeneratedAttribute]
public void set_StartAt(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndAt();
    [CompilerGeneratedAttribute]
public void set_EndAt(DateTime value);
    [CompilerGeneratedAttribute]
public long get_DurationMs();
    [CompilerGeneratedAttribute]
public void set_DurationMs(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_CallbackDurationMs();
    [CompilerGeneratedAttribute]
public void set_CallbackDurationMs(Nullable`1<long> value);
}
[ExtensionAttribute]
public static class ServiceStack.ProcessUtils : object {
    [ExtensionAttribute]
public static ProcessStartInfo ConvertToCmdExec(ProcessStartInfo startInfo);
    public static string FindExePath(string exeName);
    public static string RunShell(string arguments, string workingDir);
    public static string Run(string fileName, string arguments, string workingDir);
    public static Process CreateProcess(string fileName, string arguments, string workingDir);
    [AsyncStateMachineAttribute("ServiceStack.ProcessUtils/<RunShellAsync>d__5")]
public static Task RunShellAsync(string arguments, string workingDir, Nullable`1<int> timeoutMs, Action`1<string> onOut, Action`1<string> onError);
    [AsyncStateMachineAttribute("ServiceStack.ProcessUtils/<RunAsync>d__6")]
public static Task`1<ProcessResult> RunAsync(ProcessStartInfo startInfo, Nullable`1<int> timeoutMs, Action`1<string> onOut, Action`1<string> onError);
    public static ProcessResult CreateErrorResult(Exception e);
}
public static class ServiceStack.Reflection.DelegateFactory : object {
    public static LateBoundMethod Create(MethodInfo method);
    private static Expression[] CreateParameterExpressions(MethodInfo method, Expression argumentsParameter);
    public static LateBoundVoid CreateVoid(MethodInfo method);
}
[ExtensionAttribute]
public static class ServiceStack.RequestScriptUtils : object {
    public static Dictionary`2<string, string> GetRequestParams(IRequest request);
    [ExtensionAttribute]
public static void AddToMap(NameValueCollection nvc, Dictionary`2<string, string> map, HashSet`1<string> exclude);
}
public enum ServiceStack.Run : Enum {
    public int value__;
    public static Run Always;
    public static Run IgnoreInDebug;
    public static Run OnlyInDebug;
}
public class ServiceStack.Script.BindingExpressionException : Exception {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Member>k__BackingField;
    public string Expression { get; }
    public string Member { get; }
    public BindingExpressionException(string message, string member, string expression, Exception inner);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public string get_Member();
}
[ExtensionAttribute]
public static class ServiceStack.Script.CallExpressionUtils : object {
    private static char WhitespaceArgument;
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsCallExpression(ReadOnlySpan`1<char> literal, JsCallExpression& expression, bool filterExpression);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseWhitespaceArgument(ReadOnlySpan`1<char> literal, JsToken& argument);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseArguments(ReadOnlySpan`1<char> literal, List`1& arguments, char termination);
}
public class ServiceStack.Script.CaptureScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    [AsyncStateMachineAttribute("ServiceStack.Script.CaptureScriptBlock/<WriteAsync>d__5")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
    private Tuple Parse(ScriptScopeContext scope, PageBlockFragment block);
}
public class ServiceStack.Script.CsvScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken ct);
}
public class ServiceStack.Script.DefaultScriptBlocks : object {
    public sealed virtual void Register(ScriptContext context);
}
public class ServiceStack.Script.DefaultScripts : ScriptMethods {
    public static DefaultScripts Instance;
    [CompilerGeneratedAttribute]
private static List`1<string> <RemoveNewLinesFor>k__BackingField;
    public static List`1<string> EvaluateWhenSkippingFilterExecution;
    private static HashSet`1<string> InternalKeys;
    public static String[] XssFragments;
    public static List`1<string> RemoveNewLinesFor { get; }
    private static DefaultScripts();
    public int push(IList list, object item);
    public object pop(IList list);
    public object shift(IList list);
    public object unshift(IList list, object item);
    public int indexOf(object target, object item);
    public int indexOf(object target, object item, int startIndex);
    public int lastIndexOf(object target, object item);
    public int lastIndexOf(object target, object item, int startIndex);
    public object splice(IList list, int removeAt);
    public List`1<object> splice(IList list, int removeAt, int deleteCount);
    public List`1<object> splice(IList list, int removeAt, int deleteCount, List`1<object> insertItems);
    public List`1<object> slice(IList list);
    public List`1<object> slice(IList list, int begin);
    public List`1<object> slice(IList list, int begin, int end);
    public IgnoreResult forEach(ScriptScopeContext scope, object target, JsArrowFunctionExpression arrowExpr);
    public bool every(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public bool some(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public object find(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public int findIndex(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public List`1<object> filter(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public List`1<object> flat(IList list);
    public List`1<object> flat(IList list, int depth);
    public List`1<object> flatMap(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression);
    public List`1<object> flatMap(ScriptScopeContext scope, IList list, JsArrowFunctionExpression expression, int depth);
    public bool includes(IList list, object item);
    public bool includes(IList list, object item, int fromIndex);
    public List`1<object> sort(List`1<object> list);
    public object fromEnumFlagsList(IList values, Type enumType);
    public List`1<string> toEnumFlagsList(object enumValue);
    [CompilerGeneratedAttribute]
public static List`1<string> get_RemoveNewLinesFor();
    public sealed virtual void Configure(ScriptContext context);
    public DateTime now();
    public DateTime utcNow();
    public DateTimeOffset nowOffset();
    public DateTimeOffset utcNowOffset();
    public Guid nguid();
    public DateTime addTicks(DateTime target, int count);
    public DateTime addMilliseconds(DateTime target, int count);
    public DateTime addSeconds(DateTime target, int count);
    public DateTime addMinutes(DateTime target, int count);
    public DateTime addHours(DateTime target, int count);
    public DateTime addDays(DateTime target, int count);
    public DateTime addMonths(DateTime target, int count);
    public DateTime addYears(DateTime target, int count);
    public List`1<object> itemsOf(int count, object target);
    public List`1<int> times(int count);
    public IEnumerable`1<int> range(int count);
    public IEnumerable`1<int> range(int start, int count);
    public bool isEven(int value);
    public bool isOdd(int value);
    public static bool isTrue(object target);
    public static bool isTruthy(object target);
    public static bool isFalsy(object target);
    public object iif(object test, object ifTrue, object ifFalse);
    public object when(object returnTarget, object test);
    public object ifNot(object returnTarget, object test);
    public object unless(object returnTarget, object test);
    public object otherwise(object returnTarget, object elseReturn);
    public object ifElse(object returnTarget, object test, object defaultValue);
    public object ifNotElse(object returnTarget, object test, object defaultValue);
    public object unlessElse(object returnTarget, object test, object defaultValue);
    public object ifFalsy(object returnTarget, object test);
    public object ifTruthy(object returnTarget, object test);
    public object falsy(object test, object returnIfFalsy);
    public object truthy(object test, object returnIfTruthy);
    public bool isNull(object test);
    public bool isNotNull(object test);
    public bool exists(object test);
    public bool isZero(double value);
    public bool isPositive(double value);
    public bool isNegative(double value);
    public bool isNaN(double value);
    public bool isInfinity(double value);
    public object ifExists(object target);
    public object ifExists(object returnTarget, object test);
    public object ifNotExists(object returnTarget, object test);
    public object ifNo(object returnTarget, object target);
    public object ifNotEmpty(object target);
    public object ifNotEmpty(object returnTarget, object test);
    public object ifEmpty(object returnTarget, object test);
    public object ifTrue(object returnTarget, object test);
    public object ifFalse(object returnTarget, object test);
    public bool isEmpty(object target);
    public bool IsNullOrWhiteSpace(object target);
    public bool isEnum(Enum source, object value);
    public bool hasFlag(Enum source, object value);
    public StopExecution end();
    public Task end(ScriptScopeContext scope, object ignore);
    public StopExecution end(object ignore);
    public object endIfNull(object target);
    public object endIfNull(object ignoreTarget, object target);
    public object endIfNotNull(object target);
    public object endIfNotNull(object ignoreTarget, object target);
    public object endIfExists(object target);
    public object endIfExists(object ignoreTarget, object target);
    public object endIfEmpty(object target);
    public object endIfEmpty(object ignoreTarget, object target);
    public object endIfNotEmpty(object target);
    public object endIfNotEmpty(object ignoreTarget, object target);
    public object endIfFalsy(object target);
    public object endIfFalsy(object ignoreTarget, object target);
    public object endIfTruthy(object target);
    public object endIfTruthy(object ignoreTarget, object target);
    public object endIf(object test);
    public object endIf(object returnTarget, bool test);
    public object endIfAny(ScriptScopeContext scope, object target, object expression);
    public object endIfAll(ScriptScopeContext scope, object target, object expression);
    public object endWhere(ScriptScopeContext scope, object target, object expression);
    public object endWhere(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object ifEnd(bool test);
    public object ifEnd(object ignoreTarget, bool test);
    public object ifNotEnd(bool test);
    public object ifNotEnd(object ignoreTarget, bool test);
    public object onlyIfNull(object target);
    public object onlyIfNull(object ignoreTarget, object target);
    public object onlyIfNotNull(object target);
    public object onlyIfNotNull(object ignoreTarget, object target);
    public object onlyIfExists(object target);
    public object onlyIfExists(object ignoreTarget, object target);
    public object onlyIfEmpty(object target);
    public object onlyIfEmpty(object ignoreTarget, object target);
    public object onlyIfNotEmpty(object target);
    public object onlyIfNotEmpty(object ignoreTarget, object target);
    public object onlyIfFalsy(object target);
    public object onlyIfFalsy(object ignoreTarget, object target);
    public object onlyIfTruthy(object target);
    public object onlyIfTruthy(object ignoreTarget, object target);
    public object onlyIf(object test);
    public object onlyIf(object returnTarget, bool test);
    public object onlyIfAny(ScriptScopeContext scope, object target, object expression);
    public object onlyIfAll(ScriptScopeContext scope, object target, object expression);
    public object onlyWhere(ScriptScopeContext scope, object target, object expression);
    public object onlyIfDebug(object returnTarget);
    public object endIfDebug(object returnTarget);
    public object onlyWhere(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object ifOnly(bool test);
    public object ifOnly(object ignoreTarget, bool test);
    public object ifNotOnly(bool test);
    public object ifNotOnly(object ignoreTarget, bool test);
    public object ifDo(object test);
    public object ifDo(object ignoreTarget, object test);
    public object doIf(object test);
    public object doIf(object ignoreTarget, object test);
    public object ifUse(object test, object useValue);
    public object ifShow(object test, object useValue);
    public object ifShowRaw(object test, object useValue);
    public object useIf(object useValue, object test);
    public object showIf(object useValue, object test);
    public object showIfExists(object useValue, object test);
    public object use(object ignoreTarget, object useValue);
    public object show(object ignoreTarget, object useValue);
    public IRawString showRaw(object ignoreTarget, string content);
    public object useFmt(object ignoreTarget, string format, object arg);
    public object useFmt(object ignoreTarget, string format, object arg1, object arg2);
    public object useFmt(object ignoreTarget, string format, object arg1, object arg2, object arg3);
    public object useFormat(object ignoreTarget, object arg, string fmt);
    public object showFmt(object ignoreTarget, string format, object arg);
    public object showFmt(object ignoreTarget, string format, object arg1, object arg2);
    public object showFmt(object ignoreTarget, string format, object arg1, object arg2, object arg3);
    public object showFormat(object ignoreTarget, object arg, string fmt);
    public IRawString showFmtRaw(object ignoreTarget, string format, object arg);
    public IRawString showFmtRaw(object ignoreTarget, string format, object arg1, object arg2);
    public IRawString showFmtRaw(object ignoreTarget, string format, object arg1, object arg2, object arg3);
    public bool isString(object target);
    public bool isInt(object target);
    public bool isLong(object target);
    public bool isInteger(object target);
    public bool isDouble(object target);
    public bool isFloat(object target);
    public bool isDecimal(object target);
    public bool isBool(object target);
    public bool isList(object target);
    public bool isEnumerable(object target);
    public bool isDictionary(object target);
    public bool isChar(object target);
    public bool isChars(object target);
    public bool isByte(object target);
    public bool isBytes(object target);
    public bool isObjectDictionary(object target);
    public bool isStringDictionary(object target);
    public bool isType(object target, string typeName);
    public bool isNumber(object target);
    public bool isRealNumber(object target);
    public bool isEnum(object target);
    public bool isArray(object target);
    public bool isAnonObject(object target);
    public bool isClass(object target);
    public bool isValueType(object target);
    public bool isDto(object target);
    public bool isTuple(object target);
    public bool isKeyValuePair(object target);
    public bool instanceOf(object target, object type);
    public int length(object target);
    public bool hasMinCount(object target, int minCount);
    public bool hasMaxCount(object target, int maxCount);
    public bool OR(object lhs, object rhs);
    public bool AND(object lhs, object rhs);
    public bool equals(object target, object other);
    public bool notEquals(object target, object other);
    public bool greaterThan(object target, object other);
    public bool greaterThanEqual(object target, object other);
    public bool lessThan(object target, object other);
    public bool lessThanEqual(object target, object other);
    public bool not(bool target);
    public bool eq(object target, object other);
    public bool not(object target, object other);
    public bool gt(object target, object other);
    public bool gte(object target, object other);
    public bool lt(object target, object other);
    public bool lte(object target, object other);
    internal static bool compareTo(object target, object other, Func`2<int, bool> fn);
    public object echo(object value);
    public IRawString pass(string target);
    public string join(IEnumerable`1<object> values);
    public string joinln(IEnumerable`1<object> values);
    public string join(IEnumerable`1<object> values, string delimiter);
    public IEnumerable`1<object> reverse(ScriptScopeContext scope, IEnumerable`1<object> original);
    public KeyValuePair`2<string, object> keyValuePair(string key, object value);
    public IgnoreResult prependTo(ScriptScopeContext scope, string value, object argExpr);
    public IgnoreResult prependToGlobal(ScriptScopeContext scope, string value, object argExpr);
    private IgnoreResult prependToArgs(ScriptScopeContext scope, string filterName, string value, object argExpr, Dictionary`2<string, object> args);
    public IgnoreResult appendTo(ScriptScopeContext scope, string value, object argExpr);
    public IgnoreResult appendToGlobal(ScriptScopeContext scope, string value, object argExpr);
    private IgnoreResult appendToArgs(ScriptScopeContext scope, string filterName, string value, object argExpr, Dictionary`2<string, object> args);
    public IgnoreResult addToStart(ScriptScopeContext scope, object value, object argExpr);
    public IgnoreResult addToStartGlobal(ScriptScopeContext scope, object value, object argExpr);
    private IgnoreResult addToStartArgs(ScriptScopeContext scope, string filterName, object value, object argExpr, Dictionary`2<string, object> args);
    public IgnoreResult addTo(ScriptScopeContext scope, object value, object argExpr);
    public IgnoreResult addToGlobal(ScriptScopeContext scope, object value, object argExpr);
    private IgnoreResult addToArgs(ScriptScopeContext scope, string filterName, object value, object argExprOrCollection, Dictionary`2<string, object> args);
    public object addItem(object collection, object value);
    public object putItem(IDictionary dictionary, object key, object value);
    private static bool TryAddToCollection(object collection, object value);
    public object resolveArg(ScriptScopeContext scope, string name);
    public object resolveGlobal(ScriptScopeContext scope, string name);
    public object resolvePageArg(ScriptScopeContext scope, string name);
    public object resolveContextArg(ScriptScopeContext scope, string name);
    public object assign(ScriptScopeContext scope, string argExpr, object value);
    public object assignGlobal(ScriptScopeContext scope, string argExpr, object value);
    private object assignArgs(ScriptScopeContext scope, string argExpr, object value, Dictionary`2<string, object> args);
    public IgnoreResult to(ScriptScopeContext scope, object value, object argExpr);
    public IgnoreResult assignTo(ScriptScopeContext scope, object value, object argExpr);
    public IgnoreResult toGlobal(ScriptScopeContext scope, object value, object argExpr);
    public IgnoreResult assignToGlobal(ScriptScopeContext scope, object value, object argExpr);
    public Task to(ScriptScopeContext scope, object argExpr);
    public Task assignTo(ScriptScopeContext scope, object argExpr);
    public Task toGlobal(ScriptScopeContext scope, object argExpr);
    public Task assignToGlobal(ScriptScopeContext scope, object argExpr);
    private Task assignToArgs(ScriptScopeContext scope, string filterName, object argExpr, Dictionary`2<string, object> args);
    public static string GetVarNameFromStringOrArrowExpression(string filterName, object argExpr);
    public Task buffer(ScriptScopeContext scope, object target);
    public Task partial(ScriptScopeContext scope, object target);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<partial>d__256")]
public Task partial(ScriptScopeContext scope, object target, object scopedParams);
    public Task selectEach(ScriptScopeContext scope, object target, object items);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<selectEach>d__258")]
public Task selectEach(ScriptScopeContext scope, object target, object items, object scopeOptions);
    public string toString(object target);
    public string asString(object target);
    public List`1<object> toList(IEnumerable target);
    public List`1<string> toStringList(IEnumerable target);
    public Object[] toArray(IEnumerable target);
    public char fromCharCode(int charCode);
    public char toChar(object target);
    public Char[] toChars(object target);
    public int toCharCode(object target);
    public Byte[] toUtf8Bytes(string target);
    public string fromUtf8Bytes(Byte[] target);
    public byte toByte(object target);
    public int toInt(object target);
    public long toLong(object target);
    public float toFloat(object target);
    public double toDouble(object target);
    public decimal toDecimal(object target);
    public bool toBool(object target);
    public DateTime toDateTime(object target);
    public DateTime date(int year, int month, int day);
    public DateTime date(int year, int month, int day, int hour, int min, int secs);
    public TimeSpan toTimeSpan(object target);
    public TimeSpan time(int hours, int mins, int secs);
    public TimeSpan time(int days, int hours, int mins, int secs);
    public KeyValuePair`2<string, object> pair(string key, object value);
    public List`1<string> toKeys(object target);
    public List`1<object> toValues(object target);
    public Dictionary`2<string, object> toObjectDictionary(object target);
    public Dictionary`2<string, string> toStringDictionary(IDictionary map);
    public List`1<string> splitStringList(IEnumerable strings);
    public List`1<string> toVarNames(IEnumerable names);
    public int AssertWithinMaxQuota(int value);
    public Dictionary`2<object, object> toDictionary(ScriptScopeContext scope, object target, object expression);
    public Dictionary`2<object, object> toDictionary(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IRawString typeName(object target);
    public IRawString typeFullName(object target);
    public IEnumerable of(ScriptScopeContext scope, IEnumerable target, object scopeOptions);
    public object do(ScriptScopeContext scope, object expression);
    public Task do(ScriptScopeContext scope, object target, object expression);
    public Task do(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public List`1<string> props(object o);
    public PropertyInfo[] propTypes(object o);
    public List`1<string> staticProps(object o);
    public PropertyInfo[] staticPropTypes(object o);
    public List`1<string> fields(object o);
    public FieldInfo[] fieldTypes(object o);
    public List`1<string> staticFields(object o);
    public FieldInfo[] staticFieldTypes(object o);
    public object property(object target, string propertyName);
    public object field(object target, string fieldName);
    public object map(ScriptScopeContext scope, object items, object expression);
    public object map(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object scopeVars(object target);
    public object selectFields(object target, object names);
    public Task select(ScriptScopeContext scope, object target, object selectTemplate);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<select>d__314")]
public Task select(ScriptScopeContext scope, object target, object selectTemplate, object scopeOptions);
    public Task selectPartial(ScriptScopeContext scope, object target, string pageName);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<selectPartial>d__316")]
public Task selectPartial(ScriptScopeContext scope, object target, string pageName, object scopedParams);
    public object removeKeyFromDictionary(IDictionary dictionary, object keyToRemove);
    public object remove(object target, object keysToRemove);
    public object withoutNullValues(object target);
    public object withoutEmptyValues(object target);
    public object withKeys(IDictionary`2<string, object> target, object keys);
    public object ownProps(IEnumerable`1<KeyValuePair`2<string, object>> target);
    public object withoutKeys(IDictionary`2<string, object> target, object keys);
    public object merge(object sources);
    public object merge(IDictionary`2<string, object> target, object sources);
    public string dirPath(string filePath);
    public string resolveAsset(ScriptScopeContext scope, string virtualPath);
    [ObsoleteAttribute("Use evalScript")]
public Task`1<object> evalTemplate(ScriptScopeContext scope, string source);
    [ObsoleteAttribute("Use evalScript")]
public Task`1<object> evalTemplate(ScriptScopeContext scope, string source, Dictionary`2<string, object> args);
    public Task`1<object> evalScript(ScriptScopeContext scope, string source);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<evalScript>d__332")]
public Task`1<object> evalScript(ScriptScopeContext scope, string source, Dictionary`2<string, object> args);
    public IgnoreResult write(ScriptScopeContext scope, object value);
    public IgnoreResult writeln(ScriptScopeContext scope, object value);
    public object unwrap(object value);
    public object sync(object value);
    public object if(object test);
    public object if(object returnTarget, object test);
    public object default(object returnTarget, object elseReturn);
    public object throw(ScriptScopeContext scope, string message);
    public object throw(ScriptScopeContext scope, string message, object options);
    public StopExecution return(ScriptScopeContext scope);
    public StopExecution return(ScriptScopeContext scope, object returnValue);
    public StopExecution return(ScriptScopeContext scope, object returnValue, Dictionary`2<string, object> returnArgs);
    public object assignError(ScriptScopeContext scope, string errorBinding);
    public object catchError(ScriptScopeContext scope, string errorBinding);
    public object assignErrorAndContinueExecuting(ScriptScopeContext scope, string errorBinding);
    public object continueExecutingFiltersOnError(ScriptScopeContext scope, object ignoreTarget);
    public object continueExecutingFiltersOnError(ScriptScopeContext scope);
    public object skipExecutingFiltersOnError(ScriptScopeContext scope, object ignoreTarget);
    public object skipExecutingFiltersOnError(ScriptScopeContext scope);
    public object endIfError(ScriptScopeContext scope);
    public object endIfError(ScriptScopeContext scope, object value);
    public object ifNoError(ScriptScopeContext scope);
    public object ifNoError(ScriptScopeContext scope, object value);
    public object ifError(ScriptScopeContext scope, object ignoreTarget);
    public object ifError(ScriptScopeContext scope);
    public object ifDebug(ScriptScopeContext scope, object ignoreTarget);
    public object ifDebug(ScriptScopeContext scope);
    public object debugMode(ScriptScopeContext scope);
    public bool hasError(ScriptScopeContext scope);
    public Exception lastError(ScriptScopeContext scope);
    public string lastErrorMessage(ScriptScopeContext scope);
    public string lastErrorStackTrace(ScriptScopeContext scope);
    public object ensureAllArgsNotNull(ScriptScopeContext scope, object args);
    public object ensureAllArgsNotNull(ScriptScopeContext scope, object args, object options);
    public object ensureAnyArgsNotNull(ScriptScopeContext scope, object args);
    public object ensureAnyArgsNotNull(ScriptScopeContext scope, object args, object options);
    public object ensureAllArgsNotEmpty(ScriptScopeContext scope, object args);
    public object ensureAllArgsNotEmpty(ScriptScopeContext scope, object args, object options);
    public object ensureAnyArgsNotEmpty(ScriptScopeContext scope, object args);
    public object ensureAnyArgsNotEmpty(ScriptScopeContext scope, object args, object options);
    public object ifThrow(ScriptScopeContext scope, bool test, string message);
    public object ifThrow(ScriptScopeContext scope, bool test, string message, object options);
    public object throwIf(ScriptScopeContext scope, string message, bool test);
    public object throwIf(ScriptScopeContext scope, string message, bool test, object options);
    public object ifThrowArgumentException(ScriptScopeContext scope, bool test, string message);
    public object ifThrowArgumentException(ScriptScopeContext scope, bool test, string message, object options);
    public object ifThrowArgumentException(ScriptScopeContext scope, bool test, string message, string paramName, object options);
    public object ifThrowArgumentNullException(ScriptScopeContext scope, bool test, string paramName);
    public object ifThrowArgumentNullException(ScriptScopeContext scope, bool test, string paramName, object options);
    public object throwArgumentNullExceptionIf(ScriptScopeContext scope, string paramName, bool test);
    public object throwArgumentNullExceptionIf(ScriptScopeContext scope, string paramName, bool test, object options);
    public object throwArgumentException(ScriptScopeContext scope, string message);
    public object throwArgumentException(ScriptScopeContext scope, string message, string options);
    public object throwArgumentNullException(ScriptScopeContext scope, string paramName);
    public object throwArgumentNullException(ScriptScopeContext scope, string paramName, object options);
    public object throwNotSupportedException(ScriptScopeContext scope, string message);
    public object throwNotSupportedException(ScriptScopeContext scope, string message, object options);
    public object throwNotImplementedException(ScriptScopeContext scope, string message);
    public object throwNotImplementedException(ScriptScopeContext scope, string message, object options);
    public object throwUnauthorizedAccessException(ScriptScopeContext scope, string message);
    public object throwUnauthorizedAccessException(ScriptScopeContext scope, string message, object options);
    public object throwFileNotFoundException(ScriptScopeContext scope, string message);
    public object throwFileNotFoundException(ScriptScopeContext scope, string message, object options);
    public object throwOptimisticConcurrencyException(ScriptScopeContext scope, string message);
    public object throwOptimisticConcurrencyException(ScriptScopeContext scope, string message, object options);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<throwAsync>d__398")]
public Task`1<object> throwAsync(ScriptScopeContext scope, string message);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<throwAsync>d__399")]
public Task`1<object> throwAsync(ScriptScopeContext scope, string message, object options);
    public object add(object lhs, object rhs);
    public object sub(object lhs, object rhs);
    public object subtract(object lhs, object rhs);
    public object mul(object lhs, object rhs);
    public object multiply(object lhs, object rhs);
    public double div(double lhs, double rhs);
    public double divide(double lhs, double rhs);
    public long incr(long value);
    public long increment(long value);
    public long incrBy(long value, long by);
    public long incrementBy(long value, long by);
    public long decr(long value);
    public long decrement(long value);
    public long decrBy(long value, long by);
    public long decrementBy(long value, long by);
    public long mod(long value, long divisor);
    public double pi();
    public double e();
    public double floor(double value);
    public double ceiling(double value);
    public double abs(double value);
    public double acos(double value);
    public double atan(double value);
    public double atan2(double y, double x);
    public double cos(double value);
    public double exp(double value);
    public double log(double value);
    public double log(double a, double newBase);
    public double log2(double value);
    public double log10(double value);
    public double pow(double x, double y);
    public double round(double value);
    public double round(double value, int decimals);
    public int sign(double value);
    public double sin(double value);
    public double sinh(double value);
    public double sqrt(double value);
    public double tan(double value);
    public double tanh(double value);
    public double truncate(double value);
    public int intAdd(int lhs, int rhs);
    public int intSub(int lhs, int rhs);
    public int intMul(int lhs, int rhs);
    public int intDiv(int lhs, int rhs);
    public long longAdd(long lhs, long rhs);
    public long longSub(long lhs, long rhs);
    public long longMul(long lhs, long rhs);
    public long longDiv(long lhs, long rhs);
    public double doubleAdd(double lhs, double rhs);
    public double doubleSub(double lhs, double rhs);
    public double doubleMul(double lhs, double rhs);
    public double doubleDiv(double lhs, double rhs);
    public decimal decimalAdd(decimal lhs, decimal rhs);
    public decimal decimalSub(decimal lhs, decimal rhs);
    public decimal decimalMul(decimal lhs, decimal rhs);
    public decimal decimalDiv(decimal lhs, decimal rhs);
    public List`1<object> step(IEnumerable target, object scopeOptions);
    public object elementAt(IEnumerable target, int index);
    public bool contains(object target, object needle);
    public bool sequenceEquals(IEnumerable a, IEnumerable b);
    public IEnumerable`1<object> take(ScriptScopeContext scope, IEnumerable`1<object> original, object countOrBinding);
    public IEnumerable`1<object> skip(ScriptScopeContext scope, IEnumerable`1<object> original, object countOrBinding);
    public IEnumerable`1<object> limit(ScriptScopeContext scope, IEnumerable`1<object> original, object skipOrBinding, object takeOrBinding);
    public int count(ScriptScopeContext scope, object target);
    public int count(ScriptScopeContext scope, object target, object expression);
    public int count(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object sum(ScriptScopeContext scope, object target);
    public object sum(ScriptScopeContext scope, object target, object expression);
    public object sum(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object min(ScriptScopeContext scope, object target);
    public object min(ScriptScopeContext scope, object target, object expression);
    public object min(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object max(ScriptScopeContext scope, object target);
    public object max(ScriptScopeContext scope, object target, object expression);
    public object max(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public double average(ScriptScopeContext scope, object target);
    public double average(ScriptScopeContext scope, object target, object expression);
    public double average(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    private object applyInternal(string filterName, ScriptScopeContext scope, object target, object expression, object scopeOptions, Func`3<double, double, double> fn);
    public object reduce(ScriptScopeContext scope, object target, object expression);
    public object reduce(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public List`1<Object[]> zip(ScriptScopeContext scope, IEnumerable original, object itemsOrBinding);
    public List`1<object> flatten(object target);
    public List`1<object> flatten(object target, int depth);
    private void _flatten(List`1<object> to, object target, int depth);
    public object let(ScriptScopeContext scope, object target, object scopeBindings);
    public object first(ScriptScopeContext scope, object target);
    public object first(ScriptScopeContext scope, object target, object expression);
    public object first(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public object last(ScriptScopeContext scope, object target);
    public bool any(ScriptScopeContext scope, object target);
    public bool any(ScriptScopeContext scope, object target, object expression);
    public bool any(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public bool all(ScriptScopeContext scope, object target, object expression);
    public bool all(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> where(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> where(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> takeWhile(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> takeWhile(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> skipWhile(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> skipWhile(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> orderBy(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> orderBy(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> orderByDescending(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> orderByDescending(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> orderByDesc(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> orderByDesc(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> thenBy(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> thenBy(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<object> thenByDescending(ScriptScopeContext scope, object target, object expression);
    public IEnumerable`1<object> thenByDescending(ScriptScopeContext scope, object target, object expression, object scopeOptions);
    private static IComparer`1<object> GetComparer(string filterName, ScriptScopeContext scope, Dictionary`2<string, object> scopedParams);
    public static IEnumerable`1<object> orderByInternal(string filterName, ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public static IEnumerable`1<object> thenByInternal(string filterName, ScriptScopeContext scope, object target, object expression, object scopeOptions);
    public IEnumerable`1<IGrouping`2<object, object>> groupBy(ScriptScopeContext scope, IEnumerable`1<object> items, object expression);
    public IEnumerable`1<IGrouping`2<object, object>> groupBy(ScriptScopeContext scope, IEnumerable`1<object> items, object expression, object scopeOptions);
    public bool equivalentTo(IEnumerable`1<object> target, IEnumerable`1<object> items);
    public IEnumerable`1<object> distinct(IEnumerable`1<object> items);
    public IEnumerable`1<object> union(IEnumerable`1<object> target, IEnumerable`1<object> items);
    public IEnumerable`1<object> intersect(IEnumerable`1<object> target, IEnumerable`1<object> items);
    public IEnumerable`1<object> except(IEnumerable`1<object> target, IEnumerable`1<object> items);
    public IEnumerable`1<object> concat(IEnumerable`1<object> target, IEnumerable`1<object> items);
    public string concat(IEnumerable`1<string> target);
    public object get(object target, object key);
    public IRawString raw(object value);
    public string appSetting(string name);
    public string indent();
    public string indents(int count);
    public string space();
    public string spaces(int count);
    public string newLine();
    public string newLines(int count);
    public string newLine(string target);
    public string currency(decimal decimalValue);
    public string currency(decimal decimalValue, string culture);
    public IRawString formatRaw(object obj, string fmt);
    public string format(object obj, string format);
    public string fmt(string format, object arg);
    public string fmt(string format, object arg0, object arg1);
    public string fmt(string format, object arg0, object arg1, object arg2);
    public string append(string target, string suffix);
    public string appendLine(string target);
    public string appendFmt(string target, string format, object arg);
    public string appendFmt(string target, string format, object arg0, object arg1);
    public string appendFmt(string target, string format, object arg0, object arg1, object arg2);
    public string dateFormat(DateTime dateValue);
    public string dateFormat(DateTime dateValue, string format);
    public string dateTimeFormat(DateTime dateValue);
    public string timeFormat(TimeSpan timeValue);
    public string timeFormat(TimeSpan timeValue, string format);
    public string splitCase(string text);
    public string humanize(string text);
    public string titleCase(string text);
    public string pascalCase(string text);
    public string camelCase(string text);
    public string snakeCase(string text);
    public string kebabCase(string text);
    public string textStyle(string text, string headerStyle);
    public string lower(string text);
    public string upper(string text);
    public string substring(string text, int startIndex);
    public string substring(string text, int startIndex, int length);
    [ObsoleteAttribute("typo")]
public string substringWithElipsis(string text, int length);
    [ObsoleteAttribute("typo")]
public string substringWithElipsis(string text, int startIndex, int length);
    public string substringWithEllipsis(string text, int length);
    public string substringWithEllipsis(string text, int startIndex, int length);
    public string leftPart(string text, string needle);
    public string rightPart(string text, string needle);
    public string lastLeftPart(string text, string needle);
    public string lastRightPart(string text, string needle);
    public int compareTo(string text, string other);
    public bool startsWith(string text, string needle);
    public bool endsWith(string text, string needle);
    public string replace(string text, string oldValue, string newValue);
    public string trimStart(string text);
    public string trimStart(string text, char c);
    public string trimEnd(string text);
    public string trimEnd(string text, char c);
    public string trim(string text);
    public string trim(string text, char c);
    public string padLeft(string text, int totalWidth);
    public string padLeft(string text, int totalWidth, char padChar);
    public string padRight(string text, int totalWidth);
    public string padRight(string text, int totalWidth, char padChar);
    public String[] splitOnFirst(string text, string needle);
    public String[] splitOnLast(string text, string needle);
    public String[] split(string stringList);
    public String[] split(string stringList, object delimiter);
    public String[] glob(IEnumerable`1<string> strings, string pattern);
    public string globln(IEnumerable`1<string> strings, string pattern);
    public Dictionary`2<string, string> parseKeyValueText(string target);
    public Dictionary`2<string, string> parseKeyValueText(string target, string delimiter);
    public IEnumerable`1<KeyValuePair`2<string, string>> parseAsKeyValues(string target);
    public IEnumerable`1<KeyValuePair`2<string, string>> parseAsKeyValues(string target, string delimiter);
    public ICollection keys(object target);
    public ICollection values(object target);
    public string addPath(string target, string pathToAppend);
    public string addPaths(string target, IEnumerable pathsToAppend);
    public string addQueryString(string url, object urlParams);
    public string addHashParams(string url, object urlParams);
    public string setQueryString(string url, object urlParams);
    public string setHashParams(string url, object urlParams);
    public string repeating(int times, string text);
    public string repeat(string text, int times);
    public string escapeSingleQuotes(string text);
    public string escapeDoubleQuotes(string text);
    public string escapeBackticks(string text);
    public string escapePrimeQuotes(string text);
    public string escapeNewLines(string text);
    public IRawString jsString(string text);
    public IRawString jsQuotedString(string text);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<serialize>d__614")]
private Task serialize(ScriptScopeContext scope, object items, string jsconfig, Func`2<object, string> fn);
    private IRawString serialize(object target, string jsconfig, Func`2<object, string> fn);
    private static string jsonOrNull(object x);
    public IRawString json(object value);
    public IRawString json(object value, string jsconfig);
    public IRawString jsv(object value);
    public IRawString jsv(object value, string jsconfig);
    public IRawString csv(object value);
    public IRawString dump(object value);
    public IRawString indentJson(object value);
    public IRawString indentJson(object value, string jsconfig);
    public Task json(ScriptScopeContext scope, object items);
    public Task json(ScriptScopeContext scope, object items, string jsConfig);
    public Task jsv(ScriptScopeContext scope, object items);
    public Task jsv(ScriptScopeContext scope, object items, string jsConfig);
    public Task dump(ScriptScopeContext scope, object items);
    public Task dump(ScriptScopeContext scope, object items, string jsConfig);
    public Task csv(ScriptScopeContext scope, object items);
    public Task xml(ScriptScopeContext scope, object items);
    public JsonObject jsonToObject(string json);
    public JsonArrayObjects jsonToArrayObjects(string json);
    public Dictionary`2<string, object> jsonToObjectDictionary(string json);
    public Dictionary`2<string, string> jsonToStringDictionary(string json);
    public Dictionary`2<string, object> jsvToObjectDictionary(string json);
    public Dictionary`2<string, string> jsvToStringDictionary(string json);
    public object eval(ScriptScopeContext scope, string js);
    public object parseJson(string json);
    public string base64(Byte[] bytes);
    public Byte[] fromBase64(string base64);
    public List`1<List`1<string>> parseCsv(string csv);
    public List`1<KeyValuePair`2<string, string>> parseKeyValues(string keyValuesText);
    public List`1<KeyValuePair`2<string, string>> parseKeyValues(string keyValuesText, string delimiter);
    public string generateSlug(string phrase);
    public bool isBinary(string fileOrExt);
    public string contentType(string fileOrExt);
    public static String[] splitLines(string contents);
    public IEnumerable`1<string> readLines(string contents);
    public IRawString textList(IEnumerable target);
    public IRawString textList(IEnumerable target, Dictionary`2<string, object> options);
    public IRawString textDump(object target);
    public IRawString textDump(object target, Dictionary`2<string, object> options);
    public static string TextList(IEnumerable items, TextDumpOptions options);
    public static string TextDump(object target, TextDumpOptions options);
    internal static object ConvertDumpType(object target);
    private static int MaxLineLength(string s);
    private static string GetScalarText(object target, DefaultScripts defaults);
    private static bool isComplexType(object first);
    internal IRequest req(ScriptScopeContext scope);
    public bool matchesPathInfo(ScriptScopeContext scope, string pathInfo);
    public bool startsWithPathInfo(ScriptScopeContext scope, string pathInfo);
    public object ifMatchesPathInfo(ScriptScopeContext scope, object returnTarget, string pathInfo);
    public bool isHttpGet(ScriptScopeContext scope);
    public bool isHttpPost(ScriptScopeContext scope);
    public bool isHttpPut(ScriptScopeContext scope);
    public bool isHttpDelete(ScriptScopeContext scope);
    public bool isHttpPatch(ScriptScopeContext scope);
    public object ifHttpGet(ScriptScopeContext scope, object ignoreTarget);
    public object ifHttpGet(ScriptScopeContext scope);
    public object ifHttpPost(ScriptScopeContext scope, object ignoreTarget);
    public object ifHttpPost(ScriptScopeContext scope);
    public object ifHttpPut(ScriptScopeContext scope, object ignoreTarget);
    public object ifHttpPut(ScriptScopeContext scope);
    public object ifHttpDelete(ScriptScopeContext scope, object ignoreTarget);
    public object ifHttpDelete(ScriptScopeContext scope);
    public object ifHttpPatch(ScriptScopeContext scope, object ignoreTarget);
    public object ifHttpPatch(ScriptScopeContext scope);
    public object importRequestParams(ScriptScopeContext scope);
    public object importRequestParams(ScriptScopeContext scope, IEnumerable onlyImportArgNames);
    public Stream requestBody(ScriptScopeContext scope);
    public string rawBodyAsString(ScriptScopeContext scope);
    public object rawBodyAsJson(ScriptScopeContext scope);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<requestBodyAsString>d__685")]
public Task`1<object> requestBodyAsString(ScriptScopeContext scope);
    [AsyncStateMachineAttribute("ServiceStack.Script.DefaultScripts/<requestBodyAsJson>d__686")]
public Task`1<object> requestBodyAsJson(ScriptScopeContext scope);
    public NameValueCollection form(ScriptScopeContext scope);
    public NameValueCollection query(ScriptScopeContext scope);
    public NameValueCollection qs(ScriptScopeContext scope);
    public string queryString(ScriptScopeContext scope);
    public Dictionary`2<string, object> queryDictionary(ScriptScopeContext scope);
    public Dictionary`2<string, object> formDictionary(ScriptScopeContext scope);
    public string toQueryString(object keyValuePairs);
    public Dictionary`2<string, object> toCoercedDictionary(object target);
    public object coerce(string str);
    public string httpMethod(ScriptScopeContext scope);
    public string httpRequestUrl(ScriptScopeContext scope);
    public string httpPathInfo(ScriptScopeContext scope);
    public string formQuery(ScriptScopeContext scope, string name);
    public String[] formQueryValues(ScriptScopeContext scope, string name);
    public string httpParam(ScriptScopeContext scope, string name);
    public string urlEncode(string value, bool upperCase);
    public string urlEncode(string value);
    public string urlDecode(string value);
    public string htmlEncode(string value);
    public string htmlDecode(string value);
    public bool containsXss(object target);
    public static bool MatchesStringValue(object target, Func`2<string, bool> match);
    public static bool ContainsXss(string text);
    public List`1<NavItem> navItems();
    public List`1<NavItem> navItems(string key);
    public IRawString cssIncludes(IEnumerable cssFiles);
    public IRawString jsIncludes(IEnumerable jsFiles);
    [CompilerGeneratedAttribute]
internal static string <TextDump>g__TextKvps|656_1(StringBuilder s, IEnumerable`1<KeyValuePair`2<string, object>> kvps, <>c__DisplayClass656_0& , <>c__DisplayClass656_1& , <>c__DisplayClass656_2& );
}
public class ServiceStack.Script.DefnScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.DirectoryScripts : object {
    public IgnoreResult CreateDirectory(string path);
    public sealed virtual IgnoreResult Delete(string path);
    public sealed virtual bool Exists(string path);
    public String[] GetDirectories(string path);
    public String[] GetFiles(string path);
    public String[] GetLogicalDrives();
    public String[] GetFileSystemEntries(string path);
    public DirectoryInfo GetParent(string path);
    public string GetCurrentDirectory();
    public string GetDirectoryRoot(string path);
    public sealed virtual IgnoreResult Move(string from, string to);
    public sealed virtual IgnoreResult Copy(string from, string to);
    public static void CopyAllTo(string src, string dst, String[] excludePaths);
}
public class ServiceStack.Script.EachScriptBlock : ScriptBlock {
    public string Name { get; }
    public virtual string get_Name();
    [AsyncStateMachineAttribute("ServiceStack.Script.EachScriptBlock/<WriteAsync>d__2")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
    private EachArg ParseArgument(ScriptScopeContext scope, PageBlockFragment fragment);
}
public class ServiceStack.Script.EvalScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    [AsyncStateMachineAttribute("ServiceStack.Script.EvalScriptBlock/<WriteAsync>d__4")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.FileScripts : object {
    public sealed virtual IgnoreResult Copy(string from, string to);
    public IgnoreResult Create(string path);
    public IgnoreResult Decrypt(string path);
    public sealed virtual IgnoreResult Delete(string path);
    public IgnoreResult Encrypt(string path);
    public sealed virtual bool Exists(string path);
    public sealed virtual IgnoreResult Move(string from, string to);
    public IgnoreResult Replace(string from, string to, string backup);
    public Byte[] ReadAllBytes(string path);
    public String[] ReadAllLines(string path);
    public string ReadAllText(string path);
    public IgnoreResult WriteAllBytes(string path, Byte[] bytes);
    public IgnoreResult WriteAllLines(string path, String[] lines);
    public IgnoreResult WriteAllText(string path, string text);
    public IgnoreResult AppendAllLines(string path, String[] lines);
    public IgnoreResult AppendAllText(string path, string text);
}
public class ServiceStack.Script.FunctionScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.GitHubPlugin : object {
    public sealed virtual void Register(ScriptContext context);
}
public class ServiceStack.Script.GitHubScripts : ScriptMethods {
    public GistVirtualFiles gistVirtualFiles(string gistId);
    public GistVirtualFiles gistVirtualFiles(string gistId, string accessToken);
    public GitHubGateway githubGateway();
    public GitHubGateway githubGateway(string accessToken);
    public string githubSourceZipUrl(GitHubGateway gateway, string orgNames, string name);
    public Task`1<object> githubSourceRepos(GitHubGateway gateway, string orgName);
    public Task`1<object> githubUserAndOrgRepos(GitHubGateway gateway, string githubOrgOrUser);
    public List`1<GithubRepo> githubUserRepos(GitHubGateway gateway, string githubUser);
    public List`1<GithubRepo> githubOrgRepos(GitHubGateway gateway, string githubOrg);
    public GithubGist githubCreateGist(GitHubGateway gateway, string description, Dictionary`2<string, string> files);
    public GithubGist githubCreatePrivateGist(GitHubGateway gateway, string description, Dictionary`2<string, string> files);
    public GithubGist githubGist(GitHubGateway gateway, string gistId);
    public IgnoreResult githubWriteGistFiles(GitHubGateway gateway, string gistId, Dictionary`2<string, string> gistFiles);
    public IgnoreResult githubWriteGistFile(GitHubGateway gateway, string gistId, string filePath, string contents);
    public IgnoreResult githuDeleteGistFiles(GitHubGateway gateway, string gistId, string filePath);
    public IgnoreResult githuDeleteGistFiles(GitHubGateway gateway, string gistId, IEnumerable`1<string> filePaths);
}
public class ServiceStack.Script.HtmlPageFormat : PageFormat {
    public static string HtmlEncodeValue(object value);
    public SharpPage HtmlResolveLayout(SharpPage page);
    public virtual object HtmlExpressionException(PageResult result, Exception ex);
    [AsyncStateMachineAttribute("ServiceStack.Script.HtmlPageFormat/<HtmlEncodeTransformer>d__4")]
public static Task`1<Stream> HtmlEncodeTransformer(Stream stream);
}
public class ServiceStack.Script.HtmlScriptBlocks : object {
    public sealed virtual void Register(ScriptContext context);
}
public class ServiceStack.Script.HtmlScripts : ScriptMethods {
    public static List`1<string> EvaluateWhenSkippingFilterExecution;
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <VoidElements>k__BackingField;
    public static HashSet`1<string> VoidElements { get; }
    private static HtmlScripts();
    public sealed virtual void Configure(ScriptContext context);
    public IRawString htmlList(IEnumerable target);
    public IRawString htmlList(IEnumerable target, Dictionary`2<string, object> options);
    public IRawString htmlDump(object target);
    public IRawString htmlDump(object target, Dictionary`2<string, object> options);
    public static string HtmlList(IEnumerable items, HtmlDumpOptions options);
    public static string HtmlDump(object target, HtmlDumpOptions options);
    private static string GetScalarHtml(object target, DefaultScripts defaults);
    private static bool isComplexType(object first);
    public IRawString htmlError(ScriptScopeContext scope);
    public IRawString htmlError(ScriptScopeContext scope, Exception ex);
    public IRawString htmlError(ScriptScopeContext scope, Exception ex, object options);
    public IRawString htmlErrorMessage(ScriptScopeContext scope);
    public IRawString htmlErrorMessage(Exception ex);
    public IRawString htmlErrorMessage(Exception ex, object options);
    public IRawString htmlErrorDebug(ScriptScopeContext scope);
    public IRawString htmlErrorDebug(ScriptScopeContext scope, object ex);
    public IRawString htmlErrorDebug(ScriptScopeContext scope, Exception ex, object options);
    public string htmlAttrsList(Dictionary`2<string, object> attrs);
    public IRawString htmlAttrs(object target);
    public string htmlClassList(object target);
    public IRawString htmlClass(object target);
    public bool htmlHasClass(object target, string name);
    public string htmlAddClass(object target, string name);
    public IRawString htmlFormat(string htmlWithFormat, string arg);
    public IRawString htmlLink(string href);
    public IRawString htmlLink(string href, Dictionary`2<string, object> attrs);
    public IRawString htmlImage(string src);
    public IRawString htmlImage(string src, Dictionary`2<string, object> attrs);
    public IRawString htmlHiddenInputs(Dictionary`2<string, object> inputValues);
    public IRawString htmlOptions(object values);
    public IRawString htmlOptions(object values, object options);
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_VoidElements();
    public IRawString htmlTag(Dictionary`2<string, object> attrs, string tag);
    public IRawString htmlTag(string innerHtml, Dictionary`2<string, object> attrs, string tag);
    public IRawString htmlDiv(Dictionary`2<string, object> attrs);
    public IRawString htmlDiv(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlSpan(Dictionary`2<string, object> attrs);
    public IRawString htmlSpan(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlA(Dictionary`2<string, object> attrs);
    public IRawString htmlA(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlImg(Dictionary`2<string, object> attrs);
    public IRawString htmlImg(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH1(Dictionary`2<string, object> attrs);
    public IRawString htmlH1(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH2(Dictionary`2<string, object> attrs);
    public IRawString htmlH2(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH3(Dictionary`2<string, object> attrs);
    public IRawString htmlH3(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH4(Dictionary`2<string, object> attrs);
    public IRawString htmlH4(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH5(Dictionary`2<string, object> attrs);
    public IRawString htmlH5(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlH6(Dictionary`2<string, object> attrs);
    public IRawString htmlH6(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlEm(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlEm(string text);
    public IRawString htmlB(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlB(string text);
    public IRawString htmlUl(Dictionary`2<string, object> attrs);
    public IRawString htmlUl(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlOl(Dictionary`2<string, object> attrs);
    public IRawString htmlOl(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlLi(Dictionary`2<string, object> attrs);
    public IRawString htmlLi(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlTable(Dictionary`2<string, object> attrs);
    public IRawString htmlTable(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlTr(Dictionary`2<string, object> attrs);
    public IRawString htmlTr(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlTh(Dictionary`2<string, object> attrs);
    public IRawString htmlTh(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlTd(Dictionary`2<string, object> attrs);
    public IRawString htmlTd(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlForm(Dictionary`2<string, object> attrs);
    public IRawString htmlForm(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlLabel(Dictionary`2<string, object> attrs);
    public IRawString htmlLabel(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlInput(Dictionary`2<string, object> attrs);
    public IRawString htmlInput(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlTextArea(Dictionary`2<string, object> attrs);
    public IRawString htmlTextArea(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlButton(Dictionary`2<string, object> attrs);
    public IRawString htmlButton(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlSelect(Dictionary`2<string, object> attrs);
    public IRawString htmlSelect(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlOption(string innerHtml, Dictionary`2<string, object> attrs);
    public IRawString htmlOption(string text);
    [CompilerGeneratedAttribute]
internal static void <htmlOptions>g__appendOption|32_0(StringBuilder _sb, string value, string text, <>c__DisplayClass32_0& );
}
public interface ServiceStack.Script.IConfigurePageResult {
    public abstract virtual void Configure(PageResult pageResult);
}
public interface ServiceStack.Script.IConfigureScriptContext {
    public abstract virtual void Configure(ScriptContext context);
}
public class ServiceStack.Script.IfScriptBlock : ScriptBlock {
    public string Name { get; }
    public virtual string get_Name();
    [AsyncStateMachineAttribute("ServiceStack.Script.IfScriptBlock/<WriteAsync>d__2")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.IgnoreResult : object {
    public static IgnoreResult Value;
    private static IgnoreResult();
}
public enum ServiceStack.Script.InvokerType : Enum {
    public int value__;
    public static InvokerType Filter;
    public static InvokerType ContextFilter;
    public static InvokerType ContextBlock;
}
public interface ServiceStack.Script.IOScript {
    public abstract virtual IgnoreResult Delete(string path);
    public abstract virtual bool Exists(string target);
    public abstract virtual IgnoreResult Move(string from, string to);
    public abstract virtual IgnoreResult Copy(string from, string to);
}
public interface ServiceStack.Script.IPageResult {
}
public interface ServiceStack.Script.IResultInstruction {
}
public interface ServiceStack.Script.IScriptPlugin {
    public abstract virtual void Register(ScriptContext context);
}
public interface ServiceStack.Script.IScriptPluginAfter {
    public abstract virtual void AfterPluginsLoaded(ScriptContext context);
}
public interface ServiceStack.Script.IScriptPluginBefore {
    public abstract virtual void BeforePluginsLoaded(ScriptContext context);
}
public interface ServiceStack.Script.ISharpPages {
    public abstract virtual SharpPage ResolveLayoutPage(SharpPage page, string layout);
    public abstract virtual SharpPage AddPage(string virtualPath, IVirtualFile file);
    public abstract virtual SharpPage GetPage(string virtualPath);
    public abstract virtual SharpPage TryGetPage(string path);
    public abstract virtual SharpPage OneTimePage(string contents, string ext);
    public abstract virtual SharpPage OneTimePage(string contents, string ext, Action`1<SharpPage> init);
    public abstract virtual SharpPage ResolveLayoutPage(SharpCodePage page, string layout);
    public abstract virtual SharpCodePage GetCodePage(string virtualPath);
    public abstract virtual DateTime GetLastModified(SharpPage page);
}
public class ServiceStack.Script.JsAddition : JsBinaryOperator {
    public static JsAddition Operator;
    public string Token { get; }
    private static JsAddition();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsAnd : JsLogicOperator {
    public static JsAnd Operator;
    public string Token { get; }
    private static JsAnd();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsArrayExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsToken[] <Elements>k__BackingField;
    public JsToken[] Elements { get; }
    public JsArrayExpression(JsToken[] elements);
    public JsArrayExpression(IEnumerable`1<JsToken> elements);
    [CompilerGeneratedAttribute]
public JsToken[] get_Elements();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual string ToRawString();
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsArrayExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsArrowFunctionExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsIdentifier[] <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Body>k__BackingField;
    public JsIdentifier[] Params { get; }
    public JsToken Body { get; }
    public JsArrowFunctionExpression(JsIdentifier param, JsToken body);
    public JsArrowFunctionExpression(JsIdentifier[] params, JsToken body);
    [CompilerGeneratedAttribute]
public JsIdentifier[] get_Params();
    [CompilerGeneratedAttribute]
public JsToken get_Body();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public object Invoke(Object[] params);
    public object Invoke(ScriptScopeContext scope, Object[] params);
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsArrowFunctionExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsAssignment : JsBinaryOperator {
    public static JsAssignment Operator;
    public string Token { get; }
    private static JsAssignment();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsAssignmentExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsAssignment <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Right>k__BackingField;
    private Action`3<ScriptScopeContext, object, object> assignFn;
    public JsAssignment Operator { get; public set; }
    public JsToken Left { get; public set; }
    public JsToken Right { get; public set; }
    public JsAssignmentExpression(JsToken left, JsAssignment operator, JsToken right);
    [CompilerGeneratedAttribute]
public JsAssignment get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(JsAssignment value);
    [CompilerGeneratedAttribute]
public JsToken get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(JsToken value);
    [CompilerGeneratedAttribute]
public JsToken get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(JsToken value);
    public virtual string ToRawString();
    protected bool Equals(JsAssignmentExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string EvalProperty(JsToken token, ScriptScopeContext scope);
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
}
public class ServiceStack.Script.JsBinaryExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsBinaryOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Right>k__BackingField;
    public JsBinaryOperator Operator { get; public set; }
    public JsToken Left { get; public set; }
    public JsToken Right { get; public set; }
    public JsBinaryExpression(JsToken left, JsBinaryOperator operator, JsToken right);
    [CompilerGeneratedAttribute]
public JsBinaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(JsBinaryOperator value);
    [CompilerGeneratedAttribute]
public JsToken get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(JsToken value);
    [CompilerGeneratedAttribute]
public JsToken get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(JsToken value);
    public virtual string ToRawString();
    protected bool Equals(JsBinaryExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
}
public abstract class ServiceStack.Script.JsBinaryOperator : JsOperator {
    public abstract virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBitwiseAnd : JsBinaryOperator {
    public static JsBitwiseAnd Operator;
    public string Token { get; }
    private static JsBitwiseAnd();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBitwiseLeftShift : JsBinaryOperator {
    public static JsBitwiseLeftShift Operator;
    public string Token { get; }
    private static JsBitwiseLeftShift();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBitwiseNot : JsUnaryOperator {
    public static JsBitwiseNot Operator;
    public string Token { get; }
    private static JsBitwiseNot();
    public virtual string get_Token();
    public virtual object Evaluate(object target);
}
public class ServiceStack.Script.JsBitwiseOr : JsBinaryOperator {
    public static JsBitwiseOr Operator;
    public string Token { get; }
    private static JsBitwiseOr();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBitwiseRightShift : JsBinaryOperator {
    public static JsBitwiseRightShift Operator;
    public string Token { get; }
    private static JsBitwiseRightShift();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBitwiseXOr : JsBinaryOperator {
    public static JsBitwiseXOr Operator;
    public string Token { get; }
    private static JsBitwiseXOr();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsBlockStatement : JsStatement {
    [CompilerGeneratedAttribute]
private JsStatement[] <Statements>k__BackingField;
    public JsStatement[] Statements { get; }
    public JsBlockStatement(JsStatement[] statements);
    public JsBlockStatement(JsStatement statement);
    [CompilerGeneratedAttribute]
public JsStatement[] get_Statements();
    protected bool Equals(JsBlockStatement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsCallExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsToken <Callee>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken[] <Arguments>k__BackingField;
    private string nameString;
    public JsToken Callee { get; }
    public JsToken[] Arguments { get; }
    public string Name { get; }
    public JsCallExpression(JsToken callee, JsToken[] arguments);
    [CompilerGeneratedAttribute]
public JsToken get_Callee();
    [CompilerGeneratedAttribute]
public JsToken[] get_Arguments();
    public string get_Name();
    public static object InvokeDelegate(Delegate fn, object target, bool isMemberExpr, List`1<object> fnArgValues);
    public virtual object Evaluate(ScriptScopeContext scope);
    private object ResolveDelegate(ScriptScopeContext scope, string name);
    public static List`1<object> EvaluateArgumentValues(ScriptScopeContext scope, JsToken[] args);
    public virtual string ToString();
    public virtual string ToRawString();
    public string GetDisplayName();
    protected bool Equals(JsCallExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Dictionary`2<string, object> ToJsAst();
    [CompilerGeneratedAttribute]
internal static string <Evaluate>g__ResolveMethodName|11_0(JsToken token, <>c__DisplayClass11_0& );
}
public class ServiceStack.Script.JsCoalescing : JsBinaryOperator {
    public static JsCoalescing Operator;
    public string Token { get; }
    private static JsCoalescing();
    public virtual object Evaluate(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsConditionalExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsToken <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Consequent>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Alternate>k__BackingField;
    public JsToken Test { get; }
    public JsToken Consequent { get; }
    public JsToken Alternate { get; }
    public JsConditionalExpression(JsToken test, JsToken consequent, JsToken alternate);
    [CompilerGeneratedAttribute]
public JsToken get_Test();
    [CompilerGeneratedAttribute]
public JsToken get_Consequent();
    [CompilerGeneratedAttribute]
public JsToken get_Alternate();
    public virtual string ToRawString();
    public virtual Dictionary`2<string, object> ToJsAst();
    public virtual object Evaluate(ScriptScopeContext scope);
    protected bool Equals(JsConditionalExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsDeclaration : JsExpression {
    [CompilerGeneratedAttribute]
private JsIdentifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Init>k__BackingField;
    public JsIdentifier Id { get; public set; }
    public JsToken Init { get; public set; }
    public JsDeclaration(JsIdentifier id, JsToken init);
    [CompilerGeneratedAttribute]
public JsIdentifier get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(JsIdentifier value);
    [CompilerGeneratedAttribute]
public JsToken get_Init();
    [CompilerGeneratedAttribute]
public void set_Init(JsToken value);
    protected bool Equals(JsDeclaration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
}
public class ServiceStack.Script.JsDivision : JsBinaryOperator {
    public static JsDivision Operator;
    public string Token { get; }
    private static JsDivision();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsEquals : JsLogicOperator {
    public static JsEquals Operator;
    public string Token { get; }
    private static JsEquals();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public abstract class ServiceStack.Script.JsExpression : JsToken {
    public abstract virtual Dictionary`2<string, object> ToJsAst();
    public virtual string ToJsAstType();
}
public class ServiceStack.Script.JsExpressionStatement : JsStatement {
    [CompilerGeneratedAttribute]
private JsToken <Expression>k__BackingField;
    public JsToken Expression { get; }
    public JsExpressionStatement(JsToken expression);
    [CompilerGeneratedAttribute]
public JsToken get_Expression();
    protected bool Equals(JsExpressionStatement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class ServiceStack.Script.JsExpressionUtils : object {
    private static char ConditionalExpressionTestChar;
    [ExtensionAttribute]
public static object GetJsExpressionAndEvaluate(ReadOnlyMemory`1<char> expr, ScriptScopeContext scope, Action ifNone);
    [AsyncStateMachineAttribute("ServiceStack.Script.JsExpressionUtils/<GetJsExpressionAndEvaluateAsync>d__1")]
[ExtensionAttribute]
public static Task`1<object> GetJsExpressionAndEvaluateAsync(ReadOnlyMemory`1<char> expr, ScriptScopeContext scope, Action ifNone);
    [ExtensionAttribute]
public static bool GetJsExpressionAndEvaluateToBool(ReadOnlyMemory`1<char> expr, ScriptScopeContext scope, Action ifNone);
    [ExtensionAttribute]
public static Task`1<bool> GetJsExpressionAndEvaluateToBoolAsync(ReadOnlyMemory`1<char> expr, ScriptScopeContext scope, Action ifNone);
    [ExtensionAttribute]
public static JsToken GetCachedJsExpression(ReadOnlyMemory`1<char> expr, ScriptScopeContext scope);
    [ExtensionAttribute]
public static JsToken GetCachedJsExpression(string expr, ScriptScopeContext scope);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsExpression(string literal, JsToken& token);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsExpression(ReadOnlySpan`1<char> literal, JsToken& token);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsExpression(ReadOnlyMemory`1<char> literal, JsToken& token);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsExpression(ReadOnlySpan`1<char> literal, JsToken& token, bool filterExpression);
    [ExtensionAttribute]
private static ReadOnlySpan`1<char> ParseJsConditionalExpression(ReadOnlySpan`1<char> literal, JsToken test, JsConditionalExpression& expression);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseBinaryExpression(ReadOnlySpan`1<char> literal, JsExpression& expr, bool filterExpression);
    public static JsExpression CreateJsExpression(JsToken lhs, JsBinaryOperator op, JsToken rhs);
    [ExtensionAttribute]
private static int GetNextBinaryPrecedence(ReadOnlySpan`1<char> literal);
}
public class ServiceStack.Script.JsFilterExpressionStatement : JsStatement {
    [CompilerGeneratedAttribute]
private PageVariableFragment <FilterExpression>k__BackingField;
    public PageVariableFragment FilterExpression { get; }
    public JsFilterExpressionStatement(ReadOnlyMemory`1<char> originalText, JsToken expr, List`1<JsCallExpression> filters);
    public JsFilterExpressionStatement(string originalText, JsToken expr, JsCallExpression[] filters);
    [CompilerGeneratedAttribute]
public PageVariableFragment get_FilterExpression();
    protected bool Equals(JsFilterExpressionStatement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsGreaterThan : JsLogicOperator {
    public static JsGreaterThan Operator;
    public string Token { get; }
    private static JsGreaterThan();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsGreaterThanEqual : JsLogicOperator {
    public static JsGreaterThanEqual Operator;
    public string Token { get; }
    private static JsGreaterThanEqual();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsIdentifier : JsExpression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsIdentifier(string name);
    public JsIdentifier(ReadOnlySpan`1<char> name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    protected bool Equals(JsIdentifier other);
    public virtual Dictionary`2<string, object> ToJsAst();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class ServiceStack.Script.JsLessThan : JsLogicOperator {
    public static JsLessThan Operator;
    public string Token { get; }
    private static JsLessThan();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsLessThanEqual : JsLogicOperator {
    public static JsLessThanEqual Operator;
    public string Token { get; }
    private static JsLessThanEqual();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsLiteral : JsExpression {
    public static JsLiteral True;
    public static JsLiteral False;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public JsLiteral(object value);
    private static JsLiteral();
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual string ToRawString();
    public virtual int GetHashCode();
    protected bool Equals(JsLiteral other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
}
public class ServiceStack.Script.JsLogicalExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsLogicOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Right>k__BackingField;
    public JsLogicOperator Operator { get; public set; }
    public JsToken Left { get; public set; }
    public JsToken Right { get; public set; }
    public JsLogicalExpression(JsToken left, JsLogicOperator operator, JsToken right);
    [CompilerGeneratedAttribute]
public JsLogicOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(JsLogicOperator value);
    [CompilerGeneratedAttribute]
public JsToken get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(JsToken value);
    [CompilerGeneratedAttribute]
public JsToken get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(JsToken value);
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    protected bool Equals(JsLogicalExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Dictionary`2<string, object> ToJsAst();
}
public abstract class ServiceStack.Script.JsLogicOperator : JsBinaryOperator {
    public abstract virtual bool Test(object lhs, object rhs);
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsMemberExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsToken <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Computed>k__BackingField;
    public JsToken Object { get; }
    public JsToken Property { get; }
    public bool Computed { get; }
    public JsMemberExpression(JsToken object, JsToken property);
    public JsMemberExpression(JsToken object, JsToken property, bool computed);
    [CompilerGeneratedAttribute]
public JsToken get_Object();
    [CompilerGeneratedAttribute]
public JsToken get_Property();
    [CompilerGeneratedAttribute]
public bool get_Computed();
    public virtual string ToRawString();
    public virtual Dictionary`2<string, object> ToJsAst();
    public virtual object Evaluate(ScriptScopeContext scope);
    private static object PropValue(object targetValue, Type targetType, string name);
    private object GetValue(object targetValue, ScriptScopeContext scope);
    protected bool Equals(JsMemberExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsMinus : JsUnaryOperator {
    public static JsMinus Operator;
    public string Token { get; }
    private static JsMinus();
    public virtual string get_Token();
    public virtual object Evaluate(object target);
}
public class ServiceStack.Script.JsMod : JsBinaryOperator {
    public static JsMod Operator;
    public string Token { get; }
    private static JsMod();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsMultiplication : JsBinaryOperator {
    public static JsMultiplication Operator;
    public string Token { get; }
    private static JsMultiplication();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsNot : JsUnaryOperator {
    public static JsNot Operator;
    public string Token { get; }
    private static JsNot();
    public virtual string get_Token();
    public virtual object Evaluate(object target);
}
public class ServiceStack.Script.JsNotEquals : JsLogicOperator {
    public static JsNotEquals Operator;
    public string Token { get; }
    private static JsNotEquals();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public static class ServiceStack.Script.JsNull : object {
    public static string String;
    public static JsLiteral Value;
    private static JsNull();
}
public class ServiceStack.Script.JsObjectExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsProperty[] <Properties>k__BackingField;
    public JsProperty[] Properties { get; }
    public JsObjectExpression(JsProperty[] properties);
    public JsObjectExpression(IEnumerable`1<JsProperty> properties);
    [CompilerGeneratedAttribute]
public JsProperty[] get_Properties();
    public static string GetKey(JsToken token);
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual string ToRawString();
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsObjectExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class ServiceStack.Script.JsOperator : JsToken {
    public string Token { get; }
    public abstract virtual string get_Token();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
}
public class ServiceStack.Script.JsOr : JsLogicOperator {
    public static JsOr Operator;
    public string Token { get; }
    private static JsOr();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsPageBlockFragmentStatement : JsStatement {
    [CompilerGeneratedAttribute]
private PageBlockFragment <Block>k__BackingField;
    public PageBlockFragment Block { get; }
    public JsPageBlockFragmentStatement(PageBlockFragment block);
    [CompilerGeneratedAttribute]
public PageBlockFragment get_Block();
    protected bool Equals(JsPageBlockFragmentStatement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsPlus : JsUnaryOperator {
    public static JsPlus Operator;
    public string Token { get; }
    private static JsPlus();
    public virtual string get_Token();
    public virtual object Evaluate(object target);
}
public class ServiceStack.Script.JsProperty : object {
    [CompilerGeneratedAttribute]
private JsToken <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Shorthand>k__BackingField;
    public JsToken Key { get; }
    public JsToken Value { get; }
    public bool Shorthand { get; }
    public JsProperty(JsToken key, JsToken value);
    public JsProperty(JsToken key, JsToken value, bool shorthand);
    [CompilerGeneratedAttribute]
public JsToken get_Key();
    [CompilerGeneratedAttribute]
public JsToken get_Value();
    [CompilerGeneratedAttribute]
public bool get_Shorthand();
    protected bool Equals(JsProperty other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsSpreadElement : JsExpression {
    [CompilerGeneratedAttribute]
private JsToken <Argument>k__BackingField;
    public JsToken Argument { get; }
    public JsSpreadElement(JsToken argument);
    [CompilerGeneratedAttribute]
public JsToken get_Argument();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual string ToRawString();
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsSpreadElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class ServiceStack.Script.JsStatement : object {
}
public class ServiceStack.Script.JsStrictEquals : JsLogicOperator {
    public static JsStrictEquals Operator;
    public string Token { get; }
    private static JsStrictEquals();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsStrictNotEquals : JsLogicOperator {
    public static JsStrictNotEquals Operator;
    public string Token { get; }
    private static JsStrictNotEquals();
    public virtual bool Test(object lhs, object rhs);
    public virtual string get_Token();
}
public class ServiceStack.Script.JsSubtraction : JsBinaryOperator {
    public static JsSubtraction Operator;
    public string Token { get; }
    private static JsSubtraction();
    public virtual string get_Token();
    public virtual object Evaluate(object lhs, object rhs);
}
public class ServiceStack.Script.JsTemplateElement : object {
    [CompilerGeneratedAttribute]
private JsTemplateElementValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tail>k__BackingField;
    public JsTemplateElementValue Value { get; }
    public bool Tail { get; }
    public JsTemplateElement(string raw, string cooked, bool tail);
    public JsTemplateElement(JsTemplateElementValue value, bool tail);
    [CompilerGeneratedAttribute]
public JsTemplateElementValue get_Value();
    [CompilerGeneratedAttribute]
public bool get_Tail();
    protected bool Equals(JsTemplateElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsTemplateElementValue : object {
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Cooked>k__BackingField;
    public string Raw { get; }
    public string Cooked { get; }
    public JsTemplateElementValue(string raw, string cooked);
    [CompilerGeneratedAttribute]
public string get_Raw();
    [CompilerGeneratedAttribute]
public string get_Cooked();
    protected bool Equals(JsTemplateElementValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.JsTemplateLiteral : JsExpression {
    [CompilerGeneratedAttribute]
private JsTemplateElement[] <Quasis>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken[] <Expressions>k__BackingField;
    public JsTemplateElement[] Quasis { get; }
    public JsToken[] Expressions { get; }
    public JsTemplateLiteral(string cooked);
    public JsTemplateLiteral(JsTemplateElement[] quasis, JsToken[] expressions);
    [CompilerGeneratedAttribute]
public JsTemplateElement[] get_Quasis();
    [CompilerGeneratedAttribute]
public JsToken[] get_Expressions();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsTemplateLiteral other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class ServiceStack.Script.JsToken : object {
    public abstract virtual string ToRawString();
    public string JsonValue(object value);
    public virtual string ToString();
    public abstract virtual object Evaluate(ScriptScopeContext scope);
    public static object UnwrapValue(JsToken token);
}
[ExtensionAttribute]
public static class ServiceStack.Script.JsTokenUtils : object {
    private static Byte[] ValidNumericChars;
    private static Byte[] ValidVarNameChars;
    private static Byte[] OperatorChars;
    private static Byte[] ExpressionTerminatorChars;
    public static Byte[] NewLineUtf8;
    private static byte True;
    public static Dictionary`2<string, int> OperatorPrecedence;
    private static JsTokenUtils();
    public static int GetBinaryPrecedence(string token);
    [ExtensionAttribute]
public static bool IsNumericChar(char c);
    [ExtensionAttribute]
public static bool IsValidVarNameChar(char c);
    [ExtensionAttribute]
public static bool IsOperatorChar(char c);
    [ExtensionAttribute]
public static bool IsExpressionTerminatorChar(char c);
    [ExtensionAttribute]
public static JsUnaryOperator GetUnaryOperator(char c);
    [ExtensionAttribute]
public static bool FirstCharEquals(ReadOnlySpan`1<char> literal, char c);
    [ExtensionAttribute]
public static bool FirstCharEquals(string literal, char c);
    [ExtensionAttribute]
public static char SafeGetChar(ReadOnlySpan`1<char> literal, int index);
    [ExtensionAttribute]
public static int CountPrecedingOccurrences(ReadOnlySpan`1<char> literal, int index, char c);
    [ExtensionAttribute]
public static bool SafeCharEquals(ReadOnlySpan`1<char> literal, int index, char c);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AdvancePastPipeOperator(ReadOnlySpan`1<char> literal);
    [ExtensionAttribute]
public static char SafeGetChar(ReadOnlyMemory`1<char> literal, int index);
    [ExtensionAttribute]
public static bool IsEnd(char c);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Chop(ReadOnlyMemory`1<char> literal, char c);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Chop(ReadOnlySpan`1<char> literal, char c);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ChopNewLine(ReadOnlyMemory`1<char> literal);
    [ExtensionAttribute]
public static string ToJsAstType(Type type);
    [ExtensionAttribute]
public static Dictionary`2<string, object> ToJsAst(JsToken token);
    [ExtensionAttribute]
public static string ToJsAstString(JsToken token);
    [ExtensionAttribute]
internal static string DebugFirstChar(ReadOnlySpan`1<char> literal);
    [ExtensionAttribute]
internal static string DebugFirstChar(ReadOnlyMemory`1<char> literal);
    [ExtensionAttribute]
internal static string DebugChar(char c);
    [ExtensionAttribute]
internal static string DebugToken(JsToken token);
    [ExtensionAttribute]
internal static string DebugLiteral(ReadOnlySpan`1<char> literal);
    [ExtensionAttribute]
internal static string DebugLiteral(ReadOnlyMemory`1<char> literal);
    [ExtensionAttribute]
internal static string CookRawString(ReadOnlySpan`1<char> str, char quoteChar);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> TrimFirstNewLine(ReadOnlyMemory`1<char> literal);
    [ExtensionAttribute]
public static object Evaluate(JsToken token);
    [ExtensionAttribute]
public static bool EvaluateToBool(JsToken token, ScriptScopeContext scope);
    [AsyncStateMachineAttribute("ServiceStack.Script.JsTokenUtils/<EvaluateToBoolAsync>d__38")]
[ExtensionAttribute]
public static Task`1<bool> EvaluateToBoolAsync(JsToken token, ScriptScopeContext scope);
    [ExtensionAttribute]
public static bool EvaluateToBool(JsToken token, ScriptScopeContext scope, Nullable`1& result, Task`1& asyncResult);
    [ExtensionAttribute]
public static Task`1<object> EvaluateAsync(JsToken token, ScriptScopeContext scope);
    [ExtensionAttribute]
public static bool Evaluate(JsToken token, ScriptScopeContext scope, Object& result, Task`1& asyncResult);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsToken(ReadOnlySpan`1<char> literal, JsToken& token);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseJsToken(ReadOnlySpan`1<char> literal, JsToken& token, bool filterExpression);
    [ExtensionAttribute]
public static int IndexOfQuotedString(ReadOnlySpan`1<char> literal, char quoteChar, Boolean& hasEscapeChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseArgumentsList(ReadOnlySpan`1<char> literal, List`1& args);
    private static JsToken ParseJsTemplateLiteral(ReadOnlySpan`1<char> literal);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseArrowExpressionBody(ReadOnlySpan`1<char> literal, JsIdentifier[] args, JsArrowFunctionExpression& token);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseVariableDeclaration(ReadOnlySpan`1<char> literal, JsVariableDeclarationKind kind, JsVariableDeclaration& token);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseAssignmentExpression(ReadOnlySpan`1<char> literal, JsIdentifier id, JsAssignmentExpression& token);
    [ExtensionAttribute]
internal static SpanJsToken ParseJsMemberExpression(ReadOnlySpan`1<char> literal, JsToken node, bool filterExpression);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> EnsurePastChar(ReadOnlySpan`1<char> literal, char c);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseJsBinaryOperator(ReadOnlySpan`1<char> literal, JsBinaryOperator& op);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> ParseVarName(ReadOnlySpan`1<char> literal, ReadOnlySpan`1& varName);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ParseVarName(ReadOnlyMemory`1<char> literal, ReadOnlyMemory`1& varName);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseIdentifier(ReadOnlySpan`1<char> literal, JsToken& token);
}
public class ServiceStack.Script.JsUnaryExpression : JsExpression {
    [CompilerGeneratedAttribute]
private JsUnaryOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Argument>k__BackingField;
    public JsUnaryOperator Operator { get; }
    public JsToken Argument { get; }
    public JsUnaryExpression(JsUnaryOperator operator, JsToken argument);
    [CompilerGeneratedAttribute]
public JsUnaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public JsToken get_Argument();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
    protected bool Equals(JsUnaryExpression other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class ServiceStack.Script.JsUnaryOperator : JsOperator {
    public abstract virtual object Evaluate(object target);
}
public class ServiceStack.Script.JsVariableDeclaration : JsExpression {
    [CompilerGeneratedAttribute]
private JsVariableDeclarationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private JsDeclaration[] <Declarations>k__BackingField;
    public JsVariableDeclarationKind Kind { get; }
    public JsDeclaration[] Declarations { get; }
    public JsVariableDeclaration(JsVariableDeclarationKind kind, JsDeclaration[] declarations);
    [CompilerGeneratedAttribute]
public JsVariableDeclarationKind get_Kind();
    [CompilerGeneratedAttribute]
public JsDeclaration[] get_Declarations();
    protected bool Equals(JsVariableDeclaration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToRawString();
    public virtual object Evaluate(ScriptScopeContext scope);
    public virtual Dictionary`2<string, object> ToJsAst();
}
public enum ServiceStack.Script.JsVariableDeclarationKind : Enum {
    public int value__;
    public static JsVariableDeclarationKind Var;
    public static JsVariableDeclarationKind Let;
    public static JsVariableDeclarationKind Const;
}
public class ServiceStack.Script.KeyValuesScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken ct);
}
public static class ServiceStack.Script.Lisp : object {
    [CompilerGeneratedAttribute]
private static bool <AllowLoadingRemoteScripts>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <IndexGistId>k__BackingField;
    private static Interpreter GlobalInterpreter;
    public static Sym TRUE;
    public static Sym BOOL_TRUE;
    public static Sym BOOL_FALSE;
    private static Sym VERBOSE;
    private static Sym COND;
    private static Sym LAMBDA;
    private static Sym FN;
    private static Sym MACRO;
    private static Sym PROGN;
    private static Sym QUASIQUOTE;
    private static Sym QUOTE;
    private static Sym SETQ;
    private static Sym EXPORT;
    private static Sym BOUND;
    private static Sym BACK_QUOTE;
    private static Sym COMMAND_AT;
    private static Sym COMMA;
    private static Sym DOT;
    private static Sym LEFT_PAREN;
    private static Sym RIGHT_PAREN;
    private static Sym SINGLE_QUOTE;
    private static Sym APPEND;
    private static Sym CONS;
    internal static Sym LIST;
    private static Sym REST;
    private static Sym UNQUOTE;
    private static Sym UNQUOTE_SPLICING;
    private static Sym LEFT_BRACE;
    private static Sym RIGHT_BRACE;
    private static Sym HASH;
    private static Sym PERCENT;
    private static Sym NEWMAP;
    private static Sym ARG;
    private static Sym LEFT_BRACKET;
    private static Sym RIGHT_BRACKET;
    private static Dictionary`2<Sym, string> Quotes;
    public static string InitScript;
    public static string Prelude;
    public static string LispCore;
    public static string Extensions;
    public static bool AllowLoadingRemoteScripts { get; public set; }
    public static string IndexGistId { get; public set; }
    private static Lisp();
    [CompilerGeneratedAttribute]
public static bool get_AllowLoadingRemoteScripts();
    [CompilerGeneratedAttribute]
public static void set_AllowLoadingRemoteScripts(bool value);
    [CompilerGeneratedAttribute]
public static string get_IndexGistId();
    [CompilerGeneratedAttribute]
public static void set_IndexGistId(string value);
    public static void Reset();
    public static void Import(string lisp);
    public static void Import(ReadOnlyMemory`1<char> lisp);
    public static void Set(string symbolName, object value);
    public static void Init();
    public static Interpreter CreateInterpreter();
    private static Cell MapCar(Cell j, Func`2<object, object> fn);
    private static T FoldL(T x, Cell j, Func`3<T, object, T> fn);
    private static T FoldL(T x, IEnumerable j, Func`3<T, object, T> fn);
    private static Cell CdrCell(Cell x);
    public static Cell ToCons(IEnumerable seq);
    private static bool isTrue(object test);
    private static bool MakeArgTable(object arg, IDictionary`2<Sym, Arg> table);
    private static object ScanForArgs(object j, IDictionary`2<Sym, Arg> table);
    private static object ScanForQQ(object j, IDictionary`2<Sym, Arg> table, int level);
    public static object QqExpand(object x);
    public static object QqQuote(object x);
    private static object QqExpand0(object x, int level);
    private static Cell QqExpand1(object x, int level);
    private static object QqConcat(Cell x, object y);
    private static object QqConsCons(Cell x, object y);
    private static object QqExpand2(object y, int level);
    public static List`1<object> Parse(string lisp);
    public static List`1<object> Parse(ReadOnlyMemory`1<char> lisp);
    private static object Run(Interpreter interp, Reader reader);
    public static string Str(object x, bool quoteString);
    private static string Str4(object x, bool quoteString, int count, HashSet`1<Cell> printed);
    private static string StrListBody(Cell x, int count, HashSet`1<Cell> printed);
    public static void RunRepl(ScriptContext context);
}
public class ServiceStack.Script.LispEvalException : Exception {
    [CompilerGeneratedAttribute]
private List`1<string> <Trace>k__BackingField;
    public List`1<string> Trace { get; }
    public LispEvalException(string msg, object x, bool quoteString);
    [CompilerGeneratedAttribute]
public List`1<string> get_Trace();
    public virtual string ToString();
}
public class ServiceStack.Script.LispScriptMethods : ScriptMethods {
    public List`1<string> symbols(ScriptScopeContext scope);
    public List`1<GistLink> gistindex(ScriptScopeContext scope);
}
public class ServiceStack.Script.LispStatements : JsStatement {
    [CompilerGeneratedAttribute]
private Object[] <SExpressions>k__BackingField;
    public Object[] SExpressions { get; }
    public LispStatements(Object[] sExpressions);
    [CompilerGeneratedAttribute]
public Object[] get_SExpressions();
    protected bool Equals(LispStatements other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.MarkdownTable : object {
    [CompilerGeneratedAttribute]
private bool <IncludeHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRowNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Caption>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <HeaderTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> <Rows>k__BackingField;
    public bool IncludeHeaders { get; public set; }
    public bool IncludeRowNumbers { get; public set; }
    public string Caption { get; public set; }
    public List`1<string> Headers { get; }
    public List`1<Type> HeaderTypes { get; public set; }
    public List`1<List`1<string>> Rows { get; }
    [CompilerGeneratedAttribute]
public bool get_IncludeHeaders();
    [CompilerGeneratedAttribute]
public void set_IncludeHeaders(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRowNumbers();
    [CompilerGeneratedAttribute]
public void set_IncludeRowNumbers(bool value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Headers();
    [CompilerGeneratedAttribute]
public List`1<Type> get_HeaderTypes();
    [CompilerGeneratedAttribute]
public void set_HeaderTypes(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<string>> get_Rows();
    public string Render();
}
public class ServiceStack.Script.NoopScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.PageBlockFragment : PageFragment {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <OriginalText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Argument>k__BackingField;
    private string argumentString;
    [CompilerGeneratedAttribute]
private PageFragment[] <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private PageElseBlock[] <ElseBlocks>k__BackingField;
    public ReadOnlyMemory`1<char> OriginalText { get; internal set; }
    public string Name { get; }
    public ReadOnlyMemory`1<char> Argument { get; }
    public string ArgumentString { get; }
    public PageFragment[] Body { get; }
    public PageElseBlock[] ElseBlocks { get; }
    public PageBlockFragment(string originalText, string name, string argument, JsStatement body, IEnumerable`1<PageElseBlock> elseStatements);
    public PageBlockFragment(string originalText, string name, string argument, JsBlockStatement body, IEnumerable`1<PageElseBlock> elseStatements);
    public PageBlockFragment(string originalText, string name, string argument, List`1<PageFragment> body, List`1<PageElseBlock> elseStatements);
    public PageBlockFragment(string name, ReadOnlyMemory`1<char> argument, List`1<PageFragment> body, List`1<PageElseBlock> elseStatements);
    public PageBlockFragment(ReadOnlyMemory`1<char> originalText, string name, ReadOnlyMemory`1<char> argument, IEnumerable`1<PageFragment> body, IEnumerable`1<PageElseBlock> elseStatements);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_OriginalText();
    [CompilerGeneratedAttribute]
internal void set_OriginalText(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Argument();
    public string get_ArgumentString();
    [CompilerGeneratedAttribute]
public PageFragment[] get_Body();
    [CompilerGeneratedAttribute]
public PageElseBlock[] get_ElseBlocks();
    protected bool Equals(PageBlockFragment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.PageElseBlock : PageFragment {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private PageFragment[] <Body>k__BackingField;
    public ReadOnlyMemory`1<char> Argument { get; }
    public PageFragment[] Body { get; }
    public PageElseBlock(string argument, List`1<PageFragment> body);
    public PageElseBlock(string argument, JsStatement statement);
    public PageElseBlock(string argument, JsBlockStatement block);
    public PageElseBlock(ReadOnlyMemory`1<char> argument, IEnumerable`1<PageFragment> body);
    public PageElseBlock(ReadOnlyMemory`1<char> argument, PageFragment[] body);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Argument();
    [CompilerGeneratedAttribute]
public PageFragment[] get_Body();
    protected bool Equals(PageElseBlock other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.PageFormat : object {
    [CompilerGeneratedAttribute]
private string <ArgsPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgsSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, string> <EncodeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SharpPage, SharpPage> <ResolveLayout>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<PageResult, Exception, object> <OnExpressionException>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<PageResult, IRequest, Exception, Task> <OnViewException>k__BackingField;
    public string ArgsPrefix { get; public set; }
    public string ArgsSuffix { get; public set; }
    public string Extension { get; public set; }
    public string ContentType { get; public set; }
    public Func`2<object, string> EncodeValue { get; public set; }
    public Func`2<SharpPage, SharpPage> ResolveLayout { get; public set; }
    public Func`3<PageResult, Exception, object> OnExpressionException { get; public set; }
    public Func`4<PageResult, IRequest, Exception, Task> OnViewException { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ArgsPrefix();
    [CompilerGeneratedAttribute]
public void set_ArgsPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_ArgsSuffix();
    [CompilerGeneratedAttribute]
public void set_ArgsSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Func`2<object, string> get_EncodeValue();
    [CompilerGeneratedAttribute]
public void set_EncodeValue(Func`2<object, string> value);
    [CompilerGeneratedAttribute]
public Func`2<SharpPage, SharpPage> get_ResolveLayout();
    [CompilerGeneratedAttribute]
public void set_ResolveLayout(Func`2<SharpPage, SharpPage> value);
    [CompilerGeneratedAttribute]
public Func`3<PageResult, Exception, object> get_OnExpressionException();
    [CompilerGeneratedAttribute]
public void set_OnExpressionException(Func`3<PageResult, Exception, object> value);
    [CompilerGeneratedAttribute]
public Func`4<PageResult, IRequest, Exception, Task> get_OnViewException();
    [CompilerGeneratedAttribute]
public void set_OnViewException(Func`4<PageResult, IRequest, Exception, Task> value);
    public string DefaultEncodeValue(object value);
    public SharpPage DefaultResolveLayout(SharpPage page);
    public virtual object DefaultExpressionException(PageResult result, Exception ex);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageFormat/<DefaultViewException>d__36")]
public virtual Task DefaultViewException(PageResult pageResult, IRequest req, Exception ex);
}
public abstract class ServiceStack.Script.PageFragment : object {
}
public class ServiceStack.Script.PageJsBlockStatementFragment : PageFragment {
    [CompilerGeneratedAttribute]
private JsBlockStatement <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Quiet>k__BackingField;
    public JsBlockStatement Block { get; }
    public bool Quiet { get; public set; }
    public PageJsBlockStatementFragment(JsBlockStatement statement);
    [CompilerGeneratedAttribute]
public JsBlockStatement get_Block();
    [CompilerGeneratedAttribute]
public bool get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(bool value);
    protected bool Equals(PageJsBlockStatementFragment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.PageLispStatementFragment : PageFragment {
    [CompilerGeneratedAttribute]
private LispStatements <LispStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Quiet>k__BackingField;
    public LispStatements LispStatements { get; }
    public bool Quiet { get; public set; }
    public PageLispStatementFragment(LispStatements statements);
    [CompilerGeneratedAttribute]
public LispStatements get_LispStatements();
    [CompilerGeneratedAttribute]
public bool get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(bool value);
    protected bool Equals(PageLispStatementFragment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.PageResult : object {
    [CompilerGeneratedAttribute]
private SharpPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private SharpCodePage <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private SharpPage <LayoutPage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLayout>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptMethods> <ScriptMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptBlock> <ScriptBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SharpPage> <Partials>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`2<Stream, Task`1<Stream>>> <PageTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`2<Stream, Task`1<Stream>>> <OutputTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> <FilterTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExcludeFiltersNamed>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <LastFilterError>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <LastFilterStackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignExceptionsTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CatchExceptionsIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipFilterExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SkipExecutingFiltersIfError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RethrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaltExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableBuffering>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnValue <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PartialStackDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Evaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PageProcessed>k__BackingField;
    private Stack`1<string> stackTrace;
    private bool hasInit;
    private Dictionary`2<string, ScriptBlock> blocksMap;
    private string resultOutput;
    public SharpPage Page { get; }
    public SharpCodePage CodePage { get; }
    public SharpPage LayoutPage { get; public set; }
    public string Layout { get; public set; }
    public bool NoLayout { get; public set; }
    public object Model { get; public set; }
    public Dictionary`2<string, object> Args { get; public set; }
    public List`1<ScriptMethods> ScriptMethods { get; public set; }
    [ObsoleteAttribute("Use ScriptMethods")]
public List`1<ScriptMethods> TemplateFilters { get; }
    public List`1<ScriptBlock> ScriptBlocks { get; public set; }
    [ObsoleteAttribute("Use ScriptBlocks")]
public List`1<ScriptBlock> TemplateBlocks { get; }
    public Dictionary`2<string, SharpPage> Partials { get; public set; }
    public IDictionary`2<string, string> Options { get; public set; }
    public string ContentType { get; public set; }
    public List`1<Func`2<Stream, Task`1<Stream>>> PageTransformers { get; public set; }
    public List`1<Func`2<Stream, Task`1<Stream>>> OutputTransformers { get; public set; }
    public Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> FilterTransformers { get; public set; }
    public HashSet`1<string> ExcludeFiltersNamed { get; }
    public Exception LastFilterError { get; public set; }
    public String[] LastFilterStackTrace { get; public set; }
    public string AssignExceptionsTo { get; public set; }
    public string CatchExceptionsIn { get; public set; }
    public bool SkipFilterExecution { get; public set; }
    public Nullable`1<bool> SkipExecutingFiltersIfError { get; public set; }
    public bool RethrowExceptions { get; public set; }
    public bool HaltExecution { get; public set; }
    public bool DisableBuffering { get; public set; }
    public ReturnValue ReturnValue { get; public set; }
    public int StackDepth { get; internal set; }
    public int PartialStackDepth { get; internal set; }
    public long Evaluations { get; private set; }
    internal bool PageProcessed { get; internal set; }
    public ScriptContext Context { get; }
    public PageFormat Format { get; }
    public string VirtualPath { get; }
    public string ResultOutput { get; }
    public string Result { get; }
    private PageResult(PageFormat format);
    public PageResult(SharpPage page);
    public PageResult(SharpCodePage page);
    [CompilerGeneratedAttribute]
public SharpPage get_Page();
    [CompilerGeneratedAttribute]
public SharpCodePage get_CodePage();
    [CompilerGeneratedAttribute]
public SharpPage get_LayoutPage();
    [CompilerGeneratedAttribute]
public void set_LayoutPage(SharpPage value);
    [CompilerGeneratedAttribute]
public string get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(string value);
    [CompilerGeneratedAttribute]
public bool get_NoLayout();
    [CompilerGeneratedAttribute]
public void set_NoLayout(bool value);
    [CompilerGeneratedAttribute]
public object get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(object value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public List`1<ScriptMethods> get_ScriptMethods();
    [CompilerGeneratedAttribute]
public void set_ScriptMethods(List`1<ScriptMethods> value);
    public List`1<ScriptMethods> get_TemplateFilters();
    [CompilerGeneratedAttribute]
public List`1<ScriptBlock> get_ScriptBlocks();
    [CompilerGeneratedAttribute]
public void set_ScriptBlocks(List`1<ScriptBlock> value);
    public List`1<ScriptBlock> get_TemplateBlocks();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SharpPage> get_Partials();
    [CompilerGeneratedAttribute]
public void set_Partials(Dictionary`2<string, SharpPage> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(IDictionary`2<string, string> value);
    public string get_ContentType();
    public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public List`1<Func`2<Stream, Task`1<Stream>>> get_PageTransformers();
    [CompilerGeneratedAttribute]
public void set_PageTransformers(List`1<Func`2<Stream, Task`1<Stream>>> value);
    [CompilerGeneratedAttribute]
public List`1<Func`2<Stream, Task`1<Stream>>> get_OutputTransformers();
    [CompilerGeneratedAttribute]
public void set_OutputTransformers(List`1<Func`2<Stream, Task`1<Stream>>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> get_FilterTransformers();
    [CompilerGeneratedAttribute]
public void set_FilterTransformers(Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ExcludeFiltersNamed();
    [CompilerGeneratedAttribute]
public Exception get_LastFilterError();
    [CompilerGeneratedAttribute]
public void set_LastFilterError(Exception value);
    [CompilerGeneratedAttribute]
public String[] get_LastFilterStackTrace();
    [CompilerGeneratedAttribute]
public void set_LastFilterStackTrace(String[] value);
    [CompilerGeneratedAttribute]
public string get_AssignExceptionsTo();
    [CompilerGeneratedAttribute]
public void set_AssignExceptionsTo(string value);
    [CompilerGeneratedAttribute]
public string get_CatchExceptionsIn();
    [CompilerGeneratedAttribute]
public void set_CatchExceptionsIn(string value);
    [CompilerGeneratedAttribute]
public bool get_SkipFilterExecution();
    [CompilerGeneratedAttribute]
public void set_SkipFilterExecution(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SkipExecutingFiltersIfError();
    [CompilerGeneratedAttribute]
public void set_SkipExecutingFiltersIfError(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_RethrowExceptions();
    [CompilerGeneratedAttribute]
public void set_RethrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public bool get_HaltExecution();
    [CompilerGeneratedAttribute]
public void set_HaltExecution(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableBuffering();
    [CompilerGeneratedAttribute]
public void set_DisableBuffering(bool value);
    [CompilerGeneratedAttribute]
public ReturnValue get_ReturnValue();
    [CompilerGeneratedAttribute]
public void set_ReturnValue(ReturnValue value);
    [CompilerGeneratedAttribute]
public int get_StackDepth();
    [CompilerGeneratedAttribute]
internal void set_StackDepth(int value);
    [CompilerGeneratedAttribute]
public int get_PartialStackDepth();
    [CompilerGeneratedAttribute]
internal void set_PartialStackDepth(int value);
    [CompilerGeneratedAttribute]
public long get_Evaluations();
    [CompilerGeneratedAttribute]
private void set_Evaluations(long value);
    [CompilerGeneratedAttribute]
internal bool get_PageProcessed();
    [CompilerGeneratedAttribute]
internal void set_PageProcessed(bool value);
    public void AssertNextEvaluation();
    public void AssertNextPartial();
    public void ResetIterations();
    public PageResult AssignArgs(Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteToAsync>d__128")]
public sealed virtual Task WriteToAsync(Stream responseStream, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteToAsyncInternal>d__129")]
internal Task WriteToAsyncInternal(Stream outputStream, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteFragmentsAsync>d__130")]
internal Task WriteFragmentsAsync(ScriptScopeContext scope, IEnumerable`1<PageFragment> fragments, string callTrace, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WritePageFragmentAsync>d__131")]
public Task WritePageFragmentAsync(ScriptScopeContext scope, PageFragment fragment, CancellationToken token);
    public Task WriteStatementsAsync(ScriptScopeContext scope, IEnumerable`1<JsStatement> blockStatements, string callTrace, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteStatementsAsync>d__133")]
public Task WriteStatementsAsync(ScriptScopeContext scope, IEnumerable`1<JsStatement> blockStatements, CancellationToken token);
    public bool ShouldSkipFilterExecution(PageVariableFragment var);
    public bool ShouldSkipFilterExecution(PageFragment fragment);
    public bool ShouldSkipFilterExecution(JsStatement statement);
    public ScriptContext get_Context();
    public PageFormat get_Format();
    public string get_VirtualPath();
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<Init>d__144")]
public Task`1<PageResult> Init();
    private void InitPageArgs(Dictionary`2<string, object> pageArgs);
    private Task InitIfNewPage(SharpPage page);
    private void InitIfNewPage(SharpCodePage page);
    private void AssertInit();
    public Task WritePageAsync(SharpPage page, SharpCodePage codePage, ScriptScopeContext scope, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WritePageAsync>d__150")]
public Task WritePageAsync(SharpPage page, ScriptScopeContext scope, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WritePageAsyncInternal>d__151")]
internal Task WritePageAsyncInternal(SharpPage page, ScriptScopeContext scope, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteCodePageAsync>d__152")]
public Task WriteCodePageAsync(SharpCodePage page, ScriptScopeContext scope, CancellationToken token);
    internal Task WriteCodePageAsyncInternal(SharpCodePage page, ScriptScopeContext scope, CancellationToken token);
    private string toDebugString(object instance);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<WriteVarAsync>d__155")]
public Task WriteVarAsync(ScriptScopeContext scope, PageVariableFragment var, CancellationToken token);
    private Func`2<Stream, Task`1<Stream>> GetFilterTransformer(string name);
    private static Dictionary`2<string, object> GetPageParams(PageVariableFragment var);
    private ScriptScopeContext CreatePageContext(PageVariableFragment var, Stream outputStream);
    [AsyncStateMachineAttribute("ServiceStack.Script.PageResult/<EvaluateAsync>d__159")]
private Task`1<object> EvaluateAsync(PageVariableFragment var, ScriptScopeContext scope, CancellationToken token);
    private void ResetError();
    private static object UnwrapValue(object value);
    internal string CreateMissingFilterErrorMessage(string filterName);
    private MethodInvoker GetFilterAsBinding(string name, ScriptMethods& filter);
    private MethodInvoker GetContextFilterAsBinding(string name, ScriptMethods& filter);
    internal object InvokeFilter(MethodInvoker invoker, ScriptMethods filter, Object[] args, string binding);
    public ReadOnlySpan`1<char> ParseJsExpression(ScriptScopeContext scope, ReadOnlySpan`1<char> literal, JsToken& token);
    public ScriptBlock TryGetBlock(string name);
    public ScriptBlock GetBlock(string name);
    public ScriptScopeContext CreateScope(Stream outputStream);
    internal MethodInvoker GetFilterInvoker(string name, int argsCount, ScriptMethods& filter);
    internal MethodInvoker GetContextFilterInvoker(string name, int argsCount, ScriptMethods& filter);
    internal MethodInvoker GetContextBlockInvoker(string name, int argsCount, ScriptMethods& filter);
    private MethodInvoker GetInvoker(string name, int argsCount, InvokerType invokerType, ScriptMethods& filter);
    public object EvaluateIfToken(object value, ScriptScopeContext scope);
    internal bool TryGetValue(string name, ScriptScopeContext scope, bool argsOnly, Object& value);
    internal object GetValue(string name, ScriptScopeContext scope);
    internal object GetArgument(string name, ScriptScopeContext scope);
    public string get_ResultOutput();
    public string get_Result();
    public PageResult Execute();
    public PageResult Clone(SharpPage page);
    public sealed virtual void Dispose();
}
public class ServiceStack.Script.PageStringFragment : PageFragment {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <Value>k__BackingField;
    private string valueString;
    private ReadOnlyMemory`1<byte> valueUtf8;
    public ReadOnlyMemory`1<char> Value { get; public set; }
    public string ValueString { get; }
    public ReadOnlyMemory`1<byte> ValueUtf8 { get; }
    public PageStringFragment(string value);
    public PageStringFragment(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ReadOnlyMemory`1<char> value);
    public string get_ValueString();
    public ReadOnlyMemory`1<byte> get_ValueUtf8();
    protected bool Equals(PageStringFragment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.PageVariableFragment : PageFragment {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <OriginalText>k__BackingField;
    private ReadOnlyMemory`1<byte> originalTextUtf8;
    [CompilerGeneratedAttribute]
private JsToken <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private object <InitialValue>k__BackingField;
    [CompilerGeneratedAttribute]
private JsCallExpression <InitialExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private JsCallExpression[] <FilterExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastFilterName>k__BackingField;
    public ReadOnlyMemory`1<char> OriginalText { get; public set; }
    public ReadOnlyMemory`1<byte> OriginalTextUtf8 { get; }
    public JsToken Expression { get; }
    public string Binding { get; }
    public object InitialValue { get; }
    public JsCallExpression InitialExpression { get; }
    public JsCallExpression[] FilterExpressions { get; }
    internal string LastFilterName { get; }
    public PageVariableFragment(ReadOnlyMemory`1<char> originalText, JsToken expr, List`1<JsCallExpression> filterCommands);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_OriginalText();
    [CompilerGeneratedAttribute]
public void set_OriginalText(ReadOnlyMemory`1<char> value);
    public ReadOnlyMemory`1<byte> get_OriginalTextUtf8();
    [CompilerGeneratedAttribute]
public JsToken get_Expression();
    [CompilerGeneratedAttribute]
public string get_Binding();
    [CompilerGeneratedAttribute]
public object get_InitialValue();
    [CompilerGeneratedAttribute]
public JsCallExpression get_InitialExpression();
    [CompilerGeneratedAttribute]
public JsCallExpression[] get_FilterExpressions();
    [CompilerGeneratedAttribute]
internal string get_LastFilterName();
    public object Evaluate(ScriptScopeContext scope);
    protected bool Equals(PageVariableFragment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ServiceStack.Script.ParseRealNumber : MulticastDelegate {
    public ParseRealNumber(object object, IntPtr method);
    public virtual object Invoke(ReadOnlySpan`1<char> numLiteral);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<char> numLiteral, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.Script.PartialScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.ProtectedScriptBlocks : object {
    public sealed virtual void Register(ScriptContext context);
}
public class ServiceStack.Script.ProtectedScripts : ScriptMethods {
    public static ProtectedScripts Instance;
    private static String[] AllCacheNames;
    private IVirtualPathProvider VirtualFiles { get; }
    private static ProtectedScripts();
    public object resolve(ScriptScopeContext scope, object type);
    public object default(string typeName);
    public object new(string typeName);
    public object new(string typeName, List`1<object> constructorArgs);
    public object set(object instance, Dictionary`2<string, object> args);
    private Type[] typeGenericTypes(string typeName);
    private Type[] typeGenericTypes(List`1<string> genericArgs);
    private static List`1<string> typeGenericArgs(string typeName);
    public object createInstance(Type type);
    public object createInstance(Type type, List`1<object> constructorArgs);
    private Type AssertCanCreateType(Type type);
    private ConstructorInfo ResolveConstructor(Type type, Type[] argTypes);
    public Type getType(object instance);
    public string typeQualifiedName(Type type);
    public static string TypeNotFoundErrorMessage(string typeName);
    public Type assertTypeOf(string name);
    public Type typeof(string typeName);
    public Type typeofProgId(string name);
    public object call(object instance, string name);
    internal string callKey(Type type, string name, List`1<object> args);
    private static string argTypesString(List`1<object> args);
    private static void appendArgTypes(StringBuilder sb, List`1<object> args);
    public object call(object instance, string name, List`1<object> args);
    private MethodInfo ResolveMethod(Type type, string methodName, Type[] argTypes, Nullable`1<int> argsCount, Delegate& invokerDelegate);
    public ObjectActivator Constructor(string qualifiedConstructorName);
    public Delegate C(string qualifiedMethodName);
    public Delegate F(string qualifiedMethodName);
    public Delegate F(string qualifiedMethodName, List`1<object> args);
    public Delegate Function(string qualifiedMethodName);
    public Delegate Function(string qualifiedMethodName, List`1<object> args);
    private Delegate ResolveFunction(string name, Type[] argTypes);
    private static string MethodNotExists(string methodName);
    public MemoryVirtualFiles vfsMemory();
    public FileSystemVirtualFiles vfsFileSystem(string dirPath);
    public GistVirtualFiles vfsGist(string gistId);
    public GistVirtualFiles vfsGist(string gistId, string accessToken);
    public string osPaths(string path);
    public IVirtualFile resolveFile(ScriptScopeContext scope, string virtualPath);
    public IVirtualFile ResolveFile(string filterName, ScriptScopeContext scope, string virtualPath);
    public IVirtualFile ResolveFile(IVirtualPathProvider virtualFiles, string fromVirtualPath, string virtualPath);
    [AsyncStateMachineAttribute("ServiceStack.Script.ProtectedScripts/<includeFile>d__41")]
public Task includeFile(ScriptScopeContext scope, string virtualPath);
    [AsyncStateMachineAttribute("ServiceStack.Script.ProtectedScripts/<ifDebugIncludeScript>d__42")]
public Task ifDebugIncludeScript(ScriptScopeContext scope, string virtualPath);
    private IVirtualPathProvider get_VirtualFiles();
    [AliasAttribute("allFiles")]
public IEnumerable`1<IVirtualFile> vfsAllFiles();
    [AliasAttribute("allRootFiles")]
public IEnumerable`1<IVirtualFile> vfsAllRootFiles();
    [AliasAttribute("allRootDirectories")]
public IEnumerable`1<IVirtualDirectory> vfsAllRootDirectories();
    [AliasAttribute("combinePath")]
public string vfsCombinePath(string basePath, string relativePath);
    [AliasAttribute("findFilesInDirectory")]
public IEnumerable`1<IVirtualFile> dirFilesFind(string dirPath, string globPattern);
    [AliasAttribute("findFiles")]
public IEnumerable`1<IVirtualFile> filesFind(string globPattern);
    [AliasAttribute("writeFile")]
public string fileWrite(string virtualPath, object contents);
    [AliasAttribute("appendToFile")]
public string fileAppend(string virtualPath, object contents);
    [AliasAttribute("deleteFile")]
public string fileDelete(string virtualPath);
    [AliasAttribute("deleteFile")]
public string dirDelete(string virtualPath);
    [AliasAttribute("fileTextContents")]
public string fileReadAll(string virtualPath);
    [AliasAttribute("fileBytesContent")]
public Byte[] fileReadAllBytes(string virtualPath);
    public IEnumerable`1<IVirtualFile> allFiles();
    public IEnumerable`1<IVirtualFile> allFiles(IVirtualPathProvider vfs);
    public IEnumerable`1<IVirtualFile> allRootFiles();
    public IEnumerable`1<IVirtualFile> allRootFiles(IVirtualPathProvider vfs);
    public IEnumerable`1<IVirtualDirectory> allRootDirectories();
    public IEnumerable`1<IVirtualDirectory> allRootDirectories(IVirtualPathProvider vfs);
    public string combinePath(string basePath, string relativePath);
    public string combinePath(IVirtualPathProvider vfs, string basePath, string relativePath);
    public IVirtualDirectory dir(string virtualPath);
    public IVirtualDirectory dir(IVirtualPathProvider vfs, string virtualPath);
    public bool dirExists(string virtualPath);
    public bool dirExists(IVirtualPathProvider vfs, string virtualPath);
    public IVirtualFile dirFile(string dirPath, string fileName);
    public IVirtualFile dirFile(IVirtualPathProvider vfs, string dirPath, string fileName);
    public IEnumerable`1<IVirtualFile> dirFiles(string dirPath);
    public IEnumerable`1<IVirtualFile> dirFiles(IVirtualPathProvider vfs, string dirPath);
    public IVirtualDirectory dirDirectory(string dirPath, string dirName);
    public IVirtualDirectory dirDirectory(IVirtualPathProvider vfs, string dirPath, string dirName);
    public IEnumerable`1<IVirtualDirectory> dirDirectories(string dirPath);
    public IEnumerable`1<IVirtualDirectory> dirDirectories(IVirtualPathProvider vfs, string dirPath);
    public IEnumerable`1<IVirtualFile> findFilesInDirectory(string dirPath, string globPattern);
    public IEnumerable`1<IVirtualFile> findFilesInDirectory(IVirtualPathProvider vfs, string dirPath, string globPattern);
    public IEnumerable`1<IVirtualFile> findFiles(string globPattern);
    public IEnumerable`1<IVirtualFile> dirFindFiles(IVirtualDirectory dir, string globPattern);
    public IEnumerable`1<IVirtualFile> dirFindFiles(IVirtualDirectory dir, string globPattern, int maxDepth);
    public IEnumerable`1<IVirtualFile> findFiles(IVirtualPathProvider vfs, string globPattern);
    public IEnumerable`1<IVirtualFile> findFiles(IVirtualPathProvider vfs, string globPattern, int maxDepth);
    public bool fileExists(string virtualPath);
    public bool fileExists(IVirtualPathProvider vfs, string virtualPath);
    public IVirtualFile file(string virtualPath);
    public IVirtualFile file(IVirtualPathProvider vfs, string virtualPath);
    public string writeFile(string virtualPath, object contents);
    public string writeFile(IVirtualPathProvider vfs, string virtualPath, object contents);
    public object writeFiles(IVirtualPathProvider vfs, Dictionary`2<string, object> files);
    public object writeTextFiles(IVirtualPathProvider vfs, Dictionary`2<string, string> textFiles);
    public string appendToFile(string virtualPath, object contents);
    public string appendToFile(IVirtualPathProvider vfs, string virtualPath, object contents);
    public string deleteFile(string virtualPath);
    public string deleteFile(IVirtualPathProvider vfs, string virtualPath);
    public string deleteDirectory(string virtualPath);
    public string deleteDirectory(IVirtualPathProvider vfs, string virtualPath);
    public string fileTextContents(string virtualPath);
    public string fileTextContents(IVirtualPathProvider vfs, string virtualPath);
    public object fileContents(IVirtualPathProvider vfs, string virtualPath);
    public object fileContents(object file);
    public string textContents(IVirtualFile file);
    public Byte[] fileBytesContent(string virtualPath);
    public Byte[] fileBytesContent(IVirtualPathProvider vfs, string virtualPath);
    public Byte[] bytesContent(IVirtualFile file);
    public string fileHash(string virtualPath);
    public string fileHash(IVirtualPathProvider vfs, string virtualPath);
    public string fileHash(IVirtualFile file);
    public bool fileIsBinary(IVirtualFile file);
    public string fileContentType(IVirtualFile file);
    public Task urlContents(ScriptScopeContext scope, string url);
    public Task urlContents(ScriptScopeContext scope, string url, object options);
    public Task includeUrl(ScriptScopeContext scope, string url);
    [AsyncStateMachineAttribute("ServiceStack.Script.ProtectedScripts/<includeUrl>d__114")]
public Task includeUrl(ScriptScopeContext scope, string url, object options);
    private static HttpWebRequest initWebRequest(string url, Dictionary`2<string, object> scopedParams);
    private static HttpWebRequest postWebRequestSync(string url, Dictionary`2<string, object> scopedParams);
    public string urlTextContents(ScriptScopeContext scope, string url);
    public string urlTextContents(ScriptScopeContext scope, string url, object options);
    public ReadOnlyMemory`1<byte> urlBytesContents(ScriptScopeContext scope, string url, object options);
    private static string ConvertDataTypeToContentType(string dataType);
    private static string ConvertDataToString(object data, string contentType);
    public static string CreateCacheKey(string url, Dictionary`2<string, object> options);
    public Task fileContentsWithCache(ScriptScopeContext scope, string virtualPath);
    public Task fileContentsWithCache(ScriptScopeContext scope, string virtualPath, object options);
    public Task includeFileWithCache(ScriptScopeContext scope, string virtualPath);
    [AsyncStateMachineAttribute("ServiceStack.Script.ProtectedScripts/<includeFileWithCache>d__126")]
public Task includeFileWithCache(ScriptScopeContext scope, string virtualPath, object options);
    public Task urlContentsWithCache(ScriptScopeContext scope, string url);
    public Task urlContentsWithCache(ScriptScopeContext scope, string url, object options);
    public Task includeUrlWithCache(ScriptScopeContext scope, string url);
    [AsyncStateMachineAttribute("ServiceStack.Script.ProtectedScripts/<includeUrlWithCache>d__130")]
public Task includeUrlWithCache(ScriptScopeContext scope, string url, object options);
    public List`1<ScriptMethodInfo> scriptMethods(ScriptScopeContext scope);
    public List`1<string> scriptMethodNames(ScriptScopeContext scope);
    public List`1<string> scriptMethodSignatures(ScriptScopeContext scope);
    private ScriptMethodInfo[] filterMethods(MethodInfo[] methodInfos);
    public List`1<string> methods(object o);
    public ScriptMethodInfo[] methodTypes(object o);
    public List`1<string> staticMethods(object o);
    public ScriptMethodInfo[] staticMethodTypes(object o);
    public ScriptMethodInfo[] allMethodTypes(object o);
    public MemberInfo[] allMemberInfos(object o);
    internal IDictionary GetCache(string cacheName);
    public object cacheClear(ScriptScopeContext scope, object cacheNames);
    public object invalidateAllCaches(ScriptScopeContext scope);
    public string sh(ScriptScopeContext scope, string arguments);
    public string sh(ScriptScopeContext scope, string arguments, Dictionary`2<string, object> options);
    public string proc(ScriptScopeContext scope, string fileName);
    public string proc(ScriptScopeContext scope, string fileName, Dictionary`2<string, object> options);
    public string exePath(string exeName);
    public StopExecution exit(int exitCode);
    public IgnoreResult inspectVars(object vars);
    private static string check(string target);
    private static string winpath(string path);
    private static string unixpath(string path);
    public string mv(ScriptScopeContext scope, string from, string to);
    public string cp(ScriptScopeContext scope, string from, string to);
    public string xcopy(ScriptScopeContext scope, string from, string to);
    public string rm(ScriptScopeContext scope, string from, string to);
    public string rmdir(ScriptScopeContext scope, string target);
    public string mkdir(ScriptScopeContext scope, string target);
    public string cat(ScriptScopeContext scope, string target);
    public string touch(ScriptScopeContext scope, string target);
    public FileScripts File();
    public DirectoryScripts Directory();
    private static string HexHash(HashAlgorithm hash, string s);
    private static string HexHash(HashAlgorithm hash, Byte[] bytes);
    public string sha1(object target);
    public string sha256(object target);
    public string sha512(object target);
    public IgnoreResult Delete(string path);
    public IgnoreResult Delete(IOScript os, string path);
    public bool Exists(string path);
    public bool Exists(IOScript os, string path);
    public IgnoreResult Move(string from, string to);
    public IgnoreResult Move(IOScript os, string from, string to);
    public IgnoreResult Copy(string from, string to);
    public IgnoreResult Copy(IOScript os, string from, string to);
    public IgnoreResult Create(string from, string to);
    public IgnoreResult Create(FileScripts fs, string from, string to);
    public IgnoreResult Decrypt(string path);
    public IgnoreResult Decrypt(FileScripts fs, string path);
    public IgnoreResult Encrypt(string path);
    public IgnoreResult Encrypt(FileScripts fs, string path);
    public IgnoreResult Replace(string from, string to, string backup);
    public IgnoreResult Replace(FileScripts fs, string from, string to, string backup);
    public Byte[] ReadAllBytes(string path);
    public Byte[] ReadAllBytes(FileScripts fs, string path);
    public String[] ReadAllLines(string path);
    public String[] ReadAllLines(FileScripts fs, string path);
    public string ReadAllText(string path);
    public string ReadAllText(FileScripts fs, string path);
    public IgnoreResult WriteAllBytes(string path, Byte[] bytes);
    public IgnoreResult WriteAllBytes(FileScripts fs, string path, Byte[] bytes);
    public IgnoreResult WriteAllLines(string path, String[] lines);
    public IgnoreResult WriteAllLines(FileScripts fs, string path, String[] lines);
    public IgnoreResult WriteAllText(string path, string text);
    public IgnoreResult WriteAllText(FileScripts fs, string path, string text);
    public IgnoreResult AppendAllLines(string path, String[] lines);
    public IgnoreResult AppendAllLines(FileScripts fs, string path, String[] lines);
    public IgnoreResult AppendAllText(string path, string text);
    public IgnoreResult AppendAllText(FileScripts fs, string path, string text);
    public IgnoreResult CreateDirectory(string path);
    public IgnoreResult CreateDirectory(DirectoryScripts ds, string path);
    public String[] GetDirectories(string path);
    public String[] GetDirectories(DirectoryScripts ds, string path);
    public String[] GetFiles(string path);
    public String[] GetFiles(DirectoryScripts ds, string path);
    public String[] GetLogicalDrives();
    public String[] GetLogicalDrives(DirectoryScripts ds);
    public string GetCurrentDirectory();
    public string GetCurrentDirectory(DirectoryScripts ds);
    public string GetDirectoryRoot(string path);
    public string GetDirectoryRoot(DirectoryScripts ds, string path);
}
public class ServiceStack.Script.RawScriptBlock : ScriptBlock {
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    [AsyncStateMachineAttribute("ServiceStack.Script.RawScriptBlock/<WriteAsync>d__4")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
    private static void Capture(ScriptScopeContext scope, PageBlockFragment block, PageStringFragment strFragment);
}
public class ServiceStack.Script.RawString : object {
    public static RawString Empty;
    private string value;
    public RawString(string value);
    private static RawString();
    public sealed virtual string ToRawString();
}
public class ServiceStack.Script.ReturnValue : object {
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Args>k__BackingField;
    public object Result { get; }
    public Dictionary`2<string, object> Args { get; }
    public ReturnValue(object result, Dictionary`2<string, object> args);
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Args();
}
public class ServiceStack.Script.ScopeVars : Dictionary`2<string, object> {
    public ScopeVars(IDictionary`2<string, object> dictionary);
    public ScopeVars(IDictionary`2<string, object> dictionary, IEqualityComparer`1<string> comparer);
    public ScopeVars(IEqualityComparer`1<string> comparer);
    public ScopeVars(int capacity);
    public ScopeVars(int capacity, IEqualityComparer`1<string> comparer);
}
public class ServiceStack.Script.ScriptABlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptBBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public abstract class ServiceStack.Script.ScriptBlock : object {
    [CompilerGeneratedAttribute]
private ScriptLanguage <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ISharpPages <Pages>k__BackingField;
    public ScriptLanguage Body { get; }
    public ScriptContext Context { get; public set; }
    public ISharpPages Pages { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public virtual ScriptLanguage get_Body();
    public sealed virtual void Configure(ScriptContext context);
    [CompilerGeneratedAttribute]
public ScriptContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ScriptContext value);
    [CompilerGeneratedAttribute]
public ISharpPages get_Pages();
    [CompilerGeneratedAttribute]
public void set_Pages(ISharpPages value);
    public abstract virtual string get_Name();
    protected virtual string GetCallTrace(PageBlockFragment fragment);
    protected virtual string GetElseCallTrace(PageElseBlock fragment);
    public abstract virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptBlock/<WriteAsync>d__17")]
protected virtual Task WriteAsync(ScriptScopeContext scope, PageFragment[] body, string callTrace, CancellationToken cancel);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptBlock/<WriteAsync>d__18")]
protected virtual Task WriteAsync(ScriptScopeContext scope, JsStatement[] body, string callTrace, CancellationToken cancel);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptBlock/<WriteBodyAsync>d__19")]
protected virtual Task WriteBodyAsync(ScriptScopeContext scope, PageBlockFragment fragment, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptBlock/<WriteElseAsync>d__20")]
protected virtual Task WriteElseAsync(ScriptScopeContext scope, PageElseBlock fragment, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptBlock/<WriteElseAsync>d__21")]
protected Task WriteElseAsync(ScriptScopeContext scope, PageElseBlock[] elseBlocks, CancellationToken cancel);
    protected bool CanExportScopeArgs(object element);
    protected int AssertWithinMaxQuota(int value);
}
public class ServiceStack.Script.ScriptButtonBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptCode : ScriptLanguage {
    public static ScriptLanguage Language;
    public string Name { get; }
    private static ScriptCode();
    public virtual string get_Name();
    public virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptCode/<WritePageFragmentAsync>d__5")]
public virtual Task`1<bool> WritePageFragmentAsync(ScriptScopeContext scope, PageFragment fragment, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptCode/<WriteStatementAsync>d__6")]
public virtual Task`1<bool> WriteStatementAsync(ScriptScopeContext scope, JsStatement statement, CancellationToken token);
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptCodeUtils : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use CodeSharpPage")]
public static SharpPage CodeBlock(ScriptContext context, string code);
    [ExtensionAttribute]
public static SharpPage CodeSharpPage(ScriptContext context, string code);
    [ExtensionAttribute]
private static void AssertCode(ScriptContext context);
    private static PageResult GetCodePageResult(ScriptContext context, string code, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static string RenderCode(ScriptContext context, string code, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptCodeUtils/<RenderCodeAsync>d__5")]
[ExtensionAttribute]
public static Task`1<string> RenderCodeAsync(ScriptContext context, string code, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static JsBlockStatement ParseCode(ScriptContext context, string code);
    [ExtensionAttribute]
public static JsBlockStatement ParseCode(ScriptContext context, ReadOnlyMemory`1<char> code);
    public static string EnsureReturn(string code);
    [ExtensionAttribute]
public static T EvaluateCode(ScriptContext context, string code, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static object EvaluateCode(ScriptContext context, string code, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptCodeUtils/<EvaluateCodeAsync>d__11`1")]
[ExtensionAttribute]
public static Task`1<T> EvaluateCodeAsync(ScriptContext context, string code, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptCodeUtils/<EvaluateCodeAsync>d__12")]
[ExtensionAttribute]
public static Task`1<object> EvaluateCodeAsync(ScriptContext context, string code, Dictionary`2<string, object> args);
    [ExtensionAttribute]
internal static JsStatement[] ParseCodeStatements(ScriptContext context, ReadOnlyMemory`1<char> code);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ParseCodeScriptBlock(ReadOnlyMemory`1<char> literal, ScriptContext context, PageBlockFragment& blockFragment);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> FromStartToPreviousLine(ReadOnlyMemory`1<char> literal, int cursorPos, int lineLength);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> ToLineStart(ReadOnlyMemory`1<char> literal, int cursorPos, int lineLength);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> ToLineStart(ReadOnlyMemory`1<char> literal, int cursorPos, int lineLength, int statementPos);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> ParseCodeBody(ReadOnlyMemory`1<char> literal, ReadOnlyMemory`1<char> blockName, ReadOnlyMemory`1& body);
    [ExtensionAttribute]
internal static ReadOnlyMemory`1<char> ParseCodeElseBlock(ReadOnlyMemory`1<char> literal, ReadOnlyMemory`1<char> blockName, ReadOnlyMemory`1& elseArgument, ReadOnlyMemory`1& elseBody);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> ParseExpression(ReadOnlySpan`1<char> literal, JsToken& expr, List`1& filters);
    [ExtensionAttribute]
private static void AddExpression(List`1<JsStatement> ret, ReadOnlyMemory`1<char> originalText, JsToken expr, List`1<JsCallExpression> filters);
}
public static class ServiceStack.Script.ScriptConfig : object {
    [CompilerGeneratedAttribute]
private static HashSet`1<Type> <FatalExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<Type> <CaptureAndEvaluateExceptionsToNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static CultureInfo <DefaultCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultDateFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultDateTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultTimeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultFileCacheExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultUrlCacheExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultJsConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparison <DefaultStringComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultTableClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DefaultErrorClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AllowUnixPipeSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AllowAssignmentExpressions>k__BackingField;
    public static ParseRealNumber ParseRealNumber;
    public static HashSet`1<Type> FatalExceptions { get; public set; }
    public static HashSet`1<Type> CaptureAndEvaluateExceptionsToNull { get; public set; }
    public static CultureInfo DefaultCulture { get; public set; }
    public static string DefaultDateFormat { get; public set; }
    public static string DefaultDateTimeFormat { get; public set; }
    public static string DefaultTimeFormat { get; public set; }
    public static TimeSpan DefaultFileCacheExpiry { get; public set; }
    public static TimeSpan DefaultUrlCacheExpiry { get; public set; }
    public static string DefaultIndent { get; public set; }
    public static string DefaultNewLine { get; public set; }
    public static string DefaultJsConfig { get; public set; }
    public static StringComparison DefaultStringComparison { get; public set; }
    public static string DefaultTableClassName { get; public set; }
    public static string DefaultErrorClassName { get; public set; }
    public static bool AllowUnixPipeSyntax { get; public set; }
    public static bool AllowAssignmentExpressions { get; public set; }
    private static ScriptConfig();
    [CompilerGeneratedAttribute]
public static HashSet`1<Type> get_FatalExceptions();
    [CompilerGeneratedAttribute]
public static void set_FatalExceptions(HashSet`1<Type> value);
    [CompilerGeneratedAttribute]
public static HashSet`1<Type> get_CaptureAndEvaluateExceptionsToNull();
    [CompilerGeneratedAttribute]
public static void set_CaptureAndEvaluateExceptionsToNull(HashSet`1<Type> value);
    [CompilerGeneratedAttribute]
public static CultureInfo get_DefaultCulture();
    [CompilerGeneratedAttribute]
public static void set_DefaultCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public static string get_DefaultDateFormat();
    [CompilerGeneratedAttribute]
public static void set_DefaultDateFormat(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultDateTimeFormat();
    [CompilerGeneratedAttribute]
public static void set_DefaultDateTimeFormat(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultTimeFormat();
    [CompilerGeneratedAttribute]
public static void set_DefaultTimeFormat(string value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_DefaultFileCacheExpiry();
    [CompilerGeneratedAttribute]
public static void set_DefaultFileCacheExpiry(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_DefaultUrlCacheExpiry();
    [CompilerGeneratedAttribute]
public static void set_DefaultUrlCacheExpiry(TimeSpan value);
    [CompilerGeneratedAttribute]
public static string get_DefaultIndent();
    [CompilerGeneratedAttribute]
public static void set_DefaultIndent(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultNewLine();
    [CompilerGeneratedAttribute]
public static void set_DefaultNewLine(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultJsConfig();
    [CompilerGeneratedAttribute]
public static void set_DefaultJsConfig(string value);
    [CompilerGeneratedAttribute]
public static StringComparison get_DefaultStringComparison();
    [CompilerGeneratedAttribute]
public static void set_DefaultStringComparison(StringComparison value);
    [CompilerGeneratedAttribute]
public static string get_DefaultTableClassName();
    [CompilerGeneratedAttribute]
public static void set_DefaultTableClassName(string value);
    [CompilerGeneratedAttribute]
public static string get_DefaultErrorClassName();
    [CompilerGeneratedAttribute]
public static void set_DefaultErrorClassName(string value);
    [CompilerGeneratedAttribute]
public static bool get_AllowUnixPipeSyntax();
    [CompilerGeneratedAttribute]
public static void set_AllowUnixPipeSyntax(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AllowAssignmentExpressions();
    [CompilerGeneratedAttribute]
public static void set_AllowAssignmentExpressions(bool value);
    public static CultureInfo CreateCulture();
}
public static class ServiceStack.Script.ScriptConstants : object {
    public static string DefaultCulture;
    public static string DefaultDateFormat;
    public static string DefaultDateTimeFormat;
    public static string DefaultTimeFormat;
    public static string DefaultFileCacheExpiry;
    public static string DefaultUrlCacheExpiry;
    public static string DefaultIndent;
    public static string DefaultNewLine;
    public static string DefaultJsConfig;
    public static string DefaultStringComparison;
    public static string DefaultTableClassName;
    public static string DefaultErrorClassName;
    public static string Debug;
    public static string AssignError;
    public static string CatchError;
    public static string IfErrorReturn;
    public static string HtmlEncode;
    public static string Model;
    public static string Page;
    public static string Partial;
    public static string TempFilePath;
    public static string Index;
    public static string Comparer;
    public static string Map;
    public static string Request;
    public static string PathInfo;
    public static string PathBase;
    public static string PathArgs;
    public static string Dto;
    public static string It;
    public static string Field;
    public static string AssetsBase;
    public static string Format;
    public static string BaseUrl;
    public static string PartialArg;
    public static string Global;
    public static string Return;
    public static string ErrorCode;
    public static string ErrorMessage;
    [CompilerGeneratedAttribute]
private static IRawString <EmptyRawString>k__BackingField;
    [CompilerGeneratedAttribute]
private static IRawString <TrueRawString>k__BackingField;
    [CompilerGeneratedAttribute]
private static IRawString <FalseRawString>k__BackingField;
    public static IRawString EmptyRawString { get; }
    public static IRawString TrueRawString { get; }
    public static IRawString FalseRawString { get; }
    private static ScriptConstants();
    [CompilerGeneratedAttribute]
public static IRawString get_EmptyRawString();
    [CompilerGeneratedAttribute]
public static IRawString get_TrueRawString();
    [CompilerGeneratedAttribute]
public static IRawString get_FalseRawString();
}
public class ServiceStack.Script.ScriptContext : object {
    [CompilerGeneratedAttribute]
private List`1<PageFormat> <PageFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexPage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultLayoutPage>k__BackingField;
    [CompilerGeneratedAttribute]
private ISharpPages <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualPathProvider <VirtualFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualFiles <CacheFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <ScanTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Assembly> <ScanAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Assembly> <ScriptAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <ScriptTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ScriptNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowScriptingOfAllTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <ScriptTypeNameMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <ScriptTypeQualifiedNameMap>k__BackingField;
    [CompilerGeneratedAttribute]
private IContainer <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private IAppSettings <AppSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`2<string, string>> <Preprocessors>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptLanguage <DefaultScriptLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptLanguage> <ScriptLanguages>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptLanguage[] <ScriptLanguagesArray>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptMethods> <ScriptMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptMethods> <InsertScriptMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptBlock> <ScriptBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptBlock> <InsertScriptBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <CodePages>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExcludeFiltersNamed>k__BackingField;
    private Dictionary`2<string, ScriptLanguage> scriptLanguagesMap;
    private Dictionary`2<string, ScriptBlock> blocksMap;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, object> <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ReadOnlyMemory`1<char>, object> <CacheMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, Tuple`2<DateTime, object>> <ExpiringCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ReadOnlyMemory`1<char>, JsToken> <JsTokenCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, Action`3<ScriptScopeContext, object, object>> <AssignExpressionCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Type, Tuple`2<MethodInfo, MethodInvoker>> <CodePageInvokers>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, string> <PathMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IScriptPlugin> <Plugins>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IScriptPlugin> <InsertPlugins>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <FileFilterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> <FilterTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckForModifiedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CheckForModifiedPagesAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <InvalidateCachesBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenderExpressionExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssignExceptionsTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipExecutingFiltersIfError>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxQuota>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStackDepth>k__BackingField;
    private ILog log;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <RemoveNewLineAfterFiltersNamed>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <OnlyEvaluateFiltersWhenSkippingPageFilterExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScriptLanguage> <ParseAsLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<PageVariableFragment, ReadOnlyMemory`1<byte>> <OnUnhandledExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<PageResult, Exception> <OnRenderException>k__BackingField;
    private SharpPage emptyPage;
    private static InMemoryVirtualFile emptyFile;
    [CompilerGeneratedAttribute]
private Action`1<ScriptContext> <OnAfterPlugins>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInit>k__BackingField;
    public List`1<PageFormat> PageFormats { get; public set; }
    public string IndexPage { get; public set; }
    public string DefaultLayoutPage { get; public set; }
    public ISharpPages Pages { get; public set; }
    public IVirtualPathProvider VirtualFiles { get; public set; }
    public IVirtualFiles CacheFiles { get; public set; }
    public Dictionary`2<string, object> Args { get; }
    public bool DebugMode { get; public set; }
    public List`1<Type> ScanTypes { get; public set; }
    public List`1<Assembly> ScanAssemblies { get; public set; }
    public List`1<Assembly> ScriptAssemblies { get; public set; }
    public List`1<Type> ScriptTypes { get; public set; }
    public List`1<string> ScriptNamespaces { get; public set; }
    public bool AllowScriptingOfAllTypes { get; public set; }
    public Dictionary`2<string, Type> ScriptTypeNameMap { get; }
    public Dictionary`2<string, Type> ScriptTypeQualifiedNameMap { get; }
    public IContainer Container { get; public set; }
    public IAppSettings AppSettings { get; public set; }
    public List`1<Func`2<string, string>> Preprocessors { get; }
    public ScriptLanguage DefaultScriptLanguage { get; public set; }
    public List`1<ScriptLanguage> ScriptLanguages { get; }
    internal ScriptLanguage[] ScriptLanguagesArray { get; private set; }
    public List`1<ScriptMethods> ScriptMethods { get; }
    public List`1<ScriptMethods> InsertScriptMethods { get; }
    public List`1<ScriptBlock> ScriptBlocks { get; }
    public List`1<ScriptBlock> InsertScriptBlocks { get; }
    public Dictionary`2<string, Type> CodePages { get; }
    public HashSet`1<string> ExcludeFiltersNamed { get; }
    public ConcurrentDictionary`2<string, object> Cache { get; }
    public ConcurrentDictionary`2<ReadOnlyMemory`1<char>, object> CacheMemory { get; }
    public ConcurrentDictionary`2<string, Tuple`2<DateTime, object>> ExpiringCache { get; }
    public ConcurrentDictionary`2<ReadOnlyMemory`1<char>, JsToken> JsTokenCache { get; }
    public ConcurrentDictionary`2<string, Action`3<ScriptScopeContext, object, object>> AssignExpressionCache { get; }
    public ConcurrentDictionary`2<Type, Tuple`2<MethodInfo, MethodInvoker>> CodePageInvokers { get; }
    public ConcurrentDictionary`2<string, string> PathMappings { get; }
    public List`1<IScriptPlugin> Plugins { get; }
    public List`1<IScriptPlugin> InsertPlugins { get; }
    public HashSet`1<string> FileFilterNames { get; }
    public Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> FilterTransformers { get; public set; }
    public bool CheckForModifiedPages { get; public set; }
    public Nullable`1<TimeSpan> CheckForModifiedPagesAfter { get; public set; }
    public Nullable`1<DateTime> InvalidateCachesBefore { get; public set; }
    public bool RenderExpressionExceptions { get; public set; }
    public string AssignExceptionsTo { get; public set; }
    public bool SkipExecutingFiltersIfError { get; public set; }
    public int MaxQuota { get; public set; }
    public long MaxEvaluations { get; public set; }
    public int MaxStackDepth { get; public set; }
    public ILog Log { get; }
    public HashSet`1<string> RemoveNewLineAfterFiltersNamed { get; public set; }
    public HashSet`1<string> OnlyEvaluateFiltersWhenSkippingPageFilterExecution { get; public set; }
    public Dictionary`2<string, ScriptLanguage> ParseAsLanguage { get; public set; }
    public Func`2<PageVariableFragment, ReadOnlyMemory`1<byte>> OnUnhandledExpression { get; public set; }
    public Action`2<PageResult, Exception> OnRenderException { get; public set; }
    public DefaultScripts DefaultMethods { get; }
    public ProtectedScripts ProtectedMethods { get; }
    public HtmlScripts HtmlMethods { get; }
    public SharpPage EmptyPage { get; }
    public InMemoryVirtualFile EmptyFile { get; }
    public Action`1<ScriptContext> OnAfterPlugins { get; public set; }
    public bool HasInit { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<PageFormat> get_PageFormats();
    [CompilerGeneratedAttribute]
public void set_PageFormats(List`1<PageFormat> value);
    [CompilerGeneratedAttribute]
public string get_IndexPage();
    [CompilerGeneratedAttribute]
public void set_IndexPage(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultLayoutPage();
    [CompilerGeneratedAttribute]
public void set_DefaultLayoutPage(string value);
    [CompilerGeneratedAttribute]
public ISharpPages get_Pages();
    [CompilerGeneratedAttribute]
public void set_Pages(ISharpPages value);
    [CompilerGeneratedAttribute]
public IVirtualPathProvider get_VirtualFiles();
    [CompilerGeneratedAttribute]
public void set_VirtualFiles(IVirtualPathProvider value);
    [CompilerGeneratedAttribute]
public IVirtualFiles get_CacheFiles();
    [CompilerGeneratedAttribute]
public void set_CacheFiles(IVirtualFiles value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Args();
    [CompilerGeneratedAttribute]
public bool get_DebugMode();
    [CompilerGeneratedAttribute]
public void set_DebugMode(bool value);
    public PageFormat GetFormat(string extension);
    [CompilerGeneratedAttribute]
public List`1<Type> get_ScanTypes();
    [CompilerGeneratedAttribute]
public void set_ScanTypes(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<Assembly> get_ScanAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScanAssemblies(List`1<Assembly> value);
    [CompilerGeneratedAttribute]
public List`1<Assembly> get_ScriptAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScriptAssemblies(List`1<Assembly> value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_ScriptTypes();
    [CompilerGeneratedAttribute]
public void set_ScriptTypes(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ScriptNamespaces();
    [CompilerGeneratedAttribute]
public void set_ScriptNamespaces(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_AllowScriptingOfAllTypes();
    [CompilerGeneratedAttribute]
public void set_AllowScriptingOfAllTypes(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_ScriptTypeNameMap();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_ScriptTypeQualifiedNameMap();
    [CompilerGeneratedAttribute]
public IContainer get_Container();
    [CompilerGeneratedAttribute]
public void set_Container(IContainer value);
    [CompilerGeneratedAttribute]
public IAppSettings get_AppSettings();
    [CompilerGeneratedAttribute]
public void set_AppSettings(IAppSettings value);
    [CompilerGeneratedAttribute]
public List`1<Func`2<string, string>> get_Preprocessors();
    [CompilerGeneratedAttribute]
public ScriptLanguage get_DefaultScriptLanguage();
    [CompilerGeneratedAttribute]
public void set_DefaultScriptLanguage(ScriptLanguage value);
    [CompilerGeneratedAttribute]
public List`1<ScriptLanguage> get_ScriptLanguages();
    [CompilerGeneratedAttribute]
internal ScriptLanguage[] get_ScriptLanguagesArray();
    [CompilerGeneratedAttribute]
private void set_ScriptLanguagesArray(ScriptLanguage[] value);
    [CompilerGeneratedAttribute]
public List`1<ScriptMethods> get_ScriptMethods();
    [CompilerGeneratedAttribute]
public List`1<ScriptMethods> get_InsertScriptMethods();
    [CompilerGeneratedAttribute]
public List`1<ScriptBlock> get_ScriptBlocks();
    [CompilerGeneratedAttribute]
public List`1<ScriptBlock> get_InsertScriptBlocks();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_CodePages();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ExcludeFiltersNamed();
    public ScriptLanguage GetScriptLanguage(string name);
    public ScriptBlock GetBlock(string name);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, object> get_Cache();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<ReadOnlyMemory`1<char>, object> get_CacheMemory();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, Tuple`2<DateTime, object>> get_ExpiringCache();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<ReadOnlyMemory`1<char>, JsToken> get_JsTokenCache();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, Action`3<ScriptScopeContext, object, object>> get_AssignExpressionCache();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<Type, Tuple`2<MethodInfo, MethodInvoker>> get_CodePageInvokers();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, string> get_PathMappings();
    [CompilerGeneratedAttribute]
public List`1<IScriptPlugin> get_Plugins();
    [CompilerGeneratedAttribute]
public List`1<IScriptPlugin> get_InsertPlugins();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_FileFilterNames();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> get_FilterTransformers();
    [CompilerGeneratedAttribute]
public void set_FilterTransformers(Dictionary`2<string, Func`2<Stream, Task`1<Stream>>> value);
    [CompilerGeneratedAttribute]
public bool get_CheckForModifiedPages();
    [CompilerGeneratedAttribute]
public void set_CheckForModifiedPages(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CheckForModifiedPagesAfter();
    [CompilerGeneratedAttribute]
public void set_CheckForModifiedPagesAfter(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_InvalidateCachesBefore();
    [CompilerGeneratedAttribute]
public void set_InvalidateCachesBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_RenderExpressionExceptions();
    [CompilerGeneratedAttribute]
public void set_RenderExpressionExceptions(bool value);
    [CompilerGeneratedAttribute]
public string get_AssignExceptionsTo();
    [CompilerGeneratedAttribute]
public void set_AssignExceptionsTo(string value);
    [CompilerGeneratedAttribute]
public bool get_SkipExecutingFiltersIfError();
    [CompilerGeneratedAttribute]
public void set_SkipExecutingFiltersIfError(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxQuota();
    [CompilerGeneratedAttribute]
public void set_MaxQuota(int value);
    [CompilerGeneratedAttribute]
public long get_MaxEvaluations();
    [CompilerGeneratedAttribute]
public void set_MaxEvaluations(long value);
    [CompilerGeneratedAttribute]
public int get_MaxStackDepth();
    [CompilerGeneratedAttribute]
public void set_MaxStackDepth(int value);
    public ILog get_Log();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_RemoveNewLineAfterFiltersNamed();
    [CompilerGeneratedAttribute]
public void set_RemoveNewLineAfterFiltersNamed(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_OnlyEvaluateFiltersWhenSkippingPageFilterExecution();
    [CompilerGeneratedAttribute]
public void set_OnlyEvaluateFiltersWhenSkippingPageFilterExecution(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ScriptLanguage> get_ParseAsLanguage();
    [CompilerGeneratedAttribute]
public void set_ParseAsLanguage(Dictionary`2<string, ScriptLanguage> value);
    [CompilerGeneratedAttribute]
public Func`2<PageVariableFragment, ReadOnlyMemory`1<byte>> get_OnUnhandledExpression();
    [CompilerGeneratedAttribute]
public void set_OnUnhandledExpression(Func`2<PageVariableFragment, ReadOnlyMemory`1<byte>> value);
    [CompilerGeneratedAttribute]
public Action`2<PageResult, Exception> get_OnRenderException();
    [CompilerGeneratedAttribute]
public void set_OnRenderException(Action`2<PageResult, Exception> value);
    public SharpPage GetPage(string virtualPath);
    public DefaultScripts get_DefaultMethods();
    public ProtectedScripts get_ProtectedMethods();
    public ProtectedScripts AssertProtectedMethods();
    public HtmlScripts get_HtmlMethods();
    public void GetPage(string fromVirtualPath, string virtualPath, SharpPage& page, SharpCodePage& codePage);
    public bool TryGetPage(string fromVirtualPath, string virtualPath, SharpPage& page, SharpCodePage& codePage);
    public SharpPage get_EmptyPage();
    public InMemoryVirtualFile get_EmptyFile();
    public SharpPage OneTimePage(string contents, string ext);
    public SharpCodePage GetCodePage(string virtualPath);
    public string SetPathMapping(string prefix, string mapPath, string toPath);
    public void RemovePathMapping(string prefix, string mapPath);
    public string GetPathMapping(string prefix, string key);
    public ScriptContext RemoveFilters(Predicate`1<ScriptMethods> match);
    public ScriptContext RemoveBlocks(Predicate`1<ScriptBlock> match);
    public ScriptContext RemovePlugins(Predicate`1<IScriptPlugin> match);
    [CompilerGeneratedAttribute]
public Action`1<ScriptContext> get_OnAfterPlugins();
    [CompilerGeneratedAttribute]
public void set_OnAfterPlugins(Action`1<ScriptContext> value);
    [CompilerGeneratedAttribute]
public bool get_HasInit();
    [CompilerGeneratedAttribute]
private void set_HasInit(bool value);
    public ScriptContext Init();
    internal void InitMethod(ScriptMethods method);
    internal void InitBlock(ScriptBlock block);
    public ScriptContext ScanType(Type type);
    public Action`3<ScriptScopeContext, object, object> GetAssignExpression(Type targetType, ReadOnlyMemory`1<char> expression);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private ScriptContext <Init>b__232_0();
    [CompilerGeneratedAttribute]
private ISharpPages <Init>b__232_1();
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptContextUtils : object {
    public static string ErrorNoReturn;
    private static ScriptContextUtils();
    public static void ThrowNoReturn();
    public static bool ShouldRethrow(Exception e);
    public static Exception HandleException(Exception e, PageResult pageResult);
    [ExtensionAttribute]
public static bool EvaluateResult(PageResult pageResult, Object& returnValue);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptContextUtils/<EvaluateResultAsync>d__5")]
[ExtensionAttribute]
public static Task`1<Tuple`2<bool, object>> EvaluateResultAsync(PageResult pageResult);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptContextUtils/<RenderAsync>d__6")]
[ExtensionAttribute]
public static Task RenderAsync(PageResult pageResult, Stream stream, CancellationToken token);
    [ExtensionAttribute]
public static void RenderToStream(PageResult pageResult, Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptContextUtils/<RenderToStreamAsync>d__8")]
[ExtensionAttribute]
public static Task RenderToStreamAsync(PageResult pageResult, Stream stream);
    [ExtensionAttribute]
public static string RenderScript(PageResult pageResult);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptContextUtils/<RenderScriptAsync>d__10")]
[ExtensionAttribute]
public static Task`1<string> RenderScriptAsync(PageResult pageResult, CancellationToken token);
    [ExtensionAttribute]
public static ScriptScopeContext CreateScope(ScriptContext context, Dictionary`2<string, object> args, ScriptMethods functions, ScriptBlock blocks);
}
public class ServiceStack.Script.ScriptDdBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptDivBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptDlBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptDtBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptEmBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptException : Exception {
    [CompilerGeneratedAttribute]
private PageResult <PageResult>k__BackingField;
    public PageResult PageResult { get; }
    public string PageStackTrace { get; }
    public ScriptException(PageResult pageResult);
    [CompilerGeneratedAttribute]
public PageResult get_PageResult();
    public string get_PageStackTrace();
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptExtensions : object {
    [ExtensionAttribute]
public static object InStopFilter(Exception ex, ScriptScopeContext scope, object options);
    [ExtensionAttribute]
public static string AsString(object str);
}
public class ServiceStack.Script.ScriptFormBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public abstract class ServiceStack.Script.ScriptHtmlBlock : ScriptBlock {
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public string Name { get; }
    public ScriptLanguage Body { get; }
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Name();
    public virtual ScriptLanguage get_Body();
    public abstract virtual string get_Tag();
    [CompilerGeneratedAttribute]
public virtual string get_Suffix();
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptHtmlBlock/<WriteAsync>d__9")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
public class ServiceStack.Script.ScriptIBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptImgBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptInputBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public abstract class ServiceStack.Script.ScriptLanguage : object {
    public static ScriptLanguage Verbatim { get; }
    public string Name { get; }
    public string LineComment { get; }
    public static ScriptLanguage get_Verbatim();
    public abstract virtual string get_Name();
    public virtual string get_LineComment();
    public List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body);
    public abstract virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
    public virtual Task`1<bool> WritePageFragmentAsync(ScriptScopeContext scope, PageFragment fragment, CancellationToken token);
    public virtual Task`1<bool> WriteStatementAsync(ScriptScopeContext scope, JsStatement statement, CancellationToken token);
    public virtual PageBlockFragment ParseVerbatimBlock(string blockName, ReadOnlyMemory`1<char> argument, ReadOnlyMemory`1<char> body);
    public static object UnwrapValue(object value);
}
public class ServiceStack.Script.ScriptLiBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptLinkBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptLisp : ScriptLanguage {
    public static ScriptLanguage Language;
    public string Name { get; }
    public string LineComment { get; }
    private static ScriptLisp();
    public virtual string get_Name();
    public virtual string get_LineComment();
    public sealed virtual void Configure(ScriptContext context);
    public virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptLisp/<WritePageFragmentAsync>d__8")]
public virtual Task`1<bool> WritePageFragmentAsync(ScriptScopeContext scope, PageFragment fragment, CancellationToken token);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptLisp/<WriteStatementAsync>d__9")]
public virtual Task`1<bool> WriteStatementAsync(ScriptScopeContext scope, JsStatement statement, CancellationToken token);
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptLispUtils : object {
    [ExtensionAttribute]
public static Interpreter GetLispInterpreter(ScriptScopeContext scope);
    [ExtensionAttribute]
public static Interpreter GetLispInterpreter(PageResult pageResult, ScriptScopeContext scope);
    [ExtensionAttribute]
public static SharpPage LispSharpPage(ScriptContext context, string lisp);
    [ExtensionAttribute]
private static void AssertLisp(ScriptContext context);
    private static PageResult GetLispPageResult(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static string RenderLisp(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptLispUtils/<RenderLispAsync>d__6")]
[ExtensionAttribute]
public static Task`1<string> RenderLispAsync(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static LispStatements ParseLisp(ScriptContext context, string lisp);
    [ExtensionAttribute]
public static LispStatements ParseLisp(ScriptContext context, ReadOnlyMemory`1<char> lisp);
    [ExtensionAttribute]
public static T EvaluateLisp(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static object EvaluateLisp(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptLispUtils/<EvaluateLispAsync>d__11`1")]
[ExtensionAttribute]
public static Task`1<T> EvaluateLispAsync(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptLispUtils/<EvaluateLispAsync>d__12")]
[ExtensionAttribute]
public static Task`1<object> EvaluateLispAsync(ScriptContext context, string lisp, Dictionary`2<string, object> args);
    public static string EnsureReturn(string lisp);
}
public class ServiceStack.Script.ScriptMetaBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptMethodInfo : object {
    private MethodInfo methodInfo;
    private ParameterInfo[] params;
    private string signature;
    public string Name { get; }
    public string FirstParam { get; }
    public string FirstParamType { get; }
    public string ReturnType { get; }
    public int ParamCount { get; }
    public String[] RemainingParams { get; }
    public String[] ParamNames { get; }
    public String[] ParamTypes { get; }
    public string Return { get; }
    public string Body { get; }
    public string ScriptSignature { get; }
    public string Signature { get; }
    public ScriptMethodInfo(MethodInfo methodInfo, ParameterInfo[] params);
    public MethodInfo GetMethodInfo();
    public string get_Name();
    public string get_FirstParam();
    public string get_FirstParamType();
    public string get_ReturnType();
    public int get_ParamCount();
    public String[] get_RemainingParams();
    public String[] get_ParamNames();
    public String[] get_ParamTypes();
    public static List`1<ScriptMethodInfo> GetScriptMethods(Type scriptMethodsType, Func`2<MethodInfo, bool> where);
    public static ScriptMethodInfo Create(MethodInfo mi);
    public string get_Return();
    public string get_Body();
    public string get_ScriptSignature();
    public string get_Signature();
    public virtual string ToString();
}
public class ServiceStack.Script.ScriptMethods : object {
    [CompilerGeneratedAttribute]
private ScriptContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ISharpPages <Pages>k__BackingField;
    private Dictionary`2<string, MethodInfo> lookupIndex;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, MethodInvoker> <InvokerCache>k__BackingField;
    public ScriptContext Context { get; public set; }
    public ISharpPages Pages { get; public set; }
    public ConcurrentDictionary`2<string, MethodInvoker> InvokerCache { get; }
    [CompilerGeneratedAttribute]
public ScriptContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ScriptContext value);
    [CompilerGeneratedAttribute]
public ISharpPages get_Pages();
    [CompilerGeneratedAttribute]
public void set_Pages(ISharpPages value);
    private string CacheKey(InvokerType type, string methodName, int argsCount);
    private MethodInfo GetFilterMethod(string cacheKey);
    public List`1<MethodInfo> QueryFilters(string filterName);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, MethodInvoker> get_InvokerCache();
    public MethodInvoker GetInvoker(string name, int argsCount, InvokerType type);
}
public class ServiceStack.Script.ScriptOlBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptOptionBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptPBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public static class ServiceStack.Script.ScriptPreprocessors : object {
    public static string TransformCodeBlocks(string script);
    public static string TransformStatementBody(string body);
}
public class ServiceStack.Script.ScriptScopeContext : ValueType {
    [CompilerGeneratedAttribute]
private PageResult <PageResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <ScopedParams>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <OutputStream>k__BackingField;
    public PageResult PageResult { get; }
    public SharpPage Page { get; }
    public SharpCodePage CodePage { get; }
    public ScriptContext Context { get; }
    public Dictionary`2<string, object> ScopedParams { get; internal set; }
    public Stream OutputStream { get; }
    public ScriptScopeContext(PageResult pageResult, Stream outputStream, Dictionary`2<string, object> scopedParams);
    public ScriptScopeContext(ScriptContext context, Dictionary`2<string, object> scopedParams);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PageResult get_PageResult();
    public SharpPage get_Page();
    public SharpCodePage get_CodePage();
    public ScriptContext get_Context();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_ScopedParams();
    [CompilerGeneratedAttribute]
internal void set_ScopedParams(Dictionary`2<string, object> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Stream get_OutputStream();
    public ScriptScopeContext Clone();
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptScopeContextUtils : object {
    [ExtensionAttribute]
public static StopExecution ReturnValue(ScriptScopeContext scope, object returnValue, Dictionary`2<string, object> returnArgs);
    [ExtensionAttribute]
public static object GetValue(ScriptScopeContext scope, string name);
    [ExtensionAttribute]
public static object GetArgument(ScriptScopeContext scope, string name);
    [ExtensionAttribute]
public static bool TryGetValue(ScriptScopeContext scope, string name, Object& value);
    [ExtensionAttribute]
public static bool TryGetMethod(ScriptScopeContext scope, string name, int fnArgValuesCount, Delegate& fn, ScriptMethods& scriptMethod, Boolean& requiresScope);
    [ExtensionAttribute]
public static object EvaluateExpression(ScriptScopeContext scope, string expr);
    [ExtensionAttribute]
public static ScriptScopeContext CreateScopedContext(ScriptScopeContext scope, string template, Dictionary`2<string, object> scopeParams, bool cachePage);
    [ExtensionAttribute]
public static Task WritePageAsync(ScriptScopeContext scope);
    [ExtensionAttribute]
public static ScriptScopeContext ScopeWithParams(ScriptScopeContext parentContext, Dictionary`2<string, object> scopedParams);
    [ExtensionAttribute]
public static ScriptScopeContext ScopeWith(ScriptScopeContext parentContext, Dictionary`2<string, object> scopedParams, Stream outputStream);
    [ExtensionAttribute]
public static ScriptScopeContext ScopeWithStream(ScriptScopeContext scope, Stream stream);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptScopeContextUtils/<WritePageAsync>d__11")]
[ExtensionAttribute]
public static Task WritePageAsync(ScriptScopeContext scope, SharpPage page, SharpCodePage codePage, Dictionary`2<string, object> pageParams, CancellationToken token);
    [ExtensionAttribute]
public static void InvokeAssignExpression(ScriptScopeContext scope, string assignExpr, object target, object value);
}
public class ServiceStack.Script.ScriptScriptBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptSelectBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptSpanBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptStrongBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptStyleBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public string Suffix { get; }
    public virtual string get_Tag();
    public virtual string get_Suffix();
}
public class ServiceStack.Script.ScriptTableBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTBodyBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTdBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTemplate : ScriptLanguage {
    public static ScriptLanguage Language;
    public string Name { get; }
    private static ScriptTemplate();
    public virtual string get_Name();
    public virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptTemplate/<WritePageFragmentAsync>d__5")]
public virtual Task`1<bool> WritePageFragmentAsync(ScriptScopeContext scope, PageFragment fragment, CancellationToken token);
}
[ExtensionAttribute]
public static class ServiceStack.Script.ScriptTemplateUtils : object {
    internal static char FilterSep;
    internal static char StatementsSep;
    [CompilerGeneratedAttribute]
private static ConcurrentDictionary`2<string, Func`3<ScriptScopeContext, object, object>> <BinderCache>k__BackingField;
    private static Type[] ObjectArg;
    public static ConcurrentDictionary`2<string, Func`3<ScriptScopeContext, object, object>> BinderCache { get; }
    private static ScriptTemplateUtils();
    [ExtensionAttribute]
public static SharpPage SharpScriptPage(ScriptContext context, string code);
    [ExtensionAttribute]
public static SharpPage TemplateSharpPage(ScriptContext context, string code);
    [ExtensionAttribute]
public static string RenderScript(ScriptContext context, string script, ScriptException& error);
    [ExtensionAttribute]
public static string EvaluateScript(ScriptContext context, string script, ScriptException& error);
    [ExtensionAttribute]
public static string RenderScript(ScriptContext context, string script, Dictionary`2<string, object> args, ScriptException& error);
    [ExtensionAttribute]
public static string EvaluateScript(ScriptContext context, string script, Dictionary`2<string, object> args, ScriptException& error);
    [ExtensionAttribute]
public static string RenderScript(ScriptContext context, string script, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static string EvaluateScript(ScriptContext context, string script, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static Task`1<string> RenderScriptAsync(ScriptContext context, string script, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptTemplateUtils/<EvaluateScriptAsync>d__9")]
[ExtensionAttribute]
public static Task`1<string> EvaluateScriptAsync(ScriptContext context, string script, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static T Evaluate(ScriptContext context, string script, Dictionary`2<string, object> args);
    [ExtensionAttribute]
public static object Evaluate(ScriptContext context, string script, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptTemplateUtils/<EvaluateAsync>d__12`1")]
[ExtensionAttribute]
public static Task`1<T> EvaluateAsync(ScriptContext context, string script, Dictionary`2<string, object> args);
    [AsyncStateMachineAttribute("ServiceStack.Script.ScriptTemplateUtils/<EvaluateAsync>d__13")]
[ExtensionAttribute]
public static Task`1<object> EvaluateAsync(ScriptContext context, string script, Dictionary`2<string, object> args);
    public static List`1<PageFragment> ParseTemplate(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ParseTemplateBody(ReadOnlyMemory`1<char> literal, ReadOnlyMemory`1<char> blockName, ReadOnlyMemory`1& body);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ParseTemplateElseBlock(ReadOnlyMemory`1<char> literal, string blockName, ReadOnlyMemory`1& elseArgument, ReadOnlyMemory`1& elseBody);
    [ExtensionAttribute]
public static List`1<PageFragment> ParseScript(ScriptContext context, ReadOnlyMemory`1<char> text);
    [ExtensionAttribute]
public static List`1<PageFragment> ParseTemplate(ScriptContext context, ReadOnlyMemory`1<char> text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ParseTemplateScriptBlock(ReadOnlyMemory`1<char> literal, ScriptContext context, PageBlockFragment& blockFragment);
    [ExtensionAttribute]
public static IRawString ToRawString(string value);
    [CompilerGeneratedAttribute]
public static ConcurrentDictionary`2<string, Func`3<ScriptScopeContext, object, object>> get_BinderCache();
    public static Func`3<ScriptScopeContext, object, object> GetMemberExpression(Type targetType, ReadOnlyMemory`1<char> expression);
    public static Func`3<ScriptScopeContext, object, object> Compile(Type type, ReadOnlyMemory`1<char> expr);
    private static Expression CreateBindingExpression(Type type, ReadOnlyMemory`1<char> expr, ParameterExpression scope, ParameterExpression instance);
    public static MethodInfo CreateConvertMethod(Type toType);
    public static Action`3<ScriptScopeContext, object, object> CompileAssign(Type type, ReadOnlyMemory`1<char> expr);
    private static Expression CreateStringIndexExpression(Expression body, JsToken binding, ParameterExpression scope, Expression valueExpr, Type& currType);
    public static object EvaluateBinding(ScriptScopeContext scope, JsToken token);
    public static T EvaluateBindingAs(ScriptScopeContext scope, JsToken token);
    private static PropertyInfo AssertProperty(Type currType, string prop, ReadOnlyMemory`1<char> expr);
    [ExtensionAttribute]
public static bool IsWhiteSpace(char c);
    [CompilerGeneratedAttribute]
internal static int <ParseTemplate>g__nextPos|20_0(<>c__DisplayClass20_0& );
}
public class ServiceStack.Script.ScriptTextAreaBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTFootBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTHeadBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptTrBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptUlBlock : ScriptHtmlBlock {
    public string Tag { get; }
    public virtual string get_Tag();
}
public class ServiceStack.Script.ScriptVerbatim : ScriptLanguage {
    public static ScriptLanguage Language;
    public string Name { get; }
    private static ScriptVerbatim();
    public virtual string get_Name();
    public virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
}
public abstract class ServiceStack.Script.SharpCodePage : object {
    [CompilerGeneratedAttribute]
private string <VirtualPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private SharpPage <LayoutPage>k__BackingField;
    [CompilerGeneratedAttribute]
private PageFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ISharpPages <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptScopeContext <Scope>k__BackingField;
    private MethodInfo renderMethod;
    private MethodInvoker renderInvoker;
    [CompilerGeneratedAttribute]
private bool <HasInit>k__BackingField;
    public string VirtualPath { get; public set; }
    public string Layout { get; public set; }
    public SharpPage LayoutPage { get; public set; }
    public PageFormat Format { get; public set; }
    public Dictionary`2<string, object> Args { get; }
    public ScriptContext Context { get; public set; }
    public ISharpPages Pages { get; public set; }
    public ScriptScopeContext Scope { get; public set; }
    public bool HasInit { get; private set; }
    protected SharpCodePage(string layout);
    [CompilerGeneratedAttribute]
public string get_VirtualPath();
    [CompilerGeneratedAttribute]
public void set_VirtualPath(string value);
    [CompilerGeneratedAttribute]
public string get_Layout();
    [CompilerGeneratedAttribute]
public void set_Layout(string value);
    [CompilerGeneratedAttribute]
public SharpPage get_LayoutPage();
    [CompilerGeneratedAttribute]
public void set_LayoutPage(SharpPage value);
    [CompilerGeneratedAttribute]
public PageFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(PageFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Args();
    [CompilerGeneratedAttribute]
public ScriptContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(ScriptContext value);
    [CompilerGeneratedAttribute]
public ISharpPages get_Pages();
    [CompilerGeneratedAttribute]
public void set_Pages(ISharpPages value);
    [CompilerGeneratedAttribute]
public ScriptScopeContext get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(ScriptScopeContext value);
    [AsyncStateMachineAttribute("ServiceStack.Script.SharpCodePage/<WriteAsync>d__34")]
public Task WriteAsync(ScriptScopeContext scope);
    [CompilerGeneratedAttribute]
public bool get_HasInit();
    [CompilerGeneratedAttribute]
private void set_HasInit(bool value);
    public virtual SharpCodePage Init();
    public virtual void Dispose();
}
public class ServiceStack.Script.SharpPage : object {
    [CompilerGeneratedAttribute]
private ScriptLanguage <ScriptLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <FileContents>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<char> <BodyContents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private SharpPage <LayoutPage>k__BackingField;
    [CompilerGeneratedAttribute]
private PageFragment[] <PageFragments>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModifiedCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLayout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImmutable>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private PageFormat <Format>k__BackingField;
    private object semaphore;
    public ScriptLanguage ScriptLanguage { get; public set; }
    public IVirtualFile File { get; }
    public ReadOnlyMemory`1<char> FileContents { get; private set; }
    public ReadOnlyMemory`1<char> BodyContents { get; private set; }
    public Dictionary`2<string, object> Args { get; protected set; }
    public SharpPage LayoutPage { get; public set; }
    public PageFragment[] PageFragments { get; public set; }
    public DateTime LastModified { get; public set; }
    public DateTime LastModifiedCheck { get; private set; }
    public bool HasInit { get; private set; }
    public bool IsLayout { get; private set; }
    public bool IsImmutable { get; private set; }
    public ScriptContext Context { get; }
    public PageFormat Format { get; }
    public bool IsTempFile { get; }
    public string VirtualPath { get; }
    public SharpPage(ScriptContext context, IVirtualFile file, PageFormat format);
    public SharpPage(ScriptContext context, PageFragment[] body);
    [CompilerGeneratedAttribute]
public ScriptLanguage get_ScriptLanguage();
    [CompilerGeneratedAttribute]
public void set_ScriptLanguage(ScriptLanguage value);
    [CompilerGeneratedAttribute]
public IVirtualFile get_File();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_FileContents();
    [CompilerGeneratedAttribute]
private void set_FileContents(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<char> get_BodyContents();
    [CompilerGeneratedAttribute]
private void set_BodyContents(ReadOnlyMemory`1<char> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Args();
    [CompilerGeneratedAttribute]
protected void set_Args(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public SharpPage get_LayoutPage();
    [CompilerGeneratedAttribute]
public void set_LayoutPage(SharpPage value);
    [CompilerGeneratedAttribute]
public PageFragment[] get_PageFragments();
    [CompilerGeneratedAttribute]
public void set_PageFragments(PageFragment[] value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModifiedCheck();
    [CompilerGeneratedAttribute]
private void set_LastModifiedCheck(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_HasInit();
    [CompilerGeneratedAttribute]
private void set_HasInit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLayout();
    [CompilerGeneratedAttribute]
private void set_IsLayout(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsImmutable();
    [CompilerGeneratedAttribute]
private void set_IsImmutable(bool value);
    [CompilerGeneratedAttribute]
public ScriptContext get_Context();
    [CompilerGeneratedAttribute]
public PageFormat get_Format();
    public bool get_IsTempFile();
    public string get_VirtualPath();
    [AsyncStateMachineAttribute("ServiceStack.Script.SharpPage/<Init>d__60")]
public virtual Task`1<SharpPage> Init();
    [AsyncStateMachineAttribute("ServiceStack.Script.SharpPage/<Load>d__61")]
public Task`1<SharpPage> Load();
}
public class ServiceStack.Script.SharpPages : object {
    [CompilerGeneratedAttribute]
private ScriptContext <Context>k__BackingField;
    public static string Layout;
    private ConcurrentDictionary`2<string, SharpPage> pageMap;
    private static MemoryVirtualFiles tempFiles;
    private static InMemoryVirtualDirectory tempDir;
    internal static InMemoryVirtualDirectory TempDir;
    public ScriptContext Context { get; }
    internal static MemoryVirtualFiles TempFiles { get; }
    public SharpPages(ScriptContext context);
    private static SharpPages();
    [CompilerGeneratedAttribute]
public ScriptContext get_Context();
    public virtual SharpPage ResolveLayoutPage(SharpPage page, string layout);
    public virtual SharpPage ResolveLayoutPage(SharpCodePage page, string layout);
    public sealed virtual SharpCodePage GetCodePage(string virtualPath);
    public virtual SharpPage AddPage(string virtualPath, IVirtualFile file);
    public virtual SharpPage TryGetPage(string path);
    public virtual SharpPage GetPage(string pathInfo);
    internal static MemoryVirtualFiles get_TempFiles();
    public virtual SharpPage OneTimePage(string contents, string ext);
    public sealed virtual SharpPage OneTimePage(string contents, string ext, Action`1<SharpPage> init);
    public sealed virtual DateTime GetLastModified(SharpPage page);
    public DateTime GetLastModifiedPage(SharpPage page);
    private DateTime GetMaxLastModified(IVirtualFile file, DateTime maxLastModified);
}
public class ServiceStack.Script.SharpPartialPage : SharpPage {
    private static MemoryVirtualFiles TempFiles;
    private static InMemoryVirtualDirectory TempDir;
    public SharpPartialPage(ScriptContext context, string name, IEnumerable`1<PageFragment> body, string format, Dictionary`2<string, object> args);
    private static SharpPartialPage();
    private static IVirtualFile CreateFile(string name, string format);
    public virtual Task`1<SharpPage> Init();
}
public class ServiceStack.Script.SharpScript : ScriptLanguage {
    public static ScriptLanguage Language;
    public string Name { get; }
    private static SharpScript();
    public virtual string get_Name();
    public virtual List`1<PageFragment> Parse(ScriptContext context, ReadOnlyMemory`1<char> body, ReadOnlyMemory`1<char> modifiers);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class ServiceStack.Script.SpanJsToken : ValueType {
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private JsToken <Node>k__BackingField;
    public ReadOnlySpan`1<char> Span { get; }
    public JsToken Node { get; }
    public SpanJsToken(ReadOnlySpan`1<char> value, JsToken node);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_Span();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JsToken get_Node();
}
public class ServiceStack.Script.StopExecution : object {
    public static StopExecution Value;
    private static StopExecution();
}
public class ServiceStack.Script.StopFilterExecutionException : StopExecutionException {
    [CompilerGeneratedAttribute]
private ScriptScopeContext <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Options>k__BackingField;
    public ScriptScopeContext Scope { get; }
    public object Options { get; }
    public StopFilterExecutionException(ScriptScopeContext scope, object options, Exception innerException);
    [CompilerGeneratedAttribute]
public ScriptScopeContext get_Scope();
    [CompilerGeneratedAttribute]
public object get_Options();
    public sealed virtual ResponseStatus ToResponseStatus();
}
public class ServiceStack.Script.SyntaxErrorException : ArgumentException {
    public SyntaxErrorException(string message);
    public SyntaxErrorException(string message, Exception innerException);
}
[ExtensionAttribute]
public static class ServiceStack.Script.TemplateFilterUtils : object {
    [ExtensionAttribute]
public static Dictionary`2<string, object> AssertOptions(ScriptScopeContext scope, string filterName, object scopedParams);
    [ExtensionAttribute]
public static Dictionary`2<string, object> AssertOptions(object scopedParams, string filterName);
    [ExtensionAttribute]
public static object AssertNoCircularDeps(object value);
    [ExtensionAttribute]
public static IEnumerable`1<object> AssertEnumerable(object items, string filterName);
    [ExtensionAttribute]
public static string AssertExpression(ScriptScopeContext scope, string filterName, object expression);
    [ExtensionAttribute]
public static JsToken AssertExpression(ScriptScopeContext scope, string filterName, object expression, object scopeOptions, String& itemBinding);
    [ExtensionAttribute]
public static Dictionary`2<string, object> GetParamsWithItemBinding(ScriptScopeContext scope, string filterName, object scopedParams, String& itemBinding);
    [ExtensionAttribute]
public static Dictionary`2<string, object> GetParamsWithItemBinding(ScriptScopeContext scope, string filterName, SharpPage page, object scopedParams, String& itemBinding);
    [ExtensionAttribute]
public static Dictionary`2<string, object> GetParamsWithItemBindingOnly(ScriptScopeContext scope, string filterName, SharpPage page, object scopedParams, String& itemBinding);
    [ExtensionAttribute]
public static ScriptScopeContext AddItemToScope(ScriptScopeContext scope, string itemBinding, object item, int index);
    [ExtensionAttribute]
public static ScriptScopeContext AddItemToScope(ScriptScopeContext scope, string itemBinding, object item);
    private static ScriptScopeContext SetItemInScope(string itemBinding, object item, ScriptScopeContext newScope);
    [ExtensionAttribute]
public static T GetValueOrEvaluateBinding(ScriptScopeContext scope, object valueOrBinding);
    [ExtensionAttribute]
public static object GetValueOrEvaluateBinding(ScriptScopeContext scope, object valueOrBinding, Type returnType);
    [ExtensionAttribute]
public static bool TryGetPage(ScriptScopeContext scope, string virtualPath, SharpPage& page, SharpCodePage& codePage);
    [ExtensionAttribute]
public static ScriptContext CreateNewContext(ScriptScopeContext scope, Dictionary`2<string, object> args);
}
public class ServiceStack.Script.TypeScriptMethods : ScriptMethods {
    public RawString tsUnionStrings(IEnumerable`1<string> strings);
    public RawString tsUnionTypes(IEnumerable`1<string> strings);
}
public class ServiceStack.Script.TypeScriptPlugin : object {
    public sealed virtual void Register(ScriptContext context);
}
[ExtensionAttribute]
internal static class ServiceStack.Script.Utils : object {
    [ExtensionAttribute]
internal static object lispBool(bool t);
    [ExtensionAttribute]
internal static object fromLisp(object o);
    [ExtensionAttribute]
internal static object lastArg(Object[] a);
    [ExtensionAttribute]
internal static IEnumerable assertEnumerable(object a);
    [ExtensionAttribute]
internal static int compareTo(object a, object b);
    [ExtensionAttribute]
public static Cell unwrapDataListArgs(Cell arg);
    [ExtensionAttribute]
internal static object unwrapScriptValue(object o);
}
public class ServiceStack.Script.WhileScriptBlock : ScriptBlock {
    public string Name { get; }
    public virtual string get_Name();
    [AsyncStateMachineAttribute("ServiceStack.Script.WhileScriptBlock/<WriteAsync>d__2")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken ct);
}
public class ServiceStack.Script.WithScriptBlock : ScriptBlock {
    public string Name { get; }
    public virtual string get_Name();
    [AsyncStateMachineAttribute("ServiceStack.Script.WithScriptBlock/<WriteAsync>d__2")]
public virtual Task WriteAsync(ScriptScopeContext scope, PageBlockFragment block, CancellationToken token);
}
[ExtensionAttribute]
public static class ServiceStack.SharpPagesExtensions : object {
    [AsyncStateMachineAttribute("ServiceStack.SharpPagesExtensions/<RenderToStringAsync>d__0")]
[ExtensionAttribute]
public static Task`1<string> RenderToStringAsync(IStreamWriterAsync writer);
}
public class ServiceStack.SimpleAppSettings : object {
    private Dictionary`2<string, string> settings;
    public SimpleAppSettings(Dictionary`2<string, string> settings);
    public sealed virtual Dictionary`2<string, string> GetAll();
    public sealed virtual List`1<string> GetAllKeys();
    public sealed virtual bool Exists(string key);
    public sealed virtual void Set(string key, T value);
    public sealed virtual string GetString(string key);
    public sealed virtual IList`1<string> GetList(string key);
    public sealed virtual IDictionary`2<string, string> GetDictionary(string key);
    public sealed virtual List`1<KeyValuePair`2<string, string>> GetKeyValuePairs(string key);
    public sealed virtual T Get(string key);
    public sealed virtual T Get(string key, T defaultValue);
}
public class ServiceStack.SimpleContainer : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IgnoreTypesNamed>k__BackingField;
    protected ConcurrentDictionary`2<Type, object> InstanceCache;
    protected ConcurrentDictionary`2<Type, Func`1<object>> Factory;
    public HashSet`1<string> IgnoreTypesNamed { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IgnoreTypesNamed();
    public sealed virtual object Resolve(Type type);
    public sealed virtual bool Exists(Type type);
    public object RequiredResolve(Type type, Type ownerType);
    public sealed virtual IContainer AddSingleton(Type serviceType, Func`1<object> factory);
    public sealed virtual IContainer AddTransient(Type serviceType, Func`1<object> factory);
    public sealed virtual T TryResolve();
    protected virtual bool IncludeProperty(PropertyInfo pi);
    protected virtual ConstructorInfo ResolveBestConstructor(Type type);
    public sealed virtual Func`1<object> CreateFactory(Type type);
    public void Dispose();
}
public static class ServiceStack.SiteUtils : object {
    private static Char[] UrlCharChecks;
    private static SiteUtils();
    public static string UrlFromSlug(string slug);
    private static string UnSlash(string urlComponent);
    public static string UrlToSlug(string url);
    public static string ToUrlEncoded(List`1<string> args);
}
public class ServiceStack.StaticActionInvoker : MulticastDelegate {
    public StaticActionInvoker(object object, IntPtr method);
    public virtual void Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ServiceStack.StaticMethodInvoker : MulticastDelegate {
    public StaticMethodInvoker(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class ServiceStack.StopExecutionException : Exception {
    public StopExecutionException(string message);
    public StopExecutionException(string message, Exception innerException);
}
[ExtensionAttribute]
public static class ServiceStack.StringUtils : object {
    public static Dictionary`2<char, string> EscapedCharMap;
    private static Regex StripHtmlUnicodeRegEx;
    private static Regex SafeInputRegEx;
    private static Char[] FieldSeparators;
    private static Char[] csharpGenericDelimChars;
    public static ReadOnlyMemory`1<char> NewLineMemory;
    public static IDictionary`2<string, string> HtmlCharacterCodes;
    private static StringUtils();
    public static string Join(string delimiter, IEnumerable`1<string> values, int lineBreak, string linePrefix);
    [ExtensionAttribute]
public static List`1<Command> ParseCommands(string commandsString);
    [ExtensionAttribute]
public static List`1<Command> ParseCommands(ReadOnlyMemory`1<char> commandsString, char separator);
    public static ReadOnlyMemory`1<char> ParseArguments(ReadOnlyMemory`1<char> argsString, List`1& args);
    public static string ReplacePairs(string str, String[] replaceStringsPairs);
    [ExtensionAttribute]
public static string ReplaceOutsideOfQuotes(string str, String[] replaceStringsPairs);
    [ExtensionAttribute]
public static string SafeInput(string text);
    [ExtensionAttribute]
public static string ToEscapedString(string input);
    public static string SnakeCaseToPascalCase(string snakeCase);
    public static string RemoveSuffix(string name, string suffix);
    [ExtensionAttribute]
public static string HtmlEncodeLite(string html);
    [ExtensionAttribute]
public static string HtmlEncode(string html);
    [ExtensionAttribute]
public static string HtmlDecode(string html);
    [ExtensionAttribute]
public static string ConvertHtmlCodes(string html);
    private static string ConvertHtmlCodeToCharacter(Match match);
    [ExtensionAttribute]
public static string ToChar(int codePoint);
    public static String[] SplitVarNames(string fields);
    public static List`1<string> SplitGenericArgs(string argList);
    [ExtensionAttribute]
public static TextNode ParseTypeIntoNodes(string typeDef);
    [ExtensionAttribute]
public static TextNode ParseTypeIntoNodes(string typeDef, Char[] genericDelimChars);
    [ExtensionAttribute]
public static void AppendLine(StringBuilder sb, ReadOnlyMemory`1<char> line);
}
public class ServiceStack.Support.ActionExecHandler : object {
    private Action action;
    private AutoResetEvent waitHandle;
    public ActionExecHandler(Action action, AutoResetEvent waitHandle);
    public sealed virtual bool Execute();
}
public abstract class ServiceStack.Support.AdapterBase : object {
    protected ILog Log { get; }
    protected abstract virtual ILog get_Log();
    protected T Execute(Func`1<T> action);
    [AsyncStateMachineAttribute("ServiceStack.Support.AdapterBase/<ExecuteAsync>d__3`1")]
protected Task`1<T> ExecuteAsync(Func`1<Task`1<T>> action);
    [AsyncStateMachineAttribute("ServiceStack.Support.AdapterBase/<ExecuteAsync>d__4`1")]
protected Task`1<T> ExecuteAsync(Func`2<CancellationToken, Task`1<T>> action, CancellationToken token);
    protected void Execute(Action action);
    [AsyncStateMachineAttribute("ServiceStack.Support.AdapterBase/<ExecuteAsync>d__6")]
protected Task ExecuteAsync(Func`1<Task> action);
    [AsyncStateMachineAttribute("ServiceStack.Support.AdapterBase/<ExecuteAsync>d__7")]
protected Task ExecuteAsync(Func`2<CancellationToken, Task> action, CancellationToken token);
}
public class ServiceStack.Support.CommandExecsHandler : object {
    private ICommandExec command;
    private AutoResetEvent waitHandle;
    public CommandExecsHandler(ICommandExec command, AutoResetEvent waitHandle);
    public sealed virtual bool Execute();
}
public class ServiceStack.Support.CommandResultsHandler`1 : object {
    private List`1<T> results;
    private ICommandList`1<T> command;
    private AutoResetEvent waitHandle;
    public CommandResultsHandler`1(List`1<T> results, ICommandList`1<T> command, AutoResetEvent waitHandle);
    public sealed virtual bool Execute();
}
public class ServiceStack.Support.InMemoryLog : object {
    private object syncLock;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <CombinedLog>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DebugEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <DebugExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <InfoEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <InfoExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <WarnEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <WarnExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ErrorEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <ErrorExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FatalEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Exception> <FatalExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDebugEnabled>k__BackingField;
    public string LoggerName { get; private set; }
    public StringBuilder CombinedLog { get; private set; }
    public List`1<string> DebugEntries { get; public set; }
    public List`1<Exception> DebugExceptions { get; public set; }
    public List`1<string> InfoEntries { get; public set; }
    public List`1<Exception> InfoExceptions { get; public set; }
    public List`1<string> WarnEntries { get; public set; }
    public List`1<Exception> WarnExceptions { get; public set; }
    public List`1<string> ErrorEntries { get; public set; }
    public List`1<Exception> ErrorExceptions { get; public set; }
    public List`1<string> FatalEntries { get; public set; }
    public List`1<Exception> FatalExceptions { get; public set; }
    public bool HasExceptions { get; }
    public bool IsDebugEnabled { get; public set; }
    public InMemoryLog(string loggerName);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
private void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
public StringBuilder get_CombinedLog();
    [CompilerGeneratedAttribute]
private void set_CombinedLog(StringBuilder value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DebugEntries();
    [CompilerGeneratedAttribute]
public void set_DebugEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_DebugExceptions();
    [CompilerGeneratedAttribute]
public void set_DebugExceptions(List`1<Exception> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_InfoEntries();
    [CompilerGeneratedAttribute]
public void set_InfoEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_InfoExceptions();
    [CompilerGeneratedAttribute]
public void set_InfoExceptions(List`1<Exception> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_WarnEntries();
    [CompilerGeneratedAttribute]
public void set_WarnEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_WarnExceptions();
    [CompilerGeneratedAttribute]
public void set_WarnExceptions(List`1<Exception> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ErrorEntries();
    [CompilerGeneratedAttribute]
public void set_ErrorEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_ErrorExceptions();
    [CompilerGeneratedAttribute]
public void set_ErrorExceptions(List`1<Exception> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_FatalEntries();
    [CompilerGeneratedAttribute]
public void set_FatalEntries(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_FatalExceptions();
    [CompilerGeneratedAttribute]
public void set_FatalExceptions(List`1<Exception> value);
    public bool get_HasExceptions();
    private void AppendToLog(ICollection`1<string> logEntries, string format, Object[] args);
    private void AppendToLog(ICollection`1<string> logEntries, object message);
    private void AppendToLog(ICollection`1<string> logEntries, ICollection`1<Exception> logExceptions, object message, Exception ex);
    private void AppendToLog(ICollection`1<string> logEntries, string message);
    public sealed virtual void Debug(object message);
    public sealed virtual void Debug(object message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Error(object message);
    public sealed virtual void Error(object message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(object message);
    public sealed virtual void Fatal(object message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void Info(object message);
    public sealed virtual void Info(object message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(object message);
    public sealed virtual void Warn(object message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDebugEnabled();
    [CompilerGeneratedAttribute]
public void set_IsDebugEnabled(bool value);
}
public class ServiceStack.Support.InMemoryLogFactory : object {
    private bool debugEnabled;
    public InMemoryLogFactory(bool debugEnabled);
    public sealed virtual ILog GetLogger(Type type);
    public sealed virtual ILog GetLogger(string typeName);
}
[ExtensionAttribute]
public static class ServiceStack.TaskExt : object {
    private static TaskFactory SyncTaskFactory;
    private static TaskExt();
    [ExtensionAttribute]
public static Task`1<object> AsTaskException(Exception ex);
    [ExtensionAttribute]
public static Task`1<T> AsTaskException(Exception ex);
    [ExtensionAttribute]
public static Task`1<T> AsTaskResult(T result);
    [ExtensionAttribute]
public static object GetResult(Task task);
    [ExtensionAttribute]
public static T GetResult(Task`1<T> task);
    public static void RunSync(Func`1<Task> task);
    public static TResult RunSync(Func`1<Task`1<TResult>> task);
    [ExtensionAttribute]
public static ValueTask AsValueTask(Task task);
    [ExtensionAttribute]
public static ValueTask`1<T> AsValueTask(Task`1<T> task);
    [ExtensionAttribute]
public static Task AsTask(Task task);
}
public class ServiceStack.TextDumpOptions : object {
    [CompilerGeneratedAttribute]
private TextStyle <HeaderStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Caption>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CaptionIfEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRowNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultScripts <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCaption>k__BackingField;
    public TextStyle HeaderStyle { get; public set; }
    public string Caption { get; public set; }
    public string CaptionIfEmpty { get; public set; }
    public String[] Headers { get; public set; }
    public bool IncludeRowNumbers { get; public set; }
    public DefaultScripts Defaults { get; public set; }
    internal int Depth { get; internal set; }
    internal bool HasCaption { get; internal set; }
    [CompilerGeneratedAttribute]
public TextStyle get_HeaderStyle();
    [CompilerGeneratedAttribute]
public void set_HeaderStyle(TextStyle value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public string get_CaptionIfEmpty();
    [CompilerGeneratedAttribute]
public void set_CaptionIfEmpty(string value);
    [CompilerGeneratedAttribute]
public String[] get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(String[] value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRowNumbers();
    [CompilerGeneratedAttribute]
public void set_IncludeRowNumbers(bool value);
    [CompilerGeneratedAttribute]
public DefaultScripts get_Defaults();
    [CompilerGeneratedAttribute]
public void set_Defaults(DefaultScripts value);
    [CompilerGeneratedAttribute]
internal int get_Depth();
    [CompilerGeneratedAttribute]
internal void set_Depth(int value);
    [CompilerGeneratedAttribute]
internal bool get_HasCaption();
    [CompilerGeneratedAttribute]
internal void set_HasCaption(bool value);
    public static TextDumpOptions Parse(Dictionary`2<string, object> options, DefaultScripts defaults);
}
public class ServiceStack.TextNode : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TextNode> <Children>k__BackingField;
    public string Text { get; public set; }
    public List`1<TextNode> Children { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public List`1<TextNode> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(List`1<TextNode> value);
}
public enum ServiceStack.TextStyle : Enum {
    public int value__;
    public static TextStyle None;
    public static TextStyle SplitCase;
    public static TextStyle Humanize;
    public static TextStyle TitleCase;
    public static TextStyle PascalCase;
    public static TextStyle CamelCase;
}
[ExtensionAttribute]
public static class ServiceStack.TypeExtensions : object {
    private static Dictionary`2<ConstructorInfo, ObjectActivator> activatorCache;
    private static Dictionary`2<MethodInfo, MethodInvoker> invokerCache;
    private static Dictionary`2<MethodInfo, StaticMethodInvoker> staticInvokerCache;
    private static Dictionary`2<MethodInfo, ActionInvoker> actionInvokerCache;
    private static Dictionary`2<MethodInfo, StaticActionInvoker> staticActionInvokerCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type[] GetReferencedTypes(Type type);
    public static void AddReferencedTypes(Type type, HashSet`1<Type> refTypes);
    public static ObjectActivator GetActivatorToCache(ConstructorInfo ctor);
    [ExtensionAttribute]
public static ObjectActivator GetActivator(ConstructorInfo ctor);
    private static Expression[] CreateInvokerParamExpressions(MethodInfo method, ParameterExpression paramArgs);
    private static string UseCorrectInvokerErrorMessage(MethodInfo method);
    public static MethodInvoker GetInvokerToCache(MethodInfo method);
    public static StaticMethodInvoker GetStaticInvokerToCache(MethodInfo method);
    public static ActionInvoker GetActionInvokerToCache(MethodInfo method);
    public static StaticActionInvoker GetStaticActionInvokerToCache(MethodInfo method);
    [ExtensionAttribute]
public static Delegate GetInvokerDelegate(MethodInfo method);
    [ExtensionAttribute]
public static MethodInvoker GetInvoker(MethodInfo method);
    [ExtensionAttribute]
public static StaticMethodInvoker GetStaticInvoker(MethodInfo method);
    [ExtensionAttribute]
public static ActionInvoker GetActionInvoker(MethodInfo method);
    [ExtensionAttribute]
public static StaticActionInvoker GetStaticActionInvoker(MethodInfo method);
    public static T ConvertFromObject(object value);
    public static object ConvertToObject(T value);
    [ExtensionAttribute]
public static Func`2<object, object> GetPropertyAccessor(Type type, PropertyInfo forProperty);
    public static LambdaExpression CreatePropertyAccessorExpression(Type type, PropertyInfo forProperty);
}
public class ServiceStack.UrnId : object {
    private static char FieldSeperator;
    private static char FieldPartsSeperator;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdFieldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdFieldName>k__BackingField;
    private static int HasNoIdFieldName;
    private static int HasIdFieldName;
    public string TypeName { get; private set; }
    public string IdFieldValue { get; private set; }
    public string IdFieldName { get; private set; }
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_IdFieldValue();
    [CompilerGeneratedAttribute]
private void set_IdFieldValue(string value);
    [CompilerGeneratedAttribute]
public string get_IdFieldName();
    [CompilerGeneratedAttribute]
private void set_IdFieldName(string value);
    public static UrnId Parse(string urnId);
    public static string Create(string objectTypeName, string idFieldValue);
    public static string CreateWithParts(string objectTypeName, String[] keyParts);
    public static string CreateWithParts(String[] keyParts);
    public static string Create(string idFieldValue);
    public static string Create(object idFieldValue);
    public static string Create(Type objectType, string idFieldValue);
    public static string Create(string idFieldName, string idFieldValue);
    public static string Create(Type objectType, string idFieldName, string idFieldValue);
    public static string GetStringId(string urn);
    public static Guid GetGuidId(string urn);
    public static long GetLongId(string urn);
}
public static class ServiceStack.View : object {
    public static List`1<NavItem> NavItems { get; }
    public static Dictionary`2<string, List`1<NavItem>> NavItemsMap { get; }
    public static List`1<NavItem> get_NavItems();
    public static Dictionary`2<string, List`1<NavItem>> get_NavItemsMap();
    public static void Load(IAppSettings settings);
    public static List`1<NavItem> GetNavItems(string key);
}
[ExtensionAttribute]
public static class ServiceStack.ViewUtils : object {
    internal static DefaultScripts DefaultScripts;
    private static HtmlScripts HtmlScripts;
    [CompilerGeneratedAttribute]
private static string <NavItemsKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NavItemsMapKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static List`1<NavItem> <NavItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, List`1<NavItem>> <NavItemsMap>k__BackingField;
    public static string ValidationSummaryCssClassNames;
    public static string ValidationSuccessCssClassNames;
    public static string NavItemsKey { get; public set; }
    public static string NavItemsMapKey { get; public set; }
    public static List`1<NavItem> NavItems { get; }
    public static Dictionary`2<string, List`1<NavItem>> NavItemsMap { get; }
    private static ViewUtils();
    [CompilerGeneratedAttribute]
public static string get_NavItemsKey();
    [CompilerGeneratedAttribute]
public static void set_NavItemsKey(string value);
    [CompilerGeneratedAttribute]
public static string get_NavItemsMapKey();
    [CompilerGeneratedAttribute]
public static void set_NavItemsMapKey(string value);
    public static void Load(IAppSettings settings);
    [ExtensionAttribute]
public static bool ShowNav(NavItem navItem, HashSet`1<string> attributes);
    [CompilerGeneratedAttribute]
public static List`1<NavItem> get_NavItems();
    [CompilerGeneratedAttribute]
public static Dictionary`2<string, List`1<NavItem>> get_NavItemsMap();
    public static List`1<NavItem> GetNavItems(string key);
    public static string CssIncludes(IVirtualPathProvider vfs, List`1<string> cssFiles);
    public static string JsIncludes(IVirtualPathProvider vfs, List`1<string> jsFiles);
    public static string Nav(List`1<NavItem> navItems, NavOptions options);
    public static string NavLink(NavItem navItem, NavOptions options);
    private static string ActiveClass(NavItem navItem, string activePath);
    public static void NavLink(StringBuilder sb, NavItem navItem, NavOptions options);
    public static string NavButtonGroup(List`1<NavItem> navItems, NavOptions options);
    public static string NavButtonGroup(NavItem navItem, NavOptions options);
    public static void NavLinkButton(StringBuilder sb, NavItem navItem, NavOptions options);
    public static bool IsNull(object test);
    [ExtensionAttribute]
public static CultureInfo GetDefaultCulture(DefaultScripts defaultScripts);
    [ExtensionAttribute]
public static string GetDefaultTableClassName(DefaultScripts defaultScripts);
    [ExtensionAttribute]
public static string TextDump(object target);
    [ExtensionAttribute]
public static string TextDump(object target, TextDumpOptions options);
    [ExtensionAttribute]
public static string DumpTable(object target);
    [ExtensionAttribute]
public static void PrintDumpTable(object target);
    [ExtensionAttribute]
public static string DumpTable(object target, TextDumpOptions options);
    [ExtensionAttribute]
public static void PrintDumpTable(object target, TextDumpOptions options);
    public static string HtmlDump(object target);
    public static string HtmlDump(object target, HtmlDumpOptions options);
    public static string StyleText(string text, TextStyle textStyle);
    public static string HtmlHiddenInputs(IEnumerable`1<KeyValuePair`2<string, object>> inputValues);
    [ExtensionAttribute]
internal static object GetItem(IRequest httpReq, string key);
    public static ResponseStatus GetErrorStatus(IRequest req);
    public static bool HasErrorStatus(IRequest req);
    public static string FormQuery(IRequest req, string name);
    public static String[] FormQueryValues(IRequest req, string name);
    public static string FormValue(IRequest req, string name);
    public static string FormValue(IRequest req, string name, string defaultValue);
    public static String[] FormValues(IRequest req, string name);
    public static bool FormCheckValue(IRequest req, string name);
    public static string GetParam(IRequest req, string name);
    public static List`1<string> ToVarNames(string fieldNames);
    public static IEnumerable`1<string> ToStrings(string filterName, object arg);
    public static string ValidationSummary(ResponseStatus errorStatus, string exceptFor);
    public static string ValidationSummary(ResponseStatus errorStatus, ICollection`1<string> exceptFields, Dictionary`2<string, object> divAttrs);
    public static string ValidationSuccess(string message, Dictionary`2<string, object> divAttrs);
    public static string ErrorResponseExcept(ResponseStatus errorStatus, string fieldNames);
    public static string ErrorResponseExcept(ResponseStatus errorStatus, ICollection`1<string> fieldNames);
    public static string ErrorResponseSummary(ResponseStatus errorStatus);
    public static string ErrorResponse(ResponseStatus errorStatus, string fieldName);
    public static List`1<KeyValuePair`2<string, string>> ToKeyValues(object values);
    public static List`1<string> SplitStringList(IEnumerable strings);
    public static List`1<string> ToStringList(IEnumerable strings);
    public static string FormControl(IRequest req, Dictionary`2<string, object> args, string tagName, InputOptions inputOptions);
    private static IVirtualFiles ResolveWriteVfs(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, string outFile, bool toDisk, String& useOutFile);
    private static void ResolveVfsAndSource(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, string source, IVirtualPathProvider& useVfs, String& useSource);
    [IteratorStateMachineAttribute("ServiceStack.ViewUtils/<GetBundleFiles>d__68")]
public static IEnumerable`1<IVirtualFile> GetBundleFiles(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, IEnumerable`1<string> virtualPaths, string assetExt);
    public static string BundleJs(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, ICompressor jsCompressor, BundleOptions options);
    public static string BundleCss(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, ICompressor cssCompressor, BundleOptions options);
    public static string BundleHtml(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, ICompressor htmlCompressor, BundleOptions options);
    private static string BundleAsset(string filterName, IVirtualPathProvider webVfs, IVirtualPathProvider contentVfs, ICompressor jsCompressor, BundleOptions options, string origOutFile, string outWebPath, string htmlTagFmt, string assetExt, string pathBase);
    [CompilerGeneratedAttribute]
internal static void <BundleAsset>g__LogWarning|72_0(string msg, <>c__DisplayClass72_0& , <>c__DisplayClass72_1& );
}
[ExtensionAttribute]
public static class ServiceStack.VirtualFileExtensions : object {
    [ExtensionAttribute]
public static bool ShouldSkipPath(IVirtualNode node);
    [ExtensionAttribute]
public static IVirtualFile AssertFile(IVirtualPathProvider vfs, string path);
    [ExtensionAttribute]
public static IVirtualDirectory[] GetAllRootDirectories(IVirtualPathProvider vfs);
    [ExtensionAttribute]
public static T GetVirtualFileSource(IVirtualPathProvider vfs);
    [ExtensionAttribute]
public static MemoryVirtualFiles GetMemoryVirtualFiles(IVirtualPathProvider vfs);
    [ExtensionAttribute]
public static FileSystemVirtualFiles GetFileSystemVirtualFiles(IVirtualPathProvider vfs);
    [ExtensionAttribute]
public static GistVirtualFiles GetGistVirtualFiles(IVirtualPathProvider vfs);
    [ExtensionAttribute]
public static ResourceVirtualFiles GetResourceVirtualFiles(IVirtualPathProvider vfs);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ReadAllTextAsMemory()")]
public static ReadOnlyMemory`1<char> GetTextContentsAsMemory(IVirtualFile file);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> ReadAllTextAsMemory(IVirtualFile file);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ReadAllBytesAsMemory()")]
public static ReadOnlyMemory`1<byte> GetBytesContentsAsMemory(IVirtualFile file);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<byte> ReadAllBytesAsMemory(IVirtualFile file);
    [ExtensionAttribute]
[ObsoleteAttribute("Use ReadAllBytes()")]
public static Byte[] GetBytesContentsAsBytes(IVirtualFile file);
}
public abstract class ServiceStack.VirtualPath.AbstractVirtualDirectoryBase : object {
    protected IVirtualPathProvider VirtualPathProvider;
    [CompilerGeneratedAttribute]
private IVirtualDirectory <ParentDirectory>k__BackingField;
    public IVirtualDirectory ParentDirectory { get; public set; }
    public IVirtualDirectory Directory { get; }
    public DateTime LastModified { get; }
    public string VirtualPath { get; }
    public string RealPath { get; }
    public bool IsDirectory { get; }
    public bool IsRoot { get; }
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public string Name { get; }
    protected AbstractVirtualDirectoryBase(IVirtualPathProvider owningProvider);
    protected AbstractVirtualDirectoryBase(IVirtualPathProvider owningProvider, IVirtualDirectory parentDirectory);
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualDirectory get_ParentDirectory();
    [CompilerGeneratedAttribute]
public void set_ParentDirectory(IVirtualDirectory value);
    public sealed virtual IVirtualDirectory get_Directory();
    public abstract virtual DateTime get_LastModified();
    public virtual string get_VirtualPath();
    public virtual string get_RealPath();
    public virtual bool get_IsDirectory();
    public virtual bool get_IsRoot();
    public abstract virtual IEnumerable`1<IVirtualFile> get_Files();
    public abstract virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    public abstract virtual string get_Name();
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public virtual IVirtualFile GetFile(Stack`1<string> virtualPath);
    public virtual IVirtualDirectory GetDirectory(Stack`1<string> virtualPath);
    [IteratorStateMachineAttribute("ServiceStack.VirtualPath.AbstractVirtualDirectoryBase/<GetAllMatchingFiles>d__29")]
public virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual string GetVirtualPathToRoot();
    protected virtual string GetRealPathToRoot();
    protected virtual string GetPathToRoot(string separator, Func`2<IVirtualDirectory, string> pathSel);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public abstract virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    protected abstract virtual IVirtualFile GetFileFromBackingDirectoryOrDefault(string fileName);
    protected abstract virtual IEnumerable`1<IVirtualFile> GetMatchingFilesInDir(string globPattern);
    protected abstract virtual IVirtualDirectory GetDirectoryFromBackingDirectoryOrDefault(string directoryName);
}
public abstract class ServiceStack.VirtualPath.AbstractVirtualFileBase : object {
    [CompilerGeneratedAttribute]
private static List`1<string> <ScanSkipPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualPathProvider <VirtualPathProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IVirtualDirectory <Directory>k__BackingField;
    public static List`1<string> ScanSkipPaths { get; public set; }
    public IVirtualPathProvider VirtualPathProvider { get; public set; }
    public string Extension { get; }
    public IVirtualDirectory Directory { get; public set; }
    public string Name { get; }
    public string VirtualPath { get; }
    public string RealPath { get; }
    public bool IsDirectory { get; }
    public DateTime LastModified { get; }
    public long Length { get; }
    protected AbstractVirtualFileBase(IVirtualPathProvider owningProvider, IVirtualDirectory directory);
    private static AbstractVirtualFileBase();
    [CompilerGeneratedAttribute]
public static List`1<string> get_ScanSkipPaths();
    [CompilerGeneratedAttribute]
public static void set_ScanSkipPaths(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualPathProvider get_VirtualPathProvider();
    [CompilerGeneratedAttribute]
public void set_VirtualPathProvider(IVirtualPathProvider value);
    public virtual string get_Extension();
    [CompilerGeneratedAttribute]
public sealed virtual IVirtualDirectory get_Directory();
    [CompilerGeneratedAttribute]
public void set_Directory(IVirtualDirectory value);
    public abstract virtual string get_Name();
    public virtual string get_VirtualPath();
    public virtual string get_RealPath();
    public virtual bool get_IsDirectory();
    public abstract virtual DateTime get_LastModified();
    public abstract virtual long get_Length();
    public virtual string GetFileHash();
    public virtual StreamReader OpenText();
    public virtual string ReadAllText();
    public virtual Byte[] ReadAllBytes();
    [AsyncStateMachineAttribute("ServiceStack.VirtualPath.AbstractVirtualFileBase/<ReadAllTextAsync>d__31")]
public virtual Task`1<string> ReadAllTextAsync(CancellationToken token);
    public virtual Task`1<Byte[]> ReadAllBytesAsync(CancellationToken token);
    public abstract virtual Stream OpenRead();
    public virtual object GetContents();
    protected virtual string GetVirtualPathToRoot();
    protected virtual string GetRealPathToRoot();
    protected virtual string GetPathToRoot(string separator, Func`2<IVirtualDirectory, string> pathSel);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual void Refresh();
    [AsyncStateMachineAttribute("ServiceStack.VirtualPath.AbstractVirtualFileBase/<WritePartialToAsync>d__42")]
public virtual Task WritePartialToAsync(Stream toStream, long start, long end, CancellationToken token);
}
public abstract class ServiceStack.VirtualPath.AbstractVirtualPathProviderBase : object {
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public abstract virtual IVirtualDirectory get_RootDirectory();
    public abstract virtual string get_VirtualPathSeparator();
    public abstract virtual string get_RealPathSeparator();
    public virtual string CombineVirtualPath(string basePath, string relativePath);
    public virtual bool FileExists(string virtualPath);
    public virtual string SanitizePath(string filePath);
    public virtual bool DirectoryExists(string virtualPath);
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual string GetFileHash(string virtualPath);
    public virtual string GetFileHash(IVirtualFile virtualFile);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public virtual IEnumerable`1<IVirtualFile> GetAllMatchingFiles(string globPattern, int maxDepth);
    public virtual IEnumerable`1<IVirtualFile> GetAllFiles();
    public virtual IEnumerable`1<IVirtualFile> GetRootFiles();
    public virtual IEnumerable`1<IVirtualDirectory> GetRootDirectories();
    public virtual bool IsSharedFile(IVirtualFile virtualFile);
    public virtual bool IsViewFile(IVirtualFile virtualFile);
    protected abstract virtual void Initialize();
    public virtual string ToString();
    public virtual void WriteFiles(Dictionary`2<string, string> textFiles);
    protected NotSupportedException CreateContentNotSupportedException(object value);
    protected IVirtualFiles AssertVirtualFiles();
    public virtual void WriteFile(string path, ReadOnlyMemory`1<char> text);
    public virtual void WriteFile(string path, ReadOnlyMemory`1<byte> bytes);
    private static MemoryStream ToMemoryStream(ReadOnlyMemory`1<byte> bytes);
    public virtual void WriteFile(string path, object contents);
    public virtual Task WriteFileAsync(string path, object contents, CancellationToken token);
    public virtual void AppendFile(string path, ReadOnlyMemory`1<char> text);
    public virtual void AppendFile(string path, ReadOnlyMemory`1<byte> bytes);
    public virtual void AppendFile(string path, object contents);
    public virtual void WriteFiles(Dictionary`2<string, object> files);
}
public class ServiceStack.VirtualPath.FileSystemMapping : AbstractVirtualPathProviderBase {
    protected DirectoryInfo RootDirInfo;
    protected FileSystemVirtualDirectory RootDir;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; private set; }
    public IVirtualDirectory RootDirectory { get; }
    public string VirtualPathSeparator { get; }
    public string RealPathSeparator { get; }
    public FileSystemMapping(string alias, string rootDirectoryPath);
    public FileSystemMapping(string alias, DirectoryInfo rootDirInfo);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
    public virtual IVirtualDirectory get_RootDirectory();
    public virtual string get_VirtualPathSeparator();
    public virtual string get_RealPathSeparator();
    protected sealed virtual void Initialize();
    public string GetRealVirtualPath(string virtualPath);
    public virtual IVirtualFile GetFile(string virtualPath);
    public virtual IVirtualDirectory GetDirectory(string virtualPath);
    public virtual IEnumerable`1<IVirtualDirectory> GetRootDirectories();
    public virtual IEnumerable`1<IVirtualFile> GetRootFiles();
}
public class ServiceStack.VirtualPath.FileSystemVirtualDirectory : AbstractVirtualDirectoryBase {
    private static ILog Log;
    protected DirectoryInfo BackingDirInfo;
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public string Name { get; }
    public DateTime LastModified { get; }
    public string RealPath { get; }
    public FileSystemVirtualDirectory(IVirtualPathProvider owningProvider, IVirtualDirectory parentDirectory, DirectoryInfo dInfo);
    private static FileSystemVirtualDirectory();
    public virtual IEnumerable`1<IVirtualFile> get_Files();
    public virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    public virtual string get_Name();
    public virtual DateTime get_LastModified();
    public virtual string get_RealPath();
    public virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    private FileInfo[] GetFiles();
    private DirectoryInfo[] GetDirectories();
    protected virtual IVirtualFile GetFileFromBackingDirectoryOrDefault(string fName);
    protected virtual IEnumerable`1<IVirtualFile> GetMatchingFilesInDir(string globPattern);
    protected virtual IVirtualDirectory GetDirectoryFromBackingDirectoryOrDefault(string dName);
    public IEnumerable`1<FileInfo> EnumerateFiles(string pattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string dirName);
    [CompilerGeneratedAttribute]
private FileSystemVirtualDirectory <GetEnumerator>b__13_0(DirectoryInfo dInfo);
    [CompilerGeneratedAttribute]
private FileSystemVirtualFile <GetEnumerator>b__13_2(FileInfo fInfo);
    [CompilerGeneratedAttribute]
private IVirtualFile <GetMatchingFilesInDir>b__17_1(FileInfo fInfo);
}
public class ServiceStack.VirtualPath.FileSystemVirtualFile : AbstractVirtualFileBase {
    protected FileInfo BackingFile;
    public string Name { get; }
    public string RealPath { get; }
    public DateTime LastModified { get; }
    public long Length { get; }
    public FileSystemVirtualFile(IVirtualPathProvider owningProvider, IVirtualDirectory directory, FileInfo fInfo);
    public virtual string get_Name();
    public virtual string get_RealPath();
    public virtual DateTime get_LastModified();
    public virtual long get_Length();
    public virtual Stream OpenRead();
    public virtual void Refresh();
}
public class ServiceStack.VirtualPath.ResourceVirtualDirectory : AbstractVirtualDirectoryBase {
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <EmbeddedResourceTreatAsFiles>k__BackingField;
    protected Assembly backingAssembly;
    [CompilerGeneratedAttribute]
private string <rootNamespace>k__BackingField;
    protected List`1<ResourceVirtualDirectory> SubDirectories;
    protected List`1<ResourceVirtualFile> SubFiles;
    [CompilerGeneratedAttribute]
private string <DirectoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    public static HashSet`1<string> EmbeddedResourceTreatAsFiles { get; public set; }
    public string rootNamespace { get; public set; }
    public IEnumerable`1<IVirtualFile> Files { get; }
    public IEnumerable`1<IVirtualDirectory> Directories { get; }
    public string Name { get; }
    public string DirectoryName { get; public set; }
    public DateTime LastModified { get; }
    internal Assembly BackingAssembly { get; }
    public ResourceVirtualDirectory(IVirtualPathProvider owningProvider, IVirtualDirectory parentDir, Assembly backingAsm, DateTime lastModified, string rootNamespace);
    public ResourceVirtualDirectory(IVirtualPathProvider owningProvider, IVirtualDirectory parentDir, Assembly backingAsm, DateTime lastModified, string rootNamespace, string directoryName, List`1<string> manifestResourceNames);
    private static ResourceVirtualDirectory();
    [CompilerGeneratedAttribute]
public static HashSet`1<string> get_EmbeddedResourceTreatAsFiles();
    [CompilerGeneratedAttribute]
public static void set_EmbeddedResourceTreatAsFiles(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_rootNamespace();
    [CompilerGeneratedAttribute]
public void set_rootNamespace(string value);
    public virtual IEnumerable`1<IVirtualFile> get_Files();
    public virtual IEnumerable`1<IVirtualDirectory> get_Directories();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_DirectoryName();
    [CompilerGeneratedAttribute]
public void set_DirectoryName(string value);
    [CompilerGeneratedAttribute]
public virtual DateTime get_LastModified();
    internal Assembly get_BackingAssembly();
    public static List`1<string> GetResourceNames(Assembly asm, string basePath);
    protected void InitializeDirectoryStructure(List`1<string> manifestResourceNames);
    protected virtual ResourceVirtualDirectory CreateVirtualDirectory(IGrouping`2<string, String[]> subResources);
    protected virtual ResourceVirtualFile CreateVirtualFile(string resourceName);
    protected virtual ResourceVirtualDirectory ConsumeTokensForVirtualDir(Stack`1<string> resourceTokens);
    public virtual IEnumerator`1<IVirtualNode> GetEnumerator();
    protected virtual IVirtualFile GetFileFromBackingDirectoryOrDefault(string fileName);
    public string TranslatePath(string path);
    protected virtual IEnumerable`1<IVirtualFile> GetMatchingFilesInDir(string globPattern);
    protected virtual IVirtualDirectory GetDirectoryFromBackingDirectoryOrDefault(string directoryName);
    protected virtual string GetRealPathToRoot();
    [CompilerGeneratedAttribute]
private bool <CreateVirtualFile>b__31_0(string x);
}
public class ServiceStack.VirtualPath.ResourceVirtualFile : AbstractVirtualFileBase {
    protected Assembly BackingAssembly;
    protected string FileName;
    private Nullable`1<long> length;
    public string Name { get; }
    public string VirtualPath { get; }
    public string RealPath { get; }
    public DateTime LastModified { get; }
    public long Length { get; }
    public ResourceVirtualFile(IVirtualPathProvider owningProvider, ResourceVirtualDirectory directory, string fileName);
    public virtual string get_Name();
    public virtual string get_VirtualPath();
    public virtual string get_RealPath();
    public virtual DateTime get_LastModified();
    public virtual long get_Length();
    public virtual Stream OpenRead();
}
[ExtensionAttribute]
public static class ServiceStack.VirtualPathUtils : object {
    [CompilerGeneratedAttribute]
private static TimeSpan <MaxRetryOnExceptionTimeout>k__BackingField;
    private static HashSet`1<char> InvalidFileNameChars;
    public static TimeSpan MaxRetryOnExceptionTimeout { get; }
    private static VirtualPathUtils();
    [ExtensionAttribute]
public static Stack`1<string> TokenizeVirtualPath(string str, IVirtualPathProvider pathProvider);
    [ExtensionAttribute]
public static Stack`1<string> TokenizeVirtualPath(string str, string virtualPathSeparator);
    [ExtensionAttribute]
public static Stack`1<string> TokenizeResourcePath(string str, char pathSeparator);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<string, String[]>> GroupByFirstToken(IEnumerable`1<string> resourceNames, char pathSeparator);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(IVirtualFile file);
    [ExtensionAttribute]
public static bool Exists(IVirtualNode node);
    [ExtensionAttribute]
public static bool IsFile(IVirtualNode node);
    [ExtensionAttribute]
public static bool IsDirectory(IVirtualNode node);
    [ExtensionAttribute]
public static IVirtualNode GetVirtualNode(IVirtualPathProvider pathProvider, string virtualPath);
    [ExtensionAttribute]
public static IVirtualFile GetDefaultDocument(IVirtualDirectory dir, List`1<string> defaultDocuments);
    [CompilerGeneratedAttribute]
public static TimeSpan get_MaxRetryOnExceptionTimeout();
    [ExtensionAttribute]
internal static void SleepBackOffMultiplier(int i);
    public static string SafeFileName(string uri);
    public static bool IsValidFileName(string path);
    public static bool IsValidFilePath(string path);
}
public static class ServiceStack.When : object {
    public static string Development { get; }
    public static string Production { get; }
    public static string IsAuthenticated { get; }
    public static string get_Development();
    public static string get_Production();
    public static string get_IsAuthenticated();
    public static string HasRole(string role);
    public static string HasPermission(string perm);
    public static string HasScope(string scope);
    public static string HasClaim(string claim);
}
[ExtensionAttribute]
public static class ServiceStack.XLinqExtensions : object {
    [ExtensionAttribute]
public static string GetString(XElement el, string name);
    [ExtensionAttribute]
public static string GetStringAttributeOrDefault(XElement element, string name);
    [ExtensionAttribute]
public static T GetAttributeValueOrDefault(XAttribute attr, string name, Func`2<XAttribute, T> converter);
    [ExtensionAttribute]
public static bool GetBool(XElement el, string name);
    [ExtensionAttribute]
public static bool GetBoolOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<bool> GetNullableBool(XElement el, string name);
    [ExtensionAttribute]
public static int GetInt(XElement el, string name);
    [ExtensionAttribute]
public static int GetIntOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<int> GetNullableInt(XElement el, string name);
    [ExtensionAttribute]
public static long GetLong(XElement el, string name);
    [ExtensionAttribute]
public static long GetLongOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<long> GetNullableLong(XElement el, string name);
    [ExtensionAttribute]
public static decimal GetDecimal(XElement el, string name);
    [ExtensionAttribute]
public static decimal GetDecimalOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetNullableDecimal(XElement el, string name);
    [ExtensionAttribute]
public static DateTime GetDateTime(XElement el, string name);
    [ExtensionAttribute]
public static DateTime GetDateTimeOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<DateTime> GetNullableDateTime(XElement el, string name);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpan(XElement el, string name);
    [ExtensionAttribute]
public static TimeSpan GetTimeSpanOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<TimeSpan> GetNullableTimeSpan(XElement el, string name);
    [ExtensionAttribute]
public static Guid GetGuid(XElement el, string name);
    [ExtensionAttribute]
public static Guid GetGuidOrDefault(XElement el, string name);
    [ExtensionAttribute]
public static Nullable`1<Guid> GetNullableGuid(XElement el, string name);
    [ExtensionAttribute]
public static T GetElementValueOrDefault(XElement element, string name, Func`2<XElement, T> converter);
    [ExtensionAttribute]
public static XElement GetElement(XElement element, string name);
    [ExtensionAttribute]
public static void AssertElementHasValue(XElement element, string name);
    [ExtensionAttribute]
public static List`1<string> GetValues(IEnumerable`1<XElement> els);
    [ExtensionAttribute]
public static XAttribute AnyAttribute(XElement element, string name);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> AllElements(XElement element, string name);
    [ExtensionAttribute]
public static XElement AnyElement(XElement element, string name);
    [ExtensionAttribute]
public static XElement AnyElement(IEnumerable`1<XElement> elements, string name);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> AllElements(IEnumerable`1<XElement> elements, string name);
    [ExtensionAttribute]
public static XElement FirstElement(XElement element);
    [ExtensionAttribute]
public static XElement NextElement(XElement element);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
