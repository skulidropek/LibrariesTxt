public class SharpDX.AngleSingle : ValueType {
    public static float Degree;
    public static float Minute;
    public static float Second;
    public static float Radian;
    public static float Milliradian;
    public static float Gradian;
    private float radians;
    private int radiansInt;
    public float Revolutions { get; public set; }
    public float Degrees { get; public set; }
    public float Minutes { get; public set; }
    public float Seconds { get; public set; }
    public float Radians { get; public set; }
    public float Milliradians { get; public set; }
    public float Gradians { get; public set; }
    public bool IsRight { get; }
    public bool IsStraight { get; }
    public bool IsFullRotation { get; }
    public bool IsOblique { get; }
    public bool IsAcute { get; }
    public bool IsObtuse { get; }
    public bool IsReflex { get; }
    public AngleSingle Complement { get; }
    public AngleSingle Supplement { get; }
    public static AngleSingle ZeroAngle { get; }
    public static AngleSingle RightAngle { get; }
    public static AngleSingle StraightAngle { get; }
    public static AngleSingle FullRotationAngle { get; }
    public AngleSingle(float angle, AngleType type);
    public AngleSingle(float arcLength, float radius);
    public void Wrap();
    public void WrapPositive();
    public float get_Revolutions();
    public void set_Revolutions(float value);
    public float get_Degrees();
    public void set_Degrees(float value);
    public float get_Minutes();
    public void set_Minutes(float value);
    public float get_Seconds();
    public void set_Seconds(float value);
    public float get_Radians();
    public void set_Radians(float value);
    public float get_Milliradians();
    public void set_Milliradians(float value);
    public float get_Gradians();
    public void set_Gradians(float value);
    public bool get_IsRight();
    public bool get_IsStraight();
    public bool get_IsFullRotation();
    public bool get_IsOblique();
    public bool get_IsAcute();
    public bool get_IsObtuse();
    public bool get_IsReflex();
    public AngleSingle get_Complement();
    public AngleSingle get_Supplement();
    public static AngleSingle Wrap(AngleSingle value);
    public static AngleSingle WrapPositive(AngleSingle value);
    public static AngleSingle Min(AngleSingle left, AngleSingle right);
    public static AngleSingle Max(AngleSingle left, AngleSingle right);
    public static AngleSingle Add(AngleSingle left, AngleSingle right);
    public static AngleSingle Subtract(AngleSingle left, AngleSingle right);
    public static AngleSingle Multiply(AngleSingle left, AngleSingle right);
    public static AngleSingle Divide(AngleSingle left, AngleSingle right);
    public static AngleSingle get_ZeroAngle();
    public static AngleSingle get_RightAngle();
    public static AngleSingle get_StraightAngle();
    public static AngleSingle get_FullRotationAngle();
    public static bool op_Equality(AngleSingle left, AngleSingle right);
    public static bool op_Inequality(AngleSingle left, AngleSingle right);
    public static bool op_LessThan(AngleSingle left, AngleSingle right);
    public static bool op_GreaterThan(AngleSingle left, AngleSingle right);
    public static bool op_LessThanOrEqual(AngleSingle left, AngleSingle right);
    public static bool op_GreaterThanOrEqual(AngleSingle left, AngleSingle right);
    public static AngleSingle op_UnaryPlus(AngleSingle value);
    public static AngleSingle op_UnaryNegation(AngleSingle value);
    public static AngleSingle op_Addition(AngleSingle left, AngleSingle right);
    public static AngleSingle op_Subtraction(AngleSingle left, AngleSingle right);
    public static AngleSingle op_Multiply(AngleSingle left, AngleSingle right);
    public static AngleSingle op_Division(AngleSingle left, AngleSingle right);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(AngleSingle other);
    public sealed virtual bool Equals(AngleSingle other);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum SharpDX.AngleType : Enum {
    public int value__;
    public static AngleType Revolution;
    public static AngleType Degree;
    public static AngleType Radian;
    public static AngleType Gradian;
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Bool4 : ValueType {
    public static int SizeInBytes;
    public static Bool4 False;
    public static Bool4 UnitX;
    public static Bool4 UnitY;
    public static Bool4 UnitZ;
    public static Bool4 UnitW;
    public static Bool4 One;
    internal int iX;
    internal int iY;
    internal int iZ;
    internal int iW;
    public bool X { get; public set; }
    public bool Y { get; public set; }
    public bool Z { get; public set; }
    public bool W { get; public set; }
    public bool Item { get; public set; }
    public Bool4(bool value);
    public Bool4(bool x, bool y, bool z, bool w);
    public Bool4(Boolean[] values);
    private static Bool4();
    public bool get_X();
    public void set_X(bool value);
    public bool get_Y();
    public void set_Y(bool value);
    public bool get_Z();
    public void set_Z(bool value);
    public bool get_W();
    public void set_W(bool value);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public Boolean[] ToArray();
    public static bool op_Equality(Bool4 left, Bool4 right);
    public static bool op_Inequality(Bool4 left, Bool4 right);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Bool4& other);
    public sealed virtual bool Equals(Bool4 other);
    public virtual bool Equals(object value);
    public static Bool4 op_Implicit(Boolean[] input);
    public static Boolean[] op_Implicit(Bool4 input);
    public static RawBool4 op_Implicit(Bool4 value);
    public static Bool4 op_Implicit(RawBool4 value);
}
public class SharpDX.BoundingBox : ValueType {
    public Vector3 Minimum;
    public Vector3 Maximum;
    public float Width { get; }
    public float Height { get; }
    public float Depth { get; }
    public Vector3 Size { get; }
    public Vector3 Center { get; }
    public BoundingBox(Vector3 minimum, Vector3 maximum);
    public float get_Width();
    public float get_Height();
    public float get_Depth();
    public Vector3 get_Size();
    public Vector3 get_Center();
    public Vector3[] GetCorners();
    public void GetCorners(Vector3[] corners);
    public bool Intersects(Ray& ray);
    public bool Intersects(Ray& ray, Single& distance);
    public bool Intersects(Ray& ray, Vector3& point);
    public PlaneIntersectionType Intersects(Plane& plane);
    public bool Intersects(BoundingBox& box);
    public bool Intersects(BoundingBox box);
    public bool Intersects(BoundingSphere& sphere);
    public bool Intersects(BoundingSphere sphere);
    public ContainmentType Contains(Vector3& point);
    public ContainmentType Contains(Vector3 point);
    public ContainmentType Contains(BoundingBox& box);
    public ContainmentType Contains(BoundingBox box);
    public ContainmentType Contains(BoundingSphere& sphere);
    public ContainmentType Contains(BoundingSphere sphere);
    public static void FromPoints(Vector3[] points, BoundingBox& result);
    public static BoundingBox FromPoints(Vector3[] points);
    public static void FromSphere(BoundingSphere& sphere, BoundingBox& result);
    public static BoundingBox FromSphere(BoundingSphere sphere);
    public static void Merge(BoundingBox& value1, BoundingBox& value2, BoundingBox& result);
    public static BoundingBox Merge(BoundingBox value1, BoundingBox value2);
    public static bool op_Equality(BoundingBox left, BoundingBox right);
    public static bool op_Inequality(BoundingBox left, BoundingBox right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(BoundingBox& value);
    public sealed virtual bool Equals(BoundingBox value);
    public virtual bool Equals(object value);
}
public class SharpDX.BoundingFrustum : ValueType {
    private Matrix pMatrix;
    private Plane pNear;
    private Plane pFar;
    private Plane pLeft;
    private Plane pRight;
    private Plane pTop;
    private Plane pBottom;
    public Matrix Matrix { get; public set; }
    public Plane Near { get; }
    public Plane Far { get; }
    public Plane Left { get; }
    public Plane Right { get; }
    public Plane Top { get; }
    public Plane Bottom { get; }
    public bool IsOrthographic { get; }
    public BoundingFrustum(Matrix matrix);
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    public Plane get_Near();
    public Plane get_Far();
    public Plane get_Left();
    public Plane get_Right();
    public Plane get_Top();
    public Plane get_Bottom();
    public virtual int GetHashCode();
    public bool Equals(BoundingFrustum& other);
    public sealed virtual bool Equals(BoundingFrustum other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BoundingFrustum left, BoundingFrustum right);
    public static bool op_Inequality(BoundingFrustum left, BoundingFrustum right);
    public Plane GetPlane(int index);
    private static void GetPlanesFromMatrix(Matrix& matrix, Plane& near, Plane& far, Plane& left, Plane& right, Plane& top, Plane& bottom);
    private static Vector3 Get3PlanesInterPoint(Plane& p1, Plane& p2, Plane& p3);
    public static BoundingFrustum FromCamera(Vector3 cameraPos, Vector3 lookDir, Vector3 upDir, float fov, float znear, float zfar, float aspect);
    public static BoundingFrustum FromCamera(FrustumCameraParams cameraParams);
    public Vector3[] GetCorners();
    public void GetCorners(Vector3[] corners);
    public FrustumCameraParams GetCameraParams();
    public ContainmentType Contains(Vector3& point);
    public ContainmentType Contains(Vector3 point);
    public ContainmentType Contains(Vector3[] points);
    public void Contains(Vector3[] points, ContainmentType& result);
    private void GetBoxToPlanePVertexNVertex(BoundingBox& box, Vector3& planeNormal, Vector3& p, Vector3& n);
    public ContainmentType Contains(BoundingBox& box);
    public ContainmentType Contains(BoundingBox box);
    public void Contains(BoundingBox& box, ContainmentType& result);
    public ContainmentType Contains(BoundingSphere& sphere);
    public ContainmentType Contains(BoundingSphere sphere);
    public void Contains(BoundingSphere& sphere, ContainmentType& result);
    public bool Contains(BoundingFrustum& frustum);
    public bool Contains(BoundingFrustum frustum);
    public void Contains(BoundingFrustum& frustum, Boolean& result);
    public bool Intersects(BoundingSphere& sphere);
    public void Intersects(BoundingSphere& sphere, Boolean& result);
    public bool Intersects(BoundingBox& box);
    public void Intersects(BoundingBox& box, Boolean& result);
    private PlaneIntersectionType PlaneIntersectsPoints(Plane& plane, Vector3[] points);
    public PlaneIntersectionType Intersects(Plane& plane);
    public void Intersects(Plane& plane, PlaneIntersectionType& result);
    public float GetWidthAtDepth(float depth);
    public float GetHeightAtDepth(float depth);
    private BoundingFrustum GetInsideOutClone();
    public bool Intersects(Ray& ray);
    public bool Intersects(Ray& ray, Nullable`1& inDistance, Nullable`1& outDistance);
    public float GetZoomToExtentsShiftDistance(Vector3[] points);
    public float GetZoomToExtentsShiftDistance(BoundingBox& boundingBox);
    public Vector3 GetZoomToExtentsShiftVector(Vector3[] points);
    public Vector3 GetZoomToExtentsShiftVector(BoundingBox& boundingBox);
    public bool get_IsOrthographic();
}
public class SharpDX.BoundingSphere : ValueType {
    public Vector3 Center;
    public float Radius;
    public BoundingSphere(Vector3 center, float radius);
    public bool Intersects(Ray& ray);
    public bool Intersects(Ray& ray, Single& distance);
    public bool Intersects(Ray& ray, Vector3& point);
    public PlaneIntersectionType Intersects(Plane& plane);
    public bool Intersects(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public bool Intersects(BoundingBox& box);
    public bool Intersects(BoundingBox box);
    public bool Intersects(BoundingSphere& sphere);
    public bool Intersects(BoundingSphere sphere);
    public ContainmentType Contains(Vector3& point);
    public ContainmentType Contains(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public ContainmentType Contains(BoundingBox& box);
    public ContainmentType Contains(BoundingSphere& sphere);
    public static void FromPoints(Vector3[] points, int start, int count, BoundingSphere& result);
    public static void FromPoints(Vector3[] points, BoundingSphere& result);
    public static BoundingSphere FromPoints(Vector3[] points);
    public static void FromBox(BoundingBox& box, BoundingSphere& result);
    public static BoundingSphere FromBox(BoundingBox box);
    public static void Merge(BoundingSphere& value1, BoundingSphere& value2, BoundingSphere& result);
    public static BoundingSphere Merge(BoundingSphere value1, BoundingSphere value2);
    public static bool op_Equality(BoundingSphere left, BoundingSphere right);
    public static bool op_Inequality(BoundingSphere left, BoundingSphere right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(BoundingSphere& value);
    public sealed virtual bool Equals(BoundingSphere value);
    public virtual bool Equals(object value);
}
public static class SharpDX.Collision : object {
    public static void ClosestPointPointTriangle(Vector3& point, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3, Vector3& result);
    public static void ClosestPointPlanePoint(Plane& plane, Vector3& point, Vector3& result);
    public static void ClosestPointBoxPoint(BoundingBox& box, Vector3& point, Vector3& result);
    public static void ClosestPointSpherePoint(BoundingSphere& sphere, Vector3& point, Vector3& result);
    public static void ClosestPointSphereSphere(BoundingSphere& sphere1, BoundingSphere& sphere2, Vector3& result);
    public static float DistancePlanePoint(Plane& plane, Vector3& point);
    public static float DistanceBoxPoint(BoundingBox& box, Vector3& point);
    public static float DistanceBoxBox(BoundingBox& box1, BoundingBox& box2);
    public static float DistanceSpherePoint(BoundingSphere& sphere, Vector3& point);
    public static float DistanceSphereSphere(BoundingSphere& sphere1, BoundingSphere& sphere2);
    public static bool RayIntersectsPoint(Ray& ray, Vector3& point);
    public static bool RayIntersectsRay(Ray& ray1, Ray& ray2, Vector3& point);
    public static bool RayIntersectsPlane(Ray& ray, Plane& plane, Single& distance);
    public static bool RayIntersectsPlane(Ray& ray, Plane& plane, Vector3& point);
    public static bool RayIntersectsTriangle(Ray& ray, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3, Single& distance);
    public static bool RayIntersectsTriangle(Ray& ray, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3, Vector3& point);
    public static bool RayIntersectsBox(Ray& ray, BoundingBox& box, Single& distance);
    public static bool RayIntersectsBox(Ray& ray, BoundingBox& box, Vector3& point);
    public static bool RayIntersectsSphere(Ray& ray, BoundingSphere& sphere, Single& distance);
    public static bool RayIntersectsSphere(Ray& ray, BoundingSphere& sphere, Vector3& point);
    public static PlaneIntersectionType PlaneIntersectsPoint(Plane& plane, Vector3& point);
    public static bool PlaneIntersectsPlane(Plane& plane1, Plane& plane2);
    public static bool PlaneIntersectsPlane(Plane& plane1, Plane& plane2, Ray& line);
    public static PlaneIntersectionType PlaneIntersectsTriangle(Plane& plane, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public static PlaneIntersectionType PlaneIntersectsBox(Plane& plane, BoundingBox& box);
    public static PlaneIntersectionType PlaneIntersectsSphere(Plane& plane, BoundingSphere& sphere);
    public static bool BoxIntersectsBox(BoundingBox& box1, BoundingBox& box2);
    public static bool BoxIntersectsSphere(BoundingBox& box, BoundingSphere& sphere);
    public static bool SphereIntersectsTriangle(BoundingSphere& sphere, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public static bool SphereIntersectsSphere(BoundingSphere& sphere1, BoundingSphere& sphere2);
    public static ContainmentType BoxContainsPoint(BoundingBox& box, Vector3& point);
    public static ContainmentType BoxContainsBox(BoundingBox& box1, BoundingBox& box2);
    public static ContainmentType BoxContainsSphere(BoundingBox& box, BoundingSphere& sphere);
    public static ContainmentType SphereContainsPoint(BoundingSphere& sphere, Vector3& point);
    public static ContainmentType SphereContainsTriangle(BoundingSphere& sphere, Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public static ContainmentType SphereContainsBox(BoundingSphere& sphere, BoundingBox& box);
    public static ContainmentType SphereContainsSphere(BoundingSphere& sphere1, BoundingSphere& sphere2);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Color : ValueType {
    private static string toStringFormat;
    public byte R;
    public byte G;
    public byte B;
    public byte A;
    public static Color Zero;
    public static Color Transparent;
    public static Color AliceBlue;
    public static Color AntiqueWhite;
    public static Color Aqua;
    public static Color Aquamarine;
    public static Color Azure;
    public static Color Beige;
    public static Color Bisque;
    public static Color Black;
    public static Color BlanchedAlmond;
    public static Color Blue;
    public static Color BlueViolet;
    public static Color Brown;
    public static Color BurlyWood;
    public static Color CadetBlue;
    public static Color Chartreuse;
    public static Color Chocolate;
    public static Color Coral;
    public static Color CornflowerBlue;
    public static Color Cornsilk;
    public static Color Crimson;
    public static Color Cyan;
    public static Color DarkBlue;
    public static Color DarkCyan;
    public static Color DarkGoldenrod;
    public static Color DarkGray;
    public static Color DarkGreen;
    public static Color DarkKhaki;
    public static Color DarkMagenta;
    public static Color DarkOliveGreen;
    public static Color DarkOrange;
    public static Color DarkOrchid;
    public static Color DarkRed;
    public static Color DarkSalmon;
    public static Color DarkSeaGreen;
    public static Color DarkSlateBlue;
    public static Color DarkSlateGray;
    public static Color DarkTurquoise;
    public static Color DarkViolet;
    public static Color DeepPink;
    public static Color DeepSkyBlue;
    public static Color DimGray;
    public static Color DodgerBlue;
    public static Color Firebrick;
    public static Color FloralWhite;
    public static Color ForestGreen;
    public static Color Fuchsia;
    public static Color Gainsboro;
    public static Color GhostWhite;
    public static Color Gold;
    public static Color Goldenrod;
    public static Color Gray;
    public static Color Green;
    public static Color GreenYellow;
    public static Color Honeydew;
    public static Color HotPink;
    public static Color IndianRed;
    public static Color Indigo;
    public static Color Ivory;
    public static Color Khaki;
    public static Color Lavender;
    public static Color LavenderBlush;
    public static Color LawnGreen;
    public static Color LemonChiffon;
    public static Color LightBlue;
    public static Color LightCoral;
    public static Color LightCyan;
    public static Color LightGoldenrodYellow;
    public static Color LightGray;
    public static Color LightGreen;
    public static Color LightPink;
    public static Color LightSalmon;
    public static Color LightSeaGreen;
    public static Color LightSkyBlue;
    public static Color LightSlateGray;
    public static Color LightSteelBlue;
    public static Color LightYellow;
    public static Color Lime;
    public static Color LimeGreen;
    public static Color Linen;
    public static Color Magenta;
    public static Color Maroon;
    public static Color MediumAquamarine;
    public static Color MediumBlue;
    public static Color MediumOrchid;
    public static Color MediumPurple;
    public static Color MediumSeaGreen;
    public static Color MediumSlateBlue;
    public static Color MediumSpringGreen;
    public static Color MediumTurquoise;
    public static Color MediumVioletRed;
    public static Color MidnightBlue;
    public static Color MintCream;
    public static Color MistyRose;
    public static Color Moccasin;
    public static Color NavajoWhite;
    public static Color Navy;
    public static Color OldLace;
    public static Color Olive;
    public static Color OliveDrab;
    public static Color Orange;
    public static Color OrangeRed;
    public static Color Orchid;
    public static Color PaleGoldenrod;
    public static Color PaleGreen;
    public static Color PaleTurquoise;
    public static Color PaleVioletRed;
    public static Color PapayaWhip;
    public static Color PeachPuff;
    public static Color Peru;
    public static Color Pink;
    public static Color Plum;
    public static Color PowderBlue;
    public static Color Purple;
    public static Color Red;
    public static Color RosyBrown;
    public static Color RoyalBlue;
    public static Color SaddleBrown;
    public static Color Salmon;
    public static Color SandyBrown;
    public static Color SeaGreen;
    public static Color SeaShell;
    public static Color Sienna;
    public static Color Silver;
    public static Color SkyBlue;
    public static Color SlateBlue;
    public static Color SlateGray;
    public static Color Snow;
    public static Color SpringGreen;
    public static Color SteelBlue;
    public static Color Tan;
    public static Color Teal;
    public static Color Thistle;
    public static Color Tomato;
    public static Color Turquoise;
    public static Color Violet;
    public static Color Wheat;
    public static Color White;
    public static Color WhiteSmoke;
    public static Color Yellow;
    public static Color YellowGreen;
    public byte Item { get; public set; }
    public Color(byte value);
    public Color(float value);
    public Color(byte red, byte green, byte blue, byte alpha);
    public Color(byte red, byte green, byte blue);
    public Color(int red, int green, int blue, int alpha);
    public Color(int red, int green, int blue);
    public Color(float red, float green, float blue, float alpha);
    public Color(float red, float green, float blue);
    public Color(Vector4 value);
    public Color(Vector3 value, float alpha);
    public Color(Vector3 value);
    public Color(UInt32 rgba);
    public Color(int rgba);
    public Color(Single[] values);
    public Color(Byte[] values);
    private static Color();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public int ToBgra();
    public int ToRgba();
    public int ToAbgr();
    public Vector3 ToVector3();
    public Color3 ToColor3();
    public Vector4 ToVector4();
    public Byte[] ToArray();
    public float GetBrightness();
    public float GetHue();
    public float GetSaturation();
    public static void Add(Color& left, Color& right, Color& result);
    public static Color Add(Color left, Color right);
    public static void Subtract(Color& left, Color& right, Color& result);
    public static Color Subtract(Color left, Color right);
    public static void Modulate(Color& left, Color& right, Color& result);
    public static Color Modulate(Color left, Color right);
    public static void Scale(Color& value, float scale, Color& result);
    public static Color Scale(Color value, float scale);
    public static void Negate(Color& value, Color& result);
    public static Color Negate(Color value);
    public static void Clamp(Color& value, Color& min, Color& max, Color& result);
    public static void Premultiply(Color& value, Color& result);
    public static Color Premultiply(Color value);
    public static Color FromBgra(int color);
    public static Color FromBgra(UInt32 color);
    public static Color FromAbgr(int color);
    public static Color FromAbgr(UInt32 color);
    public static Color FromRgba(int color);
    public static Color FromRgba(UInt32 color);
    public static Color Clamp(Color value, Color min, Color max);
    public static void Lerp(Color& start, Color& end, float amount, Color& result);
    public static Color Lerp(Color start, Color end, float amount);
    public static void SmoothStep(Color& start, Color& end, float amount, Color& result);
    public static Color SmoothStep(Color start, Color end, float amount);
    public static void Max(Color& left, Color& right, Color& result);
    public static Color Max(Color left, Color right);
    public static void Min(Color& left, Color& right, Color& result);
    public static Color Min(Color left, Color right);
    public static void AdjustContrast(Color& value, float contrast, Color& result);
    public static Color AdjustContrast(Color value, float contrast);
    public static void AdjustSaturation(Color& value, float saturation, Color& result);
    public static Color AdjustSaturation(Color value, float saturation);
    public static Color op_Addition(Color left, Color right);
    public static Color op_UnaryPlus(Color value);
    public static Color op_Subtraction(Color left, Color right);
    public static Color op_UnaryNegation(Color value);
    public static Color op_Multiply(float scale, Color value);
    public static Color op_Multiply(Color value, float scale);
    public static Color op_Multiply(Color left, Color right);
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    public static Color3 op_Explicit(Color value);
    public static Vector3 op_Explicit(Color value);
    public static Vector4 op_Explicit(Color value);
    public Color4 ToColor4();
    public static Color4 op_Implicit(Color value);
    public static RawColor4 op_Implicit(Color value);
    public static RawColorBGRA op_Implicit(Color value);
    public static Nullable`1<RawColor4> op_Implicit(Color value);
    public static Color op_Explicit(Vector3 value);
    public static Color op_Explicit(Color3 value);
    public static Color op_Explicit(Vector4 value);
    public static Color op_Explicit(Color4 value);
    public static int op_Explicit(Color value);
    public static Color op_Explicit(int value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Color& other);
    public sealed virtual bool Equals(Color other);
    public virtual bool Equals(object value);
    private static byte ToByte(float component);
    public static byte ToByte(int value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Color3 : ValueType {
    private static string toStringFormat;
    public static Color3 Black;
    public static Color3 White;
    public float Red;
    public float Green;
    public float Blue;
    public float Item { get; public set; }
    public Color3(float value);
    public Color3(float red, float green, float blue);
    public Color3(Vector3 value);
    public Color3(int rgb);
    public Color3(Single[] values);
    private static Color3();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public int ToRgba();
    public int ToBgra();
    public Vector3 ToVector3();
    public Single[] ToArray();
    public static void Add(Color3& left, Color3& right, Color3& result);
    public static Color3 Add(Color3 left, Color3 right);
    public static void Subtract(Color3& left, Color3& right, Color3& result);
    public static Color3 Subtract(Color3 left, Color3 right);
    public static void Modulate(Color3& left, Color3& right, Color3& result);
    public static Color3 Modulate(Color3 left, Color3 right);
    public static void Scale(Color3& value, float scale, Color3& result);
    public static Color3 Scale(Color3 value, float scale);
    public static void Negate(Color3& value, Color3& result);
    public static Color3 Negate(Color3 value);
    public static void Clamp(Color3& value, Color3& min, Color3& max, Color3& result);
    public static Color3 Clamp(Color3 value, Color3 min, Color3 max);
    public static void Lerp(Color3& start, Color3& end, float amount, Color3& result);
    public static Color3 Lerp(Color3 start, Color3 end, float amount);
    public static void SmoothStep(Color3& start, Color3& end, float amount, Color3& result);
    public static Color3 SmoothStep(Color3 start, Color3 end, float amount);
    public static void Max(Color3& left, Color3& right, Color3& result);
    public static Color3 Max(Color3 left, Color3 right);
    public static void Min(Color3& left, Color3& right, Color3& result);
    public static Color3 Min(Color3 left, Color3 right);
    public static void AdjustContrast(Color3& value, float contrast, Color3& result);
    public static Color3 AdjustContrast(Color3 value, float contrast);
    public static void AdjustSaturation(Color3& value, float saturation, Color3& result);
    public static Color3 AdjustSaturation(Color3 value, float saturation);
    public static void Premultiply(Color3& value, float alpha, Color3& result);
    public static Color3 Premultiply(Color3 value, float alpha);
    public static Color3 op_Addition(Color3 left, Color3 right);
    public static Color3 op_UnaryPlus(Color3 value);
    public static Color3 op_Subtraction(Color3 left, Color3 right);
    public static Color3 op_UnaryNegation(Color3 value);
    public static Color3 op_Multiply(float scale, Color3 value);
    public static Color3 op_Multiply(Color3 value, float scale);
    public static Color3 op_Multiply(Color3 left, Color3 right);
    public static bool op_Equality(Color3 left, Color3 right);
    public static bool op_Inequality(Color3 left, Color3 right);
    public static Color4 op_Explicit(Color3 value);
    public static Vector3 op_Implicit(Color3 value);
    public static Color3 op_Implicit(Vector3 value);
    public static Color3 op_Explicit(int value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Color3& other);
    public sealed virtual bool Equals(Color3 other);
    public virtual bool Equals(object value);
    public static RawColor3 op_Implicit(Color3 value);
    public static Color3 op_Implicit(RawColor3 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Color4 : ValueType {
    private static string toStringFormat;
    public static Color4 Black;
    public static Color4 White;
    public float Red;
    public float Green;
    public float Blue;
    public float Alpha;
    public float Item { get; public set; }
    public Color4(float value);
    public Color4(float red, float green, float blue, float alpha);
    public Color4(Vector4 value);
    public Color4(Vector3 value, float alpha);
    public Color4(UInt32 rgba);
    public Color4(int rgba);
    public Color4(Single[] values);
    public Color4(Color3 color);
    public Color4(Color3 color, float alpha);
    private static Color4();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public int ToBgra();
    public void ToBgra(Byte& r, Byte& g, Byte& b, Byte& a);
    public int ToRgba();
    public Vector3 ToVector3();
    public Vector4 ToVector4();
    public Single[] ToArray();
    public static void Add(Color4& left, Color4& right, Color4& result);
    public static Color4 Add(Color4 left, Color4 right);
    public static void Subtract(Color4& left, Color4& right, Color4& result);
    public static Color4 Subtract(Color4 left, Color4 right);
    public static void Modulate(Color4& left, Color4& right, Color4& result);
    public static Color4 Modulate(Color4 left, Color4 right);
    public static void Scale(Color4& value, float scale, Color4& result);
    public static Color4 Scale(Color4 value, float scale);
    public static void Negate(Color4& value, Color4& result);
    public static Color4 Negate(Color4 value);
    public static void Clamp(Color4& value, Color4& min, Color4& max, Color4& result);
    public static Color4 Clamp(Color4 value, Color4 min, Color4 max);
    public static void Lerp(Color4& start, Color4& end, float amount, Color4& result);
    public static Color4 Lerp(Color4 start, Color4 end, float amount);
    public static void SmoothStep(Color4& start, Color4& end, float amount, Color4& result);
    public static Color4 SmoothStep(Color4 start, Color4 end, float amount);
    public static void Max(Color4& left, Color4& right, Color4& result);
    public static Color4 Max(Color4 left, Color4 right);
    public static void Min(Color4& left, Color4& right, Color4& result);
    public static Color4 Min(Color4 left, Color4 right);
    public static void AdjustContrast(Color4& value, float contrast, Color4& result);
    public static Color4 AdjustContrast(Color4 value, float contrast);
    public static void AdjustSaturation(Color4& value, float saturation, Color4& result);
    public static Color4 AdjustSaturation(Color4 value, float saturation);
    public static void Premultiply(Color4& value, Color4& result);
    public static Color4 Premultiply(Color4 value);
    public static Color4 op_Addition(Color4 left, Color4 right);
    public static Color4 op_UnaryPlus(Color4 value);
    public static Color4 op_Subtraction(Color4 left, Color4 right);
    public static Color4 op_UnaryNegation(Color4 value);
    public static Color4 op_Multiply(float scale, Color4 value);
    public static Color4 op_Multiply(Color4 value, float scale);
    public static Color4 op_Multiply(Color4 left, Color4 right);
    public static bool op_Equality(Color4 left, Color4 right);
    public static bool op_Inequality(Color4 left, Color4 right);
    public static Color3 op_Explicit(Color4 value);
    public static Vector3 op_Explicit(Color4 value);
    public static Vector4 op_Implicit(Color4 value);
    public static Color4 op_Explicit(Vector3 value);
    public static Color4 op_Explicit(Vector4 value);
    public static Color4 op_Explicit(ColorBGRA value);
    public static ColorBGRA op_Explicit(Color4 value);
    public static int op_Explicit(Color4 value);
    public static Color4 op_Explicit(int value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Color4& other);
    public sealed virtual bool Equals(Color4 other);
    public virtual bool Equals(object value);
    public static RawColor4 op_Implicit(Color4 value);
    public static Color4 op_Implicit(RawColor4 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.ColorBGRA : ValueType {
    private static string toStringFormat;
    public byte B;
    public byte G;
    public byte R;
    public byte A;
    public byte Item { get; public set; }
    public ColorBGRA(byte value);
    public ColorBGRA(float value);
    public ColorBGRA(byte red, byte green, byte blue, byte alpha);
    public ColorBGRA(float red, float green, float blue, float alpha);
    public ColorBGRA(Vector4 value);
    public ColorBGRA(Vector3 value, float alpha);
    public ColorBGRA(UInt32 bgra);
    public ColorBGRA(int bgra);
    public ColorBGRA(Single[] values);
    public ColorBGRA(Byte[] values);
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public int ToBgra();
    public int ToRgba();
    public Vector3 ToVector3();
    public Color3 ToColor3();
    public Vector4 ToVector4();
    public Byte[] ToArray();
    public float GetBrightness();
    public float GetHue();
    public float GetSaturation();
    public static ColorBGRA FromBgra(int color);
    public static ColorBGRA FromBgra(UInt32 color);
    public static ColorBGRA FromRgba(int color);
    public static ColorBGRA FromRgba(UInt32 color);
    public static void Add(ColorBGRA& left, ColorBGRA& right, ColorBGRA& result);
    public static ColorBGRA Add(ColorBGRA left, ColorBGRA right);
    public static void Subtract(ColorBGRA& left, ColorBGRA& right, ColorBGRA& result);
    public static ColorBGRA Subtract(ColorBGRA left, ColorBGRA right);
    public static void Modulate(ColorBGRA& left, ColorBGRA& right, ColorBGRA& result);
    public static ColorBGRA Modulate(ColorBGRA left, ColorBGRA right);
    public static void Scale(ColorBGRA& value, float scale, ColorBGRA& result);
    public static ColorBGRA Scale(ColorBGRA value, float scale);
    public static void Negate(ColorBGRA& value, ColorBGRA& result);
    public static ColorBGRA Negate(ColorBGRA value);
    public static void Clamp(ColorBGRA& value, ColorBGRA& min, ColorBGRA& max, ColorBGRA& result);
    public static ColorBGRA Clamp(ColorBGRA value, ColorBGRA min, ColorBGRA max);
    public static void Lerp(ColorBGRA& start, ColorBGRA& end, float amount, ColorBGRA& result);
    public static ColorBGRA Lerp(ColorBGRA start, ColorBGRA end, float amount);
    public static void SmoothStep(ColorBGRA& start, ColorBGRA& end, float amount, ColorBGRA& result);
    public static ColorBGRA SmoothStep(ColorBGRA start, ColorBGRA end, float amount);
    public static void Max(ColorBGRA& left, ColorBGRA& right, ColorBGRA& result);
    public static ColorBGRA Max(ColorBGRA left, ColorBGRA right);
    public static void Min(ColorBGRA& left, ColorBGRA& right, ColorBGRA& result);
    public static ColorBGRA Min(ColorBGRA left, ColorBGRA right);
    public static void AdjustContrast(ColorBGRA& value, float contrast, ColorBGRA& result);
    public static ColorBGRA AdjustContrast(ColorBGRA value, float contrast);
    public static void AdjustSaturation(ColorBGRA& value, float saturation, ColorBGRA& result);
    public static ColorBGRA AdjustSaturation(ColorBGRA value, float saturation);
    public static void Premultiply(ColorBGRA& value, ColorBGRA& result);
    public static ColorBGRA Premultiply(ColorBGRA value);
    public static ColorBGRA op_Addition(ColorBGRA left, ColorBGRA right);
    public static ColorBGRA op_UnaryPlus(ColorBGRA value);
    public static ColorBGRA op_Subtraction(ColorBGRA left, ColorBGRA right);
    public static ColorBGRA op_UnaryNegation(ColorBGRA value);
    public static ColorBGRA op_Multiply(float scale, ColorBGRA value);
    public static ColorBGRA op_Multiply(ColorBGRA value, float scale);
    public static ColorBGRA op_Multiply(ColorBGRA left, ColorBGRA right);
    public static bool op_Equality(ColorBGRA left, ColorBGRA right);
    public static bool op_Inequality(ColorBGRA left, ColorBGRA right);
    public static Color3 op_Explicit(ColorBGRA value);
    public static Vector3 op_Explicit(ColorBGRA value);
    public static Vector4 op_Explicit(ColorBGRA value);
    public static Color4 op_Explicit(ColorBGRA value);
    public static ColorBGRA op_Explicit(Vector3 value);
    public static ColorBGRA op_Explicit(Color3 value);
    public static ColorBGRA op_Explicit(Vector4 value);
    public static ColorBGRA op_Explicit(Color4 value);
    public static ColorBGRA op_Implicit(Color value);
    public static Color op_Implicit(ColorBGRA value);
    public static int op_Explicit(ColorBGRA value);
    public static ColorBGRA op_Explicit(int value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(ColorBGRA& other);
    public sealed virtual bool Equals(ColorBGRA other);
    public virtual bool Equals(object value);
    private static byte ToByte(float component);
    public static RawColorBGRA op_Implicit(ColorBGRA value);
    public static ColorBGRA op_Implicit(RawColorBGRA value);
}
public enum SharpDX.ContainmentType : Enum {
    public int value__;
    public static ContainmentType Disjoint;
    public static ContainmentType Contains;
    public static ContainmentType Intersects;
}
public class SharpDX.FrustumCameraParams : ValueType {
    public Vector3 Position;
    public Vector3 LookAtDir;
    public Vector3 UpDir;
    public float FOV;
    public float ZNear;
    public float ZFar;
    public float AspectRatio;
}
public class SharpDX.Half : ValueType {
    private ushort value;
    public static int PrecisionDigits;
    public static int MantissaBits;
    public static int MaximumDecimalExponent;
    public static int MaximumBinaryExponent;
    public static int MinimumDecimalExponent;
    public static int MinimumBinaryExponent;
    public static int ExponentRadix;
    public static int AdditionRounding;
    public static float Epsilon;
    public static float MaxValue;
    public static float MinValue;
    public ushort RawValue { get; public set; }
    public Half(float value);
    public Half(ushort rawvalue);
    private static Half();
    public ushort get_RawValue();
    public void set_RawValue(ushort value);
    public static Single[] ConvertToFloat(Half[] values);
    public static Half[] ConvertToHalf(Single[] values);
    public static Half op_Implicit(float value);
    public static float op_Implicit(Half value);
    public static bool op_Equality(Half left, Half right);
    public static bool op_Inequality(Half left, Half right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static bool Equals(Half& value1, Half& value2);
    public bool Equals(Half other);
    public virtual bool Equals(object obj);
}
public class SharpDX.Half2 : ValueType {
    public Half X;
    public Half Y;
    public Half2(Half x, Half y);
    public Half2(float x, float y);
    public Half2(ushort x, ushort y);
    public Half2(Half value);
    public Half2(float value);
    public static Half2 op_Implicit(Vector2 value);
    public static Vector2 op_Implicit(Half2 value);
    public static bool op_Equality(Half2 left, Half2 right);
    public static bool op_Inequality(Half2 left, Half2 right);
    public virtual int GetHashCode();
    public static bool Equals(Half2& value1, Half2& value2);
    public sealed virtual bool Equals(Half2 other);
    public virtual bool Equals(object obj);
}
public class SharpDX.Half3 : ValueType {
    public Half X;
    public Half Y;
    public Half Z;
    public Half3(Half x, Half y, Half z);
    public Half3(float x, float y, float z);
    public Half3(ushort x, ushort y, ushort z);
    public Half3(Half value);
    public static Half3 op_Implicit(Vector3 value);
    public static Vector3 op_Implicit(Half3 value);
    public static Half3 op_Explicit(Vector2 value);
    public static Vector2 op_Explicit(Half3 value);
    public static bool op_Equality(Half3 left, Half3 right);
    public static bool op_Inequality(Half3 left, Half3 right);
    public virtual int GetHashCode();
    public static bool Equals(Half3& value1, Half3& value2);
    public sealed virtual bool Equals(Half3 other);
    public virtual bool Equals(object obj);
}
public class SharpDX.Half4 : ValueType {
    public Half X;
    public Half Y;
    public Half Z;
    public Half W;
    public Half4(Half x, Half y, Half z, Half w);
    public Half4(float x, float y, float z, float w);
    public Half4(ushort x, ushort y, ushort z, ushort w);
    public Half4(Half value);
    public static Half4 op_Implicit(Vector4 value);
    public static Vector4 op_Implicit(Half4 value);
    public static Half4 op_Explicit(Vector3 value);
    public static Vector3 op_Explicit(Half4 value);
    public static Half4 op_Explicit(Vector2 value);
    public static Vector2 op_Explicit(Half4 value);
    public static bool op_Equality(Half4 left, Half4 right);
    public static bool op_Inequality(Half4 left, Half4 right);
    public virtual int GetHashCode();
    public static bool Equals(Half4& value1, Half4& value2);
    public sealed virtual bool Equals(Half4 other);
    public virtual bool Equals(object obj);
}
internal class SharpDX.HalfUtils : object {
    private static UInt32[] HalfToFloatMantissaTable;
    private static UInt32[] HalfToFloatExponentTable;
    private static UInt32[] HalfToFloatOffsetTable;
    private static UInt16[] FloatToHalfBaseTable;
    private static Byte[] FloatToHalfShiftTable;
    private static HalfUtils();
    public static float Unpack(ushort h);
    public static ushort Pack(float f);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Int3 : ValueType {
    public static int SizeInBytes;
    public static Int3 Zero;
    public static Int3 UnitX;
    public static Int3 UnitY;
    public static Int3 UnitZ;
    public static Int3 One;
    public int X;
    public int Y;
    public int Z;
    public int Item { get; public set; }
    public Int3(int value);
    public Int3(int x, int y, int z);
    public Int3(Int32[] values);
    private static Int3();
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public Int32[] ToArray();
    public static void Add(Int3& left, Int3& right, Int3& result);
    public static Int3 Add(Int3 left, Int3 right);
    public static void Subtract(Int3& left, Int3& right, Int3& result);
    public static Int3 Subtract(Int3 left, Int3 right);
    public static void Multiply(Int3& value, int scale, Int3& result);
    public static Int3 Multiply(Int3 value, int scale);
    public static void Modulate(Int3& left, Int3& right, Int3& result);
    public static Int3 Modulate(Int3 left, Int3 right);
    public static void Divide(Int3& value, int scale, Int3& result);
    public static Int3 Divide(Int3 value, int scale);
    public static void Negate(Int3& value, Int3& result);
    public static Int3 Negate(Int3 value);
    public static void Clamp(Int3& value, Int3& min, Int3& max, Int3& result);
    public static Int3 Clamp(Int3 value, Int3 min, Int3 max);
    public static void Max(Int3& left, Int3& right, Int3& result);
    public static Int3 Max(Int3 left, Int3 right);
    public static void Min(Int3& left, Int3& right, Int3& result);
    public static Int3 Min(Int3 left, Int3 right);
    public static Int3 op_Addition(Int3 left, Int3 right);
    public static Int3 op_UnaryPlus(Int3 value);
    public static Int3 op_Subtraction(Int3 left, Int3 right);
    public static Int3 op_UnaryNegation(Int3 value);
    public static Int3 op_Multiply(int scale, Int3 value);
    public static Int3 op_Multiply(Int3 value, int scale);
    public static Int3 op_Division(Int3 value, int scale);
    public static bool op_Equality(Int3 left, Int3 right);
    public static bool op_Inequality(Int3 left, Int3 right);
    public static Vector2 op_Explicit(Int3 value);
    public static Vector3 op_Explicit(Int3 value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Int3& other);
    public sealed virtual bool Equals(Int3 other);
    public virtual bool Equals(object value);
    public static Int3 op_Implicit(Int32[] input);
    public static Int32[] op_Implicit(Int3 input);
    public static RawInt3 op_Implicit(Int3 value);
    public static Int3 op_Implicit(RawInt3 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Int4 : ValueType {
    public static int SizeInBytes;
    public static Int4 Zero;
    public static Int4 UnitX;
    public static Int4 UnitY;
    public static Int4 UnitZ;
    public static Int4 UnitW;
    public static Int4 One;
    public int X;
    public int Y;
    public int Z;
    public int W;
    public int Item { get; public set; }
    public Int4(int value);
    public Int4(int x, int y, int z, int w);
    public Int4(Int32[] values);
    private static Int4();
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public Int32[] ToArray();
    public static void Add(Int4& left, Int4& right, Int4& result);
    public static Int4 Add(Int4 left, Int4 right);
    public static void Subtract(Int4& left, Int4& right, Int4& result);
    public static Int4 Subtract(Int4 left, Int4 right);
    public static void Multiply(Int4& value, int scale, Int4& result);
    public static Int4 Multiply(Int4 value, int scale);
    public static void Modulate(Int4& left, Int4& right, Int4& result);
    public static Int4 Modulate(Int4 left, Int4 right);
    public static void Divide(Int4& value, int scale, Int4& result);
    public static Int4 Divide(Int4 value, int scale);
    public static void Negate(Int4& value, Int4& result);
    public static Int4 Negate(Int4 value);
    public static void Clamp(Int4& value, Int4& min, Int4& max, Int4& result);
    public static Int4 Clamp(Int4 value, Int4 min, Int4 max);
    public static void Max(Int4& left, Int4& right, Int4& result);
    public static Int4 Max(Int4 left, Int4 right);
    public static void Min(Int4& left, Int4& right, Int4& result);
    public static Int4 Min(Int4 left, Int4 right);
    public static Int4 op_Addition(Int4 left, Int4 right);
    public static Int4 op_UnaryPlus(Int4 value);
    public static Int4 op_Subtraction(Int4 left, Int4 right);
    public static Int4 op_UnaryNegation(Int4 value);
    public static Int4 op_Multiply(int scale, Int4 value);
    public static Int4 op_Multiply(Int4 value, int scale);
    public static Int4 op_Division(Int4 value, int scale);
    public static bool op_Equality(Int4 left, Int4 right);
    public static bool op_Inequality(Int4 left, Int4 right);
    public static Vector2 op_Explicit(Int4 value);
    public static Vector3 op_Explicit(Int4 value);
    public static Vector4 op_Explicit(Int4 value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Int4& other);
    public sealed virtual bool Equals(Int4 other);
    public virtual bool Equals(object value);
    public static Int4 op_Implicit(Int32[] input);
    public static Int32[] op_Implicit(Int4 input);
    public static RawInt4 op_Implicit(Int4 value);
    public static Int4 op_Implicit(RawInt4 value);
}
[CompilerGeneratedAttribute]
internal class SharpDX.Mathematics.AssemblyDoc : object {
}
[CompilerGeneratedAttribute]
internal class SharpDX.Mathematics.NamespaceDoc : object {
}
public static class SharpDX.MathUtil : object {
    public static float ZeroTolerance;
    public static float Pi;
    public static float TwoPi;
    public static float PiOverTwo;
    public static float PiOverFour;
    public static bool NearEqual(float a, float b);
    public static bool IsZero(float a);
    public static bool IsOne(float a);
    public static bool WithinEpsilon(float a, float b, float epsilon);
    public static float RevolutionsToDegrees(float revolution);
    public static float RevolutionsToRadians(float revolution);
    public static float RevolutionsToGradians(float revolution);
    public static float DegreesToRevolutions(float degree);
    public static float DegreesToRadians(float degree);
    public static float RadiansToRevolutions(float radian);
    public static float RadiansToGradians(float radian);
    public static float GradiansToRevolutions(float gradian);
    public static float GradiansToDegrees(float gradian);
    public static float GradiansToRadians(float gradian);
    public static float RadiansToDegrees(float radian);
    public static float Clamp(float value, float min, float max);
    public static int Clamp(int value, int min, int max);
    public static double Lerp(double from, double to, double amount);
    public static float Lerp(float from, float to, float amount);
    public static byte Lerp(byte from, byte to, float amount);
    public static float SmoothStep(float amount);
    public static float SmootherStep(float amount);
    public static float Mod(float value, float modulo);
    public static float Mod2PI(float value);
    public static int Wrap(int value, int min, int max);
    public static float Wrap(float value, float min, float max);
    public static float Gauss(float amplitude, float x, float y, float centerX, float centerY, float sigmaX, float sigmaY);
    public static double Gauss(double amplitude, double x, double y, double centerX, double centerY, double sigmaX, double sigmaY);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Matrix : ValueType {
    public static int SizeInBytes;
    public static Matrix Zero;
    public static Matrix Identity;
    public float M11;
    public float M12;
    public float M13;
    public float M14;
    public float M21;
    public float M22;
    public float M23;
    public float M24;
    public float M31;
    public float M32;
    public float M33;
    public float M34;
    public float M41;
    public float M42;
    public float M43;
    public float M44;
    public Vector3 Up { get; public set; }
    public Vector3 Down { get; public set; }
    public Vector3 Right { get; public set; }
    public Vector3 Left { get; public set; }
    public Vector3 Forward { get; public set; }
    public Vector3 Backward { get; public set; }
    public Vector4 Row1 { get; public set; }
    public Vector4 Row2 { get; public set; }
    public Vector4 Row3 { get; public set; }
    public Vector4 Row4 { get; public set; }
    public Vector4 Column1 { get; public set; }
    public Vector4 Column2 { get; public set; }
    public Vector4 Column3 { get; public set; }
    public Vector4 Column4 { get; public set; }
    public Vector3 TranslationVector { get; public set; }
    public Vector3 ScaleVector { get; public set; }
    public bool IsIdentity { get; }
    public float Item { get; public set; }
    public float Item { get; public set; }
    public Matrix(float value);
    public Matrix(float M11, float M12, float M13, float M14, float M21, float M22, float M23, float M24, float M31, float M32, float M33, float M34, float M41, float M42, float M43, float M44);
    public Matrix(Single[] values);
    private static Matrix();
    public Vector3 get_Up();
    public void set_Up(Vector3 value);
    public Vector3 get_Down();
    public void set_Down(Vector3 value);
    public Vector3 get_Right();
    public void set_Right(Vector3 value);
    public Vector3 get_Left();
    public void set_Left(Vector3 value);
    public Vector3 get_Forward();
    public void set_Forward(Vector3 value);
    public Vector3 get_Backward();
    public void set_Backward(Vector3 value);
    public Vector4 get_Row1();
    public void set_Row1(Vector4 value);
    public Vector4 get_Row2();
    public void set_Row2(Vector4 value);
    public Vector4 get_Row3();
    public void set_Row3(Vector4 value);
    public Vector4 get_Row4();
    public void set_Row4(Vector4 value);
    public Vector4 get_Column1();
    public void set_Column1(Vector4 value);
    public Vector4 get_Column2();
    public void set_Column2(Vector4 value);
    public Vector4 get_Column3();
    public void set_Column3(Vector4 value);
    public Vector4 get_Column4();
    public void set_Column4(Vector4 value);
    public Vector3 get_TranslationVector();
    public void set_TranslationVector(Vector3 value);
    public Vector3 get_ScaleVector();
    public void set_ScaleVector(Vector3 value);
    public bool get_IsIdentity();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public float Determinant();
    public void Invert();
    public void Transpose();
    public void Orthogonalize();
    public void Orthonormalize();
    public void DecomposeQR(Matrix& Q, Matrix& R);
    public void DecomposeLQ(Matrix& L, Matrix& Q);
    public bool Decompose(Vector3& scale, Quaternion& rotation, Vector3& translation);
    public bool DecomposeUniformScale(Single& scale, Quaternion& rotation, Vector3& translation);
    public void ExchangeRows(int firstRow, int secondRow);
    public void ExchangeColumns(int firstColumn, int secondColumn);
    public Single[] ToArray();
    public static void Add(Matrix& left, Matrix& right, Matrix& result);
    public static Matrix Add(Matrix left, Matrix right);
    public static void Subtract(Matrix& left, Matrix& right, Matrix& result);
    public static Matrix Subtract(Matrix left, Matrix right);
    public static void Multiply(Matrix& left, float right, Matrix& result);
    public static Matrix Multiply(Matrix left, float right);
    public static void Multiply(Matrix& left, Matrix& right, Matrix& result);
    public static Matrix Multiply(Matrix left, Matrix right);
    public static void Divide(Matrix& left, float right, Matrix& result);
    public static Matrix Divide(Matrix left, float right);
    public static void Divide(Matrix& left, Matrix& right, Matrix& result);
    public static Matrix Divide(Matrix left, Matrix right);
    public static void Exponent(Matrix& value, int exponent, Matrix& result);
    public static Matrix Exponent(Matrix value, int exponent);
    public static void Negate(Matrix& value, Matrix& result);
    public static Matrix Negate(Matrix value);
    public static void Lerp(Matrix& start, Matrix& end, float amount, Matrix& result);
    public static Matrix Lerp(Matrix start, Matrix end, float amount);
    public static void SmoothStep(Matrix& start, Matrix& end, float amount, Matrix& result);
    public static Matrix SmoothStep(Matrix start, Matrix end, float amount);
    public static void Transpose(Matrix& value, Matrix& result);
    public static void TransposeByRef(Matrix& value, Matrix& result);
    public static Matrix Transpose(Matrix value);
    public static void Invert(Matrix& value, Matrix& result);
    public static Matrix Invert(Matrix value);
    public static void Orthogonalize(Matrix& value, Matrix& result);
    public static Matrix Orthogonalize(Matrix value);
    public static void Orthonormalize(Matrix& value, Matrix& result);
    public static Matrix Orthonormalize(Matrix value);
    public static void UpperTriangularForm(Matrix& value, Matrix& result);
    public static Matrix UpperTriangularForm(Matrix value);
    public static void LowerTriangularForm(Matrix& value, Matrix& result);
    public static Matrix LowerTriangularForm(Matrix value);
    public static void RowEchelonForm(Matrix& value, Matrix& result);
    public static Matrix RowEchelonForm(Matrix value);
    public static void ReducedRowEchelonForm(Matrix& value, Vector4& augment, Matrix& result, Vector4& augmentResult);
    public static void BillboardLH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Matrix& result);
    public static Matrix BillboardLH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static void BillboardRH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Matrix& result);
    public static Matrix BillboardRH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static void LookAtLH(Vector3& eye, Vector3& target, Vector3& up, Matrix& result);
    public static Matrix LookAtLH(Vector3 eye, Vector3 target, Vector3 up);
    public static void LookAtRH(Vector3& eye, Vector3& target, Vector3& up, Matrix& result);
    public static Matrix LookAtRH(Vector3 eye, Vector3 target, Vector3 up);
    public static void OrthoLH(float width, float height, float znear, float zfar, Matrix& result);
    public static Matrix OrthoLH(float width, float height, float znear, float zfar);
    public static void OrthoRH(float width, float height, float znear, float zfar, Matrix& result);
    public static Matrix OrthoRH(float width, float height, float znear, float zfar);
    public static void OrthoOffCenterLH(float left, float right, float bottom, float top, float znear, float zfar, Matrix& result);
    public static Matrix OrthoOffCenterLH(float left, float right, float bottom, float top, float znear, float zfar);
    public static void OrthoOffCenterRH(float left, float right, float bottom, float top, float znear, float zfar, Matrix& result);
    public static Matrix OrthoOffCenterRH(float left, float right, float bottom, float top, float znear, float zfar);
    public static void PerspectiveLH(float width, float height, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveLH(float width, float height, float znear, float zfar);
    public static void PerspectiveRH(float width, float height, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveRH(float width, float height, float znear, float zfar);
    public static void PerspectiveFovLH(float fov, float aspect, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveFovLH(float fov, float aspect, float znear, float zfar);
    public static void PerspectiveFovRH(float fov, float aspect, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveFovRH(float fov, float aspect, float znear, float zfar);
    public static void PerspectiveOffCenterLH(float left, float right, float bottom, float top, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveOffCenterLH(float left, float right, float bottom, float top, float znear, float zfar);
    public static void PerspectiveOffCenterRH(float left, float right, float bottom, float top, float znear, float zfar, Matrix& result);
    public static Matrix PerspectiveOffCenterRH(float left, float right, float bottom, float top, float znear, float zfar);
    public static void Scaling(Vector3& scale, Matrix& result);
    public static Matrix Scaling(Vector3 scale);
    public static void Scaling(float x, float y, float z, Matrix& result);
    public static Matrix Scaling(float x, float y, float z);
    public static void Scaling(float scale, Matrix& result);
    public static Matrix Scaling(float scale);
    public static void RotationX(float angle, Matrix& result);
    public static Matrix RotationX(float angle);
    public static void RotationY(float angle, Matrix& result);
    public static Matrix RotationY(float angle);
    public static void RotationZ(float angle, Matrix& result);
    public static Matrix RotationZ(float angle);
    public static void RotationAxis(Vector3& axis, float angle, Matrix& result);
    public static Matrix RotationAxis(Vector3 axis, float angle);
    public static void RotationQuaternion(Quaternion& rotation, Matrix& result);
    public static Matrix RotationQuaternion(Quaternion rotation);
    public static void RotationYawPitchRoll(float yaw, float pitch, float roll, Matrix& result);
    public static Matrix RotationYawPitchRoll(float yaw, float pitch, float roll);
    public static void Translation(Vector3& value, Matrix& result);
    public static Matrix Translation(Vector3 value);
    public static void Translation(float x, float y, float z, Matrix& result);
    public static Matrix Translation(float x, float y, float z);
    public static void Skew(float angle, Vector3& rotationVec, Vector3& transVec, Matrix& matrix);
    public static void AffineTransformation(float scaling, Quaternion& rotation, Vector3& translation, Matrix& result);
    public static Matrix AffineTransformation(float scaling, Quaternion rotation, Vector3 translation);
    public static void AffineTransformation(float scaling, Vector3& rotationCenter, Quaternion& rotation, Vector3& translation, Matrix& result);
    public static Matrix AffineTransformation(float scaling, Vector3 rotationCenter, Quaternion rotation, Vector3 translation);
    public static void AffineTransformation2D(float scaling, float rotation, Vector2& translation, Matrix& result);
    public static Matrix AffineTransformation2D(float scaling, float rotation, Vector2 translation);
    public static void AffineTransformation2D(float scaling, Vector2& rotationCenter, float rotation, Vector2& translation, Matrix& result);
    public static Matrix AffineTransformation2D(float scaling, Vector2 rotationCenter, float rotation, Vector2 translation);
    public static void Transformation(Vector3& scalingCenter, Quaternion& scalingRotation, Vector3& scaling, Vector3& rotationCenter, Quaternion& rotation, Vector3& translation, Matrix& result);
    public static Matrix Transformation(Vector3 scalingCenter, Quaternion scalingRotation, Vector3 scaling, Vector3 rotationCenter, Quaternion rotation, Vector3 translation);
    public static void Transformation2D(Vector2& scalingCenter, float scalingRotation, Vector2& scaling, Vector2& rotationCenter, float rotation, Vector2& translation, Matrix& result);
    public static Matrix Transformation2D(Vector2 scalingCenter, float scalingRotation, Vector2 scaling, Vector2 rotationCenter, float rotation, Vector2 translation);
    public static Matrix op_Addition(Matrix left, Matrix right);
    public static Matrix op_UnaryPlus(Matrix value);
    public static Matrix op_Subtraction(Matrix left, Matrix right);
    public static Matrix op_UnaryNegation(Matrix value);
    public static Matrix op_Multiply(float left, Matrix right);
    public static Matrix op_Multiply(Matrix left, float right);
    public static Matrix op_Multiply(Matrix left, Matrix right);
    public static Matrix op_Division(Matrix left, float right);
    public static Matrix op_Division(Matrix left, Matrix right);
    public static bool op_Equality(Matrix left, Matrix right);
    public static bool op_Inequality(Matrix left, Matrix right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Matrix& other);
    public sealed virtual bool Equals(Matrix other);
    public virtual bool Equals(object value);
    public static RawMatrix op_Implicit(Matrix value);
    public static Matrix op_Implicit(RawMatrix value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Matrix3x2 : ValueType {
    public static Matrix3x2 Identity;
    public float M11;
    public float M12;
    public float M21;
    public float M22;
    public float M31;
    public float M32;
    public Vector2 Row1 { get; public set; }
    public Vector2 Row2 { get; public set; }
    public Vector2 Row3 { get; public set; }
    public Vector3 Column1 { get; public set; }
    public Vector3 Column2 { get; public set; }
    public Vector2 TranslationVector { get; public set; }
    public Vector2 ScaleVector { get; public set; }
    public bool IsIdentity { get; }
    public float Item { get; public set; }
    public float Item { get; public set; }
    public Matrix3x2(float value);
    public Matrix3x2(float M11, float M12, float M21, float M22, float M31, float M32);
    public Matrix3x2(Single[] values);
    private static Matrix3x2();
    public Vector2 get_Row1();
    public void set_Row1(Vector2 value);
    public Vector2 get_Row2();
    public void set_Row2(Vector2 value);
    public Vector2 get_Row3();
    public void set_Row3(Vector2 value);
    public Vector3 get_Column1();
    public void set_Column1(Vector3 value);
    public Vector3 get_Column2();
    public void set_Column2(Vector3 value);
    public Vector2 get_TranslationVector();
    public void set_TranslationVector(Vector2 value);
    public Vector2 get_ScaleVector();
    public void set_ScaleVector(Vector2 value);
    public bool get_IsIdentity();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public Single[] ToArray();
    public static void Add(Matrix3x2& left, Matrix3x2& right, Matrix3x2& result);
    public static Matrix3x2 Add(Matrix3x2 left, Matrix3x2 right);
    public static void Subtract(Matrix3x2& left, Matrix3x2& right, Matrix3x2& result);
    public static Matrix3x2 Subtract(Matrix3x2 left, Matrix3x2 right);
    public static void Multiply(Matrix3x2& left, float right, Matrix3x2& result);
    public static Matrix3x2 Multiply(Matrix3x2 left, float right);
    public static void Multiply(Matrix3x2& left, Matrix3x2& right, Matrix3x2& result);
    public static Matrix3x2 Multiply(Matrix3x2 left, Matrix3x2 right);
    public static void Divide(Matrix3x2& left, float right, Matrix3x2& result);
    public static void Divide(Matrix3x2& left, Matrix3x2& right, Matrix3x2& result);
    public static void Negate(Matrix3x2& value, Matrix3x2& result);
    public static Matrix3x2 Negate(Matrix3x2 value);
    public static void Lerp(Matrix3x2& start, Matrix3x2& end, float amount, Matrix3x2& result);
    public static Matrix3x2 Lerp(Matrix3x2 start, Matrix3x2 end, float amount);
    public static void SmoothStep(Matrix3x2& start, Matrix3x2& end, float amount, Matrix3x2& result);
    public static Matrix3x2 SmoothStep(Matrix3x2 start, Matrix3x2 end, float amount);
    public static void Scaling(Vector2& scale, Matrix3x2& result);
    public static Matrix3x2 Scaling(Vector2 scale);
    public static void Scaling(float x, float y, Matrix3x2& result);
    public static Matrix3x2 Scaling(float x, float y);
    public static void Scaling(float scale, Matrix3x2& result);
    public static Matrix3x2 Scaling(float scale);
    public static Matrix3x2 Scaling(float x, float y, Vector2 center);
    public static void Scaling(float x, float y, Vector2& center, Matrix3x2& result);
    public float Determinant();
    public static void Rotation(float angle, Matrix3x2& result);
    public static Matrix3x2 Rotation(float angle);
    public static Matrix3x2 Rotation(float angle, Vector2 center);
    public static void Rotation(float angle, Vector2 center, Matrix3x2& result);
    public static void Transformation(float xScale, float yScale, float angle, float xOffset, float yOffset, Matrix3x2& result);
    public static Matrix3x2 Transformation(float xScale, float yScale, float angle, float xOffset, float yOffset);
    public static void Translation(Vector2& value, Matrix3x2& result);
    public static Matrix3x2 Translation(Vector2 value);
    public static void Translation(float x, float y, Matrix3x2& result);
    public static Matrix3x2 Translation(float x, float y);
    public static Vector2 TransformPoint(Matrix3x2 matrix, Vector2 point);
    public static void TransformPoint(Matrix3x2& matrix, Vector2& point, Vector2& result);
    public void Invert();
    public static Matrix3x2 Invert(Matrix3x2 value);
    public static Matrix3x2 Skew(float angleX, float angleY);
    public static void Skew(float angleX, float angleY, Matrix3x2& result);
    public static void Invert(Matrix3x2& value, Matrix3x2& result);
    public static Matrix3x2 op_Addition(Matrix3x2 left, Matrix3x2 right);
    public static Matrix3x2 op_UnaryPlus(Matrix3x2 value);
    public static Matrix3x2 op_Subtraction(Matrix3x2 left, Matrix3x2 right);
    public static Matrix3x2 op_UnaryNegation(Matrix3x2 value);
    public static Matrix3x2 op_Multiply(float left, Matrix3x2 right);
    public static Matrix3x2 op_Multiply(Matrix3x2 left, float right);
    public static Matrix3x2 op_Multiply(Matrix3x2 left, Matrix3x2 right);
    public static Matrix3x2 op_Division(Matrix3x2 left, float right);
    public static Matrix3x2 op_Division(Matrix3x2 left, Matrix3x2 right);
    public static bool op_Equality(Matrix3x2 left, Matrix3x2 right);
    public static bool op_Inequality(Matrix3x2 left, Matrix3x2 right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Matrix3x2& other);
    public bool Equals(Matrix3x2 other);
    public virtual bool Equals(object value);
    public static Matrix3x2 op_Implicit(Matrix matrix);
    public static RawMatrix3x2 op_Implicit(Matrix3x2 value);
    public static Matrix3x2 op_Implicit(RawMatrix3x2 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Matrix3x3 : ValueType {
    public static int SizeInBytes;
    public static Matrix3x3 Zero;
    public static Matrix3x3 Identity;
    public float M11;
    public float M12;
    public float M13;
    public float M21;
    public float M22;
    public float M23;
    public float M31;
    public float M32;
    public float M33;
    public Vector3 Row1 { get; public set; }
    public Vector3 Row2 { get; public set; }
    public Vector3 Row3 { get; public set; }
    public Vector3 Column1 { get; public set; }
    public Vector3 Column2 { get; public set; }
    public Vector3 Column3 { get; public set; }
    public Vector3 ScaleVector { get; public set; }
    public bool IsIdentity { get; }
    public float Item { get; public set; }
    public float Item { get; public set; }
    public Matrix3x3(float value);
    public Matrix3x3(float M11, float M12, float M13, float M21, float M22, float M23, float M31, float M32, float M33);
    public Matrix3x3(Single[] values);
    private static Matrix3x3();
    public Vector3 get_Row1();
    public void set_Row1(Vector3 value);
    public Vector3 get_Row2();
    public void set_Row2(Vector3 value);
    public Vector3 get_Row3();
    public void set_Row3(Vector3 value);
    public Vector3 get_Column1();
    public void set_Column1(Vector3 value);
    public Vector3 get_Column2();
    public void set_Column2(Vector3 value);
    public Vector3 get_Column3();
    public void set_Column3(Vector3 value);
    public Vector3 get_ScaleVector();
    public void set_ScaleVector(Vector3 value);
    public bool get_IsIdentity();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public float Determinant();
    public void Invert();
    public void Transpose();
    public void Orthogonalize();
    public void Orthonormalize();
    public void DecomposeQR(Matrix3x3& Q, Matrix3x3& R);
    public void DecomposeLQ(Matrix3x3& L, Matrix3x3& Q);
    public bool Decompose(Vector3& scale, Quaternion& rotation);
    public bool DecomposeUniformScale(Single& scale, Quaternion& rotation);
    public void ExchangeRows(int firstRow, int secondRow);
    public void ExchangeColumns(int firstColumn, int secondColumn);
    public Single[] ToArray();
    public static void Add(Matrix3x3& left, Matrix3x3& right, Matrix3x3& result);
    public static Matrix3x3 Add(Matrix3x3 left, Matrix3x3 right);
    public static void Subtract(Matrix3x3& left, Matrix3x3& right, Matrix3x3& result);
    public static Matrix3x3 Subtract(Matrix3x3 left, Matrix3x3 right);
    public static void Multiply(Matrix3x3& left, float right, Matrix3x3& result);
    public static Matrix3x3 Multiply(Matrix3x3 left, float right);
    public static void Multiply(Matrix3x3& left, Matrix3x3& right, Matrix3x3& result);
    public static Matrix3x3 Multiply(Matrix3x3 left, Matrix3x3 right);
    public static void Divide(Matrix3x3& left, float right, Matrix3x3& result);
    public static Matrix3x3 Divide(Matrix3x3 left, float right);
    public static void Divide(Matrix3x3& left, Matrix3x3& right, Matrix3x3& result);
    public static Matrix3x3 Divide(Matrix3x3 left, Matrix3x3 right);
    public static void Exponent(Matrix3x3& value, int exponent, Matrix3x3& result);
    public static Matrix3x3 Exponent(Matrix3x3 value, int exponent);
    public static void Negate(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 Negate(Matrix3x3 value);
    public static void Lerp(Matrix3x3& start, Matrix3x3& end, float amount, Matrix3x3& result);
    public static Matrix3x3 Lerp(Matrix3x3 start, Matrix3x3 end, float amount);
    public static void SmoothStep(Matrix3x3& start, Matrix3x3& end, float amount, Matrix3x3& result);
    public static Matrix3x3 SmoothStep(Matrix3x3 start, Matrix3x3 end, float amount);
    public static void Transpose(Matrix3x3& value, Matrix3x3& result);
    public static void TransposeByRef(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 Transpose(Matrix3x3 value);
    public static void Invert(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 Invert(Matrix3x3 value);
    public static void Orthogonalize(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 Orthogonalize(Matrix3x3 value);
    public static void Orthonormalize(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 Orthonormalize(Matrix3x3 value);
    public static void UpperTriangularForm(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 UpperTriangularForm(Matrix3x3 value);
    public static void LowerTriangularForm(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 LowerTriangularForm(Matrix3x3 value);
    public static void RowEchelonForm(Matrix3x3& value, Matrix3x3& result);
    public static Matrix3x3 RowEchelonForm(Matrix3x3 value);
    public static void BillboardLH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Matrix3x3& result);
    public static Matrix3x3 BillboardLH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static void BillboardRH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Matrix3x3& result);
    public static Matrix3x3 BillboardRH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static void LookAtLH(Vector3& eye, Vector3& target, Vector3& up, Matrix3x3& result);
    public static Matrix3x3 LookAtLH(Vector3 eye, Vector3 target, Vector3 up);
    public static void LookAtRH(Vector3& eye, Vector3& target, Vector3& up, Matrix3x3& result);
    public static Matrix3x3 LookAtRH(Vector3 eye, Vector3 target, Vector3 up);
    public static void Scaling(Vector3& scale, Matrix3x3& result);
    public static Matrix3x3 Scaling(Vector3 scale);
    public static void Scaling(float x, float y, float z, Matrix3x3& result);
    public static Matrix3x3 Scaling(float x, float y, float z);
    public static void Scaling(float scale, Matrix3x3& result);
    public static Matrix3x3 Scaling(float scale);
    public static void RotationX(float angle, Matrix3x3& result);
    public static Matrix3x3 RotationX(float angle);
    public static void RotationY(float angle, Matrix3x3& result);
    public static Matrix3x3 RotationY(float angle);
    public static void RotationZ(float angle, Matrix3x3& result);
    public static Matrix3x3 RotationZ(float angle);
    public static void RotationAxis(Vector3& axis, float angle, Matrix3x3& result);
    public static Matrix3x3 RotationAxis(Vector3 axis, float angle);
    public static void RotationQuaternion(Quaternion& rotation, Matrix3x3& result);
    public static Matrix3x3 RotationQuaternion(Quaternion rotation);
    public static void RotationYawPitchRoll(float yaw, float pitch, float roll, Matrix3x3& result);
    public static Matrix3x3 RotationYawPitchRoll(float yaw, float pitch, float roll);
    public static Matrix3x3 op_Addition(Matrix3x3 left, Matrix3x3 right);
    public static Matrix3x3 op_UnaryPlus(Matrix3x3 value);
    public static Matrix3x3 op_Subtraction(Matrix3x3 left, Matrix3x3 right);
    public static Matrix3x3 op_UnaryNegation(Matrix3x3 value);
    public static Matrix3x3 op_Multiply(float left, Matrix3x3 right);
    public static Matrix3x3 op_Multiply(Matrix3x3 left, float right);
    public static Matrix3x3 op_Multiply(Matrix3x3 left, Matrix3x3 right);
    public static Matrix3x3 op_Division(Matrix3x3 left, float right);
    public static Matrix3x3 op_Division(Matrix3x3 left, Matrix3x3 right);
    public static bool op_Equality(Matrix3x3 left, Matrix3x3 right);
    public static bool op_Inequality(Matrix3x3 left, Matrix3x3 right);
    public static Matrix op_Explicit(Matrix3x3 Value);
    public static Matrix3x3 op_Explicit(Matrix Value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Matrix3x3& other);
    public sealed virtual bool Equals(Matrix3x3 other);
    public static bool Equals(Matrix3x3& a, Matrix3x3& b);
    public virtual bool Equals(object value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Matrix5x4 : ValueType {
    public static int SizeInBytes;
    public static Matrix5x4 Zero;
    public static Matrix5x4 Identity;
    public float M11;
    public float M12;
    public float M13;
    public float M14;
    public float M21;
    public float M22;
    public float M23;
    public float M24;
    public float M31;
    public float M32;
    public float M33;
    public float M34;
    public float M41;
    public float M42;
    public float M43;
    public float M44;
    public float M51;
    public float M52;
    public float M53;
    public float M54;
    public Vector4 Row1 { get; public set; }
    public Vector4 Row2 { get; public set; }
    public Vector4 Row3 { get; public set; }
    public Vector4 Row4 { get; public set; }
    public Vector4 Row5 { get; public set; }
    public Vector4 TranslationVector { get; public set; }
    public Vector4 ScaleVector { get; public set; }
    public bool IsIdentity { get; }
    public float Item { get; public set; }
    public float Item { get; public set; }
    public Matrix5x4(float value);
    public Matrix5x4(float M11, float M12, float M13, float M14, float M21, float M22, float M23, float M24, float M31, float M32, float M33, float M34, float M41, float M42, float M43, float M44, float M51, float M52, float M53, float M54);
    public Matrix5x4(Single[] values);
    private static Matrix5x4();
    public Vector4 get_Row1();
    public void set_Row1(Vector4 value);
    public Vector4 get_Row2();
    public void set_Row2(Vector4 value);
    public Vector4 get_Row3();
    public void set_Row3(Vector4 value);
    public Vector4 get_Row4();
    public void set_Row4(Vector4 value);
    public Vector4 get_Row5();
    public void set_Row5(Vector4 value);
    public Vector4 get_TranslationVector();
    public void set_TranslationVector(Vector4 value);
    public Vector4 get_ScaleVector();
    public void set_ScaleVector(Vector4 value);
    public bool get_IsIdentity();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public static void Add(Matrix5x4& left, Matrix5x4& right, Matrix5x4& result);
    public static Matrix5x4 Add(Matrix5x4 left, Matrix5x4 right);
    public static void Subtract(Matrix5x4& left, Matrix5x4& right, Matrix5x4& result);
    public static Matrix5x4 Subtract(Matrix5x4 left, Matrix5x4 right);
    public static void Multiply(Matrix5x4& left, float right, Matrix5x4& result);
    public static void Divide(Matrix5x4& left, float right, Matrix5x4& result);
    public static void Negate(Matrix5x4& value, Matrix5x4& result);
    public static Matrix5x4 Negate(Matrix5x4 value);
    public static void Lerp(Matrix5x4& start, Matrix5x4& end, float amount, Matrix5x4& result);
    public static Matrix5x4 Lerp(Matrix5x4 start, Matrix5x4 end, float amount);
    public static void SmoothStep(Matrix5x4& start, Matrix5x4& end, float amount, Matrix5x4& result);
    public static Matrix5x4 SmoothStep(Matrix5x4 start, Matrix5x4 end, float amount);
    public static void Scaling(Vector4& scale, Matrix5x4& result);
    public static Matrix5x4 Scaling(Vector4 scale);
    public static void Scaling(float x, float y, float z, float w, Matrix5x4& result);
    public static Matrix5x4 Scaling(float x, float y, float z, float w);
    public static void Scaling(float scale, Matrix5x4& result);
    public static Matrix5x4 Scaling(float scale);
    public static void Translation(Vector4& value, Matrix5x4& result);
    public static Matrix5x4 Translation(Vector4 value);
    public static void Translation(float x, float y, float z, float w, Matrix5x4& result);
    public static Matrix5x4 Translation(float x, float y, float z, float w);
    public static Matrix5x4 op_Addition(Matrix5x4 left, Matrix5x4 right);
    public static Matrix5x4 op_UnaryPlus(Matrix5x4 value);
    public static Matrix5x4 op_Subtraction(Matrix5x4 left, Matrix5x4 right);
    public static Matrix5x4 op_UnaryNegation(Matrix5x4 value);
    public static Matrix5x4 op_Multiply(float left, Matrix5x4 right);
    public static Matrix5x4 op_Multiply(Matrix5x4 left, float right);
    public static Matrix5x4 op_Division(Matrix5x4 left, float right);
    public static bool op_Equality(Matrix5x4 left, Matrix5x4 right);
    public static bool op_Inequality(Matrix5x4 left, Matrix5x4 right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Matrix5x4& other);
    public sealed virtual bool Equals(Matrix5x4 other);
    public virtual bool Equals(object value);
}
public class SharpDX.OrientedBoundingBox : ValueType {
    public Vector3 Extents;
    public Matrix Transformation;
    public Vector3 Size { get; }
    public Vector3 Center { get; }
    public OrientedBoundingBox(BoundingBox bb);
    public OrientedBoundingBox(Vector3 minimum, Vector3 maximum);
    public OrientedBoundingBox(Vector3[] points);
    public Vector3[] GetCorners();
    public void Transform(Matrix& mat);
    public void Transform(Matrix mat);
    public void Scale(Vector3& scaling);
    public void Scale(Vector3 scaling);
    public void Scale(float scaling);
    public void Translate(Vector3& translation);
    public void Translate(Vector3 translation);
    public Vector3 get_Size();
    public Vector3 GetSize();
    public Vector3 GetSizeSquared();
    public Vector3 get_Center();
    public ContainmentType Contains(Vector3& point);
    public ContainmentType Contains(Vector3 point);
    public ContainmentType Contains(Vector3[] points);
    public ContainmentType Contains(BoundingSphere sphere, bool IgnoreScale);
    private static Vector3[] GetRows(Matrix& mat);
    public ContainmentType Contains(OrientedBoundingBox& obb);
    public ContainmentType ContainsLine(Vector3& L1, Vector3& L2);
    public ContainmentType Contains(BoundingBox& box);
    public bool Intersects(Ray& ray, Vector3& point);
    public bool Intersects(Ray& ray);
    private Vector3[] GetLocalCorners();
    public BoundingBox GetBoundingBox();
    public static Matrix GetBoxToBoxMatrix(OrientedBoundingBox& A, OrientedBoundingBox& B, bool NoMatrixScaleApplied);
    public static void Merge(OrientedBoundingBox& A, OrientedBoundingBox& B, bool NoMatrixScaleApplied);
    public void MergeInto(OrientedBoundingBox& OBB, bool NoMatrixScaleApplied);
    public void Add(OrientedBoundingBox& OBB, bool NoMatrixScaleApplied);
    public bool Equals(OrientedBoundingBox& value);
    public sealed virtual bool Equals(OrientedBoundingBox value);
    public virtual bool Equals(object value);
    public static bool op_Equality(OrientedBoundingBox left, OrientedBoundingBox right);
    public static bool op_Inequality(OrientedBoundingBox left, OrientedBoundingBox right);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Plane : ValueType {
    public Vector3 Normal;
    public float D;
    public float Item { get; public set; }
    public Plane(float value);
    public Plane(float a, float b, float c, float d);
    public Plane(Vector3 point, Vector3 normal);
    public Plane(Vector3 value, float d);
    public Plane(Vector3 point1, Vector3 point2, Vector3 point3);
    public Plane(Single[] values);
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Normalize();
    public Single[] ToArray();
    public PlaneIntersectionType Intersects(Vector3& point);
    public bool Intersects(Ray& ray);
    public bool Intersects(Ray& ray, Single& distance);
    public bool Intersects(Ray& ray, Vector3& point);
    public bool Intersects(Plane& plane);
    public bool Intersects(Plane& plane, Ray& line);
    public PlaneIntersectionType Intersects(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public PlaneIntersectionType Intersects(BoundingBox& box);
    public PlaneIntersectionType Intersects(BoundingSphere& sphere);
    public void Reflection(Matrix& result);
    public Matrix Reflection();
    public void Shadow(Vector4& light, Matrix& result);
    public Matrix Shadow(Vector4 light);
    public void Reflection(Matrix3x3& result);
    public Matrix3x3 Reflection3x3();
    public static void Shadow(Vector4& light, Plane& plane, Matrix3x3& result);
    public static Matrix3x3 Shadow(Vector4 light, Plane plane);
    public static void Multiply(Plane& value, float scale, Plane& result);
    public static Plane Multiply(Plane value, float scale);
    public static void Dot(Plane& left, Vector4& right, Single& result);
    public static float Dot(Plane left, Vector4 right);
    public static void DotCoordinate(Plane& left, Vector3& right, Single& result);
    public static float DotCoordinate(Plane left, Vector3 right);
    public static void DotNormal(Plane& left, Vector3& right, Single& result);
    public static float DotNormal(Plane left, Vector3 right);
    public static void Normalize(Plane& plane, Plane& result);
    public static Plane Normalize(Plane plane);
    public static void Transform(Plane& plane, Quaternion& rotation, Plane& result);
    public static Plane Transform(Plane plane, Quaternion rotation);
    public static void Transform(Plane[] planes, Quaternion& rotation);
    public static void Transform(Plane& plane, Matrix& transformation, Plane& result);
    public static Plane Transform(Plane plane, Matrix transformation);
    public static void Transform(Plane[] planes, Matrix& transformation);
    public static Plane op_Multiply(float scale, Plane plane);
    public static Plane op_Multiply(Plane plane, float scale);
    public static bool op_Equality(Plane left, Plane right);
    public static bool op_Inequality(Plane left, Plane right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Plane& value);
    public sealed virtual bool Equals(Plane value);
    public virtual bool Equals(object value);
}
public enum SharpDX.PlaneIntersectionType : Enum {
    public int value__;
    public static PlaneIntersectionType Back;
    public static PlaneIntersectionType Front;
    public static PlaneIntersectionType Intersecting;
}
public class SharpDX.Point : ValueType {
    public static Point Zero;
    public int X;
    public int Y;
    public Point(int x, int y);
    private static Point();
    public bool Equals(Point& other);
    public sealed virtual bool Equals(Point other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public virtual string ToString();
    public static Point op_Explicit(Vector2 value);
    public static Vector2 op_Implicit(Point value);
    public static RawPoint op_Implicit(Point value);
    public static Point op_Implicit(RawPoint value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Quaternion : ValueType {
    public static int SizeInBytes;
    public static Quaternion Zero;
    public static Quaternion One;
    public static Quaternion Identity;
    public float X;
    public float Y;
    public float Z;
    public float W;
    public bool IsIdentity { get; }
    public bool IsNormalized { get; }
    public float Angle { get; }
    public Vector3 Axis { get; }
    public float Item { get; public set; }
    public Quaternion(float value);
    public Quaternion(Vector4 value);
    public Quaternion(Vector3 value, float w);
    public Quaternion(Vector2 value, float z, float w);
    public Quaternion(float x, float y, float z, float w);
    public Quaternion(Single[] values);
    private static Quaternion();
    public bool get_IsIdentity();
    public bool get_IsNormalized();
    public float get_Angle();
    public Vector3 get_Axis();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Conjugate();
    public void Invert();
    public float Length();
    public float LengthSquared();
    public void Normalize();
    public Single[] ToArray();
    public static void Add(Quaternion& left, Quaternion& right, Quaternion& result);
    public static Quaternion Add(Quaternion left, Quaternion right);
    public static void Subtract(Quaternion& left, Quaternion& right, Quaternion& result);
    public static Quaternion Subtract(Quaternion left, Quaternion right);
    public static void Multiply(Quaternion& value, float scale, Quaternion& result);
    public static Quaternion Multiply(Quaternion value, float scale);
    public static void Multiply(Quaternion& left, Quaternion& right, Quaternion& result);
    public static Quaternion Multiply(Quaternion left, Quaternion right);
    public static void Negate(Quaternion& value, Quaternion& result);
    public static Quaternion Negate(Quaternion value);
    public static void Barycentric(Quaternion& value1, Quaternion& value2, Quaternion& value3, float amount1, float amount2, Quaternion& result);
    public static Quaternion Barycentric(Quaternion value1, Quaternion value2, Quaternion value3, float amount1, float amount2);
    public static void Conjugate(Quaternion& value, Quaternion& result);
    public static Quaternion Conjugate(Quaternion value);
    public static void Dot(Quaternion& left, Quaternion& right, Single& result);
    public static float Dot(Quaternion left, Quaternion right);
    public static void Exponential(Quaternion& value, Quaternion& result);
    public static Quaternion Exponential(Quaternion value);
    public static void Invert(Quaternion& value, Quaternion& result);
    public static Quaternion Invert(Quaternion value);
    public static void Lerp(Quaternion& start, Quaternion& end, float amount, Quaternion& result);
    public static Quaternion Lerp(Quaternion start, Quaternion end, float amount);
    public static void Logarithm(Quaternion& value, Quaternion& result);
    public static Quaternion Logarithm(Quaternion value);
    public static void Normalize(Quaternion& value, Quaternion& result);
    public static Quaternion Normalize(Quaternion value);
    public static void RotationAxis(Vector3& axis, float angle, Quaternion& result);
    public static Quaternion RotationAxis(Vector3 axis, float angle);
    public static void RotationMatrix(Matrix& matrix, Quaternion& result);
    public static void RotationMatrix(Matrix3x3& matrix, Quaternion& result);
    public static void LookAtLH(Vector3& eye, Vector3& target, Vector3& up, Quaternion& result);
    public static Quaternion LookAtLH(Vector3 eye, Vector3 target, Vector3 up);
    public static void RotationLookAtLH(Vector3& forward, Vector3& up, Quaternion& result);
    public static Quaternion RotationLookAtLH(Vector3 forward, Vector3 up);
    public static void LookAtRH(Vector3& eye, Vector3& target, Vector3& up, Quaternion& result);
    public static Quaternion LookAtRH(Vector3 eye, Vector3 target, Vector3 up);
    public static void RotationLookAtRH(Vector3& forward, Vector3& up, Quaternion& result);
    public static Quaternion RotationLookAtRH(Vector3 forward, Vector3 up);
    public static void BillboardLH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Quaternion& result);
    public static Quaternion BillboardLH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static void BillboardRH(Vector3& objectPosition, Vector3& cameraPosition, Vector3& cameraUpVector, Vector3& cameraForwardVector, Quaternion& result);
    public static Quaternion BillboardRH(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static Quaternion RotationMatrix(Matrix matrix);
    public static void RotationYawPitchRoll(float yaw, float pitch, float roll, Quaternion& result);
    public static Quaternion RotationYawPitchRoll(float yaw, float pitch, float roll);
    public static void Slerp(Quaternion& start, Quaternion& end, float amount, Quaternion& result);
    public static Quaternion Slerp(Quaternion start, Quaternion end, float amount);
    public static void Squad(Quaternion& value1, Quaternion& value2, Quaternion& value3, Quaternion& value4, float amount, Quaternion& result);
    public static Quaternion Squad(Quaternion value1, Quaternion value2, Quaternion value3, Quaternion value4, float amount);
    public static Quaternion[] SquadSetup(Quaternion value1, Quaternion value2, Quaternion value3, Quaternion value4);
    public static Quaternion op_Addition(Quaternion left, Quaternion right);
    public static Quaternion op_Subtraction(Quaternion left, Quaternion right);
    public static Quaternion op_UnaryNegation(Quaternion value);
    public static Quaternion op_Multiply(float scale, Quaternion value);
    public static Quaternion op_Multiply(Quaternion value, float scale);
    public static Quaternion op_Multiply(Quaternion left, Quaternion right);
    public static bool op_Equality(Quaternion left, Quaternion right);
    public static bool op_Inequality(Quaternion left, Quaternion right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Quaternion& other);
    public sealed virtual bool Equals(Quaternion other);
    public virtual bool Equals(object value);
    public static RawQuaternion op_Implicit(Quaternion value);
    public static Quaternion op_Implicit(RawQuaternion value);
}
[ExtensionAttribute]
public static class SharpDX.RandomUtil : object {
    [ExtensionAttribute]
public static float NextFloat(Random random, float min, float max);
    [ExtensionAttribute]
public static double NextDouble(Random random, double min, double max);
    [ExtensionAttribute]
public static long NextLong(Random random);
    [ExtensionAttribute]
public static long NextLong(Random random, long min, long max);
    [ExtensionAttribute]
public static Vector2 NextVector2(Random random, Vector2 min, Vector2 max);
    [ExtensionAttribute]
public static Vector3 NextVector3(Random random, Vector3 min, Vector3 max);
    [ExtensionAttribute]
public static Vector4 NextVector4(Random random, Vector4 min, Vector4 max);
    [ExtensionAttribute]
public static Color NextColor(Random random);
    [ExtensionAttribute]
public static Color NextColor(Random random, float minBrightness, float maxBrightness);
    [ExtensionAttribute]
public static Color NextColor(Random random, float minBrightness, float maxBrightness, float alpha);
    [ExtensionAttribute]
public static Color NextColor(Random random, float minBrightness, float maxBrightness, float minAlpha, float maxAlpha);
    [ExtensionAttribute]
public static Point NextPoint(Random random, Point min, Point max);
    [ExtensionAttribute]
public static TimeSpan NextTime(Random random, TimeSpan min, TimeSpan max);
}
public class SharpDX.Ray : ValueType {
    public Vector3 Position;
    public Vector3 Direction;
    public Ray(Vector3 position, Vector3 direction);
    public bool Intersects(Vector3& point);
    public bool Intersects(Ray& ray);
    public bool Intersects(Ray& ray, Vector3& point);
    public bool Intersects(Plane& plane);
    public bool Intersects(Plane& plane, Single& distance);
    public bool Intersects(Plane& plane, Vector3& point);
    public bool Intersects(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3);
    public bool Intersects(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3, Single& distance);
    public bool Intersects(Vector3& vertex1, Vector3& vertex2, Vector3& vertex3, Vector3& point);
    public bool Intersects(BoundingBox& box);
    public bool Intersects(BoundingBox box);
    public bool Intersects(BoundingBox& box, Single& distance);
    public bool Intersects(BoundingBox& box, Vector3& point);
    public bool Intersects(BoundingSphere& sphere);
    public bool Intersects(BoundingSphere sphere);
    public bool Intersects(BoundingSphere& sphere, Single& distance);
    public bool Intersects(BoundingSphere& sphere, Vector3& point);
    public static Ray GetPickRay(int x, int y, ViewportF viewport, Matrix worldViewProjection);
    public static bool op_Equality(Ray left, Ray right);
    public static bool op_Inequality(Ray left, Ray right);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Ray& value);
    public sealed virtual bool Equals(Ray value);
    public virtual bool Equals(object value);
}
public class SharpDX.Rectangle : ValueType {
    public int Left;
    public int Top;
    public int Right;
    public int Bottom;
    public static Rectangle Empty;
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool IsEmpty { get; }
    private static Rectangle();
    public Rectangle(int x, int y, int width, int height);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public bool get_IsEmpty();
    public void Offset(int offsetX, int offsetY);
    public void Inflate(int horizontalAmount, int verticalAmount);
    public bool Contains(int x, int y);
    public bool Contains(Rectangle value);
    public void Contains(Rectangle& value, Boolean& result);
    public bool Contains(float x, float y);
    public bool Intersects(Rectangle value);
    public void Intersects(Rectangle& value, Boolean& result);
    public static Rectangle Intersect(Rectangle value1, Rectangle value2);
    public static void Intersect(Rectangle& value1, Rectangle& value2, Rectangle& result);
    public static Rectangle Union(Rectangle value1, Rectangle value2);
    public static void Union(Rectangle& value1, Rectangle& value2, Rectangle& result);
    public virtual bool Equals(object obj);
    public bool Equals(Rectangle& other);
    public sealed virtual bool Equals(Rectangle other);
    public virtual int GetHashCode();
    public static bool op_Equality(Rectangle left, Rectangle right);
    public static bool op_Inequality(Rectangle left, Rectangle right);
    public virtual string ToString();
    internal void MakeXYAndWidthHeight();
    public static RawRectangle op_Implicit(Rectangle value);
    public static Rectangle op_Implicit(RawRectangle value);
    public static RawBox op_Implicit(Rectangle value);
    public static Rectangle op_Implicit(RawBox value);
}
public class SharpDX.RectangleF : ValueType {
    public float Left;
    public float Top;
    public float Right;
    public float Bottom;
    public static RectangleF Empty;
    public static RectangleF Infinite;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public Vector2 Location { get; public set; }
    public Vector2 Center { get; }
    public bool IsEmpty { get; }
    public Size2F Size { get; public set; }
    public Vector2 TopLeft { get; }
    public Vector2 TopRight { get; }
    public Vector2 BottomLeft { get; }
    public Vector2 BottomRight { get; }
    private static RectangleF();
    public RectangleF(float x, float y, float width, float height);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public Vector2 get_Location();
    public void set_Location(Vector2 value);
    public Vector2 get_Center();
    public bool get_IsEmpty();
    public Size2F get_Size();
    public void set_Size(Size2F value);
    public Vector2 get_TopLeft();
    public Vector2 get_TopRight();
    public Vector2 get_BottomLeft();
    public Vector2 get_BottomRight();
    public void Offset(Point amount);
    public void Offset(Vector2 amount);
    public void Offset(float offsetX, float offsetY);
    public void Inflate(float horizontalAmount, float verticalAmount);
    public void Contains(Vector2& value, Boolean& result);
    public bool Contains(Rectangle value);
    public void Contains(RectangleF& value, Boolean& result);
    public bool Contains(float x, float y);
    public bool Contains(Vector2 vector2D);
    public bool Contains(Point point);
    public bool Intersects(RectangleF value);
    public void Intersects(RectangleF& value, Boolean& result);
    public static RectangleF Intersect(RectangleF value1, RectangleF value2);
    public static void Intersect(RectangleF& value1, RectangleF& value2, RectangleF& result);
    public static RectangleF Union(RectangleF value1, RectangleF value2);
    public static void Union(RectangleF& value1, RectangleF& value2, RectangleF& result);
    public virtual bool Equals(object obj);
    public bool Equals(RectangleF& other);
    public sealed virtual bool Equals(RectangleF other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(RectangleF left, RectangleF right);
    public static bool op_Inequality(RectangleF left, RectangleF right);
    public static Rectangle op_Explicit(RectangleF value);
    public static RawRectangle op_Implicit(RectangleF value);
    public static RawRectangleF op_Implicit(RectangleF value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Vector2 : ValueType {
    public static int SizeInBytes;
    public static Vector2 Zero;
    public static Vector2 UnitX;
    public static Vector2 UnitY;
    public static Vector2 One;
    public float X;
    public float Y;
    public bool IsNormalized { get; }
    public bool IsZero { get; }
    public float Item { get; public set; }
    public Vector2(float value);
    public Vector2(float x, float y);
    public Vector2(Single[] values);
    private static Vector2();
    public bool get_IsNormalized();
    public bool get_IsZero();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float Length();
    public float LengthSquared();
    public void Normalize();
    public Single[] ToArray();
    public static void Add(Vector2& left, Vector2& right, Vector2& result);
    public static Vector2 Add(Vector2 left, Vector2 right);
    public static void Add(Vector2& left, Single& right, Vector2& result);
    public static Vector2 Add(Vector2 left, float right);
    public static void Subtract(Vector2& left, Vector2& right, Vector2& result);
    public static Vector2 Subtract(Vector2 left, Vector2 right);
    public static void Subtract(Vector2& left, Single& right, Vector2& result);
    public static Vector2 Subtract(Vector2 left, float right);
    public static void Subtract(Single& left, Vector2& right, Vector2& result);
    public static Vector2 Subtract(float left, Vector2 right);
    public static void Multiply(Vector2& value, float scale, Vector2& result);
    public static Vector2 Multiply(Vector2 value, float scale);
    public static void Multiply(Vector2& left, Vector2& right, Vector2& result);
    public static Vector2 Multiply(Vector2 left, Vector2 right);
    public static void Divide(Vector2& value, float scale, Vector2& result);
    public static Vector2 Divide(Vector2 value, float scale);
    public static void Divide(float scale, Vector2& value, Vector2& result);
    public static Vector2 Divide(float scale, Vector2 value);
    public static void Negate(Vector2& value, Vector2& result);
    public static Vector2 Negate(Vector2 value);
    public static void Abs(Vector2& value, Vector2& result);
    public static Vector2 Abs(Vector2 value);
    public static void Barycentric(Vector2& value1, Vector2& value2, Vector2& value3, float amount1, float amount2, Vector2& result);
    public static Vector2 Barycentric(Vector2 value1, Vector2 value2, Vector2 value3, float amount1, float amount2);
    public static void Clamp(Vector2& value, Vector2& min, Vector2& max, Vector2& result);
    public static Vector2 Clamp(Vector2 value, Vector2 min, Vector2 max);
    public void Saturate();
    public static void Distance(Vector2& value1, Vector2& value2, Single& result);
    public static float Distance(Vector2 value1, Vector2 value2);
    public static void DistanceSquared(Vector2& value1, Vector2& value2, Single& result);
    public static float DistanceSquared(Vector2 value1, Vector2 value2);
    public static void Dot(Vector2& left, Vector2& right, Single& result);
    public static float Dot(Vector2 left, Vector2 right);
    public static void Normalize(Vector2& value, Vector2& result);
    public static Vector2 Normalize(Vector2 value);
    public static void Lerp(Vector2& start, Vector2& end, float amount, Vector2& result);
    public static Vector2 Lerp(Vector2 start, Vector2 end, float amount);
    public static void SmoothStep(Vector2& start, Vector2& end, float amount, Vector2& result);
    public static Vector2 SmoothStep(Vector2 start, Vector2 end, float amount);
    public static void Hermite(Vector2& value1, Vector2& tangent1, Vector2& value2, Vector2& tangent2, float amount, Vector2& result);
    public static Vector2 Hermite(Vector2 value1, Vector2 tangent1, Vector2 value2, Vector2 tangent2, float amount);
    public static void CatmullRom(Vector2& value1, Vector2& value2, Vector2& value3, Vector2& value4, float amount, Vector2& result);
    public static Vector2 CatmullRom(Vector2 value1, Vector2 value2, Vector2 value3, Vector2 value4, float amount);
    public static void Max(Vector2& left, Vector2& right, Vector2& result);
    public static Vector2 Max(Vector2 left, Vector2 right);
    public static void Min(Vector2& left, Vector2& right, Vector2& result);
    public static Vector2 Min(Vector2 left, Vector2 right);
    public static void Reflect(Vector2& vector, Vector2& normal, Vector2& result);
    public static Vector2 Reflect(Vector2 vector, Vector2 normal);
    public static void Orthogonalize(Vector2[] destination, Vector2[] source);
    public static void Orthonormalize(Vector2[] destination, Vector2[] source);
    public static void Transform(Vector2& vector, Quaternion& rotation, Vector2& result);
    public static Vector2 Transform(Vector2 vector, Quaternion rotation);
    public static void Transform(Vector2[] source, Quaternion& rotation, Vector2[] destination);
    public static void Transform(Vector2& vector, Matrix& transform, Vector4& result);
    public static Vector4 Transform(Vector2 vector, Matrix transform);
    public static void Transform(Vector2[] source, Matrix& transform, Vector4[] destination);
    public static void TransformCoordinate(Vector2& coordinate, Matrix& transform, Vector2& result);
    public static Vector2 TransformCoordinate(Vector2 coordinate, Matrix transform);
    public static void TransformCoordinate(Vector2[] source, Matrix& transform, Vector2[] destination);
    public static void TransformNormal(Vector2& normal, Matrix& transform, Vector2& result);
    public static Vector2 TransformNormal(Vector2 normal, Matrix transform);
    public static void TransformNormal(Vector2[] source, Matrix& transform, Vector2[] destination);
    public static Vector2 op_Addition(Vector2 left, Vector2 right);
    public static Vector2 op_Multiply(Vector2 left, Vector2 right);
    public static Vector2 op_UnaryPlus(Vector2 value);
    public static Vector2 op_Subtraction(Vector2 left, Vector2 right);
    public static Vector2 op_UnaryNegation(Vector2 value);
    public static Vector2 op_Multiply(float scale, Vector2 value);
    public static Vector2 op_Multiply(Vector2 value, float scale);
    public static Vector2 op_Division(Vector2 value, float scale);
    public static Vector2 op_Division(float scale, Vector2 value);
    public static Vector2 op_Division(Vector2 value, Vector2 scale);
    public static Vector2 op_Addition(Vector2 value, float scalar);
    public static Vector2 op_Addition(float scalar, Vector2 value);
    public static Vector2 op_Subtraction(Vector2 value, float scalar);
    public static Vector2 op_Subtraction(float scalar, Vector2 value);
    public static bool op_Equality(Vector2 left, Vector2 right);
    public static bool op_Inequality(Vector2 left, Vector2 right);
    public static Vector3 op_Explicit(Vector2 value);
    public static Vector4 op_Explicit(Vector2 value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Vector2& other);
    public sealed virtual bool Equals(Vector2 other);
    public virtual bool Equals(object value);
    public static RawVector2 op_Implicit(Vector2 value);
    public static Vector2 op_Implicit(RawVector2 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Vector3 : ValueType {
    public static int SizeInBytes;
    public static Vector3 Zero;
    public static Vector3 UnitX;
    public static Vector3 UnitY;
    public static Vector3 UnitZ;
    public static Vector3 One;
    public static Vector3 Up;
    public static Vector3 Down;
    public static Vector3 Left;
    public static Vector3 Right;
    public static Vector3 ForwardRH;
    public static Vector3 ForwardLH;
    public static Vector3 BackwardRH;
    public static Vector3 BackwardLH;
    public float X;
    public float Y;
    public float Z;
    public bool IsNormalized { get; }
    public bool IsZero { get; }
    public float Item { get; public set; }
    public Vector3(float value);
    public Vector3(float x, float y, float z);
    public Vector3(Vector2 value, float z);
    public Vector3(Single[] values);
    private static Vector3();
    public bool get_IsNormalized();
    public bool get_IsZero();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float Length();
    public float LengthSquared();
    public void Normalize();
    public Single[] ToArray();
    public static void Add(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Add(Vector3 left, Vector3 right);
    public static void Add(Vector3& left, Single& right, Vector3& result);
    public static Vector3 Add(Vector3 left, float right);
    public static void Subtract(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Subtract(Vector3 left, Vector3 right);
    public static void Subtract(Vector3& left, Single& right, Vector3& result);
    public static Vector3 Subtract(Vector3 left, float right);
    public static void Subtract(Single& left, Vector3& right, Vector3& result);
    public static Vector3 Subtract(float left, Vector3 right);
    public static void Multiply(Vector3& value, float scale, Vector3& result);
    public static Vector3 Multiply(Vector3 value, float scale);
    public static void Multiply(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Multiply(Vector3 left, Vector3 right);
    public static void Divide(Vector3& value, float scale, Vector3& result);
    public static Vector3 Divide(Vector3 value, float scale);
    public static void Divide(float scale, Vector3& value, Vector3& result);
    public static Vector3 Divide(float scale, Vector3 value);
    public static void Negate(Vector3& value, Vector3& result);
    public static Vector3 Negate(Vector3 value);
    public static void Abs(Vector3& value, Vector3& result);
    public static Vector3 Abs(Vector3 value);
    public static void Barycentric(Vector3& value1, Vector3& value2, Vector3& value3, float amount1, float amount2, Vector3& result);
    public static Vector3 Barycentric(Vector3 value1, Vector3 value2, Vector3 value3, float amount1, float amount2);
    public static void Clamp(Vector3& value, Vector3& min, Vector3& max, Vector3& result);
    public static Vector3 Clamp(Vector3 value, Vector3 min, Vector3 max);
    public static void Cross(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Cross(Vector3 left, Vector3 right);
    public static void Distance(Vector3& value1, Vector3& value2, Single& result);
    public static float Distance(Vector3 value1, Vector3 value2);
    public static void DistanceSquared(Vector3& value1, Vector3& value2, Single& result);
    public static float DistanceSquared(Vector3 value1, Vector3 value2);
    public static bool NearEqual(Vector3 left, Vector3 right, Vector3 epsilon);
    public static bool NearEqual(Vector3& left, Vector3& right, Vector3& epsilon);
    public static void Dot(Vector3& left, Vector3& right, Single& result);
    public static float Dot(Vector3 left, Vector3 right);
    public static void Normalize(Vector3& value, Vector3& result);
    public static Vector3 Normalize(Vector3 value);
    public static void Lerp(Vector3& start, Vector3& end, float amount, Vector3& result);
    public static Vector3 Lerp(Vector3 start, Vector3 end, float amount);
    public static void SmoothStep(Vector3& start, Vector3& end, float amount, Vector3& result);
    public static Vector3 SmoothStep(Vector3 start, Vector3 end, float amount);
    public static void Hermite(Vector3& value1, Vector3& tangent1, Vector3& value2, Vector3& tangent2, float amount, Vector3& result);
    public static Vector3 Hermite(Vector3 value1, Vector3 tangent1, Vector3 value2, Vector3 tangent2, float amount);
    public static void CatmullRom(Vector3& value1, Vector3& value2, Vector3& value3, Vector3& value4, float amount, Vector3& result);
    public static Vector3 CatmullRom(Vector3 value1, Vector3 value2, Vector3 value3, Vector3 value4, float amount);
    public static void Max(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Max(Vector3 left, Vector3 right);
    public static void Min(Vector3& left, Vector3& right, Vector3& result);
    public static Vector3 Min(Vector3 left, Vector3 right);
    public static void Project(Vector3& vector, float x, float y, float width, float height, float minZ, float maxZ, Matrix& worldViewProjection, Vector3& result);
    public static Vector3 Project(Vector3 vector, float x, float y, float width, float height, float minZ, float maxZ, Matrix worldViewProjection);
    public static void Unproject(Vector3& vector, float x, float y, float width, float height, float minZ, float maxZ, Matrix& worldViewProjection, Vector3& result);
    public static Vector3 Unproject(Vector3 vector, float x, float y, float width, float height, float minZ, float maxZ, Matrix worldViewProjection);
    public static void Reflect(Vector3& vector, Vector3& normal, Vector3& result);
    public static Vector3 Reflect(Vector3 vector, Vector3 normal);
    public static void Orthogonalize(Vector3[] destination, Vector3[] source);
    public static void Orthonormalize(Vector3[] destination, Vector3[] source);
    public static void Transform(Vector3& vector, Quaternion& rotation, Vector3& result);
    public static Vector3 Transform(Vector3 vector, Quaternion rotation);
    public static void Transform(Vector3[] source, Quaternion& rotation, Vector3[] destination);
    public static void Transform(Vector3& vector, Matrix3x3& transform, Vector3& result);
    public static Vector3 Transform(Vector3 vector, Matrix3x3 transform);
    public static void Transform(Vector3& vector, Matrix& transform, Vector3& result);
    public static void Transform(Vector3& vector, Matrix& transform, Vector4& result);
    public static Vector4 Transform(Vector3 vector, Matrix transform);
    public static void Transform(Vector3[] source, Matrix& transform, Vector4[] destination);
    public static void TransformCoordinate(Vector3& coordinate, Matrix& transform, Vector3& result);
    public static Vector3 TransformCoordinate(Vector3 coordinate, Matrix transform);
    public static void TransformCoordinate(Vector3[] source, Matrix& transform, Vector3[] destination);
    public static void TransformNormal(Vector3& normal, Matrix& transform, Vector3& result);
    public static Vector3 TransformNormal(Vector3 normal, Matrix transform);
    public static void TransformNormal(Vector3[] source, Matrix& transform, Vector3[] destination);
    public static Vector3 op_Addition(Vector3 left, Vector3 right);
    public static Vector3 op_Multiply(Vector3 left, Vector3 right);
    public static Vector3 op_UnaryPlus(Vector3 value);
    public static Vector3 op_Subtraction(Vector3 left, Vector3 right);
    public static Vector3 op_UnaryNegation(Vector3 value);
    public static Vector3 op_Multiply(float scale, Vector3 value);
    public static Vector3 op_Multiply(Vector3 value, float scale);
    public static Vector3 op_Division(Vector3 value, float scale);
    public static Vector3 op_Division(float scale, Vector3 value);
    public static Vector3 op_Division(Vector3 value, Vector3 scale);
    public static Vector3 op_Addition(Vector3 value, float scalar);
    public static Vector3 op_Addition(float scalar, Vector3 value);
    public static Vector3 op_Subtraction(Vector3 value, float scalar);
    public static Vector3 op_Subtraction(float scalar, Vector3 value);
    public static bool op_Equality(Vector3 left, Vector3 right);
    public static bool op_Inequality(Vector3 left, Vector3 right);
    public static Vector2 op_Explicit(Vector3 value);
    public static Vector4 op_Explicit(Vector3 value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Vector3& other);
    public sealed virtual bool Equals(Vector3 other);
    public virtual bool Equals(object value);
    public static RawVector3 op_Implicit(Vector3 value);
    public static Vector3 op_Implicit(RawVector3 value);
}
[DefaultMemberAttribute("Item")]
public class SharpDX.Vector4 : ValueType {
    public static int SizeInBytes;
    public static Vector4 Zero;
    public static Vector4 UnitX;
    public static Vector4 UnitY;
    public static Vector4 UnitZ;
    public static Vector4 UnitW;
    public static Vector4 One;
    public float X;
    public float Y;
    public float Z;
    public float W;
    public bool IsNormalized { get; }
    public bool IsZero { get; }
    public float Item { get; public set; }
    public Vector4(float value);
    public Vector4(float x, float y, float z, float w);
    public Vector4(Vector3 value, float w);
    public Vector4(Vector2 value, float z, float w);
    public Vector4(Single[] values);
    private static Vector4();
    public bool get_IsNormalized();
    public bool get_IsZero();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public float Length();
    public float LengthSquared();
    public void Normalize();
    public Single[] ToArray();
    public static void Add(Vector4& left, Vector4& right, Vector4& result);
    public static Vector4 Add(Vector4 left, Vector4 right);
    public static void Add(Vector4& left, Single& right, Vector4& result);
    public static Vector4 Add(Vector4 left, float right);
    public static void Subtract(Vector4& left, Vector4& right, Vector4& result);
    public static Vector4 Subtract(Vector4 left, Vector4 right);
    public static void Subtract(Vector4& left, Single& right, Vector4& result);
    public static Vector4 Subtract(Vector4 left, float right);
    public static void Subtract(Single& left, Vector4& right, Vector4& result);
    public static Vector4 Subtract(float left, Vector4 right);
    public static void Multiply(Vector4& value, float scale, Vector4& result);
    public static Vector4 Multiply(Vector4 value, float scale);
    public static void Multiply(Vector4& left, Vector4& right, Vector4& result);
    public static Vector4 Multiply(Vector4 left, Vector4 right);
    public static void Divide(Vector4& value, float scale, Vector4& result);
    public static Vector4 Divide(Vector4 value, float scale);
    public static void Divide(float scale, Vector4& value, Vector4& result);
    public static Vector4 Divide(float scale, Vector4 value);
    public static void Negate(Vector4& value, Vector4& result);
    public static Vector4 Negate(Vector4 value);
    public static void Barycentric(Vector4& value1, Vector4& value2, Vector4& value3, float amount1, float amount2, Vector4& result);
    public static Vector4 Barycentric(Vector4 value1, Vector4 value2, Vector4 value3, float amount1, float amount2);
    public static void Clamp(Vector4& value, Vector4& min, Vector4& max, Vector4& result);
    public static Vector4 Clamp(Vector4 value, Vector4 min, Vector4 max);
    public static void Distance(Vector4& value1, Vector4& value2, Single& result);
    public static float Distance(Vector4 value1, Vector4 value2);
    public static void DistanceSquared(Vector4& value1, Vector4& value2, Single& result);
    public static float DistanceSquared(Vector4 value1, Vector4 value2);
    public static void Dot(Vector4& left, Vector4& right, Single& result);
    public static float Dot(Vector4 left, Vector4 right);
    public static void Normalize(Vector4& value, Vector4& result);
    public static Vector4 Normalize(Vector4 value);
    public static void Lerp(Vector4& start, Vector4& end, float amount, Vector4& result);
    public static Vector4 Lerp(Vector4 start, Vector4 end, float amount);
    public static void SmoothStep(Vector4& start, Vector4& end, float amount, Vector4& result);
    public static Vector4 SmoothStep(Vector4 start, Vector4 end, float amount);
    public static void Hermite(Vector4& value1, Vector4& tangent1, Vector4& value2, Vector4& tangent2, float amount, Vector4& result);
    public static Vector4 Hermite(Vector4 value1, Vector4 tangent1, Vector4 value2, Vector4 tangent2, float amount);
    public static void CatmullRom(Vector4& value1, Vector4& value2, Vector4& value3, Vector4& value4, float amount, Vector4& result);
    public static Vector4 CatmullRom(Vector4 value1, Vector4 value2, Vector4 value3, Vector4 value4, float amount);
    public static void Max(Vector4& left, Vector4& right, Vector4& result);
    public static Vector4 Max(Vector4 left, Vector4 right);
    public static void Min(Vector4& left, Vector4& right, Vector4& result);
    public static Vector4 Min(Vector4 left, Vector4 right);
    public static void Orthogonalize(Vector4[] destination, Vector4[] source);
    public static void Orthonormalize(Vector4[] destination, Vector4[] source);
    public static void Transform(Vector4& vector, Quaternion& rotation, Vector4& result);
    public static Vector4 Transform(Vector4 vector, Quaternion rotation);
    public static void Transform(Vector4[] source, Quaternion& rotation, Vector4[] destination);
    public static void Transform(Vector4& vector, Matrix& transform, Vector4& result);
    public static Vector4 Transform(Vector4 vector, Matrix transform);
    public static void Transform(Vector4& vector, Matrix5x4& transform, Vector4& result);
    public static Vector4 Transform(Vector4 vector, Matrix5x4 transform);
    public static void Transform(Vector4[] source, Matrix& transform, Vector4[] destination);
    public static Vector4 op_Addition(Vector4 left, Vector4 right);
    public static Vector4 op_Multiply(Vector4 left, Vector4 right);
    public static Vector4 op_UnaryPlus(Vector4 value);
    public static Vector4 op_Subtraction(Vector4 left, Vector4 right);
    public static Vector4 op_UnaryNegation(Vector4 value);
    public static Vector4 op_Multiply(float scale, Vector4 value);
    public static Vector4 op_Multiply(Vector4 value, float scale);
    public static Vector4 op_Division(Vector4 value, float scale);
    public static Vector4 op_Division(float scale, Vector4 value);
    public static Vector4 op_Division(Vector4 value, Vector4 scale);
    public static Vector4 op_Addition(Vector4 value, float scalar);
    public static Vector4 op_Addition(float scalar, Vector4 value);
    public static Vector4 op_Subtraction(Vector4 value, float scalar);
    public static Vector4 op_Subtraction(float scalar, Vector4 value);
    public static bool op_Equality(Vector4 left, Vector4 right);
    public static bool op_Inequality(Vector4 left, Vector4 right);
    public static Vector2 op_Explicit(Vector4 value);
    public static Vector3 op_Explicit(Vector4 value);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public bool Equals(Vector4& other);
    public sealed virtual bool Equals(Vector4 other);
    public virtual bool Equals(object value);
    public static RawVector4 op_Implicit(Vector4 value);
    public static Vector4 op_Implicit(RawVector4 value);
}
public class SharpDX.Viewport : ValueType {
    public int X;
    public int Y;
    public int Width;
    public int Height;
    public float MinDepth;
    public float MaxDepth;
    public Rectangle Bounds { get; public set; }
    public float AspectRatio { get; }
    public Viewport(int x, int y, int width, int height);
    public Viewport(int x, int y, int width, int height, float minDepth, float maxDepth);
    public Viewport(Rectangle bounds);
    public Rectangle get_Bounds();
    public void set_Bounds(Rectangle value);
    public bool Equals(Viewport& other);
    public sealed virtual bool Equals(Viewport other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Viewport left, Viewport right);
    public static bool op_Inequality(Viewport left, Viewport right);
    public virtual string ToString();
    public Vector3 Project(Vector3 source, Matrix projection, Matrix view, Matrix world);
    public void Project(Vector3& source, Matrix& matrix, Vector3& vector);
    public Vector3 Unproject(Vector3 source, Matrix projection, Matrix view, Matrix world);
    public void Unproject(Vector3& source, Matrix& matrix, Vector3& vector);
    public float get_AspectRatio();
    public static RawViewport op_Implicit(Viewport value);
    public static RawViewportF op_Implicit(Viewport value);
    public static Viewport op_Implicit(RawViewport value);
}
public class SharpDX.ViewportF : ValueType {
    public float X;
    public float Y;
    public float Width;
    public float Height;
    public float MinDepth;
    public float MaxDepth;
    public RectangleF Bounds { get; public set; }
    public float AspectRatio { get; }
    public ViewportF(float x, float y, float width, float height);
    public ViewportF(float x, float y, float width, float height, float minDepth, float maxDepth);
    public ViewportF(RectangleF bounds);
    public RectangleF get_Bounds();
    public void set_Bounds(RectangleF value);
    public bool Equals(ViewportF& other);
    public sealed virtual bool Equals(ViewportF other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ViewportF left, ViewportF right);
    public static bool op_Inequality(ViewportF left, ViewportF right);
    public virtual string ToString();
    public Vector3 Project(Vector3 source, Matrix projection, Matrix view, Matrix world);
    public void Project(Vector3& source, Matrix& matrix, Vector3& vector);
    public Vector3 Unproject(Vector3 source, Matrix projection, Matrix view, Matrix world);
    public void Unproject(Vector3& source, Matrix& matrix, Vector3& vector);
    public float get_AspectRatio();
    public static ViewportF op_Implicit(Viewport value);
    public static RawViewportF op_Implicit(ViewportF value);
    public static ViewportF op_Implicit(RawViewportF value);
}
