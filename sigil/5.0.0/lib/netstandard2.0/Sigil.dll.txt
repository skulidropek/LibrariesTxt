public class Sigil.CatchBlock : object {
    [CompilerGeneratedAttribute]
private ExceptionBlock <ExceptionBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExceptionType>k__BackingField;
    public ExceptionBlock ExceptionBlock { get; private set; }
    public bool IsCatchAll { get; }
    public Type ExceptionType { get; private set; }
    private object Sigil.Impl.IOwned.Owner { get; }
    internal CatchBlock(Type exceptionType, ExceptionBlock forTry);
    [CompilerGeneratedAttribute]
public ExceptionBlock get_ExceptionBlock();
    [CompilerGeneratedAttribute]
private void set_ExceptionBlock(ExceptionBlock value);
    public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
public Type get_ExceptionType();
    [CompilerGeneratedAttribute]
private void set_ExceptionType(Type value);
    private sealed virtual override object Sigil.Impl.IOwned.get_Owner();
}
[DefaultMemberAttribute("Item")]
public class Sigil.DisassembledOperations`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Local> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Label> <Labels>k__BackingField;
    private object UsageLock;
    private IEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) _Usage;
    [CompilerGeneratedAttribute]
private bool <CanEmit>k__BackingField;
    private List`1<Operation`1<DelegateType>> Operations;
    public int Count { get; }
    public IEnumerable`1<Parameter> Parameters { get; private set; }
    public IEnumerable`1<Local> Locals { get; private set; }
    public IEnumerable`1<Label> Labels { get; private set; }
    public IEnumerable`1<OperationResultUsage`1<DelegateType>> Usage { get; }
    public bool CanEmit { get; private set; }
    public Operation`1<DelegateType> Item { get; }
    internal DisassembledOperations`1(List`1<Operation`1<DelegateType>> ops, IEnumerable`1<Parameter> ps, IEnumerable`1<Local> locs, IEnumerable`1<Label> labels, bool canEmit);
    public int get_Count();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IEnumerable`1<Parameter> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Local> get_Locals();
    [CompilerGeneratedAttribute]
private void set_Locals(IEnumerable`1<Local> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Label> get_Labels();
    [CompilerGeneratedAttribute]
private void set_Labels(IEnumerable`1<Label> value);
    public IEnumerable`1<OperationResultUsage`1<DelegateType>> get_Usage();
    [CompilerGeneratedAttribute]
public bool get_CanEmit();
    [CompilerGeneratedAttribute]
private void set_CanEmit(bool value);
    public Operation`1<DelegateType> get_Item(int index);
    private void Apply(int i, Emit`1<DelegateType> emit);
    private Emit`1<DelegateType> EmitFrom(int from, int length, string name, ModuleBuilder module);
    private Emit`1<DelegateType> Emit(int length, string name, ModuleBuilder module);
    public Emit`1<DelegateType> EmitAll(string name, ModuleBuilder module);
    public sealed virtual IEnumerator`1<Operation`1<DelegateType>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Sigil.Disassembler`1 : object {
    private static byte ContinueOpcode;
    private static LinqDictionary`2<int, OpCode> OneByteOps;
    private static LinqDictionary`2<int, OpCode> TwoByteOps;
    private static Disassembler`1();
    private static void CheckDelegateType();
    public static DisassembledOperations`1<DelegateType> Disassemble(DelegateType del);
    private static List`1<SigilTuple`2<int, Operation`1<DelegateType>>> InferTypes(List`1<SigilTuple`2<int, Operation`1<DelegateType>>> ops, List`1<SigilTuple`2<int, Operation`1<DelegateType>>> infer, IEnumerable`1<Parameter> ps, IEnumerable`1<Local> ls, IEnumerable`1<Label> asLabels);
    private static Operation`1<DelegateType> MakeInferredReplayableOp(OpCode op, LinqList`1<TypeOnStack> consumesType, PrefixTracker prefixes);
    private static List`1<SigilTuple`2<int, Operation`1<DelegateType>>> OrderOperations(List`1<SigilTuple`2<int, Operation`1<DelegateType>>> ops);
    private static int IndexOfOpLastAt(IEnumerable`1<SigilTuple`2<int, Operation`1<DelegateType>>> ops, int ix);
    private static int DeclarationNumber(Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> start, ExceptionHandlingClause exc);
    private static IEnumerable`1<SigilTuple`2<int, Operation`1<DelegateType>>> GetOperations(Module mod, Byte[] cil, IEnumerable`1<Parameter> ps, IEnumerable`1<Local> ls, LabelTracker<DelegateType> labels, IList`1<ExceptionHandlingClause> exceptions, List`1<Label> labelAccumulator, List`1<SigilTuple`2<int, Operation`1<DelegateType>>> needsInference);
    private static void CheckForExceptionOperations(int i, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> exceptionStart, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> exceptionEnd, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> catchStart, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> catchEnd, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> finallyStart, Dictionary`2<int, LinqList`1<ExceptionHandlingClause>> finallyEnd, Dictionary`2<ExceptionHandlingClause, string> activeExceptionBlocks, Dictionary`2<ExceptionHandlingClause, string> activeCatchBlocks, Dictionary`2<ExceptionHandlingClause, string> activeFinallyBlocks, List`1<SigilTuple`2<int, Operation`1<DelegateType>>> ret);
    private static int ReadOp(Module mod, Byte[] cil, int ix, IDictionary`2<int, Parameter> pLookup, IDictionary`2<int, Local> lLookup, PrefixTracker prefixes, LabelTracker<DelegateType> labels, List`1<Label> labelAccumulator, Operation`1& op);
    private static Label ChooseLabel(int absAddr, LabelTracker<DelegateType> labels, List`1<Label> labelAccumulator);
    private static Operation`1<DelegateType> MakeReplayableOperation(OpCode op, Object[] operands, PrefixTracker prefixes, LabelTracker<DelegateType> labels, List`1<Label> labelAccumulator, IDictionary`2<int, Local> locals);
    private static long ReadLong(Byte[] cil, int at);
    private static int ReadInt(Byte[] cil, int at);
    private static short ReadShort(Byte[] cil, int at);
    private static float ReadFloat(Byte[] cil, int at);
    private static double ReadDouble(Byte[] cil, int at);
    private static float ReadSingle(Byte[] cil, int at);
    private static Object[] ReadOperands(Module mod, OpCode op, Byte[] cil, int instrStart, int operandStart, IDictionary`2<int, Parameter> pLookup, IDictionary`2<int, Local> lLookup, Int32& advance);
}
public class Sigil.Emit`1 : object {
    internal static ModuleBuilder Module;
    private bool Invalidated;
    private BufferedILGenerator`1<DelegateType> IL;
    private TypeOnStack ReturnType;
    private Type[] ParameterTypes;
    private CallingConventions CallingConventions;
    private LinqList`1<VerifiableTracker> Trackers;
    private ushort NextLocalIndex;
    private LinqList`1<Local> AllLocals;
    private LinqHashSet`1<Local> UnusedLocals;
    private LinqHashSet`1<Label> UnusedLabels;
    private LinqHashSet`1<Label> UnmarkedLabels;
    private LinqList`1<SigilTuple`3<OpCode, Label, int>> Branches;
    private LinqDictionary`2<Label, int> Marks;
    private LinqList`1<int> Returns;
    private LinqList`1<int> Throws;
    private LinqDictionary`2<int, SigilTuple`3<Label, UpdateOpCodeDelegate, OpCode>> BranchPatches;
    private Stack`1<ExceptionBlock> CurrentExceptionBlock;
    private LinqDictionary`2<ExceptionBlock, SigilTuple`2<int, int>> TryBlocks;
    private LinqDictionary`2<CatchBlock, SigilTuple`2<int, int>> CatchBlocks;
    private LinqDictionary`2<FinallyBlock, SigilTuple`2<int, int>> FinallyBlocks;
    private LinqList`1<SigilTuple`2<int, TypeOnStack>> ReadonlyPatches;
    private EmitShorthand`1<DelegateType> Shorthand;
    private DelegateType CreatedDelegate;
    [CompilerGeneratedAttribute]
private DynamicMethod <DynMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodBuilder <MtdBuilder>k__BackingField;
    private bool MethodBuilt;
    [CompilerGeneratedAttribute]
private ConstructorBuilder <ConstrBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuildingConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConstructorDefinedInType>k__BackingField;
    private bool ConstructorBuilt;
    [CompilerGeneratedAttribute]
private bool <AllowsUnverifiableCIL>k__BackingField;
    private int _MaxStackSize;
    [CompilerGeneratedAttribute]
private LinqList`1<Local> <FreedLocals>k__BackingField;
    private LinqDictionary`2<string, Local> CurrentLocals;
    [CompilerGeneratedAttribute]
private LocalLookup <Locals>k__BackingField;
    private LinqDictionary`2<string, Label> CurrentLabels;
    [CompilerGeneratedAttribute]
private LabelLookup <Labels>k__BackingField;
    private RollingVerifier CurrentVerifiers;
    private bool MustMark;
    private LinqList`1<int> ElidableCasts;
    private LinqDictionary`2<int, LinqList`1<TypeOnStack>> TypesProducedAtIndex;
    private bool IsVerifying;
    private bool UsesStrictBranchVerification;
    private Dictionary`2<string, ExceptionBlock> DisassembledExceptionBlocks;
    private Dictionary`2<string, CatchBlock> DisassembledCatchBlocks;
    private Dictionary`2<string, FinallyBlock> DisassembledFinallyBlocks;
    internal DynamicMethod DynMethod { get; internal set; }
    internal MethodBuilder MtdBuilder { get; internal set; }
    internal ConstructorBuilder ConstrBuilder { get; internal set; }
    internal bool IsBuildingConstructor { get; internal set; }
    internal Type ConstructorDefinedInType { get; internal set; }
    public bool AllowsUnverifiableCIL { get; private set; }
    public int MaxStackSize { get; private set; }
    private LinqList`1<Local> FreedLocals { get; private set; }
    public LocalLookup Locals { get; private set; }
    public LabelLookup Labels { get; private set; }
    private static Emit`1();
    private Emit`1(CallingConventions callConvention, Type returnType, Type[] parameterTypes, bool allowUnverifiable, bool doVerify, bool strictBranchVerification);
    public Emit`1<DelegateType> ArgumentList();
    private void VerifyAndDoArithmetic(string name, OpCode addOp, bool allowReference, bool allowsFloatingPoint);
    public Emit`1<DelegateType> Add();
    public Emit`1<DelegateType> AddOverflow();
    public Emit`1<DelegateType> UnsignedAddOverflow();
    public Emit`1<DelegateType> Divide();
    public Emit`1<DelegateType> UnsignedDivide();
    public Emit`1<DelegateType> Multiply();
    public Emit`1<DelegateType> MultiplyOverflow();
    public Emit`1<DelegateType> UnsignedMultiplyOverflow();
    public Emit`1<DelegateType> Remainder();
    public Emit`1<DelegateType> UnsignedRemainder();
    public Emit`1<DelegateType> Subtract();
    public Emit`1<DelegateType> SubtractOverflow();
    public Emit`1<DelegateType> UnsignedSubtractOverflow();
    public Emit`1<DelegateType> Negate();
    private void VerifyAndBinaryBitwise(string name, OpCode op);
    public Emit`1<DelegateType> And();
    public Emit`1<DelegateType> Or();
    public Emit`1<DelegateType> Xor();
    public Emit`1<DelegateType> Not();
    private void VerifyAndShift(string name, OpCode op);
    public Emit`1<DelegateType> ShiftLeft();
    public Emit`1<DelegateType> ShiftRight();
    public Emit`1<DelegateType> UnsignedShiftRight();
    public Emit`1<DelegateType> Box();
    public Emit`1<DelegateType> Box(Type valueType);
    public Emit`1<DelegateType> Branch(Label label);
    public Emit`1<DelegateType> Branch(string name);
    public Emit`1<DelegateType> BranchIfEqual(Label label);
    public Emit`1<DelegateType> BranchIfEqual(string name);
    public Emit`1<DelegateType> UnsignedBranchIfNotEqual(Label label);
    public Emit`1<DelegateType> UnsignedBranchIfNotEqual(string name);
    private TransitionWrapper BranchComparableTransitions(string name);
    public Emit`1<DelegateType> BranchIfGreaterOrEqual(Label label);
    public Emit`1<DelegateType> BranchIfGreaterOrEqual(string name);
    public Emit`1<DelegateType> UnsignedBranchIfGreaterOrEqual(Label label);
    public Emit`1<DelegateType> UnsignedBranchIfGreaterOrEqual(string name);
    public Emit`1<DelegateType> BranchIfGreater(Label label);
    public Emit`1<DelegateType> BranchIfGreater(string name);
    public Emit`1<DelegateType> UnsignedBranchIfGreater(Label label);
    public Emit`1<DelegateType> UnsignedBranchIfGreater(string name);
    public Emit`1<DelegateType> BranchIfLessOrEqual(Label label);
    public Emit`1<DelegateType> BranchIfLessOrEqual(string name);
    public Emit`1<DelegateType> UnsignedBranchIfLessOrEqual(Label label);
    public Emit`1<DelegateType> UnsignedBranchIfLessOrEqual(string name);
    public Emit`1<DelegateType> BranchIfLess(Label label);
    public Emit`1<DelegateType> BranchIfLess(string name);
    public Emit`1<DelegateType> UnsignedBranchIfLess(Label label);
    public Emit`1<DelegateType> UnsignedBranchIfLess(string name);
    public Emit`1<DelegateType> BranchIfFalse(Label label);
    public Emit`1<DelegateType> BranchIfFalse(string name);
    public Emit`1<DelegateType> BranchIfTrue(Label label);
    public Emit`1<DelegateType> BranchIfTrue(string name);
    public Emit`1<DelegateType> Break();
    private void InjectTailCall();
    public Emit`1<DelegateType> Call(Emit`1<MethodEmit> emit, Type[] arglist);
    public Emit`1<DelegateType> Call(MethodInfo method, Type[] arglist);
    private bool IsLegalConstructoCall(ConstructorInfo cons);
    public Emit`1<DelegateType> Call(ConstructorInfo cons);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions);
    public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions, Type returnType, Type[] parameterTypes, Type[] arglist);
    public Emit`1<DelegateType> CallIndirect(CallingConventions callConventions, Type returnType, Type[] parameterTypes);
    public Emit`1<DelegateType> CallVirtual(MethodInfo method, Type constrained, Type[] arglist);
    private void ElideCasts();
    public Emit`1<DelegateType> CastClass();
    public Emit`1<DelegateType> CastClass(Type referenceType);
    public Emit`1<DelegateType> CheckFinite();
    private TransitionWrapper ValidateComparable(string method);
    public Emit`1<DelegateType> CompareEqual();
    public Emit`1<DelegateType> CompareGreaterThan();
    public Emit`1<DelegateType> UnsignedCompareGreaterThan();
    public Emit`1<DelegateType> CompareLessThan();
    public Emit`1<DelegateType> UnsignedCompareLessThan();
    private TransitionWrapper CheckConvertible(string method, Type toType);
    public Emit`1<DelegateType> Convert();
    public Emit`1<DelegateType> Convert(Type primitiveType);
    public Emit`1<DelegateType> ConvertOverflow();
    public Emit`1<DelegateType> ConvertOverflow(Type primitiveType);
    public Emit`1<DelegateType> UnsignedConvertOverflow();
    public Emit`1<DelegateType> UnsignedConvertOverflow(Type primitiveType);
    public Emit`1<DelegateType> UnsignedConvertToFloat();
    private void ConvertToNativeInt(TransitionWrapper transitions);
    private void ConvertToNativeIntOverflow(TransitionWrapper transitions);
    private void UnsignedConvertToNativeIntOverflow(TransitionWrapper transitions);
    private void UnsignedConvertToUnsignedNativeIntOverflow(TransitionWrapper transitions);
    private void ConvertToUnsignedNativeInt(TransitionWrapper transitions);
    private void ConvertToUnsignedNativeIntOverflow(TransitionWrapper transitions);
    private void ConvertToSByte(TransitionWrapper transitions);
    private void ConvertToSByteOverflow(TransitionWrapper transitions);
    private void UnsignedConvertToSByteOverflow(TransitionWrapper transitions);
    private void ConvertToInt16(TransitionWrapper transitions);
    private void ConvertToInt16Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToInt16Overflow(TransitionWrapper transitions);
    private void ConvertToInt32(TransitionWrapper transitions);
    private void ConvertToInt32Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToInt32Overflow(TransitionWrapper transitions);
    private void ConvertToInt64(TransitionWrapper transitions);
    private void ConvertToInt64Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToInt64Overflow(TransitionWrapper transitions);
    private void ConvertToFloat(TransitionWrapper transitions);
    private void ConvertToDouble(TransitionWrapper transitions);
    private void ConvertToByte(TransitionWrapper transitions);
    private void ConvertToByteOverflow(TransitionWrapper transitions);
    private void UnsignedConvertToByteOverflow(TransitionWrapper transitions);
    private void ConvertToUInt16(TransitionWrapper transitions);
    private void ConvertToUInt16Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToUInt16Overflow(TransitionWrapper transitions);
    private void ConvertToUInt32(TransitionWrapper transitions);
    private void ConvertToUInt32Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToUInt32Overflow(TransitionWrapper transitions);
    private void ConvertToUInt64(TransitionWrapper transitions);
    private void ConvertToUInt64Overflow(TransitionWrapper transitions);
    private void UnsignedConvertToUInt64Overflow(TransitionWrapper transitions);
    public Emit`1<DelegateType> CopyBlock(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> CopyObject();
    public Emit`1<DelegateType> CopyObject(Type valueType);
    [CompilerGeneratedAttribute]
internal DynamicMethod get_DynMethod();
    [CompilerGeneratedAttribute]
internal void set_DynMethod(DynamicMethod value);
    [CompilerGeneratedAttribute]
internal MethodBuilder get_MtdBuilder();
    [CompilerGeneratedAttribute]
internal void set_MtdBuilder(MethodBuilder value);
    [CompilerGeneratedAttribute]
internal ConstructorBuilder get_ConstrBuilder();
    [CompilerGeneratedAttribute]
internal void set_ConstrBuilder(ConstructorBuilder value);
    [CompilerGeneratedAttribute]
internal bool get_IsBuildingConstructor();
    [CompilerGeneratedAttribute]
internal void set_IsBuildingConstructor(bool value);
    [CompilerGeneratedAttribute]
internal Type get_ConstructorDefinedInType();
    [CompilerGeneratedAttribute]
internal void set_ConstructorDefinedInType(Type value);
    [CompilerGeneratedAttribute]
public bool get_AllowsUnverifiableCIL();
    [CompilerGeneratedAttribute]
private void set_AllowsUnverifiableCIL(bool value);
    public int get_MaxStackSize();
    private void set_MaxStackSize(int value);
    [CompilerGeneratedAttribute]
private LinqList`1<Local> get_FreedLocals();
    [CompilerGeneratedAttribute]
private void set_FreedLocals(LinqList`1<Local> value);
    [CompilerGeneratedAttribute]
public LocalLookup get_Locals();
    [CompilerGeneratedAttribute]
private void set_Locals(LocalLookup value);
    [CompilerGeneratedAttribute]
public LabelLookup get_Labels();
    [CompilerGeneratedAttribute]
private void set_Labels(LabelLookup value);
    internal static Emit`1<NonGenericPlaceholderDelegate> MakeNonGenericEmit(CallingConventions callConvention, Type returnType, Type[] parameterTypes, bool allowUnverifiable, bool doVerify, bool strictBranchVerification);
    public EmitShorthand`1<DelegateType> AsShorthand();
    public string Instructions();
    public int ILOffset();
    private void Seal(OptimizationOptions optimizationOptions);
    public IEnumerable`1<OperationResultUsage`1<DelegateType>> TraceOperationResultUsage();
    internal Delegate InnerCreateDelegate(Type delegateType, String& instructions, OptimizationOptions optimizationOptions);
    public DelegateType CreateDelegate(String& instructions, OptimizationOptions optimizationOptions);
    public DelegateType CreateDelegate(OptimizationOptions optimizationOptions);
    public MethodBuilder CreateMethod(String& instructions, OptimizationOptions optimizationOptions);
    public MethodBuilder CreateMethod(OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateConstructor(String& instructions, OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateConstructor(OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateTypeInitializer(String& instructions, OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateTypeInitializer(OptimizationOptions optimizationOptions);
    private static void ValidateNewParameters();
    internal static bool AllowsUnverifiableCode(Module m);
    internal static bool AllowsUnverifiableCode(ModuleBuilder m);
    public static Emit`1<DelegateType> NewDynamicMethod(string name, ModuleBuilder module, bool doVerify, bool strictBranchVerification);
    internal static Emit`1<DelegateType> DisassemblerDynamicMethod(Type[] parameters, string name, ModuleBuilder module, bool doVerify, bool strictBranchVerification);
    public static Emit`1<DelegateType> NewDynamicMethod(Type owner, string name, bool doVerify, bool strictBranchVerification);
    internal static void CheckAttributesAndConventions(MethodAttributes attributes, CallingConventions callingConvention);
    private static bool HasFlag(MethodAttributes value, MethodAttributes flag);
    private static bool HasFlag(CallingConventions value, CallingConventions flag);
    public static Emit`1<DelegateType> BuildMethod(TypeBuilder type, string name, MethodAttributes attributes, CallingConventions callingConvention, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public static Emit`1<DelegateType> BuildStaticMethod(TypeBuilder type, string name, MethodAttributes attributes, bool allowUnverifiableCode, bool doVerify);
    public static Emit`1<DelegateType> BuildInstanceMethod(TypeBuilder type, string name, MethodAttributes attributes, bool allowUnverifiableCode, bool doVerify);
    public static Emit`1<DelegateType> BuildConstructor(TypeBuilder type, MethodAttributes attributes, CallingConventions callingConvention, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public static Emit`1<DelegateType> BuildTypeInitializer(TypeBuilder type, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    private void RemoveInstruction(int index);
    private void InsertInstruction(int index, OpCode instr);
    private void UpdateStackAndInstrStream(Nullable`1<OpCode> instr, TransitionWrapper transitions, bool firstParamIsThis);
    private void UpdateState(TransitionWrapper transitions);
    private void UpdateState(OpCode instr, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, byte param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, short param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, int param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, UInt32 param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, long param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, ulong param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, float param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, double param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, Local param, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, Label param, TransitionWrapper transitions, UpdateOpCodeDelegate& update);
    private void UpdateState(OpCode instr, Label[] param, TransitionWrapper transitions, UpdateOpCodeDelegate& update);
    private void UpdateState(OpCode instr, MethodInfo method, IEnumerable`1<Type> parameterTypes, TransitionWrapper transitions, bool firstParamIsThis, Type[] arglist);
    private void UpdateState(OpCode instr, ConstructorInfo cons, IEnumerable`1<Type> parameterTypes, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, ConstructorInfo cons, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, Type type, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, FieldInfo field, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, string str, TransitionWrapper transitions);
    private void UpdateState(OpCode instr, CallingConventions callConventions, Type returnType, Type[] parameterTypes, TransitionWrapper transitions, Type[] arglist);
    private TransitionWrapper Wrap(IEnumerable`1<StackTransition> trans, string name);
    public Emit`1<DelegateType> Duplicate();
    public Emit`1<DelegateType> InitializeBlock(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> InitializeObject();
    public Emit`1<DelegateType> InitializeObject(Type valueType);
    public Emit`1<DelegateType> IsInstance();
    public Emit`1<DelegateType> IsInstance(Type type);
    public Emit`1<DelegateType> Jump(MethodInfo method);
    private void PatchBranches();
    public Label DefineLabel(string name);
    public Emit`1<DelegateType> DefineLabel(Label& label, string name);
    public Emit`1<DelegateType> MarkLabel(Label label);
    public Emit`1<DelegateType> MarkLabel(string name);
    public Emit`1<DelegateType> Leave(Label label);
    public Emit`1<DelegateType> Leave(string name);
    public Emit`1<DelegateType> LoadArgument(ushort index);
    public Emit`1<DelegateType> LoadArgumentAddress(ushort index);
    public Emit`1<DelegateType> LoadConstant(bool b);
    public Emit`1<DelegateType> LoadConstant(int i);
    public Emit`1<DelegateType> LoadConstant(UInt32 i);
    public Emit`1<DelegateType> LoadConstant(long l);
    public Emit`1<DelegateType> LoadConstant(ulong l);
    public Emit`1<DelegateType> LoadConstant(float f);
    public Emit`1<DelegateType> LoadConstant(double d);
    public Emit`1<DelegateType> LoadConstant(string str);
    public Emit`1<DelegateType> LoadConstant(FieldInfo field);
    public Emit`1<DelegateType> LoadConstant(MethodInfo method);
    public Emit`1<DelegateType> LoadConstant();
    public Emit`1<DelegateType> LoadConstant(Type type);
    public Emit`1<DelegateType> LoadNull();
    public Emit`1<DelegateType> LoadElement();
    public Emit`1<DelegateType> LoadElement(Type elementType);
    private void InjectReadOnly();
    public Emit`1<DelegateType> LoadElementAddress();
    public Emit`1<DelegateType> LoadElementAddress(Type elementType);
    public Emit`1<DelegateType> LoadField(FieldInfo field, Nullable`1<bool> isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> LoadFieldAddress(FieldInfo field);
    public Emit`1<DelegateType> LoadFunctionPointer(MethodInfo method);
    public Emit`1<DelegateType> LoadFunctionPointer(MethodBuilder method, Type[] parameterTypes);
    private Emit`1<DelegateType> InnerLoadFunctionPointer(MethodInfo method, Type[] parameterTypes);
    public Emit`1<DelegateType> LoadIndirect(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> LoadIndirect(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> LoadLength();
    public Emit`1<DelegateType> LoadLength(Type elementType);
    public Emit`1<DelegateType> LoadLocal(Local local);
    public Emit`1<DelegateType> LoadLocal(string name);
    public Emit`1<DelegateType> LoadLocalAddress(Local local);
    public Emit`1<DelegateType> LoadLocalAddress(string name);
    public Emit`1<DelegateType> LoadObject(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> LoadObject(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> LoadVirtualFunctionPointer(MethodInfo method);
    public Emit`1<DelegateType> LoadVirtualFunctionPointer(MethodBuilder method, Type[] parameterTypes);
    private Emit`1<DelegateType> InnerLoadVirtualFunctionPointer(MethodInfo method, Type[] parameterTypes);
    public Emit`1<DelegateType> LocalAllocate();
    private void LocalReleased(Local local);
    public Local DeclareLocal(string name, bool initializeReused);
    public Local DeclareLocal(Type type, string name, bool initializeReused);
    public Emit`1<DelegateType> DeclareLocal(Local& local, string name, bool initializeReused);
    public Emit`1<DelegateType> DeclareLocal(Type type, Local& local, string name, bool initializeReused);
    public Emit`1<DelegateType> MakeReferenceAny();
    public Emit`1<DelegateType> MakeReferenceAny(Type type);
    public Emit`1<DelegateType> NewArray();
    public Emit`1<DelegateType> NewArray(Type elementType);
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit`1<DelegateType> NewObject();
    public Emit`1<DelegateType> NewObject(Type type, Type[] parameterTypes);
    public Emit`1<DelegateType> NewObject(ConstructorInfo constructor);
    public Emit`1<DelegateType> NewObject(ConstructorBuilder constructor, Type[] parameterTypes);
    private Emit`1<DelegateType> InnerNewObject(ConstructorInfo constructor, Type[] parameterTypes);
    public Emit`1<DelegateType> Nop();
    public Emit`1<DelegateType> Pop();
    public Emit`1<DelegateType> ReferenceAnyType();
    public Emit`1<DelegateType> ReferenceAnyValue();
    public Emit`1<DelegateType> ReferenceAnyValue(Type type);
    public Emit`1<DelegateType> ReThrow();
    public Emit`1<DelegateType> Return();
    public Emit`1<DelegateType> SizeOf();
    public Emit`1<DelegateType> SizeOf(Type valueType);
    public Emit`1<DelegateType> StoreArgument(ushort index);
    public Emit`1<DelegateType> StoreElement();
    public Emit`1<DelegateType> StoreElement(Type elementType);
    public Emit`1<DelegateType> StoreField(FieldInfo field, bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> StoreIndirect(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> StoreIndirect(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> StoreLocal(Local local);
    public Emit`1<DelegateType> StoreLocal(string name);
    public Emit`1<DelegateType> StoreObject(bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> StoreObject(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public Emit`1<DelegateType> Switch(Label[] labels);
    public Emit`1<DelegateType> Switch(String[] names);
    public Emit`1<DelegateType> Throw();
    internal void BeginExceptionBlock(string storeUnderName);
    internal void EndExceptionBlock(string lookupByName);
    internal void BeginCatchBlock(string lookupExcName, Type exceptionType, string storeUnderName);
    internal void EndCatchBlock(string lookupByName);
    internal void BeginFinallyBlock(string lookupExcName, string storeUnderName);
    internal void EndFinallyBlock(string lookupByName);
    public ExceptionBlock BeginExceptionBlock();
    public Emit`1<DelegateType> BeginExceptionBlock(ExceptionBlock& forTry);
    public Emit`1<DelegateType> EndExceptionBlock(ExceptionBlock forTry);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry);
    public Emit`1<DelegateType> BeginCatchBlock(ExceptionBlock forTry, CatchBlock& forCatch);
    public CatchBlock BeginCatchAllBlock(ExceptionBlock forTry);
    public Emit`1<DelegateType> BeginCatchAllBlock(ExceptionBlock forTry, CatchBlock& forCatch);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry, Type exceptionType);
    public Emit`1<DelegateType> BeginCatchBlock(ExceptionBlock forTry, Type exceptionType, CatchBlock& forCatch);
    public Emit`1<DelegateType> EndCatchBlock(CatchBlock forCatch);
    public Emit`1<DelegateType> BeginFinallyBlock(ExceptionBlock forTry, FinallyBlock& forFinally);
    public FinallyBlock BeginFinallyBlock(ExceptionBlock forTry);
    public Emit`1<DelegateType> EndFinallyBlock(FinallyBlock forFinally);
    public Emit`1<DelegateType> Unbox();
    public Emit`1<DelegateType> Unbox(Type valueType);
    public Emit`1<DelegateType> UnboxAny();
    public Emit`1<DelegateType> UnboxAny(Type valueType);
    private void FailStackUnderflow(int expected, string method);
    private void FailOwnership(IOwned obj);
    private void FailUnverifiable(string method);
    private void ValidateTryCatchFinallyBlocks();
    private void ValidateTryCatchFinallyBranches();
    private void Validate();
    public Emit`1<DelegateType> WriteLine(string line, Local[] locals);
    [CompilerGeneratedAttribute]
private Operation`1<DelegateType> <TraceOperationResultUsage>b__215_1(InstructionAndTransitions u);
    [CompilerGeneratedAttribute]
private Label <Switch>b__366_1(string n);
    [CompilerGeneratedAttribute]
private bool <WriteLine>b__400_0(IOwned l);
}
public class Sigil.EmitShorthand`1 : object {
    private Emit`1<DelegateType> InnerEmit;
    public bool AllowsUnverifiableCIL { get; }
    public int MaxStackSize { get; }
    public LocalLookup Locals { get; }
    public LabelLookup Labels { get; }
    internal EmitShorthand`1(Emit`1<DelegateType> inner);
    public bool get_AllowsUnverifiableCIL();
    public int get_MaxStackSize();
    public LocalLookup get_Locals();
    public LabelLookup get_Labels();
    public Emit`1<DelegateType> AsLonghand();
    public string Instructions();
    public Local DeclareLocal(string name, bool initializeReused);
    public EmitShorthand`1<DelegateType> DeclareLocal(Local& local, string name, bool initializeReused);
    public Local DeclareLocal(Type type, string name, bool initializeReused);
    public EmitShorthand`1<DelegateType> DeclareLocal(Type type, Local& local, string name, bool initializeReused);
    public Label DefineLabel(string name);
    public EmitShorthand`1<DelegateType> DefineLabel(Label& label, string name);
    public EmitShorthand`1<DelegateType> MarkLabel(Label label);
    public EmitShorthand`1<DelegateType> MarkLabel(string name);
    public ExceptionBlock BeginExceptionBlock();
    public EmitShorthand`1<DelegateType> BeginExceptionBlock(ExceptionBlock& forTry);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry);
    public EmitShorthand`1<DelegateType> BeginCatchBlock(ExceptionBlock forTry, CatchBlock& tryCatch);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry, Type exceptionType);
    public EmitShorthand`1<DelegateType> BeginCatchBlock(ExceptionBlock forTry, Type exceptionType, CatchBlock& forCatch);
    public EmitShorthand`1<DelegateType> EndCatchBlock(CatchBlock forCatch);
    public FinallyBlock BeginFinallyBlock(ExceptionBlock forTry);
    public EmitShorthand`1<DelegateType> BeginFinallyBlock(ExceptionBlock forTry, FinallyBlock& forFinally);
    public EmitShorthand`1<DelegateType> EndFinallyBlock(FinallyBlock forFinally);
    public EmitShorthand`1<DelegateType> EndExceptionBlock(ExceptionBlock forTry);
    public DelegateType CreateDelegate(OptimizationOptions optimizationOptions);
    public MethodBuilder CreateMethod();
    public ConstructorBuilder CreateConstructor();
    public EmitShorthand`1<DelegateType> Add();
    public EmitShorthand`1<DelegateType> Add_Ovf();
    public EmitShorthand`1<DelegateType> Add_Ovf_Un();
    public EmitShorthand`1<DelegateType> And();
    public EmitShorthand`1<DelegateType> Beq(Label label);
    public EmitShorthand`1<DelegateType> Beq(string name);
    public EmitShorthand`1<DelegateType> Bge(Label label);
    public EmitShorthand`1<DelegateType> Bge(string name);
    public EmitShorthand`1<DelegateType> Bge_Un(Label label);
    public EmitShorthand`1<DelegateType> Bge_Un(string name);
    public EmitShorthand`1<DelegateType> Bgt(Label label);
    public EmitShorthand`1<DelegateType> Bgt(string name);
    public EmitShorthand`1<DelegateType> Bgt_Un(Label label);
    public EmitShorthand`1<DelegateType> Bgt_Un(string name);
    public EmitShorthand`1<DelegateType> Ble(Label label);
    public EmitShorthand`1<DelegateType> Ble(string name);
    public EmitShorthand`1<DelegateType> Ble_Un(Label label);
    public EmitShorthand`1<DelegateType> Ble_Un(string name);
    public EmitShorthand`1<DelegateType> Blt(Label label);
    public EmitShorthand`1<DelegateType> Blt(string name);
    public EmitShorthand`1<DelegateType> Blt_Un(Label label);
    public EmitShorthand`1<DelegateType> Blt_Un(string name);
    public EmitShorthand`1<DelegateType> Bne_Un(Label label);
    public EmitShorthand`1<DelegateType> Bne_Un(string name);
    public EmitShorthand`1<DelegateType> Box();
    public EmitShorthand`1<DelegateType> Box(Type valueType);
    public EmitShorthand`1<DelegateType> Br(Label label);
    public EmitShorthand`1<DelegateType> Br(string name);
    public EmitShorthand`1<DelegateType> Break();
    public EmitShorthand`1<DelegateType> Brfalse(Label label);
    public EmitShorthand`1<DelegateType> Brfalse(string name);
    public EmitShorthand`1<DelegateType> Brtrue(Label label);
    public EmitShorthand`1<DelegateType> Brtrue(string name);
    public EmitShorthand`1<DelegateType> Call(MethodInfo method);
    public EmitShorthand`1<DelegateType> Calli(CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public EmitShorthand`1<DelegateType> Callvirt(MethodInfo method, Type constrained);
    public EmitShorthand`1<DelegateType> Castclass();
    public EmitShorthand`1<DelegateType> Castclass(Type referenceType);
    public EmitShorthand`1<DelegateType> Ceq();
    public EmitShorthand`1<DelegateType> Cgt();
    public EmitShorthand`1<DelegateType> Cgt_Un();
    public EmitShorthand`1<DelegateType> Ckfinite();
    public EmitShorthand`1<DelegateType> Clt();
    public EmitShorthand`1<DelegateType> Clt_Un();
    public EmitShorthand`1<DelegateType> Conv_Ovf_Un();
    public EmitShorthand`1<DelegateType> Conv_Ovf_Un(Type primitiveType);
    public EmitShorthand`1<DelegateType> Conv_R_Un();
    public EmitShorthand`1<DelegateType> Conv();
    public EmitShorthand`1<DelegateType> Conv(Type primitiveType);
    public EmitShorthand`1<DelegateType> Conv_Ovf();
    public EmitShorthand`1<DelegateType> Conv_Ovf(Type primitiveType);
    public EmitShorthand`1<DelegateType> Cpblk(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Cpobj();
    public EmitShorthand`1<DelegateType> Cpobj(Type valueType);
    public EmitShorthand`1<DelegateType> Div();
    public EmitShorthand`1<DelegateType> Div_Un();
    public EmitShorthand`1<DelegateType> Dup();
    public EmitShorthand`1<DelegateType> Initblk(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Initobj();
    public EmitShorthand`1<DelegateType> Initobj(Type valueType);
    public EmitShorthand`1<DelegateType> Isinst();
    public EmitShorthand`1<DelegateType> Isinst(Type type);
    public EmitShorthand`1<DelegateType> Jmp(MethodInfo method);
    public EmitShorthand`1<DelegateType> Ldarg(ushort index);
    public EmitShorthand`1<DelegateType> Ldarga(ushort index);
    public EmitShorthand`1<DelegateType> Ldc(bool b);
    public EmitShorthand`1<DelegateType> Ldc(float f);
    public EmitShorthand`1<DelegateType> Ldc(double d);
    public EmitShorthand`1<DelegateType> Ldc(UInt32 u);
    public EmitShorthand`1<DelegateType> Ldc(int i);
    public EmitShorthand`1<DelegateType> Ldc(long l);
    public EmitShorthand`1<DelegateType> Ldc(ulong u);
    public EmitShorthand`1<DelegateType> Ldelem();
    public EmitShorthand`1<DelegateType> Ldelem(Type elementType);
    public EmitShorthand`1<DelegateType> Ldelema();
    public EmitShorthand`1<DelegateType> Ldelema(Type elementType);
    public EmitShorthand`1<DelegateType> Ldfld(FieldInfo field, Nullable`1<bool> isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Ldflda(FieldInfo field);
    public EmitShorthand`1<DelegateType> Ldftn(MethodInfo method);
    public EmitShorthand`1<DelegateType> Ldind(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Ldind(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Ldlen();
    public EmitShorthand`1<DelegateType> Ldlen(Type elementType);
    public EmitShorthand`1<DelegateType> Ldloc(Local local);
    public EmitShorthand`1<DelegateType> Ldloc(string name);
    public EmitShorthand`1<DelegateType> Ldloca(Local local);
    public EmitShorthand`1<DelegateType> Ldloca(string name);
    public EmitShorthand`1<DelegateType> Ldnull();
    public EmitShorthand`1<DelegateType> Ldobj(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Ldobj(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Ldstr(string str);
    public EmitShorthand`1<DelegateType> Ldtoken(FieldInfo field);
    public EmitShorthand`1<DelegateType> Ldtoken(MethodInfo method);
    public EmitShorthand`1<DelegateType> Ldtoken();
    public EmitShorthand`1<DelegateType> Ldtoken(Type type);
    public EmitShorthand`1<DelegateType> Ldvirtftn(MethodInfo method);
    public EmitShorthand`1<DelegateType> Leave(Label label);
    public EmitShorthand`1<DelegateType> Leave(string name);
    public EmitShorthand`1<DelegateType> Localloc();
    public EmitShorthand`1<DelegateType> Mul();
    public EmitShorthand`1<DelegateType> Mul_Ovf();
    public EmitShorthand`1<DelegateType> Mul_Ovf_Un();
    public EmitShorthand`1<DelegateType> Neg();
    public EmitShorthand`1<DelegateType> Newarr();
    public EmitShorthand`1<DelegateType> Newarr(Type elementType);
    public EmitShorthand`1<DelegateType> Newobj(ConstructorInfo constructor);
    public EmitShorthand`1<DelegateType> Nop();
    public EmitShorthand`1<DelegateType> Not();
    public EmitShorthand`1<DelegateType> Or();
    public EmitShorthand`1<DelegateType> Pop();
    public EmitShorthand`1<DelegateType> Rem();
    public EmitShorthand`1<DelegateType> Rem_Un();
    public EmitShorthand`1<DelegateType> Ret();
    public EmitShorthand`1<DelegateType> Rethrow();
    public EmitShorthand`1<DelegateType> Shl();
    public EmitShorthand`1<DelegateType> Shr();
    public EmitShorthand`1<DelegateType> Shr_Un();
    public EmitShorthand`1<DelegateType> Sizeof();
    public EmitShorthand`1<DelegateType> Sizeof(Type valueType);
    public EmitShorthand`1<DelegateType> Starg(ushort index);
    public EmitShorthand`1<DelegateType> Stelem();
    public EmitShorthand`1<DelegateType> Stelem(Type elementType);
    public EmitShorthand`1<DelegateType> Stfld(FieldInfo field, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Stind(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Stind(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Stloc(Local local);
    public EmitShorthand`1<DelegateType> Stloc(string name);
    public EmitShorthand`1<DelegateType> Stobj(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Stobj(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand`1<DelegateType> Sub();
    public EmitShorthand`1<DelegateType> Sub_Ovf();
    public EmitShorthand`1<DelegateType> Sub_Ovf_Un();
    public EmitShorthand`1<DelegateType> Switch(Label[] labels);
    public EmitShorthand`1<DelegateType> Switch(String[] names);
    public EmitShorthand`1<DelegateType> Throw();
    public EmitShorthand`1<DelegateType> Unbox();
    public EmitShorthand`1<DelegateType> Unbox(Type valueType);
    public EmitShorthand`1<DelegateType> Unbox_Any();
    public EmitShorthand`1<DelegateType> Unbox_Any(Type valueType);
    public EmitShorthand`1<DelegateType> WriteLine(string line, Local[] locals);
    public EmitShorthand`1<DelegateType> Xor();
    public IEnumerable`1<OperationResultUsage`1<DelegateType>> TraceOperationResultUsage();
}
public class Sigil.ExceptionBlock : object {
    [CompilerGeneratedAttribute]
private Label <Label>k__BackingField;
    private object Sigil.Impl.IOwned.Owner { get; }
    public Label Label { get; private set; }
    internal ExceptionBlock(Label label);
    private sealed virtual override object Sigil.Impl.IOwned.get_Owner();
    [CompilerGeneratedAttribute]
public Label get_Label();
    [CompilerGeneratedAttribute]
private void set_Label(Label value);
}
public class Sigil.FinallyBlock : object {
    [CompilerGeneratedAttribute]
private ExceptionBlock <ExceptionBlock>k__BackingField;
    public ExceptionBlock ExceptionBlock { get; private set; }
    private object Sigil.Impl.IOwned.Owner { get; }
    internal FinallyBlock(ExceptionBlock forTry);
    [CompilerGeneratedAttribute]
public ExceptionBlock get_ExceptionBlock();
    [CompilerGeneratedAttribute]
private void set_ExceptionBlock(ExceptionBlock value);
    private sealed virtual override object Sigil.Impl.IOwned.get_Owner();
}
internal class Sigil.Impl.AnyByRefType : object {
}
internal class Sigil.Impl.AnyPointerType : object {
}
internal static class Sigil.Impl.AutoNamer : object {
    private static object NullKey;
    private static Dictionary`2<SigilTuple`2<object, string>, int> State;
    private static AutoNamer();
    public static string Next(string root);
    public static string Next(object on, string root, IEnumerable`1[] inUse);
    public static void Release(object on);
}
[DefaultMemberAttribute("Item")]
internal class Sigil.Impl.BufferedILGenerator`1 : object {
    private LinqList`1<SigilAction`3<ILGenerator, bool, StringBuilder>> Buffer;
    private LinqList`1<BufferedILInstruction> TraversableBuffer;
    internal LinqList`1<Operation`1<DelegateType>> Operations;
    private LinqList`1<SigilFunc`1<int>> InstructionSizes;
    private Dictionary`2<int, int> LengthCache;
    private static Regex _ExtractLocal;
    public BufferedILInstruction Item { get; }
    public int Index { get; }
    private static BufferedILGenerator`1();
    public BufferedILInstruction get_Item(int ix);
    public int get_Index();
    public string UnBuffer(ILGenerator il);
    private int LengthTo(int end);
    internal String[] Instructions(LinqList`1<Local> locals);
    private static LinqDictionary`2<int, Local> GetInScopeAt(LinqList`1<Local> allLocals, int ix);
    private static Local ExtractLocal(string from, LinqList`1<Local> locals, int ix);
    public int ByteDistance(int start, int stop);
    public void Remove(int ix);
    public void Insert(int ix, OpCode op);
    public void Emit(OpCode op);
    public void Emit(OpCode op, byte b);
    public void Emit(OpCode op, short s);
    public void Emit(OpCode op, int i);
    public void Emit(OpCode op, UInt32 ui);
    public void Emit(OpCode op, long l);
    public void Emit(OpCode op, ulong ul);
    public void Emit(OpCode op, float f);
    public void Emit(OpCode op, double d);
    public void Emit(OpCode op, MethodInfo method, IEnumerable`1<Type> parameterTypes);
    public void Emit(OpCode op, ConstructorInfo cons, IEnumerable`1<Type> parameterTypes);
    public void Emit(OpCode op, ConstructorInfo cons);
    public void Emit(OpCode op, Type type);
    public void Emit(OpCode op, FieldInfo field);
    public void Emit(OpCode op, string str);
    public void Emit(OpCode op, Label label, UpdateOpCodeDelegate& update);
    public void Emit(OpCode op, Label[] labels, UpdateOpCodeDelegate& update);
    internal static string Join(string delimiter, IEnumerable`1<T> parts);
    public void Emit(OpCode op, Local local);
    public void Emit(OpCode op, CallingConventions callConventions, Type returnType, Type[] parameterTypes);
    public void EmitCall(OpCode op, MethodInfo method, IEnumerable`1<Type> parameterTypes, Type[] arglist);
    public void EmitCalli(CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] arglist);
    public DefineLabelDelegate BeginExceptionBlock();
    public void BeginCatchBlock(Type exception);
    public void EndExceptionBlock();
    public void EndCatchBlock();
    public void BeginFinallyBlock();
    public void EndFinallyBlock();
    public DefineLabelDelegate DefineLabel();
    public void MarkLabel(Label label);
    public DeclareLocallDelegate DeclareLocal(Type type);
}
internal class Sigil.Impl.BufferedILInstruction : object {
    [CompilerGeneratedAttribute]
private bool <DefinesLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private Label <MarksLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartsExceptionBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndsExceptionBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartsCatchBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndsCatchBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartsFinallyBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndsFinallyBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeclaresLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<OpCode> <IsInstruction>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MethodReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqRoot`1<Type> <MethodParameterTypes>k__BackingField;
    public bool DefinesLabel { get; internal set; }
    public Label MarksLabel { get; internal set; }
    public bool StartsExceptionBlock { get; internal set; }
    public bool EndsExceptionBlock { get; internal set; }
    public bool StartsCatchBlock { get; internal set; }
    public bool EndsCatchBlock { get; internal set; }
    public bool StartsFinallyBlock { get; internal set; }
    public bool EndsFinallyBlock { get; internal set; }
    public bool DeclaresLocal { get; internal set; }
    public Nullable`1<OpCode> IsInstruction { get; internal set; }
    public Type MethodReturnType { get; internal set; }
    public LinqRoot`1<Type> MethodParameterTypes { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_DefinesLabel();
    [CompilerGeneratedAttribute]
internal void set_DefinesLabel(bool value);
    [CompilerGeneratedAttribute]
public Label get_MarksLabel();
    [CompilerGeneratedAttribute]
internal void set_MarksLabel(Label value);
    [CompilerGeneratedAttribute]
public bool get_StartsExceptionBlock();
    [CompilerGeneratedAttribute]
internal void set_StartsExceptionBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EndsExceptionBlock();
    [CompilerGeneratedAttribute]
internal void set_EndsExceptionBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_StartsCatchBlock();
    [CompilerGeneratedAttribute]
internal void set_StartsCatchBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EndsCatchBlock();
    [CompilerGeneratedAttribute]
internal void set_EndsCatchBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_StartsFinallyBlock();
    [CompilerGeneratedAttribute]
internal void set_StartsFinallyBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EndsFinallyBlock();
    [CompilerGeneratedAttribute]
internal void set_EndsFinallyBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeclaresLocal();
    [CompilerGeneratedAttribute]
internal void set_DeclaresLocal(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<OpCode> get_IsInstruction();
    [CompilerGeneratedAttribute]
internal void set_IsInstruction(Nullable`1<OpCode> value);
    [CompilerGeneratedAttribute]
public Type get_MethodReturnType();
    [CompilerGeneratedAttribute]
internal void set_MethodReturnType(Type value);
    [CompilerGeneratedAttribute]
public LinqRoot`1<Type> get_MethodParameterTypes();
    [CompilerGeneratedAttribute]
internal void set_MethodParameterTypes(LinqRoot`1<Type> value);
    public bool TakesTypedReference();
    public bool TakesManagedPointer();
    internal bool TakesByRefArgs();
}
internal class Sigil.Impl.DeclareLocallDelegate : MulticastDelegate {
    public DeclareLocallDelegate(object object, IntPtr method);
    public virtual LocalBuilder Invoke(ILGenerator il);
    public virtual IAsyncResult BeginInvoke(ILGenerator il, AsyncCallback callback, object object);
    public virtual LocalBuilder EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.DefineLabelDelegate : MulticastDelegate {
    public DefineLabelDelegate(object object, IntPtr method);
    public virtual Label Invoke(ILGenerator il);
    public virtual IAsyncResult BeginInvoke(ILGenerator il, AsyncCallback callback, object object);
    public virtual Label EndInvoke(IAsyncResult result);
}
internal static class Sigil.Impl.ExtensionMethods : object {
    private static Dictionary`2<Type, Type> _AliasCache;
    private static ExtensionMethods();
    public static bool IsTailableCall(OpCode op);
    public static bool StartsWithVowel(string str);
    public static bool IsVolatile(FieldInfo field);
    public static bool IsPrefix(OpCode op);
    private static Type Alias(Type t);
    public static bool IsAssignableFrom(Type type1, Type type2);
    public static bool IsAssignableFrom(Type type1, TypeOnStack type2);
    public static bool IsAssignableFrom(TypeOnStack type1, TypeOnStack type2);
    private static LinqList`1<Type> GetBases(Type t);
    private static bool ReallyIsAssignableFrom(Type t1, Type t2);
}
internal interface Sigil.Impl.IGrouping`2 {
    public K Key { get; }
    public abstract virtual K get_Key();
}
internal class Sigil.Impl.InstructionAndTransitions : object {
    [CompilerGeneratedAttribute]
private LinqList`1<StackTransition> <Transitions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<OpCode> <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InstructionIndex>k__BackingField;
    public LinqList`1<StackTransition> Transitions { get; private set; }
    public Nullable`1<OpCode> Instruction { get; private set; }
    public Nullable`1<int> InstructionIndex { get; private set; }
    public InstructionAndTransitions(Nullable`1<OpCode> instr, Nullable`1<int> ix, LinqList`1<StackTransition> trans);
    [CompilerGeneratedAttribute]
public LinqList`1<StackTransition> get_Transitions();
    [CompilerGeneratedAttribute]
private void set_Transitions(LinqList`1<StackTransition> value);
    [CompilerGeneratedAttribute]
public Nullable`1<OpCode> get_Instruction();
    [CompilerGeneratedAttribute]
private void set_Instruction(Nullable`1<OpCode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InstructionIndex();
    [CompilerGeneratedAttribute]
private void set_InstructionIndex(Nullable`1<int> value);
    public virtual string ToString();
}
internal static class Sigil.Impl.InstructionSize : object {
    public static int Get(OpCode op, Label[] labels);
    public static int BeginCatchBlock();
    public static int EndCatchBlock();
    public static int BeginExceptionBlock();
    public static int EndExceptionBlock();
    public static int BeginFinallyBlock();
    public static int EndFinallyBlock();
    public static int DeclareLocal();
    public static int DefineLabel();
    public static int MarkLabel();
}
internal interface Sigil.Impl.IOwned {
    public object Owner { get; }
    public abstract virtual object get_Owner();
}
internal static class Sigil.Impl.LinqAlternative : object {
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Where>d__2`1")]
private static IEnumerable`1<T> _Where(IEnumerable`1<T> e, SigilFunc`2<T, bool> pred);
    public static LinqRoot`1<T> Where(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    public static int Count(IEnumerable`1<T> e);
    public static int Count(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    public static bool Any(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Select>d__7`2")]
public static IEnumerable`1<V> _Select(IEnumerable`1<T> e, SigilFunc`2<T, V> p);
    public static LinqRoot`1<V> Select(IEnumerable`1<T> e, SigilFunc`2<T, V> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Select>d__9`2")]
public static IEnumerable`1<V> _Select(IEnumerable`1<T> e, SigilFunc`3<T, int, V> p);
    public static LinqRoot`1<V> Select(IEnumerable`1<T> e, SigilFunc`3<T, int, V> p);
    public static LinqList`1<T> ToList(IEnumerable`1<T> e);
    public static T[] ToArray(IEnumerable`1<T> e);
    public static LinqDictionary`2<Key, Value> ToDictionary(IEnumerable`1<T> e, SigilFunc`2<T, Key> k, SigilFunc`2<T, Value> v);
    public static LinqRoot`1<T> AsEnumerable(LinqRoot`1<T> e);
    public static T FirstOrDefault(IEnumerable`1<T> e);
    public static T FirstOrDefault(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    public static T First(IEnumerable`1<T> e);
    public static T ElementAt(IEnumerable`1<T> e, int n);
    public static T Last(IEnumerable`1<T> e);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Reverse>d__20`1")]
private static IEnumerable`1<T> _Reverse(IEnumerable`1<T> e);
    public static LinqRoot`1<T> Reverse(IEnumerable`1<T> e);
    public static LinqRoot`1<T> Reverse(LinqRoot`1<T> e);
    public static LinqRoot`1<T> Reverse(LinqArray`1<T> e);
    public static bool All(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Skip>d__25`1")]
private static IEnumerable`1<T> _Skip(IEnumerable`1<T> e, int n);
    public static LinqRoot`1<T> Skip(IEnumerable`1<T> e, int n);
    public static T Single(IEnumerable`1<T> e);
    public static T SingleOrDefault(IEnumerable`1<T> e);
    public static T SingleOrDefault(IEnumerable`1<T> e, SigilFunc`2<T, bool> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Cast>d__30`1")]
private static IEnumerable`1<T> _Cast(IEnumerable e);
    public static LinqRoot`1<T> Cast(IEnumerable e);
    public static bool Contains(IEnumerable`1<T> e, T a);
    public static V Aggregate(IEnumerable`1<T> e, V seed, SigilFunc`3<V, T, V> a);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_SelectMany>d__34`2")]
private static IEnumerable`1<V> _SelectMany(IEnumerable`1<T> e, SigilFunc`2<T, IEnumerable`1<V>> p);
    public static LinqRoot`1<V> SelectMany(IEnumerable`1<T> e, SigilFunc`2<T, IEnumerable`1<V>> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_Distinct>d__36`1")]
private static IEnumerable`1<T> _Distinct(IEnumerable`1<T> e, IEqualityComparer`1<T> c);
    public static LinqRoot`1<T> Distinct(IEnumerable`1<T> e);
    public static LinqRoot`1<T> Distinct(IEnumerable`1<T> e, IEqualityComparer`1<T> c);
    public static LinqRoot`1<IGrouping`2<K, T>> GroupBy(IEnumerable`1<T> e, SigilFunc`2<T, K> p);
    [IteratorStateMachineAttribute("Sigil.Impl.LinqAlternative/<_QuickSort>d__40`2")]
private static IEnumerable`1<T> _QuickSort(T[] data, Int32[] ixs, V[] keys, IComparer`1<V> c);
    private static int _Partition(Int32[] ixs, V[] keys, int left, int right, int pivot, IComparer`1<V> c);
    private static IEnumerable`1<T> _Order(IEnumerable`1<T> e, SigilFunc`2<T, V> p, IComparer`1<V> c);
    public static LinqRoot`1<T> OrderBy(IEnumerable`1<T> e, SigilFunc`2<T, V> p);
    public static LinqRoot`1<T> OrderByDescending(IEnumerable`1<T> e, SigilFunc`2<T, V> p);
    public static void Each(IEnumerable`1<T> e, Action`1<T> a);
}
internal class Sigil.Impl.LinqArray`1 : LinqRoot`1<T> {
    private T[] Inner;
    private LinqArray`1(T[] i);
    public static LinqArray`1<T> op_Implicit(T[] t);
    protected virtual IEnumerable`1<T> InnerEnumerable();
}
[DefaultMemberAttribute("Item")]
internal class Sigil.Impl.LinqDictionary`2 : LinqRoot`1<KeyValuePair`2<K, V>> {
    private Dictionary`2<K, V> Inner;
    public V Item { get; public set; }
    public LinqRoot`1<K> Keys { get; }
    private LinqDictionary`2(Dictionary`2<K, V> d);
    public LinqDictionary`2(LinqDictionary`2<K, V> dict);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public LinqRoot`1<K> get_Keys();
    protected virtual IEnumerable`1<KeyValuePair`2<K, V>> InnerEnumerable();
    public bool Remove(K key);
    public bool ContainsKey(K key);
    public bool TryGetValue(K key, V& value);
    public void Add(K key, V value);
}
internal class Sigil.Impl.LinqEnumerable`1 : LinqRoot`1<T> {
    private IEnumerable`1<T> Inner;
    private LinqEnumerable`1(IEnumerable`1<T> i);
    protected virtual IEnumerable`1<T> InnerEnumerable();
    public static LinqEnumerable`1<T> For(IEnumerable`1<T> e);
    public static LinqEnumerable`1<T> For(LinqRoot`1<T> e);
}
internal class Sigil.Impl.LinqHashSet`1 : LinqRoot`1<T> {
    private Hashtable Inner;
    public int Count { get; }
    private LinqHashSet`1(Hashtable h);
    public LinqHashSet`1(IEqualityComparer`1<T> c);
    public LinqHashSet`1(IEnumerable`1<T> e);
    public int get_Count();
    [IteratorStateMachineAttribute("Sigil.Impl.LinqHashSet`1/<InnerEnumerable>d__8")]
protected virtual IEnumerable`1<T> InnerEnumerable();
    public void Add(T item);
    public bool Remove(T item);
    public bool Contains(T item);
}
[DefaultMemberAttribute("Item")]
internal class Sigil.Impl.LinqList`1 : LinqRoot`1<T> {
    private List`1<T> Inner;
    public T Item { get; public set; }
    public int Count { get; }
    private LinqList`1(List`1<T> l);
    public LinqList`1(int n);
    public LinqList`1(IEnumerable`1<T> e);
    public LinqList`1(LinqRoot`1<T> e);
    public T get_Item(int ix);
    public void set_Item(int ix, T value);
    public int get_Count();
    protected virtual IEnumerable`1<T> InnerEnumerable();
    public int IndexOf(T item);
    public void Add(T item);
    public void AddRange(IEnumerable`1<T> items);
    public void Insert(int ix, T item);
    public void RemoveAt(int ix);
    public void AddRange(LinqRoot`1<T> other);
    public bool Remove(T item);
    public void CopyTo(T[] arr);
}
internal abstract class Sigil.Impl.LinqRoot`1 : object {
    protected abstract virtual IEnumerable`1<T> InnerEnumerable();
    public LinqRoot`1<T> Where(SigilFunc`2<T, bool> p);
    public int Count();
    public int Count(SigilFunc`2<T, bool> p);
    public bool Any(SigilFunc`2<T, bool> p);
    public LinqRoot`1<V> Select(SigilFunc`2<T, V> p);
    public LinqRoot`1<V> Select(SigilFunc`3<T, int, V> p);
    public LinqList`1<T> ToList();
    public T[] ToArray();
    public LinqDictionary`2<Key, Value> ToDictionary(SigilFunc`2<T, Key> k, SigilFunc`2<T, Value> v);
    public IEnumerable`1<T> AsEnumerable();
    public T FirstOrDefault();
    public T FirstOrDefault(SigilFunc`2<T, bool> p);
    public T First();
    public T ElementAt(int n);
    public T Last();
    public LinqRoot`1<T> Reverse();
    public bool All(SigilFunc`2<T, bool> p);
    public LinqRoot`1<T> Skip(int n);
    public T Single();
    public T SingleOrDefault();
    public T SingleOrDefault(SigilFunc`2<T, bool> p);
    public LinqRoot`1<V> Cast();
    public bool Contains(T i);
    public V Aggregate(V seed, SigilFunc`3<V, T, V> p);
    public LinqRoot`1<V> SelectMany(SigilFunc`2<T, IEnumerable`1<V>> p);
    public LinqRoot`1<V> SelectMany(SigilFunc`2<T, LinqRoot`1<V>> p);
    public LinqRoot`1<T> Distinct();
    public LinqRoot`1<T> Distinct(IEqualityComparer`1<T> c);
    public LinqRoot`1<IGrouping`2<K, T>> GroupBy(SigilFunc`2<T, K> p);
    public LinqRoot`1<T> OrderBy(SigilFunc`2<T, V> p);
    public LinqRoot`1<T> OrderByDescending(SigilFunc`2<T, V> p);
    public void Each(Action`1<T> a);
}
internal class Sigil.Impl.LinqStack`1 : LinqRoot`1<T> {
    private Stack`1<T> Inner;
    private static LinqList`1<TypeOnStack> _PeekWildcard;
    public int Count { get; }
    private LinqStack`1(Stack`1<T> i);
    public LinqStack`1(IEnumerable`1<T> e);
    public LinqStack`1(int n);
    public LinqStack`1(LinqRoot`1<T> e);
    private static LinqStack`1();
    public int get_Count();
    protected virtual IEnumerable`1<T> InnerEnumerable();
    public T Pop();
    public void Push(T t);
    public T Peek();
    public void Clear();
    public LinqList`1[] Peek(bool baseless, int n);
}
internal class Sigil.Impl.LocalReusableDelegate : MulticastDelegate {
    public LocalReusableDelegate(object object, IntPtr method);
    public virtual void Invoke(Local local);
    public virtual IAsyncResult BeginInvoke(Local local, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.NativeIntType : object {
}
internal enum Sigil.Impl.NonGenericEmitType : Enum {
    public int value__;
    public static NonGenericEmitType DynamicMethod;
    public static NonGenericEmitType Method;
    public static NonGenericEmitType Constructor;
    public static NonGenericEmitType TypeInitializer;
}
internal class Sigil.Impl.NonGenericPlaceholderDelegate : MulticastDelegate {
    public NonGenericPlaceholderDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.NullType : object {
}
internal class Sigil.Impl.OnlyObjectType : object {
}
internal class Sigil.Impl.PopAllType : object {
}
internal class Sigil.Impl.PrefixTracker : object {
    [CompilerGeneratedAttribute]
private bool <HasUnaligned>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Unaligned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTailCall>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstrained>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Constrained>k__BackingField;
    public bool HasUnaligned { get; private set; }
    public Nullable`1<int> Unaligned { get; private set; }
    public bool HasVolatile { get; private set; }
    public bool HasReadOnly { get; private set; }
    public bool HasTailCall { get; private set; }
    public bool HasConstrained { get; private set; }
    public Type Constrained { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasUnaligned();
    [CompilerGeneratedAttribute]
private void set_HasUnaligned(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Unaligned();
    [CompilerGeneratedAttribute]
private void set_Unaligned(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_HasVolatile();
    [CompilerGeneratedAttribute]
private void set_HasVolatile(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasReadOnly();
    [CompilerGeneratedAttribute]
private void set_HasReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasTailCall();
    [CompilerGeneratedAttribute]
private void set_HasTailCall(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasConstrained();
    [CompilerGeneratedAttribute]
private void set_HasConstrained(bool value);
    [CompilerGeneratedAttribute]
public Type get_Constrained();
    [CompilerGeneratedAttribute]
private void set_Constrained(Type value);
    public void SetUnaligned(int a);
    public void SetVolatile();
    public void SetReadOnly();
    public void SetTailCall();
    public void SetConstrained(Type t);
    public void Clear();
    public PrefixTracker Clone();
}
internal class Sigil.Impl.ReturnTracer : object {
    private LinqList`1<SigilTuple`3<OpCode, Label, int>> Branches;
    private LinqDictionary`2<Label, int> Marks;
    private LinqList`1<int> Returns;
    private LinqList`1<int> Throws;
    private Dictionary`2<int, ReturnTracerResult> Cache;
    public ReturnTracer(LinqList`1<SigilTuple`3<OpCode, Label, int>> branches, LinqDictionary`2<Label, int> marks, LinqList`1<int> returns, LinqList`1<int> throws);
    private static bool IsUnconditionalBranch(OpCode op);
    private ReturnTracerResult TraceFrom(int startAt, LinqList`1<Label> path, LinqHashSet`1<Label> pathLookup);
    public ReturnTracerResult Verify();
}
internal class Sigil.Impl.ReturnTracerResult : object {
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqRoot`1<LinqRoot`1<Label>> <FailingPaths>k__BackingField;
    public bool IsSuccess { get; private set; }
    public LinqRoot`1<LinqRoot`1<Label>> FailingPaths { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
private void set_IsSuccess(bool value);
    [CompilerGeneratedAttribute]
public LinqRoot`1<LinqRoot`1<Label>> get_FailingPaths();
    [CompilerGeneratedAttribute]
private void set_FailingPaths(LinqRoot`1<LinqRoot`1<Label>> value);
    public static ReturnTracerResult Success();
    public static ReturnTracerResult Failure(LinqList`1<Label> path);
    public static ReturnTracerResult Combo(ReturnTracerResult[] other);
}
internal class Sigil.Impl.RollingVerifier : object {
    private LinqList`1<VerifiableTracker> CurrentlyInScope;
    private LinqList`1<LinqStack`1<LinqList`1<TypeOnStack>>> CurrentlyInScopeStacks;
    private LinqDictionary`2<Label, LinqList`1<VerifiableTracker>> RestoreOnMark;
    private LinqDictionary`2<Label, LinqList`1<LinqStack`1<LinqList`1<TypeOnStack>>>> RestoreStacksOnMark;
    private LinqDictionary`2<Label, LinqList`1<VerifiableTracker>> VerifyFromLabel;
    private LinqDictionary`2<Label, SigilTuple`2<bool, LinqStack`1<LinqList`1<TypeOnStack>>>> StacksAtLabels;
    private LinqDictionary`2<Label, LinqList`1<SigilTuple`2<bool, LinqStack`1<LinqList`1<TypeOnStack>>>>> ExpectedStacksAtLabels;
    private bool MarkCreatesNewVerifier;
    private bool UsesStrictBranchVerification;
    private LinqHashSet`1<Label> MustBeEmptyWhenBranchedTo;
    public RollingVerifier(Label beginAt, bool strictBranchVerification);
    private void EmptyCurrentScope();
    private void Add(VerifiableTracker tracker, LinqStack`1<LinqList`1<TypeOnStack>> stack);
    private void AddRange(LinqList`1<VerifiableTracker> trackers, LinqList`1<LinqStack`1<LinqList`1<TypeOnStack>>> stacks);
    private void RemoveAt(int ix);
    public virtual VerificationResult Mark(Label label);
    private void RemoveUnnecessaryVerifiers();
    public virtual VerificationResult ReThrow();
    public virtual VerificationResult Throw();
    public virtual VerificationResult Return();
    public virtual VerificationResult UnconditionalBranch(Label to);
    public virtual VerificationResult ConditionalBranch(Label[] toLabels);
    private SigilTuple`2<bool, LinqStack`1<LinqList`1<TypeOnStack>>> GetCurrentStack();
    private VerificationResult CheckStackMatches(Label atLabel);
    private VerificationResult CompareStacks(Label label, SigilTuple`2<bool, LinqStack`1<LinqList`1<TypeOnStack>>> actual, SigilTuple`2<bool, LinqStack`1<LinqList`1<TypeOnStack>>> expected);
    private void UpdateRestores(Label l);
    private VerificationResult VerifyBranchInto(Label to);
    private LinqStack`1<LinqList`1<TypeOnStack>> CopyStack(LinqStack`1<LinqList`1<TypeOnStack>> toCopy);
    public virtual VerificationResult Transition(InstructionAndTransitions legalTransitions);
    public virtual LinqStack`1<TypeOnStack> InferStack(int ofDepth);
    [CompilerGeneratedAttribute]
private LinqStack`1<LinqList`1<TypeOnStack>> <ConditionalBranch>b__21_1(LinqStack`1<LinqList`1<TypeOnStack>> s);
}
internal class Sigil.Impl.RollingVerifierWithoutVerification : RollingVerifier {
    public RollingVerifierWithoutVerification(Label beginAt);
    public virtual VerificationResult ConditionalBranch(Label[] toLabels);
    public virtual LinqStack`1<TypeOnStack> InferStack(int ofDepth);
    public virtual VerificationResult Mark(Label label);
    public virtual VerificationResult ReThrow();
    public virtual VerificationResult Return();
    public virtual VerificationResult Throw();
    public virtual VerificationResult Transition(InstructionAndTransitions legalTransitions);
    public virtual VerificationResult UnconditionalBranch(Label to);
}
internal class Sigil.Impl.SameByRefType : object {
}
internal class Sigil.Impl.SamePointerType : object {
}
internal class Sigil.Impl.SigilAction : MulticastDelegate {
    public SigilAction(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.SigilAction`3 : MulticastDelegate {
    public SigilAction`3(object object, IntPtr method);
    public virtual void Invoke(A a, B b, C c);
    public virtual IAsyncResult BeginInvoke(A a, B b, C c, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.SigilFunc`1 : MulticastDelegate {
    public SigilFunc`1(object object, IntPtr method);
    public virtual R Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.SigilFunc`2 : MulticastDelegate {
    public SigilFunc`2(object object, IntPtr method);
    public virtual R Invoke(A a);
    public virtual IAsyncResult BeginInvoke(A a, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.SigilFunc`3 : MulticastDelegate {
    public SigilFunc`3(object object, IntPtr method);
    public virtual R Invoke(A a, B b);
    public virtual IAsyncResult BeginInvoke(A a, B b, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal static class Sigil.Impl.SigilTuple : object {
    public static SigilTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static SigilTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static SigilTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
}
internal class Sigil.Impl.SigilTuple`2 : object {
    private T1 item1;
    private T2 item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public SigilTuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SigilTuple`2<T1, T2> obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Sigil.Impl.SigilTuple`3 : object {
    private T1 item1;
    private T2 item2;
    private T3 item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public SigilTuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SigilTuple`3<T1, T2, T3> obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Sigil.Impl.SigilTuple`4 : object {
    private T1 item1;
    private T2 item2;
    private T3 item3;
    private T4 item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public SigilTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SigilTuple`4<T1, T2, T3, T4> obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Sigil.Impl.StackTransition : object {
    [CompilerGeneratedAttribute]
private TypeOnStack[] <PoppedFromStack>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeOnStack[] <PushedToStack>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StackSizeMustBe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDuplicate>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationCallback <Before>k__BackingField;
    public int PoppedCount { get; }
    public TypeOnStack[] PoppedFromStack { get; private set; }
    public TypeOnStack[] PushedToStack { get; private set; }
    public Nullable`1<int> StackSizeMustBe { get; private set; }
    public bool IsDuplicate { get; private set; }
    public VerificationCallback Before { get; private set; }
    public StackTransition(IEnumerable`1<Type> popped, IEnumerable`1<Type> pushed, VerificationCallback before);
    public StackTransition(int sizeMustBe);
    public StackTransition(bool isDuplicate);
    public StackTransition(IEnumerable`1<TypeOnStack> popped, IEnumerable`1<TypeOnStack> pushed, VerificationCallback before);
    public int get_PoppedCount();
    [CompilerGeneratedAttribute]
public TypeOnStack[] get_PoppedFromStack();
    [CompilerGeneratedAttribute]
private void set_PoppedFromStack(TypeOnStack[] value);
    [CompilerGeneratedAttribute]
public TypeOnStack[] get_PushedToStack();
    [CompilerGeneratedAttribute]
private void set_PushedToStack(TypeOnStack[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StackSizeMustBe();
    [CompilerGeneratedAttribute]
private void set_StackSizeMustBe(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IsDuplicate();
    [CompilerGeneratedAttribute]
private void set_IsDuplicate(bool value);
    [CompilerGeneratedAttribute]
public VerificationCallback get_Before();
    [CompilerGeneratedAttribute]
private void set_Before(VerificationCallback value);
    public virtual string ToString();
    public static StackTransition[] None();
    public static StackTransition[] Push();
    public static StackTransition[] Push(Type pushType);
    public static StackTransition[] Push(TypeOnStack pushType);
    public static StackTransition[] Pop();
    public static StackTransition[] Pop(Type popType);
    public static StackTransition[] Pop(TypeOnStack popType);
}
internal class Sigil.Impl.TransitionWrapper : object {
    [CompilerGeneratedAttribute]
private LinqList`1<StackTransition> <Transitions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public LinqList`1<StackTransition> Transitions { get; private set; }
    public string MethodName { get; private set; }
    [CompilerGeneratedAttribute]
public LinqList`1<StackTransition> get_Transitions();
    [CompilerGeneratedAttribute]
private void set_Transitions(LinqList`1<StackTransition> value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
    public static TransitionWrapper Get(string name, IEnumerable`1<StackTransition> transitions);
}
internal static class Sigil.Impl.TypeHelpers : object {
    public static Type[] EmptyTypes;
    private static TypeHelpers();
    public static Type GetBaseType(Type type);
    public static bool IsValueType(Type type);
    public static bool ContainsGenericParameters(Type type);
    public static bool IsGenericType(Type type);
    public static bool IsEnum(Type type);
    public static bool IsPrimitive(Type type);
    public static bool IsInterface(Type type);
    public static MethodInfo GetMethod(Type type, string name, Type[] parameterTypes);
    public static Type AsType(TypeBuilder type);
    public static Module GetModule(Type type);
    public static bool IsAssignableFrom(Type x, Type y);
}
internal class Sigil.Impl.TypeOnStack : object {
    private static Dictionary`2<SigilTuple`4<CallingConventions, Type, Type, Type[]>, TypeOnStack> KnownFunctionPointerCache;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAttachedMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CallingConventions <CallingConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <InstanceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqHashSet`1<SigilTuple`2<InstructionAndTransitions, int>> <UsedBy>k__BackingField;
    public Type Type { get; private set; }
    public bool IsReference { get; }
    public bool IsPointer { get; }
    public bool IsArray { get; }
    public bool HasAttachedMethodInfo { get; private set; }
    public CallingConventions CallingConvention { get; private set; }
    public Type InstanceType { get; private set; }
    public Type ReturnType { get; private set; }
    public Type[] ParameterTypes { get; private set; }
    public bool IsMarkable { get; }
    public bool IsVoid { get; }
    internal LinqHashSet`1<SigilTuple`2<InstructionAndTransitions, int>> UsedBy { get; internal set; }
    private static TypeOnStack();
    public static bool op_Equality(TypeOnStack a, TypeOnStack b);
    public static bool op_Inequality(TypeOnStack a, TypeOnStack b);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public bool get_IsReference();
    public bool get_IsPointer();
    public bool get_IsArray();
    [CompilerGeneratedAttribute]
public bool get_HasAttachedMethodInfo();
    [CompilerGeneratedAttribute]
private void set_HasAttachedMethodInfo(bool value);
    [CompilerGeneratedAttribute]
public CallingConventions get_CallingConvention();
    [CompilerGeneratedAttribute]
private void set_CallingConvention(CallingConventions value);
    [CompilerGeneratedAttribute]
public Type get_InstanceType();
    [CompilerGeneratedAttribute]
private void set_InstanceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
    [CompilerGeneratedAttribute]
public Type[] get_ParameterTypes();
    [CompilerGeneratedAttribute]
private void set_ParameterTypes(Type[] value);
    public bool get_IsMarkable();
    public bool get_IsVoid();
    [CompilerGeneratedAttribute]
internal LinqHashSet`1<SigilTuple`2<InstructionAndTransitions, int>> get_UsedBy();
    [CompilerGeneratedAttribute]
internal void set_UsedBy(LinqHashSet`1<SigilTuple`2<InstructionAndTransitions, int>> value);
    public void Mark(InstructionAndTransitions instr, int index);
    public int CountMarks(OpCode code, int ix);
    public int CountMarks();
    public static TypeOnStack Get();
    public static TypeOnStack Get(Type type);
    public static TypeOnStack GetKnownFunctionPointer(CallingConventions conv, Type instanceType, Type returnType, Type[] parameterTypes);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsAssignableFrom(TypeOnStack other);
    public sealed virtual int CompareTo(object obj);
}
internal class Sigil.Impl.UpdateOpCodeDelegate : MulticastDelegate {
    public UpdateOpCodeDelegate(object object, IntPtr method);
    public virtual void Invoke(OpCode newOpcode);
    public virtual IAsyncResult BeginInvoke(OpCode newOpcode, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.VerifiableTracker : object {
    [CompilerGeneratedAttribute]
private Label <BeganAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBaseless>k__BackingField;
    private LinqList`1<InstructionAndTransitions> Transitions;
    private LinqDictionary`2<Label, int> MarkedLabelsAtTransitions;
    private LinqDictionary`2<Label, int> BranchesAtTransitions;
    private LinqStack`1<LinqList`1<TypeOnStack>> StartingStack;
    [CompilerGeneratedAttribute]
private bool <CanBePruned>k__BackingField;
    private LinqStack`1<LinqList`1<TypeOnStack>> CachedVerifyStack;
    private Nullable`1<int> CachedVerifyIndex;
    public int Iteration { get; }
    public Label BeganAt { get; private set; }
    public bool IsBaseless { get; private set; }
    public bool CanBePruned { get; private set; }
    public VerifiableTracker(Label beganAt, bool baseless, VerifiableTracker createdFrom, bool canBePruned);
    public int get_Iteration();
    [CompilerGeneratedAttribute]
public Label get_BeganAt();
    [CompilerGeneratedAttribute]
private void set_BeganAt(Label value);
    [CompilerGeneratedAttribute]
public bool get_IsBaseless();
    [CompilerGeneratedAttribute]
private void set_IsBaseless(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBePruned();
    [CompilerGeneratedAttribute]
private void set_CanBePruned(bool value);
    internal VerifiableTracker Concat(VerifiableTracker other);
    public VerificationResult Transition(InstructionAndTransitions legalTransitions);
    public Nullable`1<int> GetInstructionIndex(int ix);
    private static LinqStack`1<LinqList`1<TypeOnStack>> GetStack(VerifiableTracker tracker);
    private static void UpdateStack(LinqStack`1<LinqList`1<TypeOnStack>> stack, InstructionAndTransitions wrapped, bool isBaseless);
    private LinqList`1<StackTransition> GetLegalTransitions(LinqList`1<StackTransition> ops, LinqStack`1<LinqList`1<TypeOnStack>> runningStack);
    public VerificationResult CollapseAndVerify();
    private int FindStackFailureIndex(LinqStack`1<LinqList`1<TypeOnStack>> types, IEnumerable`1<StackTransition> ops, IEnumerable`1& expected);
    public VerifiableTracker Clone();
    public LinqStack`1<TypeOnStack> InferStack(int ofDepth);
    public virtual string ToString();
}
internal class Sigil.Impl.VerificationCallback : MulticastDelegate {
    public VerificationCallback(object object, IntPtr method);
    public virtual void Invoke(LinqStack`1<LinqList`1<TypeOnStack>> currentStack, bool isBaseless);
    public virtual IAsyncResult BeginInvoke(LinqStack`1<LinqList`1<TypeOnStack>> currentStack, bool isBaseless, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Sigil.Impl.VerificationResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqStack`1<LinqList`1<TypeOnStack>> <Stack>k__BackingField;
    [CompilerGeneratedAttribute]
private VerifiableTracker <Verifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStackUnderflow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExpectedStackSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStackMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqStack`1<LinqList`1<TypeOnStack>> <ExpectedStack>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqStack`1<LinqList`1<TypeOnStack>> <IncomingStack>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TransitionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StackIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqRoot`1<TypeOnStack> <ExpectedAtStackIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStackSizeFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private Label <InvolvingLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqRoot`1<TypeOnStack> <ExpectedOnStack>k__BackingField;
    [CompilerGeneratedAttribute]
private LinqRoot`1<TypeOnStack> <ActuallyOnStack>k__BackingField;
    public bool Success { get; private set; }
    public LinqStack`1<LinqList`1<TypeOnStack>> Stack { get; private set; }
    public int StackSize { get; }
    public VerifiableTracker Verifier { get; private set; }
    public bool IsStackUnderflow { get; private set; }
    public int ExpectedStackSize { get; private set; }
    public bool IsStackMismatch { get; private set; }
    public LinqStack`1<LinqList`1<TypeOnStack>> ExpectedStack { get; private set; }
    public LinqStack`1<LinqList`1<TypeOnStack>> IncomingStack { get; private set; }
    public bool IsTypeMismatch { get; private set; }
    public Nullable`1<int> TransitionIndex { get; private set; }
    public int StackIndex { get; private set; }
    public LinqRoot`1<TypeOnStack> ExpectedAtStackIndex { get; private set; }
    public bool IsStackSizeFailure { get; private set; }
    public Label InvolvingLabel { get; private set; }
    public LinqRoot`1<TypeOnStack> ExpectedOnStack { get; private set; }
    public LinqRoot`1<TypeOnStack> ActuallyOnStack { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    [CompilerGeneratedAttribute]
public LinqStack`1<LinqList`1<TypeOnStack>> get_Stack();
    [CompilerGeneratedAttribute]
private void set_Stack(LinqStack`1<LinqList`1<TypeOnStack>> value);
    public int get_StackSize();
    [CompilerGeneratedAttribute]
public VerifiableTracker get_Verifier();
    [CompilerGeneratedAttribute]
private void set_Verifier(VerifiableTracker value);
    [CompilerGeneratedAttribute]
public bool get_IsStackUnderflow();
    [CompilerGeneratedAttribute]
private void set_IsStackUnderflow(bool value);
    [CompilerGeneratedAttribute]
public int get_ExpectedStackSize();
    [CompilerGeneratedAttribute]
private void set_ExpectedStackSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IsStackMismatch();
    [CompilerGeneratedAttribute]
private void set_IsStackMismatch(bool value);
    [CompilerGeneratedAttribute]
public LinqStack`1<LinqList`1<TypeOnStack>> get_ExpectedStack();
    [CompilerGeneratedAttribute]
private void set_ExpectedStack(LinqStack`1<LinqList`1<TypeOnStack>> value);
    [CompilerGeneratedAttribute]
public LinqStack`1<LinqList`1<TypeOnStack>> get_IncomingStack();
    [CompilerGeneratedAttribute]
private void set_IncomingStack(LinqStack`1<LinqList`1<TypeOnStack>> value);
    [CompilerGeneratedAttribute]
public bool get_IsTypeMismatch();
    [CompilerGeneratedAttribute]
private void set_IsTypeMismatch(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TransitionIndex();
    [CompilerGeneratedAttribute]
private void set_TransitionIndex(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_StackIndex();
    [CompilerGeneratedAttribute]
private void set_StackIndex(int value);
    [CompilerGeneratedAttribute]
public LinqRoot`1<TypeOnStack> get_ExpectedAtStackIndex();
    [CompilerGeneratedAttribute]
private void set_ExpectedAtStackIndex(LinqRoot`1<TypeOnStack> value);
    [CompilerGeneratedAttribute]
public bool get_IsStackSizeFailure();
    [CompilerGeneratedAttribute]
private void set_IsStackSizeFailure(bool value);
    [CompilerGeneratedAttribute]
public Label get_InvolvingLabel();
    [CompilerGeneratedAttribute]
private void set_InvolvingLabel(Label value);
    [CompilerGeneratedAttribute]
public LinqRoot`1<TypeOnStack> get_ExpectedOnStack();
    [CompilerGeneratedAttribute]
private void set_ExpectedOnStack(LinqRoot`1<TypeOnStack> value);
    [CompilerGeneratedAttribute]
public LinqRoot`1<TypeOnStack> get_ActuallyOnStack();
    [CompilerGeneratedAttribute]
private void set_ActuallyOnStack(LinqRoot`1<TypeOnStack> value);
    public static VerificationResult Successful();
    public static VerificationResult Successful(VerifiableTracker verifier, LinqStack`1<LinqList`1<TypeOnStack>> stack);
    public static VerificationResult FailureUnderflow(Label involving, int expectedSize);
    public static VerificationResult FailureUnderflow(VerifiableTracker verifier, int transitionIndex, int expectedSize, LinqStack`1<LinqList`1<TypeOnStack>> stack);
    public static VerificationResult FailureStackMismatch(VerifiableTracker verifier, LinqStack`1<LinqList`1<TypeOnStack>> expected, LinqStack`1<LinqList`1<TypeOnStack>> incoming);
    public static VerificationResult FailureTypeMismatch(Label involving, LinqList`1<TypeOnStack> expected, LinqList`1<TypeOnStack> actual);
    public static VerificationResult FailureTypeMismatch(VerifiableTracker verifier, int transitionIndex, int stackIndex, IEnumerable`1<TypeOnStack> expectedTypes, LinqStack`1<LinqList`1<TypeOnStack>> stack);
    public static VerificationResult FailureStackSize(VerifiableTracker verifier, int transitionIndex, int expectedSize);
}
internal class Sigil.Impl.WildcardType : object {
}
public class Sigil.Label : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DefineLabelDelegate <LabelDel>k__BackingField;
    private object _Owner;
    public string Name { get; private set; }
    internal DefineLabelDelegate LabelDel { get; private set; }
    private object Sigil.Impl.IOwned.Owner { get; }
    internal Label(object owner, DefineLabelDelegate label, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
internal DefineLabelDelegate get_LabelDel();
    [CompilerGeneratedAttribute]
private void set_LabelDel(DefineLabelDelegate value);
    private sealed virtual override object Sigil.Impl.IOwned.get_Owner();
    internal void SetOwner(object owner);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Sigil.LabelLookup : object {
    private LinqDictionary`2<string, Label> InnerLookup;
    public Label Item { get; }
    public int Count { get; }
    private LinqRoot`1<string> _Names { get; }
    public IEnumerable`1<string> Names { get; }
    internal LabelLookup(LinqDictionary`2<string, Label> innerLookup);
    public Label get_Item(string name);
    public int get_Count();
    private LinqRoot`1<string> get__Names();
    public IEnumerable`1<string> get_Names();
}
public class Sigil.Local : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LocalType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeOnStack <StackType>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclareLocallDelegate <LocalDel>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalReusableDelegate <Reusable>k__BackingField;
    private object _Owner;
    [CompilerGeneratedAttribute]
private int <DeclaredAtIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReleasedAtIndex>k__BackingField;
    public string Name { get; private set; }
    public Type LocalType { get; private set; }
    internal TypeOnStack StackType { get; private set; }
    internal ushort Index { get; private set; }
    internal DeclareLocallDelegate LocalDel { get; private set; }
    internal LocalReusableDelegate Reusable { get; private set; }
    private object Sigil.Impl.IOwned.Owner { get; }
    internal int DeclaredAtIndex { get; private set; }
    internal Nullable`1<int> ReleasedAtIndex { get; private set; }
    internal Local(object owner, ushort index, Type localType, DeclareLocallDelegate local, string name, LocalReusableDelegate reusable, int declaredAt);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_LocalType();
    [CompilerGeneratedAttribute]
private void set_LocalType(Type value);
    [CompilerGeneratedAttribute]
internal TypeOnStack get_StackType();
    [CompilerGeneratedAttribute]
private void set_StackType(TypeOnStack value);
    [CompilerGeneratedAttribute]
internal ushort get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(ushort value);
    [CompilerGeneratedAttribute]
internal DeclareLocallDelegate get_LocalDel();
    [CompilerGeneratedAttribute]
private void set_LocalDel(DeclareLocallDelegate value);
    [CompilerGeneratedAttribute]
internal LocalReusableDelegate get_Reusable();
    [CompilerGeneratedAttribute]
private void set_Reusable(LocalReusableDelegate value);
    private sealed virtual override object Sigil.Impl.IOwned.get_Owner();
    [CompilerGeneratedAttribute]
internal int get_DeclaredAtIndex();
    [CompilerGeneratedAttribute]
private void set_DeclaredAtIndex(int value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_ReleasedAtIndex();
    [CompilerGeneratedAttribute]
private void set_ReleasedAtIndex(Nullable`1<int> value);
    internal void SetOwner(object owner);
    internal void SetReleasedAt(int index);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
public class Sigil.LocalLookup : object {
    private LinqDictionary`2<string, Local> InnerLookup;
    public Local Item { get; }
    public int Count { get; }
    private LinqRoot`1<string> _Names { get; }
    public IEnumerable`1<string> Names { get; }
    internal LocalLookup(LinqDictionary`2<string, Local> innerLookup);
    public Local get_Item(string name);
    public int get_Count();
    private LinqRoot`1<string> get__Names();
    public IEnumerable`1<string> get_Names();
}
public class Sigil.NonGeneric.Emit : object {
    private Emit`1<NonGenericPlaceholderDelegate> InnerEmit;
    private Module Module;
    private string Name;
    private Type ReturnType;
    private Type[] ParameterTypes;
    private Delegate CreatedDelegate;
    private MethodBuilder CreatedMethod;
    private ConstructorBuilder CreatedConstructor;
    private NonGenericEmitType EmitType;
    private TypeBuilder TypeBuilder;
    private MethodAttributes Attributes;
    private CallingConventions CallingConvention;
    private EmitShorthand Shorthand;
    public LabelLookup Labels { get; }
    public int MaxStackSize { get; }
    public LocalLookup Locals { get; }
    public bool AllowsUnverifiableCIL { get; }
    private Emit(Emit`1<NonGenericPlaceholderDelegate> innerEmit, NonGenericEmitType type);
    public Emit ArgumentList();
    public Emit Add();
    public Emit AddOverflow();
    public Emit UnsignedAddOverflow();
    public Emit Divide();
    public Emit UnsignedDivide();
    public Emit Multiply();
    public Emit MultiplyOverflow();
    public Emit UnsignedMultiplyOverflow();
    public Emit Remainder();
    public Emit UnsignedRemainder();
    public Emit Subtract();
    public Emit SubtractOverflow();
    public Emit UnsignedSubtractOverflow();
    public Emit Negate();
    public Emit And();
    public Emit Or();
    public Emit Xor();
    public Emit Not();
    public Emit ShiftLeft();
    public Emit ShiftRight();
    public Emit UnsignedShiftRight();
    public Emit Box();
    public Emit Box(Type valueType);
    public Emit Branch(Label label);
    public Emit Branch(string name);
    public Emit BranchIfEqual(Label label);
    public Emit BranchIfEqual(string name);
    public Emit UnsignedBranchIfNotEqual(Label label);
    public Emit UnsignedBranchIfNotEqual(string name);
    public Emit BranchIfGreaterOrEqual(Label label);
    public Emit BranchIfGreaterOrEqual(string name);
    public Emit UnsignedBranchIfGreaterOrEqual(Label label);
    public Emit UnsignedBranchIfGreaterOrEqual(string name);
    public Emit BranchIfGreater(Label label);
    public Emit BranchIfGreater(string name);
    public Emit UnsignedBranchIfGreater(Label label);
    public Emit UnsignedBranchIfGreater(string name);
    public Emit BranchIfLessOrEqual(Label label);
    public Emit BranchIfLessOrEqual(string name);
    public Emit UnsignedBranchIfLessOrEqual(Label label);
    public Emit UnsignedBranchIfLessOrEqual(string name);
    public Emit BranchIfLess(Label label);
    public Emit BranchIfLess(string name);
    public Emit UnsignedBranchIfLess(Label label);
    public Emit UnsignedBranchIfLess(string name);
    public Emit BranchIfFalse(Label label);
    public Emit BranchIfFalse(string name);
    public Emit BranchIfTrue(Label label);
    public Emit BranchIfTrue(string name);
    public Emit Break();
    public Emit Call(MethodInfo method, Type[] arglist);
    public Emit Call(ConstructorInfo constructor);
    public Emit Call(Emit emit, Type[] arglist);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    [ExcludeFromCodeCoverageAttribute]
public Emit CallIndirect(CallingConventions callConventions);
    public Emit CallIndirect(CallingConventions callConventions, Type returnType, Type[] parameterTypes, Type[] arglist);
    public Emit CallIndirect(CallingConventions callConventions, Type returnType, Type[] parameterTypes);
    public Emit CallVirtual(MethodInfo method, Type constrained, Type[] arglist);
    public Emit CastClass();
    public Emit CastClass(Type referenceType);
    public Emit CheckFinite();
    public Emit CompareEqual();
    public Emit CompareGreaterThan();
    public Emit UnsignedCompareGreaterThan();
    public Emit CompareLessThan();
    public Emit UnsignedCompareLessThan();
    public Emit Convert();
    public Emit Convert(Type primitiveType);
    public Emit ConvertOverflow();
    public Emit ConvertOverflow(Type primitiveType);
    public Emit UnsignedConvertOverflow();
    public Emit UnsignedConvertOverflow(Type primitiveType);
    public Emit UnsignedConvertToFloat();
    public Emit CopyBlock(bool isVolatile, Nullable`1<int> unaligned);
    public Emit CopyObject();
    public Emit CopyObject(Type valueType);
    public LabelLookup get_Labels();
    public int get_MaxStackSize();
    public LocalLookup get_Locals();
    public bool get_AllowsUnverifiableCIL();
    private static void ValidateReturnAndParameterTypes(Type returnType, Type[] parameterTypes);
    public static Emit NewDynamicMethod(Type returnType, Type[] parameterTypes, string name, ModuleBuilder module, bool doVerify, bool strictBranchVerification);
    private void ValidateDelegateType(Type delegateType);
    public Delegate CreateDelegate(Type delegateType, String& instructions, OptimizationOptions optimizationOptions);
    public Delegate CreateDelegate(Type delegateType, OptimizationOptions optimizationOptions);
    public DelegateType CreateDelegate(String& instructions, OptimizationOptions optimizationOptions);
    public DelegateType CreateDelegate(OptimizationOptions optimizationOptions);
    private static bool HasFlag(CallingConventions value, CallingConventions flag);
    public static Emit BuildMethod(Type returnType, Type[] parameterTypes, TypeBuilder type, string name, MethodAttributes attributes, CallingConventions callingConvention, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public static Emit BuildInstanceMethod(Type returnType, Type[] parameterTypes, TypeBuilder type, string name, MethodAttributes attributes, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public static Emit BuildStaticMethod(Type returnType, Type[] parameterTypes, TypeBuilder type, string name, MethodAttributes attributes, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public MethodBuilder CreateMethod(String& instructions, OptimizationOptions optimizationOptions);
    public MethodBuilder CreateMethod(OptimizationOptions optimizationOptions);
    public static Emit BuildConstructor(Type[] parameterTypes, TypeBuilder type, MethodAttributes attributes, CallingConventions callingConvention, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public static Emit BuildTypeInitializer(TypeBuilder type, bool allowUnverifiableCode, bool doVerify, bool strictBranchVerification);
    public ConstructorBuilder CreateConstructor(String& instructions, OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateConstructor(OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateTypeInitializer(String& instructions, OptimizationOptions optimizationOptions);
    public ConstructorBuilder CreateTypeInitializer(OptimizationOptions optimizationOptions);
    public string Instructions();
    public EmitShorthand AsShorthand();
    public Emit Duplicate();
    public Emit InitializeBlock(bool isVolatile, Nullable`1<int> unaligned);
    public Emit InitializeObject();
    public Emit InitializeObject(Type valueType);
    public Emit IsInstance();
    public Emit IsInstance(Type type);
    public Emit Jump(MethodInfo method);
    public Label DefineLabel(string name);
    public Emit DefineLabel(Label& label, string name);
    public Emit MarkLabel(Label label);
    public Emit MarkLabel(string name);
    public Emit Leave(Label label);
    public Emit Leave(string name);
    public Emit LoadArgument(ushort index);
    public Emit LoadArgumentAddress(ushort index);
    public Emit LoadConstant(bool b);
    public Emit LoadConstant(int i);
    public Emit LoadConstant(UInt32 i);
    public Emit LoadConstant(long l);
    public Emit LoadConstant(ulong l);
    public Emit LoadConstant(float f);
    public Emit LoadConstant(double d);
    public Emit LoadConstant(string str);
    public Emit LoadConstant(FieldInfo field);
    public Emit LoadConstant(MethodInfo method);
    public Emit LoadConstant();
    public Emit LoadConstant(Type type);
    public Emit LoadNull();
    public Emit LoadElement();
    public Emit LoadElement(Type elementType);
    public Emit LoadElementAddress();
    public Emit LoadElementAddress(Type elementType);
    public Emit LoadField(FieldInfo field, Nullable`1<bool> isVolatile, Nullable`1<int> unaligned);
    public Emit LoadFieldAddress(FieldInfo field);
    public Emit LoadFunctionPointer(MethodInfo method);
    public Emit LoadFunctionPointer(MethodBuilder method, Type[] parameterTypes);
    public Emit LoadIndirect(bool isVolatile, Nullable`1<int> unaligned);
    public Emit LoadIndirect(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public Emit LoadLength();
    public Emit LoadLength(Type elementType);
    public Emit LoadLocal(Local local);
    public Emit LoadLocal(string name);
    public Emit LoadLocalAddress(Local local);
    public Emit LoadLocalAddress(string name);
    public Emit LoadObject(bool isVolatile, Nullable`1<int> unaligned);
    public Emit LoadObject(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public Emit LoadVirtualFunctionPointer(MethodInfo method);
    public Emit LoadVirtualFunctionPointer(MethodBuilder method, Type[] parameterTypes);
    public Emit LocalAllocate();
    public Local DeclareLocal(string name);
    public Local DeclareLocal(Type type, string name);
    public Emit DeclareLocal(Local& local, string name);
    public Emit DeclareLocal(Type type, Local& local, string name);
    public Emit MakeReferenceAny();
    public Emit MakeReferenceAny(Type type);
    public Emit NewArray();
    public Emit NewArray(Type elementType);
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    [ExcludeFromCodeCoverageAttribute]
public Emit NewObject();
    public Emit NewObject(Type type, Type[] parameterTypes);
    public Emit NewObject(ConstructorInfo constructor);
    public Emit NewObject(ConstructorBuilder constructor, Type[] parameterTypes);
    public Emit Nop();
    public Emit Pop();
    public Emit ReferenceAnyType();
    public Emit ReferenceAnyValue();
    public Emit ReferenceAnyValue(Type type);
    public Emit ReThrow();
    public Emit Return();
    public Emit SizeOf();
    public Emit SizeOf(Type valueType);
    public Emit StoreArgument(ushort index);
    public Emit StoreElement();
    public Emit StoreElement(Type elementType);
    public Emit StoreField(FieldInfo field, bool isVolatile, Nullable`1<int> unaligned);
    public Emit StoreIndirect(bool isVolatile, Nullable`1<int> unaligned);
    public Emit StoreIndirect(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public Emit StoreLocal(Local local);
    public Emit StoreLocal(string name);
    public Emit StoreObject(bool isVolatile, Nullable`1<int> unaligned);
    public Emit StoreObject(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public Emit Switch(Label[] labels);
    public Emit Switch(String[] names);
    public Emit Throw();
    public ExceptionBlock BeginExceptionBlock();
    public Emit BeginExceptionBlock(ExceptionBlock& forTry);
    public Emit EndExceptionBlock(ExceptionBlock forTry);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry);
    public Emit BeginCatchBlock(ExceptionBlock forTry, CatchBlock& forCatch);
    public CatchBlock BeginCatchAllBlock(ExceptionBlock forTry);
    public Emit BeginCatchAllBlock(ExceptionBlock forTry, CatchBlock& forCatch);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry, Type exceptionType);
    public Emit BeginCatchBlock(ExceptionBlock forTry, Type exceptionType, CatchBlock& forCatch);
    public Emit EndCatchBlock(CatchBlock forCatch);
    public Emit BeginFinallyBlock(ExceptionBlock forTry, FinallyBlock& forFinally);
    public FinallyBlock BeginFinallyBlock(ExceptionBlock forTry);
    public Emit EndFinallyBlock(FinallyBlock forFinally);
    public Emit Unbox();
    public Emit Unbox(Type valueType);
    public Emit UnboxAny();
    public Emit UnboxAny(Type valueType);
    public Emit WriteLine(string line, Local[] locals);
}
public class Sigil.NonGeneric.EmitShorthand : object {
    private Emit InnerEmit;
    public bool AllowsUnverifiableCIL { get; }
    public int MaxStackSize { get; }
    public LocalLookup Locals { get; }
    public LabelLookup Labels { get; }
    internal EmitShorthand(Emit inner);
    public bool get_AllowsUnverifiableCIL();
    public int get_MaxStackSize();
    public LocalLookup get_Locals();
    public LabelLookup get_Labels();
    public Emit AsLonghand();
    public string Instructions();
    public Local DeclareLocal(string name);
    public EmitShorthand DeclareLocal(Local& local, string name);
    public Local DeclareLocal(Type type, string name);
    public EmitShorthand DeclareLocal(Type type, Local& local, string name);
    public Label DefineLabel(string name);
    public EmitShorthand DefineLabel(Label& label, string name);
    public EmitShorthand MarkLabel(Label label);
    public EmitShorthand MarkLabel(string name);
    public ExceptionBlock BeginExceptionBlock();
    public EmitShorthand BeginExceptionBlock(ExceptionBlock& forTry);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry);
    public EmitShorthand BeginCatchBlock(ExceptionBlock forTry, CatchBlock& tryCatch);
    public CatchBlock BeginCatchBlock(ExceptionBlock forTry, Type exceptionType);
    public EmitShorthand BeginCatchBlock(ExceptionBlock forTry, Type exceptionType, CatchBlock& forCatch);
    public EmitShorthand EndCatchBlock(CatchBlock forCatch);
    public FinallyBlock BeginFinallyBlock(ExceptionBlock forTry);
    public EmitShorthand BeginFinallyBlock(ExceptionBlock forTry, FinallyBlock& forFinally);
    public EmitShorthand EndFinallyBlock(FinallyBlock forFinally);
    public EmitShorthand EndExceptionBlock(ExceptionBlock forTry);
    public object CreateDelegate(Type delegateType, OptimizationOptions optimizationOptions);
    public DelegateType CreateDelegate(OptimizationOptions optimizationOptions);
    public MethodBuilder CreateMethod();
    public ConstructorBuilder CreateConstructor();
    public EmitShorthand Add();
    public EmitShorthand Add_Ovf();
    public EmitShorthand Add_Ovf_Un();
    public EmitShorthand And();
    public EmitShorthand Beq(Label label);
    public EmitShorthand Beq(string name);
    public EmitShorthand Bge(Label label);
    public EmitShorthand Bge(string name);
    public EmitShorthand Bge_Un(Label label);
    public EmitShorthand Bge_Un(string name);
    public EmitShorthand Bgt(Label label);
    public EmitShorthand Bgt(string name);
    public EmitShorthand Bgt_Un(Label label);
    public EmitShorthand Bgt_Un(string name);
    public EmitShorthand Ble(Label label);
    public EmitShorthand Ble(string name);
    public EmitShorthand Ble_Un(Label label);
    public EmitShorthand Ble_Un(string name);
    public EmitShorthand Blt(Label label);
    public EmitShorthand Blt(string name);
    public EmitShorthand Blt_Un(Label label);
    public EmitShorthand Blt_Un(string name);
    public EmitShorthand Bne_Un(Label label);
    public EmitShorthand Bne_Un(string name);
    public EmitShorthand Box();
    public EmitShorthand Box(Type valueType);
    public EmitShorthand Br(Label label);
    public EmitShorthand Br(string name);
    public EmitShorthand Break();
    public EmitShorthand Brfalse(Label label);
    public EmitShorthand Brfalse(string name);
    public EmitShorthand Brtrue(Label label);
    public EmitShorthand Brtrue(string name);
    public EmitShorthand Call(MethodInfo method);
    public EmitShorthand Calli(CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public EmitShorthand Callvirt(MethodInfo method, Type constrained);
    public EmitShorthand Castclass();
    public EmitShorthand Castclass(Type referenceType);
    public EmitShorthand Ceq();
    public EmitShorthand Cgt();
    public EmitShorthand Cgt_Un();
    public EmitShorthand Ckfinite();
    public EmitShorthand Clt();
    public EmitShorthand Clt_Un();
    public EmitShorthand Conv_Ovf_Un();
    public EmitShorthand Conv_Ovf_Un(Type primitiveType);
    public EmitShorthand Conv_R_Un();
    public EmitShorthand Conv();
    public EmitShorthand Conv(Type primitiveType);
    public EmitShorthand Conv_Ovf();
    public EmitShorthand Conv_Ovf(Type primitiveType);
    public EmitShorthand Cpblk(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Cpobj();
    public EmitShorthand Cpobj(Type valueType);
    public EmitShorthand Div();
    public EmitShorthand Div_Un();
    public EmitShorthand Dup();
    public EmitShorthand Initblk(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Initobj();
    public EmitShorthand Initobj(Type valueType);
    public EmitShorthand Isinst();
    public EmitShorthand Isinst(Type type);
    public EmitShorthand Jmp(MethodInfo method);
    public EmitShorthand Ldarg(ushort index);
    public EmitShorthand Ldarga(ushort index);
    public EmitShorthand Ldc(bool b);
    public EmitShorthand Ldc(float f);
    public EmitShorthand Ldc(double d);
    public EmitShorthand Ldc(UInt32 u);
    public EmitShorthand Ldc(int i);
    public EmitShorthand Ldc(long l);
    public EmitShorthand Ldc(ulong u);
    public EmitShorthand Ldelem();
    public EmitShorthand Ldelem(Type elementType);
    public EmitShorthand Ldelema();
    public EmitShorthand Ldelema(Type elementType);
    public EmitShorthand Ldfld(FieldInfo field, Nullable`1<bool> isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Ldflda(FieldInfo field);
    public EmitShorthand Ldftn(MethodInfo method);
    public EmitShorthand Ldind(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Ldind(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Ldlen();
    public EmitShorthand Ldlen(Type elementType);
    public EmitShorthand Ldloc(Local local);
    public EmitShorthand Ldloc(string name);
    public EmitShorthand Ldloca(Local local);
    public EmitShorthand Ldloca(string name);
    public EmitShorthand Ldnull();
    public EmitShorthand Ldobj(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Ldobj(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Ldstr(string str);
    public EmitShorthand Ldtoken(FieldInfo field);
    public EmitShorthand Ldtoken(MethodInfo method);
    public EmitShorthand Ldtoken();
    public EmitShorthand Ldtoken(Type type);
    public EmitShorthand Ldvirtftn(MethodInfo method);
    public EmitShorthand Leave(Label label);
    public EmitShorthand Leave(string name);
    public EmitShorthand Localloc();
    public EmitShorthand Mul();
    public EmitShorthand Mul_Ovf();
    public EmitShorthand Mul_Ovf_Un();
    public EmitShorthand Neg();
    public EmitShorthand Newarr();
    public EmitShorthand Newarr(Type elementType);
    public EmitShorthand Newobj(ConstructorInfo constructor);
    public EmitShorthand Nop();
    public EmitShorthand Not();
    public EmitShorthand Or();
    public EmitShorthand Pop();
    public EmitShorthand Rem();
    public EmitShorthand Rem_Un();
    public EmitShorthand Ret();
    public EmitShorthand Rethrow();
    public EmitShorthand Shl();
    public EmitShorthand Shr();
    public EmitShorthand Shr_Un();
    public EmitShorthand Sizeof();
    public EmitShorthand Sizeof(Type valueType);
    public EmitShorthand Starg(ushort index);
    public EmitShorthand Stelem();
    public EmitShorthand Stelem(Type elementType);
    public EmitShorthand Stfld(FieldInfo field, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Stind(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Stind(Type type, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Stloc(Local local);
    public EmitShorthand Stloc(string name);
    public EmitShorthand Stobj(bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Stobj(Type valueType, bool isVolatile, Nullable`1<int> unaligned);
    public EmitShorthand Sub();
    public EmitShorthand Sub_Ovf();
    public EmitShorthand Sub_Ovf_Un();
    public EmitShorthand Switch(Label[] labels);
    public EmitShorthand Switch(String[] names);
    public EmitShorthand Throw();
    public EmitShorthand Unbox();
    public EmitShorthand Unbox(Type valueType);
    public EmitShorthand Unbox_Any();
    public EmitShorthand Unbox_Any(Type valueType);
    public EmitShorthand WriteLine(string line, Local[] locals);
    public EmitShorthand Xor();
}
public class Sigil.Operation`1 : object {
    [CompilerGeneratedAttribute]
private OpCode <OpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<object> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExceptionBlockStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExceptionBlockEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCatchBlockStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCatchBlockEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinallyBlockStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinallyBlockEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarkLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LabelName>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Emit`1<DelegateType>> <Replay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private PrefixTracker <Prefixes>k__BackingField;
    public OpCode OpCode { get; internal set; }
    public IEnumerable`1<object> Parameters { get; internal set; }
    public bool IsExceptionBlockStart { get; internal set; }
    public bool IsExceptionBlockEnd { get; internal set; }
    public bool IsCatchBlockStart { get; internal set; }
    public bool IsCatchBlockEnd { get; internal set; }
    public bool IsFinallyBlockStart { get; internal set; }
    public bool IsFinallyBlockEnd { get; internal set; }
    public bool IsMarkLabel { get; internal set; }
    public string LabelName { get; internal set; }
    public bool IsOpCode { get; }
    internal Action`1<Emit`1<DelegateType>> Replay { get; internal set; }
    internal bool IsIgnored { get; internal set; }
    internal PrefixTracker Prefixes { get; internal set; }
    [CompilerGeneratedAttribute]
public OpCode get_OpCode();
    [CompilerGeneratedAttribute]
internal void set_OpCode(OpCode value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<object> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IEnumerable`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_IsExceptionBlockStart();
    [CompilerGeneratedAttribute]
internal void set_IsExceptionBlockStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExceptionBlockEnd();
    [CompilerGeneratedAttribute]
internal void set_IsExceptionBlockEnd(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCatchBlockStart();
    [CompilerGeneratedAttribute]
internal void set_IsCatchBlockStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCatchBlockEnd();
    [CompilerGeneratedAttribute]
internal void set_IsCatchBlockEnd(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFinallyBlockStart();
    [CompilerGeneratedAttribute]
internal void set_IsFinallyBlockStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFinallyBlockEnd();
    [CompilerGeneratedAttribute]
internal void set_IsFinallyBlockEnd(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMarkLabel();
    [CompilerGeneratedAttribute]
internal void set_IsMarkLabel(bool value);
    [CompilerGeneratedAttribute]
public string get_LabelName();
    [CompilerGeneratedAttribute]
internal void set_LabelName(string value);
    public bool get_IsOpCode();
    [CompilerGeneratedAttribute]
internal Action`1<Emit`1<DelegateType>> get_Replay();
    [CompilerGeneratedAttribute]
internal void set_Replay(Action`1<Emit`1<DelegateType>> value);
    [CompilerGeneratedAttribute]
internal bool get_IsIgnored();
    [CompilerGeneratedAttribute]
internal void set_IsIgnored(bool value);
    [CompilerGeneratedAttribute]
internal PrefixTracker get_Prefixes();
    [CompilerGeneratedAttribute]
internal void set_Prefixes(PrefixTracker value);
    public virtual string ToString();
    internal void Apply(Emit`1<DelegateType> emit);
}
public class Sigil.OperationResultUsage`1 : object {
    [CompilerGeneratedAttribute]
private Operation`1<DelegateType> <ProducesResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Operation`1<DelegateType>> <ResultUsedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeOnStack> <TypesProduced>k__BackingField;
    public Operation`1<DelegateType> ProducesResult { get; private set; }
    public IEnumerable`1<Operation`1<DelegateType>> ResultUsedBy { get; private set; }
    internal IEnumerable`1<TypeOnStack> TypesProduced { get; private set; }
    internal OperationResultUsage`1(Operation`1<DelegateType> producer, IEnumerable`1<Operation`1<DelegateType>> users, IEnumerable`1<TypeOnStack> typesProduced);
    [CompilerGeneratedAttribute]
public Operation`1<DelegateType> get_ProducesResult();
    [CompilerGeneratedAttribute]
private void set_ProducesResult(Operation`1<DelegateType> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Operation`1<DelegateType>> get_ResultUsedBy();
    [CompilerGeneratedAttribute]
private void set_ResultUsedBy(IEnumerable`1<Operation`1<DelegateType>> value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<TypeOnStack> get_TypesProduced();
    [CompilerGeneratedAttribute]
private void set_TypesProduced(IEnumerable`1<TypeOnStack> value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Sigil.OptimizationOptions : Enum {
    public int value__;
    public static OptimizationOptions None;
    public static OptimizationOptions EnableBranchPatching;
    public static OptimizationOptions EnableTrivialCastEliding;
    public static OptimizationOptions All;
}
public class Sigil.Parameter : object {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    public int Position { get; private set; }
    public Type ParameterType { get; private set; }
    internal Parameter(int pos, Type type);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
private void set_ParameterType(Type value);
    internal static Parameter For(ParameterInfo p);
    public virtual string ToString();
}
public class Sigil.SigilVerificationException : Exception {
    private String[] Instructions;
    private VerificationResult VerificationFailure;
    private ReturnTracerResult ReturnFailure;
    internal SigilVerificationException(string message, ReturnTracerResult failure, String[] instructions);
    internal SigilVerificationException(string method, VerificationResult failure, String[] instructions);
    internal SigilVerificationException(string message, String[] instructions);
    private static string GetMessage(string method, VerificationResult failure);
    private static string ErrorMessageString(LinqRoot`1<TypeOnStack> types);
    public string GetDebugInfo();
    private static void PrintStack(LinqStack`1<LinqList`1<TypeOnStack>> stack, StringBuilder sb, string mark, Nullable`1<int> markAt);
    [ExcludeFromCodeCoverageAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [ExcludeFromCodeCoverageAttribute]
public virtual string ToString();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.0.25.34678")]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
