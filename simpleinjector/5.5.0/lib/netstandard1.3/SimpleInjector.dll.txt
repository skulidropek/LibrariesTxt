[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.ActivationException : Exception {
    public ActivationException(string message);
    public ActivationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SimpleInjector.Advanced.AdvancedExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Please use the Container.IsLocked property instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static bool IsLocked(Container container);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.IsVerifying instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static bool IsVerifying(Container container);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.ContainerScope.GetItem instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static object GetItem(Container container, object key);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.ContainerScope.SetItem instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void SetItem(Container container, object key, object item);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.ContainerScope.GetOrSetItem instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static T GetOrSetItem(Container container, object key, Func`3<Container, object, T> valueFactory);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.Collection.Append instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void AppendToCollection(Container container, Type serviceType, Registration registration);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Container.Collection.Append instead. Will be removed in version 6.0.", "True")]
public static void AppendToCollection(Container container, Type serviceType, Type implementationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SimpleInjector.Advanced.ApiObject : object {
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public Type GetType();
}
[DebuggerDisplayAttribute("DefaultConstructorResolutionBehavior")]
internal class SimpleInjector.Advanced.DefaultConstructorResolutionBehavior : object {
    [NullableContextAttribute("2")]
public sealed virtual ConstructorInfo TryGetConstructor(Type implementationType, String& errorMessage);
    [NullableContextAttribute("1")]
private static void VerifyTypeIsConcrete(Type implementationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("DefaultDependencyInjectionBehavior")]
internal class SimpleInjector.Advanced.DefaultDependencyInjectionBehavior : object {
    private Container container;
    internal DefaultDependencyInjectionBehavior(Container container);
    public sealed virtual bool VerifyDependency(InjectionConsumerInfo dependency, String& errorMessage);
    public sealed virtual InstanceProducer GetInstanceProducer(InjectionConsumerInfo dependency, bool throwOnFailure);
    private static bool HasValueTypeSemantics(Type targetType);
}
internal class SimpleInjector.Advanced.DefaultExpressionCompilationBehavior : object {
    [NullableContextAttribute("1")]
public sealed virtual Delegate Compile(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Lifestyle.Name,nq}LifestyleSelectionBehavior")]
internal class SimpleInjector.Advanced.DefaultLifestyleSelectionBehavior : object {
    private ContainerOptions options;
    internal DefaultLifestyleSelectionBehavior(ContainerOptions options);
    public sealed virtual Lifestyle SelectLifestyle(Type implementationType);
}
[DebuggerDisplayAttribute("DefaultPropertySelectionBehavior")]
internal class SimpleInjector.Advanced.DefaultPropertySelectionBehavior : object {
    [NullableContextAttribute("1")]
public sealed virtual bool SelectProperty(Type implementationType, PropertyInfo propertyInfo);
}
[NullableContextAttribute("2")]
public interface SimpleInjector.Advanced.IConstructorResolutionBehavior {
    public abstract virtual ConstructorInfo TryGetConstructor(Type implementationType, String& errorMessage);
}
[NullableContextAttribute("1")]
public interface SimpleInjector.Advanced.IDependencyInjectionBehavior {
    public abstract virtual bool VerifyDependency(InjectionConsumerInfo dependency, String& errorMessage);
    public abstract virtual InstanceProducer GetInstanceProducer(InjectionConsumerInfo dependency, bool throwOnFailure);
}
[NullableContextAttribute("1")]
public interface SimpleInjector.Advanced.IExpressionCompilationBehavior {
    public abstract virtual Delegate Compile(Expression expression);
}
[NullableContextAttribute("1")]
public interface SimpleInjector.Advanced.ILifestyleSelectionBehavior {
    public abstract virtual Lifestyle SelectLifestyle(Type implementationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("InitializationContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.Advanced.InitializationContext : object {
    [CompilerGeneratedAttribute]
private InstanceProducer <Producer>k__BackingField;
    [CompilerGeneratedAttribute]
private Registration <Registration>k__BackingField;
    public InstanceProducer Producer { get; }
    public Registration Registration { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal InitializationContext(InstanceProducer producer, Registration registration);
    [CompilerGeneratedAttribute]
public InstanceProducer get_Producer();
    [CompilerGeneratedAttribute]
public Registration get_Registration();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("InitializerContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.Advanced.InitializerContext : object {
    [CompilerGeneratedAttribute]
private Registration <Registration>k__BackingField;
    public Registration Registration { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal InitializerContext(Registration registration);
    [CompilerGeneratedAttribute]
public Registration get_Registration();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("InstanceInitializationData ({DebuggerDisplay, nq})")]
public class SimpleInjector.Advanced.InstanceInitializationData : ValueType {
    [CompilerGeneratedAttribute]
private InitializerContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public InitializerContext Context { get; }
    public object Instance { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    public InstanceInitializationData(InitializerContext context, object instance);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InitializerContext get_Context();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Instance();
    internal string get_DebuggerDisplay();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InstanceInitializationData other);
    public static bool op_Equality(InstanceInitializationData first, InstanceInitializationData second);
    public static bool op_Inequality(InstanceInitializationData first, InstanceInitializationData second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class SimpleInjector.Advanced.Internal.LazyScope : ValueType {
    private Container container;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<Scope> scopeFactory;
    [NullableAttribute("2")]
private Scope value;
    public Scope Value { get; }
    public LazyScope(Func`1<Scope> scopeFactory, Container container);
    public Scope get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class SimpleInjector.Advanced.Internal.LazyScopedRegistration`1 : ValueType {
    private Registration registration;
    [NullableAttribute("2")]
private TImplementation instance;
    public LazyScopedRegistration`1(Registration registration);
    public TImplementation GetInstance(Scope scope);
}
[NullableContextAttribute("1")]
public interface SimpleInjector.Advanced.IPropertySelectionBehavior {
    public abstract virtual bool SelectProperty(Type implementationType, PropertyInfo propertyInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class SimpleInjector.Advanced.KnownRelationship : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DiagnosticType, string> additionalInformation;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceProducer <Dependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseForVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private InjectionConsumerInfo <Consumer>k__BackingField;
    [DebuggerDisplayAttribute("{ImplementationTypeDebuggerDisplay, nq}")]
public Type ImplementationType { get; }
    public Lifestyle Lifestyle { get; }
    public InstanceProducer Dependency { get; }
    internal bool UseForVerification { get; internal set; }
    internal InjectionConsumerInfo Consumer { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [DebuggerBrowsableAttribute("0")]
private string ImplementationTypeDebuggerDisplay { get; }
    public KnownRelationship(Type implementationType, Lifestyle lifestyle, InstanceProducer dependency);
    internal KnownRelationship(Type implementationType, Lifestyle lifestyle, InjectionConsumerInfo consumer, InstanceProducer dependency);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
public InstanceProducer get_Dependency();
    internal void AddAdditionalInformation(DiagnosticType type, string message);
    internal string GetAdditionalInformation(DiagnosticType type);
    [CompilerGeneratedAttribute]
internal bool get_UseForVerification();
    [CompilerGeneratedAttribute]
internal void set_UseForVerification(bool value);
    [CompilerGeneratedAttribute]
internal InjectionConsumerInfo get_Consumer();
    private string get_DebuggerDisplay();
    private string get_ImplementationTypeDebuggerDisplay();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(KnownRelationship other);
    internal KnownRelationship ReplaceLifestyle(Lifestyle lifestyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Advanced.PropertyInjectionHelper : object {
    private static int MaximumNumberOfFuncArguments;
    private static int MaximumNumberOfPropertiesPerDelegate;
    private static ReadOnlyCollection`1<Type> FuncTypes;
    private Container container;
    private Type implementationType;
    internal PropertyInjectionHelper(Container container, Type implementationType);
    private static PropertyInjectionHelper();
    internal static PropertyInjectionData BuildPropertyInjectionExpression(Container container, Type implementationType, PropertyInfo[] properties, Expression expressionToWrap);
    internal static PropertyInfo[] GetCandidateInjectionPropertiesFor(Type implementationType);
    internal static void VerifyProperties(PropertyInfo[] properties);
    private Delegate BuildPropertyInjectionDelegate(PropertyInfo[] properties);
    private Delegate BuildPropertyInjectionDelegateInternal(PropertyInfo[] properties);
    private List`1<Expression> BuildPropertyInjectionExpressions(ParameterExpression targetParameter, PropertyInfo[] properties, ParameterExpression[] dependencyParameters);
    private static void VerifyProperty(PropertyInfo property);
    private PropertyInjectionData BuildPropertyInjectionExpression(Expression expression, PropertyInfo[] properties);
    private InstanceProducer[] GetPropertyInstanceProducers(PropertyInfo[] properties);
    private InstanceProducer GetPropertyExpression(PropertyInfo property);
    private static Type GetFuncType(PropertyInfo[] properties, Type injecteeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SimpleInjector.ConstructorResolutionBehaviorExtensions : object {
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(IConstructorResolutionBehavior behavior, Type implementationType);
    private static ActivationException BuildActivationException(IConstructorResolutionBehavior behavior, Type implementationType, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("SimpleInjector.Diagnostics.Debugger.ContainerDebugView")]
public class SimpleInjector.Container : ApiObject {
    private static long Counter;
    internal Dictionary`2<object, Dictionary`2<Type, WeakReference>> LifestyleRegistrationCache;
    internal long ContainerId;
    private object locker;
    private List`1<IInstanceInitializer> instanceInitializers;
    private List`1<ContextualResolveInterceptor> resolveInterceptors;
    private Dictionary`2<Type, IRegistrationEntry> explicitRegistrations;
    private Dictionary`2<Type, CollectionResolver> collectionResolvers;
    private ConditionalHashSet`1<InstanceProducer> externalProducers;
    private bool locked;
    [NullableAttribute("2")]
private string stackTraceThatLockedTheContainer;
    private bool disposed;
    [NullableAttribute("2")]
private string stackTraceThatDisposedTheContainer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<UnregisteredTypeEventArgs> resolveUnregisteredType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<ExpressionBuildingEventArgs> expressionBuilding;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<ExpressionBuiltEventArgs> expressionBuilt;
    private IInstanceProducerBuilder[] producerBuilders;
    private IInstanceProducerBuilder unregisteredConcreteTypeProducerBuilder;
    [CompilerGeneratedAttribute]
private ContainerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerScope <ContainerScope>k__BackingField;
    [CompilerGeneratedAttribute]
private LifestyleSelectionBehaviorProxyLifestyle <SelectionBasedLifestyle>k__BackingField;
    private Dictionary`2<Type, List`1<Type>> skippedNonGenericDecorators;
    [CompilerGeneratedAttribute]
private Action Verifying;
    [CompilerGeneratedAttribute]
private ContainerCollectionRegistrator <Collection>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, InstanceProducer> rootProducerCache;
    private ThreadLocal`1<bool> isVerifying;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadLocal`1<Scope> resolveScope;
    private bool usingCurrentThreadResolveScope;
    [CompilerGeneratedAttribute]
private bool <SuccesfullyVerified>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Scope <VerificationScope>k__BackingField;
    public ContainerOptions Options { get; }
    public ContainerScope ContainerScope { get; }
    public bool IsVerifying { get; private set; }
    public bool IsLocked { get; }
    internal LifestyleSelectionBehaviorProxyLifestyle SelectionBasedLifestyle { get; }
    internal bool HasRegistrations { get; }
    internal bool HasResolveInterceptors { get; }
    internal bool IsDisposed { get; }
    public ContainerCollectionRegistrator Collection { get; }
    internal bool SuccesfullyVerified { get; private set; }
    [NullableAttribute("2")]
internal Scope VerificationScope { get; private set; }
    [NullableAttribute("2")]
internal Scope CurrentThreadResolveScope { get; internal set; }
    [AsyncStateMachineAttribute("SimpleInjector.Container/<DisposeContainerAsync>d__0")]
public Task DisposeContainerAsync();
    [CompilerGeneratedAttribute]
public ContainerOptions get_Options();
    [CompilerGeneratedAttribute]
public ContainerScope get_ContainerScope();
    public bool get_IsVerifying();
    private void set_IsVerifying(bool value);
    public bool get_IsLocked();
    [CompilerGeneratedAttribute]
internal LifestyleSelectionBehaviorProxyLifestyle get_SelectionBasedLifestyle();
    internal bool get_HasRegistrations();
    internal bool get_HasResolveInterceptors();
    internal bool get_IsDisposed();
    public InstanceProducer[] GetCurrentRegistrations();
    public InstanceProducer[] GetRootRegistrations();
    public sealed virtual void Dispose();
    internal InstanceProducer[] GetRootRegistrations(bool includeInvalidContainerRegisteredTypes);
    internal InstanceProducer[] GetCurrentRegistrations(bool includeInvalidContainerRegisteredTypes, bool includeExternalProducers);
    internal Expression OnExpressionBuilding(Registration registration, Type implementationType, Expression instanceCreatorExpression);
    internal ExpressionBuiltEventArgs OnExpressionBuilt(InstanceProducer instanceProducer, Expression expression);
    internal void LockContainer();
    internal void ThrowWhenDisposed();
    internal Func`1<object> WrapWithResolveInterceptor(InstanceProducer instanceProducer, Func`1<object> producer);
    internal void ThrowWhenContainerIsLockedOrDisposed();
    internal void ThrowParameterTypeMustBeRegistered(InjectionTargetInfo target);
    internal CollectionResolver GetContainerUncontrolledResolver(Type itemType);
    internal CollectionResolver GetCollectionResolver(Type itemType, bool containerControlled);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
private static string GetStackTraceOrNull();
    private static Func`1<object> ApplyResolveInterceptor(ResolveInterceptor interceptor, InitializationContext context, Func`1<object> wrappedProducer);
    private CollectionResolver CreateAndAddCollectionResolver(Type openServiceType, bool controlled);
    private void NotifyAndLock();
    private void ThrowContainerDisposedException();
    private static object ThrowWhenResolveInterceptorReturnsNull(object instance);
    private IEnumerable`1<ResolveInterceptor> GetResolveInterceptorsFor(InitializationContext context);
    private Action`1[] GetInstanceInitializersFor(Type type, Registration registration);
    private void RegisterOpenGeneric(Type serviceType, Type implementationType, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    private void AddInstanceProducer(InstanceProducer producer);
    private void AddUncontrolledCollectionInstanceProducer(InstanceProducer producer);
    private int GetNumberOfConditionalRegistrationsFor(Type serviceType);
    private InstanceProducer GetInstanceProducerForType(Type serviceType, InjectionConsumerInfo consumer, Func`1<InstanceProducer> buildInstanceProducer);
    private InstanceProducer GetExplicitlyRegisteredInstanceProducer(Type serviceType, InjectionConsumerInfo consumer);
    private InstanceProducer TryGetInstanceProducerForRegisteredCollection(Type enumerableServiceType);
    private InstanceProducer GetInstanceProducerForRegisteredCollection(Type serviceType);
    private IRegistrationEntry GetOrCreateRegistrationalEntry(Type serviceType);
    private IRegistrationEntry GetRegistrationalEntryOrNull(Type serviceType);
    private static Type GetRegistrationKey(Type serviceType);
    private Type[] GetLookalikesForMissingType(Type missingServiceType);
    private IEnumerable`1<Type> GetLookalikesForMissingNonGenericType(Type missingServiceType);
    private IEnumerable`1<Type> GetLookalikesFromCurrentRegistrationsForMissingNonAndClosedGenericType(string name);
    private IEnumerable`1<Type> GetLookalikesFromExplictRegistrationsForMissingNonAndClosedGenericType(string name);
    private IEnumerable`1<Type> GetLookalikesForMissingGenericTypeDefinitions(Type missingType);
    public void Register(Type openGenericServiceType, Assembly[] assemblies);
    public void Register(Type openGenericServiceType, IEnumerable`1<Assembly> assemblies);
    public void Register(Type openGenericServiceType, Assembly assembly, Lifestyle lifestyle);
    public void Register(Type openGenericServiceType, IEnumerable`1<Assembly> assemblies, Lifestyle lifestyle);
    public void Register(Type openGenericServiceType, IEnumerable`1<Type> implementationTypes);
    public void Register(Type openGenericServiceType, IEnumerable`1<Type> implementationTypes, Lifestyle lifestyle);
    public void RegisterSingleton(Type openGenericServiceType, Assembly[] assemblies);
    public void RegisterSingleton(Type openGenericServiceType, IEnumerable`1<Assembly> assemblies);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public void RegisterCollection(IEnumerable`1<Assembly> assemblies);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public void RegisterCollection(Type serviceType, Assembly[] assemblies);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public void RegisterCollection(Type serviceType, IEnumerable`1<Assembly> assemblies);
    public IEnumerable`1<Type> GetTypesToRegister(IEnumerable`1<Assembly> assemblies);
    public IEnumerable`1<Type> GetTypesToRegister(Assembly[] assemblies);
    public IEnumerable`1<Type> GetTypesToRegister(Type serviceType, Assembly[] assemblies);
    public IEnumerable`1<Type> GetTypesToRegister(Type serviceType, IEnumerable`1<Assembly> assemblies);
    public IEnumerable`1<Type> GetTypesToRegister(IEnumerable`1<Assembly> assemblies, TypesToRegisterOptions options);
    public IEnumerable`1<Type> GetTypesToRegister(Type serviceType, IEnumerable`1<Assembly> assemblies, TypesToRegisterOptions options);
    private IEnumerable`1<Type> GetTypesToRegisterInternal(Type serviceType, IEnumerable`1<Assembly> assemblies, TypesToRegisterOptions options);
    private NonGenericTypesToRegisterForOneToOneMappingResults GetNonGenericTypesToRegisterForOneToOneMapping(Type openGenericServiceType, IEnumerable`1<Assembly> assemblies);
    private bool IsDecorator(Type openGenericServiceType, Type implemenationType);
    private ConstructorInfo SelectImplementationTypeConstructorOrNull(Type implementationType);
    private static IEnumerable`1<Type> GetTypesFromAssembly(Assembly assembly);
    private void AddSkippedDecorators(Type openGenericServiceType, IEnumerable`1<Type> nonGenericDecorators);
    private Type[] GetNonGenericDecoratorsSkippedDuringAutoRegistration(Type serviceType);
    private static void CollectionDoesNotContainOpenGenericTypes(Type openGenericServiceType, IEnumerable`1<Type> typesToRegister, string paramName);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(IEnumerable`1<TService> containerUncontrolledCollection);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(TService[] singletons);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(IEnumerable`1<Type> serviceTypes);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(IEnumerable`1<Registration> registrations);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(Type serviceType, IEnumerable`1<Type> serviceTypes);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(Type serviceType, IEnumerable`1<Registration> registrations);
    [ObsoleteAttribute("Please use Container.Collection.Register instead. Will be removed in version 6.0.", "True")]
public void RegisterCollection(Type serviceType, IEnumerable containerUncontrolledCollection);
    public void RegisterConditional(Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Type serviceType, Type implementationType, Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Type serviceType, Type implementationType, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Type serviceType, Func`2<TypeFactoryContext, Type> implementationTypeFactory, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Registration registration, Predicate`1<PredicateContext> predicate);
    public void RegisterConditional(Type serviceType, Registration registration, Predicate`1<PredicateContext> predicate);
    public void add_ResolveUnregisteredType(EventHandler`1<UnregisteredTypeEventArgs> value);
    public void remove_ResolveUnregisteredType(EventHandler`1<UnregisteredTypeEventArgs> value);
    public void add_ExpressionBuilt(EventHandler`1<ExpressionBuiltEventArgs> value);
    public void remove_ExpressionBuilt(EventHandler`1<ExpressionBuiltEventArgs> value);
    public void add_ExpressionBuilding(EventHandler`1<ExpressionBuildingEventArgs> value);
    public void remove_ExpressionBuilding(EventHandler`1<ExpressionBuildingEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_Verifying(Action value);
    [CompilerGeneratedAttribute]
internal void remove_Verifying(Action value);
    [CompilerGeneratedAttribute]
public ContainerCollectionRegistrator get_Collection();
    public void Register();
    public void Register(Lifestyle lifestyle);
    public void Register();
    public void Register(Lifestyle lifestyle);
    public void Register(Func`1<TService> instanceCreator);
    public void Register(Func`1<TService> instanceCreator, Lifestyle lifestyle);
    public void Register(Type concreteType);
    public void Register(Type serviceType, Type implementationType);
    public void Register(Type serviceType, Type implementationType, Lifestyle lifestyle);
    public void Register(Type serviceType, Func`1<object> instanceCreator);
    public void Register(Type serviceType, Func`1<object> instanceCreator, Lifestyle lifestyle);
    [ObsoleteAttribute("Please use RegisterInstance<TService>(TService) instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public void RegisterSingleton(TService instance);
    public void RegisterInstance(TService instance);
    [ObsoleteAttribute("Please use RegisterInstance(Type, object) instead. Will be removed in version 6.0.", "True")]
[EditorBrowsableAttribute("1")]
public void RegisterSingleton(Type serviceType, object instance);
    public void RegisterInstance(Type serviceType, object instance);
    public void RegisterSingleton();
    public void RegisterSingleton();
    public void RegisterSingleton(Func`1<TService> instanceCreator);
    public void RegisterSingleton(Type serviceType, Type implementationType);
    public void RegisterSingleton(Type serviceType, Func`1<object> instanceCreator);
    public void RegisterInitializer(Action`1<TService> instanceInitializer);
    public void RegisterInitializer(Action`1<InstanceInitializationData> instanceInitializer, Predicate`1<InitializerContext> predicate);
    public void AddRegistration(Registration registration);
    public void AddRegistration(Type serviceType, Registration registration);
    internal void RegisterExternalProducer(InstanceProducer producer);
    internal void RemoveExternalProducer(InstanceProducer producer);
    internal void RegisterResolveInterceptor(ResolveInterceptor interceptor, Predicate`1<InitializationContext> predicate);
    private void Register(Lifestyle lifestyle, string serviceTypeParamName, string implementationTypeParamName);
    private void Register(Type serviceType, Type implementationType, Lifestyle lifestyle, string serviceTypeParamName, string implementationTypeParamName);
    private void AddRegistrationInternal(Type serviceType, Registration registration);
    private void ThrowArgumentExceptionWhenTypeIsNotConstructable(Type implementationType, string parameterName);
    public void RegisterDecorator();
    public void RegisterDecorator(Lifestyle lifestyle);
    public void RegisterDecorator(Type serviceType, Type decoratorType);
    public void RegisterDecorator(Type serviceType, Type decoratorType, Lifestyle lifestyle);
    public void RegisterDecorator(Type serviceType, Type decoratorType, Lifestyle lifestyle, Predicate`1<DecoratorPredicateContext> predicate);
    public void RegisterDecorator(Type serviceType, Func`2<DecoratorPredicateContext, Type> decoratorTypeFactory, Lifestyle lifestyle, Predicate`1<DecoratorPredicateContext> predicate);
    public void RegisterDecorator(Type serviceType, Type decoratorType, Predicate`1<DecoratorPredicateContext> predicate);
    private void RegisterDecoratorCore(Type serviceType, Type decoratorType, Predicate`1<DecoratorPredicateContext> predicate, Lifestyle lifestyle);
    public TService GetInstance();
    public object GetInstance(Type serviceType);
    public IEnumerable`1<TService> GetAllInstances();
    public IEnumerable`1<object> GetAllInstances(Type serviceType);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public InstanceProducer GetRegistration(Type serviceType);
    public InstanceProducer GetRegistration();
    [NullableContextAttribute("2")]
public InstanceProducer GetRegistration(bool throwOnFailure);
    public InstanceProducer GetRegistration(Type serviceType, bool throwOnFailure);
    internal Action`1<object> GetInitializer(Type implementationType, Registration context);
    internal InstanceProducer GetRegistrationEvenIfInvalid(Type serviceType, InjectionConsumerInfo consumer, bool autoCreateConcreteTypes);
    internal bool IsConcreteConstructableType(Type concreteType);
    internal InstanceProducer GetInstanceProducerForType(Type serviceType, InjectionConsumerInfo context);
    private Action`1<T> GetInitializer(Type implementationType, Registration context);
    private object GetInstanceForRootType(Type serviceType);
    private object GetInstanceFromProducer(InstanceProducer instanceProducer, Type serviceType);
    private InstanceProducer BuildInstanceProducerForType(Type serviceType, bool autoCreateConcreteTypes);
    private void AppendRootInstanceProducer(Type serviceType, InstanceProducer rootProducer);
    private void ThrowInvalidRegistrationException(Type serviceType, InstanceProducer producer);
    internal void ThrowMissingInstanceProducerException(Type type);
    private bool IsCollectionButNoOneToToOneRegistrationExists(Type collectionServiceType);
    private bool ContainsOneToOneRegistrationForCollection(Type collectionServiceType);
    private bool ContainsCollectionRegistrationFor(Type serviceType);
    private bool ContainsExplicitRegistrationFor(Type serviceType);
    private void ThrowNotConstructableException(Type concreteType);
    [CompilerGeneratedAttribute]
internal bool get_SuccesfullyVerified();
    [CompilerGeneratedAttribute]
private void set_SuccesfullyVerified(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Scope get_VerificationScope();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_VerificationScope(Scope value);
    [NullableContextAttribute("2")]
internal Scope get_CurrentThreadResolveScope();
    [NullableContextAttribute("2")]
internal void set_CurrentThreadResolveScope(Scope value);
    public void Verify();
    public void Verify(VerificationOption option);
    [NullableContextAttribute("2")]
internal Scope GetVerificationOrResolveScopeForCurrentThread();
    [NullableContextAttribute("2")]
private Scope GetScopeWhileVerifying();
    internal void UseCurrentThreadResolveScope();
    private void VerifyInternal(bool suppressLifestyleMismatchVerification);
    private void VerifyThatAllExpressionsCanBeBuilt();
    private void VerifyThatAllRootObjectsCanBeCreated(Scope verificationScope);
    private IEnumerable`1<InstanceProducer> GetProducersThatNeedExplicitVerification();
    private static void VerifyThatAllExpressionsCanBeBuilt(InstanceProducer[] producersToVerify);
    private static void VerifyInstanceProducersOfContainerControlledCollection(Expression expression);
    private void VerifyInstanceCreation(InstanceProducer[] producersToVerify, Scope verificationScope);
    private static void VerifyContainerUncontrolledCollection(object instance, InstanceProducer producer);
    private void ThrowOnDiagnosticWarnings();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__19_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_1(UnregisteredTypeEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.ContainerCollectionRegistrator : ApiObject {
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    public Container Container { get; }
    internal ContainerCollectionRegistrator(Container container);
    [CompilerGeneratedAttribute]
public Container get_Container();
    public IList`1<TService> Create(Assembly[] assemblies);
    public IList`1<TService> Create(IEnumerable`1<Assembly> assemblies);
    public IList`1<TService> Create(Type[] serviceTypes);
    public IList`1<TService> Create(IEnumerable`1<Type> serviceTypes);
    public IList`1<TService> Create(Registration[] registrations);
    public IList`1<TService> Create(IEnumerable`1<Registration> registrations);
    public Registration CreateRegistration(Assembly[] assemblies);
    public Registration CreateRegistration(IEnumerable`1<Assembly> assemblies);
    public Registration CreateRegistration(Type[] serviceTypes);
    public Registration CreateRegistration(IEnumerable`1<Type> serviceTypes);
    public Registration CreateRegistration(Registration[] registrations);
    public Registration CreateRegistration(IEnumerable`1<Registration> registrations);
    public void Append(Type serviceType, Registration registration);
    public void Append();
    public void Append(Lifestyle lifestyle);
    public void Append(Type serviceType, Type implementationType);
    public void Append(Type serviceType, Type implementationType, Lifestyle lifestyle);
    public void Append(Func`1<TService> instanceCreator, Lifestyle lifestyle);
    public void AppendInstance(TService instance);
    public void AppendInstance(Type serviceType, object instance);
    public void Register(IEnumerable`1<TService> containerUncontrolledCollection);
    public void Register(TService[] singletons);
    public void Register(Type[] serviceTypes);
    public void Register(IEnumerable`1<Type> serviceTypes);
    public void Register(IEnumerable`1<Type> serviceTypes, Lifestyle lifestyle);
    public void Register(IEnumerable`1<Registration> registrations);
    public void Register(Type serviceType, IEnumerable`1<Type> serviceTypes);
    public void Register(Type serviceType, IEnumerable`1<Type> serviceTypes, Lifestyle lifestyle);
    public void Register(Type serviceType, IEnumerable`1<Registration> registrations);
    public void Register(Type serviceType, IEnumerable containerUncontrolledCollection);
    public void Register(Assembly[] assemblies);
    public void Register(IEnumerable`1<Assembly> assemblies);
    public void Register(IEnumerable`1<Assembly> assemblies, Lifestyle lifestyle);
    public void Register(Type serviceType, Assembly[] assemblies);
    public void Register(Type serviceType, IEnumerable`1<Assembly> assemblies);
    public void Register(Type serviceType, IEnumerable`1<Assembly> assemblies, Lifestyle lifestyle);
    private ContainerControlledCollection`1<TService> CreateInternal(IEnumerable`1<Type> serviceTypes);
    private ContainerControlledCollection`1<TService> CreateInternal(IEnumerable`1<Registration> registrations);
    private void RegisterForVerification(ContainerControlledCollection`1<TService> collection);
    private void AppendToCollectionInternal(Type itemType, Registration registration);
    private void AppendToCollectionInternal(Type itemType, Type implementationType, Lifestyle lifestyle);
    private void RegisterCollectionInternal(Type itemType, IEnumerable`1<Registration> registrations);
    private void RegisterCollectionInternal(Type itemType, IEnumerable`1<Type> serviceTypes);
    private void RegisterCollectionInternal(Type itemType, ContainerControlledItem[] controlledItems, bool appending);
    private void RegisterGenericContainerControlledCollection(Type itemType, ContainerControlledItem[] controlledItems, bool appending);
    private void RegisterGenericContainerUncontrolledCollection(Type itemType, IEnumerable collection);
    private void RegisterContainerUncontrolledCollection(Type itemType, IEnumerable`1<T> containerUncontrolledCollection);
    private CollectionResolver GetContainerControlledResolver(Type itemType);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Registration <Register>b__25_0(TService singleton);
}
public class SimpleInjector.ContainerLockingEventArgs : EventArgs {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayDescription, nq}")]
public class SimpleInjector.ContainerOptions : ApiObject {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<ContainerLockingEventArgs> containerLocking;
    [DebuggerBrowsableAttribute("0")]
private IConstructorResolutionBehavior resolutionBehavior;
    [DebuggerBrowsableAttribute("0")]
private IDependencyInjectionBehavior injectionBehavior;
    [DebuggerBrowsableAttribute("0")]
private IPropertySelectionBehavior propertyBehavior;
    [DebuggerBrowsableAttribute("0")]
private ILifestyleSelectionBehavior lifestyleBehavior;
    [DebuggerBrowsableAttribute("0")]
private IExpressionCompilationBehavior compilationBehavior;
    [DebuggerBrowsableAttribute("0")]
private Lifestyle defaultLifestyle;
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private ScopedLifestyle defaultScopedLifestyle;
    [DebuggerBrowsableAttribute("0")]
private bool resolveUnregisteredConcreteTypes;
    [DebuggerBrowsableAttribute("0")]
private bool useStrictLifestyleMismatchBehavior;
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowOverridingRegistrations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressLifestyleMismatchVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableAutoVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDynamicAssemblyCompilation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumNumberOfNodesPerDelegate>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public Container Container { get; }
    public bool AllowOverridingRegistrations { get; public set; }
    public bool SuppressLifestyleMismatchVerification { get; public set; }
    [ObsoleteAttribute("Please use the UseStrictLifestyleMismatchBehavior property instead. Note that UseStrictLifestyleMismatchBehavior's behavior is negated. This means that if you're currently supplying 'false' to UseLoosenedLifestyleMismatchBehavior, you will have to supply 'true' to UseStrictLifestyleMismatchBehavior instead, and vise versa. Also note that 'loosend' behavior became the default in 5.0 â€” In case you are assinging UseLoosenedLifestyleMismatchBehavior to 'true', the call can be removed safely. Will be treated as an error from version 5.5. Will be removed in version 6.0.", "False")]
[EditorBrowsableAttribute("1")]
public bool UseLoosenedLifestyleMismatchBehavior { get; public set; }
    public bool UseStrictLifestyleMismatchBehavior { get; public set; }
    public bool EnableAutoVerification { get; public set; }
    public bool UseFullyQualifiedTypeNames { get; public set; }
    public bool ResolveUnregisteredConcreteTypes { get; public set; }
    public IConstructorResolutionBehavior ConstructorResolutionBehavior { get; public set; }
    public IDependencyInjectionBehavior DependencyInjectionBehavior { get; public set; }
    public IPropertySelectionBehavior PropertySelectionBehavior { get; public set; }
    public ILifestyleSelectionBehavior LifestyleSelectionBehavior { get; public set; }
    public IExpressionCompilationBehavior ExpressionCompilationBehavior { get; public set; }
    public Lifestyle DefaultLifestyle { get; public set; }
    [NullableAttribute("2")]
public ScopedLifestyle DefaultScopedLifestyle { get; public set; }
    [DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Changing this value to true has no effect. To use dynamic assembly compilation, set the ExpressionCompilationBehavior property with a new DynamicAssemblyExpressionCompilationBehavior instance that is located in the SimpleInjector.DynamicAssemblyCompilation package. Will be treated as an error from version 5.5. Will be removed in version 6.0.", "False")]
public bool EnableDynamicAssemblyCompilation { get; public set; }
    [DebuggerBrowsableAttribute("0")]
internal int MaximumNumberOfNodesPerDelegate { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplayDescription { get; }
    internal ContainerOptions(Container container);
    public void add_ContainerLocking(EventHandler`1<ContainerLockingEventArgs> value);
    public void remove_ContainerLocking(EventHandler`1<ContainerLockingEventArgs> value);
    [CompilerGeneratedAttribute]
public Container get_Container();
    [CompilerGeneratedAttribute]
public bool get_AllowOverridingRegistrations();
    [CompilerGeneratedAttribute]
public void set_AllowOverridingRegistrations(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressLifestyleMismatchVerification();
    [CompilerGeneratedAttribute]
public void set_SuppressLifestyleMismatchVerification(bool value);
    public bool get_UseLoosenedLifestyleMismatchBehavior();
    public void set_UseLoosenedLifestyleMismatchBehavior(bool value);
    public bool get_UseStrictLifestyleMismatchBehavior();
    public void set_UseStrictLifestyleMismatchBehavior(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableAutoVerification();
    [CompilerGeneratedAttribute]
public void set_EnableAutoVerification(bool value);
    public bool get_UseFullyQualifiedTypeNames();
    public void set_UseFullyQualifiedTypeNames(bool value);
    public bool get_ResolveUnregisteredConcreteTypes();
    public void set_ResolveUnregisteredConcreteTypes(bool value);
    public IConstructorResolutionBehavior get_ConstructorResolutionBehavior();
    public void set_ConstructorResolutionBehavior(IConstructorResolutionBehavior value);
    public IDependencyInjectionBehavior get_DependencyInjectionBehavior();
    public void set_DependencyInjectionBehavior(IDependencyInjectionBehavior value);
    public IPropertySelectionBehavior get_PropertySelectionBehavior();
    public void set_PropertySelectionBehavior(IPropertySelectionBehavior value);
    public ILifestyleSelectionBehavior get_LifestyleSelectionBehavior();
    public void set_LifestyleSelectionBehavior(ILifestyleSelectionBehavior value);
    public IExpressionCompilationBehavior get_ExpressionCompilationBehavior();
    public void set_ExpressionCompilationBehavior(IExpressionCompilationBehavior value);
    public Lifestyle get_DefaultLifestyle();
    public void set_DefaultLifestyle(Lifestyle value);
    [NullableContextAttribute("2")]
public ScopedLifestyle get_DefaultScopedLifestyle();
    [NullableContextAttribute("2")]
public void set_DefaultScopedLifestyle(ScopedLifestyle value);
    [CompilerGeneratedAttribute]
public bool get_EnableDynamicAssemblyCompilation();
    [CompilerGeneratedAttribute]
public void set_EnableDynamicAssemblyCompilation(bool value);
    [CompilerGeneratedAttribute]
internal int get_MaximumNumberOfNodesPerDelegate();
    [CompilerGeneratedAttribute]
internal void set_MaximumNumberOfNodesPerDelegate(int value);
    internal string get_DebuggerDisplayDescription();
    public void RegisterResolveInterceptor(ResolveInterceptor interceptor, Predicate`1<InitializationContext> predicate);
    public virtual string ToString();
    internal bool IsConstructableType(Type implementationType, String& errorMessage);
    internal InstanceProducer GetInstanceProducerFor(InjectionConsumerInfo consumer);
    internal Lifestyle SelectLifestyle(Type implementationType);
    internal void RaiseContainerLockingAndReset();
    internal ConstructorInfo SelectConstructorOrNull(Type implementationType);
    internal ConstructorInfo SelectConstructor(Type implementatioType);
    private void ThrowWhenContainerHasRegistrations(string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.ContainerScope : ApiObject {
    private Scope scope;
    internal ContainerScope(Container container);
    public Task DisposeScopeAsync();
    public virtual void WhenScopeEnds(Action action);
    public void RegisterForDisposal(IDisposable disposable);
    public void RegisterForDisposal(object disposable);
    public object GetItem(object key);
    public void SetItem(object key, object item);
    public T GetOrSetItem(object key, Func`3<Container, object, T> valueFactory);
    public IDisposable[] GetDisposables();
    public Object[] GetAllDisposables();
    internal void Dispose();
}
public class SimpleInjector.CreateLifestyleApplier : MulticastDelegate {
    public CreateLifestyleApplier(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Func`1<object> Invoke(Func`1<object> transientInstanceCreator);
    public virtual IAsyncResult BeginInvoke(Func`1<object> transientInstanceCreator, AsyncCallback callback, object object);
    public virtual Func`1<object> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("DecoratorContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.DecoratorContext : ApiObject {
    [DebuggerBrowsableAttribute("0")]
private DecoratorPredicateContext context;
    public Type ServiceType { get; }
    public Type ImplementationType { get; }
    public ReadOnlyCollection`1<Type> AppliedDecorators { get; }
    public Expression Expression { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal DecoratorContext(DecoratorPredicateContext context);
    public Type get_ServiceType();
    public Type get_ImplementationType();
    public ReadOnlyCollection`1<Type> get_AppliedDecorators();
    public Expression get_Expression();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("DecoratorPredicateContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.DecoratorPredicateContext : ApiObject {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Type> <AppliedDecorators>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Type ServiceType { get; }
    public Type ImplementationType { get; }
    public ReadOnlyCollection`1<Type> AppliedDecorators { get; }
    public Expression Expression { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal DecoratorPredicateContext(Type serviceType, Type implementationType, ReadOnlyCollection`1<Type> appliedDecorators, Expression expression);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Type> get_AppliedDecorators();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    internal string get_DebuggerDisplay();
    internal static DecoratorPredicateContext CreateFromInfo(Type serviceType, Expression expression, ServiceTypeDecoratorInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Decorators.CompositeHelpers : object {
    internal static bool ComposesServiceType(Type serviceType, ConstructorInfo constructor);
    private static int GetNumberOfCompositeServiceTypeDependencies(Type serviceType, ConstructorInfo compositeConstructor);
    private static Type GetCompositeBaseType(Type serviceType, ConstructorInfo compositeConstructor);
    private static bool ContainsCompositeParameters(ConstructorInfo compositeConstructor, Type serviceType);
    private static bool IsCompositeParameter(ParameterInfo parameter, Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.ContainerUncontrolledServicesDecoratorInterceptor : DecoratorExpressionInterceptor {
    private Dictionary`2<InstanceProducer, IEnumerable> singletonDecoratedCollectionsCache;
    private ExpressionBuiltEventArgs e;
    private Type registeredServiceType;
    [NullableAttribute("2")]
private ConstructorInfo decoratorConstructor;
    [NullableAttribute("2")]
private Type decoratorType;
    public ContainerUncontrolledServicesDecoratorInterceptor(DecoratorExpressionInterceptorData data, Dictionary`2<InstanceProducer, IEnumerable> singletonDecoratedCollectionsCache, ExpressionBuiltEventArgs e, Type registeredServiceType);
    internal bool SatisfiesPredicate();
    internal void SetDecorator(Type decorator);
    internal void ApplyDecorator();
    private Expression BuildDecoratorExpression(Registration& decoratorRegistration);
    private Registration CreateRegistrationForUncontrolledCollection(Expression decorateeExpression);
    private OverriddenParameter[] CreateOverriddenParameters(Expression decorateeExpression);
    private IEnumerable`1<OverriddenParameter> CreateOverriddenDecoratorContextParameters(InstanceProducer currentProducer);
    private LambdaExpression BuildDecoratorWrapper(ParameterExpression parameter, Expression decoratorExpression);
    private Expression BuildDecoratorEnumerableExpressionForConstantEnumerable(Delegate wrapInstanceWithDecoratorDelegate, IEnumerable collection);
    private Expression BuildDecoratorEnumerableExpressionForNonConstantExpression(Delegate wrapInstanceWithDecorator, Expression expression);
    private void ThrowWhenDecoratorNeedsAFunc(Type decoratorTypeDefinition);
    private Type GetDecorateeFactoryTypeOrNull();
    private void ThrownWhenLifestyleIsNotSupported(Type decoratorTypeDefinition);
    private IEnumerable GetSingletonDecoratedCollection(Func`1<IEnumerable> collectionCreator);
    private static Array ToArray(Type elementType, IEnumerable source);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDecorateeFactoryTypeOrNull>b__17_0(ParameterInfo parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SimpleInjector.Decorators.DecoratorExpressionInterceptor : object {
    private static MethodInfo ResolveWithinThreadResolveScopeMethod;
    private DecoratorExpressionInterceptorData data;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DecoratorPredicateContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [NullableAttribute("2")]
internal DecoratorPredicateContext Context { get; internal set; }
    protected Container Container { get; }
    protected Lifestyle Lifestyle { get; protected set; }
    [NullableAttribute("2")]
protected Type DecoratorTypeDefinition { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Predicate`1<DecoratorPredicateContext> Predicate { get; }
    protected DecoratorExpressionInterceptor(DecoratorExpressionInterceptorData data);
    private static DecoratorExpressionInterceptor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal DecoratorPredicateContext get_Context();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Context(DecoratorPredicateContext value);
    protected Container get_Container();
    [CompilerGeneratedAttribute]
protected Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
protected void set_Lifestyle(Lifestyle value);
    [NullableContextAttribute("2")]
protected Type get_DecoratorTypeDefinition();
    protected Predicate`1<DecoratorPredicateContext> get_Predicate();
    public static TService ResolveWithinThreadResolveScope(Scope scope, Func`1<TService> instanceCreator, Container container);
    protected bool SatisfiesPredicate(DecoratorPredicateContext context);
    [NullableContextAttribute("2")]
protected ServiceTypeDecoratorInfo GetServiceTypeInfo(ExpressionBuiltEventArgs e, Expression originalExpression, Registration originalRegistration, Type registeredServiceType);
    protected Registration CreateRegistration(Type serviceType, ConstructorInfo decoratorConstructor, Expression decorateeExpression, InstanceProducer realProducer, ServiceTypeDecoratorInfo info);
    protected DecoratorPredicateContext CreatePredicateContext(ExpressionBuiltEventArgs e);
    protected DecoratorPredicateContext CreatePredicateContext(Type registeredServiceType, Expression expression, ServiceTypeDecoratorInfo info);
    protected Expression GetExpressionForDecorateeDependencyParameterOrNull(ParameterInfo param, Type serviceType, Expression expr);
    protected static ParameterInfo GetDecorateeParameter(Type serviceType, ConstructorInfo decoratorConstructor);
    protected InstanceProducer CreateDecorateeFactoryProducer(ParameterInfo parameter, InstanceProducer decorateeProducer);
    private static void AddVerifierForDecorateeFactoryDependency(Expression decorateeExpression, InstanceProducer producer);
    private OverriddenParameter[] CreateOverriddenParameters(Type serviceType, ConstructorInfo decoratorConstructor, Expression decorateeExpression, InstanceProducer realProducer, ServiceTypeDecoratorInfo info);
    private IEnumerable`1<OverriddenParameter> CreateOverriddenDecoratorContextParameters(ConstructorInfo decoratorConstructor, InstanceProducer currentProducer);
    private static Action`1<Scope> GetVerifierFromDecorateeExpression(Expression decorateeExpression);
    private static Expression BuildExpressionForDecorateeDependencyParameter(ParameterInfo parameter, Type serviceType, Expression expression);
    private static bool IsDecorateeDependencyParameter(ParameterInfo parameter, Type registeredServiceType);
    private Expression BuildExpressionForDecorateeFactoryDependencyParameter(ParameterInfo param, Type serviceType, Expression expr);
    private Expression BuildExpressionForScopedDecorateeFactoryDependencyParameter(ParameterInfo param, Type serviceType, Expression expr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.DecoratorExpressionInterceptorData : object {
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <DecoratorType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<DecoratorPredicateContext, Type> <DecoratorTypeFactory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<DecoratorPredicateContext> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    internal Container Container { get; }
    internal Type ServiceType { get; }
    [NullableAttribute("2")]
internal Type DecoratorType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`2<DecoratorPredicateContext, Type> DecoratorTypeFactory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Predicate`1<DecoratorPredicateContext> Predicate { get; }
    internal Lifestyle Lifestyle { get; }
    public DecoratorExpressionInterceptorData(Container container, Type serviceType, Type decoratorType, Predicate`1<DecoratorPredicateContext> predicate, Lifestyle lifestyle, Func`2<DecoratorPredicateContext, Type> factory);
    [CompilerGeneratedAttribute]
internal Container get_Container();
    [CompilerGeneratedAttribute]
internal Type get_ServiceType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Type get_DecoratorType();
    [CompilerGeneratedAttribute]
internal Func`2<DecoratorPredicateContext, Type> get_DecoratorTypeFactory();
    [CompilerGeneratedAttribute]
internal Predicate`1<DecoratorPredicateContext> get_Predicate();
    [CompilerGeneratedAttribute]
internal Lifestyle get_Lifestyle();
    private Func`2<DecoratorPredicateContext, Type> WrapInNullProtector(Func`2<DecoratorPredicateContext, Type> decoratorTypeFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Decorators.DecoratorHelpers : object {
    private static MethodInfo EnumerableSelectMethod;
    private static MethodInfo DecoratorHelpersReadOnlyCollectionMethod;
    private static DecoratorHelpers();
    [IteratorStateMachineAttribute("SimpleInjector.Decorators.DecoratorHelpers/<ReadOnlyCollection>d__2`1")]
public static IEnumerable`1<T> ReadOnlyCollection(T[] collection);
    internal static IEnumerable MakeReadOnly(Type elementType, Array collection);
    internal static Type DetermineImplementationType(Expression expression, InstanceProducer registeredProducer);
    [ExtensionAttribute]
internal static void AddRange(Collection`1<T> collection, IEnumerable`1<T> range);
    [ExtensionAttribute]
internal static IEnumerable Select(IEnumerable source, Type type, Delegate selector);
    internal static MethodCallExpression Select(Expression collectionExpression, Type type, Delegate selector);
    internal static bool DecoratesServiceType(Type serviceType, ConstructorInfo decoratorConstructor);
    internal static Type GetDecoratingBaseType(Type serviceType, ConstructorInfo decoratorConstructor);
    internal static int GetNumberOfServiceTypeDependencies(Type serviceType, ConstructorInfo decoratorConstructor);
    internal static bool DecoratesBaseTypes(Type serviceType, ConstructorInfo decoratorConstructor);
    internal static Type[] GetValidDecoratorConstructorArgumentTypes(Type serviceType, ConstructorInfo decoratorConstructor);
    internal static bool IsDecorateeParameter(ParameterInfo parameter, Type decoratingType);
    internal static bool IsDecorateeDependencyType(Type dependencyType, Type serviceType);
    internal static bool IsDecorateeFactoryDependencyType(Type dependencyType, Type decoratingType);
    internal static bool IsScopelessDecorateeFactoryDependencyType(Type dependencyType, Type decoratingType);
    internal static bool IsScopeDecorateeFactoryDependencyParameter(Type parameterType, Type decoratingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.DecoratorInfo : object {
    internal Type DecoratorType;
    internal InstanceProducer DecoratorProducer;
    internal DecoratorInfo(Type decoratorType, InstanceProducer decoratorProducer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.DecoratorInterceptor : object {
    private Dictionary`2<InstanceProducer, Registration> registrationsCache;
    private Dictionary`2<InstanceProducer, IEnumerable> singletonDecoratedCollectionsCache;
    private DecoratorExpressionInterceptorData data;
    protected Type ServiceTypeDefinition { get; }
    [NullableAttribute("2")]
protected Type DecoratorTypeDefinition { get; }
    public DecoratorInterceptor(DecoratorExpressionInterceptorData data);
    protected Type get_ServiceTypeDefinition();
    [NullableContextAttribute("2")]
protected Type get_DecoratorTypeDefinition();
    internal void ExpressionBuilt(object sender, ExpressionBuiltEventArgs e);
    private void TryToApplyDecorator(ExpressionBuiltEventArgs e);
    private void TryToApplyDecoratorOnContainerUncontrolledCollections(ExpressionBuiltEventArgs e);
    private void ApplyDecoratorOnContainerUncontrolledCollection(ExpressionBuiltEventArgs e, Type decoratorType);
    private static bool IsCollectionType(Type serviceType);
    private bool MustDecorate(Type serviceType, Type& decoratorType);
    private Type GetDecoratorTypeFromDecoratorFactory(Type requestedServiceType, DecoratorPredicateContext context);
    private BuildResult BuildClosedGenericImplementation(Type serviceType, Type decoratorTypeDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.ServiceDecoratorExpressionInterceptor : DecoratorExpressionInterceptor {
    private Dictionary`2<InstanceProducer, Registration> registrations;
    private ExpressionBuiltEventArgs e;
    private Type registeredServiceType;
    public ServiceDecoratorExpressionInterceptor(DecoratorExpressionInterceptorData data, Dictionary`2<InstanceProducer, Registration> registrations, ExpressionBuiltEventArgs e);
    internal bool SatisfiesPredicate();
    internal void ApplyDecorator(Type closedDecoratorType);
    private void ReplaceOriginalExpression(Registration decoratorRegistration);
    private void MarkDecorateeFactoryRelationshipAsInstanceCreationDelegate(KnownRelationship[] relationships);
    private IEnumerable`1<Registration> GetDecorateeFactoryDependencies(KnownRelationship[] relationships);
    private Registration CreateRegistrationForDecorator(ConstructorInfo decoratorConstructor);
    private void AddAppliedDecoratorToPredicateContext(IEnumerable`1<KnownRelationship> decoratorRelationships, ConstructorInfo decoratorConstructor);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDecorateeFactoryDependencies>b__8_0(KnownRelationship relationship);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Decorators.ServiceTypeDecoratorInfo : object {
    private List`1<DecoratorInfo> appliedDecorators;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceProducer <OriginalProducer>k__BackingField;
    internal Type ImplementationType { get; }
    internal InstanceProducer OriginalProducer { get; }
    internal IEnumerable`1<DecoratorInfo> AppliedDecorators { get; }
    internal ServiceTypeDecoratorInfo(Type implementationType, InstanceProducer originalProducer);
    [CompilerGeneratedAttribute]
internal Type get_ImplementationType();
    [CompilerGeneratedAttribute]
internal InstanceProducer get_OriginalProducer();
    internal IEnumerable`1<DecoratorInfo> get_AppliedDecorators();
    internal InstanceProducer GetCurrentInstanceProducer();
    internal void AddAppliedDecorator(Type serviceType, Type decoratorType, Container container, Lifestyle lifestyle, Expression decoratedExpression, IEnumerable`1<KnownRelationship> decoratorRelationships);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SimpleInjector.DependencyInjectionBehaviorExtensions : object {
    [ExtensionAttribute]
public static void Verify(IDependencyInjectionBehavior behavior, InjectionConsumerInfo consumer);
    [ExtensionAttribute]
internal static string VerifyConstructor(IDependencyInjectionBehavior behavior, ConstructorInfo constructor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.DependencyMetadata`1 : ApiObject {
    [NullableAttribute("2")]
private Scope scope;
    [CompilerGeneratedAttribute]
private InstanceProducer <Dependency>k__BackingField;
    public Type ImplementationType { get; }
    public InstanceProducer Dependency { get; }
    internal DependencyMetadata`1(Scope scope, InstanceProducer dependency);
    public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public InstanceProducer get_Dependency();
    public TService GetInstance();
    public sealed virtual bool Equals(DependencyMetadata`1<TService> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.AmbiguousLifestylesDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Lifestyle> <Lifestyles>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceProducer <DiagnosedRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<InstanceProducer> <ConflictingRegistrations>k__BackingField;
    public ReadOnlyCollection`1<Lifestyle> Lifestyles { get; }
    public Type ImplementationType { get; }
    public InstanceProducer DiagnosedRegistration { get; }
    public ReadOnlyCollection`1<InstanceProducer> ConflictingRegistrations { get; }
    internal AmbiguousLifestylesDiagnosticResult(Type serviceType, string description, Lifestyle[] lifestyles, Type implementationType, InstanceProducer diagnosedProducer, InstanceProducer[] conflictingProducers);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Lifestyle> get_Lifestyles();
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public InstanceProducer get_DiagnosedRegistration();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<InstanceProducer> get_ConflictingRegistrations();
    private static DebuggerViewItem[] CreateDebugValue(Type implementationType, Lifestyle[] lifestyles, InstanceProducer[] conflictingRegistrations);
    private static string ToCommaSeparatedText(IEnumerable`1<Lifestyle> lifestyles);
    private static string ToCommaSeparatedText(IEnumerable`1<InstanceProducer> producers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SimpleInjector.Diagnostics.Analyzer : object {
    public static DiagnosticResult[] Analyze(Container container);
    internal static InstanceProducer[] GetProducersToAnalyze(Container container);
    private static IEnumerable`1<InstanceProducer> SelfAndWrappedProducers(InstanceProducer producer);
    private static IEnumerable`1<InstanceProducer> GetSelfAndDependentProducers(InstanceProducer producer);
    [IteratorStateMachineAttribute("SimpleInjector.Diagnostics.Analyzer/<GetSelfAndDependentProducers>d__4")]
private static IEnumerable`1<InstanceProducer> GetSelfAndDependentProducers(InstanceProducer producer, HashSet`1<InstanceProducer> set);
    private static void RequiresContainerToBeVerified(Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.AmbiguousLifestylesAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private bool ShouldIncludeWarning(AmbiguousLifestylesDiagnosticResult warning);
    private static IEnumerable`1<AmbiguousLifestylesDiagnosticResult> GetDiagnosticWarnings(IEnumerable`1<InstanceProducer> instanceProducers);
    private static AmbiguousLifestylesDiagnosticResult CreateDiagnosticResult(InstanceProducer diagnosedProducer, InstanceProducer[] conflictingProducers);
    private static string BuildDescription(InstanceProducer diagnosedProducer, InstanceProducer[] conflictingProducers);
    private static string ToFriendlyNameWithLifestyle(InstanceProducer producer);
    private static string RegistrationsPlural(int number);
    private static string LifestylesPlural(int number);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Analyze>b__6_0(AmbiguousLifestylesDiagnosticResult warning);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.ContainerRegisteredServiceAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static ContainerRegisteredServiceDiagnosticResult BuildDiagnosticResult(InstanceProducer registration, KnownRelationship[] relationships);
    private static string BuildDescription(InstanceProducer registration, KnownRelationship[] relationships);
    private static string BuildComponentName(InstanceProducer registration, KnownRelationship[] relationships);
    private static string BuildUnregisteredTypeDescription(KnownRelationship[] relationships);
    private static string GetTypeRootDescription(int number);
    private static string GetTypeGroupDescription(int number);
    private static string GetComponentDescription(int number);
    private static int GetNumberOfComponents(IEnumerable`1<DiagnosticResult> results);
    private static int GetNumberOfAutoRegisteredServices(IEnumerable`1<DiagnosticResult> results);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Diagnostics.Analyzers.DebuggerGeneralWarningsContainerAnalyzer : object {
    internal static DebuggerViewItem Analyze(Container container);
    private static DebuggerViewItem[] ConvertToDebuggerViewItems(DiagnosticGroup group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.DisposableTransientComponentAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static string BuildDescription(InstanceProducer producer);
    private static string ComponentPlural(int number);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Analyze>b__6_3(<>f__AnonymousType27`2<InstanceProducer, Registration> <>h__TransparentIdentifier0);
}
[ExtensionAttribute]
internal static class SimpleInjector.Diagnostics.Analyzers.FriendlyTypeNameHelper : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static string FriendlyName(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.LifestyleMismatchAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static string BuildRelationshipDescription(KnownRelationship relationship);
    private static string ServicePlural(int number);
    private static string MismatchPlural(int number);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Analyze>b__6_3(<>f__AnonymousType26`2<InstanceProducer, KnownRelationship> <>h__TransparentIdentifier0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.ShortCircuitedDependencyAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static Dictionary`2<Type, IEnumerable`1<InstanceProducer>> GetRegisteredImplementationTypes(IEnumerable`1<InstanceProducer> producers);
    private static Dictionary`2<Type, InstanceProducer> GetAutoRegisteredRegistrationsWithLifestyleMismatch(IEnumerable`1<InstanceProducer> producers, Dictionary`2<Type, IEnumerable`1<InstanceProducer>> registeredImplementationTypes);
    private static string BuildDescription(KnownRelationship relationship, IEnumerable`1<InstanceProducer> possibleSkippedRegistrations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.SingleResponsibilityViolationsAnalyzer : object {
    private static int MaximumValidNumberOfDependencies;
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static bool IsAnalyzable(InstanceProducer producer);
    private static string BuildRelationshipDescription(Type implementationType, int numberOfDependencies);
    private static string ViolationPlural(int count);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Analyze>b__7_0(InstanceProducer producer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Analyzers.TornLifestyleContainerAnalyzer : object {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public sealed virtual DiagnosticType get_DiagnosticType();
    public sealed virtual string get_Name();
    public sealed virtual string GetRootDescription(DiagnosticResult[] results);
    public sealed virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public sealed virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
    private static IEnumerable`1<InstanceProducer[]> GetTornRegistrationGroups(IEnumerable`1<InstanceProducer> producers);
    private static bool HasConflict(int groupSize, InstanceProducer[] possibleConflictingProducers);
    private static TornLifestyleDiagnosticResult CreateDiagnosticResult(InstanceProducer diagnosedProducer, InstanceProducer[] affectedProducers);
    private static string BuildDescription(InstanceProducer diagnosedProducer, InstanceProducer[] affectedProducers);
    private static string RegistrationsPlural(int number);
}
internal static class SimpleInjector.Diagnostics.ContainerAnalyzerProvider : object {
    [NullableAttribute("1")]
internal static ReadOnlyCollection`1<IContainerAnalyzer> Analyzers;
    private static ContainerAnalyzerProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.ContainerRegisteredServiceDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<KnownRelationship> <Relationships>k__BackingField;
    public ReadOnlyCollection`1<KnownRelationship> Relationships { get; }
    internal ContainerRegisteredServiceDiagnosticResult(Type serviceType, string description, IEnumerable`1<KnownRelationship> relationships);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<KnownRelationship> get_Relationships();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.Debugger.ContainerDebugView : object {
    [DebuggerBrowsableAttribute("0")]
private Container container;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DebuggerViewItem[] <Items>k__BackingField;
    public ContainerOptions Options { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("")]
[DebuggerBrowsableAttribute("3")]
public DebuggerViewItem[] Items { get; private set; }
    public ContainerDebugView(Container container);
    public ContainerOptions get_Options();
    [CompilerGeneratedAttribute]
public DebuggerViewItem[] get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(DebuggerViewItem[] value);
    private void Initialize();
    private DebuggerViewItem[] GetAnalysisResults();
    private static DebuggerViewItem[] GetDebuggerTypeProxyFailureResults(Exception exception);
    private Object[] GroupProducers(IEnumerable`1<InstanceProducer> producers);
    private Object[] GroupProducers(IEnumerable`1<InstanceProducer> producers, int level);
    private object BuildProducerGroup(Type groupType, InstanceProducer[] producersForGroup, int level);
    private object BuildGenericGroup(Type groupType, InstanceProducer[] producersForGroup, int level);
    private static DebuggerViewItem BuildNonGenericGroup(Type closedType, InstanceProducer[] producersForGroup);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Description, nq}")]
internal class SimpleInjector.Diagnostics.Debugger.DebuggerViewItem : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
public string Description { get; }
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("3")]
public object Value { get; }
    internal DebuggerViewItem(string name, string description, object value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("DiagnosticGroup (Name: {Name, nq})")]
public class SimpleInjector.Diagnostics.DiagnosticGroup : object {
    [CompilerGeneratedAttribute]
private Type <GroupType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticType <DiagnosticType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DiagnosticGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<DiagnosticGroup> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<DiagnosticResult> <Results>k__BackingField;
    [DebuggerDisplayAttribute("{SimpleInjector.TypesExtensions.ToFriendlyName(GroupType), nq}")]
public Type GroupType { get; }
    [DebuggerDisplayAttribute("{Name, nq}")]
public string Name { get; }
    [DebuggerDisplayAttribute("{Description, nq}")]
public string Description { get; }
    public DiagnosticType DiagnosticType { get; }
    [NullableAttribute("2")]
public DiagnosticGroup Parent { get; private set; }
    public ReadOnlyCollection`1<DiagnosticGroup> Children { get; }
    public ReadOnlyCollection`1<DiagnosticResult> Results { get; }
    internal DiagnosticGroup(DiagnosticType diagnosticType, Type groupType, string name, string description, IEnumerable`1<DiagnosticGroup> children, IEnumerable`1<DiagnosticResult> results);
    [CompilerGeneratedAttribute]
public Type get_GroupType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public DiagnosticType get_DiagnosticType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DiagnosticGroup get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(DiagnosticGroup value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<DiagnosticGroup> get_Children();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<DiagnosticResult> get_Results();
    private void InitializeChildren();
    private void InitializeResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SimpleInjector.Diagnostics.DiagnosticResult : object {
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticType <DiagnosticType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DiagnosticGroup <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public DiagnosticSeverity Severity { get; }
    public DiagnosticType DiagnosticType { get; }
    [DebuggerDisplayAttribute("{SimpleInjector.TypesExtensions.ToFriendlyName(ServiceType),nq}")]
public Type ServiceType { get; }
    [DebuggerDisplayAttribute("{Description, nq}")]
public string Description { get; }
    [DebuggerDisplayAttribute("{DocumentationUrl, nq}")]
public Uri DocumentationUrl { get; }
    [NullableAttribute("2")]
public DiagnosticGroup Group { get; internal set; }
    [DebuggerHiddenAttribute]
internal object Value { get; }
    [DebuggerHiddenAttribute]
internal string Name { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal DiagnosticResult(Type serviceType, string description, DiagnosticType diagnosticType, DiagnosticSeverity severity, object value);
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_Severity();
    [CompilerGeneratedAttribute]
public DiagnosticType get_DiagnosticType();
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Description();
    public Uri get_DocumentationUrl();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DiagnosticGroup get_Group();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Group(DiagnosticGroup value);
    [CompilerGeneratedAttribute]
internal object get_Value();
    internal string get_Name();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Diagnostics.DiagnosticResultGrouper : object {
    private IContainerAnalyzer analyzer;
    internal DiagnosticResultGrouper(IContainerAnalyzer analyzer);
    internal static DiagnosticGroup Group(IContainerAnalyzer analyzer, DiagnosticResult[] results);
    internal DiagnosticGroup Group(DiagnosticResult[] results);
    private DiagnosticGroup[] GroupResults(IEnumerable`1<DiagnosticResult> results, int level);
    private static Type MakeTypePartiallyGenericUpToLevel(Type serviceType, int level);
    private DiagnosticGroup BuildDiagnosticGroup(Type groupType, IEnumerable`1<DiagnosticResult> results, int level);
    private DiagnosticGroup BuildGenericGroup(Type groupType, IEnumerable`1<DiagnosticResult> results, int level);
    private DiagnosticGroup BuildNonGenericGroup(Type closedType, IEnumerable`1<DiagnosticResult> results);
    private static DiagnosticResult[] GetGroupResults(IEnumerable`1<DiagnosticResult> results, int level);
}
public enum SimpleInjector.Diagnostics.DiagnosticSeverity : Enum {
    public int value__;
    public static DiagnosticSeverity Information;
    public static DiagnosticSeverity Warning;
}
public enum SimpleInjector.Diagnostics.DiagnosticType : Enum {
    public int value__;
    [DocumentationAttribute("Container-Registered Component", "https://simpleinjector.org/diaut")]
public static DiagnosticType ContainerRegisteredComponent;
    [DocumentationAttribute("Lifestyle Mismatch", "https://simpleinjector.org/dialm")]
public static DiagnosticType LifestyleMismatch;
    [DocumentationAttribute("Short Circuited Dependency", "https://simpleinjector.org/diasc")]
public static DiagnosticType ShortCircuitedDependency;
    [DocumentationAttribute("SRP Violation", "https://simpleinjector.org/diasr")]
public static DiagnosticType SingleResponsibilityViolation;
    [DocumentationAttribute("Torn Lifestyle", "https://simpleinjector.org/diatl")]
public static DiagnosticType TornLifestyle;
    [DocumentationAttribute("Disposable Transient Component", "https://simpleinjector.org/diadt")]
public static DiagnosticType DisposableTransientComponent;
    [DocumentationAttribute("Ambiguous Lifestyles", "https://simpleinjector.org/diaal")]
public static DiagnosticType AmbiguousLifestyles;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.DisposableTransientComponentDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private InstanceProducer <Registration>k__BackingField;
    public InstanceProducer Registration { get; }
    internal DisposableTransientComponentDiagnosticResult(Type serviceType, InstanceProducer registration, string description);
    [CompilerGeneratedAttribute]
public InstanceProducer get_Registration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class SimpleInjector.Diagnostics.DocumentationAttribute : Attribute {
    public string Name;
    public Uri DocumentationUrl;
    public DocumentationAttribute(string name, string documentationUrl);
    internal static DocumentationAttribute GetDocumentationAttribute(DiagnosticType value);
}
[NullableContextAttribute("1")]
internal interface SimpleInjector.Diagnostics.IContainerAnalyzer {
    public DiagnosticType DiagnosticType { get; }
    public string Name { get; }
    public abstract virtual DiagnosticType get_DiagnosticType();
    public abstract virtual string get_Name();
    public abstract virtual string GetRootDescription(DiagnosticResult[] results);
    public abstract virtual string GetGroupDescription(IEnumerable`1<DiagnosticResult> results);
    public abstract virtual DiagnosticResult[] Analyze(IEnumerable`1<InstanceProducer> producers);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class SimpleInjector.Diagnostics.KnownRelationshipCollection : Collection`1<KnownRelationship> {
    [CompilerGeneratedAttribute]
private bool <HasChanged>k__BackingField;
    public bool HasChanged { get; private set; }
    internal KnownRelationshipCollection(List`1<KnownRelationship> relationships);
    [CompilerGeneratedAttribute]
public bool get_HasChanged();
    [CompilerGeneratedAttribute]
private void set_HasChanged(bool value);
    protected virtual void InsertItem(int index, KnownRelationship item);
    protected virtual void SetItem(int index, KnownRelationship item);
    protected virtual void RemoveItem(int index);
}
internal static class SimpleInjector.Diagnostics.LifestyleMismatchChecker : object {
    [NullableContextAttribute("1")]
internal static bool HasLifestyleMismatch(Container container, KnownRelationship relationship);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.LifestyleMismatchDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private KnownRelationship <Relationship>k__BackingField;
    public KnownRelationship Relationship { get; }
    internal LifestyleMismatchDiagnosticResult(Type serviceType, string description, KnownRelationship relationship);
    [CompilerGeneratedAttribute]
public KnownRelationship get_Relationship();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.ShortCircuitedDependencyDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private KnownRelationship <Relationship>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<InstanceProducer> <ExpectedDependencies>k__BackingField;
    public KnownRelationship Relationship { get; }
    public ReadOnlyCollection`1<InstanceProducer> ExpectedDependencies { get; }
    internal ShortCircuitedDependencyDiagnosticResult(Type serviceType, string description, InstanceProducer registration, KnownRelationship relationship, IEnumerable`1<InstanceProducer> expectedDependencies);
    [CompilerGeneratedAttribute]
public KnownRelationship get_Relationship();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<InstanceProducer> get_ExpectedDependencies();
    private static DebuggerViewItem[] CreateDebugValue(InstanceProducer registration, KnownRelationship actualDependency, InstanceProducer[] possibleSkippedRegistrations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.SingleResponsibilityViolationDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<InstanceProducer> <Dependencies>k__BackingField;
    public Type ImplementationType { get; }
    public ReadOnlyCollection`1<InstanceProducer> Dependencies { get; }
    internal SingleResponsibilityViolationDiagnosticResult(Type serviceType, string description, Type implementationType, IEnumerable`1<InstanceProducer> dependencies);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<InstanceProducer> get_Dependencies();
    private static DebuggerViewItem[] GetDebugValue(Type implementationType, InstanceProducer[] dependencies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.Diagnostics.TornLifestyleDiagnosticResult : DiagnosticResult {
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<InstanceProducer> <AffectedRegistrations>k__BackingField;
    public Lifestyle Lifestyle { get; }
    public Type ImplementationType { get; }
    public ReadOnlyCollection`1<InstanceProducer> AffectedRegistrations { get; }
    internal TornLifestyleDiagnosticResult(Type serviceType, string description, Lifestyle lifestyle, Type implementationType, InstanceProducer[] affectedRegistrations);
    [CompilerGeneratedAttribute]
public Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<InstanceProducer> get_AffectedRegistrations();
    private static DebuggerViewItem[] CreateDebugValue(Type implementationType, Lifestyle lifestyle, InstanceProducer[] affectedRegistrations);
    private static string ToCommaSeparatedText(IEnumerable`1<InstanceProducer> producers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Diagnostics.TypeGeneralizer : object {
    internal static Type MakeTypePartiallyGenericUpToLevel(Type type, int nestingLevel);
    private static Type MakeTypePartiallyGeneric(Type type, int nestingLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.DiagnosticVerificationException : Exception {
    private static ReadOnlyCollection`1<DiagnosticResult> Empty;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<DiagnosticResult> <Errors>k__BackingField;
    public ReadOnlyCollection`1<DiagnosticResult> Errors { get; }
    public DiagnosticVerificationException(string message);
    public DiagnosticVerificationException(IList`1<DiagnosticResult> errors);
    public DiagnosticVerificationException(string message, Exception innerException);
    internal DiagnosticVerificationException(string message, DiagnosticResult error);
    private static DiagnosticVerificationException();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<DiagnosticResult> get_Errors();
    private static string BuildMessage(IList`1<DiagnosticResult> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ExpressionBuildingEventArgs ({DebuggerDisplay), nq})")]
public class SimpleInjector.ExpressionBuildingEventArgs : EventArgs {
    private Expression expression;
    [CompilerGeneratedAttribute]
private Type <KnownImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<KnownRelationship> <KnownRelationships>k__BackingField;
    public Type KnownImplementationType { get; }
    public Lifestyle Lifestyle { get; }
    public Expression Expression { get; public set; }
    public Collection`1<KnownRelationship> KnownRelationships { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal ExpressionBuildingEventArgs(Type knownImplementationType, Expression expression, Lifestyle lifestyle, Collection`1<KnownRelationship> knownRelationships);
    [CompilerGeneratedAttribute]
public Type get_KnownImplementationType();
    [CompilerGeneratedAttribute]
public Lifestyle get_Lifestyle();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public Collection`1<KnownRelationship> get_KnownRelationships();
    [CompilerGeneratedAttribute]
internal void set_KnownRelationships(Collection`1<KnownRelationship> value);
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ExpressionBuiltEventArgs ({DebuggerDisplay, nq})")]
public class SimpleInjector.ExpressionBuiltEventArgs : EventArgs {
    private Expression expression;
    private Lifestyle lifestyle;
    [CompilerGeneratedAttribute]
private Type <RegisteredServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<KnownRelationship> <KnownRelationships>k__BackingField;
    [CompilerGeneratedAttribute]
private Registration <ReplacedRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceProducer <InstanceProducer>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ServiceTypeDecoratorInfo <DecoratorInfo>k__BackingField;
    [DebuggerDisplayAttribute("{SimpleInjector.TypesExtensions.ToFriendlyName(RegisteredServiceType), nq}")]
public Type RegisteredServiceType { get; }
    public Expression Expression { get; public set; }
    public Lifestyle Lifestyle { get; public set; }
    public Collection`1<KnownRelationship> KnownRelationships { get; internal set; }
    internal Registration ReplacedRegistration { get; internal set; }
    internal InstanceProducer InstanceProducer { get; internal set; }
    [NullableAttribute("2")]
internal ServiceTypeDecoratorInfo DecoratorInfo { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal ExpressionBuiltEventArgs(Type registeredServiceType, Expression expression, InstanceProducer producer, Registration replacedRegistration, Collection`1<KnownRelationship> knownRelationships);
    [CompilerGeneratedAttribute]
public Type get_RegisteredServiceType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public Lifestyle get_Lifestyle();
    public void set_Lifestyle(Lifestyle value);
    [CompilerGeneratedAttribute]
public Collection`1<KnownRelationship> get_KnownRelationships();
    [CompilerGeneratedAttribute]
internal void set_KnownRelationships(Collection`1<KnownRelationship> value);
    [CompilerGeneratedAttribute]
internal Registration get_ReplacedRegistration();
    [CompilerGeneratedAttribute]
internal void set_ReplacedRegistration(Registration value);
    [CompilerGeneratedAttribute]
internal InstanceProducer get_InstanceProducer();
    [CompilerGeneratedAttribute]
internal void set_InstanceProducer(InstanceProducer value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ServiceTypeDecoratorInfo get_DecoratorInfo();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DecoratorInfo(ServiceTypeDecoratorInfo value);
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Helpers : object {
    internal static int CombineHashes(int a, int b);
    [NullableContextAttribute("2")]
internal static int Hash(object a);
    [NullableContextAttribute("2")]
internal static int Hash(object a, object b);
    [NullableContextAttribute("2")]
internal static int Hash(object a, object b, object c, object d);
    internal static LazyEx`1<T> ToLazy(T value);
    [ExtensionAttribute]
internal static T AddReturn(HashSet`1<T> set, T value);
    [ExtensionAttribute]
internal static string ToCommaSeparatedText(IEnumerable`1<string> values);
    [ExtensionAttribute]
internal static IEnumerable`1<T> MakeReadOnly(IEnumerable`1<T> collection);
    internal static void InterlockedAddAndReplace(Dictionary`2& source, TKey key, TValue value);
    [ExtensionAttribute]
internal static Dictionary`2<TKey, TValue> MakeCopy(Dictionary`2<TKey, TValue> source);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> source, TKey key);
    internal static void VerifyCollection(IEnumerable collection, Type serviceType);
    internal static Action`1<T> CreateAction(object action);
    internal static IEnumerable CastCollection(IEnumerable collection, Type resultType);
    [ExtensionAttribute]
internal static Tuple`2<List`1<T>, List`1<T>> Partition(T[] collection, Predicate`1<T> predicate);
    internal static MethodInfo GetMethod(Expression`1<Action> methodCall);
    internal static MethodInfo GetGenericMethodDefinition(Expression`1<Action> methodCall);
    internal static ConstructorInfo GetConstructor(Expression`1<Func`1<T>> constructorCall);
    private static IEnumerable`1<T> CreateReadOnlyCollection(IEnumerable`1<T> collection);
    [IteratorStateMachineAttribute("SimpleInjector.Helpers/<Collections_Register_Enumerable>d__19`1")]
private static IEnumerable`1<T> Collections_Register_Enumerable(IEnumerable`1<T> collection);
    private static void ThrowWhenCollectionCanNotBeIterated(IEnumerable collection, Type serviceType, Action`1<object> itemProcessor);
    private static void ThrowWhenCollectionContainsNullElements(Type serviceType, bool collectionContainsNullItems);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.InjectionConsumerInfo : ApiObject {
    internal static InjectionConsumerInfo Root;
    private Type implementationType;
    private InjectionTargetInfo target;
    public Type ImplementationType { get; }
    public InjectionTargetInfo Target { get; }
    internal bool IsRoot { get; }
    public InjectionConsumerInfo(ParameterInfo parameter);
    public InjectionConsumerInfo(Type implementationType, PropertyInfo property);
    private static InjectionConsumerInfo();
    public Type get_ImplementationType();
    public InjectionTargetInfo get_Target();
    internal bool get_IsRoot();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(InjectionConsumerInfo other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.InjectionTargetInfo : ApiObject {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [NullableAttribute("2")]
public ParameterInfo Parameter { get; }
    [NullableAttribute("2")]
public PropertyInfo Property { get; }
    public string Name { get; }
    public Type TargetType { get; }
    public MemberInfo Member { get; }
    internal string DebuggerDisplay { get; }
    private object Target { get; }
    internal InjectionTargetInfo(ParameterInfo parameter);
    internal InjectionTargetInfo(PropertyInfo property);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    public string get_Name();
    public Type get_TargetType();
    public MemberInfo get_Member();
    internal string get_DebuggerDisplay();
    private object get_Target();
    public Object[] GetCustomAttributes(bool inherit);
    public Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public bool IsDefined(Type attributeType, bool inherit);
    public T GetCustomAttribute();
    public T GetCustomAttribute(bool inherit);
    public Attribute GetCustomAttribute(Type attributeType);
    public Attribute GetCustomAttribute(Type attributeType, bool inherit);
    public IEnumerable`1<T> GetCustomAttributes();
    public IEnumerable`1<T> GetCustomAttributes(bool inherit);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(InjectionTargetInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("SimpleInjector.InstanceProducer/InstanceProducerDebugView")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class SimpleInjector.InstanceProducer : object {
    internal static IEqualityComparer`1<InstanceProducer> EqualityComparer;
    private static Predicate`1<PredicateContext> Always;
    private object locker;
    private LazyEx`1<Expression> lazyExpression;
    [NullableAttribute("2")]
private CyclicDependencyValidator validator;
    private Func`1<object> instanceCreator;
    private Nullable`1<bool> isValid;
    [NullableAttribute("2")]
private Lifestyle overriddenLifestyle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyCollection`1<KnownRelationship> knownRelationships;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action`1<Scope>> verifiers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<InstanceProducer> wrappedProducers;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Registration <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsContainerAutoRegistered>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<PredicateContext> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDecorated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstanceSuccessfullyCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerifiersAreSuccessfullyCalled>k__BackingField;
    public Lifestyle Lifestyle { get; }
    public Type ServiceType { get; }
    public Registration Registration { get; private set; }
    public Type ImplementationType { get; }
    internal Type FinalImplementationType { get; }
    internal Container Container { get; }
    internal bool IsContainerAutoRegistered { get; internal set; }
    internal bool IsValid { get; }
    [NullableAttribute("2")]
internal Exception Exception { get; private set; }
    internal Predicate`1<PredicateContext> Predicate { get; }
    internal bool IsDecorated { get; internal set; }
    internal bool IsConditional { get; }
    internal bool IsUnconditional { get; }
    internal bool IsExpressionCreated { get; }
    internal bool MustBeExplicitlyVerified { get; }
    internal bool InstanceSuccessfullyCreated { get; private set; }
    internal bool VerifiersAreSuccessfullyCalled { get; private set; }
    internal string DebuggerDisplay { get; }
    internal IEnumerable`1<InstanceProducer> SelfAndWrappedProducers { get; }
    private IEnumerable`1<InstanceProducer> Self { get; }
    public InstanceProducer(Type serviceType, Registration registration);
    internal InstanceProducer(Type serviceType, Registration registration, Predicate`1<PredicateContext> predicate);
    internal InstanceProducer(Type serviceType, Registration registration, bool registerExternalProducer);
    private InstanceProducer(Type serviceType, Expression expression, Container container);
    private static InstanceProducer();
    public Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public Registration get_Registration();
    [CompilerGeneratedAttribute]
private void set_Registration(Registration value);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    internal Type get_FinalImplementationType();
    internal Container get_Container();
    [CompilerGeneratedAttribute]
internal bool get_IsContainerAutoRegistered();
    [CompilerGeneratedAttribute]
internal void set_IsContainerAutoRegistered(bool value);
    internal bool get_IsValid();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Exception get_Exception();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
internal Predicate`1<PredicateContext> get_Predicate();
    [CompilerGeneratedAttribute]
internal bool get_IsDecorated();
    [CompilerGeneratedAttribute]
internal void set_IsDecorated(bool value);
    internal bool get_IsConditional();
    internal bool get_IsUnconditional();
    internal bool get_IsExpressionCreated();
    internal bool get_MustBeExplicitlyVerified();
    [CompilerGeneratedAttribute]
internal bool get_InstanceSuccessfullyCreated();
    [CompilerGeneratedAttribute]
private void set_InstanceSuccessfullyCreated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_VerifiersAreSuccessfullyCalled();
    [CompilerGeneratedAttribute]
private void set_VerifiersAreSuccessfullyCalled(bool value);
    internal string get_DebuggerDisplay();
    internal IEnumerable`1<InstanceProducer> get_SelfAndWrappedProducers();
    private IEnumerable`1<InstanceProducer> get_Self();
    public static InstanceProducer FromExpression(Type serviceType, Expression expression, Container container);
    public object GetInstance(Scope scope);
    public object GetInstance();
    public Expression BuildExpression();
    public KnownRelationship[] GetRelationships();
    public string VisualizeObjectGraph();
    public string VisualizeObjectGraph(VisualizationOptions options);
    internal bool ContainsScopedComponentsInGraph();
    internal Expression VerifyExpressionBuilding();
    internal object VerifyInstanceCreation();
    internal void AddVerifier(Action`1<Scope> action);
    internal void AddProducerToVerify(InstanceProducer currentProducer);
    internal void ReplaceRelationships(IEnumerable`1<KnownRelationship> relationships);
    internal void EnsureTypeWillBeExplicitlyVerified();
    internal void DoExtraVerfication(Scope scope);
    private static bool ContainsScopedComponentsInGraph(InstanceProducer producer);
    private static bool ContainsScopedComponentsInGraphRecursive(InstanceProducer producer);
    private Action`1[] GetVerifiers();
    private Func`1<object> BuildInstanceCreator();
    private void Analyze();
    private Expression BuildExpressionInternal();
    private bool MustWrapThrownException(Exception ex);
    private string BuildActivationExceptionMessage(Exception innerException);
    private object BuildAndReplaceInstanceCreatorAndCreateFirstInstance();
    private void CheckForCyclicDependencies();
    private void RemoveCyclicDependencyValidator();
    private void ResetCyclicDependencyValidator();
    [NullableContextAttribute("2")]
private Exception GetExceptionIfInvalid();
    private static bool ShouldBeRegisteredAsAnExternalProducer(Registration registration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.InstanceProducer`1 : InstanceProducer {
    public InstanceProducer`1(Registration registration);
    public TService GetInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
internal class SimpleInjector.Internals.ArgumentMapping : object {
    [CompilerGeneratedAttribute]
private Type <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConcreteType>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    [DebuggerDisplayAttribute("{Argument, nq}")]
internal Type Argument { get; }
    [DebuggerDisplayAttribute("{ConcreteType, nq}")]
internal Type ConcreteType { get; }
    internal bool TypeConstraintsAreSatisfied { get; }
    private TypeConstraintValidator Validator { get; }
    internal ArgumentMapping(Type argument, Type concreteType);
    internal string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
internal Type get_Argument();
    [CompilerGeneratedAttribute]
internal Type get_ConcreteType();
    internal bool get_TypeConstraintsAreSatisfied();
    private TypeConstraintValidator get_Validator();
    private sealed virtual override bool System.IEquatable<SimpleInjector.Internals.ArgumentMapping>.Equals(ArgumentMapping other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal static ArgumentMapping Create(Type argument, Type concreteType);
    internal static ArgumentMapping[] Zip(Type[] arguments, Type[] concreteTypes);
    internal bool ConcreteTypeMatchesPartialArgument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SimpleInjector.Internals.CollectionResolver : object {
    private List`1<RegistrationGroup> registrationGroups;
    private Dictionary`2<Type, InstanceProducer> producerCache;
    private bool verified;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    protected IEnumerable`1<RegistrationGroup> RegistrationGroups { get; }
    protected Type ServiceType { get; }
    protected Container Container { get; }
    protected CollectionResolver(Container container, Type serviceType);
    protected IEnumerable`1<RegistrationGroup> get_RegistrationGroups();
    [CompilerGeneratedAttribute]
protected Type get_ServiceType();
    [CompilerGeneratedAttribute]
protected Container get_Container();
    internal abstract virtual void AddControlledRegistrations(Type serviceType, ContainerControlledItem[] items, bool append);
    internal abstract virtual void RegisterUncontrolledCollection(Type serviceType, InstanceProducer producer);
    internal InstanceProducer TryGetInstanceProducer(Type elementType);
    internal void ResolveUnregisteredType(object sender, UnregisteredTypeEventArgs e);
    internal void TriggerUnregisteredTypeResolutionOnAllClosedCollections();
    protected abstract virtual Type[] GetAllKnownClosedServiceTypes();
    protected abstract virtual InstanceProducer BuildCollectionProducer(Type closedServiceType);
    protected void AddRegistrationGroup(RegistrationGroup group);
    private InstanceProducer GetInstanceProducerFromCache(Type closedServiceType);
    private void RemoveRegistrationsToOverride(Type serviceType);
    private void CheckForOverlappingRegistrations(Type serviceType);
    private IEnumerable`1<RegistrationGroup> GetOverlappingGroupsFor(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Internals.CompilationHelpers : object {
    private static ConstructorInfo LazyScopeConstructor;
    private static CompilationHelpers();
    public static Func`1<TResult> CreateConstantValueDelegate(Expression expression);
    internal static Func`1<TResult> CompileExpression(Container container, Expression expression);
    internal static Delegate CompileExpression(Container container, Expression expression, Dictionary`2<Expression, InvocationExpression> reducedNodes);
    internal static Expression OptimizeScopedRegistrationsInObjectGraph(Container container, Expression expression);
    internal static Func`1<TService> CompileLambda(Expression expression);
    private static Expression OptimizeExpression(Container container, Expression expression, OptimizableLifestyleInfo[] lifestyleInfos);
    private static NewExpression CreateNewLazyScopeExpression(Func`1<Scope> scopeFactory, Container container);
    private static NewExpression CreateNewLazyScopedRegistration(Registration registration);
    private static Expression ReduceObjectGraphSize(Expression expression, Container container, Dictionary`2<Expression, InvocationExpression> reducedNodes);
    private static InvocationExpression CompileToInvocation(Expression expression, Container container, Dictionary`2<Expression, InvocationExpression> reducedNodes);
    private static Expression FindMostReductiveNodeOrNull(NodeSizes results, int maximumNumberOfNodesPerDelegate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ConditionalHashSet`1 : object {
    private static int ShrinkStepCount;
    private static Predicate`1<WeakReference> IsDead;
    private Dictionary`2<int, List`1<WeakReference>> dictionary;
    private int shrinkCount;
    private static ConditionalHashSet`1();
    internal void Add(T item);
    internal void Remove(T item);
    internal T[] GetLivingItems();
    private WeakReference GetWeakReferenceOrNull(T item);
    private void RemoveDeadItems();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class SimpleInjector.Internals.ContainerControlledCollection`1 : object {
    private static InjectionConsumerInfo ConsumerInfo;
    private Container container;
    private List`1<LazyEx`1<InstanceProducer>> lazyProducers;
    private LazyEx`1<InstanceProducer[]> producers;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InstanceProducer <ParentProducer>k__BackingField;
    public InjectionConsumerInfo InjectionConsumerInfo { get; }
    public bool AllProducersVerified { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TService>.IsReadOnly { get; }
    [NullableAttribute("2")]
internal InstanceProducer ParentProducer { get; internal set; }
    public TService Item { get; public set; }
    public ContainerControlledCollection`1(Container container);
    protected ContainerControlledCollection`1(Container container, ContainerControlledCollection`1<TService> definition);
    internal ContainerControlledCollection`1(TService services);
    private static ContainerControlledCollection`1();
    public sealed virtual InjectionConsumerInfo get_InjectionConsumerInfo();
    public sealed virtual bool get_AllProducersVerified();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TService>.get_IsReadOnly();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal InstanceProducer get_ParentProducer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ParentProducer(InstanceProducer value);
    public virtual TService get_Item(int index);
    public virtual void set_Item(int index, TService value);
    public sealed virtual void VerifyCreatingProducers();
    public virtual int IndexOf(TService item);
    private sealed virtual override void System.Collections.Generic.IList<TService>.Insert(int index, TService item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<TService>.Add(TService item);
    private sealed virtual override void System.Collections.Generic.ICollection<TService>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TService>.Contains(TService item);
    public virtual void CopyTo(TService[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TService>.Remove(TService item);
    private sealed virtual override void SimpleInjector.Internals.IContainerControlledCollection.Clear();
    private sealed virtual override void SimpleInjector.Internals.IContainerControlledCollection.Append(ContainerControlledItem item);
    public sealed virtual InstanceProducer[] GetProducers();
    public virtual IEnumerator`1<TService> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected static TService GetInstance(InstanceProducer producer);
    private static object VerifyCreatingProducer(LazyEx`1<InstanceProducer> lazy);
    private LazyEx`1<InstanceProducer> ToLazyInstanceProducer(ContainerControlledItem item);
    private static LazyEx`1<InstanceProducer> ToLazyInstanceProducer(Registration registration);
    private InstanceProducer GetOrCreateInstanceProducer(ContainerControlledItem item);
    private static bool AreAmbiguous(ContainerControlledItem item, InstanceProducer producer);
    private InstanceProducer GetExplicitRegisteredInstanceProducer(Type implementationType);
    private InstanceProducer GetInstanceProducerThroughUnregisteredTypeResolution(Type implementationType);
    private InstanceProducer CreateNewExternalProducer(ContainerControlledItem item);
    private static NotSupportedException GetNotSupportedBecauseReadOnlyException();
    private void ThrowWhenCollectionAlreadyHasBeenIterated();
    [CompilerGeneratedAttribute]
private InstanceProducer[] <.ctor>b__4_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Internals.ContainerControlledCollectionExtensions : object {
    [ExtensionAttribute]
internal static void AppendAll(IContainerControlledCollection collection, IEnumerable`1<ContainerControlledItem> items);
    [ExtensionAttribute]
internal static void AppendAll(IContainerControlledCollection collection, IEnumerable`1<Registration> registrations);
    [ExtensionAttribute]
internal static void AppendAll(IContainerControlledCollection collection, IEnumerable`1<Type> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ContainerControlledCollectionResolver : CollectionResolver {
    internal ContainerControlledCollectionResolver(Container container, Type openGenericServiceType);
    internal virtual void RegisterUncontrolledCollection(Type serviceType, InstanceProducer producer);
    internal virtual void AddControlledRegistrations(Type serviceType, ContainerControlledItem[] items, bool append);
    protected virtual InstanceProducer BuildCollectionProducer(Type closedServiceType);
    protected virtual Type[] GetAllKnownClosedServiceTypes();
    private ContainerControlledItem[] GetClosedContainerControlledItemsFor(Type serviceType);
    private IEnumerable`1<ContainerControlledItem> GetItemsFor(Type closedGenericServiceType);
    private static ContainerControlledItem[] GetClosedGenericImplementationsFor(Type closedGenericServiceType, IEnumerable`1<ContainerControlledItem> containerControlledItems);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Type> <GetAllKnownClosedServiceTypes>b__4_4(<>f__AnonymousType49`2<<>f__AnonymousType48`2<RegistrationGroup, ContainerControlledItem>, Type> <>h__TransparentIdentifier1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ContainerControlledItem ({DebuggerDisplay, nq})")]
internal class SimpleInjector.Internals.ContainerControlledItem : object {
    public Type ImplementationType;
    [NullableAttribute("2")]
public Registration Registration;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RegisteredImplementationType>k__BackingField;
    [NullableAttribute("2")]
public Lifestyle Lifestyle { get; }
    internal Type RegisteredImplementationType { get; internal set; }
    internal string DebuggerDisplay { get; }
    private ContainerControlledItem(Registration registration);
    private ContainerControlledItem(Type implementationType, Lifestyle lifestyle);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
internal Type get_RegisteredImplementationType();
    [CompilerGeneratedAttribute]
internal void set_RegisteredImplementationType(Type value);
    internal string get_DebuggerDisplay();
    public static ContainerControlledItem CreateFromRegistration(Registration registration);
    public static ContainerControlledItem CreateFromType(Type implementationType);
    public static ContainerControlledItem CreateFromType(Type implementationType, Lifestyle lifestyle);
    public static ContainerControlledItem CreateFromType(Type registeredImplementationType, Type closedImplementationType, Lifestyle lifestyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ContainerUncontrolledCollectionResolver : CollectionResolver {
    internal ContainerUncontrolledCollectionResolver(Container container, Type openGenericServiceType);
    internal virtual void AddControlledRegistrations(Type serviceType, ContainerControlledItem[] registrations, bool append);
    internal virtual void RegisterUncontrolledCollection(Type serviceType, InstanceProducer producer);
    protected virtual InstanceProducer BuildCollectionProducer(Type closedServiceType);
    protected virtual Type[] GetAllKnownClosedServiceTypes();
    private InstanceProducer[] GetAssignableProducers(Type closedServiceType);
    private InstanceProducer CombineProducersToOne(Type closedServiceType, InstanceProducer[] producers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Internals.ControlledCollectionHelper : object {
    private static object ServiceCreatedListenersLocker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<Action`1<ServiceCreatedListenerArgs>> serviceCreatedListeners;
    [CompilerGeneratedAttribute]
private static bool <ContainsServiceCreatedListeners>k__BackingField;
    internal static bool ContainsServiceCreatedListeners { get; private set; }
    private static ControlledCollectionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_ContainsServiceCreatedListeners();
    [CompilerGeneratedAttribute]
private static void set_ContainsServiceCreatedListeners(bool value);
    internal static void AddServiceCreatedListener(Action`1<ServiceCreatedListenerArgs> serviceCreated);
    internal static void RemoveServiceCreatedListener(Action`1<ServiceCreatedListenerArgs> serviceCreated);
    internal static void NotifyServiceCreatedListeners(InstanceProducer producer);
    internal static IContainerControlledCollection ExtractContainerControlledCollectionFromRegistration(Registration registration);
    internal static IContainerControlledCollection CreateContainerControlledCollection(Type serviceType, Container container);
    [ExtensionAttribute]
internal static InstanceProducer CreateInstanceProducer(ContainerControlledCollection`1<TService> collection, Container container);
    [ExtensionAttribute]
internal static Registration CreateRegistration(IContainerControlledCollection instance, Type collectionType, Container container);
    private static ScopedRegistration TryCreateRegistrationForFlowingCollection(IContainerControlledCollection instance, Type collectionType, Container container);
    private static bool ContainsScopedComponents(IContainerControlledCollection instance);
    internal static bool IsContainerControlledCollectionExpression(Expression enumerableExpression);
    [ExtensionAttribute]
internal static bool IsContainerControlledCollection(InstanceProducer producer);
    [ExtensionAttribute]
internal static bool IsContainerControlledCollection(Registration registration);
    [ExtensionAttribute]
internal static Type GetContainerControlledCollectionElementType(InstanceProducer producer);
    private static Registration TryCreateRegistrationForCollectionOfT(Type collectionType, IContainerControlledCollection controlledCollection, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.CyclicDependencyException : ActivationException {
    private List`1<Type> types;
    [CompilerGeneratedAttribute]
private InstanceProducer <OriginatingProducer>k__BackingField;
    public string Message { get; }
    internal IEnumerable`1<Type> DependencyCycle { get; }
    internal InstanceProducer OriginatingProducer { get; }
    public CyclicDependencyException(InstanceProducer originatingProducer, Type typeToValidate);
    public virtual string get_Message();
    internal IEnumerable`1<Type> get_DependencyCycle();
    [CompilerGeneratedAttribute]
internal InstanceProducer get_OriginatingProducer();
    internal void AddTypeToCycle(Type type);
}
internal class SimpleInjector.Internals.CyclicDependencyValidator : object {
    [NullableAttribute("2")]
private List`1<int> enteredThreads;
    [NullableContextAttribute("1")]
internal void Check(InstanceProducer producer);
    internal void Reset();
    private bool IsCurrentThreadReentering();
    private void MarkCurrentThreadAsEntering();
    private void MarkCurrentThreadAsLeaving();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Internals.DisposableHelpers : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, Task> asyncDisposer;
    [NullableAttribute("2")]
private static Type AsyncDisposableInterface;
    internal static bool AsyncDisposableInterfaceFound { get; }
    internal static bool get_AsyncDisposableInterfaceFound();
    internal static bool IsAsyncOrAsyncDisposable(object instance);
    internal static bool IsAsyncDisposable(object instance);
    internal static bool IsSyncOrAsyncDisposableType(Type type);
    internal static bool IsAsyncDisposableType(Type type);
    internal static Task DisposeAsync(object asyncDisposableInstance);
    private static Func`2<object, Task> CreateDisposer(Type asyncDisposableInterface);
    private static bool InitializeAsyncDisposableInterface(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class SimpleInjector.Internals.FlowingContainerControlledCollection`1 : ContainerControlledCollection`1<TService> {
    private Scope scope;
    public TService Item { get; public set; }
    public FlowingContainerControlledCollection`1(Scope scope, ContainerControlledCollection`1<TService> definition);
    public virtual TService get_Item(int index);
    public virtual void set_Item(int index, TService value);
    public virtual int IndexOf(TService item);
    public virtual void CopyTo(TService[] array, int arrayIndex);
    [IteratorStateMachineAttribute("SimpleInjector.Internals.FlowingContainerControlledCollection`1/<GetEnumerator>d__7")]
public virtual IEnumerator`1<TService> GetEnumerator();
    [NullableContextAttribute("2")]
private IDisposable ApplyScoping();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.FoundInstanceProducer : ValueType {
    public Type ServiceType;
    public Type ImplementationType;
    public InstanceProducer Producer;
    public FoundInstanceProducer(Type serviceType, Type implementationType, InstanceProducer producer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.GenericArgumentFinder : object {
    private IList`1<Type> serviceTypeDefinitionArguments;
    private Type[] serviceTypeToResolveArguments;
    private IList`1<Type> implementationTypeDefinitionArguments;
    private Type[] partialImplementationArguments;
    public GenericArgumentFinder(Type serviceTypeDefinition, Type serviceTypeToResolve, Type implementationTypeDefinition, Type partialOpenGenericImplementation);
    internal Type[] GetConcreteTypeArgumentsForClosedImplementation();
    private ArgumentMapping[] FindArgumentMappings();
    private IEnumerable`1<ArgumentMapping> GetOpenServiceArgumentToConcreteTypeMappings();
    private void ConvertToOpenImplementationArgumentMappings(IEnumerable`1& mappings);
    private void RemoveMappingsThatDoNotSatisfyAllTypeConstraints(IEnumerable`1& mappings);
    private bool CanBeMappedToSuppliedConcreteTypes(ArgumentMapping mapping);
    [IteratorStateMachineAttribute("SimpleInjector.Internals.GenericArgumentFinder/<ConvertToOpenImplementationArgumentMappings>d__11")]
private IEnumerable`1<ArgumentMapping> ConvertToOpenImplementationArgumentMappings(ArgumentMapping mapping, IList`1<Type> processedTypes);
    private ArgumentMapping[] GetTypeConstraintArgumentMappingsRecursive(ArgumentMapping mapping, IList`1<Type> processedTypes);
    private ArgumentMapping[] ConvertToOpenImplementationArgumentMappingsRecursive(ArgumentMapping mapping, IList`1<Type> processedTypes);
    private Type GetGenericArrayDefinition(Type type);
    private ArgumentMapping[] ConvertToOpenImplementationArgumentMappingsForType(ArgumentMapping mapping, Type type, IList`1<Type> processedTypes);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private int <GetConcreteTypeArgumentsForClosedImplementation>b__5_0(ArgumentMapping mapping);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ArgumentMapping> <ConvertToOpenImplementationArgumentMappings>b__8_0(ArgumentMapping mapping);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <RemoveMappingsThatDoNotSatisfyAllTypeConstraints>b__9_1(ArgumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.GenericRegistrationEntry : object {
    private List`1<IProducerProvider> providers;
    private ContainerOptions options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, ClosedToInstanceProducerProviderDictionaryEntry> closedProviders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<OpenGenericToInstanceProducerProvider> openProviders;
    private Container Container { get; }
    private bool AllowOverridingRegistrations { get; }
    private bool IsEmpty { get; }
    public IEnumerable`1<InstanceProducer> CurrentProducers { get; }
    internal GenericRegistrationEntry(Container container);
    private Container get_Container();
    private bool get_AllowOverridingRegistrations();
    private bool get_IsEmpty();
    public sealed virtual IEnumerable`1<InstanceProducer> get_CurrentProducers();
    public sealed virtual void Add(InstanceProducer producer);
    private void AddClosedToInstanceProducerProvider(ClosedToInstanceProducerProvider provider);
    public sealed virtual void AddGeneric(Type serviceType, Type implementationType, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public sealed virtual void Add(Type serviceType, Func`2<TypeFactoryContext, Type> implementationTypeFactory, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    private void AddOpenGenericToInstanceProducerProvider(OpenGenericToInstanceProducerProvider provider);
    public sealed virtual InstanceProducer TryGetInstanceProducer(Type serviceType, InjectionConsumerInfo consumer);
    public sealed virtual int GetNumberOfConditionalRegistrationsFor(Type serviceType);
    private IEnumerable`1<IProducerProvider> GetConditionalProvidersThatMatchType(Type serviceType);
    private void ThrowWhenOverlappingRegistrationsExist(InstanceProducer producerToRegister);
    private IProducerProvider GetFirstOverlappingProvider(InstanceProducer producerToRegister);
    private void ThrowWhenConditionalIsRegisteredInOverridingMode(InstanceProducer producer);
    private void ThrowWhenConditionalIsRegisteredInOverridingMode(OpenGenericToInstanceProducerProvider provider);
    private void ThrowWhenProviderToRegisterOverlapsWithExistingProvider(OpenGenericToInstanceProducerProvider providerToRegister);
    private IProducerProvider GetFirstOrDefaultSupersetProvidersFor(Type implementationType);
    private static InvalidOperationException GetAnOverlappingGenericRegistrationExistsException(IProducerProvider providerToRegister, IProducerProvider overlappingProvider);
    private List`1<FoundInstanceProducer> GetInstanceProducers(Type closedGenericServiceType, InjectionConsumerInfo consumer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.GenericTypeBuilder : object {
    [DebuggerDisplayAttribute("{SimpleInjector.TypesExtensions.ToFriendlyName(closedServiceType),nq}")]
private Type closedServiceType;
    [DebuggerDisplayAttribute("{SimpleInjector.TypesExtensions.ToFriendlyName(implementation),nq}")]
private Type implementation;
    private Type openGenericImplementation;
    [NullableAttribute("2")]
[DebuggerDisplayAttribute("{(partialOpenGenericImplementation == null ? "null" : SimpleInjector.TypesExtensions.ToFriendlyName(partialOpenGenericImplementation)),nq}")]
private Type partialOpenGenericImplementation;
    private bool isPartialOpenGenericImplementation;
    internal GenericTypeBuilder(Type closedServiceType, Type implementation);
    internal static bool IsImplementationApplicableToEveryGenericType(Type openAbstraction, Type openImplementation);
    internal static Type MakeClosedImplementation(Type closedAbstraction, Type openImplementation);
    internal bool OpenGenericImplementationCanBeAppliedToServiceType();
    private Type[] GetOpenGenericBaseTypes(Type openGenericBaseType);
    internal BuildResult BuildClosedGenericImplementation();
    private CandicateServiceType FindMatchingOpenGenericServiceType();
    private Type BuildClosedGenericImplementationBasedOnMatchingServiceType(CandicateServiceType candicateServiceType);
    private IEnumerable`1<CandicateServiceType> GetOpenCandidateServiceTypes();
    private CandicateServiceType ToCandicateServiceType(Type openCandidateServiceType);
    private bool MatchesClosedGenericBaseType(CandicateServiceType openCandidateServiceType);
    private bool SatisfiesGenericTypeConstraints(CandicateServiceType openCandidateServiceType);
    private bool SafisfiesPartialTypeArguments(CandicateServiceType candicateServiceType);
    private bool SafisfiesPartialTypeArguments(Type[] arguments);
    private Type[] GetMatchingGenericArgumentsForOpenImplementationBasedOn(Type openCandidateServiceType);
    private static IEnumerable`1<Type> GetNestedTypeArgumentsForType(Type type);
    private static IEnumerable`1<Type> GetNestedTypeArgumentsForTypeArgument(Type argument, IList`1<Type> processedArguments);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <OpenGenericImplementationCanBeAppliedToServiceType>b__8_0(Type type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <FindMatchingOpenGenericServiceType>b__11_0(CandicateServiceType openCandidateServiceType);
}
[NullableContextAttribute("1")]
internal interface SimpleInjector.Internals.IContainerControlledCollection {
    public bool AllProducersVerified { get; }
    public int Count { get; }
    public InjectionConsumerInfo InjectionConsumerInfo { get; }
    public abstract virtual bool get_AllProducersVerified();
    public abstract virtual int get_Count();
    public abstract virtual InjectionConsumerInfo get_InjectionConsumerInfo();
    public abstract virtual InstanceProducer[] GetProducers();
    public abstract virtual void Append(ContainerControlledItem item);
    public abstract virtual void Clear();
    public abstract virtual void VerifyCreatingProducers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Internals.InstanceProducerVisualizer : object {
    private static string ExpressionNotCreatedYetMessage;
    [ExtensionAttribute]
internal static string VisualizeIndentedObjectGraph(InstanceProducer producer, VisualizationOptions options);
    [ExtensionAttribute]
internal static string VisualizeInlinedAndTruncatedObjectGraph(InstanceProducer producer, int maxLength);
    [ExtensionAttribute]
private static void VisualizeIndentedObjectGraph(InstanceProducer producer, int indentingDepth, bool last, HashSet`1<InstanceProducer> set, ObjectGraphStringBuilder objectGraphBuilder);
    [ExtensionAttribute]
private static void VisualizeIndentedObjectSubGraph(InstanceProducer dependency, int indentingDepth, bool last, HashSet`1<InstanceProducer> set, ObjectGraphStringBuilder objectGraphBuilder);
    [IteratorStateMachineAttribute("SimpleInjector.Internals.InstanceProducerVisualizer/<VisualizeInlinedDependencies>d__5")]
[ExtensionAttribute]
private static IEnumerable`1<string> VisualizeInlinedDependencies(InstanceProducer producer, int maxLength);
}
[NullableContextAttribute("1")]
internal interface SimpleInjector.Internals.IRegistrationEntry {
    public IEnumerable`1<InstanceProducer> CurrentProducers { get; }
    public abstract virtual IEnumerable`1<InstanceProducer> get_CurrentProducers();
    public abstract virtual void Add(InstanceProducer producer);
    public abstract virtual void AddGeneric(Type serviceType, Type implementationType, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public abstract virtual void Add(Type serviceType, Func`2<TypeFactoryContext, Type> implementationTypeFactory, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public abstract virtual InstanceProducer TryGetInstanceProducer(Type serviceType, InjectionConsumerInfo consumer);
    public abstract virtual int GetNumberOfConditionalRegistrationsFor(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={value}")]
internal class SimpleInjector.Internals.LazyEx`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<T> factory;
    [NullableAttribute("2")]
private T value;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public LazyEx`1(Func`1<T> valueFactory);
    public LazyEx`1(T value);
    public bool get_IsValueCreated();
    public T get_Value();
    public virtual string ToString();
    private T InitializeAndReturn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.NonGenericRegistrationEntry : object {
    private List`1<IProducerProvider> providers;
    private Type nonGenericServiceType;
    private Container container;
    public IEnumerable`1<InstanceProducer> CurrentProducers { get; }
    private IEnumerable`1<InstanceProducer> ConditionalProducers { get; }
    private IEnumerable`1<InstanceProducer> UnconditionalProducers { get; }
    public NonGenericRegistrationEntry(Type nonGenericServiceType, Container container);
    public sealed virtual IEnumerable`1<InstanceProducer> get_CurrentProducers();
    private IEnumerable`1<InstanceProducer> get_ConditionalProducers();
    private IEnumerable`1<InstanceProducer> get_UnconditionalProducers();
    public sealed virtual int GetNumberOfConditionalRegistrationsFor(Type serviceType);
    public sealed virtual void Add(InstanceProducer producer);
    public sealed virtual void Add(Type serviceType, Func`2<TypeFactoryContext, Type> implementationTypeFactory, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    public sealed virtual InstanceProducer TryGetInstanceProducer(Type serviceType, InjectionConsumerInfo consumer);
    public sealed virtual void AddGeneric(Type serviceType, Type implementationType, Lifestyle lifestyle, Predicate`1<PredicateContext> predicate);
    [IteratorStateMachineAttribute("SimpleInjector.Internals.NonGenericRegistrationEntry/<GetInstanceProducers>d__16")]
private IEnumerable`1<InstanceProducer> GetInstanceProducers(InjectionConsumerInfo consumer);
    private void ThrowWhenTypeAlreadyRegistered(InstanceProducer producer);
    private void ThrowWhenIdenticalImplementationIsAlreadyRegistered(InstanceProducer producerToRegister);
    private IEnumerable`1<InstanceProducer> GetOverlappingProducers(InstanceProducer producerToRegister);
    private ActivationException ThrowMultipleApplicableRegistrationsFound(InstanceProducer[] producers);
    private void ThrowWhenConditionalAndUnconditionalAreMixed(InstanceProducer producer);
    private void ThrowWhenConditionalIsRegisteredInOverridingMode(InstanceProducer producer);
    private void ThrowWhenNonGenericTypeAlreadyRegisteredAsUnconditionalRegistration(InstanceProducer producer);
    private void ThrowWhenNonGenericTypeAlreadyRegisteredAsConditionalRegistration(InstanceProducer producer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private FoundInstanceProducer <ThrowMultipleApplicableRegistrationsFound>b__20_0(InstanceProducer producer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ObjectGraphStringBuilder : object {
    private static int IndentSize;
    private StringBuilder builder;
    private Stack`1<ProducerEntry> producers;
    private VisualizationOptions visualizationOptions;
    [NullableAttribute("2")]
private ProducerEntry stillToWriteLifestyleEntry;
    private int indentingDepth;
    public ObjectGraphStringBuilder(VisualizationOptions visualizationOptions);
    public virtual string ToString();
    internal void BeginInstanceProducer(InstanceProducer producer);
    internal void AppendCyclicInstanceProducer(InstanceProducer producer, bool last);
    internal void EndInstanceProducer(bool last);
    private void AppendNewLine();
    private void AppendLifestyle(ProducerEntry entry);
    private void AppendIndent();
    private void Append(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.OverriddenParameter : ValueType {
    internal ParameterInfo Parameter;
    internal ConstantExpression PlaceHolder;
    internal Expression Expression;
    internal InstanceProducer Producer;
    internal OverriddenParameter(ParameterInfo parameter, Expression expression, InstanceProducer producer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class SimpleInjector.Internals.ParameterDictionary`1 : Dictionary`2<ParameterInfo, TValue> {
    public ParameterDictionary`1(IEnumerable`1<TValue> collection, Func`2<TValue, ParameterInfo> keySelector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ReferenceEqualityComparer`1 : object {
    internal static ReferenceEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    [DebuggerStepThroughAttribute]
public sealed virtual bool Equals(T x, T y);
    [DebuggerStepThroughAttribute]
public sealed virtual int GetHashCode(T obj);
}
internal static class SimpleInjector.Internals.RegistrationEntry : object {
    [NullableContextAttribute("1")]
internal static IRegistrationEntry Create(Type serviceType, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.ServiceCreatedListenerArgs : object {
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceProducer <Producer>k__BackingField;
    public bool Handled { get; public set; }
    public InstanceProducer Producer { get; }
    public ServiceCreatedListenerArgs(InstanceProducer producer);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
    [CompilerGeneratedAttribute]
public InstanceProducer get_Producer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.SubExpressionReplacer : ExpressionVisitor {
    private ConstantExpression subExpressionToFind;
    private Expression replacementExpression;
    private SubExpressionReplacer(ConstantExpression subExpressionToFind, Expression replacementExpression);
    internal static Expression Replace(Expression expressionToAlter, ConstantExpression nodeToFind, Expression replacementNode);
    protected virtual Expression VisitConstant(ConstantExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Internals.TypeConstraintValidator : object {
    [CompilerGeneratedAttribute]
private ArgumentMapping <Mapping>k__BackingField;
    internal ArgumentMapping Mapping { get; }
    public TypeConstraintValidator(ArgumentMapping mapping);
    [CompilerGeneratedAttribute]
internal ArgumentMapping get_Mapping();
    internal bool AreTypeConstraintsSatisfied();
    private bool ParameterSatisfiesDefaultConstructorConstraint();
    private static bool HasDefaultConstructor(Type t);
    private bool ParameterSatisfiesReferenceTypeConstraint();
    private bool ParameterSatisfiesNotNullableValueTypeConstraint();
    private bool ParameterSatisfiesGenericParameterConstraints();
    private bool MappingMightBeCompatibleWithTypeConstraint(Type constraint);
    private bool MappingArgumentHasConstraint(GenericParameterAttributes constraint);
    private bool MappingConcreteTypeHasConstraint(GenericParameterAttributes constraint);
    private static bool GenericParameterHasConstraint(Type genericParameter, GenericParameterAttributes constraint);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ParameterSatisfiesGenericParameterConstraints>b__9_0(Type constraint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Name, nq}")]
public abstract class SimpleInjector.Lifestyle : object {
    public static Lifestyle Transient;
    public static ScopedLifestyle Scoped;
    public static SingletonLifestyle Singleton;
    [DebuggerBrowsableAttribute("0")]
internal static Lifestyle Unknown;
    [DebuggerBrowsableAttribute("0")]
private static MethodInfo OpenCreateRegistrationTServiceFuncMethod;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <IdentificationKey>k__BackingField;
    public string Name { get; }
    public int Length { get; }
    internal object IdentificationKey { get; }
    protected Lifestyle(string name);
    private static Lifestyle();
    [CompilerGeneratedAttribute]
public string get_Name();
    public abstract virtual int get_Length();
    [CompilerGeneratedAttribute]
internal object get_IdentificationKey();
    public static Lifestyle CreateHybrid(ScopedLifestyle defaultLifestyle, Lifestyle fallbackLifestyle);
    public static ScopedLifestyle CreateHybrid(ScopedLifestyle defaultLifestyle, ScopedLifestyle fallbackLifestyle);
    public static Lifestyle CreateHybrid(Func`1<bool> lifestyleSelector, Lifestyle trueLifestyle, Lifestyle falseLifestyle);
    public static ScopedLifestyle CreateHybrid(Func`1<bool> lifestyleSelector, ScopedLifestyle trueLifestyle, ScopedLifestyle falseLifestyle);
    public static Lifestyle CreateCustom(string name, CreateLifestyleApplier lifestyleApplierFactory);
    public InstanceProducer`1<TService> CreateProducer(Container container);
    public InstanceProducer`1<TService> CreateProducer(Type implementationType, Container container);
    public InstanceProducer`1<TService> CreateProducer(Func`1<TService> instanceCreator, Container container);
    public InstanceProducer CreateProducer(Type serviceType, Type implementationType, Container container);
    public Registration CreateRegistration(Container container);
    public Registration CreateRegistration(Func`1<TService> instanceCreator, Container container);
    public Registration CreateRegistration(Type concreteType, Container container);
    public Registration CreateRegistration(Type serviceType, Func`1<object> instanceCreator, Container container);
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    internal Registration CreateRegistrationInternal(Type concreteType, Container container, bool preventTornLifestyles);
    internal Registration CreateDecoratorRegistration(Type concreteType, Container container, OverriddenParameter[] overriddenParameters);
    protected internal abstract virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal abstract virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
    private Registration CreateRegistrationFromCache(Type concreteType, Container container);
    private WeakReference GetLifestyleRegistrationEntryFromCache(Type concreteType, Container container);
    private static object ConvertDelegateToTypeSafeDelegate(Type serviceType, Func`1<object> instanceCreator);
    private static ArgumentException BuildUnableToResolveTypeDueToSecurityConfigException(Type type, MemberAccessException innerException, string paramName);
    private static MethodInfo GetMethod(Expression`1<Action`1<Lifestyle>> methodCall);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.Lifestyles.AsyncScopedLifestyle : ScopedLifestyle {
    private static object managerKey;
    private static AsyncScopedLifestyle();
    public static Scope BeginScope(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
    private static ScopeManager GetScopeManager(Container c);
    private static ScopeManager CreateManager(Container container, object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.CustomLifestyle : Lifestyle {
    private CreateLifestyleApplier lifestyleApplierFactory;
    public int Length { get; }
    public CustomLifestyle(string name, CreateLifestyleApplier lifestyleApplierFactory);
    public virtual int get_Length();
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.DefaultFallbackScopedHybridLifestyle : ScopedLifestyle {
    private ScopedLifestyle defaultLifestyle;
    private ScopedLifestyle fallbackLifestyle;
    internal DefaultFallbackScopedHybridLifestyle(ScopedLifestyle defaultLifestyle, ScopedLifestyle fallbackLifestyle);
    private sealed virtual override string SimpleInjector.Lifestyles.IHybridLifestyle.GetHybridName();
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    private static string GetHybridName(Lifestyle lifestyle);
}
internal enum SimpleInjector.Lifestyles.Disposability : Enum {
    public byte value__;
    public static Disposability Always;
    public static Disposability Never;
    public static Disposability Maybe;
}
internal class SimpleInjector.Lifestyles.DisposabilityTypeInfo : ValueType {
    public Disposability Sync;
    public Disposability Async;
    [NullableContextAttribute("1")]
public DisposabilityTypeInfo(Type type, ScopedRegistration registration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.ExpressionRegistration : Registration {
    private Expression expression;
    internal ExpressionRegistration(Expression expression, Container container);
    internal ExpressionRegistration(Expression expression, Type implementationType, Lifestyle lifestyle, Container container);
    public virtual Expression BuildExpression();
    private static Lifestyle GetLifestyleFor(Expression expression);
    private static Type GetImplementationTypeFor(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.FlowingScopedLifestyle : ScopedLifestyle {
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.HybridLifestyle : Lifestyle {
    private Predicate`1<Container> lifestyleSelector;
    private Lifestyle trueLifestyle;
    private Lifestyle falseLifestyle;
    public int Length { get; }
    internal HybridLifestyle(Predicate`1<Container> lifestyleSelector, Lifestyle trueLifestyle, Lifestyle falseLifestyle);
    public virtual int get_Length();
    private sealed virtual override string SimpleInjector.Lifestyles.IHybridLifestyle.GetHybridName();
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    internal static string GetHybridName(Lifestyle lifestyle);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.HybridRegistration : Registration {
    private Func`1<bool> test;
    private Registration trueRegistration;
    private Registration falseRegistration;
    public HybridRegistration(Type implementationType, Func`1<bool> test, Registration trueRegistration, Registration falseRegistration, Lifestyle lifestyle, Container container);
    public virtual Expression BuildExpression();
    internal virtual void SetParameterOverrides(IEnumerable`1<OverriddenParameter> overrides);
    private void AddRelationships();
    private IEnumerable`1<KnownRelationship> GetRelationshipsThisLifestyle(Registration registration);
}
[NullableContextAttribute("1")]
internal interface SimpleInjector.Lifestyles.IHybridLifestyle {
    public abstract virtual string GetHybridName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.LifestyleSelectionBehaviorProxyLifestyle : Lifestyle {
    private ContainerOptions options;
    public int Length { get; }
    public LifestyleSelectionBehaviorProxyLifestyle(ContainerOptions options);
    public virtual int get_Length();
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.LifestyleSelectorScopedHybridLifestyle : ScopedLifestyle {
    private Predicate`1<Container> selector;
    private ScopedLifestyle trueLifestyle;
    private ScopedLifestyle falseLifestyle;
    internal LifestyleSelectorScopedHybridLifestyle(Predicate`1<Container> lifestyleSelector, ScopedLifestyle trueLifestyle, ScopedLifestyle falseLifestyle);
    private sealed virtual override string SimpleInjector.Lifestyles.IHybridLifestyle.GetHybridName();
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
    private ScopedLifestyle CurrentLifestyle(Container container);
    private static string GetHybridName(Lifestyle lifestyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.ScopedProxyLifestyle : ScopedLifestyle {
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
    private static ScopedLifestyle GetDefaultScopedLifestyle(Container container);
    private static ScopedLifestyle ThrowDefaultScopeLifestyleIsNotSet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.ScopedRegistration : Registration {
    private static Func`1<string> EmptyStringProvider;
    [NullableAttribute("2")]
private Func`1<Scope> scopeFactory;
    private Nullable`1<DisposabilityTypeInfo> disposability;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<object> <InstanceCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<string> <AdditionalInformationForLifestyleMismatchDiagnosticsProvider>k__BackingField;
    public ScopedLifestyle Lifestyle { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`1<object> InstanceCreator { get; private set; }
    internal Func`1<string> AdditionalInformationForLifestyleMismatchDiagnosticsProvider { get; internal set; }
    internal DisposabilityTypeInfo Disposability { get; }
    internal ScopedRegistration(ScopedLifestyle lifestyle, Container container, Type implementationType, Func`1<object> creator);
    private static ScopedRegistration();
    public ScopedLifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
internal Func`1<object> get_InstanceCreator();
    [CompilerGeneratedAttribute]
private void set_InstanceCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
internal Func`1<string> get_AdditionalInformationForLifestyleMismatchDiagnosticsProvider();
    [CompilerGeneratedAttribute]
internal void set_AdditionalInformationForLifestyleMismatchDiagnosticsProvider(Func`1<string> value);
    internal DisposabilityTypeInfo get_Disposability();
    public virtual Expression BuildExpression();
    internal static ScopedRegistration GetScopedRegistration(MethodCallExpression node);
    public TImplementation GetInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.ScopedScopeLifestyle : ScopedLifestyle {
    internal static ScopedScopeLifestyle Instance;
    private static ScopedScopeLifestyle();
    internal Scope GetCurrentScope(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    private Scope GetScopeFromDefaultScopedLifestyle(Container container);
    private static Scope ThrowResolveFromScopeOrRegisterDefaultScopedLifestyleException();
    private static Scope ThrowThereIsNoActiveScopeException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.ScopeManager : object {
    private Container container;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<Scope> scopeRetriever;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<Scope> scopeReplacer;
    [NullableAttribute("2")]
internal Scope CurrentScope { get; }
    [NullableAttribute("2")]
private Scope CurrentScopeInternal { get; private set; }
    internal ScopeManager(Container container, Func`1<Scope> scopeRetriever, Action`1<Scope> scopeReplacer);
    [NullableContextAttribute("2")]
internal Scope get_CurrentScope();
    [NullableContextAttribute("2")]
private Scope get_CurrentScopeInternal();
    [NullableContextAttribute("2")]
private void set_CurrentScopeInternal(Scope value);
    internal void SetCurrentScope(Scope scope);
    internal Scope BeginScope();
    internal void RemoveScope(Scope scope);
    private bool IsScopeInLocalChain(Scope scope);
    [NullableContextAttribute("2")]
private Scope GetCurrentScopeWithAutoCleanup();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.Lifestyles.SingletonLifestyle : Lifestyle {
    internal static SingletonLifestyle Instance;
    public int Length { get; }
    private static SingletonLifestyle();
    public virtual int get_Length();
    public Registration CreateRegistration(Type instanceType, object instance, Container container);
    public Registration CreateRegistration(Type serviceType, Func`1<object> instanceCreator, Container container);
    internal static Registration CreateSingleInstanceRegistration(Type serviceType, Type implementationType, object instance, Container container);
    internal static InstanceProducer CreateUncontrolledCollectionProducer(Type itemType, IEnumerable collection, Container container);
    internal static Registration CreateUncontrolledCollectionRegistration(Type itemType, IEnumerable collection, Container container);
    internal static bool IsSingletonInstanceRegistration(Registration registration);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
    private static ConstantExpression BuildConstantExpression(object instance, Type implementationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SimpleInjector.Lifestyles.ThreadScopedLifestyle : ScopedLifestyle {
    private static object ManagerKey;
    private static ThreadScopedLifestyle();
    public static Scope BeginScope(Container container);
    protected internal virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
    private static ScopeManager GetScopeManager(Container container);
    private static ScopeManager CreateManager(Container container, object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.TransientLifestyle : Lifestyle {
    public int Length { get; }
    public virtual int get_Length();
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.Lifestyles.UnknownLifestyle : Lifestyle {
    public int Length { get; }
    public virtual int get_Length();
    internal virtual int ComponentLength(Container container);
    internal virtual int DependencyLength(Container container);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("PredicateContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.PredicateContext : ApiObject {
    private InjectionConsumerInfo consumer;
    private LazyEx`1<Type> implementationType;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    public Type ServiceType { get; }
    [NullableAttribute("2")]
public Type ImplementationType { get; }
    public bool Handled { get; }
    public InjectionConsumerInfo Consumer { get; }
    public bool HasConsumer { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal PredicateContext(InstanceProducer producer, InjectionConsumerInfo consumer, bool handled);
    internal PredicateContext(Type serviceType, Type implementationType, InjectionConsumerInfo consumer, bool handled);
    internal PredicateContext(Type serviceType, Func`1<Type> implementationTypeProvider, InjectionConsumerInfo consumer, bool handled);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [NullableContextAttribute("2")]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    public InjectionConsumerInfo get_Consumer();
    public bool get_HasConsumer();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.ProducerBuilders.CollectionInstanceProducerBuilder : object {
    private static MethodInfo EnumerableToArrayMethod;
    private static MethodInfo EnumerableToListMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, InstanceProducer> emptyAndRedirectedCollectionRegistrationCache;
    private Container container;
    public CollectionInstanceProducerBuilder(Container container);
    private static CollectionInstanceProducerBuilder();
    public sealed virtual InstanceProducer TryBuild(Type serviceType);
    private InstanceProducer TryBuildInstanceProducerForMutableCollection(Type serviceType);
    private InstanceProducer BuildInstanceProducerForMutableCollectionType(Type serviceType, Type elementType);
    private InstanceProducer BuildMutableCollectionProducerFromControlledCollection(Type serviceType, Type elementType);
    private Expression BuildMutableCollectionExpressionFromControlledCollection(Type serviceType, Type elementType);
    private InstanceProducer BuildMutableCollectionProducerFromUncontrolledCollection(Type serviceType, Type elementType);
    private InstanceProducer TryBuildInstanceProducerForStream(Type serviceType);
    private InstanceProducer TryBuildStreamInstanceProducer(Type collectionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.ProducerBuilders.DependencyMetadataInstanceProducerBuilder : object {
    private Container container;
    public DependencyMetadataInstanceProducerBuilder(Container container);
    public sealed virtual InstanceProducer TryBuild(Type serviceType);
    private InstanceProducer BuildInstanceProducerForDependencyMetadata(Type metadataType);
    private InstanceProducer BuildInstanceProducerForMetadataList(Type enumerableOfProducersType);
    private Registration CreateMetadataRegistration(Type metadataType, InstanceProducer producer);
    private bool ShouldFlow(InstanceProducer producer);
    private Func`1<object> BuildMetadataInstanceCreator(Type metadataType, InstanceProducer producer, bool flowing);
}
[NullableContextAttribute("1")]
internal interface SimpleInjector.ProducerBuilders.IInstanceProducerBuilder {
    public abstract virtual InstanceProducer TryBuild(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.ProducerBuilders.UnregisteredConcreteTypeInstanceProducerBuilder : object {
    private Dictionary`2<Type, InstanceProducer> unregisteredConcreteTypeInstanceProducers;
    private Container container;
    public UnregisteredConcreteTypeInstanceProducerBuilder(Container container);
    public sealed virtual InstanceProducer TryBuild(Type serviceType);
    private static InstanceProducer BuildInstanceProducerForConcreteUnregisteredType(Type concreteType, Registration registration);
    private InstanceProducer GetOrBuildInstanceProducerForConcreteUnregisteredType(Type concreteType, Func`1<InstanceProducer> instanceProducerBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SimpleInjector.ProducerBuilders.UnregisteredTypeResolutionInstanceProducerBuilder : object {
    private Dictionary`2<Type, LazyEx`1<InstanceProducer>> resolveUnregisteredTypeRegistrations;
    private Container container;
    private Func`1<bool> shouldResolveUnregisteredTypes;
    private Action`1<UnregisteredTypeEventArgs> resolveUnregisteredType;
    internal UnregisteredTypeResolutionInstanceProducerBuilder(Container container, Func`1<bool> shouldResolveUnregisteredTypes, Action`1<UnregisteredTypeEventArgs> resolveUnregisteredType);
    public sealed virtual InstanceProducer TryBuild(Type serviceType);
    private InstanceProducer TryGetInstanceProducerForUnregisteredTypeResolutionFromCache(Type serviceType);
    private InstanceProducer TryGetInstanceProducerThroughResolveUnregisteredTypeEvent(Type serviceType);
    private InstanceProducer TryGetProducerFromUnregisteredTypeResolutionCacheOrAdd(UnregisteredTypeEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.ReflectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name);
    [ExtensionAttribute]
public static Type[] GetTypes(Assembly assembly);
    [ExtensionAttribute]
public static MemberInfo[] GetMember(Type type, string name);
    [ExtensionAttribute]
public static Type[] GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type other);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsNestedPublic(Type type);
    [ExtensionAttribute]
public static bool IsPublic(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static Type[] GetGenericParameterConstraints(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericParameter(Type type);
    [ExtensionAttribute]
public static GenericParameterAttributes GetGenericParameterAttributes(Type type);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type type);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type type);
    [ExtensionAttribute]
public static Guid GetGuid(Type type);
    [ExtensionAttribute]
public static ConstructorInfo[] GetConstructors(Type type, bool includeNonPublic);
    [ExtensionAttribute]
public static ConstructorInfo[] GetConstructors(Type type);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, Type[] types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SimpleInjector.Registration : object {
    private static Action`1<object> NoOp;
    private HashSet`1<KnownRelationship> knownRelationships;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`1<object> instanceCreator;
    [NullableAttribute("2")]
private HashSet`1<DiagnosticType> suppressions;
    [NullableAttribute("2")]
private ParameterDictionary`1<OverriddenParameter> overriddenParameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<object> instanceInitializer;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifestyle <Lifestyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressDisposal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExpressionIntercepted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrapsInstanceCreationDelegate>k__BackingField;
    public Type ImplementationType { get; }
    public Lifestyle Lifestyle { get; }
    public Container Container { get; }
    public bool SuppressDisposal { get; public set; }
    internal bool IsCollection { get; internal set; }
    internal Nullable`1<bool> ExpressionIntercepted { get; private set; }
    internal bool MustBeVerified { get; }
    internal bool ResolvesExternallyOwnedInstance { get; }
    internal bool WrapsInstanceCreationDelegate { get; internal set; }
    protected Registration(Lifestyle lifestyle, Container container, Type implementationType, Func`1<object> instanceCreator);
    private static Registration();
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public Lifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
public Container get_Container();
    [CompilerGeneratedAttribute]
public bool get_SuppressDisposal();
    [CompilerGeneratedAttribute]
public void set_SuppressDisposal(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsCollection();
    [CompilerGeneratedAttribute]
internal void set_IsCollection(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_ExpressionIntercepted();
    [CompilerGeneratedAttribute]
private void set_ExpressionIntercepted(Nullable`1<bool> value);
    internal virtual bool get_MustBeVerified();
    internal virtual bool get_ResolvesExternallyOwnedInstance();
    [CompilerGeneratedAttribute]
internal bool get_WrapsInstanceCreationDelegate();
    [CompilerGeneratedAttribute]
internal void set_WrapsInstanceCreationDelegate(bool value);
    public abstract virtual Expression BuildExpression();
    public KnownRelationship[] GetRelationships();
    public void InitializeInstance(object instance);
    public void SuppressDiagnosticWarning(DiagnosticType type, string justification);
    internal bool ShouldNotBeSuppressed(DiagnosticType type);
    internal virtual KnownRelationship[] GetRelationshipsCore();
    internal void ReplaceRelationships(IEnumerable`1<KnownRelationship> relationships);
    internal Expression InterceptInstanceCreation(Type implementationType, Expression instanceCreatorExpression);
    internal void AddRelationship(KnownRelationship relationship);
    internal virtual void SetParameterOverrides(IEnumerable`1<OverriddenParameter> overrides);
    internal Expression WrapWithPropertyInjector(Type implementationType, Expression expressionToWrap);
    internal Expression WrapWithInitializer(Type implementationType, Expression expression);
    protected Func`1<object> BuildTransientDelegate();
    protected Expression BuildTransientExpression();
    private Action`1<object> BuildInstanceInitializer();
    private Expression BuildNewExpression();
    private void EnsureImplementationTypeInitialized();
    private Expression BuildInvocationExpression(Func`1<object> instanceCreator);
    private ParameterDictionary`1<DependencyData> BuildConstructorParameters(ConstructorInfo constructor);
    private ConstantExpression GetPlaceHolderFor(ParameterInfo parameter);
    private Expression WrapWithPropertyInjectorInternal(Type implementationType, Expression expressionToWrap);
    private PropertyInfo[] GetPropertiesToInject(Type implementationType);
    private Expression ReplacePlaceHoldersWithOverriddenParameters(Expression expression);
    private OverriddenParameter GetOverriddenParameterFor(ParameterInfo parameter);
    private void AddRelationships(ConstructorInfo constructor, ParameterDictionary`1<DependencyData> parameters);
    private Expression WrapWithNullCheck(Expression expression);
    private static Expression BuildExpressionWithInstanceInitializer(Expression newExpression, Action`1<TImplementation> instanceInitializer);
    private Delegate BuildDelegate(Expression expression);
    [CompilerGeneratedAttribute]
private object <WrapWithNullCheck>b__61_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SimpleInjector.Requires : object {
    [DebuggerStepThroughAttribute]
internal static void IsNotNull(object instance, string paramName);
    [DebuggerStepThroughAttribute]
internal static void IsNotNullOrEmpty(string instance, string paramName);
    [DebuggerStepThroughAttribute]
internal static void IsReferenceType(Type type, string paramName);
    [DebuggerStepThroughAttribute]
internal static void IsNotOpenGenericType(Type type, string paramName);
    [DebuggerStepThroughAttribute]
internal static void ServiceIsAssignableFromExpression(Type service, Expression expression, string paramName);
    [DebuggerStepThroughAttribute]
internal static void ServiceIsAssignableFromRegistration(Type service, Registration registration, string paramName);
    [DebuggerStepThroughAttribute]
internal static void ServiceIsAssignableFromImplementation(Type service, Type implementation, string paramName);
    [DebuggerStepThroughAttribute]
internal static void IsNotAnAmbiguousType(Type type, string paramName);
    [DebuggerStepThroughAttribute]
internal static void IsGenericType(Type type, string paramName, Func`2<Type, string> guidance);
    [DebuggerStepThroughAttribute]
internal static void IsOpenGenericType(Type type, string paramName, Func`2<Type, string> guidance);
    internal static void DoesNotContainNullValues(IEnumerable`1<T> collection, string paramName);
    internal static void DoesNotContainOpenGenericTypesWhenServiceTypeIsNotGeneric(Type serviceType, IEnumerable`1<Type> serviceTypes, string paramName);
    internal static void ServiceTypeIsNotClosedWhenImplementationIsOpen(Type service, Type implementation);
    internal static void ServiceOrItsGenericTypeDefinitionIsAssignableFromImplementation(Type service, Type implementation, string paramName);
    internal static void ServiceIsAssignableFromImplementations(Type serviceType, IEnumerable`1<Type> typesToRegister, string paramName, bool typeCanBeServiceType);
    internal static void ServiceIsAssignableFromImplementations(Type serviceType, IEnumerable`1<Registration> registrations, string paramName, bool typeCanBeServiceType);
    internal static void ImplementationHasSelectableConstructor(Container container, Type implementationType, string paramName);
    internal static void TypeFactoryReturnedTypeThatDoesNotContainUnresolvableTypeArguments(Type serviceType, Type implementationType);
    internal static void OpenGenericTypesDoNotContainUnresolvableTypeArguments(Type serviceType, IEnumerable`1<Registration> registrations, string parameterName);
    internal static void OpenGenericTypesDoNotContainUnresolvableTypeArguments(Type serviceType, IEnumerable`1<Type> implementationTypes, string parameterName);
    internal static void OpenGenericTypeDoesNotContainUnresolvableTypeArguments(Type serviceType, Type implementationType, string parameterName);
    internal static void DecoratorIsNotAnOpenGenericTypeDefinitionWhenTheServiceTypeIsNot(Type serviceType, Type decoratorType, string parameterName);
    internal static void HasFactoryCreatedDecorator(Container container, Type serviceType, Type decoratorType);
    internal static void FactoryReturnsATypeThatIsAssignableFromServiceType(Type serviceType, Type implementationType);
    internal static void IsDecorator(Container container, Type serviceType, Type decoratorType, string paramName);
    internal static void AreRegistrationsForThisContainer(Container container, IEnumerable`1<Registration> registrations, string paramName);
    internal static void IsRegistrationForThisContainer(Container container, Registration registration, string paramName);
    [NullableContextAttribute("0")]
[DebuggerStepThroughAttribute]
internal static void IsValidEnum(TEnum value, string paramName);
    internal static void IsNotPartiallyClosed(Type openGenericServiceType, string paramName);
    internal static void IsNotPartiallyClosed(Type openGenericServiceType, string paramName, string implementationTypeParamName);
    private static void DecoratesServiceType(Type serviceType, ConstructorInfo decoratorConstructor, string paramName);
    private static void ThrowMustDecorateServiceType(Type serviceType, ConstructorInfo constructor, string paramName);
    private static void ThrowMustContainTheServiceTypeAsArgument(Type serviceType, ConstructorInfo decoratorConstructor, string paramName);
    private static void ThrowMustContainASingleInstanceOfTheServiceTypeAsArgument(Type serviceType, ConstructorInfo decoratorConstructor, string paramName);
    private static void ThrowArgumentNullException(string paramName);
    private static void ThrowSuppliedElementDoesNotInheritFromOrImplement(Type service, Type implementation, string elementDescription, string paramName);
    private static void ThrowSuppliedTypeDoesNotInheritFromOrImplement(Type service, Type implementation, string paramName);
}
public class SimpleInjector.ResolveInterceptor : MulticastDelegate {
    public ResolveInterceptor(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(InitializationContext context, Func`1<object> instanceProducer);
    public virtual IAsyncResult BeginInvoke(InitializationContext context, Func`1<object> instanceProducer, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebugString,nq}")]
public class SimpleInjector.Scope : ApiObject {
    private static Task CompletedTask;
    private static int MaximumDisposeRecursion;
    private static long counter;
    private object syncRoot;
    [NullableAttribute("2")]
private ScopeManager manager;
    private long scopeId;
    [NullableAttribute("2")]
private IDictionary items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Registration, object> cachedInstances;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action> scopeEndActions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<object> disposables;
    private DisposeState state;
    private int recursionDuringDisposalCounter;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Container <Container>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Scope <ParentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsContainerScope>k__BackingField;
    [NullableAttribute("2")]
public Container Container { get; }
    internal bool Disposed { get; }
    [NullableAttribute("2")]
internal Scope ParentScope { get; }
    internal bool IsContainerScope { get; internal set; }
    private string DebugString { get; }
    public Scope(Container container);
    internal Scope(Container container, ScopeManager manager, Scope parentScope);
    private static Scope();
    [AsyncStateMachineAttribute("SimpleInjector.Scope/<DisposeScopeAsync>d__1")]
public Task DisposeScopeAsync();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Container get_Container();
    internal bool get_Disposed();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Scope get_ParentScope();
    [CompilerGeneratedAttribute]
internal bool get_IsContainerScope();
    [CompilerGeneratedAttribute]
internal void set_IsContainerScope(bool value);
    private string get_DebugString();
    public TService GetInstance();
    public object GetInstance(Type serviceType);
    public virtual void WhenScopeEnds(Action action);
    public void RegisterForDisposal(IDisposable disposable);
    public void RegisterForDisposal(object disposable);
    public object GetItem(object key);
    public void SetItem(object key, object item);
    public IDisposable[] GetDisposables();
    public Object[] GetAllDisposables();
    public sealed virtual void Dispose();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    internal static TImplementation GetInstance(ScopedRegistration registration, Scope scope);
    internal T GetOrSetItem(object key, Func`3<Container, object, T> valueFactory);
    protected virtual void Dispose(bool disposing);
    private void ClearState();
    private void DisposeRecursively(bool operatingInException);
    private void ExecuteAllRegisteredEndScopeActions();
    private static object GetScopelessInstance(ScopedRegistration registration);
    private object GetInstanceInternal(ScopedRegistration registration);
    private object CreateAndCacheInstanceInternal(ScopedRegistration registration, Dictionary`2<Registration, object> cache);
    private void TryRegisterForDisposalInternal(ScopedRegistration registration, object instance);
    private void RegisterForDisposalInternal(object disposable);
    private void DisposeAllRegisteredDisposables();
    private void RequiresInstanceNotDisposed();
    private void ThrowObjectDisposedException();
    private void PreventCyclicDependenciesDuringDisposal();
    private static void ThrowRecursionException();
    private void DisposeInstancesInReverseOrder(List`1<object> disposables, int startingAsIndex);
    private void ThrowTypeOnlyImplementsIAsyncDisposable(object instance);
    [AsyncStateMachineAttribute("SimpleInjector.Scope/<DisposeInternalAsync>d__60")]
private Task DisposeInternalAsync();
    [AsyncStateMachineAttribute("SimpleInjector.Scope/<DisposeRecursivelyAsync>d__61")]
private Task DisposeRecursivelyAsync(bool operatingInException);
    private Task DisposeAllRegisteredDisposablesAsync();
    [AsyncStateMachineAttribute("SimpleInjector.Scope/<DisposeInstancesInReverseOrderAsync>d__63")]
private static Task DisposeInstancesInReverseOrderAsync(List`1<object> disposables, int startingAsIndex);
    private static Task DisposeInstanceAsync(object instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SimpleInjector.ScopedLifestyle : Lifestyle {
    public static ScopedLifestyle Flowing;
    public int Length { get; }
    protected ScopedLifestyle(string name);
    private static ScopedLifestyle();
    public virtual int get_Length();
    public void WhenScopeEnds(Container container, Action action);
    public void RegisterForDisposal(Container container, IDisposable disposable);
    public Scope GetCurrentScope(Container container);
    public void SetCurrentScope(Scope scope);
    protected internal abstract virtual Func`1<Scope> CreateCurrentScopeProvider(Container container);
    protected internal virtual Registration CreateRegistrationCore(Func`1<TService> instanceCreator, Container container);
    protected internal virtual Registration CreateRegistrationCore(Type concreteType, Container container);
    protected virtual Scope GetCurrentScopeCore(Container container);
    protected virtual void SetCurrentScopeCore(Scope scope);
    private Scope GetCurrentScopeOrThrow(Container container);
    private Scope GetCurrentScopeInternal(Container container);
    private void ThrowThisMethodCanOnlyBeCalledWithinTheContextOfAnActiveScope();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.StringResources : object {
    private static string CollectionsRegisterMethodName;
    private static string EnableAutoVerificationPropertyName;
    private static string CollectionsAppendMethodName;
    private static PropertyInfo AssemblyLocationProperty;
    [CompilerGeneratedAttribute]
private static bool <UseFullyQualifiedTypeNames>k__BackingField;
    internal static bool UseFullyQualifiedTypeNames { get; internal set; }
    private static StringResources();
    [CompilerGeneratedAttribute]
internal static bool get_UseFullyQualifiedTypeNames();
    [CompilerGeneratedAttribute]
internal static void set_UseFullyQualifiedTypeNames(bool value);
    internal static string ContainerCanNotBeChangedAfterUse(string stackTrace);
    internal static string ContainerCanNotBeUsedAfterDisposal(Type type, string stackTrace);
    internal static string DelegateForTypeReturnedNull(Type serviceType);
    internal static string ResolveInterceptorDelegateReturnedNull();
    internal static string ErrorWhileBuildingDelegateFromExpression(Type serviceType, Expression expression, Exception exception);
    internal static string DelegateForTypeThrewAnException(Type serviceType);
    internal static string NoRegistrationForTypeFound(Type serviceType, int numberOfConditionals, bool containerHasRegistrations, bool collectionRegistrationDoesNotExists, bool containerHasRelatedOneToOneMapping, bool containerHasRelatedCollectionMapping, Type[] skippedDecorators, Type[] lookalikes);
    internal static string CallingPredicateContextConsumerOnDirectResolveIsNotSupported(PredicateContext context);
    private static string CallingPredicateContextConsumerOnDirectResolveExample(PredicateContext context);
    internal static string KnownImplementationTypeShouldBeAssignableFromExpressionType(Type knownImplementationType, Type currentExpressionType);
    internal static string FlowingCollectionIsScopedBecause(Type collectionType);
    internal static string FlowingMetadataIsScopedBecause(Type metadataType);
    internal static string MultipleClosedTypesAreAssignableFromType(Type type, Type genericTypeDefinition, IList`1<Type> types, string otherMethod);
    internal static string TypeIsNotAssignableFromOpenGenericType(Type type, Type genericTypeDefinition);
    internal static string OpenGenericTypesCanNotBeResolved(Type serviceType);
    internal static string LifestyleMismatchesReported(LifestyleMismatchDiagnosticResult error);
    internal static string LifestyleMismatchesCanCauseConcurrencyBugs();
    internal static string DiagnosticWarningsReported(IList`1<DiagnosticResult> errors);
    internal static string EnableAutoVerificationIsEnabled(string innerMessage);
    internal static string ConfigurationInvalidCreatingInstanceFailed(Type serviceType, Exception exception);
    internal static string ConfigurationInvalidIteratingCollectionFailed(Type serviceType, Exception exception);
    internal static string ConfigurationInvalidCollectionContainsNullElements(Type firstInvalidServiceType);
    internal static string TypeAlreadyRegistered(Type serviceType);
    internal static string ScopePropertyCanOnlyBeUsedWhenDefaultScopedLifestyleIsConfigured();
    internal static string MakingConditionalRegistrationsInOverridingModeIsNotSupported();
    internal static string MakingRegistrationsWithTypeConstraintsInOverridingModeIsNotSupported();
    internal static string NonGenericTypeAlreadyRegisteredAsConditionalRegistration(Type serviceType);
    internal static string GetAdditionalInformationForLifestyleMismatchCausedByMutableCollectionType(KnownRelationship relationship);
    internal static string CollectionUsedDuringConstruction(Type consumer, InstanceProducer producer, KnownRelationship relationship);
    internal static string UnregisteredAbstractionFoundInCollection(Type serviceType, Type registeredType, Type foundAbstractType);
    internal static string AmbiquousLifestyleFoundForResolvedProducerOfCollection(Type serviceType, Type registeredType, Lifestyle itemLifestyle, Lifestyle producerLifestyle);
    internal static string NonGenericTypeAlreadyRegisteredAsUnconditionalRegistration(Type serviceType);
    internal static string CollectionTypeAlreadyRegistered(Type serviceType);
    internal static string ParameterTypeMustBeRegistered(Container container, InjectionTargetInfo target, bool forceFullQualificationOfTarget, int numberOfConditionals, bool hasRelatedOneToOneMapping, bool collectionRegistrationDoesNotExists, bool hasRelatedCollectionMapping, Type[] skippedDecorators, Type[] lookalikes);
    internal static string TypeMustHaveASinglePublicConstructorButItHasNone(Type serviceType);
    internal static string TypeMustHaveASinglePublicConstructorButItHas(Type serviceType, int count);
    internal static string TypeMustNotContainInvalidInjectionTarget(InjectionTargetInfo invalidTarget);
    internal static string TypeShouldBeConcreteToBeUsedOnThisMethod(Type serviceType);
    internal static string MultipleObserversRegisteredTheSameTypeToResolveUnregisteredType(Type unregisteredServiceType);
    internal static string ImplicitRegistrationCouldNotBeMadeForType(Type serviceType, bool containerHasRegistrations);
    internal static string ImplicitRegistrationCouldNotBeMadeForType(Container container, Type serviceType, bool containerHasRegistrations);
    internal static string DefaultScopedLifestyleCanNotBeSetWithLifetimeScoped();
    internal static string TypeDependsOnItself(Type serviceType);
    internal static string CyclicDependencyGraphMessage(IEnumerable`1<Type> dependencyCycle);
    internal static string UnableToResolveTypeDueToSecurityConfiguration(Type serviceType, Exception innerException);
    internal static string UnableToInjectPropertiesDueToSecurityConfiguration(Type serviceType, Exception innerException);
    internal static string UnableToInjectImplicitPropertiesDueToSecurityConfiguration(Type injectee, Exception innerException);
    internal static string PropertyCanNotBeChangedAfterTheFirstRegistration(string propertyName);
    internal static string CollectionsRegisterCalledWithTypeAsTService(IEnumerable`1<Type> types);
    internal static string TypeIsAmbiguous(Type serviceType);
    internal static string SuppliedTypeIsNotAReferenceType(Type type);
    internal static string SuppliedTypeIsAnOpenGenericType(Type type);
    internal static string SuppliedTypeIsAnOpenGenericTypeWhileTheServiceTypeIsNot(Type type);
    internal static string SuppliedElementDoesNotInheritFromOrImplement(Type serviceType, Type elementType, string elementDescription);
    internal static string SuppliedTypeDoesNotInheritFromOrImplement(Type service, Type implementation);
    internal static string DependencyInjectionBehaviorReturnedNull(IDependencyInjectionBehavior behavior);
    internal static string LifestyleSelectionBehaviorReturnedNull(ILifestyleSelectionBehavior selectionBehavior, Type implementationType);
    internal static string TypeHasNoInjectableConstructorAccordingToCustomResolutionBehavior(IConstructorResolutionBehavior behavior, Type implementationType);
    internal static string DependencyNotValidForInjectionAccordingToCustomInjectionBehavior(IDependencyInjectionBehavior behavior, InjectionConsumerInfo dependency);
    internal static string RegistrationReturnedNullFromBuildExpression(Registration lifestyleRegistration);
    internal static string MultipleTypesThatRepresentClosedGenericType(Type closedServiceType, Type[] implementations);
    private static string NoteAssemblyLoadedMoreThanOnceOnDuplicateTypes(Type[] implementations);
    internal static string CantGenerateFuncForDecorator(Type serviceType, Type decorateeFactoryType, Type decoratorType);
    internal static string ScopeSuppliedToScopedDecorateeFactoryMustHaveAContainer();
    internal static string ScopeSuppliedToScopedDecorateeFactoryMustBeForSameContainer();
    internal static string SuppliedTypeIsNotAGenericType(Type type);
    internal static string SuppliedTypeIsNotAnOpenGenericType(Type type);
    internal static string SuppliedTypeCanNotBeOpenWhenDecoratorIsClosed();
    internal static string TheConstructorOfTypeMustContainTheServiceTypeAsArgument(Type decoratorType, Type serviceType);
    internal static string TheConstructorOfTypeMustContainASingleInstanceOfTheServiceTypeAsArgument(Type decoratorType, Type serviceType);
    internal static string OpenGenericTypeContainsUnresolvableTypeArguments(Type openGenericImplementation);
    internal static string DecoratorCanNotBeAGenericTypeDefinitionWhenServiceTypeIsNot(Type serviceType, Type decoratorType);
    internal static string TheSuppliedRegistrationBelongsToADifferentContainer();
    internal static string CanNotDecorateContainerUncontrolledCollectionWithThisLifestyle(Type decoratorType, Lifestyle lifestyle, Type serviceType);
    internal static string PropertyHasNoSetter(PropertyInfo property);
    internal static string PropertyIsStatic(PropertyInfo property);
    internal static string ThisOverloadDoesNotAllowOpenGenerics(Type openGenericServiceType, Type[] openGenericTypes, Type[] closedAndNonGenericTypes);
    internal static string ThisOverloadDoesNotAllowOpenGenericsExample(Type openGenericServiceType, Type[] openGenericTypes, Type firstClosedAndNonGenericType);
    internal static string AppendingRegistrationsToContainerUncontrolledCollectionsIsNotSupported(Type serviceType);
    internal static string UnregisteredTypeEventArgsRegisterDelegateReturnedUncastableInstance(Type serviceType, InvalidCastException exception);
    internal static string UnregisteredTypeEventArgsRegisterDelegateThrewAnException(Type serviceType, Exception exception);
    internal static string TheServiceIsRequestedOutsideTheContextOfAScopedLifestyle(Type serviceType, ScopedLifestyle lifestyle);
    internal static string ThisMethodCanOnlyBeCalledWithinTheContextOfAnActiveScope(ScopedLifestyle lifestyle);
    internal static string DecoratorFactoryReturnedNull(Type serviceType);
    internal static string FactoryReturnedNull(Type serviceType);
    internal static string ImplementationTypeFactoryReturnedNull(Type serviceType);
    internal static string TheDecoratorReturnedFromTheFactoryShouldNotBeOpenGeneric(Type serviceType, Type decoratorType);
    internal static string TheTypeReturnedFromTheFactoryShouldNotBeOpenGeneric(Type serviceType, Type implementationType);
    internal static string TypeFactoryReturnedIncompatibleType(Type serviceType, Type implementationType);
    internal static string RecursiveInstanceRegistrationDetected();
    internal static string GetRootRegistrationsCanNotBeCalledBeforeVerify();
    internal static string VisualizeObjectGraphShouldBeCalledAfterTheExpressionIsCreated();
    internal static string MixingCallsToCollectionsRegisterIsNotSupported(Type serviceType);
    internal static string MixingRegistrationsWithControlledAndUncontrolledIsNotSupported(Type serviceType, bool controlled);
    internal static string ValueInvalidForEnumType(string paramName, object invalidValue, Type enumClass);
    internal static string ServiceTypeCannotBeAPartiallyClosedType(Type openGenericServiceType);
    internal static string ServiceTypeCannotBeAPartiallyClosedType(Type openGenericServiceType, string serviceTypeParamName, string implementationTypeParamName);
    internal static string SuppliedTypeIsNotGenericExplainingAlternativesWithAssemblies(Type type);
    internal static string SuppliedTypeIsNotGenericExplainingAlternativesWithTypes(Type type);
    internal static string SuppliedTypeIsNotOpenGenericExplainingAlternativesWithAssemblies(Type type);
    internal static string SuppliedTypeIsNotOpenGenericExplainingAlternativesWithTypes(Type type);
    internal static string RegistrationForClosedServiceTypeOverlapsWithOpenGenericRegistration(Type closedServiceType, Type overlappingGenericImplementationType);
    internal static string AnOverlappingRegistrationExists(Type openGenericServiceType, Type overlappingImplementationType, bool isExistingRegistrationConditional, Type implementationTypeOfNewRegistration, bool isNewRegistrationConditional);
    internal static string MultipleApplicableRegistrationsFound(Type serviceType, IEnumerable`1<FoundInstanceProducer> overlappingRegistrations);
    internal static string UnableToLoadTypesFromAssembly(Assembly assembly, Exception innerException);
    internal static string TypeOnlyImplementsIAsyncDisposable(object instance, bool containerScope);
    private static bool IsListOrArrayRelationship(KnownRelationship relationship);
    private static string CollectionUsedDuringConstructionByInjectingMutableCollection(Type consumer, InstanceProducer producer, KnownRelationship relationship);
    private static string CollectionUsedDuringConstructionByIteratingAStream(Type consumer, InstanceProducer producer, KnownRelationship relationship);
    private static string BuildRegistrationName(FoundInstanceProducer registration, int index);
    private static string NonGenericTypeAlreadyRegistered(Type serviceType, bool existingRegistrationIsConditional);
    private static string GetAdditionalInformationAboutExistingConditionalRegistrations(InjectionTargetInfo target, int numberOfConditionalRegistrations);
    private static string GetAdditionalInformationAboutExistingConditionalRegistrations(Type serviceType, Type consumerImplementationType, int numberOfConditionalRegistrations);
    private static string SuppliedTypeIsNotOpenGenericExplainingAlternatives(Type type, string registeringElement);
    private static string ToTypeOCfSharpFriendlyList(IEnumerable`1<Type> types);
    private static string SuppliedTypeIsNotGenericExplainingAlternatives(Type type, string registeringElement);
    private static object ContainerHasNoRegistrationsAddition(bool containerHasRegistrations);
    private static object DidYouMeanToCallGetInstanceInstead(bool hasRelatedOneToOneMapping, Type collectionServiceType);
    private static object NoCollectionRegistrationExists(bool shouldDisplayMessage, Type collectionServiceType);
    private static string DidYouMeanToDependOnNonCollectionInstead(bool hasRelatedOneToOneMapping, Type collectionServiceType);
    private static string DidYouMeanToCallGetAllInstancesInstead(bool hasCollection, Type serviceType);
    private static string DidYouMeanToDependOnCollectionInstead(bool hasCollection, Type serviceType);
    private static string NoteThatSkippedDecoratorsWereFound(Type serviceType, Type[] decorators);
    private static string NoteThatTypeLookalikesAreFound(Type serviceType, Type[] lookalikes, int numberOfConditionals);
    private static string AssemblyLoadedMoreThanOnce(Type serviceType, Type duplicateAssemblyLookalike);
    private static string NoteThatConcreteTypeCanNotBeResolvedDueToConfiguration(Container container, InjectionTargetInfo target);
    private static string NoteThatConcreteTypeCanNotBeResolvedDueToConfiguration(Container container, Type resolvedType, Type consumingType);
    private static string ThereIsAMappingToImplementationType(Container container, Type resolvedType, Type consumingType);
    private static string ThereIsAMappingToImplementationType(Type resolvedType, Type[] serviceTypes);
    private static string DidYouIntendForXToDependOnYInstead(Type consumingType, Type[] serviceTypes);
    private static IEnumerable`1<Type> GetServiceTypesForMappedImplementation(Container container, Type type);
    private static string BuildAssemblyLocationMessage(Type serviceType, Type duplicateAssemblyLookalike);
    private static string GetAssemblyLocationOrNull(Type type);
    private static Type GetDuplicateLoadedAssemblyLookalikeTypeOrNull(Type serviceType, Type[] lookalikes);
    [ExtensionAttribute]
private static string ShortTypeName(Type type);
    [ExtensionAttribute]
private static string TypeName(Type type);
    [ExtensionAttribute]
private static string TypeName(Type type, bool forceFullQualification);
    [ExtensionAttribute]
private static string CSharpFriendlyName(Type type);
    private static string Format(string format, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("TypeFactoryContext ({DebuggerDisplay, nq})")]
public class SimpleInjector.TypeFactoryContext : ApiObject {
    private InjectionConsumerInfo consumer;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    [NullableAttribute("2")]
public InjectionConsumerInfo Consumer { get; }
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    internal TypeFactoryContext(Type serviceType, InjectionConsumerInfo consumer);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [NullableContextAttribute("2")]
public InjectionConsumerInfo get_Consumer();
    internal string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SimpleInjector.Types : object {
    private static Dictionary`2<Type, string> CSharpKeywordTypes;
    private static Type[] AmbiguousTypes;
    private static Func`2<Type[], string> FullyQualifiedNameArgumentsFormatter;
    private static Func`2<Type[], string> SimpleNameArgumentsFormatter;
    private static Func`2<Type[], string> CSharpFriendlyNameArgumentFormatter;
    private static Types();
    [ExtensionAttribute]
internal static bool ContainsGenericParameter(Type type);
    [ExtensionAttribute]
internal static bool IsGenericArgument(Type type);
    [ExtensionAttribute]
internal static bool IsGenericTypeDefinitionOf(Type genericTypeDefinition, Type typeToCheck);
    internal static bool IsAmbiguousOrValueType(Type type);
    internal static bool IsAmbiguousType(Type type);
    [ExtensionAttribute]
internal static bool IsPartiallyClosed(Type type);
    internal static string ToCSharpFriendlyName(Type genericTypeDefinition);
    internal static string ToCSharpFriendlyName(Type genericTypeDefinition, bool fullyQualifiedName);
    [ExtensionAttribute]
internal static string ToFriendlyName(Type type, bool fullyQualifiedName);
    internal static bool IsConcreteConstructableType(Type serviceType);
    internal static bool IsConcreteType(Type serviceType);
    internal static bool IsDecorator(Type serviceType, ConstructorInfo implementationConstructor);
    internal static bool IsComposite(Type serviceType, ConstructorInfo implementationConstructor);
    internal static bool IsGenericCollectionType(Type serviceType);
    internal static List`1<Type> GetTypeHierarchyFor(Type type);
    internal static IEnumerable`1<Type> GetBaseTypeCandidates(Type serviceType, Type implementationType);
    internal static bool ServiceIsAssignableFromImplementation(Type service, Type implementation);
    [ExtensionAttribute]
internal static IEnumerable`1<Type> GetBaseTypesAndInterfacesFor(Type type, Type serviceType);
    [ExtensionAttribute]
internal static IEnumerable`1<Type> GetTypeBaseTypesAndInterfacesFor(Type type, Type serviceType);
    [ExtensionAttribute]
internal static IEnumerable`1<Type> GetBaseTypesAndInterfaces(Type type);
    [ExtensionAttribute]
internal static IEnumerable`1<Type> GetTypeBaseTypesAndInterfaces(Type type);
    [IteratorStateMachineAttribute("SimpleInjector.Types/<GetBaseTypes>d__26")]
[ExtensionAttribute]
private static IEnumerable`1<Type> GetBaseTypes(Type type);
    private static IEnumerable`1<Type> GetGenericImplementationsOf(IEnumerable`1<Type> types, Type serviceType);
    private static bool IsGenericImplementationOf(Type type, Type serviceType);
    [ExtensionAttribute]
private static bool IsVariantVersionOf(Type type, Type otherType);
    [ExtensionAttribute]
private static string ToFriendlyName(Type type, bool fullyQualifiedName, Func`2<Type[], string> argumentsFormatter);
    private static Type[] GetGenericArguments(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SimpleInjector.TypesExtensions : object {
    internal static string FriendlyName;
    [ExtensionAttribute]
public static string ToFriendlyName(Type type);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type type, Type genericTypeDefinition);
    [ExtensionAttribute]
public static Type GetClosedTypeOf(Type type, Type genericTypeDefinition);
    [ExtensionAttribute]
public static Type[] GetClosedTypesOf(Type type, Type genericTypeDefinition);
    private static List`1<Type> GetClosedTypesOfInternal(Type type, Type genericTypeDefinition);
}
public class SimpleInjector.TypesToRegisterOptions : ApiObject {
    [CompilerGeneratedAttribute]
private bool <IncludeDecorators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGenericTypeDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeComposites>k__BackingField;
    public bool IncludeDecorators { get; public set; }
    public bool IncludeGenericTypeDefinitions { get; public set; }
    public bool IncludeComposites { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeDecorators();
    [CompilerGeneratedAttribute]
public void set_IncludeDecorators(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeGenericTypeDefinitions();
    [CompilerGeneratedAttribute]
public void set_IncludeGenericTypeDefinitions(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeComposites();
    [CompilerGeneratedAttribute]
public void set_IncludeComposites(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SimpleInjector.UnregisteredTypeEventArgs : EventArgs {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type <UnregisteredServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Registration <Registration>k__BackingField;
    [NullableAttribute("1")]
public Type UnregisteredServiceType { get; }
    public bool Handled { get; }
    internal Expression Expression { get; private set; }
    internal Registration Registration { get; private set; }
    [NullableContextAttribute("1")]
internal UnregisteredTypeEventArgs(Type unregisteredServiceType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Type get_UnregisteredServiceType();
    public bool get_Handled();
    [CompilerGeneratedAttribute]
internal Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
internal Registration get_Registration();
    [CompilerGeneratedAttribute]
private void set_Registration(Registration value);
    [NullableContextAttribute("1")]
public void Register(Func`1<object> instanceCreator);
    [NullableContextAttribute("1")]
public void Register(Expression expression);
    [NullableContextAttribute("1")]
public void Register(Registration registration);
    private void RequiresNotHandled();
}
public enum SimpleInjector.VerificationOption : Enum {
    public int value__;
    public static VerificationOption VerifyOnly;
    public static VerificationOption VerifyAndDiagnose;
}
public class SimpleInjector.VisualizationOptions : ApiObject {
    [CompilerGeneratedAttribute]
private bool <IncludeLifestyleInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseFullyQualifiedTypeNames>k__BackingField;
    public bool IncludeLifestyleInformation { get; public set; }
    public bool UseFullyQualifiedTypeNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeLifestyleInformation();
    [CompilerGeneratedAttribute]
public void set_IncludeLifestyleInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseFullyQualifiedTypeNames();
    [CompilerGeneratedAttribute]
public void set_UseFullyQualifiedTypeNames(bool value);
}
[ConditionalAttribute("EXCLUDED")]
[AttributeUsageAttribute("749")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
