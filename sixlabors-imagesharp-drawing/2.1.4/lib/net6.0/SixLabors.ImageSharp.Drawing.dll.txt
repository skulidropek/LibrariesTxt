[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class SixLabors.DebugGuard : object {
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void NotNull(TValue value, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void NotNullOrWhiteSpace(string value, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeLessThan(TValue value, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeLessThanOrEqualTo(TValue value, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeGreaterThan(TValue value, TValue min, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeGreaterThanOrEqualTo(TValue value, TValue min, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeBetweenOrEqualTo(TValue value, TValue min, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool target, string parameterName, string message);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool target, string parameterName, string message);
    [ConditionalAttribute("DEBUG")]
public static void MustBeSizedAtLeast(ReadOnlySpan`1<T> source, int minLength, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeSizedAtLeast(Span`1<T> source, int minLength, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void DestinationShouldNotBeTooShort(ReadOnlySpan`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void DestinationShouldNotBeTooShort(Span`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    private static void ThrowArgumentException(string message, string parameterName);
    private static void ThrowArgumentOutOfRangeException(string parameterName, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class SixLabors.Guard : object {
    [NullableContextAttribute("2")]
public static void NotNull(TValue value, string parameterName);
    public static void NotNullOrWhiteSpace(string value, string parameterName);
    public static void MustBeLessThan(TValue value, TValue max, string parameterName);
    public static void MustBeLessThanOrEqualTo(TValue value, TValue max, string parameterName);
    public static void MustBeGreaterThan(TValue value, TValue min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(TValue value, TValue min, string parameterName);
    public static void MustBeBetweenOrEqualTo(TValue value, TValue min, TValue max, string parameterName);
    public static void IsTrue(bool target, string parameterName, string message);
    public static void IsFalse(bool target, string parameterName, string message);
    public static void MustBeSizedAtLeast(ReadOnlySpan`1<T> source, int minLength, string parameterName);
    public static void MustBeSizedAtLeast(Span`1<T> source, int minLength, string parameterName);
    [NullableContextAttribute("2")]
public static void DestinationShouldNotBeTooShort(ReadOnlySpan`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    [NullableContextAttribute("2")]
public static void DestinationShouldNotBeTooShort(Span`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    public static void MustBeLessThan(byte value, byte max, string parameterName);
    public static void MustBeLessThanOrEqualTo(byte value, byte max, string parameterName);
    public static void MustBeGreaterThan(byte value, byte min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(byte value, byte min, string parameterName);
    public static void MustBeBetweenOrEqualTo(byte value, byte min, byte max, string parameterName);
    public static void MustBeLessThan(sbyte value, sbyte max, string parameterName);
    public static void MustBeLessThanOrEqualTo(sbyte value, sbyte max, string parameterName);
    public static void MustBeGreaterThan(sbyte value, sbyte min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(sbyte value, sbyte min, string parameterName);
    public static void MustBeBetweenOrEqualTo(sbyte value, sbyte min, sbyte max, string parameterName);
    public static void MustBeLessThan(short value, short max, string parameterName);
    public static void MustBeLessThanOrEqualTo(short value, short max, string parameterName);
    public static void MustBeGreaterThan(short value, short min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(short value, short min, string parameterName);
    public static void MustBeBetweenOrEqualTo(short value, short min, short max, string parameterName);
    public static void MustBeLessThan(ushort value, ushort max, string parameterName);
    public static void MustBeLessThanOrEqualTo(ushort value, ushort max, string parameterName);
    public static void MustBeGreaterThan(ushort value, ushort min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(ushort value, ushort min, string parameterName);
    public static void MustBeBetweenOrEqualTo(ushort value, ushort min, ushort max, string parameterName);
    public static void MustBeLessThan(char value, char max, string parameterName);
    public static void MustBeLessThanOrEqualTo(char value, char max, string parameterName);
    public static void MustBeGreaterThan(char value, char min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(char value, char min, string parameterName);
    public static void MustBeBetweenOrEqualTo(char value, char min, char max, string parameterName);
    public static void MustBeLessThan(int value, int max, string parameterName);
    public static void MustBeLessThanOrEqualTo(int value, int max, string parameterName);
    public static void MustBeGreaterThan(int value, int min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(int value, int min, string parameterName);
    public static void MustBeBetweenOrEqualTo(int value, int min, int max, string parameterName);
    public static void MustBeLessThan(UInt32 value, UInt32 max, string parameterName);
    public static void MustBeLessThanOrEqualTo(UInt32 value, UInt32 max, string parameterName);
    public static void MustBeGreaterThan(UInt32 value, UInt32 min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(UInt32 value, UInt32 min, string parameterName);
    public static void MustBeBetweenOrEqualTo(UInt32 value, UInt32 min, UInt32 max, string parameterName);
    public static void MustBeLessThan(float value, float max, string parameterName);
    public static void MustBeLessThanOrEqualTo(float value, float max, string parameterName);
    public static void MustBeGreaterThan(float value, float min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(float value, float min, string parameterName);
    public static void MustBeBetweenOrEqualTo(float value, float min, float max, string parameterName);
    public static void MustBeLessThan(long value, long max, string parameterName);
    public static void MustBeLessThanOrEqualTo(long value, long max, string parameterName);
    public static void MustBeGreaterThan(long value, long min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(long value, long min, string parameterName);
    public static void MustBeBetweenOrEqualTo(long value, long min, long max, string parameterName);
    public static void MustBeLessThan(ulong value, ulong max, string parameterName);
    public static void MustBeLessThanOrEqualTo(ulong value, ulong max, string parameterName);
    public static void MustBeGreaterThan(ulong value, ulong min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(ulong value, ulong min, string parameterName);
    public static void MustBeBetweenOrEqualTo(ulong value, ulong min, ulong max, string parameterName);
    public static void MustBeLessThan(double value, double max, string parameterName);
    public static void MustBeLessThanOrEqualTo(double value, double max, string parameterName);
    public static void MustBeGreaterThan(double value, double min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(double value, double min, string parameterName);
    public static void MustBeBetweenOrEqualTo(double value, double min, double max, string parameterName);
    public static void MustBeLessThan(decimal value, decimal max, string parameterName);
    public static void MustBeLessThanOrEqualTo(decimal value, decimal max, string parameterName);
    public static void MustBeGreaterThan(decimal value, decimal min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(decimal value, decimal min, string parameterName);
    public static void MustBeBetweenOrEqualTo(decimal value, decimal min, decimal max, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.ArcLineSegment : object {
    private static float ZeroTolerance;
    private PointF[] linePoints;
    [CompilerGeneratedAttribute]
private PointF <EndPoint>k__BackingField;
    public PointF EndPoint { get; }
    public ArcLineSegment(PointF from, PointF to, SizeF radius, float rotation, bool largeArc, bool sweep);
    public ArcLineSegment(PointF center, SizeF radius, float rotation, float startAngle, float sweepAngle);
    private ArcLineSegment(PointF[] linePoints);
    [CompilerGeneratedAttribute]
public sealed virtual PointF get_EndPoint();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<PointF> Flatten();
    public ILineSegment Transform(Matrix3x2 matrix);
    private sealed virtual override ILineSegment SixLabors.ImageSharp.Drawing.ILineSegment.Transform(Matrix3x2 matrix);
    private static PointF[] EllipticArcFromEndParams(PointF from, PointF to, SizeF radius, float rotation, bool largeArc, bool sweep);
    private static bool EllipticArcOutOfRange(Vector2 from, Vector2 to, Vector2 radius);
    private static Vector2 EllipticArcDerivative(Vector2 r, float xAngle, float t);
    private static Vector2 EllipticArcPoint(Vector2 c, Vector2 r, float xAngle, float t);
    private static PointF[] EllipticArcToBezierCurve(Vector2 from, Vector2 center, Vector2 radius, float xAngle, float startAngle, float sweepAngle);
    private static void EndpointToCenterArcParams(Vector2 p1, Vector2 p2, Vector2& r, float xRotation, bool flagA, bool flagS, Vector2& center, Vector2& angles);
    private static float Clamp(float val, float min, float max);
    private static float SvgAngle(double ux, double uy, double vx, double vy);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.ArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T[] Merge(T[] source1, T[] source2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.ClipPathExtensions : object {
    [ExtensionAttribute]
public static IPath Clip(IPath subjectPath, IPath[] clipPaths);
    [ExtensionAttribute]
public static IPath Clip(IPath subjectPath, ShapeOptions options, IPath[] clipPaths);
    [ExtensionAttribute]
public static IPath Clip(IPath subjectPath, IEnumerable`1<IPath> clipPaths);
    [ExtensionAttribute]
public static IPath Clip(IPath subjectPath, ShapeOptions options, IEnumerable`1<IPath> clipPaths);
}
public enum SixLabors.ImageSharp.Drawing.ClippingOperation : Enum {
    public int value__;
    public static ClippingOperation None;
    public static ClippingOperation Intersection;
    public static ClippingOperation Union;
    public static ClippingOperation Difference;
    public static ClippingOperation Xor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.ComplexPolygon : object {
    private IPath[] paths;
    private List`1<InternalPath> internalPaths;
    private float length;
    [CompilerGeneratedAttribute]
private PathTypes <PathType>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleF <Bounds>k__BackingField;
    public PathTypes PathType { get; }
    public IEnumerable`1<IPath> Paths { get; }
    public RectangleF Bounds { get; }
    public ComplexPolygon(PointF[] contour, PointF[] hole);
    public ComplexPolygon(IEnumerable`1<IPath> paths);
    public ComplexPolygon(IPath[] paths);
    [CompilerGeneratedAttribute]
public sealed virtual PathTypes get_PathType();
    public IEnumerable`1<IPath> get_Paths();
    [CompilerGeneratedAttribute]
public sealed virtual RectangleF get_Bounds();
    public sealed virtual IPath Transform(Matrix3x2 matrix);
    public sealed virtual IEnumerable`1<ISimplePath> Flatten();
    public sealed virtual IPath AsClosedPath();
    private sealed virtual override SegmentInfo SixLabors.ImageSharp.Drawing.IPathInternals.PointAlongPath(float distance);
    private sealed virtual override IReadOnlyList`1<InternalPath> SixLabors.ImageSharp.Drawing.IInternalPathOwner.GetRingsAsInternalPath();
    private static InvalidOperationException ThrowOutOfRange();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.CubicBezierLineSegment : object {
    private static float MinimumSqrDistance;
    private static float DivisionThreshold;
    private PointF[] linePoints;
    private PointF[] controlPoints;
    [CompilerGeneratedAttribute]
private PointF <EndPoint>k__BackingField;
    public IReadOnlyList`1<PointF> ControlPoints { get; }
    public PointF EndPoint { get; }
    public CubicBezierLineSegment(PointF[] points);
    public CubicBezierLineSegment(PointF start, PointF controlPoint1, PointF controlPoint2, PointF end, PointF[] additionalPoints);
    public IReadOnlyList`1<PointF> get_ControlPoints();
    [CompilerGeneratedAttribute]
public sealed virtual PointF get_EndPoint();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<PointF> Flatten();
    public CubicBezierLineSegment Transform(Matrix3x2 matrix);
    private sealed virtual override ILineSegment SixLabors.ImageSharp.Drawing.ILineSegment.Transform(Matrix3x2 matrix);
    private static PointF[] GetDrawingPoints(PointF[] controlPoints);
    private static List`1<PointF> FindDrawingPoints(int curveIndex, PointF[] controlPoints);
    private static int FindDrawingPoints(int curveIndex, float t0, float t1, List`1<PointF> pointList, int insertionIndex, PointF[] controlPoints, int depth);
    private static PointF CalculateBezierPoint(int curveIndex, float t, PointF[] controlPoints);
    private static Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.EllipsePolygon : object {
    private InternalPath innerPath;
    private CubicBezierLineSegment segment;
    public bool IsClosed { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<PointF> Points { get; }
    public RectangleF Bounds { get; }
    public PathTypes PathType { get; }
    public EllipsePolygon(PointF location, SizeF size);
    public EllipsePolygon(PointF location, float radius);
    public EllipsePolygon(float x, float y, float width, float height);
    public EllipsePolygon(float x, float y, float radius);
    private EllipsePolygon(CubicBezierLineSegment segment);
    public sealed virtual bool get_IsClosed();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<PointF> get_Points();
    public sealed virtual RectangleF get_Bounds();
    public sealed virtual PathTypes get_PathType();
    public sealed virtual IPath Transform(Matrix3x2 matrix);
    public sealed virtual IPath AsClosedPath();
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Drawing.EllipsePolygon/<Flatten>d__17")]
public sealed virtual IEnumerable`1<ISimplePath> Flatten();
    private sealed virtual override SegmentInfo SixLabors.ImageSharp.Drawing.IPathInternals.PointAlongPath(float distance);
    private sealed virtual override IReadOnlyList`1<InternalPath> SixLabors.ImageSharp.Drawing.IInternalPathOwner.GetRingsAsInternalPath();
    private static CubicBezierLineSegment CreateSegment(Vector2 location, SizeF size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.EmptyPath : object {
    [CompilerGeneratedAttribute]
private static EmptyPath <ClosedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static EmptyPath <OpenPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PathTypes <PathType>k__BackingField;
    public static EmptyPath ClosedPath { get; }
    public static EmptyPath OpenPath { get; }
    public PathTypes PathType { get; }
    public RectangleF Bounds { get; }
    private EmptyPath(PathTypes pathType);
    private static EmptyPath();
    [CompilerGeneratedAttribute]
public static EmptyPath get_ClosedPath();
    [CompilerGeneratedAttribute]
public static EmptyPath get_OpenPath();
    [CompilerGeneratedAttribute]
public sealed virtual PathTypes get_PathType();
    public sealed virtual RectangleF get_Bounds();
    public sealed virtual IPath AsClosedPath();
    public sealed virtual IEnumerable`1<ISimplePath> Flatten();
    public sealed virtual IPath Transform(Matrix3x2 matrix);
}
public enum SixLabors.ImageSharp.Drawing.EndCapStyle : Enum {
    public int value__;
    public static EndCapStyle Butt;
    public static EndCapStyle Round;
    public static EndCapStyle Square;
    public static EndCapStyle Polygon;
    public static EndCapStyle Joined;
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.GraphicsOptionsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsOpaqueColorWithoutBlending(GraphicsOptions options, Color color);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Drawing.IInternalPathOwner {
    public abstract virtual IReadOnlyList`1<InternalPath> GetRingsAsInternalPath();
}
public interface SixLabors.ImageSharp.Drawing.ILineSegment {
    public PointF EndPoint { get; }
    public abstract virtual PointF get_EndPoint();
    public abstract virtual ReadOnlyMemory`1<PointF> Flatten();
    [NullableContextAttribute("1")]
public abstract virtual ILineSegment Transform(Matrix3x2 matrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.InternalPath : object {
    private static float Epsilon;
    private static float Epsilon2;
    private static Vector2 MaxVector;
    private PointData[] points;
    private bool closedPath;
    [CompilerGeneratedAttribute]
private RectangleF <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Length>k__BackingField;
    public RectangleF Bounds { get; }
    public float Length { get; }
    public int PointCount { get; }
    internal InternalPath(IReadOnlyList`1<ILineSegment> segments, bool isClosedPath, bool removeCloseAndCollinear);
    internal InternalPath(ILineSegment segment, bool isClosedPath);
    [NullableContextAttribute("0")]
internal InternalPath(ReadOnlyMemory`1<PointF> points, bool isClosedPath);
    private InternalPath(PointData[] points, bool isClosedPath);
    private static InternalPath();
    [CompilerGeneratedAttribute]
public RectangleF get_Bounds();
    [CompilerGeneratedAttribute]
public float get_Length();
    public int get_PointCount();
    [NullableContextAttribute("0")]
internal ReadOnlyMemory`1<PointF> Points();
    internal SegmentInfo PointAlongPath(float distanceAlongPath);
    internal IMemoryOwner`1<PointF> ExtractVertices(MemoryAllocator allocator);
    private static int WrapArrayIndex(int i, int arrayLength);
    private static PointOrientation CalulateOrientation(Vector2 p, Vector2 q, Vector2 r);
    private static PointOrientation CalulateOrientation(Vector2 qp, Vector2 rq);
    private static PointData[] Simplify(IReadOnlyList`1<ILineSegment> segments, bool isClosed, bool removeCloseAndCollinear);
    [NullableContextAttribute("0")]
private static PointData[] Simplify(ReadOnlyMemory`1<PointF> vectors, bool isClosed, bool removeCloseAndCollinear);
}
public enum SixLabors.ImageSharp.Drawing.IntersectionRule : Enum {
    public int value__;
    public static IntersectionRule EvenOdd;
    public static IntersectionRule NonZero;
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Drawing.IPath {
    public PathTypes PathType { get; }
    public RectangleF Bounds { get; }
    public abstract virtual PathTypes get_PathType();
    public abstract virtual RectangleF get_Bounds();
    public abstract virtual IEnumerable`1<ISimplePath> Flatten();
    public abstract virtual IPath Transform(Matrix3x2 matrix);
    public abstract virtual IPath AsClosedPath();
}
public interface SixLabors.ImageSharp.Drawing.IPathCollection {
    public RectangleF Bounds { get; }
    public abstract virtual RectangleF get_Bounds();
    [NullableContextAttribute("1")]
public abstract virtual IPathCollection Transform(Matrix3x2 matrix);
}
internal interface SixLabors.ImageSharp.Drawing.IPathInternals {
    public abstract virtual SegmentInfo PointAlongPath(float distance);
}
public interface SixLabors.ImageSharp.Drawing.ISimplePath {
    public bool IsClosed { get; }
    public ReadOnlyMemory`1<PointF> Points { get; }
    public abstract virtual bool get_IsClosed();
    public abstract virtual ReadOnlyMemory`1<PointF> get_Points();
}
public enum SixLabors.ImageSharp.Drawing.JointStyle : Enum {
    public int value__;
    public static JointStyle Square;
    public static JointStyle Round;
    public static JointStyle Miter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.LinearLineSegment : object {
    private PointF[] points;
    [CompilerGeneratedAttribute]
private PointF <EndPoint>k__BackingField;
    public PointF EndPoint { get; }
    public LinearLineSegment(PointF start, PointF end);
    public LinearLineSegment(PointF point1, PointF point2, PointF[] additionalPoints);
    public LinearLineSegment(PointF[] points);
    [CompilerGeneratedAttribute]
public sealed virtual PointF get_EndPoint();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<PointF> Flatten();
    public LinearLineSegment Transform(Matrix3x2 matrix);
    private sealed virtual override ILineSegment SixLabors.ImageSharp.Drawing.ILineSegment.Transform(Matrix3x2 matrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.OutlinePathExtensions : object {
    private static float MiterOffsetDelta;
    private static JointStyle DefaultJointStyle;
    private static EndCapStyle DefaultEndCapStyle;
    private static float CalculateScalingMatrix(float width, Matrix3x2& scaleUpMartrix, Matrix3x2& scaleDownMartrix);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width, JointStyle jointStyle, EndCapStyle endCapStyle);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width, ReadOnlySpan`1<float> pattern);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width, ReadOnlySpan`1<float> pattern, bool startOff);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width, ReadOnlySpan`1<float> pattern, JointStyle jointStyle, EndCapStyle endCapStyle);
    [ExtensionAttribute]
public static IPath GenerateOutline(IPath path, float width, ReadOnlySpan`1<float> pattern, bool startOff, JointStyle jointStyle, EndCapStyle endCapStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Path : object {
    private ILineSegment[] lineSegments;
    [NullableAttribute("2")]
private InternalPath innerPath;
    [CompilerGeneratedAttribute]
private static IPath <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveCloseAndCollinearPoints>k__BackingField;
    public static IPath Empty { get; }
    private bool SixLabors.ImageSharp.Drawing.ISimplePath.IsClosed { get; }
    public bool IsClosed { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<PointF> Points { get; }
    public RectangleF Bounds { get; }
    public PathTypes PathType { get; }
    internal int MaxIntersections { get; }
    public IReadOnlyList`1<ILineSegment> LineSegments { get; }
    internal bool RemoveCloseAndCollinearPoints { get; internal set; }
    private InternalPath InnerPath { get; }
    public Path(PointF[] points);
    public Path(IEnumerable`1<ILineSegment> segments);
    public Path(Path path);
    public Path(ILineSegment[] segments);
    private static Path();
    [CompilerGeneratedAttribute]
public static IPath get_Empty();
    private sealed virtual override bool SixLabors.ImageSharp.Drawing.ISimplePath.get_IsClosed();
    public virtual bool get_IsClosed();
    [NullableContextAttribute("0")]
public sealed virtual ReadOnlyMemory`1<PointF> get_Points();
    public sealed virtual RectangleF get_Bounds();
    public sealed virtual PathTypes get_PathType();
    internal int get_MaxIntersections();
    public IReadOnlyList`1<ILineSegment> get_LineSegments();
    [CompilerGeneratedAttribute]
internal bool get_RemoveCloseAndCollinearPoints();
    [CompilerGeneratedAttribute]
internal void set_RemoveCloseAndCollinearPoints(bool value);
    private InternalPath get_InnerPath();
    public virtual IPath Transform(Matrix3x2 matrix);
    public sealed virtual IPath AsClosedPath();
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Drawing.Path/<Flatten>d__31")]
public sealed virtual IEnumerable`1<ISimplePath> Flatten();
    private sealed virtual override SegmentInfo SixLabors.ImageSharp.Drawing.IPathInternals.PointAlongPath(float distance);
    private sealed virtual override IReadOnlyList`1<InternalPath> SixLabors.ImageSharp.Drawing.IInternalPathOwner.GetRingsAsInternalPath();
    public static bool TryParseSvgPath(string svgPath, IPath& value);
    [NullableContextAttribute("0")]
public static bool TryParseSvgPath(ReadOnlySpan`1<char> svgPath, IPath& value);
    [NullableContextAttribute("0")]
private static bool TryTrimSeparator(ReadOnlySpan`1& str);
    [NullableContextAttribute("0")]
private static bool TryFindScaler(ReadOnlySpan`1& str, Single& value);
    [NullableContextAttribute("0")]
private static bool TryFindPoint(ReadOnlySpan`1& str, bool relative, PointF current, PointF& value);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<char> FindPoint(ReadOnlySpan`1<char> str, bool isRelative, PointF relative, PointF& value);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<char> FindScaler(ReadOnlySpan`1<char> str, Single& scaler);
    private static bool IsSeparator(char ch);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<char> TrimSeparator(ReadOnlySpan`1<char> data);
    [NullableContextAttribute("0")]
private static float ParseFloat(ReadOnlySpan`1<char> str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.PathBuilder : object {
    private List`1<Figure> figures;
    private Matrix3x2 defaultTransform;
    private Figure currentFigure;
    private Matrix3x2 currentTransform;
    private Matrix3x2 setTransform;
    private Vector2 currentPoint;
    public PathBuilder(Matrix3x2 defaultTransform);
    public PathBuilder SetTransform(Matrix3x2 transform);
    public PathBuilder SetOrigin(PointF origin);
    public PathBuilder ResetTransform();
    public PathBuilder ResetOrigin();
    public PathBuilder MoveTo(PointF point);
    public PathBuilder LineTo(PointF point);
    public PathBuilder LineTo(float x, float y);
    public PathBuilder AddLine(PointF start, PointF end);
    public PathBuilder AddLine(float x1, float y1, float x2, float y2);
    public PathBuilder AddLines(IEnumerable`1<PointF> points);
    public PathBuilder AddLines(PointF[] points);
    public PathBuilder AddSegment(ILineSegment segment);
    public PathBuilder QuadraticBezierTo(Vector2 secondControlPoint, Vector2 point);
    public PathBuilder CubicBezierTo(Vector2 secondControlPoint, Vector2 thirdControlPoint, Vector2 point);
    public PathBuilder AddQuadraticBezier(PointF startPoint, PointF controlPoint, PointF endPoint);
    public PathBuilder AddCubicBezier(PointF startPoint, PointF controlPoint1, PointF controlPoint2, PointF endPoint);
    public PathBuilder ArcTo(float radiusX, float radiusY, float rotation, bool largeArc, bool sweep, PointF point);
    public PathBuilder AddArc(PointF startPoint, float radiusX, float radiusY, float rotation, bool largeArc, bool sweep, PointF endPoint);
    public PathBuilder AddArc(RectangleF rectangle, float rotation, float startAngle, float sweepAngle);
    public PathBuilder AddArc(Rectangle rectangle, int rotation, int startAngle, int sweepAngle);
    public PathBuilder AddArc(PointF center, float radiusX, float radiusY, float rotation, float startAngle, float sweepAngle);
    public PathBuilder AddArc(Point center, int radiusX, int radiusY, int rotation, int startAngle, int sweepAngle);
    public PathBuilder AddArc(int x, int y, int radiusX, int radiusY, int rotation, int startAngle, int sweepAngle);
    public PathBuilder AddArc(float x, float y, float radiusX, float radiusY, float rotation, float startAngle, float sweepAngle);
    public PathBuilder StartFigure();
    public PathBuilder CloseFigure();
    public PathBuilder CloseAllFigures();
    public IPath Build();
    public PathBuilder Reset();
    [MemberNotNullAttribute("currentFigure")]
public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.PathCollection : object {
    private IPath[] paths;
    [CompilerGeneratedAttribute]
private RectangleF <Bounds>k__BackingField;
    public RectangleF Bounds { get; }
    public PathCollection(IEnumerable`1<IPath> paths);
    public PathCollection(IPath[] paths);
    [CompilerGeneratedAttribute]
public sealed virtual RectangleF get_Bounds();
    public sealed virtual IEnumerator`1<IPath> GetEnumerator();
    public sealed virtual IPathCollection Transform(Matrix3x2 matrix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.PathExtensions : object {
    [ExtensionAttribute]
public static IPathCollection Rotate(IPathCollection path, float radians);
    [ExtensionAttribute]
public static IPathCollection RotateDegree(IPathCollection shape, float degree);
    [ExtensionAttribute]
public static IPathCollection Translate(IPathCollection path, PointF position);
    [ExtensionAttribute]
public static IPathCollection Translate(IPathCollection path, float x, float y);
    [ExtensionAttribute]
public static IPathCollection Scale(IPathCollection path, float scaleX, float scaleY);
    [ExtensionAttribute]
public static IPathCollection Scale(IPathCollection path, float scale);
    [ExtensionAttribute]
public static IPath Rotate(IPath path, float radians);
    [ExtensionAttribute]
public static IPath RotateDegree(IPath shape, float degree);
    [ExtensionAttribute]
public static IPath Translate(IPath path, PointF position);
    [ExtensionAttribute]
public static IPath Translate(IPath path, float x, float y);
    [ExtensionAttribute]
public static IPath Scale(IPath path, float scaleX, float scaleY);
    [ExtensionAttribute]
public static IPath Scale(IPath path, float scale);
    [ExtensionAttribute]
public static float ComputeLength(IPath path);
    [ExtensionAttribute]
internal static IPath Reverse(IPath path);
}
public enum SixLabors.ImageSharp.Drawing.PathTypes : Enum {
    public int value__;
    public static PathTypes Open;
    public static PathTypes Closed;
    public static PathTypes Mixed;
}
internal enum SixLabors.ImageSharp.Drawing.PointOrientation : Enum {
    public int value__;
    public static PointOrientation Collinear;
    public static PointOrientation Clockwise;
    public static PointOrientation Counterclockwise;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Polygon : Path {
    public bool IsClosed { get; }
    public Polygon(PointF[] points);
    public Polygon(ILineSegment[] segments);
    public Polygon(IEnumerable`1<ILineSegment> segments);
    public Polygon(ILineSegment segment);
    internal Polygon(Path path);
    public virtual bool get_IsClosed();
    public virtual IPath Transform(Matrix3x2 matrix);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Drawing.Processing.Brush : object {
    [NullableContextAttribute("1")]
public abstract virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
    public abstract virtual bool Equals(Brush other);
    public virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Drawing.Processing.BrushApplicator`1 : object {
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private PixelBlender`1<TPixel> <Blender>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImageFrame`1<TPixel> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphicsOptions <Options>k__BackingField;
    protected Configuration Configuration { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal PixelBlender`1<TPixel> Blender { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImageFrame`1<TPixel> Target { get; }
    protected GraphicsOptions Options { get; }
    protected BrushApplicator`1(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> target);
    [CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    [CompilerGeneratedAttribute]
internal PixelBlender`1<TPixel> get_Blender();
    [CompilerGeneratedAttribute]
protected ImageFrame`1<TPixel> get_Target();
    [CompilerGeneratedAttribute]
protected GraphicsOptions get_Options();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("0")]
public abstract virtual void Apply(Span`1<float> scanline, int x, int y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Drawing.Processing.Brushes : object {
    private static Boolean[0...,0...] Percent10Pattern;
    private static Boolean[0...,0...] Percent20Pattern;
    private static Boolean[0...,0...] HorizontalPattern;
    private static Boolean[0...,0...] MinPattern;
    private static Boolean[0...,0...] VerticalPattern;
    private static Boolean[0...,0...] ForwardDiagonalPattern;
    private static Boolean[0...,0...] BackwardDiagonalPattern;
    private static Brushes();
    public static SolidBrush Solid(Color color);
    public static PatternBrush Percent10(Color foreColor);
    public static PatternBrush Percent10(Color foreColor, Color backColor);
    public static PatternBrush Percent20(Color foreColor);
    public static PatternBrush Percent20(Color foreColor, Color backColor);
    public static PatternBrush Horizontal(Color foreColor);
    public static PatternBrush Horizontal(Color foreColor, Color backColor);
    public static PatternBrush Min(Color foreColor);
    public static PatternBrush Min(Color foreColor, Color backColor);
    public static PatternBrush Vertical(Color foreColor);
    public static PatternBrush Vertical(Color foreColor, Color backColor);
    public static PatternBrush ForwardDiagonal(Color foreColor);
    public static PatternBrush ForwardDiagonal(Color foreColor, Color backColor);
    public static PatternBrush BackwardDiagonal(Color foreColor);
    public static PatternBrush BackwardDiagonal(Color foreColor, Color backColor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.ClearExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Brush brush);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Brush brush);
    [ExtensionAttribute]
internal static DrawingOptions CloneForClearOperation(DrawingOptions drawingOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.ClearPathExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Color color, IPath region);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Color color, IPath region);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Brush brush, IPath region);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Brush brush, IPath region);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.ClearRectangleExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Color color, RectangleF rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Color color, RectangleF rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, Brush brush, RectangleF rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Clear(IImageProcessingContext source, DrawingOptions options, Brush brush, RectangleF rectangle);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.ClipPathExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageProcessingContext Clip(IImageProcessingContext source, IPath region, Action`1<IImageProcessingContext> operation);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("ColorStop({Ratio} -> {Color}")]
public class SixLabors.ImageSharp.Drawing.Processing.ColorStop : ValueType {
    [CompilerGeneratedAttribute]
private float <Ratio>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    public float Ratio { get; }
    public Color Color { get; }
    public ColorStop(float ratio, Color& color);
    [CompilerGeneratedAttribute]
public float get_Ratio();
    [CompilerGeneratedAttribute]
public Color get_Color();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawBezierExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, DrawingOptions options, Pen pen, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, Pen pen, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, Color color, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawBeziers(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, PointF[] points);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.Processing.DrawingHelpers : object {
    [ExtensionAttribute]
public static DenseMatrix`1<TPixel> ToPixelMatrix(DenseMatrix`1<Color> colorMatrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.DrawingOptions : object {
    private GraphicsOptions graphicsOptions;
    private ShapeOptions shapeOptions;
    [CompilerGeneratedAttribute]
private Matrix3x2 <Transform>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; public set; }
    public ShapeOptions ShapeOptions { get; public set; }
    public Matrix3x2 Transform { get; public set; }
    internal DrawingOptions(GraphicsOptions graphicsOptions, ShapeOptions shapeOptions, Matrix3x2 transform);
    public GraphicsOptions get_GraphicsOptions();
    public void set_GraphicsOptions(GraphicsOptions value);
    public ShapeOptions get_ShapeOptions();
    public void set_ShapeOptions(ShapeOptions value);
    [CompilerGeneratedAttribute]
public Matrix3x2 get_Transform();
    [CompilerGeneratedAttribute]
public void set_Transform(Matrix3x2 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawingOptionsDefaultsExtensions : object {
    private static string DrawingTransformMatrixKey;
    [ExtensionAttribute]
public static DrawingOptions GetDrawingOptions(IImageProcessingContext context);
    [ExtensionAttribute]
public static IImageProcessingContext SetDrawingTransform(IImageProcessingContext context, Matrix3x2 matrix);
    [ExtensionAttribute]
public static void SetDrawingTransform(Configuration configuration, Matrix3x2 matrix);
    [ExtensionAttribute]
public static Matrix3x2 GetDrawingTransform(IImageProcessingContext context);
    [ExtensionAttribute]
public static Matrix3x2 GetDrawingTransform(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawLineExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, Color color, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, DrawingOptions options, Pen pen, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawLine(IImageProcessingContext source, Pen pen, PointF[] points);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawPathCollectionExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Pen pen, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Pen pen, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Brush brush, float thickness, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Color color, float thickness, IPathCollection paths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawPathExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Pen pen, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Pen pen, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Brush brush, float thickness, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Color color, float thickness, IPath path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawPolygonExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, Pen pen, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, DrawingOptions options, Pen pen, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, Brush brush, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, Color color, float thickness, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext DrawPolygon(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, PointF[] points);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawRectangleExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Pen pen, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Pen pen, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Brush brush, float thickness, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Brush brush, float thickness, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, DrawingOptions options, Color color, float thickness, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Draw(IImageProcessingContext source, Color color, float thickness, RectangleF shape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.DrawTextExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, string text, Font font, Color color, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, DrawingOptions drawingOptions, string text, Font font, Color color, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, RichTextOptions textOptions, string text, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, string text, Font font, Brush brush, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, string text, Font font, Pen pen, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, string text, Font font, Brush brush, Pen pen, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, RichTextOptions textOptions, string text, Brush brush);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, RichTextOptions textOptions, string text, Pen pen);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, RichTextOptions textOptions, string text, Brush brush, Pen pen);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, DrawingOptions drawingOptions, string text, Font font, Pen pen, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, DrawingOptions drawingOptions, string text, Font font, Brush brush, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, DrawingOptions drawingOptions, string text, Font font, Brush brush, Pen pen, PointF location);
    [ExtensionAttribute]
public static IImageProcessingContext DrawText(IImageProcessingContext source, DrawingOptions drawingOptions, RichTextOptions textOptions, string text, Brush brush, Pen pen);
}
public class SixLabors.ImageSharp.Drawing.Processing.EllipticGradientBrush : GradientBrush {
    private PointF center;
    private PointF referenceAxisEnd;
    private float axisRatio;
    [NullableContextAttribute("1")]
public EllipticGradientBrush(PointF center, PointF referenceAxisEnd, float axisRatio, GradientRepetitionMode repetitionMode, ColorStop[] colorStops);
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Brush brush);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Brush brush);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillPathBuilderExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Color color, Action`1<PathBuilder> region);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Color color, Action`1<PathBuilder> region);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Brush brush, Action`1<PathBuilder> region);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Brush brush, Action`1<PathBuilder> region);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillPathCollectionExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Brush brush, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Brush brush, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Color color, IPathCollection paths);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Color color, IPathCollection paths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillPathExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Color color, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Color color, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Brush brush, IPath path);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Brush brush, IPath path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillPolygonExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext FillPolygon(IImageProcessingContext source, DrawingOptions options, Brush brush, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext FillPolygon(IImageProcessingContext source, Brush brush, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext FillPolygon(IImageProcessingContext source, DrawingOptions options, Color color, PointF[] points);
    [ExtensionAttribute]
public static IImageProcessingContext FillPolygon(IImageProcessingContext source, Color color, PointF[] points);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.FillRectangleExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Brush brush, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Brush brush, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, DrawingOptions options, Color color, RectangleF shape);
    [ExtensionAttribute]
public static IImageProcessingContext Fill(IImageProcessingContext source, Color color, RectangleF shape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Drawing.Processing.GradientBrush : Brush {
    [CompilerGeneratedAttribute]
private GradientRepetitionMode <RepetitionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorStop[] <ColorStops>k__BackingField;
    protected GradientRepetitionMode RepetitionMode { get; }
    protected ColorStop[] ColorStops { get; }
    protected GradientBrush(GradientRepetitionMode repetitionMode, ColorStop[] colorStops);
    [CompilerGeneratedAttribute]
protected GradientRepetitionMode get_RepetitionMode();
    [CompilerGeneratedAttribute]
protected ColorStop[] get_ColorStops();
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
}
public enum SixLabors.ImageSharp.Drawing.Processing.GradientRepetitionMode : Enum {
    public int value__;
    public static GradientRepetitionMode None;
    public static GradientRepetitionMode Repeat;
    public static GradientRepetitionMode Reflect;
    public static GradientRepetitionMode DontFill;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.ImageBrush : Brush {
    private Image image;
    private RectangleF region;
    private Point offset;
    public ImageBrush(Image image);
    public ImageBrush(Image image, Point offset);
    public ImageBrush(Image image, RectangleF region);
    public ImageBrush(Image image, RectangleF region, Point offset);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
    public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
}
public class SixLabors.ImageSharp.Drawing.Processing.LinearGradientBrush : GradientBrush {
    private PointF p1;
    private PointF p2;
    [NullableContextAttribute("1")]
public LinearGradientBrush(PointF p1, PointF p2, GradientRepetitionMode repetitionMode, ColorStop[] colorStops);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.PathGradientBrush : Brush {
    private Edge[] edges;
    private Color centerColor;
    private bool hasSpecialCenterColor;
    public PathGradientBrush(PointF[] points, Color[] colors);
    public PathGradientBrush(PointF[] points, Color[] colors, Color centerColor);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
    public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
    private static Color CalculateCenterColor(Color[] colors);
    private static float DistanceBetween(Vector2 p1, Vector2 p2);
    [CompilerGeneratedAttribute]
internal static Color <.ctor>g__ColorAt|3_0(int index, <>c__DisplayClass3_0& );
}
public class SixLabors.ImageSharp.Drawing.Processing.PatternBrush : Brush {
    private DenseMatrix`1<Color> pattern;
    private DenseMatrix`1<Vector4> patternVector;
    [NullableContextAttribute("1")]
public PatternBrush(Color foreColor, Color backColor, Boolean[0...,0...] pattern);
    internal PatternBrush(Color foreColor, Color backColor, DenseMatrix`1& pattern);
    [NullableContextAttribute("1")]
internal PatternBrush(PatternBrush brush);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.PatternPen : Pen {
    public PatternPen(Color color, Single[] strokePattern);
    public PatternPen(Color color, float strokeWidth, Single[] strokePattern);
    public PatternPen(Brush strokeFill, float strokeWidth, Single[] strokePattern);
    public PatternPen(PenOptions options);
    [NullableContextAttribute("2")]
public virtual bool Equals(Pen other);
    public virtual IPath GeneratePath(IPath path, float strokeWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Drawing.Processing.Pen : object {
    private Single[] pattern;
    [CompilerGeneratedAttribute]
private Brush <StrokeFill>k__BackingField;
    [CompilerGeneratedAttribute]
private float <StrokeWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private JointStyle <JointStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private EndCapStyle <EndCapStyle>k__BackingField;
    public Brush StrokeFill { get; }
    public float StrokeWidth { get; }
    [NullableAttribute("0")]
public ReadOnlySpan`1<float> StrokePattern { get; }
    public JointStyle JointStyle { get; }
    public EndCapStyle EndCapStyle { get; }
    protected Pen(Brush strokeFill);
    protected Pen(Brush strokeFill, float strokeWidth);
    protected Pen(Brush strokeFill, float strokeWidth, Single[] strokePattern);
    protected Pen(PenOptions options);
    [CompilerGeneratedAttribute]
public Brush get_StrokeFill();
    [CompilerGeneratedAttribute]
public float get_StrokeWidth();
    [NullableContextAttribute("0")]
public ReadOnlySpan`1<float> get_StrokePattern();
    [CompilerGeneratedAttribute]
public JointStyle get_JointStyle();
    [CompilerGeneratedAttribute]
public EndCapStyle get_EndCapStyle();
    public IPath GeneratePath(IPath path);
    public abstract virtual IPath GeneratePath(IPath path, float strokeWidth);
    [NullableContextAttribute("2")]
public virtual bool Equals(Pen other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.PenOptions : ValueType {
    [CompilerGeneratedAttribute]
private Brush <StrokeFill>k__BackingField;
    [CompilerGeneratedAttribute]
private float <StrokeWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[] <StrokePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private JointStyle <JointStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private EndCapStyle <EndCapStyle>k__BackingField;
    public Brush StrokeFill { get; }
    public float StrokeWidth { get; }
    public Single[] StrokePattern { get; }
    public JointStyle JointStyle { get; public set; }
    public EndCapStyle EndCapStyle { get; public set; }
    public PenOptions(float strokeWidth);
    public PenOptions(Color color, float strokeWidth);
    [NullableContextAttribute("2")]
public PenOptions(Color color, float strokeWidth, Single[] strokePattern);
    public PenOptions(Brush strokeFill, float strokeWidth, Single[] strokePattern);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Brush get_StrokeFill();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_StrokeWidth();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Single[] get_StrokePattern();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JointStyle get_JointStyle();
    [CompilerGeneratedAttribute]
public void set_JointStyle(JointStyle value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EndCapStyle get_EndCapStyle();
    [CompilerGeneratedAttribute]
public void set_EndCapStyle(EndCapStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Drawing.Processing.Pens : object {
    private static Single[] DashDotPattern;
    private static Single[] DashDotDotPattern;
    private static Single[] DottedPattern;
    private static Single[] DashedPattern;
    internal static Single[] EmptyPattern;
    private static Pens();
    public static SolidPen Solid(Color color);
    public static SolidPen Solid(Brush brush);
    public static SolidPen Solid(Color color, float width);
    public static SolidPen Solid(Brush brush, float width);
    public static PatternPen Dash(Color color, float width);
    public static PatternPen Dash(Brush brush, float width);
    public static PatternPen Dot(Color color, float width);
    public static PatternPen Dot(Brush brush, float width);
    public static PatternPen DashDot(Color color, float width);
    public static PatternPen DashDot(Brush brush, float width);
    public static PatternPen DashDotDot(Color color, float width);
    public static PatternPen DashDotDot(Brush brush, float width);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.ClipPathProcessor : object {
    [CompilerGeneratedAttribute]
private DrawingOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IPath <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IImageProcessingContext> <Operation>k__BackingField;
    public DrawingOptions Options { get; }
    public IPath Region { get; }
    public Action`1<IImageProcessingContext> Operation { get; }
    public ClipPathProcessor(DrawingOptions options, IPath path, Action`1<IImageProcessingContext> operation);
    [CompilerGeneratedAttribute]
public DrawingOptions get_Options();
    [CompilerGeneratedAttribute]
public IPath get_Region();
    [CompilerGeneratedAttribute]
public Action`1<IImageProcessingContext> get_Operation();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.ClipPathProcessor`1 : object {
    [NullableAttribute("1")]
private ClipPathProcessor definition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Image`1<TPixel> source;
    [NullableAttribute("1")]
private Configuration configuration;
    private Rectangle sourceRectangle;
    [NullableContextAttribute("1")]
public ClipPathProcessor`1(ClipPathProcessor definition, Image`1<TPixel> source, Configuration configuration, Rectangle sourceRectangle);
    public sealed virtual void Dispose();
    public sealed virtual void Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.DrawPathProcessor : object {
    [CompilerGeneratedAttribute]
private Pen <Pen>k__BackingField;
    [CompilerGeneratedAttribute]
private IPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DrawingOptions <Options>k__BackingField;
    public Pen Pen { get; }
    public IPath Path { get; }
    public DrawingOptions Options { get; }
    public DrawPathProcessor(DrawingOptions options, Pen pen, IPath path);
    [CompilerGeneratedAttribute]
public Pen get_Pen();
    [CompilerGeneratedAttribute]
public IPath get_Path();
    [CompilerGeneratedAttribute]
public DrawingOptions get_Options();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.FillPathProcessor : object {
    internal static int MinimumSubpixelCount;
    [CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private IPath <Region>k__BackingField;
    [CompilerGeneratedAttribute]
private DrawingOptions <Options>k__BackingField;
    public Brush Brush { get; }
    public IPath Region { get; }
    public DrawingOptions Options { get; }
    public FillPathProcessor(DrawingOptions options, Brush brush, IPath path);
    [CompilerGeneratedAttribute]
public Brush get_Brush();
    [CompilerGeneratedAttribute]
public IPath get_Region();
    [CompilerGeneratedAttribute]
public DrawingOptions get_Options();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.FillPathProcessor`1 : ImageProcessor`1<TPixel> {
    private FillPathProcessor definition;
    private IPath path;
    private Rectangle bounds;
    public FillPathProcessor`1(Configuration configuration, FillPathProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static bool IsSolidBrushWithoutBlending(GraphicsOptions options, Brush inputBrush, SolidBrush& solidBrush);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.FillProcessor : object {
    [CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private DrawingOptions <Options>k__BackingField;
    public Brush Brush { get; }
    public DrawingOptions Options { get; }
    public FillProcessor(DrawingOptions options, Brush brush);
    [CompilerGeneratedAttribute]
public Brush get_Brush();
    [CompilerGeneratedAttribute]
public DrawingOptions get_Options();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Drawing.FillProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private FillProcessor definition;
    [NullableContextAttribute("1")]
public FillProcessor`1(Configuration configuration, FillProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    [NullableContextAttribute("2")]
private bool IsSolidBrushWithoutBlending(SolidBrush& solidBrush);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Text.DrawingOperation : ValueType {
    [CompilerGeneratedAttribute]
private Buffer2D`1<float> <Map>k__BackingField;
    [CompilerGeneratedAttribute]
private IPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <RenderPass>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <RenderLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    public Buffer2D`1<float> Map { get; public set; }
    public IPath Path { get; public set; }
    public byte RenderPass { get; public set; }
    public Point RenderLocation { get; public set; }
    public Brush Brush { get; internal set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Buffer2D`1<float> get_Map();
    [CompilerGeneratedAttribute]
public void set_Map(Buffer2D`1<float> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IPath get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(IPath value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_RenderPass();
    [CompilerGeneratedAttribute]
public void set_RenderPass(byte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Point get_RenderLocation();
    [CompilerGeneratedAttribute]
public void set_RenderLocation(Point value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Brush get_Brush();
    [CompilerGeneratedAttribute]
internal void set_Brush(Brush value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.Processors.Text.DrawTextProcessor : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private DrawingOptions <DrawingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private RichTextOptions <TextOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Pen <Pen>k__BackingField;
    [CompilerGeneratedAttribute]
private PointF <Location>k__BackingField;
    [NullableAttribute("2")]
public Brush Brush { get; }
    public DrawingOptions DrawingOptions { get; }
    public RichTextOptions TextOptions { get; }
    public string Text { get; }
    [NullableAttribute("2")]
public Pen Pen { get; }
    public PointF Location { get; }
    public DrawTextProcessor(DrawingOptions drawingOptions, RichTextOptions textOptions, string text, Brush brush, Pen pen);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Brush get_Brush();
    [CompilerGeneratedAttribute]
public DrawingOptions get_DrawingOptions();
    [CompilerGeneratedAttribute]
public RichTextOptions get_TextOptions();
    [CompilerGeneratedAttribute]
public string get_Text();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Pen get_Pen();
    [CompilerGeneratedAttribute]
public PointF get_Location();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Text.DrawTextProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("2")]
private RichTextGlyphRenderer textRenderer;
    private DrawTextProcessor definition;
    public DrawTextProcessor`1(Configuration configuration, DrawTextProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void AfterImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static RichTextOptions ConfigureOptions(RichTextOptions options);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnFrameApply>g__Draw|5_0(IEnumerable`1<DrawingOperation> operations, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Processing.Processors.Text.RichTextGlyphRenderer : BaseGlyphBuilder {
    private static byte RenderOrderFill;
    private static byte RenderOrderOutline;
    private static byte RenderOrderDecoration;
    private DrawingOptions drawingOptions;
    private MemoryAllocator memoryAllocator;
    [NullableAttribute("2")]
private Pen defaultPen;
    [NullableAttribute("2")]
private Brush defaultBrush;
    [NullableAttribute("2")]
private IPathInternals path;
    private bool isDisposed;
    private Dictionary`2<Color, Brush> brushLookup;
    [NullableAttribute("2")]
private TextRun currentTextRun;
    [NullableAttribute("2")]
private Brush currentBrush;
    [NullableAttribute("2")]
private Pen currentPen;
    private Nullable`1<Color> currentColor;
    private Nullable`1<TextDecorationDetails> currentUnderline;
    private Nullable`1<TextDecorationDetails> currentStrikeout;
    private Nullable`1<TextDecorationDetails> currentOverline;
    private bool currentDecorationIsVertical;
    private static float AccuracyMultiple;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<GlyphRendererParameters, RectangleF>, GlyphRenderData> glyphData;
    private bool rasterizationRequired;
    private bool noCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
private ValueTuple`2<GlyphRendererParameters, RectangleF> currentCacheKey;
    [CompilerGeneratedAttribute]
private List`1<DrawingOperation> <DrawingOperations>k__BackingField;
    public List`1<DrawingOperation> DrawingOperations { get; }
    public RichTextGlyphRenderer(RichTextOptions textOptions, DrawingOptions drawingOptions, MemoryAllocator memoryAllocator, Pen pen, Brush brush);
    [CompilerGeneratedAttribute]
public List`1<DrawingOperation> get_DrawingOperations();
    protected virtual void BeginText(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds);
    protected virtual void BeginGlyph(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds, GlyphRendererParameters& modreq(System.Runtime.InteropServices.InAttribute) parameters);
    public sealed virtual void SetColor(GlyphColor color);
    public virtual TextDecorations EnabledDecorations();
    public virtual void SetDecoration(TextDecorations textDecorations, Vector2 start, Vector2 end, float thickness);
    protected virtual void EndGlyph();
    protected virtual void EndText();
    public sealed virtual void Dispose();
    private static Point ClampToPixel(PointF point);
    private static PointF ClampToPixel(PointF point, int thickness, bool rotated);
    private void FinalizeDecoration(Nullable`1& decoration);
    private void AppendDecoration(Nullable`1& decoration, Vector2 start, Vector2 end, Pen pen, float thickness, bool rotated);
    private void TransformGlyph(FontRectangle& bounds);
    private Matrix3x2 ComputeTransform(FontRectangle& bounds);
    private Buffer2D`1<float> Render(IPath path);
    private void Dispose(bool disposing);
}
public class SixLabors.ImageSharp.Drawing.Processing.RadialGradientBrush : GradientBrush {
    private PointF center;
    private float radius;
    [NullableContextAttribute("1")]
public RadialGradientBrush(PointF center, float radius, GradientRepetitionMode repetitionMode, ColorStop[] colorStops);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
}
public class SixLabors.ImageSharp.Drawing.Processing.RecolorBrush : Brush {
    [CompilerGeneratedAttribute]
private float <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <SourceColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <TargetColor>k__BackingField;
    public float Threshold { get; }
    public Color SourceColor { get; }
    public Color TargetColor { get; }
    public RecolorBrush(Color sourceColor, Color targetColor, float threshold);
    [CompilerGeneratedAttribute]
public float get_Threshold();
    [CompilerGeneratedAttribute]
public Color get_SourceColor();
    [CompilerGeneratedAttribute]
public Color get_TargetColor();
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.RichTextOptions : TextOptions {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPath <Path>k__BackingField;
    public IReadOnlyList`1<RichTextRun> TextRuns { get; public set; }
    [NullableAttribute("2")]
public IPath Path { get; public set; }
    public RichTextOptions(Font font);
    public RichTextOptions(RichTextOptions options);
    public IReadOnlyList`1<RichTextRun> get_TextRuns();
    public void set_TextRuns(IReadOnlyList`1<RichTextRun> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPath get_Path();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Path(IPath value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.RichTextRun : TextRun {
    [CompilerGeneratedAttribute]
private Brush <Brush>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <Pen>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <StrikeoutPen>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <UnderlinePen>k__BackingField;
    [CompilerGeneratedAttribute]
private Pen <OverlinePen>k__BackingField;
    public Brush Brush { get; public set; }
    public Pen Pen { get; public set; }
    public Pen StrikeoutPen { get; public set; }
    public Pen UnderlinePen { get; public set; }
    public Pen OverlinePen { get; public set; }
    [CompilerGeneratedAttribute]
public Brush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(Brush value);
    [CompilerGeneratedAttribute]
public Pen get_Pen();
    [CompilerGeneratedAttribute]
public void set_Pen(Pen value);
    [CompilerGeneratedAttribute]
public Pen get_StrikeoutPen();
    [CompilerGeneratedAttribute]
public void set_StrikeoutPen(Pen value);
    [CompilerGeneratedAttribute]
public Pen get_UnderlinePen();
    [CompilerGeneratedAttribute]
public void set_UnderlinePen(Pen value);
    [CompilerGeneratedAttribute]
public Pen get_OverlinePen();
    [CompilerGeneratedAttribute]
public void set_OverlinePen(Pen value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Drawing.Processing.ShapeGraphicOptionsDefaultsExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext SetShapeOptions(IImageProcessingContext context, Action`1<ShapeOptions> optionsBuilder);
    [ExtensionAttribute]
public static void SetShapeOptions(Configuration configuration, Action`1<ShapeOptions> optionsBuilder);
    [ExtensionAttribute]
public static IImageProcessingContext SetShapeOptions(IImageProcessingContext context, ShapeOptions options);
    [ExtensionAttribute]
public static void SetShapeOptions(Configuration configuration, ShapeOptions options);
    [ExtensionAttribute]
public static ShapeOptions GetShapeOptions(IImageProcessingContext context);
    [ExtensionAttribute]
public static ShapeOptions GetShapeOptions(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.ShapeOptions : object {
    [CompilerGeneratedAttribute]
private ClippingOperation <ClippingOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private IntersectionRule <IntersectionRule>k__BackingField;
    public ClippingOperation ClippingOperation { get; public set; }
    public IntersectionRule IntersectionRule { get; public set; }
    private ShapeOptions(ShapeOptions source);
    [CompilerGeneratedAttribute]
public ClippingOperation get_ClippingOperation();
    [CompilerGeneratedAttribute]
public void set_ClippingOperation(ClippingOperation value);
    [CompilerGeneratedAttribute]
public IntersectionRule get_IntersectionRule();
    [CompilerGeneratedAttribute]
public void set_IntersectionRule(IntersectionRule value);
    public sealed virtual ShapeOptions DeepClone();
}
public class SixLabors.ImageSharp.Drawing.Processing.SolidBrush : Brush {
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    public Color Color { get; }
    public SolidBrush(Color color);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [NullableContextAttribute("1")]
public virtual BrushApplicator`1<TPixel> CreateApplicator(Configuration configuration, GraphicsOptions options, ImageFrame`1<TPixel> source, RectangleF region);
    [NullableContextAttribute("2")]
public virtual bool Equals(Brush other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Processing.SolidPen : Pen {
    public SolidPen(Color color);
    public SolidPen(Color color, float width);
    public SolidPen(Brush strokeFill);
    public SolidPen(Brush strokeFill, float strokeWidth);
    public SolidPen(PenOptions options);
    [NullableContextAttribute("2")]
public virtual bool Equals(Pen other);
    public virtual IPath GeneratePath(IPath path, float strokeWidth);
}
public class SixLabors.ImageSharp.Drawing.RectangularPolygon : object {
    private Vector2 topLeft;
    private Vector2 bottomRight;
    [NullableAttribute("1")]
private PointF[] points;
    private float halfLength;
    private float length;
    [CompilerGeneratedAttribute]
private PointF <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleF <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private SizeF <Size>k__BackingField;
    public PointF Location { get; }
    public float Left { get; }
    public float X { get; }
    public float Right { get; }
    public float Top { get; }
    public float Y { get; }
    public float Bottom { get; }
    public RectangleF Bounds { get; private set; }
    public bool IsClosed { get; }
    public ReadOnlyMemory`1<PointF> Points { get; }
    public SizeF Size { get; }
    public float Width { get; }
    public float Height { get; }
    public PathTypes PathType { get; }
    public PointF Center { get; }
    public RectangularPolygon(float x, float y, float width, float height);
    public RectangularPolygon(PointF topLeft, PointF bottomRight);
    public RectangularPolygon(PointF point, SizeF size);
    public RectangularPolygon(RectangleF rectangle);
    [CompilerGeneratedAttribute]
public PointF get_Location();
    public float get_Left();
    public float get_X();
    public float get_Right();
    public float get_Top();
    public float get_Y();
    public float get_Bottom();
    [CompilerGeneratedAttribute]
public sealed virtual RectangleF get_Bounds();
    [CompilerGeneratedAttribute]
private void set_Bounds(RectangleF value);
    public sealed virtual bool get_IsClosed();
    public sealed virtual ReadOnlyMemory`1<PointF> get_Points();
    [CompilerGeneratedAttribute]
public SizeF get_Size();
    public float get_Width();
    public float get_Height();
    public sealed virtual PathTypes get_PathType();
    public PointF get_Center();
    [NullableContextAttribute("1")]
public static RectangularPolygon op_Explicit(Polygon polygon);
    [NullableContextAttribute("1")]
public sealed virtual IPath Transform(Matrix3x2 matrix);
    private sealed virtual override SegmentInfo SixLabors.ImageSharp.Drawing.IPathInternals.PointAlongPath(float distance);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("SixLabors.ImageSharp.Drawing.RectangularPolygon/<Flatten>d__46")]
public sealed virtual IEnumerable`1<ISimplePath> Flatten();
    [NullableContextAttribute("1")]
public sealed virtual IPath AsClosedPath();
}
public class SixLabors.ImageSharp.Drawing.RegularPolygon : Polygon {
    public RegularPolygon(PointF location, int vertices, float radius, float angle);
    public RegularPolygon(PointF location, int vertices, float radius);
    public RegularPolygon(float x, float y, int vertices, float radius, float angle);
    public RegularPolygon(float x, float y, int vertices, float radius);
    [NullableContextAttribute("1")]
private static LinearLineSegment CreateSegment(PointF location, float radius, int vertices, float angle);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Drawing.SegmentInfo : ValueType {
    [CompilerGeneratedAttribute]
private PointF <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Angle>k__BackingField;
    public PointF Point { get; public set; }
    public float Angle { get; public set; }
    [CompilerGeneratedAttribute]
public PointF get_Point();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Point(PointF value);
    [CompilerGeneratedAttribute]
public float get_Angle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Angle(float value);
}
internal static class SixLabors.ImageSharp.Drawing.Shapes.Helpers.TopologyUtilities : object {
    public static void EnsureOrientation(Span`1<PointF> polygon, int expectedOrientation);
    private static int GetPolygonOrientation(ReadOnlySpan`1<PointF> polygon);
}
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.BoundsF : ValueType {
    public float Left;
    public float Top;
    public float Right;
    public float Bottom;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public BoundsF(float l, float t, float r, float b);
    public BoundsF(BoundsF bounds);
    public BoundsF(bool isValid);
    [IsReadOnlyAttribute]
public float get_Width();
    public void set_Width(float value);
    [IsReadOnlyAttribute]
public float get_Height();
    public void set_Height(float value);
    [IsReadOnlyAttribute]
public bool IsEmpty();
    [IsReadOnlyAttribute]
public Vector2 MidPoint();
    [IsReadOnlyAttribute]
public bool Contains(Vector2 pt);
    [IsReadOnlyAttribute]
public bool Contains(BoundsF bounds);
    [IsReadOnlyAttribute]
public bool Intersects(BoundsF bounds);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public PathF AsPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.Clipper : object {
    private PolygonClipper polygonClipper;
    public IPath[] GenerateClippedShapes(ClippingOperation operation, IntersectionRule rule);
    public void AddPaths(IEnumerable`1<IPath> paths, ClippingType clippingType);
    public void AddPath(IPath path, ClippingType clippingType);
    internal void AddPath(ISimplePath path, ClippingType clippingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.ClipperException : Exception {
    public ClipperException(string message);
    public ClipperException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.ClipperOffset : object {
    private PolygonOffsetter polygonClipperOffset;
    public ClipperOffset(float meterLimit, float arcTolerance);
    public ComplexPolygon Execute(float width);
    [NullableContextAttribute("0")]
public void AddPath(ReadOnlySpan`1<PointF> pathPoints, JointStyle jointStyle, EndCapStyle endCapStyle);
    public void AddPath(IPath path, JointStyle jointStyle, EndCapStyle endCapStyle);
    private void AddPath(ISimplePath path, JointStyle jointStyle, EndCapStyle endCapStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.ClipperUtils : object {
    public static float DefaultArcTolerance;
    public static float FloatingPointTolerance;
    public static float DefaultMinimumEdgeLength;
    public static float Sqr(float value);
    public static float Area(PathF path);
    public static PathF StripDuplicates(PathF path, bool isClosedPath);
    public static PathF Ellipse(Vector2 center, float radiusX, float radiusY, int steps);
    public static float DotProduct(Vector2 vec1, Vector2 vec2);
    public static float CrossProduct(Vector2 vec1, Vector2 vec2);
    public static float CrossProduct(Vector2 pt1, Vector2 pt2, Vector2 pt3);
    public static float DotProduct(Vector2 pt1, Vector2 pt2, Vector2 pt3);
    public static bool IsAlmostZero(float value);
    public static float PerpendicDistFromLineSqrd(Vector2 pt, Vector2 line1, Vector2 line2);
    public static bool SegsIntersect(Vector2 seg1a, Vector2 seg1b, Vector2 seg2a, Vector2 seg2b, bool inclusive);
    internal static bool GetIntersectPt(Vector2 ln1a, Vector2 ln1b, Vector2 ln2a, Vector2 ln2b, Vector2& ip);
    public static bool GetIntersectPoint(Vector2 ln1a, Vector2 ln1b, Vector2 ln2a, Vector2 ln2b, Vector2& ip);
    public static Vector2 GetClosestPtOnSegment(Vector2 offPt, Vector2 seg1, Vector2 seg2);
    public static PathF ReversePath(PathF path);
}
public enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.ClippingType : Enum {
    public int value__;
    public static ClippingType Subject;
    public static ClippingType Clip;
}
internal enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule NonZero;
    public static FillRule Positive;
    public static FillRule Negative;
}
internal enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.HorzPosition : Enum {
    public int value__;
    public static HorzPosition Bottom;
    public static HorzPosition Middle;
    public static HorzPosition Top;
}
internal enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.JoinWith : Enum {
    public int value__;
    public static JoinWith None;
    public static JoinWith Left;
    public static JoinWith Right;
}
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PathF : List`1<Vector2> {
    [NullableContextAttribute("1")]
public PathF(IEnumerable`1<Vector2> items);
    public PathF(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PathsF : List`1<PathF> {
    public PathsF(IEnumerable`1<PathF> items);
    public PathsF(int capacity);
}
[FlagsAttribute]
internal enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PointInPolygonResult : Enum {
    public int value__;
    public static PointInPolygonResult IsOn;
    public static PointInPolygonResult IsInside;
    public static PointInPolygonResult IsOutside;
}
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PolygonClipper : object {
    private ClippingOperation clipType;
    private FillRule fillRule;
    private Active actives;
    private Active flaggedHorizontal;
    private List`1<LocalMinima> minimaList;
    private List`1<IntersectNode> intersectList;
    private List`1<Vertex> vertexList;
    private List`1<OutRec> outrecList;
    private List`1<float> scanlineList;
    private List`1<HorzSegment> horzSegList;
    private List`1<HorzJoin> horzJoinList;
    private int currentLocMin;
    private float currentBotY;
    private bool isSortedMinimaList;
    private bool hasOpenPaths;
    [CompilerGeneratedAttribute]
private bool <PreserveCollinear>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReverseSolution>k__BackingField;
    public bool PreserveCollinear { get; public set; }
    public bool ReverseSolution { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PreserveCollinear();
    [CompilerGeneratedAttribute]
public void set_PreserveCollinear(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReverseSolution();
    [CompilerGeneratedAttribute]
public void set_ReverseSolution(bool value);
    public void AddSubject(PathsF paths);
    public void AddPath(PathF path, ClippingType polytype, bool isOpen);
    public void AddPaths(PathsF paths, ClippingType polytype, bool isOpen);
    public void Execute(ClippingOperation clipType, FillRule fillRule, PathsF solutionClosed);
    public void Execute(ClippingOperation clipType, FillRule fillRule, PathsF solutionClosed, PathsF solutionOpen);
    private void ExecuteInternal(ClippingOperation ct, FillRule fillRule);
    private void DoIntersections(float topY);
    private void DisposeIntersectNodes();
    private void AddNewIntersectNode(Active ae1, Active ae2, float topY);
    private static bool SetHorzSegHeadingForward(HorzSegment hs, OutPt opP, OutPt opN);
    private static bool UpdateHorzSegment(HorzSegment hs);
    private static OutPt DuplicateOp(OutPt op, bool insert_after);
    private void ConvertHorzSegsToJoins();
    private void ClearSolutionOnly();
    private bool BuildPaths(PathsF solutionClosed, PathsF solutionOpen);
    private static bool BuildPath(OutPt op, bool reverse, bool isOpen, PathF path);
    private void DoHorizontal(Active horz);
    private void DoTopOfScanbeam(float y);
    private Active DoMaxima(Active ae);
    private static void TrimHorz(Active horzEdge, bool preserveCollinear);
    private void AddToHorzSegList(OutPt op);
    private static OutPt GetLastOp(Active hotEdge);
    private static Vertex GetCurrYMaximaVertex_Open(Active ae);
    private static Vertex GetCurrYMaximaVertex(Active ae);
    private static bool IsVerySmallTriangle(OutPt op);
    private static bool IsValidClosedPath(OutPt op);
    private static OutPt DisposeOutPt(OutPt op);
    private void ProcessHorzJoins();
    private static bool PtsReallyClose(Vector2 pt1, Vector2 pt2);
    private void CleanCollinear(OutRec outrec);
    private void DoSplitOp(OutRec outrec, OutPt splitOp);
    private void FixSelfIntersects(OutRec outrec);
    private void Reset();
    private void InsertScanline(float y);
    private bool PopScanline(Single& y);
    private void InsertLocalMinimaIntoAEL(float botY);
    private static Active ExtractFromSEL(Active ae);
    private static void Insert1Before2InSEL(Active ae1, Active ae2);
    private bool BuildIntersectList(float topY);
    private void ProcessIntersectList();
    private void SwapPositionsInAEL(Active ae1, Active ae2);
    private static bool ResetHorzDirection(Active horz, Vertex vertexMax, Single& leftX, Single& rightX);
    private static bool HorzIsSpike(Active horz);
    private static Active FindEdgeWithMatchingLocMin(Active e);
    private OutPt IntersectEdges(Active ae1, Active ae2, Vector2 pt);
    private void DeleteFromAEL(Active ae);
    private void AdjustCurrXAndCopyToSEL(float topY);
    private bool HasLocMinAtY(float y);
    private LocalMinima PopLocalMinima();
    private void AddPathsToVertexList(PathsF paths, ClippingType polytype, bool isOpen);
    private void AddLocMin(Vertex vert, ClippingType polytype, bool isOpen);
    private void PushHorz(Active ae);
    private bool PopHorz(Active& ae);
    private OutPt AddLocalMinPoly(Active ae1, Active ae2, Vector2 pt, bool isNew);
    private static void SetDx(Active ae);
    private static float GetDx(Vector2 pt1, Vector2 pt2);
    private static float TopX(Active ae, float currentY);
    private static bool IsHorizontal(Active ae);
    private static bool IsHeadingRightHorz(Active ae);
    private static bool IsHeadingLeftHorz(Active ae);
    private static void SwapActives(Active& ae1, Active& ae2);
    private static ClippingType GetPolyType(Active ae);
    private static bool IsSamePolyType(Active ae1, Active ae2);
    private bool IsContributingClosed(Active ae);
    private bool IsContributingOpen(Active ae);
    private void SetWindCountForClosedPathEdge(Active ae);
    private void SetWindCountForOpenPathEdge(Active ae);
    private static bool IsValidAelOrder(Active resident, Active newcomer);
    private void InsertLeftEdge(Active ae);
    private static void InsertRightEdge(Active ae, Active ae2);
    private static Vertex NextVertex(Active ae);
    private static Vertex PrevPrevVertex(Active ae);
    private static bool IsMaxima(Vertex vertex);
    private static bool IsMaxima(Active ae);
    private static Active GetMaximaPair(Active ae);
    private static bool IsOdd(int val);
    private static bool IsHotEdge(Active ae);
    private static bool IsOpen(Active ae);
    private static bool IsOpenEnd(Active ae);
    private static bool IsOpenEnd(Vertex v);
    private static Active GetPrevHotEdge(Active ae);
    private static void JoinOutrecPaths(Active ae1, Active ae2);
    private static OutPt AddOutPt(Active ae, Vector2 pt);
    private OutRec NewOutRec();
    private OutPt StartOpenPath(Active ae, Vector2 pt);
    private void UpdateEdgeIntoAEL(Active ae);
    private static void SetSides(OutRec outrec, Active startEdge, Active endEdge);
    private static void SwapOutrecs(Active ae1, Active ae2);
    private static void SetOwner(OutRec outrec, OutRec newOwner);
    private static float Area(OutPt op);
    private static float AreaTriangle(Vector2 pt1, Vector2 pt2, Vector2 pt3);
    private static OutRec GetRealOutRec(OutRec outRec);
    private static void UncoupleOutRec(Active ae);
    private static bool OutrecIsAscending(Active hotEdge);
    private static void SwapFrontBackSides(OutRec outrec);
    private static bool EdgesAdjacentInAEL(IntersectNode inode);
    private void CheckJoinLeft(Active e, Vector2 pt, bool checkCurrX);
    private void CheckJoinRight(Active e, Vector2 pt, bool checkCurrX);
    private static void FixOutRecPts(OutRec outrec);
    private OutPt AddLocalMaxPoly(Active ae1, Active ae2, Vector2 pt);
    private static bool IsJoined(Active e);
    private void Split(Active e, Vector2 currPt);
    private static bool IsFront(Active ae);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PolygonOffsetter : object {
    private static float Tolerance;
    private List`1<Group> groupList;
    private PathF normals;
    private PathsF solution;
    private float groupDelta;
    private float delta;
    private float absGroupDelta;
    private float mitLimSqr;
    private float stepsPerRad;
    private float stepSin;
    private float stepCos;
    private JointStyle joinType;
    private EndCapStyle endType;
    [CompilerGeneratedAttribute]
private float <ArcTolerance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MiterLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveCollinear>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReverseSolution>k__BackingField;
    public float ArcTolerance { get; }
    public bool MergeGroups { get; }
    public float MiterLimit { get; }
    public bool PreserveCollinear { get; }
    public bool ReverseSolution { get; }
    public PolygonOffsetter(float miterLimit, float arcTolerance, bool preserveCollinear, bool reverseSolution);
    [CompilerGeneratedAttribute]
public float get_ArcTolerance();
    [CompilerGeneratedAttribute]
public bool get_MergeGroups();
    [CompilerGeneratedAttribute]
public float get_MiterLimit();
    [CompilerGeneratedAttribute]
public bool get_PreserveCollinear();
    [CompilerGeneratedAttribute]
public bool get_ReverseSolution();
    public void AddPath(PathF path, JointStyle joinType, EndCapStyle endType);
    public void AddPaths(PathsF paths, JointStyle joinType, EndCapStyle endType);
    public void Execute(float delta, PathsF solution);
    private void ExecuteInternal(float delta);
    private void DoGroupOffset(Group group);
    private static void GetBoundsAndLowestPolyIdx(PathsF paths, Int32& index, BoundsF& bounds);
    private void BuildNormals(PathF path);
    private void OffsetOpenJoined(Group group, PathF path);
    private void OffsetOpenPath(Group group, PathF path);
    private static Vector2 GetUnitNormal(Vector2 pt1, Vector2 pt2);
    private void OffsetPolygon(Group group, PathF path);
    private void OffsetPoint(Group group, PathF path, int j, Int32& k);
    private Vector2 GetPerpendic(Vector2 pt, Vector2 norm);
    private void DoSquare(Group group, PathF path, int j, int k);
    private void DoMiter(Group group, PathF path, int j, int k, float cosA);
    private void DoRound(Group group, PathF path, int j, int k, float angle);
    private static Vector2 TranslatePoint(Vector2 pt, float dx, float dy);
    private static Vector2 ReflectPoint(Vector2 pt, Vector2 pivot);
    private static Vector2 IntersectPoint(Vector2 pt1a, Vector2 pt1b, Vector2 pt2a, Vector2 pt2b);
    private static Vector2 GetAvgUnitVector(Vector2 vec1, Vector2 vec2);
    private static float Hypotenuse(Vector2 vector);
    private static Vector2 NormalizeVector(Vector2 vector);
}
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PolyPathF : object {
    private PolyPathF parent;
    private List`1<PolyPathF> items;
    [CompilerGeneratedAttribute]
private PathF <Polygon>k__BackingField;
    public PathF Polygon { get; private set; }
    public int Level { get; }
    public bool IsHole { get; }
    public int Count { get; }
    public PolyPathF Item { get; }
    public PolyPathF(PolyPathF parent);
    [CompilerGeneratedAttribute]
public PathF get_Polygon();
    [CompilerGeneratedAttribute]
private void set_Polygon(PathF value);
    public int get_Level();
    public bool get_IsHole();
    public int get_Count();
    public PolyPathF get_Item(int index);
    public PolyPathF AddChild(PathF p);
    public float Area();
    public void Clear();
    private bool GetIsHole();
    private int GetLevel();
    public sealed virtual IEnumerator`1<PolyPathF> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.PolyTreeF : PolyPathF {
}
[FlagsAttribute]
internal enum SixLabors.ImageSharp.Drawing.Shapes.PolygonClipper.VertexFlags : Enum {
    public int value__;
    public static VertexFlags None;
    public static VertexFlags OpenStart;
    public static VertexFlags OpenEnd;
    public static VertexFlags LocalMax;
    public static VertexFlags LocalMin;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class SixLabors.ImageSharp.Drawing.Shapes.Rasterization.ActiveEdgeList : ValueType {
    private static int EnteringEdgeFlag;
    private static int LeavingEdgeFlag;
    private static int MaxEdges;
    private static int StripMask;
    private static float NonzeroSortingHelperEpsilon;
    private int count;
    internal Span`1<int> Buffer;
    private Span`1<int> ActiveEdges { get; }
    public ActiveEdgeList(Span`1<int> buffer);
    [IsReadOnlyAttribute]
private Span`1<int> get_ActiveEdges();
    public void EnterEdge(int edgeIdx);
    public void LeaveEdge(int edgeIdx);
    public void RemoveLeavingEdges();
    public Span`1<float> ScanOddEven(float y, Span`1<ScanEdge> edges, Span`1<float> intersections);
    public Span`1<float> ScanNonZero(float y, Span`1<ScanEdge> edges, Span`1<float> intersections, Span`1<NonZeroIntersectionType> intersectionTypes);
    private static Span`1<float> ApplyNonzeroRule(Span`1<float> intersections, Span`1<NonZeroIntersectionType> intersectionTypes);
    private static void NonzeroEmitIfNeeded(Span`1<float> intersections, int i, int diff, float emitVal, Int32& tracker, Int32& offset);
    private static void Emit(float x, int times, Span`1<float> emitSpan, Int32& emitCounter);
    private static void EmitNonZero(float x, int times, bool edgeUp, Span`1<float> emitSpan, Span`1<NonZeroIntersectionType> intersectionTypes, Int32& emitCounter);
    private static int Strip(int flaggedIdx);
    private static bool IsEntering(int flaggedIdx);
    private static bool IsLeaving(int flaggedIdx);
}
internal enum SixLabors.ImageSharp.Drawing.Shapes.Rasterization.NonZeroIntersectionType : Enum {
    public int value__;
    public static NonZeroIntersectionType Down;
    public static NonZeroIntersectionType Up;
    public static NonZeroIntersectionType Corner;
    public static NonZeroIntersectionType CornerDummy;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class SixLabors.ImageSharp.Drawing.Shapes.Rasterization.PolygonScanner : ValueType {
    private int minY;
    private int maxY;
    private IntersectionRule intersectionRule;
    [NullableAttribute("1")]
private ScanEdgeCollection edgeCollection;
    private Span`1<ScanEdge> edges;
    [NullableAttribute("1")]
private IMemoryOwner`1<int> dataBuffer;
    private Span`1<int> sorted0;
    private Span`1<int> sorted1;
    private ActiveEdgeList activeEdges;
    private Span`1<float> intersections;
    private Span`1<NonZeroIntersectionType> intersectionTypes;
    private int idx0;
    private int idx1;
    private float yPlusOne;
    public float SubpixelDistance;
    public float SubpixelArea;
    public int PixelLineY;
    public float SubPixelY;
    [NullableContextAttribute("1")]
private PolygonScanner(ScanEdgeCollection edgeCollection, int maxIntersectionCount, int minY, int maxY, int subsampling, IntersectionRule intersectionRule, MemoryAllocator allocator);
    [NullableContextAttribute("1")]
public static PolygonScanner Create(IPath polygon, int minY, int maxY, int subsampling, IntersectionRule intersectionRule, MemoryAllocator allocator);
    private void Init();
    private void SkipEdgesBeforeMinY();
    public bool MoveToNextPixelLine();
    public bool MoveToNextSubpixelScanLine();
    public ReadOnlySpan`1<float> ScanCurrentLine();
    [IsReadOnlyAttribute]
public void Dispose();
    private void EnterEdges();
    private void LeaveEdges();
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.Shapes.Rasterization.RasterizerExtensions : object {
    [ExtensionAttribute]
public static bool ScanCurrentPixelLineInto(PolygonScanner& scanner, int minX, float xOffset, Span`1<float> scanline);
    [ExtensionAttribute]
private static void ScanCurrentSubpixelLineInto(PolygonScanner& scanner, int minX, float xOffset, Span`1<float> scanline, Boolean& scanlineDirty);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Drawing.Shapes.Rasterization.ScanEdge : ValueType {
    public float Y0;
    public float Y1;
    private float p;
    private float q;
    private int flags;
    public bool EdgeUp { get; }
    public int EmitV0 { get; }
    public int EmitV1 { get; }
    internal ScanEdge(PointF p0, PointF p1, int flags);
    public bool get_EdgeUp();
    public int get_EmitV0();
    public int get_EmitV1();
    public float GetX(float y);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class SixLabors.ImageSharp.Drawing.Shapes.Rasterization.ScanEdgeCollection : object {
    [NullableAttribute("1")]
private IMemoryOwner`1<ScanEdge> buffer;
    private Memory`1<ScanEdge> memory;
    public Span`1<ScanEdge> Edges { get; }
    public int Count { get; }
    [NullableContextAttribute("1")]
private ScanEdgeCollection(IMemoryOwner`1<ScanEdge> buffer, int count);
    [NullableContextAttribute("1")]
internal static ScanEdgeCollection Create(TessellatedMultipolygon multiPolygon, MemoryAllocator allocator, int subsampling);
    private static Vector128`1<float> AdvSimdShuffle(Vector128`1<float> a, Vector128`1<float> b, byte control);
    private static VertexCategory CreateVertexCategory(EdgeCategory previousCategory, EdgeCategory currentCategory);
    [ConditionalAttribute("DEBUG")]
private static void VerifyVertexCategory(VertexCategory vertexCategory);
    public Span`1<ScanEdge> get_Edges();
    public int get_Count();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static ScanEdgeCollection Create(IPath polygon, MemoryAllocator allocator, int subsampling);
    [CompilerGeneratedAttribute]
internal static void <Create>g__RoundY|2_1(ReadOnlySpan`1<PointF> vertices, Span`1<float> destination, float subsamplingRatio);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Drawing.Shapes.TessellatedMultipolygon : object {
    private Ring[] rings;
    [CompilerGeneratedAttribute]
private int <TotalVertexCount>k__BackingField;
    public int TotalVertexCount { get; }
    public int Count { get; }
    public Ring Item { get; }
    private TessellatedMultipolygon(Ring[] rings);
    [CompilerGeneratedAttribute]
public int get_TotalVertexCount();
    public sealed virtual int get_Count();
    public sealed virtual Ring get_Item(int index);
    public static TessellatedMultipolygon Create(IPath path, MemoryAllocator memoryAllocator);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<Ring> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal static Ring <Create>g__MakeRing|9_0(ReadOnlyMemory`1<PointF> points, bool enforcePositiveOrientation, MemoryAllocator allocator);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <Create>g__RepeatFirstVertexAndEnsureOrientation|9_1(Span`1<PointF> span, bool enforcePositiveOrientation);
}
public class SixLabors.ImageSharp.Drawing.Star : Polygon {
    public Star(PointF location, int prongs, float innerRadii, float outerRadii, float angle);
    public Star(PointF location, int prongs, float innerRadii, float outerRadii);
    public Star(float x, float y, int prongs, float innerRadii, float outerRadii, float angle);
    public Star(float x, float y, int prongs, float innerRadii, float outerRadii);
    [NullableContextAttribute("1")]
private static LinearLineSegment CreateSegment(Vector2 location, float innerRadii, float outerRadii, int prongs, float angle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Text.BaseGlyphBuilder : object {
    private List`1<IPath> paths;
    private Vector2 currentPoint;
    private GlyphRendererParameters parameters;
    [CompilerGeneratedAttribute]
private PathBuilder <Builder>k__BackingField;
    public IPathCollection Paths { get; }
    protected PathBuilder Builder { get; }
    public BaseGlyphBuilder(Matrix3x2 transform);
    public IPathCollection get_Paths();
    [CompilerGeneratedAttribute]
protected PathBuilder get_Builder();
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.EndText();
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.BeginText(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds);
    private sealed virtual override bool SixLabors.Fonts.IGlyphRenderer.BeginGlyph(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds, GlyphRendererParameters& modreq(System.Runtime.InteropServices.InAttribute) parameters);
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.BeginFigure();
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.CubicBezierTo(Vector2 secondControlPoint, Vector2 thirdControlPoint, Vector2 point);
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.EndGlyph();
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.EndFigure();
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.LineTo(Vector2 point);
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.MoveTo(Vector2 point);
    private sealed virtual override void SixLabors.Fonts.IGlyphRenderer.QuadraticBezierTo(Vector2 secondControlPoint, Vector2 point);
    protected virtual void BeginText(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds);
    protected virtual void BeginGlyph(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds, GlyphRendererParameters& modreq(System.Runtime.InteropServices.InAttribute) parameters);
    protected virtual void EndGlyph();
    protected virtual void EndText();
    public virtual TextDecorations EnabledDecorations();
    public virtual void SetDecoration(TextDecorations textDecorations, Vector2 start, Vector2 end, float thickness);
    private static Point ClampToPixel(PointF point);
    private static PointF ClampToPixel(PointF point, int thickness, bool rotated);
}
internal class SixLabors.ImageSharp.Drawing.Text.GlyphBuilder : BaseGlyphBuilder {
    public GlyphBuilder(Vector2 origin);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Drawing.Text.PathGlyphBuilder : GlyphBuilder {
    private IPathInternals path;
    public PathGlyphBuilder(IPath path);
    protected virtual void BeginGlyph(FontRectangle& modreq(System.Runtime.InteropServices.InAttribute) bounds, GlyphRendererParameters& modreq(System.Runtime.InteropServices.InAttribute) parameters);
    private void TransformGlyph(FontRectangle& bounds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Drawing.TextBuilder : object {
    public static IPathCollection GenerateGlyphs(string text, TextOptions textOptions);
    public static IPathCollection GenerateGlyphs(string text, IPath path, TextOptions textOptions);
    private static ValueTuple`2<IPath, TextOptions> ConfigureOptions(TextOptions options, IPath path);
}
internal static class SixLabors.ImageSharp.Drawing.Utilities.Intersect : object {
    private static float Eps;
    private static float MinusEps;
    private static float OnePlusEps;
    public static bool LineSegmentToLineSegmentIgnoreCollinear(Vector2 a0, Vector2 a1, Vector2 b0, Vector2 b1, Vector2& intersectionPoint);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.Utilities.NumericUtilities : object {
    [ExtensionAttribute]
public static void AddToAllElements(Span`1<float> span, float value);
    public static float ClampFloat(float value, float min, float max);
}
internal class SixLabors.ImageSharp.Drawing.Utilities.ThreadLocalBlenderBuffers`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadLocal`1<BufferOwner<TPixel>> data;
    public Span`1<float> AmountSpan { get; }
    public Span`1<TPixel> OverlaySpan { get; }
    [NullableContextAttribute("1")]
public ThreadLocalBlenderBuffers`1(MemoryAllocator allocator, int scanlineWidth, bool amountBufferOnly);
    public Span`1<float> get_AmountSpan();
    public Span`1<TPixel> get_OverlaySpan();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Drawing.VectorExtensions : object {
    [ExtensionAttribute]
public static bool Equivalent(PointF source1, PointF source2, float threshold);
    [ExtensionAttribute]
public static bool Equivalent(Vector2 source1, Vector2 source2, float threshold);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowArgumentExceptionForNotNullOrWhitespace(string value, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeLessThan(T value, T max, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeLessThanOrEqualTo(T value, T maximum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeGreaterThan(T value, T minimum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeGreaterThanOrEqualTo(T value, T minimum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeBetweenOrEqualTo(T value, T minimum, T maximum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeSizedAtLeast(int minLength, string parameterName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string name, string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException(string name, string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
