[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class SixLabors.DebugGuard : object {
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool target, string message);
    [ConditionalAttribute("DEBUG")]
public static void NotDisposed(bool isDisposed, string objectName);
    [NullableContextAttribute("0")]
[ConditionalAttribute("DEBUG")]
public static void MustBeSameSized(ReadOnlySpan`1<T> target, ReadOnlySpan`1<T> other, string parameterName);
    [NullableContextAttribute("0")]
[ConditionalAttribute("DEBUG")]
public static void MustBeSizedAtLeast(ReadOnlySpan`1<T> target, ReadOnlySpan`1<T> minSpan, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void NotNull(TValue value, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void NotNullOrWhiteSpace(string value, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeLessThan(TValue value, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeLessThanOrEqualTo(TValue value, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeGreaterThan(TValue value, TValue min, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeGreaterThanOrEqualTo(TValue value, TValue min, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeBetweenOrEqualTo(TValue value, TValue min, TValue max, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool target, string parameterName, string message);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool target, string parameterName, string message);
    [ConditionalAttribute("DEBUG")]
public static void MustBeSizedAtLeast(ReadOnlySpan`1<T> source, int minLength, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void MustBeSizedAtLeast(Span`1<T> source, int minLength, string parameterName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void DestinationShouldNotBeTooShort(ReadOnlySpan`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void DestinationShouldNotBeTooShort(Span`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    private static void ThrowArgumentException(string message, string parameterName);
    private static void ThrowArgumentOutOfRangeException(string parameterName, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class SixLabors.Guard : object {
    public static void MustBeValueType(TValue value, string parameterName);
    [NullableContextAttribute("2")]
public static void NotNull(TValue value, string parameterName);
    public static void NotNullOrWhiteSpace(string value, string parameterName);
    public static void MustBeLessThan(TValue value, TValue max, string parameterName);
    public static void MustBeLessThanOrEqualTo(TValue value, TValue max, string parameterName);
    public static void MustBeGreaterThan(TValue value, TValue min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(TValue value, TValue min, string parameterName);
    public static void MustBeBetweenOrEqualTo(TValue value, TValue min, TValue max, string parameterName);
    public static void IsTrue(bool target, string parameterName, string message);
    public static void IsFalse(bool target, string parameterName, string message);
    public static void MustBeSizedAtLeast(ReadOnlySpan`1<T> source, int minLength, string parameterName);
    public static void MustBeSizedAtLeast(Span`1<T> source, int minLength, string parameterName);
    [NullableContextAttribute("2")]
public static void DestinationShouldNotBeTooShort(ReadOnlySpan`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    [NullableContextAttribute("2")]
public static void DestinationShouldNotBeTooShort(Span`1<TSource> source, Span`1<TDest> destination, string destinationParamName);
    public static void MustBeLessThan(byte value, byte max, string parameterName);
    public static void MustBeLessThanOrEqualTo(byte value, byte max, string parameterName);
    public static void MustBeGreaterThan(byte value, byte min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(byte value, byte min, string parameterName);
    public static void MustBeBetweenOrEqualTo(byte value, byte min, byte max, string parameterName);
    public static void MustBeLessThan(sbyte value, sbyte max, string parameterName);
    public static void MustBeLessThanOrEqualTo(sbyte value, sbyte max, string parameterName);
    public static void MustBeGreaterThan(sbyte value, sbyte min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(sbyte value, sbyte min, string parameterName);
    public static void MustBeBetweenOrEqualTo(sbyte value, sbyte min, sbyte max, string parameterName);
    public static void MustBeLessThan(short value, short max, string parameterName);
    public static void MustBeLessThanOrEqualTo(short value, short max, string parameterName);
    public static void MustBeGreaterThan(short value, short min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(short value, short min, string parameterName);
    public static void MustBeBetweenOrEqualTo(short value, short min, short max, string parameterName);
    public static void MustBeLessThan(ushort value, ushort max, string parameterName);
    public static void MustBeLessThanOrEqualTo(ushort value, ushort max, string parameterName);
    public static void MustBeGreaterThan(ushort value, ushort min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(ushort value, ushort min, string parameterName);
    public static void MustBeBetweenOrEqualTo(ushort value, ushort min, ushort max, string parameterName);
    public static void MustBeLessThan(char value, char max, string parameterName);
    public static void MustBeLessThanOrEqualTo(char value, char max, string parameterName);
    public static void MustBeGreaterThan(char value, char min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(char value, char min, string parameterName);
    public static void MustBeBetweenOrEqualTo(char value, char min, char max, string parameterName);
    public static void MustBeLessThan(int value, int max, string parameterName);
    public static void MustBeLessThanOrEqualTo(int value, int max, string parameterName);
    public static void MustBeGreaterThan(int value, int min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(int value, int min, string parameterName);
    public static void MustBeBetweenOrEqualTo(int value, int min, int max, string parameterName);
    public static void MustBeLessThan(UInt32 value, UInt32 max, string parameterName);
    public static void MustBeLessThanOrEqualTo(UInt32 value, UInt32 max, string parameterName);
    public static void MustBeGreaterThan(UInt32 value, UInt32 min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(UInt32 value, UInt32 min, string parameterName);
    public static void MustBeBetweenOrEqualTo(UInt32 value, UInt32 min, UInt32 max, string parameterName);
    public static void MustBeLessThan(float value, float max, string parameterName);
    public static void MustBeLessThanOrEqualTo(float value, float max, string parameterName);
    public static void MustBeGreaterThan(float value, float min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(float value, float min, string parameterName);
    public static void MustBeBetweenOrEqualTo(float value, float min, float max, string parameterName);
    public static void MustBeLessThan(long value, long max, string parameterName);
    public static void MustBeLessThanOrEqualTo(long value, long max, string parameterName);
    public static void MustBeGreaterThan(long value, long min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(long value, long min, string parameterName);
    public static void MustBeBetweenOrEqualTo(long value, long min, long max, string parameterName);
    public static void MustBeLessThan(ulong value, ulong max, string parameterName);
    public static void MustBeLessThanOrEqualTo(ulong value, ulong max, string parameterName);
    public static void MustBeGreaterThan(ulong value, ulong min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(ulong value, ulong min, string parameterName);
    public static void MustBeBetweenOrEqualTo(ulong value, ulong min, ulong max, string parameterName);
    public static void MustBeLessThan(double value, double max, string parameterName);
    public static void MustBeLessThanOrEqualTo(double value, double max, string parameterName);
    public static void MustBeGreaterThan(double value, double min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(double value, double min, string parameterName);
    public static void MustBeBetweenOrEqualTo(double value, double min, double max, string parameterName);
    public static void MustBeLessThan(decimal value, decimal max, string parameterName);
    public static void MustBeLessThanOrEqualTo(decimal value, decimal max, string parameterName);
    public static void MustBeGreaterThan(decimal value, decimal min, string parameterName);
    public static void MustBeGreaterThanOrEqualTo(decimal value, decimal min, string parameterName);
    public static void MustBeBetweenOrEqualTo(decimal value, decimal min, decimal max, string parameterName);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Advanced.AdvancedImageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageEncoder DetectEncoder(Image source, string filePath);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AcceptVisitor(Image source, IImageVisitor visitor);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task AcceptVisitorAsync(Image source, IImageVisitorAsync visitor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMemoryGroup`1<TPixel> GetPixelMemoryGroup(ImageFrame`1<TPixel> source);
    [ExtensionAttribute]
public static IMemoryGroup`1<TPixel> GetPixelMemoryGroup(Image`1<TPixel> source);
    [ExtensionAttribute]
public static Memory`1<TPixel> DangerousGetPixelRowMemory(ImageFrame`1<TPixel> source, int rowIndex);
    [ExtensionAttribute]
public static Memory`1<TPixel> DangerousGetPixelRowMemory(Image`1<TPixel> source, int rowIndex);
}
[ExcludeFromCodeCoverageAttribute]
internal static class SixLabors.ImageSharp.Advanced.AotCompilerTools : object {
    [PreserveAttribute]
private static void SeedPixelFormats();
    [PreserveAttribute]
private static void Seed();
    [PreserveAttribute]
private static void AotCompileImage();
    [PreserveAttribute]
private static void AotCompileImageProcessingContextFactory();
    [PreserveAttribute]
private static void AotCompileImageEncoderInternals();
    [PreserveAttribute]
private static void AotCompileImageDecoderInternals();
    [PreserveAttribute]
private static void AotCompileImageEncoders();
    [PreserveAttribute]
private static void AotCompileImageDecoders();
    [PreserveAttribute]
private static void AotCompileImageEncoder();
    [PreserveAttribute]
private static void AotCompileImageDecoder();
    [PreserveAttribute]
private static void AotCompileImageProcessors();
    [PreserveAttribute]
private static void AotCompileImageProcessor();
    [PreserveAttribute]
private static void AotCompilerCloningImageProcessor();
    [PreserveAttribute]
private static void AotCompileGenericImageProcessors();
    [PreserveAttribute]
private static void AotCompileGenericCloningImageProcessor();
    [PreserveAttribute]
private static void AotCompileResamplers();
    [PreserveAttribute]
private static void AotCompileResampler();
    [PreserveAttribute]
private static void AotCompileQuantizers();
    [PreserveAttribute]
private static void AotCompileQuantizer();
    [PreserveAttribute]
private static void AotCompilePixelSamplingStrategys();
    [PreserveAttribute]
private static void AotCompileDithers();
    [PreserveAttribute]
private static void AotCompileDither();
    [PreserveAttribute]
private static void AotCompileMemoryManagers();
    [PreserveAttribute]
private static void AotCompileMemoryManager();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Advanced.IConfigurationProvider {
    public Configuration Configuration { get; }
    public abstract virtual Configuration get_Configuration();
}
public interface SixLabors.ImageSharp.Advanced.IImageVisitor {
    public abstract virtual void Visit(Image`1<TPixel> image);
}
public interface SixLabors.ImageSharp.Advanced.IImageVisitorAsync {
    public abstract virtual Task VisitAsync(Image`1<TPixel> image, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Advanced.IPixelSource {
    public Buffer2D`1<byte> PixelBuffer { get; }
    public abstract virtual Buffer2D`1<byte> get_PixelBuffer();
}
internal interface SixLabors.ImageSharp.Advanced.IPixelSource`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Buffer2D`1<TPixel> PixelBuffer { get; }
    public abstract virtual Buffer2D`1<TPixel> get_PixelBuffer();
}
public interface SixLabors.ImageSharp.Advanced.IRowIntervalOperation {
    public abstract virtual void Invoke(RowInterval& modreq(System.Runtime.InteropServices.InAttribute) rows);
}
public interface SixLabors.ImageSharp.Advanced.IRowIntervalOperation`1 {
    public abstract virtual int GetRequiredBufferLength(Rectangle bounds);
    public abstract virtual void Invoke(RowInterval& modreq(System.Runtime.InteropServices.InAttribute) rows, Span`1<TBuffer> span);
}
public interface SixLabors.ImageSharp.Advanced.IRowOperation {
    public abstract virtual void Invoke(int y);
}
public interface SixLabors.ImageSharp.Advanced.IRowOperation`1 {
    public abstract virtual int GetRequiredBufferLength(Rectangle bounds);
    public abstract virtual void Invoke(int y, Span`1<TBuffer> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Advanced.ParallelExecutionSettings : ValueType {
    public static int DefaultMinimumPixelsProcessedPerTask;
    [CompilerGeneratedAttribute]
private MemoryAllocator <MemoryAllocator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumPixelsProcessedPerTask>k__BackingField;
    public MemoryAllocator MemoryAllocator { get; }
    public int MaxDegreeOfParallelism { get; }
    public int MinimumPixelsProcessedPerTask { get; }
    public ParallelExecutionSettings(int maxDegreeOfParallelism, int minimumPixelsProcessedPerTask, MemoryAllocator memoryAllocator);
    public ParallelExecutionSettings(int maxDegreeOfParallelism, MemoryAllocator memoryAllocator);
    [CompilerGeneratedAttribute]
public MemoryAllocator get_MemoryAllocator();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public int get_MinimumPixelsProcessedPerTask();
    public ParallelExecutionSettings MultiplyMinimumPixelsPerTask(int multiplier);
    public static ParallelExecutionSettings FromConfiguration(Configuration configuration);
}
public static class SixLabors.ImageSharp.Advanced.ParallelRowIterator : object {
    public static void IterateRows(Configuration configuration, Rectangle rectangle, T& operation);
    public static void IterateRows(Rectangle rectangle, ParallelExecutionSettings& parallelSettings, T& operation);
    public static void IterateRows(Configuration configuration, Rectangle rectangle, T& operation);
    public static void IterateRows(Rectangle rectangle, ParallelExecutionSettings& parallelSettings, T& operation);
    public static void IterateRowIntervals(Configuration configuration, Rectangle rectangle, T& operation);
    public static void IterateRowIntervals(Rectangle rectangle, ParallelExecutionSettings& parallelSettings, T& operation);
    public static void IterateRowIntervals(Configuration configuration, Rectangle rectangle, T& operation);
    public static void IterateRowIntervals(Rectangle rectangle, ParallelExecutionSettings& parallelSettings, T& operation);
    private static int DivideCeil(long dividend, int divisor);
    private static void ValidateRectangle(Rectangle rectangle);
}
[AttributeUsageAttribute("64")]
internal class SixLabors.ImageSharp.Advanced.PreserveAttribute : Attribute {
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Byte3 : ValueType {
}
public enum SixLabors.ImageSharp.ByteOrder : Enum {
    public int value__;
    public static ByteOrder BigEndian;
    public static ByteOrder LittleEndian;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Color : ValueType {
    private Rgba64 data;
    [NullableAttribute("2")]
private IPixel boxedHighPrecisionPixel;
    private static Lazy`1<Dictionary`2<string, Color>> NamedColorsLookupLazy;
    public static Color AliceBlue;
    public static Color AntiqueWhite;
    public static Color Aqua;
    public static Color Aquamarine;
    public static Color Azure;
    public static Color Beige;
    public static Color Bisque;
    public static Color Black;
    public static Color BlanchedAlmond;
    public static Color Blue;
    public static Color BlueViolet;
    public static Color Brown;
    public static Color BurlyWood;
    public static Color CadetBlue;
    public static Color Chartreuse;
    public static Color Chocolate;
    public static Color Coral;
    public static Color CornflowerBlue;
    public static Color Cornsilk;
    public static Color Crimson;
    public static Color Cyan;
    public static Color DarkBlue;
    public static Color DarkCyan;
    public static Color DarkGoldenrod;
    public static Color DarkGray;
    public static Color DarkGreen;
    public static Color DarkGrey;
    public static Color DarkKhaki;
    public static Color DarkMagenta;
    public static Color DarkOliveGreen;
    public static Color DarkOrange;
    public static Color DarkOrchid;
    public static Color DarkRed;
    public static Color DarkSalmon;
    public static Color DarkSeaGreen;
    public static Color DarkSlateBlue;
    public static Color DarkSlateGray;
    public static Color DarkSlateGrey;
    public static Color DarkTurquoise;
    public static Color DarkViolet;
    public static Color DeepPink;
    public static Color DeepSkyBlue;
    public static Color DimGray;
    public static Color DimGrey;
    public static Color DodgerBlue;
    public static Color Firebrick;
    public static Color FloralWhite;
    public static Color ForestGreen;
    public static Color Fuchsia;
    public static Color Gainsboro;
    public static Color GhostWhite;
    public static Color Gold;
    public static Color Goldenrod;
    public static Color Gray;
    public static Color Green;
    public static Color GreenYellow;
    public static Color Grey;
    public static Color Honeydew;
    public static Color HotPink;
    public static Color IndianRed;
    public static Color Indigo;
    public static Color Ivory;
    public static Color Khaki;
    public static Color Lavender;
    public static Color LavenderBlush;
    public static Color LawnGreen;
    public static Color LemonChiffon;
    public static Color LightBlue;
    public static Color LightCoral;
    public static Color LightCyan;
    public static Color LightGoldenrodYellow;
    public static Color LightGray;
    public static Color LightGreen;
    public static Color LightGrey;
    public static Color LightPink;
    public static Color LightSalmon;
    public static Color LightSeaGreen;
    public static Color LightSkyBlue;
    public static Color LightSlateGray;
    public static Color LightSlateGrey;
    public static Color LightSteelBlue;
    public static Color LightYellow;
    public static Color Lime;
    public static Color LimeGreen;
    public static Color Linen;
    public static Color Magenta;
    public static Color Maroon;
    public static Color MediumAquamarine;
    public static Color MediumBlue;
    public static Color MediumOrchid;
    public static Color MediumPurple;
    public static Color MediumSeaGreen;
    public static Color MediumSlateBlue;
    public static Color MediumSpringGreen;
    public static Color MediumTurquoise;
    public static Color MediumVioletRed;
    public static Color MidnightBlue;
    public static Color MintCream;
    public static Color MistyRose;
    public static Color Moccasin;
    public static Color NavajoWhite;
    public static Color Navy;
    public static Color OldLace;
    public static Color Olive;
    public static Color OliveDrab;
    public static Color Orange;
    public static Color OrangeRed;
    public static Color Orchid;
    public static Color PaleGoldenrod;
    public static Color PaleGreen;
    public static Color PaleTurquoise;
    public static Color PaleVioletRed;
    public static Color PapayaWhip;
    public static Color PeachPuff;
    public static Color Peru;
    public static Color Pink;
    public static Color Plum;
    public static Color PowderBlue;
    public static Color Purple;
    public static Color RebeccaPurple;
    public static Color Red;
    public static Color RosyBrown;
    public static Color RoyalBlue;
    public static Color SaddleBrown;
    public static Color Salmon;
    public static Color SandyBrown;
    public static Color SeaGreen;
    public static Color SeaShell;
    public static Color Sienna;
    public static Color Silver;
    public static Color SkyBlue;
    public static Color SlateBlue;
    public static Color SlateGray;
    public static Color SlateGrey;
    public static Color Snow;
    public static Color SpringGreen;
    public static Color SteelBlue;
    public static Color Tan;
    public static Color Teal;
    public static Color Thistle;
    public static Color Tomato;
    public static Color Transparent;
    public static Color Turquoise;
    public static Color Violet;
    public static Color Wheat;
    public static Color White;
    public static Color WhiteSmoke;
    public static Color Yellow;
    public static Color YellowGreen;
    private static Lazy`1<Color[]> WebSafePaletteLazy;
    private static Lazy`1<Color[]> WernerPaletteLazy;
    [NullableAttribute("0")]
public static ReadOnlyMemory`1<Color> WebSafePalette { get; }
    [NullableAttribute("0")]
public static ReadOnlyMemory`1<Color> WernerPalette { get; }
    public Color(Rgba64 pixel);
    public Color(Rgb48 pixel);
    public Color(La32 pixel);
    public Color(L16 pixel);
    public Color(Rgba32 pixel);
    public Color(Argb32 pixel);
    public Color(Bgra32 pixel);
    public Color(Abgr32 pixel);
    public Color(Rgb24 pixel);
    public Color(Bgr24 pixel);
    public Color(Vector4 vector);
    private Color(byte r, byte g, byte b, byte a);
    private Color(byte r, byte g, byte b);
    private Color(IPixel pixel);
    private static Color();
    public static Vector4 op_Explicit(Color color);
    public static Color op_Explicit(Vector4 source);
    internal Rgba32 ToRgba32();
    internal Bgra32 ToBgra32();
    internal Argb32 ToArgb32();
    internal Abgr32 ToAbgr32();
    internal Rgb24 ToRgb24();
    internal Bgr24 ToBgr24();
    internal Vector4 ToScaledVector4();
    public static bool op_Equality(Color left, Color right);
    public static bool op_Inequality(Color left, Color right);
    public static Color FromRgba(byte r, byte g, byte b, byte a);
    public static Color FromRgb(byte r, byte g, byte b);
    [NullableContextAttribute("0")]
public static Color FromPixel(TPixel pixel);
    public static Color ParseHex(string hex);
    public static bool TryParseHex(string hex, Color& result);
    public static Color Parse(string input);
    public static bool TryParse(string input, Color& result);
    public Color WithAlpha(float alpha);
    public string ToHex();
    public virtual string ToString();
    [NullableContextAttribute("0")]
public TPixel ToPixel();
    [NullableContextAttribute("0")]
public static void ToPixel(ReadOnlySpan`1<Color> source, Span`1<TPixel> destination);
    public sealed virtual bool Equals(Color other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static Dictionary`2<string, Color> CreateNamedColorsLookup();
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<Color> get_WebSafePalette();
    private static Color[] CreateWebSafePalette();
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<Color> get_WernerPalette();
    private static Color[] CreateWernerPalette();
}
public class SixLabors.ImageSharp.ColorMatrix : ValueType {
    public float M11;
    public float M12;
    public float M13;
    public float M14;
    public float M21;
    public float M22;
    public float M23;
    public float M24;
    public float M31;
    public float M32;
    public float M33;
    public float M34;
    public float M41;
    public float M42;
    public float M43;
    public float M44;
    public float M51;
    public float M52;
    public float M53;
    public float M54;
    public static ColorMatrix Identity { get; }
    public bool IsIdentity { get; }
    public ColorMatrix(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44, float m51, float m52, float m53, float m54);
    public static ColorMatrix get_Identity();
    public bool get_IsIdentity();
    public static ColorMatrix op_Addition(ColorMatrix value1, ColorMatrix value2);
    public static ColorMatrix op_Subtraction(ColorMatrix value1, ColorMatrix value2);
    public static ColorMatrix op_UnaryNegation(ColorMatrix value);
    public static ColorMatrix op_Multiply(ColorMatrix value1, ColorMatrix value2);
    public static ColorMatrix op_Multiply(ColorMatrix value1, float value2);
    public static bool op_Equality(ColorMatrix value1, ColorMatrix value2);
    public static bool op_Inequality(ColorMatrix value1, ColorMatrix value2);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(ColorMatrix other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [UnscopedRefAttribute]
internal Impl& AsImpl();
    [IsReadOnlyAttribute]
[UnscopedRefAttribute]
internal Impl& modreq(System.Runtime.InteropServices.InAttribute) AsROImpl();
}
internal static class SixLabors.ImageSharp.ColorNumerics : object {
    private static Vector4 Bt709;
    private static ColorNumerics();
    public static int GetBT709Luminance(Vector4& vector, int luminanceLevels);
    public static byte Get8BitBT709Luminance(byte r, byte g, byte b);
    public static ushort Get16BitBT709Luminance(ushort r, ushort g, ushort b);
    public static ushort Get16BitBT709Luminance(float r, float g, float b);
    public static byte DownScaleFrom16BitTo8Bit(ushort component);
    public static ushort UpscaleFrom8BitTo16Bit(byte component);
    public static int GetBitsNeededForColorDepth(int colors);
    public static int GetColorCountForBitDepth(int bitDepth);
    internal static Vector4 Transform(Vector4 vector, Impl& matrix);
    public static void Transform(Vector4& vector, ColorMatrix& matrix);
    public static void Transform(Span`1<Vector4> vectors, ColorMatrix& matrix);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieLab : ValueType {
    public static CieXyz DefaultWhitePoint;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <A>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    public float L { get; }
    public float A { get; }
    public float B { get; }
    public CieXyz WhitePoint { get; }
    public CieLab(float l, float a, float b);
    public CieLab(float l, float a, float b, CieXyz whitePoint);
    public CieLab(Vector3 vector);
    public CieLab(Vector3 vector, CieXyz whitePoint);
    private static CieLab();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_A();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    public static bool op_Equality(CieLab left, CieLab right);
    public static bool op_Inequality(CieLab left, CieLab right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieLab other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieLch : ValueType {
    public static CieXyz DefaultWhitePoint;
    private static Vector3 Min;
    private static Vector3 Max;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <H>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    public float L { get; }
    public float C { get; }
    public float H { get; }
    public CieXyz WhitePoint { get; }
    public CieLch(float l, float c, float h);
    public CieLch(float l, float c, float h, CieXyz whitePoint);
    public CieLch(Vector3 vector);
    public CieLch(Vector3 vector, CieXyz whitePoint);
    private static CieLch();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_H();
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    public static bool op_Equality(CieLch left, CieLch right);
    public static bool op_Inequality(CieLch left, CieLch right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieLch other);
    public float Saturation();
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieLchuv : ValueType {
    private static Vector3 Min;
    private static Vector3 Max;
    public static CieXyz DefaultWhitePoint;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <H>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    public float L { get; }
    public float C { get; }
    public float H { get; }
    public CieXyz WhitePoint { get; }
    public CieLchuv(float l, float c, float h);
    public CieLchuv(float l, float c, float h, CieXyz whitePoint);
    public CieLchuv(Vector3 vector);
    public CieLchuv(Vector3 vector, CieXyz whitePoint);
    private static CieLchuv();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_H();
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    public static bool op_Equality(CieLchuv left, CieLchuv right);
    public static bool op_Inequality(CieLchuv left, CieLchuv right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieLchuv other);
    public float Saturation();
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieLuv : ValueType {
    public static CieXyz DefaultWhitePoint;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <U>k__BackingField;
    [CompilerGeneratedAttribute]
private float <V>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    public float L { get; }
    public float U { get; }
    public float V { get; }
    public CieXyz WhitePoint { get; }
    public CieLuv(float l, float u, float v);
    public CieLuv(float l, float u, float v, CieXyz whitePoint);
    public CieLuv(Vector3 vector);
    public CieLuv(Vector3 vector, CieXyz whitePoint);
    private static CieLuv();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_U();
    [CompilerGeneratedAttribute]
public float get_V();
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    public static bool op_Equality(CieLuv left, CieLuv right);
    public static bool op_Inequality(CieLuv left, CieLuv right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieLuv other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieXyy : ValueType {
    [CompilerGeneratedAttribute]
private float <X>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Yl>k__BackingField;
    public float X { get; }
    public float Y { get; }
    public float Yl { get; }
    public CieXyy(float x, float y, float yl);
    public CieXyy(Vector3 vector);
    [CompilerGeneratedAttribute]
public float get_X();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_Yl();
    public static bool op_Equality(CieXyy left, CieXyy right);
    public static bool op_Inequality(CieXyy left, CieXyy right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieXyy other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.CieXyz : ValueType {
    [CompilerGeneratedAttribute]
private float <X>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Z>k__BackingField;
    public float X { get; }
    public float Y { get; }
    public float Z { get; }
    public CieXyz(float x, float y, float z);
    public CieXyz(Vector3 vector);
    [CompilerGeneratedAttribute]
public float get_X();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_Z();
    public static bool op_Equality(CieXyz left, CieXyz right);
    public static bool op_Inequality(CieXyz left, CieXyz right);
    public Vector3 ToVector3();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieXyz other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Cmyk : ValueType {
    private static Vector4 Min;
    private static Vector4 Max;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <M>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <K>k__BackingField;
    public float C { get; }
    public float M { get; }
    public float Y { get; }
    public float K { get; }
    public Cmyk(float c, float m, float y, float k);
    public Cmyk(Vector4 vector);
    private static Cmyk();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_M();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_K();
    public static bool op_Equality(Cmyk left, Cmyk right);
    public static bool op_Inequality(Cmyk left, Cmyk right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Cmyk other);
}
public static class SixLabors.ImageSharp.ColorSpaces.Companding.GammaCompanding : object {
    public static float Expand(float channel, float gamma);
    public static float Compress(float channel, float gamma);
}
public static class SixLabors.ImageSharp.ColorSpaces.Companding.LCompanding : object {
    public static float Expand(float channel);
    public static float Compress(float channel);
}
public static class SixLabors.ImageSharp.ColorSpaces.Companding.Rec2020Companding : object {
    private static float Alpha;
    private static float AlphaMinusOne;
    private static float Beta;
    private static float InverseBeta;
    private static float Epsilon;
    public static float Expand(float channel);
    public static float Compress(float channel);
}
public static class SixLabors.ImageSharp.ColorSpaces.Companding.Rec709Companding : object {
    private static float Epsilon;
    public static float Expand(float channel);
    public static float Compress(float channel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.ColorSpaces.Companding.SRgbCompanding : object {
    private static int Length;
    private static int Scale;
    private static Lazy`1<Single[]> LazyCompressTable;
    private static Lazy`1<Single[]> LazyExpandTable;
    private static Single[] ExpandTable { get; }
    private static Single[] CompressTable { get; }
    private static SRgbCompanding();
    private static Single[] get_ExpandTable();
    private static Single[] get_CompressTable();
    [NullableContextAttribute("0")]
public static void Expand(Span`1<Vector4> vectors);
    [NullableContextAttribute("0")]
public static void Compress(Span`1<Vector4> vectors);
    public static void Expand(Vector4& vector);
    public static void Compress(Vector4& vector);
    public static float Expand(float channel);
    public static float Compress(float channel);
    [NullableContextAttribute("0")]
private static void CompandAvx2(Span`1<Vector4> vectors, Single[] table);
    [NullableContextAttribute("0")]
private static void CompandScalar(Span`1<Vector4> vectors, Single[] table);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieConstants : object {
    public static float Epsilon;
    public static float Kappa;
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLabToCieLchConverter : object {
    public static CieLch Convert(CieLab& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLabToCieXyzConverter : object {
    public static CieXyz Convert(CieLab& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLchToCieLabConverter : object {
    public static CieLab Convert(CieLch& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLchuvToCieLuvConverter : object {
    public static CieLuv Convert(CieLchuv& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLuvToCieLchuvConverter : object {
    public static CieLchuv Convert(CieLuv& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieLuvToCieXyzConverter : object {
    public static CieXyz Convert(CieLuv& input);
    private static float ComputeU0(CieXyz& input);
    private static float ComputeV0(CieXyz& input);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyChromaticityCoordinates : ValueType {
    [CompilerGeneratedAttribute]
private float <X>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    public float X { get; }
    public float Y { get; }
    public CieXyChromaticityCoordinates(float x, float y);
    [CompilerGeneratedAttribute]
public float get_X();
    [CompilerGeneratedAttribute]
public float get_Y();
    public static bool op_Equality(CieXyChromaticityCoordinates left, CieXyChromaticityCoordinates right);
    public static bool op_Inequality(CieXyChromaticityCoordinates left, CieXyChromaticityCoordinates right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CieXyChromaticityCoordinates other);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzAndCieXyyConverter : object {
    public static CieXyy Convert(CieXyz& input);
    public static CieXyz Convert(CieXyy& input);
}
internal abstract class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzAndHunterLabConverterBase : object {
    public static float ComputeKa(CieXyz whitePoint);
    public static float ComputeKb(CieXyz whitePoint);
}
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzAndLmsConverter : object {
    public static Matrix4x4 DefaultTransformationMatrix;
    private Matrix4x4 inverseTransformationMatrix;
    private Matrix4x4 transformationMatrix;
    public CieXyzAndLmsConverter(Matrix4x4 transformationMatrix);
    private static CieXyzAndLmsConverter();
    public Lms Convert(CieXyz& input);
    public CieXyz Convert(Lms& input);
}
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzToCieLabConverter : object {
    [CompilerGeneratedAttribute]
private CieXyz <LabWhitePoint>k__BackingField;
    public CieXyz LabWhitePoint { get; }
    public CieXyzToCieLabConverter(CieXyz labWhitePoint);
    [CompilerGeneratedAttribute]
public CieXyz get_LabWhitePoint();
    public CieLab Convert(CieXyz& input);
}
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzToCieLuvConverter : object {
    [CompilerGeneratedAttribute]
private CieXyz <LuvWhitePoint>k__BackingField;
    public CieXyz LuvWhitePoint { get; }
    public CieXyzToCieLuvConverter(CieXyz luvWhitePoint);
    [CompilerGeneratedAttribute]
public CieXyz get_LuvWhitePoint();
    public CieLuv Convert(CieXyz& input);
    private static float ComputeUp(CieXyz& input);
    private static float ComputeVp(CieXyz& input);
}
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzToHunterLabConverter : CieXyzAndHunterLabConverterBase {
    [CompilerGeneratedAttribute]
private CieXyz <HunterLabWhitePoint>k__BackingField;
    public CieXyz HunterLabWhitePoint { get; }
    public CieXyzToHunterLabConverter(CieXyz labWhitePoint);
    [CompilerGeneratedAttribute]
public CieXyz get_HunterLabWhitePoint();
    public HunterLab Convert(CieXyz& input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.CieXyzToLinearRgbConverter : LinearRgbAndCieXyzConverterBase {
    private Matrix4x4 conversionMatrix;
    [CompilerGeneratedAttribute]
private RgbWorkingSpace <TargetWorkingSpace>k__BackingField;
    public RgbWorkingSpace TargetWorkingSpace { get; }
    public CieXyzToLinearRgbConverter(RgbWorkingSpace workingSpace);
    [CompilerGeneratedAttribute]
public RgbWorkingSpace get_TargetWorkingSpace();
    public LinearRgb Convert(CieXyz& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.CmykAndRgbConverter : object {
    public static Rgb Convert(Cmyk& input);
    public static Cmyk Convert(Rgb& input);
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.ColorSpaceConverter : object {
    [NullableAttribute("1")]
private static ConcurrentDictionary`2<RgbWorkingSpace, LinearRgbToCieXyzConverter> ConverterCache;
    [NullableAttribute("1")]
private static ColorSpaceConverterOptions DefaultOptions;
    private Matrix4x4 lmsAdaptationMatrix;
    private CieXyz whitePoint;
    private CieXyz targetLuvWhitePoint;
    private CieXyz targetLabWhitePoint;
    private CieXyz targetHunterLabWhitePoint;
    [NullableAttribute("1")]
private RgbWorkingSpace targetRgbWorkingSpace;
    [NullableAttribute("2")]
private IChromaticAdaptation chromaticAdaptation;
    private bool performChromaticAdaptation;
    [NullableAttribute("1")]
private CieXyzAndLmsConverter cieXyzAndLmsConverter;
    [NullableAttribute("1")]
private CieXyzToCieLabConverter cieXyzToCieLabConverter;
    [NullableAttribute("1")]
private CieXyzToCieLuvConverter cieXyzToCieLuvConverter;
    [NullableAttribute("1")]
private CieXyzToHunterLabConverter cieXyzToHunterLabConverter;
    [NullableAttribute("1")]
private CieXyzToLinearRgbConverter cieXyzToLinearRgbConverter;
    [NullableContextAttribute("1")]
public ColorSpaceConverter(ColorSpaceConverterOptions options);
    private static ColorSpaceConverter();
    public CieXyz Adapt(CieXyz& color, CieXyz& sourceWhitePoint);
    public CieXyz Adapt(CieXyz& color, CieXyz& sourceWhitePoint, CieXyz& targetWhitePoint);
    public CieLab Adapt(CieLab& color);
    public CieLch Adapt(CieLch& color);
    public CieLchuv Adapt(CieLchuv& color);
    public CieLuv Adapt(CieLuv& color);
    public HunterLab Adapt(HunterLab& color);
    public LinearRgb Adapt(LinearRgb& color);
    public Rgb Adapt(Rgb& color);
    public CieLab ToCieLab(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(Hsl& color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieLab> destination);
    public CieLab ToCieLab(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieLab> destination);
    public CieLch ToCieLch(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(Hsl& color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieLch> destination);
    public CieLch ToCieLch(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieLch> destination);
    public CieLchuv ToCieLchuv(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(Hsl& color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieLchuv> destination);
    public CieLchuv ToCieLchuv(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieLchuv> destination);
    public CieLuv ToCieLuv(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(Hsl& color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieLuv> destination);
    public CieLuv ToCieLuv(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieLuv> destination);
    public CieXyy ToCieXyy(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<CieXyy> destination);
    public static CieXyy ToCieXyy(CieXyz& color);
    public static void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(Hsl color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieXyy> destination);
    public CieXyy ToCieXyy(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieXyy> destination);
    public CieXyz ToCieXyz(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<CieXyz> destination);
    public static CieXyz ToCieXyz(CieXyy& color);
    public static void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(Cmyk& color);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(Hsl& color);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(Hsv& color);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(LinearRgb& color);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(Rgb& color);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<CieXyz> destination);
    public CieXyz ToCieXyz(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<CieXyz> destination);
    [NullableContextAttribute("1")]
private static LinearRgbToCieXyzConverter GetLinearRgbToCieXyzConverter(RgbWorkingSpace workingSpace);
    public Cmyk ToCmyk(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<Cmyk> destination);
    public static Cmyk ToCmyk(Hsl& color);
    public static void Convert(ReadOnlySpan`1<Hsl> source, Span`1<Cmyk> destination);
    public static Cmyk ToCmyk(Hsv& color);
    public static void Convert(ReadOnlySpan`1<Hsv> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<Cmyk> destination);
    public static Cmyk ToCmyk(LinearRgb& color);
    public static void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(Lms& color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<Cmyk> destination);
    public static Cmyk ToCmyk(Rgb& color);
    public static void Convert(ReadOnlySpan`1<Rgb> source, Span`1<Cmyk> destination);
    public Cmyk ToCmyk(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<Cmyk> destination);
    public Hsl ToHsl(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<Hsl> destination);
    public Hsl ToHsl(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<Hsl> destination);
    public Hsl ToHsl(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<Hsl> destination);
    public Hsl ToHsl(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<Hsl> destination);
    public Hsl ToHsl(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<Hsl> destination);
    public Hsl ToHsl(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<Hsl> destination);
    public static Hsl ToHsl(Cmyk& color);
    public static void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<Hsl> destination);
    public static Hsl ToHsl(Hsv& color);
    public static void Convert(ReadOnlySpan`1<Hsv> source, Span`1<Hsl> destination);
    public Hsl ToHsl(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<Hsl> destination);
    public static Hsl ToHsl(LinearRgb& color);
    public static void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<Hsl> destination);
    public Hsl ToHsl(Lms color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<Hsl> destination);
    public static Hsl ToHsl(Rgb& color);
    public static void Convert(ReadOnlySpan`1<Rgb> source, Span`1<Hsl> destination);
    public Hsl ToHsl(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<Hsl> destination);
    public Hsv ToHsv(CieLab& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<Hsv> destination);
    public Hsv ToHsv(CieLch& color);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<Hsv> destination);
    public Hsv ToHsv(CieLchuv& color);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<Hsv> destination);
    public Hsv ToHsv(CieLuv& color);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<Hsv> destination);
    public Hsv ToHsv(CieXyy& color);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<Hsv> destination);
    public Hsv ToHsv(CieXyz& color);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<Hsv> destination);
    public static Hsv ToHsv(Cmyk& color);
    public static void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<Hsv> destination);
    public static Hsv ToHsv(Hsl& color);
    public static void Convert(ReadOnlySpan`1<Hsl> source, Span`1<Hsv> destination);
    public Hsv ToHsv(HunterLab& color);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<Hsv> destination);
    public static Hsv ToHsv(LinearRgb& color);
    public static void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<Hsv> destination);
    public Hsv ToHsv(Lms color);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<Hsv> destination);
    public static Hsv ToHsv(Rgb& color);
    public static void Convert(ReadOnlySpan`1<Rgb> source, Span`1<Hsv> destination);
    public Hsv ToHsv(YCbCr& color);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<Hsv> destination);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<HunterLab> destination);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<HunterLab> destination);
    public HunterLab ToHunterLab(CieLab& color);
    public HunterLab ToHunterLab(CieLch& color);
    public HunterLab ToHunterLab(CieLchuv& color);
    public HunterLab ToHunterLab(CieLuv& color);
    public HunterLab ToHunterLab(CieXyy& color);
    public HunterLab ToHunterLab(CieXyz& color);
    public HunterLab ToHunterLab(Cmyk& color);
    public HunterLab ToHunterLab(Hsl& color);
    public HunterLab ToHunterLab(Hsv& color);
    public HunterLab ToHunterLab(LinearRgb& color);
    public HunterLab ToHunterLab(Lms& color);
    public HunterLab ToHunterLab(Rgb& color);
    public HunterLab ToHunterLab(YCbCr& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<LinearRgb> destination);
    public static void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<LinearRgb> destination);
    public static void Convert(ReadOnlySpan`1<Hsl> source, Span`1<LinearRgb> destination);
    public static void Convert(ReadOnlySpan`1<Hsv> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<LinearRgb> destination);
    public static void Convert(ReadOnlySpan`1<Rgb> source, Span`1<LinearRgb> destination);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<LinearRgb> destination);
    public LinearRgb ToLinearRgb(CieLab& color);
    public LinearRgb ToLinearRgb(CieLch& color);
    public LinearRgb ToLinearRgb(CieLchuv& color);
    public LinearRgb ToLinearRgb(CieLuv& color);
    public LinearRgb ToLinearRgb(CieXyy& color);
    public LinearRgb ToLinearRgb(CieXyz& color);
    public static LinearRgb ToLinearRgb(Cmyk& color);
    public static LinearRgb ToLinearRgb(Hsl& color);
    public static LinearRgb ToLinearRgb(Hsv& color);
    public LinearRgb ToLinearRgb(HunterLab& color);
    public LinearRgb ToLinearRgb(Lms& color);
    public static LinearRgb ToLinearRgb(Rgb& color);
    public LinearRgb ToLinearRgb(YCbCr& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<Hsl> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<Hsv> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<Rgb> source, Span`1<Lms> destination);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<Lms> destination);
    public Lms ToLms(CieLab& color);
    public Lms ToLms(CieLch& color);
    public Lms ToLms(CieLchuv& color);
    public Lms ToLms(CieLuv& color);
    public Lms ToLms(CieXyy& color);
    public Lms ToLms(CieXyz& color);
    public Lms ToLms(Cmyk& color);
    public Lms ToLms(Hsl& color);
    public Lms ToLms(Hsv& color);
    public Lms ToLms(HunterLab& color);
    public Lms ToLms(LinearRgb& color);
    public Lms ToLms(Rgb& color);
    public Lms ToLms(YCbCr& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<CieLchuv> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<Rgb> destination);
    public static void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<Rgb> destination);
    public static void Convert(ReadOnlySpan`1<Hsv> source, Span`1<Rgb> destination);
    public static void Convert(ReadOnlySpan`1<Hsl> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<Rgb> destination);
    public static void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<Rgb> destination);
    public void Convert(ReadOnlySpan`1<YCbCr> source, Span`1<Rgb> destination);
    public Rgb ToRgb(CieLab& color);
    public Rgb ToRgb(CieLch& color);
    public Rgb ToRgb(CieLchuv& color);
    public Rgb ToRgb(CieLuv& color);
    public Rgb ToRgb(CieXyy& color);
    public Rgb ToRgb(CieXyz& color);
    public static Rgb ToRgb(Cmyk& color);
    public static Rgb ToRgb(Hsv& color);
    public static Rgb ToRgb(Hsl& color);
    public Rgb ToRgb(HunterLab& color);
    public static Rgb ToRgb(LinearRgb& color);
    public Rgb ToRgb(Lms& color);
    public Rgb ToRgb(YCbCr& color);
    public void Convert(ReadOnlySpan`1<CieLab> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<CieLch> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<CieLuv> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<CieXyy> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<CieXyz> source, Span`1<YCbCr> destination);
    public static void Convert(ReadOnlySpan`1<Cmyk> source, Span`1<YCbCr> destination);
    public static void Convert(ReadOnlySpan`1<Hsl> source, Span`1<YCbCr> destination);
    public static void Convert(ReadOnlySpan`1<Hsv> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<HunterLab> source, Span`1<YCbCr> destination);
    public static void Convert(ReadOnlySpan`1<LinearRgb> source, Span`1<YCbCr> destination);
    public void Convert(ReadOnlySpan`1<Lms> source, Span`1<YCbCr> destination);
    public static void Convert(ReadOnlySpan`1<Rgb> source, Span`1<YCbCr> destination);
    public YCbCr ToYCbCr(CieLab& color);
    public YCbCr ToYCbCr(CieLch& color);
    public YCbCr ToYCbCr(CieLuv& color);
    public YCbCr ToYCbCr(CieXyy& color);
    public YCbCr ToYCbCr(CieXyz& color);
    public static YCbCr ToYCbCr(Cmyk& color);
    public static YCbCr ToYCbCr(Hsl& color);
    public static YCbCr ToYCbCr(Hsv& color);
    public YCbCr ToYCbCr(HunterLab& color);
    public static YCbCr ToYCbCr(LinearRgb& color);
    public YCbCr ToYCbCr(Lms& color);
    public static YCbCr ToYCbCr(Rgb& color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.ColorSpaces.Conversion.ColorSpaceConverterOptions : object {
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <TargetLuvWhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <TargetLabWhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <TargetHunterLabWhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private RgbWorkingSpace <TargetRgbWorkingSpace>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IChromaticAdaptation <ChromaticAdaptation>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix4x4 <LmsAdaptationMatrix>k__BackingField;
    public CieXyz WhitePoint { get; public set; }
    public CieXyz TargetLuvWhitePoint { get; public set; }
    public CieXyz TargetLabWhitePoint { get; public set; }
    public CieXyz TargetHunterLabWhitePoint { get; public set; }
    public RgbWorkingSpace TargetRgbWorkingSpace { get; public set; }
    [NullableAttribute("2")]
public IChromaticAdaptation ChromaticAdaptation { get; public set; }
    public Matrix4x4 LmsAdaptationMatrix { get; public set; }
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    [CompilerGeneratedAttribute]
public void set_WhitePoint(CieXyz value);
    [CompilerGeneratedAttribute]
public CieXyz get_TargetLuvWhitePoint();
    [CompilerGeneratedAttribute]
public void set_TargetLuvWhitePoint(CieXyz value);
    [CompilerGeneratedAttribute]
public CieXyz get_TargetLabWhitePoint();
    [CompilerGeneratedAttribute]
public void set_TargetLabWhitePoint(CieXyz value);
    [CompilerGeneratedAttribute]
public CieXyz get_TargetHunterLabWhitePoint();
    [CompilerGeneratedAttribute]
public void set_TargetHunterLabWhitePoint(CieXyz value);
    [CompilerGeneratedAttribute]
public RgbWorkingSpace get_TargetRgbWorkingSpace();
    [CompilerGeneratedAttribute]
public void set_TargetRgbWorkingSpace(RgbWorkingSpace value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IChromaticAdaptation get_ChromaticAdaptation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ChromaticAdaptation(IChromaticAdaptation value);
    [CompilerGeneratedAttribute]
public Matrix4x4 get_LmsAdaptationMatrix();
    [CompilerGeneratedAttribute]
public void set_LmsAdaptationMatrix(Matrix4x4 value);
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.GammaWorkingSpace : RgbWorkingSpace {
    [CompilerGeneratedAttribute]
private float <Gamma>k__BackingField;
    public float Gamma { get; }
    public GammaWorkingSpace(float gamma, CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    [CompilerGeneratedAttribute]
public float get_Gamma();
    public virtual float Compress(float channel);
    public virtual float Expand(float channel);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.HslAndRgbConverter : object {
    public static Rgb Convert(Hsl& input);
    public static Hsl Convert(Rgb& input);
    private static float GetColorComponent(float first, float second, float third);
    private static float MoveIntoRange(float value);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.HsvAndRgbConverter : object {
    public static Rgb Convert(Hsv& input);
    public static Hsv Convert(Rgb& input);
}
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.HunterLabToCieXyzConverter : CieXyzAndHunterLabConverterBase {
    public static CieXyz Convert(HunterLab& input);
}
public interface SixLabors.ImageSharp.ColorSpaces.Conversion.IChromaticAdaptation {
    public abstract virtual CieXyz Transform(CieXyz& modreq(System.Runtime.InteropServices.InAttribute) source, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) sourceWhitePoint, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) destinationWhitePoint);
    public abstract virtual void Transform(ReadOnlySpan`1<CieXyz> source, Span`1<CieXyz> destination, CieXyz sourceWhitePoint, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) destinationWhitePoint);
}
internal abstract class SixLabors.ImageSharp.ColorSpaces.Conversion.LinearRgbAndCieXyzConverterBase : object {
    [NullableContextAttribute("1")]
public static Matrix4x4 GetRgbToCieXyzMatrix(RgbWorkingSpace workingSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.ColorSpaces.Conversion.LinearRgbToCieXyzConverter : LinearRgbAndCieXyzConverterBase {
    private Matrix4x4 conversionMatrix;
    [CompilerGeneratedAttribute]
private RgbWorkingSpace <SourceWorkingSpace>k__BackingField;
    public RgbWorkingSpace SourceWorkingSpace { get; }
    public LinearRgbToCieXyzConverter(RgbWorkingSpace workingSpace);
    [CompilerGeneratedAttribute]
public RgbWorkingSpace get_SourceWorkingSpace();
    public CieXyz Convert(LinearRgb& input);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.LinearRgbToRgbConverter : object {
    public static Rgb Convert(LinearRgb& input);
}
public static class SixLabors.ImageSharp.ColorSpaces.Conversion.LmsAdaptationMatrix : object {
    public static Matrix4x4 VonKriesHPEAdjusted;
    public static Matrix4x4 VonKriesHPE;
    public static Matrix4x4 XyzScaling;
    public static Matrix4x4 Bradford;
    public static Matrix4x4 BradfordSharp;
    public static Matrix4x4 CMCCAT2000;
    public static Matrix4x4 CAT02;
    private static LmsAdaptationMatrix();
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.LWorkingSpace : RgbWorkingSpace {
    public LWorkingSpace(CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    public virtual float Compress(float channel);
    public virtual float Expand(float channel);
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.Rec2020WorkingSpace : RgbWorkingSpace {
    public Rec2020WorkingSpace(CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    public virtual float Compress(float channel);
    public virtual float Expand(float channel);
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.Rec709WorkingSpace : RgbWorkingSpace {
    public Rec709WorkingSpace(CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    public virtual float Compress(float channel);
    public virtual float Expand(float channel);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Conversion.RgbPrimariesChromaticityCoordinates : ValueType {
    [CompilerGeneratedAttribute]
private CieXyChromaticityCoordinates <R>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyChromaticityCoordinates <G>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyChromaticityCoordinates <B>k__BackingField;
    public CieXyChromaticityCoordinates R { get; }
    public CieXyChromaticityCoordinates G { get; }
    public CieXyChromaticityCoordinates B { get; }
    public RgbPrimariesChromaticityCoordinates(CieXyChromaticityCoordinates r, CieXyChromaticityCoordinates g, CieXyChromaticityCoordinates b);
    [CompilerGeneratedAttribute]
public CieXyChromaticityCoordinates get_R();
    [CompilerGeneratedAttribute]
public CieXyChromaticityCoordinates get_G();
    [CompilerGeneratedAttribute]
public CieXyChromaticityCoordinates get_B();
    public static bool op_Equality(RgbPrimariesChromaticityCoordinates left, RgbPrimariesChromaticityCoordinates right);
    public static bool op_Inequality(RgbPrimariesChromaticityCoordinates left, RgbPrimariesChromaticityCoordinates right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RgbPrimariesChromaticityCoordinates other);
    public virtual int GetHashCode();
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.RgbToLinearRgbConverter : object {
    public static LinearRgb Convert(Rgb& input);
}
public abstract class SixLabors.ImageSharp.ColorSpaces.Conversion.RgbWorkingSpace : object {
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private RgbPrimariesChromaticityCoordinates <ChromaticityCoordinates>k__BackingField;
    public CieXyz WhitePoint { get; }
    public RgbPrimariesChromaticityCoordinates ChromaticityCoordinates { get; }
    protected RgbWorkingSpace(CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    [CompilerGeneratedAttribute]
public RgbPrimariesChromaticityCoordinates get_ChromaticityCoordinates();
    public abstract virtual float Expand(float channel);
    public abstract virtual float Compress(float channel);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.SRgbWorkingSpace : RgbWorkingSpace {
    public SRgbWorkingSpace(CieXyz referenceWhite, RgbPrimariesChromaticityCoordinates chromaticityCoordinates);
    public virtual float Compress(float channel);
    public virtual float Expand(float channel);
}
public class SixLabors.ImageSharp.ColorSpaces.Conversion.VonKriesChromaticAdaptation : object {
    [NullableAttribute("1")]
private CieXyzAndLmsConverter converter;
    public VonKriesChromaticAdaptation(Matrix4x4 transformationMatrix);
    [NullableContextAttribute("1")]
internal VonKriesChromaticAdaptation(CieXyzAndLmsConverter converter);
    public CieXyz Transform(CieXyz& source, CieXyz& sourceWhitePoint, CieXyz& destinationWhitePoint);
    public void Transform(ReadOnlySpan`1<CieXyz> source, Span`1<CieXyz> destination, CieXyz sourceWhitePoint, CieXyz& destinationWhitePoint);
    private sealed virtual override CieXyz SixLabors.ImageSharp.ColorSpaces.Conversion.IChromaticAdaptation.Transform(CieXyz& modreq(System.Runtime.InteropServices.InAttribute) source, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) sourceWhitePoint, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) destinationWhitePoint);
    private sealed virtual override void SixLabors.ImageSharp.ColorSpaces.Conversion.IChromaticAdaptation.Transform(ReadOnlySpan`1<CieXyz> source, Span`1<CieXyz> destination, CieXyz sourceWhitePoint, CieXyz& modreq(System.Runtime.InteropServices.InAttribute) destinationWhitePoint);
}
internal static class SixLabors.ImageSharp.ColorSpaces.Conversion.YCbCrAndRgbConverter : object {
    private static Vector3 MaxBytes;
    private static YCbCrAndRgbConverter();
    public static Rgb Convert(YCbCr& input);
    public static YCbCr Convert(Rgb& input);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Hsl : ValueType {
    private static Vector3 Min;
    private static Vector3 Max;
    [CompilerGeneratedAttribute]
private float <H>k__BackingField;
    [CompilerGeneratedAttribute]
private float <S>k__BackingField;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    public float H { get; }
    public float S { get; }
    public float L { get; }
    public Hsl(float h, float s, float l);
    public Hsl(Vector3 vector);
    private static Hsl();
    [CompilerGeneratedAttribute]
public float get_H();
    [CompilerGeneratedAttribute]
public float get_S();
    [CompilerGeneratedAttribute]
public float get_L();
    public static bool op_Equality(Hsl left, Hsl right);
    public static bool op_Inequality(Hsl left, Hsl right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Hsl other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Hsv : ValueType {
    private static Vector3 Min;
    private static Vector3 Max;
    [CompilerGeneratedAttribute]
private float <H>k__BackingField;
    [CompilerGeneratedAttribute]
private float <S>k__BackingField;
    [CompilerGeneratedAttribute]
private float <V>k__BackingField;
    public float H { get; }
    public float S { get; }
    public float V { get; }
    public Hsv(float h, float s, float v);
    public Hsv(Vector3 vector);
    private static Hsv();
    [CompilerGeneratedAttribute]
public float get_H();
    [CompilerGeneratedAttribute]
public float get_S();
    [CompilerGeneratedAttribute]
public float get_V();
    public static bool op_Equality(Hsv left, Hsv right);
    public static bool op_Inequality(Hsv left, Hsv right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Hsv other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.HunterLab : ValueType {
    public static CieXyz DefaultWhitePoint;
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <A>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private CieXyz <WhitePoint>k__BackingField;
    public float L { get; }
    public float A { get; }
    public float B { get; }
    public CieXyz WhitePoint { get; }
    public HunterLab(float l, float a, float b);
    public HunterLab(float l, float a, float b, CieXyz whitePoint);
    public HunterLab(Vector3 vector);
    public HunterLab(Vector3 vector, CieXyz whitePoint);
    private static HunterLab();
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_A();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public CieXyz get_WhitePoint();
    public static bool op_Equality(HunterLab left, HunterLab right);
    public static bool op_Inequality(HunterLab left, HunterLab right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HunterLab other);
}
public static class SixLabors.ImageSharp.ColorSpaces.Illuminants : object {
    public static CieXyz A;
    public static CieXyz B;
    public static CieXyz C;
    public static CieXyz D50;
    public static CieXyz D55;
    public static CieXyz D65;
    public static CieXyz D75;
    public static CieXyz E;
    public static CieXyz F2;
    public static CieXyz F7;
    public static CieXyz F11;
    private static Illuminants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.LinearRgb : ValueType {
    private static Vector3 Min;
    private static Vector3 Max;
    public static RgbWorkingSpace DefaultWorkingSpace;
    [CompilerGeneratedAttribute]
private float <R>k__BackingField;
    [CompilerGeneratedAttribute]
private float <G>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private RgbWorkingSpace <WorkingSpace>k__BackingField;
    public float R { get; }
    public float G { get; }
    public float B { get; }
    public RgbWorkingSpace WorkingSpace { get; }
    public LinearRgb(float r, float g, float b);
    public LinearRgb(float r, float g, float b, RgbWorkingSpace workingSpace);
    public LinearRgb(Vector3 vector);
    public LinearRgb(Vector3 vector, RgbWorkingSpace workingSpace);
    private static LinearRgb();
    [CompilerGeneratedAttribute]
public float get_R();
    [CompilerGeneratedAttribute]
public float get_G();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public RgbWorkingSpace get_WorkingSpace();
    public static bool op_Equality(LinearRgb left, LinearRgb right);
    public static bool op_Inequality(LinearRgb left, LinearRgb right);
    public Vector3 ToVector3();
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LinearRgb other);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Lms : ValueType {
    [CompilerGeneratedAttribute]
private float <L>k__BackingField;
    [CompilerGeneratedAttribute]
private float <M>k__BackingField;
    [CompilerGeneratedAttribute]
private float <S>k__BackingField;
    public float L { get; }
    public float M { get; }
    public float S { get; }
    public Lms(float l, float m, float s);
    public Lms(Vector3 vector);
    [CompilerGeneratedAttribute]
public float get_L();
    [CompilerGeneratedAttribute]
public float get_M();
    [CompilerGeneratedAttribute]
public float get_S();
    public static bool op_Equality(Lms left, Lms right);
    public static bool op_Inequality(Lms left, Lms right);
    public Vector3 ToVector3();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Lms other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.Rgb : ValueType {
    public static RgbWorkingSpace DefaultWorkingSpace;
    private static Vector3 Min;
    private static Vector3 Max;
    [CompilerGeneratedAttribute]
private float <R>k__BackingField;
    [CompilerGeneratedAttribute]
private float <G>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private RgbWorkingSpace <WorkingSpace>k__BackingField;
    public float R { get; }
    public float G { get; }
    public float B { get; }
    public RgbWorkingSpace WorkingSpace { get; }
    public Rgb(float r, float g, float b);
    public Rgb(float r, float g, float b, RgbWorkingSpace workingSpace);
    public Rgb(Vector3 vector);
    public Rgb(Vector3 vector, RgbWorkingSpace workingSpace);
    private static Rgb();
    [CompilerGeneratedAttribute]
public float get_R();
    [CompilerGeneratedAttribute]
public float get_G();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public RgbWorkingSpace get_WorkingSpace();
    public static Rgb op_Implicit(Rgb24 color);
    public static Rgb op_Implicit(Rgba32 color);
    public static bool op_Equality(Rgb left, Rgb right);
    public static bool op_Inequality(Rgb left, Rgb right);
    public Vector3 ToVector3();
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rgb other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.ColorSpaces.RgbWorkingSpaces : object {
    public static RgbWorkingSpace SRgb;
    public static RgbWorkingSpace SRgbSimplified;
    public static RgbWorkingSpace Rec709;
    public static RgbWorkingSpace Rec2020;
    public static RgbWorkingSpace ECIRgbv2;
    public static RgbWorkingSpace AdobeRgb1998;
    public static RgbWorkingSpace ApplesRgb;
    public static RgbWorkingSpace BestRgb;
    public static RgbWorkingSpace BetaRgb;
    public static RgbWorkingSpace BruceRgb;
    public static RgbWorkingSpace CIERgb;
    public static RgbWorkingSpace ColorMatchRgb;
    public static RgbWorkingSpace DonRgb4;
    public static RgbWorkingSpace EktaSpacePS5;
    public static RgbWorkingSpace NTSCRgb;
    public static RgbWorkingSpace PALSECAMRgb;
    public static RgbWorkingSpace ProPhotoRgb;
    public static RgbWorkingSpace SMPTECRgb;
    public static RgbWorkingSpace WideGamutRgb;
    private static RgbWorkingSpaces();
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.ColorSpaces.YCbCr : ValueType {
    private static Vector3 Min;
    private static Vector3 Max;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cb>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Cr>k__BackingField;
    public float Y { get; }
    public float Cb { get; }
    public float Cr { get; }
    public YCbCr(float y, float cb, float cr);
    public YCbCr(Vector3 vector);
    private static YCbCr();
    [CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public float get_Cb();
    [CompilerGeneratedAttribute]
public float get_Cr();
    public static bool op_Equality(YCbCr left, YCbCr right);
    public static bool op_Inequality(YCbCr left, YCbCr right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(YCbCr other);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Common.Helpers.ExifResolutionValues : ValueType {
    [CompilerGeneratedAttribute]
private ushort <ResolutionUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <HorizontalResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <VerticalResolution>k__BackingField;
    public ushort ResolutionUnit { get; }
    public Nullable`1<double> HorizontalResolution { get; }
    public Nullable`1<double> VerticalResolution { get; }
    public ExifResolutionValues(ushort resolutionUnit, Nullable`1<double> horizontalResolution, Nullable`1<double> verticalResolution);
    [CompilerGeneratedAttribute]
public ushort get_ResolutionUnit();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_HorizontalResolution();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_VerticalResolution();
}
internal static class SixLabors.ImageSharp.Common.Helpers.HexConverter : object {
    public static int HexStringToBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    [CompilerGeneratedAttribute]
internal static int <HexStringToBytes>g__FromChar|0_0(int c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Common.Helpers.RiffHelper : object {
    private static UInt32 RiffFourCc;
    public static void WriteRiffFile(Stream stream, string formType, Action`1<Stream> func);
    public static void WriteChunk(Stream stream, UInt32 fourCc, Action`1<Stream> func);
    [NullableContextAttribute("0")]
public static void WriteChunk(Stream stream, UInt32 fourCc, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
public static void WriteChunk(Stream stream, UInt32 fourCc, TStruct& chunk);
    public static long BeginWriteChunk(Stream stream, UInt32 fourCc);
    public static void EndWriteChunk(Stream stream, long sizePosition);
    public static long BeginWriteRiffFile(Stream stream, string formType);
    public static void EndWriteRiffFile(Stream stream, WebpVp8X& vp8x, bool updateVp8x, long sizePosition);
}
internal static class SixLabors.ImageSharp.Common.Helpers.RuntimeUtility : object {
    [NullableContextAttribute("1")]
public static void Swap(T& a, T& b);
    [NullableContextAttribute("2")]
public static void Swap(Span`1& a, Span`1& b);
}
internal static class SixLabors.ImageSharp.Common.Helpers.TestHelpers : object {
    [NullableAttribute("1")]
internal static string ImageSharpBuiltAgainst;
}
internal static class SixLabors.ImageSharp.Common.Helpers.UnitConverter : object {
    private static double CmsInMeter;
    private static double CmsInInch;
    private static double InchesInMeter;
    private static PixelResolutionUnit DefaultResolutionUnit;
    public static double CmToMeter(double x);
    public static double MeterToCm(double x);
    public static double MeterToInch(double x);
    public static double InchToMeter(double x);
    public static double CmToInch(double x);
    public static double InchToCm(double x);
    [NullableContextAttribute("1")]
public static PixelResolutionUnit ExifProfileToResolutionUnit(ExifProfile profile);
    public static ExifResolutionValues GetExifResolutionValues(PixelResolutionUnit unit, double horizontal, double vertical);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Complex64 : ValueType {
    public float Real;
    public float Imaginary;
    public Complex64(float real, float imaginary);
    public static Complex64 op_Multiply(Complex64 value, float scalar);
    public static ComplexVector4 op_Multiply(Complex64 value, Vector4 vector);
    public static ComplexVector4 op_Multiply(Complex64 value, ComplexVector4 vector);
    public sealed virtual bool Equals(Complex64 other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class SixLabors.ImageSharp.ComplexVector4 : ValueType {
    public Vector4 Real;
    public Vector4 Imaginary;
    public void Sum(ComplexVector4 value);
    public Vector4 WeightedSum(float a, float b);
    public sealed virtual bool Equals(ComplexVector4 other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class SixLabors.ImageSharp.Compression.Zlib.Adler32 : object {
    public static UInt32 SeedValue;
    private static UInt32 BASE;
    private static UInt32 NMAX;
    private static int MinBufferSize;
    private static int BlockSize;
    private static ReadOnlySpan`1<byte> Tap1Tap2 { get; }
    private static ReadOnlySpan`1<byte> get_Tap1Tap2();
    public static UInt32 Calculate(ReadOnlySpan`1<byte> buffer);
    public static UInt32 Calculate(UInt32 adler, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateSse(UInt32 adler, ReadOnlySpan`1<byte> buffer);
    public static UInt32 CalculateAvx2(UInt32 adler, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateArm(UInt32 adler, ReadOnlySpan`1<byte> buffer);
    private static void HandleLeftOver(Byte* localBufferPtr, UInt32 length, UInt32& s1, UInt32& s2);
    private static UInt32 CalculateScalar(UInt32 adler, ReadOnlySpan`1<byte> buffer);
}
internal static class SixLabors.ImageSharp.Compression.Zlib.Crc32 : object {
    public static UInt32 SeedValue;
    private static int MinBufferSize;
    private static int ChunksizeMask;
    [NullableAttribute("1")]
private static UInt64[] K05Poly;
    [NullableAttribute("1")]
private static UInt32[] CrcTable;
    private static Crc32();
    public static UInt32 Calculate(ReadOnlySpan`1<byte> buffer);
    public static UInt32 Calculate(UInt32 crc, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateSse(UInt32 crc, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateArm(UInt32 crc, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateArm64(UInt32 crc, ReadOnlySpan`1<byte> buffer);
    private static UInt32 CalculateScalar(UInt32 crc, ReadOnlySpan`1<byte> buffer);
}
public enum SixLabors.ImageSharp.Compression.Zlib.DeflateCompressionLevel : Enum {
    public int value__;
    public static DeflateCompressionLevel Level0;
    public static DeflateCompressionLevel NoCompression;
    public static DeflateCompressionLevel Level1;
    public static DeflateCompressionLevel BestSpeed;
    public static DeflateCompressionLevel Level2;
    public static DeflateCompressionLevel Level3;
    public static DeflateCompressionLevel Level4;
    public static DeflateCompressionLevel Level5;
    public static DeflateCompressionLevel Level6;
    public static DeflateCompressionLevel DefaultCompression;
    public static DeflateCompressionLevel Level7;
    public static DeflateCompressionLevel Level8;
    public static DeflateCompressionLevel Level9;
    public static DeflateCompressionLevel BestCompression;
}
internal class SixLabors.ImageSharp.Compression.Zlib.Deflater : object {
    public static int BestCompression;
    public static int BestSpeed;
    public static int DefaultCompression;
    public static int NoCompression;
    public static int Deflated;
    private int level;
    private int state;
    [NullableAttribute("1")]
private DeflaterEngine engine;
    private bool isDisposed;
    private static int IsFlushing;
    private static int IsFinishing;
    private static int BusyState;
    private static int FlushingState;
    private static int FinishingState;
    private static int FinishedState;
    private static int ClosedState;
    public bool IsFinished { get; }
    public bool IsNeedingInput { get; }
    [NullableContextAttribute("1")]
public Deflater(MemoryAllocator memoryAllocator, int level);
    public bool get_IsFinished();
    public bool get_IsNeedingInput();
    public void Reset();
    public void Flush();
    public void Finish();
    [NullableContextAttribute("1")]
public void SetInput(Byte[] input, int offset, int count);
    public void SetLevel(int level);
    public int Deflate(Span`1<byte> output, int offset, int length);
    public sealed virtual void Dispose();
}
internal static class SixLabors.ImageSharp.Compression.Zlib.DeflaterConstants : object {
    public static bool DEBUGGING;
    public static int STORED_BLOCK;
    public static int STATIC_TREES;
    public static int DYN_TREES;
    public static int PRESET_DICT;
    public static int DEFAULT_MEM_LEVEL;
    public static int MAX_MATCH;
    public static int MIN_MATCH;
    public static int MAX_WBITS;
    public static int WSIZE;
    public static int WMASK;
    public static int HASH_BITS;
    public static int HASH_SIZE;
    public static int HASH_MASK;
    public static int HASH_SHIFT;
    public static int MIN_LOOKAHEAD;
    public static int MAX_DIST;
    public static int PENDING_BUF_SIZE;
    public static int MAX_BLOCK_SIZE;
    public static int DEFLATE_STORED;
    public static int DEFLATE_FAST;
    public static int DEFLATE_SLOW;
    public static Int32[] GOOD_LENGTH;
    public static Int32[] MAX_LAZY;
    public static Int32[] NICE_LENGTH;
    public static Int32[] MAX_CHAIN;
    public static Int32[] COMPR_FUNC;
    private static DeflaterConstants();
}
internal class SixLabors.ImageSharp.Compression.Zlib.DeflaterEngine : object {
    private static int TooFar;
    private int insertHashIndex;
    private int matchStart;
    private int matchLen;
    private bool prevAvailable;
    private int blockStart;
    private int strstart;
    private int lookahead;
    private int compressionFunction;
    [NullableAttribute("2")]
private Byte[] inputBuf;
    private int inputOff;
    private int inputEnd;
    private DeflateStrategy strategy;
    [NullableAttribute("1")]
private DeflaterHuffman huffman;
    private bool isDisposed;
    [NullableAttribute("1")]
private IMemoryOwner`1<short> headMemoryOwner;
    private MemoryHandle headMemoryHandle;
    private Memory`1<short> head;
    private Int16* pinnedHeadPointer;
    [NullableAttribute("1")]
private IMemoryOwner`1<short> prevMemoryOwner;
    private MemoryHandle prevMemoryHandle;
    private Memory`1<short> prev;
    private Int16* pinnedPrevPointer;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> windowMemoryOwner;
    private MemoryHandle windowMemoryHandle;
    private Memory`1<byte> window;
    private Byte* pinnedWindowPointer;
    private int maxChain;
    private int maxLazy;
    private int niceLength;
    private int goodLength;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DeflaterPendingBuffer <Pending>k__BackingField;
    [NullableAttribute("1")]
public DeflaterPendingBuffer Pending { get; }
    [NullableContextAttribute("1")]
public DeflaterEngine(MemoryAllocator memoryAllocator, DeflateStrategy strategy);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public DeflaterPendingBuffer get_Pending();
    public bool Deflate(bool flush, bool finish);
    [NullableContextAttribute("2")]
public void SetInput(Byte[] buffer, int offset, int count);
    public bool NeedsInput();
    public void Reset();
    public void SetLevel(int level);
    public void FillWindow();
    public sealed virtual void Dispose();
    private void UpdateHash();
    private int InsertString();
    private void SlideWindow();
    private bool FindLongestMatch(int curMatch);
    private bool DeflateStored(bool flush, bool finish);
    private bool DeflateFast(bool flush, bool finish);
    private bool DeflateSlow(bool flush, bool finish);
}
internal class SixLabors.ImageSharp.Compression.Zlib.DeflaterHuffman : object {
    private static int BufferSize;
    private static int LiteralNumber;
    private static int DistanceNumber;
    private static int BitLengthNumber;
    private static int Repeat3To6;
    private static int Repeat3To10;
    private static int Repeat11To138;
    private static int EofSymbol;
    [NullableAttribute("1")]
private Tree literalTree;
    [NullableAttribute("1")]
private Tree distTree;
    [NullableAttribute("1")]
private Tree blTree;
    [NullableAttribute("1")]
private IMemoryOwner`1<short> distanceMemoryOwner;
    private Int16* pinnedDistanceBuffer;
    private MemoryHandle distanceBufferHandle;
    [NullableAttribute("1")]
private IMemoryOwner`1<short> literalMemoryOwner;
    private Int16* pinnedLiteralBuffer;
    private MemoryHandle literalBufferHandle;
    private int lastLiteral;
    private int extraBits;
    private bool isDisposed;
    [NullableAttribute("1")]
private static Int16[] StaticLCodes;
    [NullableAttribute("1")]
private static Int16[] StaticDCodes;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DeflaterPendingBuffer <Pending>k__BackingField;
    private static ReadOnlySpan`1<byte> StaticLLength { get; }
    private static ReadOnlySpan`1<byte> StaticDLength { get; }
    private static ReadOnlySpan`1<byte> BitLengthOrder { get; }
    private static ReadOnlySpan`1<byte> Bit4Reverse { get; }
    [NullableAttribute("1")]
public DeflaterPendingBuffer Pending { get; private set; }
    [NullableContextAttribute("1")]
public DeflaterHuffman(MemoryAllocator memoryAllocator);
    private static DeflaterHuffman();
    private static ReadOnlySpan`1<byte> get_StaticLLength();
    private static ReadOnlySpan`1<byte> get_StaticDLength();
    private static ReadOnlySpan`1<byte> get_BitLengthOrder();
    private static ReadOnlySpan`1<byte> get_Bit4Reverse();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public DeflaterPendingBuffer get_Pending();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Pending(DeflaterPendingBuffer value);
    public void Reset();
    public void SendAllTrees(int blTreeCodes);
    public void CompressBlock();
    public void FlushStoredBlock(ReadOnlySpan`1<byte> stored, int storedOffset, int storedLength, bool lastBlock);
    public void FlushBlock(ReadOnlySpan`1<byte> stored, int storedOffset, int storedLength, bool lastBlock);
    public bool IsFull();
    public bool TallyLit(int literal);
    public bool TallyDist(int distance, int length);
    public static short BitReverse(int toReverse);
    public sealed virtual void Dispose();
    private static int Lcode(int length);
    private static int Dcode(int distance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Compression.Zlib.DeflaterOutputStream : Stream {
    private static int BufferLength;
    private IMemoryOwner`1<byte> memoryOwner;
    [NullableAttribute("0")]
private Memory`1<byte> buffer;
    private Deflater deflater;
    private Stream rawStream;
    private bool isDisposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflaterOutputStream(MemoryAllocator memoryAllocator, Stream rawStream, int compressionLevel);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void Deflate();
    private void Deflate(bool flushing);
    private void Finish();
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Compression.Zlib.DeflaterPendingBuffer : object {
    private Memory`1<byte> buffer;
    private Byte* pinnedBuffer;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> bufferMemoryOwner;
    private MemoryHandle bufferMemoryHandle;
    private int start;
    private int end;
    private UInt32 bits;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private int <BitCount>k__BackingField;
    public int BitCount { get; private set; }
    public bool IsFlushed { get; }
    [NullableContextAttribute("1")]
public DeflaterPendingBuffer(MemoryAllocator memoryAllocator);
    [CompilerGeneratedAttribute]
public int get_BitCount();
    [CompilerGeneratedAttribute]
private void set_BitCount(int value);
    public bool get_IsFlushed();
    public void Reset();
    public void WriteShort(int value);
    public void WriteBlock(ReadOnlySpan`1<byte> block, int offset, int length);
    public void AlignToByte();
    public void WriteBits(int b, int count);
    public void WriteShortMSB(int value);
    public int Flush(Span`1<byte> output, int offset, int length);
    public sealed virtual void Dispose();
}
internal enum SixLabors.ImageSharp.Compression.Zlib.DeflateStrategy : Enum {
    public int value__;
    public static DeflateStrategy Default;
    public static DeflateStrategy Filtered;
    public static DeflateStrategy HuffmanOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Compression.Zlib.DeflateThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowAlreadyFinished();
    [DoesNotReturnAttribute]
public static void ThrowAlreadyClosed();
    [DoesNotReturnAttribute]
public static void ThrowUnknownCompression();
    [DoesNotReturnAttribute]
public static void ThrowNotProcessed();
    [DoesNotReturnAttribute]
public static void ThrowNull(string name);
    [DoesNotReturnAttribute]
public static void ThrowOutOfRange(string name);
    [DoesNotReturnAttribute]
public static void ThrowHeapViolated();
    [DoesNotReturnAttribute]
public static void ThrowNoDeflate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Compression.Zlib.ZlibDeflateStream : Stream {
    private Stream rawStream;
    private UInt32 adler;
    private bool isDisposed;
    private DeflaterOutputStream deflateStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibDeflateStream(MemoryAllocator memoryAllocator, Stream stream, DeflateCompressionLevel level);
    public ZlibDeflateStream(MemoryAllocator memoryAllocator, Stream stream, PngCompressionLevel level);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Compression.Zlib.ZlibInflateStream : Stream {
    private static Byte[] ChecksumBuffer;
    private static Func`1<int> GetDataNoOp;
    private BufferedReadStream innerStream;
    private bool isDisposed;
    private int currentDataRemaining;
    private Func`1<int> getData;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DeflateStream <CompressedStream>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [NullableAttribute("2")]
public DeflateStream CompressedStream { get; private set; }
    public ZlibInflateStream(BufferedReadStream innerStream);
    public ZlibInflateStream(BufferedReadStream innerStream, Func`1<int> getData);
    private static ZlibInflateStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DeflateStream get_CompressedStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_CompressedStream(DeflateStream value);
    [MemberNotNullWhenAttribute("True", "CompressedStream")]
public bool AllocateNewBytes(int bytes, bool isCriticalChunk);
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    [MemberNotNullWhenAttribute("True", "CompressedStream")]
private bool InitializeInflateStream(bool isCriticalChunk);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Configuration : object {
    private static Lazy`1<Configuration> Lazy;
    private static int DefaultStreamProcessingBufferSize;
    private int streamProcessingBufferSize;
    private int maxDegreeOfParallelism;
    private MemoryAllocator memoryAllocator;
    [CompilerGeneratedAttribute]
private static Configuration <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferContiguousImageBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOrigin <ReadOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageFormatManager <ImageFormatsManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WorkingBufferSizeHintInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private IImageProcessingContextFactory <ImageOperationsProvider>k__BackingField;
    public static Configuration Default { get; }
    public int MaxDegreeOfParallelism { get; public set; }
    public int StreamProcessingBufferSize { get; public set; }
    public bool PreferContiguousImageBuffers { get; public set; }
    public IDictionary`2<object, object> Properties { get; }
    public IEnumerable`1<IImageFormat> ImageFormats { get; }
    public ReadOrigin ReadOrigin { get; public set; }
    public ImageFormatManager ImageFormatsManager { get; private set; }
    public MemoryAllocator MemoryAllocator { get; public set; }
    internal int MaxHeaderSize { get; }
    internal IFileSystem FileSystem { get; internal set; }
    internal int WorkingBufferSizeHintInBytes { get; internal set; }
    internal IImageProcessingContextFactory ImageOperationsProvider { get; internal set; }
    public Configuration(IImageFormatConfigurationModule[] configurationModules);
    private static Configuration();
    [CompilerGeneratedAttribute]
public static Configuration get_Default();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public int get_StreamProcessingBufferSize();
    public void set_StreamProcessingBufferSize(int value);
    [CompilerGeneratedAttribute]
public bool get_PreferContiguousImageBuffers();
    [CompilerGeneratedAttribute]
public void set_PreferContiguousImageBuffers(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<object, object> get_Properties();
    public IEnumerable`1<IImageFormat> get_ImageFormats();
    [CompilerGeneratedAttribute]
public ReadOrigin get_ReadOrigin();
    [CompilerGeneratedAttribute]
public void set_ReadOrigin(ReadOrigin value);
    [CompilerGeneratedAttribute]
public ImageFormatManager get_ImageFormatsManager();
    [CompilerGeneratedAttribute]
private void set_ImageFormatsManager(ImageFormatManager value);
    public MemoryAllocator get_MemoryAllocator();
    public void set_MemoryAllocator(MemoryAllocator value);
    internal int get_MaxHeaderSize();
    [CompilerGeneratedAttribute]
internal IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
internal void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
internal int get_WorkingBufferSizeHintInBytes();
    [CompilerGeneratedAttribute]
internal void set_WorkingBufferSizeHintInBytes(int value);
    [CompilerGeneratedAttribute]
internal IImageProcessingContextFactory get_ImageOperationsProvider();
    [CompilerGeneratedAttribute]
internal void set_ImageOperationsProvider(IImageProcessingContextFactory value);
    public void Configure(IImageFormatConfigurationModule configuration);
    public Configuration Clone();
    internal static Configuration CreateDefaultInstance();
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.ConfigurationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ParallelOptions GetParallelOptions(Configuration configuration);
}
internal static class SixLabors.ImageSharp.Constants : object {
    public static float Epsilon;
    public static float EpsilonSquared;
    private static Constants();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.DefaultPad3Shuffle4 : ValueType {
    [CompilerGeneratedAttribute]
private byte <Control>k__BackingField;
    public byte Control { get; }
    public DefaultPad3Shuffle4(byte control);
    [CompilerGeneratedAttribute]
public byte get_Control();
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.DefaultShuffle3 : ValueType {
    [CompilerGeneratedAttribute]
private byte <Control>k__BackingField;
    public byte Control { get; }
    public DefaultShuffle3(byte control);
    [CompilerGeneratedAttribute]
public byte get_Control();
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.DefaultShuffle4 : ValueType {
    [CompilerGeneratedAttribute]
private byte <Control>k__BackingField;
    public byte Control { get; }
    public DefaultShuffle4(byte control);
    [CompilerGeneratedAttribute]
public byte get_Control();
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.DefaultShuffle4Slice3 : ValueType {
    [CompilerGeneratedAttribute]
private byte <Control>k__BackingField;
    public byte Control { get; }
    public DefaultShuffle4Slice3(byte control);
    [CompilerGeneratedAttribute]
public byte get_Control();
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.DenseMatrix`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private T[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rows>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public T[] Data { get; }
    public int Columns { get; }
    public int Rows { get; }
    public Size Size { get; }
    public int Count { get; }
    public Span`1<T> Span { get; }
    public T& Item { get; }
    public DenseMatrix`1(int length);
    public DenseMatrix`1(int columns, int rows);
    public DenseMatrix`1(T[0...,0...] data);
    public DenseMatrix`1(int columns, int rows, Span`1<T> data);
    [CompilerGeneratedAttribute]
public T[] get_Data();
    [CompilerGeneratedAttribute]
public int get_Columns();
    [CompilerGeneratedAttribute]
public int get_Rows();
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public int get_Count();
    public Span`1<T> get_Span();
    public T& get_Item(int row, int column);
    public static DenseMatrix`1<T> op_Implicit(T[0...,0...] data);
    public static T[0...,0...] op_Implicit(DenseMatrix`1& data);
    public static bool op_Equality(DenseMatrix`1<T> left, DenseMatrix`1<T> right);
    public static bool op_Inequality(DenseMatrix`1<T> left, DenseMatrix`1<T> right);
    public DenseMatrix`1<T> Transpose();
    public void Fill(T value);
    public void Clear();
    [ConditionalAttribute("DEBUG")]
private void CheckCoordinates(int row, int column);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DenseMatrix`1<T> other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Diagnostics.MemoryDiagnostics : object {
    private static int totalUndisposedAllocationCount;
    private static UndisposedAllocationDelegate undisposedAllocation;
    private static int undisposedAllocationSubscriptionCounter;
    [NullableAttribute("1")]
private static object SyncRoot;
    [CompilerGeneratedAttribute]
private static Action MemoryAllocated;
    [CompilerGeneratedAttribute]
private static Action MemoryReleased;
    public static int TotalUndisposedAllocationCount { get; }
    internal static bool UndisposedAllocationSubscribed { get; }
    private static MemoryDiagnostics();
    [NullableContextAttribute("1")]
public static void add_UndisposedAllocation(UndisposedAllocationDelegate value);
    [NullableContextAttribute("1")]
public static void remove_UndisposedAllocation(UndisposedAllocationDelegate value);
    [CompilerGeneratedAttribute]
internal static void add_MemoryAllocated(Action value);
    [CompilerGeneratedAttribute]
internal static void remove_MemoryAllocated(Action value);
    [CompilerGeneratedAttribute]
internal static void add_MemoryReleased(Action value);
    [CompilerGeneratedAttribute]
internal static void remove_MemoryReleased(Action value);
    public static int get_TotalUndisposedAllocationCount();
    internal static bool get_UndisposedAllocationSubscribed();
    internal static void IncrementTotalUndisposedAllocationCount();
    internal static void DecrementTotalUndisposedAllocationCount();
    [NullableContextAttribute("1")]
internal static void RaiseUndisposedMemoryResource(string allocationStackTrace);
}
public class SixLabors.ImageSharp.Diagnostics.UndisposedAllocationDelegate : MulticastDelegate {
    public UndisposedAllocationDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(string allocationStackTrace);
    public virtual IAsyncResult BeginInvoke(string allocationStackTrace, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.EnumerableExtensions : object {
    public static IEnumerable`1<int> SteppedRange(int fromInclusive, Func`2<int, bool> toDelegate, int step);
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.EnumerableExtensions/<RangeIterator>d__1")]
private static IEnumerable`1<int> RangeIterator(int fromInclusive, Func`2<int, bool> toDelegate, int step);
}
internal static class SixLabors.ImageSharp.EnumUtils : object {
    public static TEnum Parse(int value, TEnum defaultValue);
    public static bool HasFlag(TEnum value, TEnum flag);
}
internal class SixLabors.ImageSharp.Formats.AnimatedImageFrameMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<Color>> <ColorTable>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameColorTableMode <ColorTableMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameBlendMode <BlendMode>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameDisposalMode <DisposalMode>k__BackingField;
    public Nullable`1<ReadOnlyMemory`1<Color>> ColorTable { get; public set; }
    public FrameColorTableMode ColorTableMode { get; public set; }
    public TimeSpan Duration { get; public set; }
    public FrameBlendMode BlendMode { get; public set; }
    public FrameDisposalMode DisposalMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<Color>> get_ColorTable();
    [CompilerGeneratedAttribute]
public void set_ColorTable(Nullable`1<ReadOnlyMemory`1<Color>> value);
    [CompilerGeneratedAttribute]
public FrameColorTableMode get_ColorTableMode();
    [CompilerGeneratedAttribute]
public void set_ColorTableMode(FrameColorTableMode value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public FrameBlendMode get_BlendMode();
    [CompilerGeneratedAttribute]
public void set_BlendMode(FrameBlendMode value);
    [CompilerGeneratedAttribute]
public FrameDisposalMode get_DisposalMode();
    [CompilerGeneratedAttribute]
public void set_DisposalMode(FrameDisposalMode value);
}
internal class SixLabors.ImageSharp.Formats.AnimatedImageMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<Color>> <ColorTable>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameColorTableMode <ColorTableMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RepeatCount>k__BackingField;
    public Nullable`1<ReadOnlyMemory`1<Color>> ColorTable { get; public set; }
    public FrameColorTableMode ColorTableMode { get; public set; }
    public Color BackgroundColor { get; public set; }
    public ushort RepeatCount { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<Color>> get_ColorTable();
    [CompilerGeneratedAttribute]
public void set_ColorTable(Nullable`1<ReadOnlyMemory`1<Color>> value);
    [CompilerGeneratedAttribute]
public FrameColorTableMode get_ColorTableMode();
    [CompilerGeneratedAttribute]
public void set_ColorTableMode(FrameColorTableMode value);
    [CompilerGeneratedAttribute]
public Color get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Color value);
    [CompilerGeneratedAttribute]
public ushort get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(ushort value);
}
internal static class SixLabors.ImageSharp.Formats.AnimationUtilities : object {
    public static ValueTuple`2<bool, Rectangle> DeDuplicatePixels(Configuration configuration, ImageFrame`1<TPixel> previousFrame, ImageFrame`1<TPixel> currentFrame, ImageFrame`1<TPixel> nextFrame, ImageFrame`1<TPixel> resultFrame, Color replacement, bool blend, ClampingMode clampingMode);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Bmp.BmpArrayFileHeader : ValueType {
    [CompilerGeneratedAttribute]
private short <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OffsetToNext>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ScreenWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ScreenHeight>k__BackingField;
    public short Type { get; }
    public int Size { get; }
    public int OffsetToNext { get; }
    public short ScreenWidth { get; }
    public short ScreenHeight { get; }
    public BmpArrayFileHeader(short type, int size, int offsetToNext, short width, short height);
    [CompilerGeneratedAttribute]
public short get_Type();
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public int get_OffsetToNext();
    [CompilerGeneratedAttribute]
public short get_ScreenWidth();
    [CompilerGeneratedAttribute]
public short get_ScreenHeight();
    public static BmpArrayFileHeader Parse(Span`1<byte> data);
}
public enum SixLabors.ImageSharp.Formats.Bmp.BmpBitsPerPixel : Enum {
    public short value__;
    public static BmpBitsPerPixel Pixel1;
    public static BmpBitsPerPixel Pixel2;
    public static BmpBitsPerPixel Pixel4;
    public static BmpBitsPerPixel Pixel8;
    public static BmpBitsPerPixel Pixel16;
    public static BmpBitsPerPixel Pixel24;
    public static BmpBitsPerPixel Pixel32;
}
internal enum SixLabors.ImageSharp.Formats.Bmp.BmpColorSpace : Enum {
    public int value__;
    public static BmpColorSpace LCS_CALIBRATED_RGB;
    public static BmpColorSpace LCS_WINDOWS_COLOR_SPACE;
    public static BmpColorSpace LCS_sRGB;
    public static BmpColorSpace PROFILE_LINKED;
    public static BmpColorSpace PROFILE_EMBEDDED;
}
internal enum SixLabors.ImageSharp.Formats.Bmp.BmpCompression : Enum {
    public int value__;
    public static BmpCompression RGB;
    public static BmpCompression RLE8;
    public static BmpCompression RLE4;
    public static BmpCompression BitFields;
    public static BmpCompression JPEG;
    public static BmpCompression PNG;
    public static BmpCompression BI_ALPHABITFIELDS;
    public static BmpCompression RLE24;
}
public class SixLabors.ImageSharp.Formats.Bmp.BmpConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
internal static class SixLabors.ImageSharp.Formats.Bmp.BmpConstants : object {
    [NullableAttribute("1")]
public static IEnumerable`1<string> MimeTypes;
    [NullableAttribute("1")]
public static IEnumerable`1<string> FileExtensions;
    private static BmpConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SixLabors.ImageSharp.Formats.Bmp.BmpDecoder : SpecializedImageDecoder`1<BmpDecoderOptions> {
    [CompilerGeneratedAttribute]
private static BmpDecoder <Instance>k__BackingField;
    public static BmpDecoder Instance { get; }
    private static BmpDecoder();
    [CompilerGeneratedAttribute]
public static BmpDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(BmpDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(BmpDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual BmpDecoderOptions CreateDefaultSpecializedOptions(DecoderOptions options);
}
internal class SixLabors.ImageSharp.Formats.Bmp.BmpDecoderCore : object {
    private static int DefaultRgb16RMask;
    private static int DefaultRgb16GMask;
    private static int DefaultRgb16BMask;
    private static int RleCommand;
    private static int RleEndOfLine;
    private static int RleEndOfBitmap;
    private static int RleDelta;
    [NullableAttribute("2")]
private ImageMetadata metadata;
    [NullableAttribute("2")]
private BmpMetadata bmpMetadata;
    private BmpFileHeader fileHeader;
    private BmpFileMarkerType fileMarkerType;
    private BmpInfoHeader infoHeader;
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    private RleSkippedPixelHandling rleSkippedPixelHandling;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    [NullableContextAttribute("1")]
public BmpDecoderCore(BmpDecoderOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private static int Invert(int y, int height, bool inverted);
    private static int CalculatePadding(int width, int componentCount);
    private void ReadBitFields(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, bool inverted);
    [NullableContextAttribute("1")]
private void ReadRle(BufferedReadStream stream, BmpCompression compression, Buffer2D`1<TPixel> pixels, Byte[] colors, int width, int height, bool inverted);
    private void ReadRle24(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted);
    private void UncompressRle4(BufferedReadStream stream, int w, Span`1<byte> buffer, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    private void UncompressRle8(BufferedReadStream stream, int w, Span`1<byte> buffer, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    private void UncompressRle24(BufferedReadStream stream, int w, Span`1<byte> buffer, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    private static void RleSkipEndOfBitmap(int count, int w, int skipPixelCount, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    private static int RleSkipEndOfLine(int count, int w, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    private static int RleSkipDelta(int count, int w, int dx, int dy, Span`1<bool> undefinedPixels, Span`1<bool> rowsWithUndefinedPixels);
    [NullableContextAttribute("1")]
private void ReadRgbPalette(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, Byte[] colors, int width, int height, int bitsPerPixel, int bytesPerColorMapEntry, bool inverted);
    private void ReadRgb16(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted, int redMask, int greenMask, int blueMask);
    private static byte GetBytesFrom5BitValue(int value);
    private static byte GetBytesFrom6BitValue(int value);
    private void ReadRgb24(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted);
    private void ReadRgb32Fast(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted);
    private void ReadRgb32Slow(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted);
    private void ReadRgb32BitFields(BufferedReadStream stream, Buffer2D`1<TPixel> pixels, int width, int height, bool inverted, int redMask, int greenMask, int blueMask, int alphaMask);
    private static int CalculateRightShift(UInt32 n);
    private static int CountBits(UInt32 n);
    [NullableContextAttribute("1")]
[MemberNotNullAttribute("metadata")]
[MemberNotNullAttribute("bmpMetadata")]
private void ReadInfoHeader(BufferedReadStream stream);
    [NullableContextAttribute("1")]
private void ReadFileHeader(BufferedReadStream stream);
    [NullableContextAttribute("1")]
[MemberNotNullAttribute("metadata")]
[MemberNotNullAttribute("bmpMetadata")]
private int ReadImageHeaders(BufferedReadStream stream, Boolean& inverted, Byte[]& palette);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Bmp.BmpDecoderOptions : object {
    [CompilerGeneratedAttribute]
private DecoderOptions <GeneralOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private RleSkippedPixelHandling <RleSkippedPixelHandling>k__BackingField;
    public DecoderOptions GeneralOptions { get; public set; }
    public RleSkippedPixelHandling RleSkippedPixelHandling { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_GeneralOptions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GeneralOptions(DecoderOptions value);
    [CompilerGeneratedAttribute]
public RleSkippedPixelHandling get_RleSkippedPixelHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RleSkippedPixelHandling(RleSkippedPixelHandling value);
}
public class SixLabors.ImageSharp.Formats.Bmp.BmpEncoder : QuantizingImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<BmpBitsPerPixel> <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTransparency>k__BackingField;
    public Nullable`1<BmpBitsPerPixel> BitsPerPixel { get; public set; }
    public bool SupportTransparency { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<BmpBitsPerPixel> get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitsPerPixel(Nullable`1<BmpBitsPerPixel> value);
    [CompilerGeneratedAttribute]
public bool get_SupportTransparency();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SupportTransparency(bool value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Bmp.BmpEncoderCore : object {
    private int padding;
    private static int Rgba32AlphaMask;
    private static int Rgba32RedMask;
    private static int Rgba32GreenMask;
    private static int Rgba32BlueMask;
    private static int ColorPaletteSize8Bit;
    private static int ColorPaletteSize4Bit;
    private static int ColorPaletteSize2Bit;
    private static int ColorPaletteSize1Bit;
    private MemoryAllocator memoryAllocator;
    private Nullable`1<BmpBitsPerPixel> bitsPerPixel;
    private BmpInfoHeaderType infoHeaderType;
    private IQuantizer quantizer;
    private IPixelSamplingStrategy pixelSamplingStrategy;
    public BmpEncoderCore(BmpEncoder encoder, MemoryAllocator memoryAllocator);
    [NullableContextAttribute("0")]
public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private BmpInfoHeader CreateBmpInfoHeader(int width, int height, int infoHeaderSize, ushort bpp, int bytesPerLine, ImageMetadata metadata, Byte[] iccProfileData);
    [NullableContextAttribute("0")]
private static void WriteColorProfile(Stream stream, Byte[] iccProfileData, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
private static void WriteBitmapFileHeader(Stream stream, int infoHeaderSize, int colorPaletteSize, int iccProfileSize, BmpInfoHeader infoHeader, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
private void WriteBitmapInfoHeader(Stream stream, BmpInfoHeader infoHeader, Span`1<byte> buffer, int infoHeaderSize);
    private void WriteImage(Configuration configuration, Stream stream, Image`1<TPixel> image);
    private IMemoryOwner`1<byte> AllocateRow(int width, int bytesPerPixel);
    private void Write32BitPixelData(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    private void Write24BitPixelData(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    private void Write16BitPixelData(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    private void Write8BitPixelData(Configuration configuration, Stream stream, Image`1<TPixel> image);
    [NullableContextAttribute("0")]
private void Write8BitColor(Configuration configuration, Stream stream, Image`1<TPixel> image, Span`1<byte> colorPalette);
    [NullableContextAttribute("0")]
private void Write8BitPixelData(Stream stream, Image`1<TPixel> image, Span`1<byte> colorPalette);
    private void Write4BitPixelData(Configuration configuration, Stream stream, Image`1<TPixel> image);
    private void Write2BitPixelData(Configuration configuration, Stream stream, Image`1<TPixel> image);
    private void Write1BitPixelData(Configuration configuration, Stream stream, Image`1<TPixel> image);
    [NullableContextAttribute("0")]
private static void WriteColorPalette(Configuration configuration, Stream stream, ReadOnlySpan`1<TPixel> quantizedColorPalette, Span`1<byte> colorPalette);
    [NullableContextAttribute("0")]
private static void Write1BitPalette(Stream stream, int startIdx, int endIdx, ReadOnlySpan`1<byte> quantizedPixelRow);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Bmp.BmpFileHeader : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private short <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Reserved>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public short Type { get; }
    public int FileSize { get; }
    public int Reserved { get; }
    public int Offset { get; }
    public BmpFileHeader(short type, int fileSize, int reserved, int offset);
    [CompilerGeneratedAttribute]
public short get_Type();
    [CompilerGeneratedAttribute]
public int get_FileSize();
    [CompilerGeneratedAttribute]
public int get_Reserved();
    [CompilerGeneratedAttribute]
public int get_Offset();
    public static BmpFileHeader Parse(Span`1<byte> data);
    public void WriteTo(Span`1<byte> buffer);
}
public enum SixLabors.ImageSharp.Formats.Bmp.BmpFileMarkerType : Enum {
    public int value__;
    public static BmpFileMarkerType Bitmap;
    public static BmpFileMarkerType BitmapArray;
    public static BmpFileMarkerType ColorIcon;
    public static BmpFileMarkerType ColorPointer;
    public static BmpFileMarkerType Icon;
    public static BmpFileMarkerType Pointer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Bmp.BmpFormat : object {
    [CompilerGeneratedAttribute]
private static BmpFormat <Instance>k__BackingField;
    public static BmpFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static BmpFormat();
    [CompilerGeneratedAttribute]
public static BmpFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual BmpMetadata CreateDefaultFormatMetadata();
}
public class SixLabors.ImageSharp.Formats.Bmp.BmpImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
internal class SixLabors.ImageSharp.Formats.Bmp.BmpInfoHeader : ValueType {
    public static int CoreSize;
    public static int Os22ShortSize;
    public static int SizeV3;
    public static int AdobeV3Size;
    public static int AdobeV3WithAlphaSize;
    public static int Os2v2Size;
    public static int SizeV4;
    public static int SizeV5;
    public static int MaxHeaderSize;
    public static int HeaderSizeSize;
    [CompilerGeneratedAttribute]
private int <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Planes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private BmpCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XPelsPerMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YPelsPerMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClrUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClrImportant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RedMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GreenMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlueMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AlphaMask>k__BackingField;
    [CompilerGeneratedAttribute]
private BmpColorSpace <CsType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RedX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RedY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RedZ>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GreenX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GreenY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GreenZ>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlueX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlueY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlueZ>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GammaRed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GammaGreen>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GammaBlue>k__BackingField;
    [CompilerGeneratedAttribute]
private BmpRenderingIntent <Intent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProfileData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProfileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Reserved>k__BackingField;
    public int HeaderSize { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public short Planes { get; public set; }
    public ushort BitsPerPixel { get; public set; }
    public BmpCompression Compression { get; public set; }
    public int ImageSize { get; public set; }
    public int XPelsPerMeter { get; public set; }
    public int YPelsPerMeter { get; public set; }
    public int ClrUsed { get; public set; }
    public int ClrImportant { get; public set; }
    public int RedMask { get; public set; }
    public int GreenMask { get; public set; }
    public int BlueMask { get; public set; }
    public int AlphaMask { get; public set; }
    public BmpColorSpace CsType { get; public set; }
    public int RedX { get; public set; }
    public int RedY { get; public set; }
    public int RedZ { get; public set; }
    public int GreenX { get; public set; }
    public int GreenY { get; public set; }
    public int GreenZ { get; public set; }
    public int BlueX { get; public set; }
    public int BlueY { get; public set; }
    public int BlueZ { get; public set; }
    public int GammaRed { get; public set; }
    public int GammaGreen { get; public set; }
    public int GammaBlue { get; public set; }
    public BmpRenderingIntent Intent { get; public set; }
    public int ProfileData { get; public set; }
    public int ProfileSize { get; public set; }
    public int Reserved { get; public set; }
    public BmpInfoHeader(int headerSize, int width, int height, short planes, ushort bitsPerPixel, BmpCompression compression, int imageSize, int xPelsPerMeter, int yPelsPerMeter, int clrUsed, int clrImportant, int redMask, int greenMask, int blueMask, int alphaMask, BmpColorSpace csType, int redX, int redY, int redZ, int greenX, int greenY, int greenZ, int blueX, int blueY, int blueZ, int gammeRed, int gammeGreen, int gammeBlue, BmpRenderingIntent intent, int profileData, int profileSize, int reserved);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public short get_Planes();
    [CompilerGeneratedAttribute]
public void set_Planes(short value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ushort get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(ushort value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BmpCompression get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(BmpCompression value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ImageSize();
    [CompilerGeneratedAttribute]
public void set_ImageSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_XPelsPerMeter();
    [CompilerGeneratedAttribute]
public void set_XPelsPerMeter(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_YPelsPerMeter();
    [CompilerGeneratedAttribute]
public void set_YPelsPerMeter(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ClrUsed();
    [CompilerGeneratedAttribute]
public void set_ClrUsed(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ClrImportant();
    [CompilerGeneratedAttribute]
public void set_ClrImportant(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RedMask();
    [CompilerGeneratedAttribute]
public void set_RedMask(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GreenMask();
    [CompilerGeneratedAttribute]
public void set_GreenMask(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BlueMask();
    [CompilerGeneratedAttribute]
public void set_BlueMask(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_AlphaMask();
    [CompilerGeneratedAttribute]
public void set_AlphaMask(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BmpColorSpace get_CsType();
    [CompilerGeneratedAttribute]
public void set_CsType(BmpColorSpace value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RedX();
    [CompilerGeneratedAttribute]
public void set_RedX(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RedY();
    [CompilerGeneratedAttribute]
public void set_RedY(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RedZ();
    [CompilerGeneratedAttribute]
public void set_RedZ(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GreenX();
    [CompilerGeneratedAttribute]
public void set_GreenX(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GreenY();
    [CompilerGeneratedAttribute]
public void set_GreenY(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GreenZ();
    [CompilerGeneratedAttribute]
public void set_GreenZ(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BlueX();
    [CompilerGeneratedAttribute]
public void set_BlueX(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BlueY();
    [CompilerGeneratedAttribute]
public void set_BlueY(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BlueZ();
    [CompilerGeneratedAttribute]
public void set_BlueZ(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GammaRed();
    [CompilerGeneratedAttribute]
public void set_GammaRed(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GammaGreen();
    [CompilerGeneratedAttribute]
public void set_GammaGreen(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_GammaBlue();
    [CompilerGeneratedAttribute]
public void set_GammaBlue(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BmpRenderingIntent get_Intent();
    [CompilerGeneratedAttribute]
public void set_Intent(BmpRenderingIntent value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ProfileData();
    [CompilerGeneratedAttribute]
public void set_ProfileData(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ProfileSize();
    [CompilerGeneratedAttribute]
public void set_ProfileSize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Reserved();
    [CompilerGeneratedAttribute]
public void set_Reserved(int value);
    public static BmpInfoHeader ParseCore(ReadOnlySpan`1<byte> data);
    public static BmpInfoHeader ParseOs22Short(ReadOnlySpan`1<byte> data);
    public static BmpInfoHeader ParseV3(ReadOnlySpan`1<byte> data);
    public static BmpInfoHeader ParseAdobeV3(ReadOnlySpan`1<byte> data, bool withAlpha);
    public static BmpInfoHeader ParseOs2Version2(ReadOnlySpan`1<byte> data);
    public static BmpInfoHeader ParseV4(ReadOnlySpan`1<byte> data);
    public static BmpInfoHeader ParseV5(ReadOnlySpan`1<byte> data);
    public void WriteV3Header(Span`1<byte> buffer);
    public void WriteV4Header(Span`1<byte> buffer);
    public void WriteV5Header(Span`1<byte> buffer);
}
public enum SixLabors.ImageSharp.Formats.Bmp.BmpInfoHeaderType : Enum {
    public int value__;
    public static BmpInfoHeaderType WinVersion2;
    public static BmpInfoHeaderType Os2Version2Short;
    public static BmpInfoHeaderType WinVersion3;
    public static BmpInfoHeaderType AdobeVersion3;
    public static BmpInfoHeaderType AdobeVersion3WithAlpha;
    public static BmpInfoHeaderType Os2Version2;
    public static BmpInfoHeaderType WinVersion4;
    public static BmpInfoHeaderType WinVersion5;
}
public class SixLabors.ImageSharp.Formats.Bmp.BmpMetadata : object {
    [CompilerGeneratedAttribute]
private BmpInfoHeaderType <InfoHeaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private BmpBitsPerPixel <BitsPerPixel>k__BackingField;
    public BmpInfoHeaderType InfoHeaderType { get; public set; }
    public BmpBitsPerPixel BitsPerPixel { get; public set; }
    [NullableContextAttribute("1")]
private BmpMetadata(BmpMetadata other);
    [CompilerGeneratedAttribute]
public BmpInfoHeaderType get_InfoHeaderType();
    [CompilerGeneratedAttribute]
public void set_InfoHeaderType(BmpInfoHeaderType value);
    [CompilerGeneratedAttribute]
public BmpBitsPerPixel get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(BmpBitsPerPixel value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
internal enum SixLabors.ImageSharp.Formats.Bmp.BmpRenderingIntent : Enum {
    public int value__;
    public static BmpRenderingIntent Invalid;
    public static BmpRenderingIntent LCS_GM_BUSINESS;
    public static BmpRenderingIntent LCS_GM_GRAPHICS;
    public static BmpRenderingIntent LCS_GM_IMAGES;
    public static BmpRenderingIntent LCS_GM_ABS_COLORIMETRIC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Bmp.BmpThrowHelper : object {
    public static void ThrowInvalidImageContentException(string errorMessage);
    public static void ThrowNotSupportedException(string errorMessage);
}
public enum SixLabors.ImageSharp.Formats.Bmp.RleSkippedPixelHandling : Enum {
    public int value__;
    public static RleSkippedPixelHandling Black;
    public static RleSkippedPixelHandling Transparent;
    public static RleSkippedPixelHandling FirstColorOfPalette;
}
internal enum SixLabors.ImageSharp.Formats.ClampingMode : Enum {
    public int value__;
    public static ClampingMode None;
    public static ClampingMode Even;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.DecoderOptions : object {
    private static Lazy`1<DecoderOptions> LazyOptions;
    private UInt32 maxFrames;
    private Configuration configuration;
    [CompilerGeneratedAttribute]
private static DecoderOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <TargetSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IResampler <Sampler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipMetadata>k__BackingField;
    internal static DecoderOptions Default { get; }
    public Configuration Configuration { get; public set; }
    public Nullable`1<Size> TargetSize { get; public set; }
    public IResampler Sampler { get; public set; }
    public bool SkipMetadata { get; public set; }
    public UInt32 MaxFrames { get; public set; }
    private static DecoderOptions();
    [CompilerGeneratedAttribute]
internal static DecoderOptions get_Default();
    public Configuration get_Configuration();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Configuration(Configuration value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_TargetSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public IResampler get_Sampler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Sampler(IResampler value);
    [CompilerGeneratedAttribute]
public bool get_SkipMetadata();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkipMetadata(bool value);
    public UInt32 get_MaxFrames();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaxFrames(UInt32 value);
    internal void SetConfiguration(Configuration configuration);
}
internal enum SixLabors.ImageSharp.Formats.FrameBlendMode : Enum {
    public int value__;
    public static FrameBlendMode Source;
    public static FrameBlendMode Over;
}
internal enum SixLabors.ImageSharp.Formats.FrameColorTableMode : Enum {
    public int value__;
    public static FrameColorTableMode Global;
    public static FrameColorTableMode Local;
}
internal enum SixLabors.ImageSharp.Formats.FrameDisposalMode : Enum {
    public int value__;
    public static FrameDisposalMode Unspecified;
    public static FrameDisposalMode DoNotDispose;
    public static FrameDisposalMode RestoreToBackground;
    public static FrameDisposalMode RestoreToPrevious;
}
public enum SixLabors.ImageSharp.Formats.Gif.GifColorTableMode : Enum {
    public int value__;
    public static GifColorTableMode Global;
    public static GifColorTableMode Local;
}
public class SixLabors.ImageSharp.Formats.Gif.GifConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
internal static class SixLabors.ImageSharp.Formats.Gif.GifConstants : object {
    [NullableAttribute("1")]
public static string FileType;
    [NullableAttribute("1")]
public static string FileVersion;
    public static byte ExtensionIntroducer;
    public static byte GraphicControlLabel;
    public static byte ApplicationExtensionLabel;
    public static byte ApplicationBlockSize;
    [NullableAttribute("1")]
public static string NetscapeApplicationIdentification;
    public static byte NetscapeLoopingSubBlockSize;
    public static byte CommentLabel;
    public static int MaxCommentSubBlockLength;
    public static byte ImageDescriptorLabel;
    public static byte PlainTextLabel;
    public static byte ImageLabel;
    public static byte Terminator;
    public static byte EndIntroducer;
    [NullableAttribute("1")]
public static Encoding Encoding;
    [NullableAttribute("1")]
public static IEnumerable`1<string> MimeTypes;
    [NullableAttribute("1")]
public static IEnumerable`1<string> FileExtensions;
    internal static ReadOnlySpan`1<byte> MagicNumber { get; }
    internal static ReadOnlySpan`1<byte> NetscapeApplicationIdentificationBytes { get; }
    internal static ReadOnlySpan`1<byte> XmpApplicationIdentificationBytes { get; }
    private static GifConstants();
    internal static ReadOnlySpan`1<byte> get_MagicNumber();
    internal static ReadOnlySpan`1<byte> get_NetscapeApplicationIdentificationBytes();
    internal static ReadOnlySpan`1<byte> get_XmpApplicationIdentificationBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Gif.GifDecoder : ImageDecoder {
    [CompilerGeneratedAttribute]
private static GifDecoder <Instance>k__BackingField;
    public static GifDecoder Instance { get; }
    private static GifDecoder();
    [CompilerGeneratedAttribute]
public static GifDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Gif.GifDecoderCore : object {
    private ScratchBuffer buffer;
    [NullableAttribute("2")]
private IMemoryOwner`1<byte> globalColorTable;
    [NullableAttribute("2")]
private IMemoryOwner`1<byte> currentLocalColorTable;
    private int currentLocalColorTableSize;
    private Nullable`1<Rectangle> restoreArea;
    private GifLogicalScreenDescriptor logicalScreenDescriptor;
    private GifGraphicControlExtension graphicsControlExtension;
    private GifImageDescriptor imageDescriptor;
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private UInt32 maxFrames;
    private bool skipMetadata;
    [NullableAttribute("2")]
private ImageMetadata metadata;
    [NullableAttribute("2")]
private GifMetadata gifMetadata;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public GifDecoderCore(DecoderOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    [NullableContextAttribute("0")]
public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private void ReadGraphicalControlExtension(BufferedReadStream stream);
    private void ReadImageDescriptor(BufferedReadStream stream);
    private void ReadLogicalScreenDescriptor(BufferedReadStream stream);
    private void ReadApplicationExtension(BufferedReadStream stream);
    private static void SkipBlock(BufferedReadStream stream, int blockSize);
    private void ReadComments(BufferedReadStream stream);
    [NullableContextAttribute("0")]
private void ReadFrame(BufferedReadStream stream, Image`1& image, ImageFrame`1& previousFrame);
    [NullableContextAttribute("0")]
private void ReadFrameColors(BufferedReadStream stream, Image`1& image, ImageFrame`1& previousFrame, ReadOnlySpan`1<Rgb24> colorTable, GifImageDescriptor& descriptor);
    private void ReadFrameMetadata(BufferedReadStream stream, List`1<ImageFrameMetadata> frameMetadata, ImageFrameMetadata& previousFrame);
    [NullableContextAttribute("0")]
private void RestoreToBackground(ImageFrame`1<TPixel> frame);
    private void SetFrameMetadata(ImageFrameMetadata metadata);
    [MemberNotNullAttribute("metadata")]
[MemberNotNullAttribute("gifMetadata")]
private void ReadLogicalScreenDescriptorAndGlobalColorTable(BufferedReadStream stream);
}
public enum SixLabors.ImageSharp.Formats.Gif.GifDisposalMethod : Enum {
    public int value__;
    public static GifDisposalMethod Unspecified;
    public static GifDisposalMethod NotDispose;
    public static GifDisposalMethod RestoreToBackground;
    public static GifDisposalMethod RestoreToPrevious;
}
public class SixLabors.ImageSharp.Formats.Gif.GifEncoder : QuantizingImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<GifColorTableMode> <ColorTableMode>k__BackingField;
    public Nullable`1<GifColorTableMode> ColorTableMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<GifColorTableMode> get_ColorTableMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorTableMode(Nullable`1<GifColorTableMode> value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Gif.GifEncoderCore : object {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    [NullableAttribute("1")]
private Configuration configuration;
    private bool skipMetadata;
    [NullableAttribute("2")]
private IQuantizer quantizer;
    private bool hasQuantizer;
    private Nullable`1<GifColorTableMode> colorTableMode;
    [NullableAttribute("1")]
private IPixelSamplingStrategy pixelSamplingStrategy;
    [NullableContextAttribute("1")]
public GifEncoderCore(Configuration configuration, GifEncoder encoder);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private static GifMetadata GetGifMetadata(Image`1<TPixel> image);
    private static GifFrameMetadata GetGifFrameMetadata(ImageFrame`1<TPixel> frame, int transparencyIndex);
    private void EncodeAdditionalFrames(Stream stream, Image`1<TPixel> image, ReadOnlyMemory`1<TPixel> globalPalette, int globalTransparencyIndex, GifDisposalMethod previousDisposalMethod);
    [NullableContextAttribute("1")]
private void EncodeFirstFrame(Stream stream, GifFrameMetadata metadata, IndexedImageFrame`1<TPixel> quantized);
    private void EncodeAdditionalFrame(Stream stream, ImageFrame`1<TPixel> previousFrame, ImageFrame`1<TPixel> currentFrame, ImageFrame`1<TPixel> nextFrame, ImageFrame`1<TPixel> encodingFrame, bool useLocal, GifFrameMetadata metadata, PaletteQuantizer`1<TPixel> globalPaletteQuantizer, GifDisposalMethod previousDisposal);
    private IndexedImageFrame`1<TPixel> QuantizeAdditionalFrameAndUpdateMetadata(ImageFrame`1<TPixel> encodingFrame, Rectangle bounds, GifFrameMetadata metadata, bool useLocal, PaletteQuantizer`1<TPixel> globalPaletteQuantizer, bool hasDuplicates, int transparencyIndex);
    private static byte ClampIndex(int value);
    private static int GetTransparentIndex(IndexedImageFrame`1<TPixel> quantized, GifFrameMetadata metadata);
    [NullableContextAttribute("1")]
private static void WriteHeader(Stream stream);
    [NullableContextAttribute("1")]
private void WriteLogicalScreenDescriptor(ImageMetadata metadata, int width, int height, byte backgroundIndex, bool useGlobalTable, int bitDepth, Stream stream);
    [NullableContextAttribute("1")]
private void WriteApplicationExtensions(Stream stream, int frameCount, ushort repeatCount, XmpProfile xmpProfile);
    [NullableContextAttribute("1")]
private void WriteComments(GifMetadata metadata, Stream stream);
    private static void WriteCommentSubBlock(Stream stream, ReadOnlySpan`1<char> commentSpan, int idx, int length);
    [NullableContextAttribute("1")]
private void WriteGraphicalControlExtension(GifFrameMetadata metadata, Stream stream);
    private void WriteExtension(TGifExtension extension, Stream stream);
    [NullableContextAttribute("1")]
private void WriteImageDescriptor(Rectangle rectangle, bool hasColorTable, int bitDepth, Stream stream);
    private void WriteColorTable(IndexedImageFrame`1<TPixel> image, int bitDepth, Stream stream);
    [NullableContextAttribute("1")]
private void WriteImageData(Buffer2D`1<byte> indices, Stream stream, int paletteLength, int transparencyIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Gif.GifFormat : object {
    [CompilerGeneratedAttribute]
private static GifFormat <Instance>k__BackingField;
    public static GifFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static GifFormat();
    [CompilerGeneratedAttribute]
public static GifFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual GifMetadata CreateDefaultFormatMetadata();
    public sealed virtual GifFrameMetadata CreateDefaultFormatFrameMetadata();
}
public class SixLabors.ImageSharp.Formats.Gif.GifFrameMetadata : object {
    [CompilerGeneratedAttribute]
private GifColorTableMode <ColorTableMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<Color>> <LocalColorTable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTransparency>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <TransparencyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrameDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private GifDisposalMethod <DisposalMethod>k__BackingField;
    public GifColorTableMode ColorTableMode { get; public set; }
    public Nullable`1<ReadOnlyMemory`1<Color>> LocalColorTable { get; public set; }
    public bool HasTransparency { get; public set; }
    public byte TransparencyIndex { get; public set; }
    public int FrameDelay { get; public set; }
    public GifDisposalMethod DisposalMethod { get; public set; }
    [NullableContextAttribute("1")]
private GifFrameMetadata(GifFrameMetadata other);
    [CompilerGeneratedAttribute]
public GifColorTableMode get_ColorTableMode();
    [CompilerGeneratedAttribute]
public void set_ColorTableMode(GifColorTableMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<Color>> get_LocalColorTable();
    [CompilerGeneratedAttribute]
public void set_LocalColorTable(Nullable`1<ReadOnlyMemory`1<Color>> value);
    [CompilerGeneratedAttribute]
public bool get_HasTransparency();
    [CompilerGeneratedAttribute]
public void set_HasTransparency(bool value);
    [CompilerGeneratedAttribute]
public byte get_TransparencyIndex();
    [CompilerGeneratedAttribute]
public void set_TransparencyIndex(byte value);
    [CompilerGeneratedAttribute]
public int get_FrameDelay();
    [CompilerGeneratedAttribute]
public void set_FrameDelay(int value);
    [CompilerGeneratedAttribute]
public GifDisposalMethod get_DisposalMethod();
    [CompilerGeneratedAttribute]
public void set_DisposalMethod(GifDisposalMethod value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
    [NullableContextAttribute("1")]
internal static GifFrameMetadata FromAnimatedMetadata(AnimatedImageFrameMetadata metadata);
    private static GifDisposalMethod GetMode(FrameDisposalMode mode);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Gif.GifGraphicControlExtension : ValueType {
    [CompilerGeneratedAttribute]
private byte <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Packed>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DelayTime>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <TransparencyIndex>k__BackingField;
    public byte BlockSize { get; }
    public byte Packed { get; }
    public ushort DelayTime { get; }
    public byte TransparencyIndex { get; }
    public GifDisposalMethod DisposalMethod { get; }
    public bool TransparencyFlag { get; }
    private byte SixLabors.ImageSharp.Formats.Gif.IGifExtension.Label { get; }
    private int SixLabors.ImageSharp.Formats.Gif.IGifExtension.ContentLength { get; }
    public GifGraphicControlExtension(byte packed, ushort delayTime, byte transparencyIndex);
    [CompilerGeneratedAttribute]
public byte get_BlockSize();
    [CompilerGeneratedAttribute]
public byte get_Packed();
    [CompilerGeneratedAttribute]
public ushort get_DelayTime();
    [CompilerGeneratedAttribute]
public byte get_TransparencyIndex();
    public GifDisposalMethod get_DisposalMethod();
    public bool get_TransparencyFlag();
    private sealed virtual override byte SixLabors.ImageSharp.Formats.Gif.IGifExtension.get_Label();
    private sealed virtual override int SixLabors.ImageSharp.Formats.Gif.IGifExtension.get_ContentLength();
    public static bool op_Equality(GifGraphicControlExtension left, GifGraphicControlExtension right);
    public static bool op_Inequality(GifGraphicControlExtension left, GifGraphicControlExtension right);
    public sealed virtual int WriteTo(Span`1<byte> buffer);
    public static GifGraphicControlExtension Parse(ReadOnlySpan`1<byte> buffer);
    public static byte GetPackedValue(GifDisposalMethod disposalMethod, bool userInputFlag, bool transparencyFlag);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GifGraphicControlExtension other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Gif.GifImageDescriptor : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private ushort <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Packed>k__BackingField;
    public ushort Left { get; }
    public ushort Top { get; }
    public ushort Width { get; }
    public ushort Height { get; }
    public byte Packed { get; }
    public bool LocalColorTableFlag { get; }
    public int LocalColorTableSize { get; }
    public bool InterlaceFlag { get; }
    public GifImageDescriptor(ushort left, ushort top, ushort width, ushort height, byte packed);
    [CompilerGeneratedAttribute]
public ushort get_Left();
    [CompilerGeneratedAttribute]
public ushort get_Top();
    [CompilerGeneratedAttribute]
public ushort get_Width();
    [CompilerGeneratedAttribute]
public ushort get_Height();
    [CompilerGeneratedAttribute]
public byte get_Packed();
    public bool get_LocalColorTableFlag();
    public int get_LocalColorTableSize();
    public bool get_InterlaceFlag();
    public void WriteTo(Span`1<byte> buffer);
    public static GifImageDescriptor Parse(ReadOnlySpan`1<byte> buffer);
    public static byte GetPackedValue(bool localColorTableFlag, bool interfaceFlag, bool sortFlag, int localColorTableSize);
}
public class SixLabors.ImageSharp.Formats.Gif.GifImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Gif.GifLogicalScreenDescriptor : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private ushort <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Packed>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <BackgroundColorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <PixelAspectRatio>k__BackingField;
    public ushort Width { get; }
    public ushort Height { get; }
    public byte Packed { get; }
    public byte BackgroundColorIndex { get; }
    public byte PixelAspectRatio { get; }
    public bool GlobalColorTableFlag { get; }
    public int GlobalColorTableSize { get; }
    public int BitsPerPixel { get; }
    public GifLogicalScreenDescriptor(ushort width, ushort height, byte packed, byte backgroundColorIndex, byte pixelAspectRatio);
    [CompilerGeneratedAttribute]
public ushort get_Width();
    [CompilerGeneratedAttribute]
public ushort get_Height();
    [CompilerGeneratedAttribute]
public byte get_Packed();
    [CompilerGeneratedAttribute]
public byte get_BackgroundColorIndex();
    [CompilerGeneratedAttribute]
public byte get_PixelAspectRatio();
    public bool get_GlobalColorTableFlag();
    public int get_GlobalColorTableSize();
    public int get_BitsPerPixel();
    public void WriteTo(Span`1<byte> buffer);
    public static GifLogicalScreenDescriptor Parse(ReadOnlySpan`1<byte> buffer);
    public static byte GetPackedValue(bool globalColorTableFlag, int colorResolution, bool sortFlag, int globalColorTableSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Gif.GifMetadata : object {
    [CompilerGeneratedAttribute]
private ushort <RepeatCount>k__BackingField;
    [CompilerGeneratedAttribute]
private GifColorTableMode <ColorTableMode>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<Color>> <GlobalColorTable>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <BackgroundColorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Comments>k__BackingField;
    public ushort RepeatCount { get; public set; }
    public GifColorTableMode ColorTableMode { get; public set; }
    [NullableAttribute("0")]
public Nullable`1<ReadOnlyMemory`1<Color>> GlobalColorTable { get; public set; }
    public byte BackgroundColorIndex { get; public set; }
    public IList`1<string> Comments { get; public set; }
    private GifMetadata(GifMetadata other);
    [CompilerGeneratedAttribute]
public ushort get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(ushort value);
    [CompilerGeneratedAttribute]
public GifColorTableMode get_ColorTableMode();
    [CompilerGeneratedAttribute]
public void set_ColorTableMode(GifColorTableMode value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<Color>> get_GlobalColorTable();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_GlobalColorTable(Nullable`1<ReadOnlyMemory`1<Color>> value);
    [CompilerGeneratedAttribute]
public byte get_BackgroundColorIndex();
    [CompilerGeneratedAttribute]
public void set_BackgroundColorIndex(byte value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Comments();
    [CompilerGeneratedAttribute]
public void set_Comments(IList`1<string> value);
    public sealed virtual IDeepCloneable DeepClone();
    internal static GifMetadata FromAnimatedMetadata(AnimatedImageMetadata metadata);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Gif.GifNetscapeLoopingApplicationExtension : ValueType {
    [CompilerGeneratedAttribute]
private ushort <RepeatCount>k__BackingField;
    public byte Label { get; }
    public int ContentLength { get; }
    public ushort RepeatCount { get; }
    public GifNetscapeLoopingApplicationExtension(ushort repeatCount);
    public sealed virtual byte get_Label();
    public sealed virtual int get_ContentLength();
    [CompilerGeneratedAttribute]
public ushort get_RepeatCount();
    public static GifNetscapeLoopingApplicationExtension Parse(ReadOnlySpan`1<byte> buffer);
    public sealed virtual int WriteTo(Span`1<byte> buffer);
}
internal static class SixLabors.ImageSharp.Formats.Gif.GifThrowHelper : object {
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
public static void ThrowInvalidImageContentException(string errorMessage);
    [DoesNotReturnAttribute]
public static void ThrowNoHeader();
    [DoesNotReturnAttribute]
public static void ThrowNoData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Gif.GifXmpApplicationExtension : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public byte Label { get; }
    public int ContentLength { get; }
    public Byte[] Data { get; }
    public GifXmpApplicationExtension(Byte[] data);
    public sealed virtual byte get_Label();
    public sealed virtual int get_ContentLength();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    public static GifXmpApplicationExtension Read(Stream stream, MemoryAllocator allocator);
    [NullableContextAttribute("0")]
public sealed virtual int WriteTo(Span`1<byte> buffer);
    private static Byte[] ReadXmpData(Stream stream, MemoryAllocator allocator);
}
public interface SixLabors.ImageSharp.Formats.Gif.IGifExtension {
    public byte Label { get; }
    public int ContentLength { get; }
    public abstract virtual byte get_Label();
    public abstract virtual int get_ContentLength();
    public abstract virtual int WriteTo(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Gif.LzwDecoder : object {
    private static int MaxStackSize;
    private static int MaximumLzwBits;
    private static int NullCode;
    private BufferedReadStream stream;
    private IMemoryOwner`1<int> prefix;
    private IMemoryOwner`1<int> suffix;
    private IMemoryOwner`1<byte> scratchBuffer;
    private IMemoryOwner`1<int> pixelStack;
    private int minCodeSize;
    private int clearCode;
    private int endCode;
    private int code;
    private int codeSize;
    private int codeMask;
    private int availableCode;
    private int oldCode;
    private int bits;
    private int top;
    private int count;
    private int bufferIndex;
    private int data;
    private int first;
    public LzwDecoder(MemoryAllocator memoryAllocator, BufferedReadStream stream, int minCodeSize);
    public static bool IsValidMinCodeSize(int minCodeSize);
    [NullableContextAttribute("0")]
public void DecodePixelRow(Span`1<byte> indices);
    public void SkipIndices(int length);
    [NullableContextAttribute("0")]
private int ReadBlock(Span`1<byte> buffer);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Gif.LzwEncoder : object {
    private static int HashSize;
    private static int HashShift;
    private static Int32[] Masks;
    private static int MaxBits;
    private static int MaxMaxCode;
    private int initialCodeSize;
    private IMemoryOwner`1<int> hashTable;
    private IMemoryOwner`1<int> codeTable;
    private Byte[] accumulators;
    private int bitCount;
    private int maxCode;
    private int freeEntry;
    private bool clearFlag;
    private int globalInitialBits;
    private int clearCode;
    private int eofCode;
    private int currentAccumulator;
    private int currentBits;
    private int accumulatorCount;
    public LzwEncoder(MemoryAllocator memoryAllocator, int colorDepth);
    private static LzwEncoder();
    public void Encode(Buffer2D`1<byte> indexedPixels, Stream stream);
    private static int GetMaxCode(int bitCount);
    private void AddCharacter(byte c, Byte& accumulatorsRef, Stream stream);
    private void ClearBlock(Stream stream);
    private void ResetCodeTable();
    private void Compress(Buffer2D`1<byte> indexedPixels, int initialBits, Stream stream);
    private void FlushPacket(Stream outStream);
    private void Output(int code, Stream outs);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.IImageDecoder {
    public abstract virtual ImageInfo Identify(DecoderOptions options, Stream stream);
    public abstract virtual Task`1<ImageInfo> IdentifyAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream);
    public abstract virtual Image Decode(DecoderOptions options, Stream stream);
    public abstract virtual Task`1<Image`1<TPixel>> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<Image> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Formats.IImageDecoderInternals {
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public abstract virtual DecoderOptions get_Options();
    public abstract virtual Size get_Dimensions();
    [NullableContextAttribute("0")]
public abstract virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public abstract virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
}
public interface SixLabors.ImageSharp.Formats.IImageEncoder {
    public bool SkipMetadata { get; public set; }
    public abstract virtual bool get_SkipMetadata();
    public abstract virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkipMetadata(bool value);
    public abstract virtual void Encode(Image`1<TPixel> image, Stream stream);
    [NullableContextAttribute("1")]
public abstract virtual Task EncodeAsync(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal interface SixLabors.ImageSharp.Formats.IImageEncoderInternals {
    public abstract virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.IImageFormat {
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DefaultMimeType();
    public abstract virtual IEnumerable`1<string> get_MimeTypes();
    public abstract virtual IEnumerable`1<string> get_FileExtensions();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.IImageFormat`1 {
    public abstract virtual TFormatMetadata CreateDefaultFormatMetadata();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.IImageFormat`2 {
    public abstract virtual TFormatFrameMetadata CreateDefaultFormatFrameMetadata();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.IImageFormatConfigurationModule {
    public abstract virtual void Configure(Configuration configuration);
}
public interface SixLabors.ImageSharp.Formats.IImageFormatDetector {
    public int HeaderSize { get; }
    public abstract virtual int get_HeaderSize();
    public abstract virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Formats.ImageDecoder : object {
    public sealed virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream);
    public sealed virtual Image Decode(DecoderOptions options, Stream stream);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.ImageDecoder/<DecodeAsync>d__2`1")]
public sealed virtual Task`1<Image`1<TPixel>> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.ImageDecoder/<DecodeAsync>d__3")]
public sealed virtual Task`1<Image> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(DecoderOptions options, Stream stream);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.ImageDecoder/<IdentifyAsync>d__5")]
public sealed virtual Task`1<ImageInfo> IdentifyAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected static void ScaleToTargetSize(DecoderOptions options, Image image);
    private static bool ShouldResize(DecoderOptions options, Image image);
    internal static T WithSeekableStream(DecoderOptions options, Stream stream, Func`2<Stream, T> action);
    internal static Task`1<T> WithSeekableMemoryStreamAsync(DecoderOptions options, Stream stream, Func`3<Stream, CancellationToken, T> action, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.ImageDecoder/<CopyToMemoryStreamAndActionAsync>d__13`1")]
private static Task`1<T> CopyToMemoryStreamAndActionAsync(DecoderOptions options, Stream stream, Func`4<Stream, long, CancellationToken, Task`1<T>> action, CancellationToken cancellationToken);
    internal void SetDecoderFormat(Configuration configuration, Image image);
    internal void SetDecoderFormat(Configuration configuration, ImageInfo info);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <WithSeekableStream>g__PeformActionAndResetPosition|11_0(Stream s, long position, <>c__DisplayClass11_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Formats.ImageDecoderUtilities : object {
    [ExtensionAttribute]
internal static ImageInfo Identify(IImageDecoderInternals decoder, Configuration configuration, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Image`1<TPixel> Decode(IImageDecoderInternals decoder, Configuration configuration, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Image`1<TPixel> Decode(IImageDecoderInternals decoder, Configuration configuration, Stream stream, Func`3<InvalidMemoryOperationException, Size, InvalidImageContentException> largeImageExceptionFactory, CancellationToken cancellationToken);
    private static InvalidImageContentException DefaultLargeImageExceptionFactory(InvalidMemoryOperationException memoryOperationException, Size dimensions);
}
public abstract class SixLabors.ImageSharp.Formats.ImageEncoder : object {
    [CompilerGeneratedAttribute]
private bool <SkipMetadata>k__BackingField;
    public bool SkipMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkipMetadata(bool value);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream);
    [NullableContextAttribute("1")]
public sealed virtual Task EncodeAsync(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private void EncodeWithSeekableStream(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.ImageEncoder/<EncodeWithSeekableStreamAsync>d__8`1")]
private Task EncodeWithSeekableStreamAsync(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Task <EncodeWithSeekableStreamAsync>g__DoEncodeAsync|8_0(Stream innerStream, <>c__DisplayClass8_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.ImageFormatManager : object {
    private static object HashLock;
    private ConcurrentDictionary`2<IImageFormat, IImageEncoder> mimeTypeEncoders;
    private ConcurrentDictionary`2<IImageFormat, IImageDecoder> mimeTypeDecoders;
    private HashSet`1<IImageFormat> imageFormats;
    private ConcurrentBag`1<IImageFormatDetector> imageFormatDetectors;
    [CompilerGeneratedAttribute]
private int <MaxHeaderSize>k__BackingField;
    internal int MaxHeaderSize { get; private set; }
    public IEnumerable`1<IImageFormat> ImageFormats { get; }
    internal IEnumerable`1<IImageFormatDetector> FormatDetectors { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IEnumerable`1<KeyValuePair`2<IImageFormat, IImageDecoder>> ImageDecoders { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IEnumerable`1<KeyValuePair`2<IImageFormat, IImageEncoder>> ImageEncoders { get; }
    private static ImageFormatManager();
    [CompilerGeneratedAttribute]
internal int get_MaxHeaderSize();
    [CompilerGeneratedAttribute]
private void set_MaxHeaderSize(int value);
    public IEnumerable`1<IImageFormat> get_ImageFormats();
    internal IEnumerable`1<IImageFormatDetector> get_FormatDetectors();
    internal IEnumerable`1<KeyValuePair`2<IImageFormat, IImageDecoder>> get_ImageDecoders();
    internal IEnumerable`1<KeyValuePair`2<IImageFormat, IImageEncoder>> get_ImageEncoders();
    public void AddImageFormat(IImageFormat format);
    public bool TryFindFormatByFileExtension(string extension, IImageFormat& format);
    public bool TryFindFormatByMimeType(string mimeType, IImageFormat& format);
    internal bool TryFindFormatByDecoder(IImageDecoder decoder, IImageFormat& format);
    public void SetEncoder(IImageFormat imageFormat, IImageEncoder encoder);
    public void SetDecoder(IImageFormat imageFormat, IImageDecoder decoder);
    public void ClearImageFormatDetectors();
    public void AddImageFormatDetector(IImageFormatDetector detector);
    public IImageDecoder GetDecoder(IImageFormat format);
    public IImageEncoder GetEncoder(IImageFormat format);
    private void SetMaxHeaderSize();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidDecoder(ImageFormatManager manager);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.ISpecializedDecoderOptions {
    public DecoderOptions GeneralOptions { get; public set; }
    public abstract virtual DecoderOptions get_GeneralOptions();
    public abstract virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GeneralOptions(DecoderOptions value);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Formats.ISpecializedImageDecoder`1 {
    public abstract virtual Image`1<TPixel> Decode(T options, Stream stream);
    public abstract virtual Image Decode(T options, Stream stream);
    public abstract virtual Task`1<Image`1<TPixel>> DecodeAsync(T options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<Image> DecodeAsync(T options, Stream stream, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Block8x8 : ValueType {
    public static int Size;
    public Vector128`1<short> V0;
    public Vector128`1<short> V1;
    public Vector128`1<short> V2;
    public Vector128`1<short> V3;
    public Vector128`1<short> V4;
    public Vector128`1<short> V5;
    public Vector128`1<short> V6;
    public Vector128`1<short> V7;
    public Vector256`1<short> V01;
    public Vector256`1<short> V23;
    public Vector256`1<short> V45;
    public Vector256`1<short> V67;
    public short Item { get; public set; }
    public short Item { get; public set; }
    public short get_Item(int idx);
    public void set_Item(int idx, short value);
    public short get_Item(int x, int y);
    public void set_Item(int x, int y, short value);
    public static Block8x8 Load(Span`1<short> data);
    public Block8x8F AsFloatBlock();
    [NullableContextAttribute("1")]
public Int16[] ToArray();
    public void CopyTo(Span`1<short> destination);
    public void CopyTo(Span`1<int> destination);
    public static Block8x8 Load(ReadOnlySpan`1<byte> data);
    public void LoadFrom(ReadOnlySpan`1<byte> source);
    public void LoadFrom(Span`1<int> source);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public IntPtr GetLastNonZeroIndex();
    public void TransposeInplace();
    public static long TotalDifference(Block8x8& a, Block8x8& b);
}
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Block8x8F : ValueType {
    public static int Size;
    public Vector4 V0L;
    public Vector4 V0R;
    public Vector4 V1L;
    public Vector4 V1R;
    public Vector4 V2L;
    public Vector4 V2R;
    public Vector4 V3L;
    public Vector4 V3R;
    public Vector4 V4L;
    public Vector4 V4R;
    public Vector4 V5L;
    public Vector4 V5R;
    public Vector4 V6L;
    public Vector4 V6R;
    public Vector4 V7L;
    public Vector4 V7R;
    public static int RowCount;
    public Vector256`1<float> V0;
    public Vector256`1<float> V1;
    public Vector256`1<float> V2;
    public Vector256`1<float> V3;
    public Vector256`1<float> V4;
    public Vector256`1<float> V5;
    public Vector256`1<float> V6;
    public Vector256`1<float> V7;
    public float Item { get; public set; }
    internal float Item { get; internal set; }
    public float Item { get; public set; }
    public float get_Item(int idx);
    public void set_Item(int idx, float value);
    internal float get_Item(UIntPtr idx);
    internal void set_Item(UIntPtr idx, float value);
    public float get_Item(int x, int y);
    public void set_Item(int x, int y, float value);
    public static Block8x8F Load(Span`1<float> data);
    public void LoadFrom(Span`1<int> source);
    [NullableContextAttribute("1")]
public void ScaledCopyTo(Single[] dest);
    [NullableContextAttribute("1")]
public Single[] ToArray();
    public void MultiplyInPlace(float value);
    public void MultiplyInPlace(Block8x8F& other);
    public void AddInPlace(float value);
    public static void Quantize(Block8x8F& block, Block8x8& dest, Block8x8F& qt);
    public void RoundInto(Block8x8& dest);
    public Block8x8 RoundAsInt16Block();
    public void NormalizeColorsAndRoundInPlace(float maximum);
    public void DE_NormalizeColors(float maximum);
    public void RoundInPlace();
    public void LoadFrom(Block8x8& source);
    public void LoadFromInt16ExtendedAvx2(Block8x8& source);
    public bool EqualsToScalar(int value);
    public sealed virtual bool Equals(Block8x8F other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void TransposeInplace();
    private void TransposeInplace_Scalar();
    private static Vector`1<float> NormalizeAndRound(Vector`1<float> row, Vector`1<float> off, Vector`1<float> max);
    public void NormalizeColorsInPlace(float maximum);
    public void NormalizeColorsAndRoundInPlaceVector8(float maximum);
    public void LoadFromInt16Scalar(Block8x8& source);
    private static void MultiplyIntoInt16_Avx2(Block8x8F& a, Block8x8F& b, Block8x8& dest);
    private static void MultiplyIntoInt16_Sse2(Block8x8F& a, Block8x8F& b, Block8x8& dest);
    private void TransposeInplace_Avx();
    public void ScaledCopyFrom(Single& areaOrigin, int areaStride);
    public void ScaledCopyTo(Single& areaOrigin, int areaStride, int horizontalScale, int verticalScale);
    private void CopyTo2x2Scale(Single& areaOrigin, int areaStride);
    private void CopyArbitraryScale(Single& areaOrigin, UInt32 areaStride, UInt32 horizontalScale, UInt32 verticalScale);
    private static void CopyTo1x1Scale(Byte& origin, Byte& dest, int areaStride);
    private static void CopyFrom1x1Scale(Byte& origin, Byte& dest, int areaStride);
    [CompilerGeneratedAttribute]
internal static void <CopyTo2x2Scale>g__WidenCopyRowImpl2x2|66_0(Vector4& selfBase, Vector2& destBase, UIntPtr row, UIntPtr destStride);
    [CompilerGeneratedAttribute]
internal static void <CopyTo1x1Scale>g__CopyRowImpl|68_0(Byte& origin, Byte& dest, int destStride, int row);
    [CompilerGeneratedAttribute]
internal static void <CopyFrom1x1Scale>g__CopyRowImpl|69_0(Byte& origin, Byte& dest, int sourceStride, int row);
}
internal enum SixLabors.ImageSharp.Formats.Jpeg.Components.ComponentType : Enum {
    public int value__;
    public static ComponentType Huffman;
    public static ComponentType Arithmetic;
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.AdobeMarker : ValueType {
    public static int Length;
    [CompilerGeneratedAttribute]
private short <DCTEncodeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private short <APP14Flags0>k__BackingField;
    [CompilerGeneratedAttribute]
private short <APP14Flags1>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ColorTransform>k__BackingField;
    public short DCTEncodeVersion { get; }
    public short APP14Flags0 { get; }
    public short APP14Flags1 { get; }
    public byte ColorTransform { get; }
    private AdobeMarker(short dctEncodeVersion, short app14Flags0, short app14Flags1, byte colorTransform);
    [CompilerGeneratedAttribute]
public short get_DCTEncodeVersion();
    [CompilerGeneratedAttribute]
public short get_APP14Flags0();
    [CompilerGeneratedAttribute]
public short get_APP14Flags1();
    [CompilerGeneratedAttribute]
public byte get_ColorTransform();
    public static bool TryParse(ReadOnlySpan`1<byte> bytes, AdobeMarker& marker);
    public sealed virtual bool Equals(AdobeMarker other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ArithmeticDecodingComponent : JpegComponent {
    [CompilerGeneratedAttribute]
private int <DcContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ArithmeticStatistics <DcStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private ArithmeticStatistics <AcStatistics>k__BackingField;
    public int DcContext { get; public set; }
    public ArithmeticStatistics DcStatistics { get; public set; }
    public ArithmeticStatistics AcStatistics { get; public set; }
    public ArithmeticDecodingComponent(MemoryAllocator memoryAllocator, JpegFrame frame, byte id, int horizontalFactor, int verticalFactor, byte quantizationTableIndex, int index);
    [CompilerGeneratedAttribute]
public int get_DcContext();
    [CompilerGeneratedAttribute]
public void set_DcContext(int value);
    [CompilerGeneratedAttribute]
public ArithmeticStatistics get_DcStatistics();
    [CompilerGeneratedAttribute]
public void set_DcStatistics(ArithmeticStatistics value);
    [CompilerGeneratedAttribute]
public ArithmeticStatistics get_AcStatistics();
    [CompilerGeneratedAttribute]
public void set_AcStatistics(ArithmeticStatistics value);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ArithmeticDecodingTable : object {
    [CompilerGeneratedAttribute]
private byte <TableClass>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ConditioningTableValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcL>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcU>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AcKx>k__BackingField;
    public byte TableClass { get; }
    public byte Identifier { get; }
    public byte ConditioningTableValue { get; private set; }
    public int DcL { get; private set; }
    public int DcU { get; private set; }
    public int AcKx { get; private set; }
    public ArithmeticDecodingTable(byte tableClass, byte identifier);
    [CompilerGeneratedAttribute]
public byte get_TableClass();
    [CompilerGeneratedAttribute]
public byte get_Identifier();
    [CompilerGeneratedAttribute]
public byte get_ConditioningTableValue();
    [CompilerGeneratedAttribute]
private void set_ConditioningTableValue(byte value);
    [CompilerGeneratedAttribute]
public int get_DcL();
    [CompilerGeneratedAttribute]
private void set_DcL(int value);
    [CompilerGeneratedAttribute]
public int get_DcU();
    [CompilerGeneratedAttribute]
private void set_DcU(int value);
    [CompilerGeneratedAttribute]
public int get_AcKx();
    [CompilerGeneratedAttribute]
private void set_AcKx(int value);
    public void Configure(byte conditioningTableValue);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ArithmeticScanDecoder : object {
    private BufferedReadStream stream;
    private int c;
    private int a;
    private int ct;
    private JpegFrame frame;
    private IJpegComponent[] components;
    private int scanComponentCount;
    private int restartInterval;
    private int todo;
    private SpectralConverter spectralConverter;
    private JpegBitReader scanBuffer;
    private ArithmeticDecodingTable[] dcDecodingTables;
    private ArithmeticDecodingTable[] acDecodingTables;
    private Byte[] fixedBin;
    private CancellationToken cancellationToken;
    private static Int32[] ArithmeticTable;
    private List`1<ArithmeticStatistics> statistics;
    [CompilerGeneratedAttribute]
private int <SpectralStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpectralEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuccessiveHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuccessiveLow>k__BackingField;
    unknown int ResetInterval {public set; }
    public int SpectralStart { get; public set; }
    public int SpectralEnd { get; public set; }
    public int SuccessiveHigh { get; public set; }
    public int SuccessiveLow { get; public set; }
    public ArithmeticScanDecoder(BufferedReadStream stream, SpectralConverter converter, CancellationToken cancellationToken);
    private static ArithmeticScanDecoder();
    public sealed virtual void set_ResetInterval(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SpectralStart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SpectralStart(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SpectralEnd();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SpectralEnd(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuccessiveHigh();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuccessiveHigh(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuccessiveLow();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuccessiveLow(int value);
    public void InitDecodingTables(List`1<ArithmeticDecodingTable> arithmeticDecodingTables);
    private Byte& GetFixedBinReference();
    public sealed virtual void ParseEntropyCodedData(int scanComponentCount);
    public sealed virtual void InjectFrameData(JpegFrame frame, IRawJpegData jpegData);
    private static ArithmeticDecodingTable GetArithmeticTable(List`1<ArithmeticDecodingTable> arithmeticDecodingTables, bool isDcTable, int identifier);
    private ArithmeticStatistics CreateOrGetStatisticsBin(bool dc, int identifier, bool reset);
    private void ParseBaselineData();
    private void ParseProgressiveData();
    private void CheckProgressiveData();
    private void ParseBaselineDataInterleaved();
    private void ParseBaselineDataSingleComponent();
    private void ParseBaselineDataNonInterleaved();
    private void ParseProgressiveDataInterleaved();
    private void ParseProgressiveDataNonInterleaved();
    private void DecodeBlockProgressiveDc(ArithmeticDecodingComponent component, Block8x8& block, ArithmeticDecodingTable& dcTable);
    private void DecodeBlockProgressiveAc(ArithmeticDecodingComponent component, Block8x8& block, ArithmeticDecodingTable& acTable);
    private void ReadBlockProgressiveAcRefined(ArithmeticStatistics acStatistics, Int16& blockDataRef);
    private void DecodeBlockBaseline(ArithmeticDecodingComponent component, Block8x8& destinationBlock, ArithmeticDecodingTable& acTable, ArithmeticDecodingTable& dcTable);
    private bool HandleRestart();
    private void Reset();
    private int DecodeBinaryDecision(JpegBitReader& reader, Byte& st);
    private static int Pack(int a, int b, int c, int d);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ArithmeticStatistics : object {
    [NullableAttribute("1")]
private Byte[] statistics;
    [CompilerGeneratedAttribute]
private bool <IsDcStatistics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Identifier>k__BackingField;
    public bool IsDcStatistics { get; private set; }
    public int Identifier { get; private set; }
    public ArithmeticStatistics(bool dc, int identifier);
    [CompilerGeneratedAttribute]
public bool get_IsDcStatistics();
    [CompilerGeneratedAttribute]
private void set_IsDcStatistics(bool value);
    [CompilerGeneratedAttribute]
public int get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(int value);
    public Byte& GetReference();
    public Byte& GetReference(int offset);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ComponentProcessor : object {
    [CompilerGeneratedAttribute]
private JpegFrame <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private IJpegComponent <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private Buffer2D`1<float> <ColorBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <BlockAreaSize>k__BackingField;
    protected JpegFrame Frame { get; }
    protected IJpegComponent Component { get; }
    protected Buffer2D`1<float> ColorBuffer { get; }
    protected Size BlockAreaSize { get; }
    public ComponentProcessor(MemoryAllocator memoryAllocator, JpegFrame frame, Size postProcessorBufferSize, IJpegComponent component, int blockSize);
    [CompilerGeneratedAttribute]
protected JpegFrame get_Frame();
    [CompilerGeneratedAttribute]
protected IJpegComponent get_Component();
    [CompilerGeneratedAttribute]
protected Buffer2D`1<float> get_ColorBuffer();
    [CompilerGeneratedAttribute]
protected Size get_BlockAreaSize();
    public abstract virtual void CopyBlocksToColorBuffer(int row);
    public void ClearSpectralBuffers();
    [NullableContextAttribute("0")]
public Span`1<float> GetColorBufferRowSpan(int row);
    public sealed virtual void Dispose();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.DirectComponentProcessor : ComponentProcessor {
    private Block8x8F dequantizationTable;
    [NullableContextAttribute("1")]
public DirectComponentProcessor(MemoryAllocator memoryAllocator, JpegFrame frame, IRawJpegData rawJpeg, Size postProcessorBufferSize, IJpegComponent component);
    public virtual void CopyBlocksToColorBuffer(int spectralStep);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.DownScalingComponentProcessor2 : ComponentProcessor {
    private Block8x8F dequantizationTable;
    [NullableContextAttribute("1")]
public DownScalingComponentProcessor2(MemoryAllocator memoryAllocator, JpegFrame frame, IRawJpegData rawJpeg, Size postProcessorBufferSize, IJpegComponent component);
    public virtual void CopyBlocksToColorBuffer(int spectralStep);
    public static void ScaledCopyTo(Block8x8F& block, Single& destRef, int destStrideWidth, int horizontalScale, int verticalScale);
    [CompilerGeneratedAttribute]
internal static void <ScaledCopyTo>g__CopyArbitraryScale|3_0(Block8x8F& block, Single& areaOrigin, UInt32 areaStride, UInt32 horizontalScale, UInt32 verticalScale);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.DownScalingComponentProcessor4 : ComponentProcessor {
    private Block8x8F dequantizationTable;
    [NullableContextAttribute("1")]
public DownScalingComponentProcessor4(MemoryAllocator memoryAllocator, JpegFrame frame, IRawJpegData rawJpeg, Size postProcessorBufferSize, IJpegComponent component);
    public virtual void CopyBlocksToColorBuffer(int spectralStep);
    public static void ScaledCopyTo(Block8x8F& block, Single& destRef, int destStrideWidth, int horizontalScale, int verticalScale);
    [CompilerGeneratedAttribute]
internal static void <ScaledCopyTo>g__CopyArbitraryScale|3_0(Block8x8F& block, Single& areaOrigin, UInt32 areaStride, UInt32 horizontalScale, UInt32 verticalScale);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.DownScalingComponentProcessor8 : ComponentProcessor {
    private float dcDequantizatizer;
    [NullableContextAttribute("1")]
public DownScalingComponentProcessor8(MemoryAllocator memoryAllocator, JpegFrame frame, IRawJpegData rawJpeg, Size postProcessorBufferSize, IJpegComponent component);
    public virtual void CopyBlocksToColorBuffer(int spectralStep);
    public static void ScaledCopyTo(float value, Single& destRef, int destStrideWidth, int horizontalScale, int verticalScale);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.HuffmanScanDecoder : object {
    private BufferedReadStream stream;
    private JpegFrame frame;
    private IJpegComponent[] components;
    private int scanComponentCount;
    private int restartInterval;
    private int todo;
    private int eobrun;
    private HuffmanTable[] dcHuffmanTables;
    private HuffmanTable[] acHuffmanTables;
    private JpegBitReader scanBuffer;
    private SpectralConverter spectralConverter;
    private CancellationToken cancellationToken;
    [CompilerGeneratedAttribute]
private int <SpectralStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpectralEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuccessiveHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuccessiveLow>k__BackingField;
    unknown int ResetInterval {public set; }
    public int SpectralStart { get; public set; }
    public int SpectralEnd { get; public set; }
    public int SuccessiveHigh { get; public set; }
    public int SuccessiveLow { get; public set; }
    public HuffmanScanDecoder(BufferedReadStream stream, SpectralConverter converter, CancellationToken cancellationToken);
    public sealed virtual void set_ResetInterval(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SpectralStart();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SpectralStart(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SpectralEnd();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SpectralEnd(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuccessiveHigh();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuccessiveHigh(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SuccessiveLow();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SuccessiveLow(int value);
    public sealed virtual void ParseEntropyCodedData(int scanComponentCount);
    public sealed virtual void InjectFrameData(JpegFrame frame, IRawJpegData jpegData);
    private void ParseBaselineData();
    private void ParseBaselineDataInterleaved();
    private void ParseBaselineDataNonInterleaved();
    private void ParseBaselineDataSingleComponent();
    private void CheckProgressiveData();
    private void ParseProgressiveData();
    private void ParseProgressiveDataInterleaved();
    private void ParseProgressiveDataNonInterleaved();
    private void DecodeBlockBaseline(JpegComponent component, Block8x8& block, HuffmanTable& dcTable, HuffmanTable& acTable);
    private void DecodeBlockProgressiveDC(JpegComponent component, Block8x8& block, HuffmanTable& dcTable);
    private void DecodeBlockProgressiveAC(Block8x8& block, HuffmanTable& acTable);
    private void DecodeBlockProgressiveACRefined(Int16& blockDataRef, HuffmanTable& acTable);
    private void Reset();
    private bool HandleRestart();
    public void BuildHuffmanTable(int type, int index, ReadOnlySpan`1<byte> codeLengths, ReadOnlySpan`1<byte> values, Span`1<UInt32> workspace);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.HuffmanTable : ValueType {
    public static int WorkspaceByteSize;
    [FixedBufferAttribute("System.Byte", "256")]
public <Values>e__FixedBuffer Values;
    [FixedBufferAttribute("System.UInt64", "18")]
public <MaxCode>e__FixedBuffer MaxCode;
    [FixedBufferAttribute("System.Int32", "19")]
public <ValOffset>e__FixedBuffer ValOffset;
    [FixedBufferAttribute("System.Byte", "256")]
public <LookaheadSize>e__FixedBuffer LookaheadSize;
    [FixedBufferAttribute("System.Byte", "256")]
public <LookaheadValue>e__FixedBuffer LookaheadValue;
    public HuffmanTable(ReadOnlySpan`1<byte> codeLengths, ReadOnlySpan`1<byte> values, Span`1<UInt32> workspace);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.IJpegComponent {
    public byte Id { get; }
    public int Index { get; }
    public Size SizeInBlocks { get; }
    public Size SamplingFactors { get; }
    public int HorizontalSamplingFactor { get; }
    public int VerticalSamplingFactor { get; }
    public Size SubSamplingDivisors { get; }
    public int QuantizationTableIndex { get; }
    public Buffer2D`1<Block8x8> SpectralBlocks { get; }
    public int DcPredictor { get; public set; }
    public int DcTableId { get; public set; }
    public int AcTableId { get; public set; }
    public abstract virtual byte get_Id();
    public abstract virtual int get_Index();
    public abstract virtual Size get_SizeInBlocks();
    public abstract virtual Size get_SamplingFactors();
    public abstract virtual int get_HorizontalSamplingFactor();
    public abstract virtual int get_VerticalSamplingFactor();
    public abstract virtual Size get_SubSamplingDivisors();
    public abstract virtual int get_QuantizationTableIndex();
    public abstract virtual Buffer2D`1<Block8x8> get_SpectralBlocks();
    public abstract virtual int get_DcPredictor();
    public abstract virtual void set_DcPredictor(int value);
    public abstract virtual int get_DcTableId();
    public abstract virtual void set_DcTableId(int value);
    public abstract virtual int get_AcTableId();
    public abstract virtual void set_AcTableId(int value);
    public abstract virtual void Init(int maxSubFactorH, int maxSubFactorV);
    public abstract virtual void AllocateSpectral(bool fullScan);
    public abstract virtual void Dispose();
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.IJpegScanDecoder {
    unknown int ResetInterval {public set; }
    public int SpectralStart { get; public set; }
    public int SpectralEnd { get; public set; }
    public int SuccessiveHigh { get; public set; }
    public int SuccessiveLow { get; public set; }
    public abstract virtual void set_ResetInterval(int value);
    public abstract virtual int get_SpectralStart();
    public abstract virtual void set_SpectralStart(int value);
    public abstract virtual int get_SpectralEnd();
    public abstract virtual void set_SpectralEnd(int value);
    public abstract virtual int get_SuccessiveHigh();
    public abstract virtual void set_SuccessiveHigh(int value);
    public abstract virtual int get_SuccessiveLow();
    public abstract virtual void set_SuccessiveLow(int value);
    public abstract virtual void ParseEntropyCodedData(int scanComponentCount);
    public abstract virtual void InjectFrameData(JpegFrame frame, IRawJpegData jpegData);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.IRawJpegData {
    public JpegColorSpace ColorSpace { get; }
    public JpegComponent[] Components { get; }
    public Block8x8F[] QuantizationTables { get; }
    public abstract virtual JpegColorSpace get_ColorSpace();
    public abstract virtual JpegComponent[] get_Components();
    public abstract virtual Block8x8F[] get_QuantizationTables();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.JFifMarker : ValueType {
    public static int Length;
    [CompilerGeneratedAttribute]
private byte <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelResolutionUnit <DensityUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private short <XDensity>k__BackingField;
    [CompilerGeneratedAttribute]
private short <YDensity>k__BackingField;
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public PixelResolutionUnit DensityUnits { get; }
    public short XDensity { get; }
    public short YDensity { get; }
    private JFifMarker(byte majorVersion, byte minorVersion, byte densityUnits, short xDensity, short yDensity);
    [CompilerGeneratedAttribute]
public byte get_MajorVersion();
    [CompilerGeneratedAttribute]
public byte get_MinorVersion();
    [CompilerGeneratedAttribute]
public PixelResolutionUnit get_DensityUnits();
    [CompilerGeneratedAttribute]
public short get_XDensity();
    [CompilerGeneratedAttribute]
public short get_YDensity();
    public static bool TryParse(ReadOnlySpan`1<byte> bytes, JFifMarker& marker);
    public sealed virtual bool Equals(JFifMarker other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.JpegBitReader : ValueType {
    private BufferedReadStream stream;
    private ulong data;
    private int remainingBits;
    private bool badData;
    private int eofHitCount;
    [CompilerGeneratedAttribute]
private byte <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MarkerPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoData>k__BackingField;
    public byte Marker { get; private set; }
    public long MarkerPosition { get; private set; }
    public bool NoData { get; private set; }
    public JpegBitReader(BufferedReadStream stream);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public byte get_Marker();
    [CompilerGeneratedAttribute]
private void set_Marker(byte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_MarkerPosition();
    [CompilerGeneratedAttribute]
private void set_MarkerPosition(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_NoData();
    [CompilerGeneratedAttribute]
private void set_NoData(bool value);
    public void CheckBits();
    public void Reset();
    public bool HasRestartMarker();
    public bool HasBadMarker();
    public void FillBuffer();
    public int DecodeHuffman(HuffmanTable& h);
    public int Receive(int nbits);
    private static bool HasRestart(byte marker);
    public int GetBits(int nbits);
    public int PeekBits(int nbits);
    private static ulong ExtractBits(ulong value, int offset, int size);
    private static int Extend(int v, int nbits);
    private ulong GetBytes();
    public bool FindNextMarker();
    private int ReadStream();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.JpegComponent : object {
    private MemoryAllocator memoryAllocator;
    [CompilerGeneratedAttribute]
private byte <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcPredictor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HorizontalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VerticalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Buffer2D`1<Block8x8> <SpectralBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SubSamplingDivisors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuantizationTableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SizeInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SamplingFactors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WidthInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeightInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcTableId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AcTableId>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegFrame <Frame>k__BackingField;
    public byte Id { get; }
    public int DcPredictor { get; public set; }
    public int HorizontalSamplingFactor { get; }
    public int VerticalSamplingFactor { get; }
    public Buffer2D`1<Block8x8> SpectralBlocks { get; private set; }
    public Size SubSamplingDivisors { get; private set; }
    public int QuantizationTableIndex { get; }
    public int Index { get; }
    public Size SizeInBlocks { get; private set; }
    public Size SamplingFactors { get; public set; }
    public int WidthInBlocks { get; private set; }
    public int HeightInBlocks { get; private set; }
    public int DcTableId { get; public set; }
    public int AcTableId { get; public set; }
    public JpegFrame Frame { get; }
    public JpegComponent(MemoryAllocator memoryAllocator, JpegFrame frame, byte id, int horizontalFactor, int verticalFactor, byte quantizationTableIndex, int index);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual int get_DcPredictor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DcPredictor(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_HorizontalSamplingFactor();
    [CompilerGeneratedAttribute]
public sealed virtual int get_VerticalSamplingFactor();
    [CompilerGeneratedAttribute]
public sealed virtual Buffer2D`1<Block8x8> get_SpectralBlocks();
    [CompilerGeneratedAttribute]
private void set_SpectralBlocks(Buffer2D`1<Block8x8> value);
    [CompilerGeneratedAttribute]
public sealed virtual Size get_SubSamplingDivisors();
    [CompilerGeneratedAttribute]
private void set_SubSamplingDivisors(Size value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_QuantizationTableIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual Size get_SizeInBlocks();
    [CompilerGeneratedAttribute]
private void set_SizeInBlocks(Size value);
    [CompilerGeneratedAttribute]
public sealed virtual Size get_SamplingFactors();
    [CompilerGeneratedAttribute]
public void set_SamplingFactors(Size value);
    [CompilerGeneratedAttribute]
public int get_WidthInBlocks();
    [CompilerGeneratedAttribute]
private void set_WidthInBlocks(int value);
    [CompilerGeneratedAttribute]
public int get_HeightInBlocks();
    [CompilerGeneratedAttribute]
private void set_HeightInBlocks(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DcTableId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DcTableId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_AcTableId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AcTableId(int value);
    [CompilerGeneratedAttribute]
public JpegFrame get_Frame();
    public sealed virtual void Dispose();
    public sealed virtual void Init(int maxSubFactorH, int maxSubFactorV);
    public sealed virtual void AllocateSpectral(bool fullScan);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.JpegFileMarker : ValueType {
    [CompilerGeneratedAttribute]
private bool <Invalid>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool Invalid { get; }
    public byte Marker { get; }
    public long Position { get; }
    public JpegFileMarker(byte marker, long position);
    public JpegFileMarker(byte marker, long position, bool invalid);
    [CompilerGeneratedAttribute]
public bool get_Invalid();
    [CompilerGeneratedAttribute]
public byte get_Marker();
    [CompilerGeneratedAttribute]
public long get_Position();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.JpegFrame : object {
    [CompilerGeneratedAttribute]
private bool <IsExtended>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Progressive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Interleaved>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MaxColorChannelValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PixelHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PixelWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ComponentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ComponentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ComponentOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegComponent[] <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private int <McusPerLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <McusPerColumn>k__BackingField;
    public bool IsExtended { get; private set; }
    public bool Progressive { get; private set; }
    public bool Interleaved { get; public set; }
    public byte Precision { get; private set; }
    public float MaxColorChannelValue { get; private set; }
    public int PixelHeight { get; private set; }
    public int PixelWidth { get; private set; }
    public Size PixelSize { get; }
    public byte ComponentCount { get; private set; }
    public Byte[] ComponentIds { get; public set; }
    public Byte[] ComponentOrder { get; public set; }
    public JpegComponent[] Components { get; public set; }
    public int McusPerLine { get; public set; }
    public int McusPerColumn { get; public set; }
    public Size McuSize { get; }
    public int BitsPerPixel { get; }
    public JpegFrame(JpegFileMarker sofMarker, byte precision, int width, int height, byte componentCount);
    [CompilerGeneratedAttribute]
public bool get_IsExtended();
    [CompilerGeneratedAttribute]
private void set_IsExtended(bool value);
    [CompilerGeneratedAttribute]
public bool get_Progressive();
    [CompilerGeneratedAttribute]
private void set_Progressive(bool value);
    [CompilerGeneratedAttribute]
public bool get_Interleaved();
    [CompilerGeneratedAttribute]
public void set_Interleaved(bool value);
    [CompilerGeneratedAttribute]
public byte get_Precision();
    [CompilerGeneratedAttribute]
private void set_Precision(byte value);
    [CompilerGeneratedAttribute]
public float get_MaxColorChannelValue();
    [CompilerGeneratedAttribute]
private void set_MaxColorChannelValue(float value);
    [CompilerGeneratedAttribute]
public int get_PixelHeight();
    [CompilerGeneratedAttribute]
private void set_PixelHeight(int value);
    [CompilerGeneratedAttribute]
public int get_PixelWidth();
    [CompilerGeneratedAttribute]
private void set_PixelWidth(int value);
    public Size get_PixelSize();
    [CompilerGeneratedAttribute]
public byte get_ComponentCount();
    [CompilerGeneratedAttribute]
private void set_ComponentCount(byte value);
    [CompilerGeneratedAttribute]
public Byte[] get_ComponentIds();
    [CompilerGeneratedAttribute]
public void set_ComponentIds(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ComponentOrder();
    [CompilerGeneratedAttribute]
public void set_ComponentOrder(Byte[] value);
    [CompilerGeneratedAttribute]
public JpegComponent[] get_Components();
    [CompilerGeneratedAttribute]
public void set_Components(JpegComponent[] value);
    [CompilerGeneratedAttribute]
public int get_McusPerLine();
    [CompilerGeneratedAttribute]
public void set_McusPerLine(int value);
    [CompilerGeneratedAttribute]
public int get_McusPerColumn();
    [CompilerGeneratedAttribute]
public void set_McusPerColumn(int value);
    public Size get_McuSize();
    public int get_BitsPerPixel();
    public sealed virtual void Dispose();
    public void Init(int maxSubFactorH, int maxSubFactorV);
    public void AllocateComponents();
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.ProfileResolver : object {
    public static ReadOnlySpan`1<byte> JFifMarker { get; }
    public static ReadOnlySpan`1<byte> JFxxMarker { get; }
    public static ReadOnlySpan`1<byte> IccMarker { get; }
    public static ReadOnlySpan`1<byte> AdobePhotoshopApp13Marker { get; }
    public static ReadOnlySpan`1<byte> AdobeImageResourceBlockMarker { get; }
    public static ReadOnlySpan`1<byte> AdobeIptcMarker { get; }
    public static ReadOnlySpan`1<byte> ExifMarker { get; }
    public static ReadOnlySpan`1<byte> XmpMarker { get; }
    public static ReadOnlySpan`1<byte> AdobeMarker { get; }
    public static ReadOnlySpan`1<byte> get_JFifMarker();
    public static ReadOnlySpan`1<byte> get_JFxxMarker();
    public static ReadOnlySpan`1<byte> get_IccMarker();
    public static ReadOnlySpan`1<byte> get_AdobePhotoshopApp13Marker();
    public static ReadOnlySpan`1<byte> get_AdobeImageResourceBlockMarker();
    public static ReadOnlySpan`1<byte> get_AdobeIptcMarker();
    public static ReadOnlySpan`1<byte> get_ExifMarker();
    public static ReadOnlySpan`1<byte> get_XmpMarker();
    public static ReadOnlySpan`1<byte> get_AdobeMarker();
    public static bool IsProfile(ReadOnlySpan`1<byte> bytesToCheck, ReadOnlySpan`1<byte> profileIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.SpectralConverter : object {
    private static Int32[] ScaledBlockSizes;
    [CompilerGeneratedAttribute]
private bool <Converted>k__BackingField;
    protected bool Converted { get; private set; }
    private static SpectralConverter();
    [CompilerGeneratedAttribute]
protected bool get_Converted();
    [CompilerGeneratedAttribute]
private void set_Converted(bool value);
    public abstract virtual void InjectFrameData(JpegFrame frame, IRawJpegData jpegData);
    public abstract virtual void PrepareForDecoding();
    public abstract virtual void ConvertStrideBaseline();
    public void CommitConversion();
    protected virtual JpegColorConverterBase GetColorConverter(JpegFrame frame, IRawJpegData jpegData);
    public static Size CalculateResultingImageSize(Size size, Nullable`1<Size> targetSize, Int32& blockPixelSize);
    public abstract virtual bool HasPixelBuffer();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.SpectralConverter`1 : SpectralConverter {
    private JpegFrame frame;
    private IRawJpegData jpegData;
    private ComponentProcessor[] componentProcessors;
    private JpegColorConverterBase colorConverter;
    private IMemoryOwner`1<byte> rgbBuffer;
    private IMemoryOwner`1<TPixel> paddedProxyPixelRow;
    private Buffer2D`1<TPixel> pixelBuffer;
    private int pixelRowsPerStep;
    private int pixelRowCounter;
    private Nullable`1<Size> targetSize;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    public Configuration Configuration { get; }
    public SpectralConverter`1(Configuration configuration, Nullable`1<Size> targetSize);
    [CompilerGeneratedAttribute]
public Configuration get_Configuration();
    public virtual bool HasPixelBuffer();
    public Buffer2D`1<TPixel> GetPixelBuffer(CancellationToken cancellationToken);
    private void ConvertStride(int spectralStep);
    public virtual void InjectFrameData(JpegFrame frame, IRawJpegData jpegData);
    public virtual void PrepareForDecoding();
    public virtual void ConvertStrideBaseline();
    protected ComponentProcessor[] CreateComponentProcessors(JpegFrame frame, IRawJpegData jpegData, int blockPixelSize, Size processorBufferSize);
    public sealed virtual void Dispose();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.Component : object {
    private MemoryAllocator memoryAllocator;
    [CompilerGeneratedAttribute]
private int <DcPredictor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HorizontalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VerticalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Buffer2D`1<Block8x8> <SpectralBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SubSamplingDivisors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuantizationTableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SizeInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SamplingFactors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WidthInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeightInBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcTableId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AcTableId>k__BackingField;
    public int DcPredictor { get; public set; }
    public int HorizontalSamplingFactor { get; }
    public int VerticalSamplingFactor { get; }
    public Buffer2D`1<Block8x8> SpectralBlocks { get; private set; }
    public Size SubSamplingDivisors { get; private set; }
    public int QuantizationTableIndex { get; }
    public Size SizeInBlocks { get; private set; }
    public Size SamplingFactors { get; public set; }
    public int WidthInBlocks { get; private set; }
    public int HeightInBlocks { get; private set; }
    public int DcTableId { get; public set; }
    public int AcTableId { get; public set; }
    public Component(MemoryAllocator memoryAllocator, int horizontalFactor, int verticalFactor, int quantizationTableIndex);
    [CompilerGeneratedAttribute]
public int get_DcPredictor();
    [CompilerGeneratedAttribute]
public void set_DcPredictor(int value);
    [CompilerGeneratedAttribute]
public int get_HorizontalSamplingFactor();
    [CompilerGeneratedAttribute]
public int get_VerticalSamplingFactor();
    [CompilerGeneratedAttribute]
public Buffer2D`1<Block8x8> get_SpectralBlocks();
    [CompilerGeneratedAttribute]
private void set_SpectralBlocks(Buffer2D`1<Block8x8> value);
    [CompilerGeneratedAttribute]
public Size get_SubSamplingDivisors();
    [CompilerGeneratedAttribute]
private void set_SubSamplingDivisors(Size value);
    [CompilerGeneratedAttribute]
public int get_QuantizationTableIndex();
    [CompilerGeneratedAttribute]
public Size get_SizeInBlocks();
    [CompilerGeneratedAttribute]
private void set_SizeInBlocks(Size value);
    [CompilerGeneratedAttribute]
public Size get_SamplingFactors();
    [CompilerGeneratedAttribute]
public void set_SamplingFactors(Size value);
    [CompilerGeneratedAttribute]
public int get_WidthInBlocks();
    [CompilerGeneratedAttribute]
private void set_WidthInBlocks(int value);
    [CompilerGeneratedAttribute]
public int get_HeightInBlocks();
    [CompilerGeneratedAttribute]
private void set_HeightInBlocks(int value);
    [CompilerGeneratedAttribute]
public int get_DcTableId();
    [CompilerGeneratedAttribute]
public void set_DcTableId(int value);
    [CompilerGeneratedAttribute]
public int get_AcTableId();
    [CompilerGeneratedAttribute]
public void set_AcTableId(int value);
    public sealed virtual void Dispose();
    public void Init(JpegFrame frame, int maxSubFactorH, int maxSubFactorV);
    public void AllocateSpectral(bool fullScan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.ComponentProcessor : object {
    private Size blockAreaSize;
    private Component component;
    private Block8x8F quantTable;
    [CompilerGeneratedAttribute]
private Buffer2D`1<float> <ColorBuffer>k__BackingField;
    public Buffer2D`1<float> ColorBuffer { get; }
    public ComponentProcessor(MemoryAllocator memoryAllocator, Component component, Size postProcessorBufferSize, Block8x8F quantTable);
    [CompilerGeneratedAttribute]
public Buffer2D`1<float> get_ColorBuffer();
    public void CopyColorBufferToBlocks(int spectralStep);
    [NullableContextAttribute("0")]
public Span`1<float> GetColorBufferRowSpan(int row);
    public sealed virtual void Dispose();
    private void PackColorBuffer();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <PackColorBuffer>g__SumVertical|10_0(Span`1<float> target, Span`1<float> source);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <PackColorBuffer>g__SumHorizontal|10_1(Span`1<float> target, int factor);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <PackColorBuffer>g__MultiplyToAverage|10_2(Span`1<float> target, float multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.HuffmanLut : ValueType {
    [CompilerGeneratedAttribute]
private Int32[] <Values>k__BackingField;
    public Int32[] Values { get; }
    public HuffmanLut(HuffmanSpec spec);
    [CompilerGeneratedAttribute]
public Int32[] get_Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.HuffmanScanEncoder : object {
    private static int MaxBytesPerBlock;
    private static int MaxBytesPerBlockMultiplier;
    private static int OutputBufferLengthMultiplier;
    private HuffmanLut[] dcHuffmanTables;
    private HuffmanLut[] acHuffmanTables;
    private UInt32 accumulatedBits;
    private UInt32[] emitBuffer;
    private Byte[] streamWriteBuffer;
    private int bitCount;
    private int emitWriteIndex;
    private Stream target;
    private bool IsStreamFlushNeeded { get; }
    public HuffmanScanEncoder(int blocksPerCodingUnit, Stream outputStream);
    private bool get_IsStreamFlushNeeded();
    public void BuildHuffmanTable(JpegHuffmanTableConfig tableConfig);
    [NullableContextAttribute("0")]
public void EncodeScanBaselineInterleaved(JpegEncodingColor color, JpegFrame frame, SpectralConverter`1<TPixel> converter, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public void EncodeScanBaselineSingleComponent(Component component, SpectralConverter`1<TPixel> converter, CancellationToken cancellationToken);
    public void EncodeScanBaseline(Component component, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private void EncodeScanBaselineInterleaved(JpegFrame frame, SpectralConverter`1<TPixel> converter, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private void EncodeThreeComponentBaselineInterleavedScanNoSubsampling(JpegFrame frame, SpectralConverter`1<TPixel> converter, CancellationToken cancellationToken);
    private void WriteBlock(Component component, Block8x8& block, HuffmanLut& dcTable, HuffmanLut& acTable);
    private void Emit(UInt32 bits, int count);
    private void EmitHuff(Int32[] table, int value);
    private void EmitHuffRLE(Int32[] table, int runLength, int value);
    internal static int GetHuffmanEncodingLength(UInt32 value);
    private void FlushToStream(int endIndex);
    private void FlushToStream();
    private void FlushRemainingBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.HuffmanSpec : ValueType {
    public static HuffmanSpec LuminanceDC;
    public static HuffmanSpec LuminanceAC;
    public static HuffmanSpec ChrominanceDC;
    public static HuffmanSpec ChrominanceAC;
    [CompilerGeneratedAttribute]
private Byte[] <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Values>k__BackingField;
    public Byte[] Count { get; }
    public Byte[] Values { get; }
    public HuffmanSpec(Byte[] count, Byte[] values);
    private static HuffmanSpec();
    [CompilerGeneratedAttribute]
public Byte[] get_Count();
    [CompilerGeneratedAttribute]
public Byte[] get_Values();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.JpegComponentConfig : object {
    [CompilerGeneratedAttribute]
private byte <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HorizontalSampleFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VerticalSampleFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuantizatioTableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DcTableSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AcTableSelector>k__BackingField;
    public byte Id { get; }
    public int HorizontalSampleFactor { get; }
    public int VerticalSampleFactor { get; }
    public int QuantizatioTableIndex { get; }
    public int DcTableSelector { get; }
    public int AcTableSelector { get; }
    public JpegComponentConfig(byte id, int hsf, int vsf, int quantIndex, int dcIndex, int acIndex);
    [CompilerGeneratedAttribute]
public byte get_Id();
    [CompilerGeneratedAttribute]
public int get_HorizontalSampleFactor();
    [CompilerGeneratedAttribute]
public int get_VerticalSampleFactor();
    [CompilerGeneratedAttribute]
public int get_QuantizatioTableIndex();
    [CompilerGeneratedAttribute]
public int get_DcTableSelector();
    [CompilerGeneratedAttribute]
public int get_AcTableSelector();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.JpegFrame : object {
    [CompilerGeneratedAttribute]
private JpegColorSpace <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Interleaved>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PixelHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PixelWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Component[] <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private int <McusPerLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <McusPerColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlocksPerMcu>k__BackingField;
    public JpegColorSpace ColorSpace { get; }
    public bool Interleaved { get; }
    public int PixelHeight { get; }
    public int PixelWidth { get; }
    public Component[] Components { get; }
    public int McusPerLine { get; }
    public int McusPerColumn { get; }
    public int BlocksPerMcu { get; }
    public JpegFrame(Image image, JpegFrameConfig frameConfig, bool interleaved);
    [CompilerGeneratedAttribute]
public JpegColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
public bool get_Interleaved();
    [CompilerGeneratedAttribute]
public int get_PixelHeight();
    [CompilerGeneratedAttribute]
public int get_PixelWidth();
    [CompilerGeneratedAttribute]
public Component[] get_Components();
    [CompilerGeneratedAttribute]
public int get_McusPerLine();
    [CompilerGeneratedAttribute]
public int get_McusPerColumn();
    [CompilerGeneratedAttribute]
public int get_BlocksPerMcu();
    public sealed virtual void Dispose();
    public void AllocateComponents(bool fullScan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.JpegFrameConfig : object {
    [CompilerGeneratedAttribute]
private JpegColorSpace <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegEncodingColor <EncodingColor>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegComponentConfig[] <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegHuffmanTableConfig[] <HuffmanTables>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegQuantizationTableConfig[] <QuantizationTables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHorizontalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxVerticalSamplingFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<byte> <AdobeColorTransformMarkerFlag>k__BackingField;
    public JpegColorSpace ColorType { get; }
    public JpegEncodingColor EncodingColor { get; }
    public JpegComponentConfig[] Components { get; }
    public JpegHuffmanTableConfig[] HuffmanTables { get; }
    public JpegQuantizationTableConfig[] QuantizationTables { get; }
    public int MaxHorizontalSamplingFactor { get; }
    public int MaxVerticalSamplingFactor { get; }
    public Nullable`1<byte> AdobeColorTransformMarkerFlag { get; public set; }
    public JpegFrameConfig(JpegColorSpace colorType, JpegEncodingColor encodingColor, JpegComponentConfig[] components, JpegHuffmanTableConfig[] huffmanTables, JpegQuantizationTableConfig[] quantTables);
    [CompilerGeneratedAttribute]
public JpegColorSpace get_ColorType();
    [CompilerGeneratedAttribute]
public JpegEncodingColor get_EncodingColor();
    [CompilerGeneratedAttribute]
public JpegComponentConfig[] get_Components();
    [CompilerGeneratedAttribute]
public JpegHuffmanTableConfig[] get_HuffmanTables();
    [CompilerGeneratedAttribute]
public JpegQuantizationTableConfig[] get_QuantizationTables();
    [CompilerGeneratedAttribute]
public int get_MaxHorizontalSamplingFactor();
    [CompilerGeneratedAttribute]
public int get_MaxVerticalSamplingFactor();
    [CompilerGeneratedAttribute]
public Nullable`1<byte> get_AdobeColorTransformMarkerFlag();
    [CompilerGeneratedAttribute]
public void set_AdobeColorTransformMarkerFlag(Nullable`1<byte> value);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.JpegHuffmanTableConfig : object {
    [CompilerGeneratedAttribute]
private int <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DestinationIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private HuffmanSpec <Table>k__BackingField;
    public int Class { get; }
    public int DestinationIndex { get; }
    public HuffmanSpec Table { get; }
    public JpegHuffmanTableConfig(int class, int destIndex, HuffmanSpec table);
    [CompilerGeneratedAttribute]
public int get_Class();
    [CompilerGeneratedAttribute]
public int get_DestinationIndex();
    [CompilerGeneratedAttribute]
public HuffmanSpec get_Table();
}
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.JpegQuantizationTableConfig : object {
    [CompilerGeneratedAttribute]
private int <DestinationIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Block8x8 <Table>k__BackingField;
    public int DestinationIndex { get; }
    public Block8x8 Table { get; }
    public JpegQuantizationTableConfig(int destIndex, ReadOnlySpan`1<byte> quantizationTable);
    [CompilerGeneratedAttribute]
public int get_DestinationIndex();
    [CompilerGeneratedAttribute]
public Block8x8 get_Table();
}
internal abstract class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.SpectralConverter : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.Encoder.SpectralConverter`1 : SpectralConverter {
    private ComponentProcessor[] componentProcessors;
    private int pixelRowsPerStep;
    private int pixelRowCounter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> pixelBuffer;
    private IMemoryOwner`1<float> redLane;
    private IMemoryOwner`1<float> greenLane;
    private IMemoryOwner`1<float> blueLane;
    private int alignedPixelWidth;
    private JpegColorConverterBase colorConverter;
    public SpectralConverter`1(JpegFrame frame, Image`1<TPixel> image, Block8x8F[] dequantTables);
    public void ConvertStrideBaseline();
    public void ConvertFull();
    private void ConvertStride(int spectralStep);
    public sealed virtual void Dispose();
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.FloatingPointDCT : object {
    private static Vector4 mm128_F_0_7071;
    private static Vector4 mm128_F_0_3826;
    private static Vector4 mm128_F_0_5411;
    private static Vector4 mm128_F_1_3065;
    private static Vector4 mm128_F_1_4142;
    private static Vector4 mm128_F_1_8477;
    private static Vector4 mm128_F_n1_0823;
    private static Vector4 mm128_F_n2_6131;
    [NullableAttribute("1")]
private static Single[] AdjustmentCoefficients;
    private static FloatingPointDCT();
    public static void AdjustToIDCT(Block8x8F& quantTable);
    public static void AdjustToFDCT(Block8x8F& quantTable);
    public static void TransformIDCT(Block8x8F& block);
    public static void TransformFDCT(Block8x8F& block);
    private static void IDCT_Vector4(Block8x8F& transposedBlock);
    private static void FDCT_Vector4(Block8x8F& block);
    private static void FDCT8x8_Avx(Block8x8F& block);
    private static void IDCT8x8_Avx(Block8x8F& transposedBlock);
    [CompilerGeneratedAttribute]
internal static void <IDCT_Vector4>g__IDCT8x4_Vector4|13_0(Vector4& vecRef);
    [CompilerGeneratedAttribute]
internal static void <FDCT_Vector4>g__FDCT8x4_Vector4|14_0(Vector4& vecRef);
    [CompilerGeneratedAttribute]
internal static void <FDCT8x8_Avx>g__FDCT8x8_1D_Avx|15_0(Block8x8F& block);
    [CompilerGeneratedAttribute]
internal static void <IDCT8x8_Avx>g__IDCT8x8_1D_Avx|16_0(Block8x8F& block);
}
internal abstract class SixLabors.ImageSharp.Formats.Jpeg.Components.JpegColorConverterBase : object {
    private static JpegColorConverterBase[] Converters;
    [CompilerGeneratedAttribute]
private JpegColorSpace <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MaximumValue>k__BackingField;
    [CompilerGeneratedAttribute]
private float <HalfValue>k__BackingField;
    public bool IsAvailable { get; }
    public int ElementsPerBatch { get; }
    public JpegColorSpace ColorSpace { get; }
    public int Precision { get; }
    private float MaximumValue { get; }
    private float HalfValue { get; }
    protected JpegColorConverterBase(JpegColorSpace colorSpace, int precision);
    private static JpegColorConverterBase();
    public abstract virtual bool get_IsAvailable();
    public abstract virtual int get_ElementsPerBatch();
    [CompilerGeneratedAttribute]
public JpegColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
private float get_MaximumValue();
    [CompilerGeneratedAttribute]
private float get_HalfValue();
    public static JpegColorConverterBase GetConverter(JpegColorSpace colorSpace, int precision);
    public abstract virtual void ConvertToRgbInplace(ComponentValues& modreq(System.Runtime.InteropServices.InAttribute) values);
    public abstract virtual void ConvertFromRgb(ComponentValues& modreq(System.Runtime.InteropServices.InAttribute) values, Span`1<float> rLane, Span`1<float> gLane, Span`1<float> bLane);
    private static JpegColorConverterBase[] CreateConverters();
    private static JpegColorConverterBase GetYCbCrConverter(int precision);
    private static JpegColorConverterBase GetYccKConverter(int precision);
    private static JpegColorConverterBase GetCmykConverter(int precision);
    private static JpegColorConverterBase GetGrayScaleConverter(int precision);
    private static JpegColorConverterBase GetRgbConverter(int precision);
}
internal enum SixLabors.ImageSharp.Formats.Jpeg.Components.JpegColorSpace : Enum {
    public int value__;
    public static JpegColorSpace Grayscale;
    public static JpegColorSpace Ycck;
    public static JpegColorSpace Cmyk;
    public static JpegColorSpace RGB;
    public static JpegColorSpace YCbCr;
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.Quantization : object {
    public static int MaxQualityFactor;
    public static int MinQualityFactor;
    public static int DefaultQualityFactor;
    public static int QualityEstimationConfidenceLowerThreshold;
    public static int QualityEstimationConfidenceUpperThreshold;
    public static ReadOnlySpan`1<byte> LuminanceTable { get; }
    public static ReadOnlySpan`1<byte> ChrominanceTable { get; }
    public static ReadOnlySpan`1<byte> get_LuminanceTable();
    public static ReadOnlySpan`1<byte> get_ChrominanceTable();
    public static int EstimateQuality(Block8x8F& table, ReadOnlySpan`1<byte> target);
    public static int EstimateLuminanceQuality(Block8x8F& luminanceTable);
    public static int EstimateChrominanceQuality(Block8x8F& chrominanceTable);
    private static int QualityToScale(int quality);
    public static Block8x8F ScaleQuantizationTable(int scale, ReadOnlySpan`1<byte> unscaledTable);
    public static Block8x8 ScaleQuantizationTable(int quality, Block8x8 unscaledTable);
    public static Block8x8F ScaleLuminanceTable(int quality);
    public static Block8x8F ScaleChrominanceTable(int quality);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Formats.Jpeg.Components.RowOctet`1 : ValueType {
    private Span`1<T> row0;
    private Span`1<T> row1;
    private Span`1<T> row2;
    private Span`1<T> row3;
    private Span`1<T> row4;
    private Span`1<T> row5;
    private Span`1<T> row6;
    private Span`1<T> row7;
    public Span`1<T> Item { get; private set; }
    public Span`1<T> get_Item(int y);
    private void set_Item(int y, Span`1<T> value);
    public void Update(Buffer2D`1<T> buffer, int startY);
    private static Span`1<T> ThrowIndexOutOfRangeException();
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.ScaledFloatingPointDCT : object {
    private static float FP32_0_541196100;
    private static float FP32_0_765366865;
    private static float FP32_1_847759065;
    private static float FP32_0_211164243;
    private static float FP32_1_451774981;
    private static float FP32_2_172734803;
    private static float FP32_1_061594337;
    private static float FP32_0_509795579;
    private static float FP32_0_601344887;
    private static float FP32_0_899976223;
    private static float FP32_2_562915447;
    private static float FP32_0_720959822;
    private static float FP32_0_850430095;
    private static float FP32_1_272758580;
    private static float FP32_3_624509785;
    public static void AdjustToIDCT(Block8x8F& quantTable);
    public static void TransformIDCT_4x4(Block8x8F& block, Block8x8F& dequantTable, float normalizationValue, float maxValue);
    public static void TransformIDCT_2x2(Block8x8F& block, Block8x8F& dequantTable, float normalizationValue, float maxValue);
    public static float TransformIDCT_1x1(float dc, float dequantizer, float normalizationValue, float maxValue);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.SizeExtensions : object {
    [ExtensionAttribute]
public static Size MultiplyBy(Size a, Size b);
    [ExtensionAttribute]
public static Size DivideBy(Size a, Size b);
    [ExtensionAttribute]
public static Size DivideRoundUp(Size originalSize, int divX, int divY);
    [ExtensionAttribute]
public static Size DivideRoundUp(Size originalSize, int divisor);
    [ExtensionAttribute]
public static Size DivideRoundUp(Size originalSize, Size divisor);
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.Components.ZigZag : object {
    private static byte _;
    public static ReadOnlySpan`1<byte> ZigZagOrder { get; }
    public static ReadOnlySpan`1<byte> TransposingOrder { get; }
    private static ReadOnlySpan`1<byte> SseShuffleMasks { get; }
    private static ReadOnlySpan`1<byte> AvxShuffleMasks { get; }
    public static ReadOnlySpan`1<byte> get_ZigZagOrder();
    public static ReadOnlySpan`1<byte> get_TransposingOrder();
    private static ReadOnlySpan`1<byte> get_SseShuffleMasks();
    private static ReadOnlySpan`1<byte> get_AvxShuffleMasks();
    public static void ApplyTransposingZigZagOrderingSsse3(Block8x8& block);
    public static void ApplyTransposingZigZagOrderingAvx2(Block8x8& block);
}
public class SixLabors.ImageSharp.Formats.Jpeg.JpegConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
internal static class SixLabors.ImageSharp.Formats.Jpeg.JpegConstants : object {
    public static ushort MaxLength;
    [NullableAttribute("1")]
public static IEnumerable`1<string> MimeTypes;
    [NullableAttribute("1")]
public static IEnumerable`1<string> FileExtensions;
    private static JpegConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SixLabors.ImageSharp.Formats.Jpeg.JpegDecoder : SpecializedImageDecoder`1<JpegDecoderOptions> {
    [CompilerGeneratedAttribute]
private static JpegDecoder <Instance>k__BackingField;
    public static JpegDecoder Instance { get; }
    private static JpegDecoder();
    [CompilerGeneratedAttribute]
public static JpegDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(JpegDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(JpegDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual JpegDecoderOptions CreateDefaultSpecializedOptions(DecoderOptions options);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.JpegDecoderCore : object {
    private bool hasExif;
    private Byte[] exifData;
    private bool hasIcc;
    private Byte[] iccData;
    private bool hasIptc;
    private Byte[] iptcData;
    private bool hasXmp;
    private Byte[] xmpData;
    private bool hasAdobeMarker;
    private JFifMarker jFif;
    private AdobeMarker adobe;
    private IJpegScanDecoder scanDecoder;
    private List`1<ArithmeticDecodingTable> arithmeticDecodingTables;
    private Nullable`1<int> resetInterval;
    private Configuration configuration;
    private bool skipMetadata;
    private JpegDecoderResizeMode resizeMode;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegFrame <Frame>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegColorSpace <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private Block8x8F[] <QuantizationTables>k__BackingField;
    private static ReadOnlySpan`1<byte> SupportedPrecisions { get; }
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public JpegFrame Frame { get; private set; }
    public ImageMetadata Metadata { get; private set; }
    public JpegColorSpace ColorSpace { get; private set; }
    public JpegComponent[] Components { get; }
    private JpegComponent[] SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.IRawJpegData.Components { get; }
    public Block8x8F[] QuantizationTables { get; private set; }
    public JpegDecoderCore(JpegDecoderOptions options);
    private static ReadOnlySpan`1<byte> get_SupportedPrecisions();
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    [CompilerGeneratedAttribute]
public JpegFrame get_Frame();
    [CompilerGeneratedAttribute]
private void set_Frame(JpegFrame value);
    [CompilerGeneratedAttribute]
public ImageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(ImageMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual JpegColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
private void set_ColorSpace(JpegColorSpace value);
    public JpegComponent[] get_Components();
    private sealed virtual override JpegComponent[] SixLabors.ImageSharp.Formats.Jpeg.Components.Decoder.IRawJpegData.get_Components();
    [CompilerGeneratedAttribute]
public sealed virtual Block8x8F[] get_QuantizationTables();
    [CompilerGeneratedAttribute]
private void set_QuantizationTables(Block8x8F[] value);
    public static JpegFileMarker FindNextFileMarker(BufferedReadStream stream);
    public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    public void LoadTables(Byte[] tableBytes, IJpegScanDecoder scanDecoder);
    internal void ParseStream(BufferedReadStream stream, SpectralConverter spectralConverter, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    internal static JpegColorSpace DeduceJpegColorSpace(byte componentCount, AdobeMarker& adobeMarker);
    internal static JpegColorSpace DeduceJpegColorSpace(byte componentCount);
    private JpegEncodingColor DeduceJpegColorType();
    private void InitExifProfile();
    private void InitIccProfile();
    private void InitIptcProfile();
    private void InitXmpProfile();
    private void InitDerivedMetadataProperties();
    private double GetExifResolutionValue(ExifTag`1<Rational> tag);
    private static void ExtendProfile(Byte[]& profile, Byte[] extension);
    private void ProcessApplicationHeaderMarker(BufferedReadStream stream, int remaining);
    private void ProcessApp1Marker(BufferedReadStream stream, int remaining);
    private void ProcessApp2Marker(BufferedReadStream stream, int remaining);
    private void ProcessApp13Marker(BufferedReadStream stream, int remaining);
    private void ProcessArithmeticTable(BufferedReadStream stream, int remaining);
    private static int ReadImageResourceNameLength(Span`1<byte> blockDataSpan);
    private static int ReadResourceDataLength(Span`1<byte> blockDataSpan, int resourceBlockNameLength);
    private void ProcessApp14Marker(BufferedReadStream stream, int remaining);
    private void ProcessDefineQuantizationTablesMarker(BufferedReadStream stream, int remaining);
    private void ProcessStartOfFrameMarker(BufferedReadStream stream, int remaining, JpegFileMarker& frameMarker, ComponentType decodingComponentType, bool metadataOnly);
    private void ProcessDefineHuffmanTablesMarker(BufferedReadStream stream, int remaining);
    private void ProcessDefineRestartIntervalMarker(BufferedReadStream stream, int remaining, Span`1<byte> markerBuffer);
    private void ProcessStartOfScanMarker(BufferedReadStream stream, int remaining);
    private static ushort ReadUint16(BufferedReadStream stream, Span`1<byte> markerBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Jpeg.JpegDecoderOptions : object {
    [CompilerGeneratedAttribute]
private DecoderOptions <GeneralOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private JpegDecoderResizeMode <ResizeMode>k__BackingField;
    public DecoderOptions GeneralOptions { get; public set; }
    public JpegDecoderResizeMode ResizeMode { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_GeneralOptions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GeneralOptions(DecoderOptions value);
    [CompilerGeneratedAttribute]
public JpegDecoderResizeMode get_ResizeMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResizeMode(JpegDecoderResizeMode value);
}
public enum SixLabors.ImageSharp.Formats.Jpeg.JpegDecoderResizeMode : Enum {
    public int value__;
    public static JpegDecoderResizeMode Combined;
    public static JpegDecoderResizeMode IdctOnly;
    public static JpegDecoderResizeMode ScaleOnly;
}
public class SixLabors.ImageSharp.Formats.Jpeg.JpegEncoder : ImageEncoder {
    private Nullable`1<int> quality;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Interleaved>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JpegEncodingColor> <ColorType>k__BackingField;
    public Nullable`1<int> Quality { get; public set; }
    public Nullable`1<bool> Interleaved { get; public set; }
    public Nullable`1<JpegEncodingColor> ColorType { get; public set; }
    public Nullable`1<int> get_Quality();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Quality(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Interleaved();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interleaved(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JpegEncodingColor> get_ColorType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorType(Nullable`1<JpegEncodingColor> value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Jpeg.JpegEncoderCore : object {
    private static JpegFrameConfig[] FrameConfigs;
    private JpegEncoder encoder;
    private Stream outputStream;
    [CompilerGeneratedAttribute]
private Block8x8F[] <QuantizationTables>k__BackingField;
    public Block8x8F[] QuantizationTables { get; }
    public JpegEncoderCore(JpegEncoder encoder);
    private static JpegEncoderCore();
    [CompilerGeneratedAttribute]
public Block8x8F[] get_QuantizationTables();
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private void WriteStartOfImage(Span`1<byte> buffer);
    private void WriteJfifApplicationHeader(ImageMetadata meta, Span`1<byte> buffer);
    private void WriteDefineHuffmanTables(JpegHuffmanTableConfig[] tableConfigs, HuffmanScanEncoder scanEncoder, Span`1<byte> buffer);
    private void WriteApp14Marker(byte colorTransform, Span`1<byte> buffer);
    private void WriteExifProfile(ExifProfile exifProfile, Span`1<byte> buffer);
    private void WriteIptcProfile(IptcProfile iptcProfile, Span`1<byte> buffer);
    private void WriteXmpProfile(XmpProfile xmpProfile, Span`1<byte> buffer);
    private void WriteApp1Header(int app1Length, Span`1<byte> buffer);
    private void WriteAppHeader(int length, byte appMarker, Span`1<byte> buffer);
    private void WriteIccProfile(IccProfile iccProfile, Span`1<byte> buffer);
    private void WriteProfiles(ImageMetadata metadata, Span`1<byte> buffer);
    private void WriteStartOfFrame(int width, int height, JpegFrameConfig frame, Span`1<byte> buffer);
    private void WriteStartOfScan(Span`1<JpegComponentConfig> components, Span`1<byte> buffer);
    private void WriteEndOfImageMarker(Span`1<byte> buffer);
    private void WriteHuffmanScans(JpegFrame frame, JpegFrameConfig frameConfig, SpectralConverter`1<TPixel> spectralConverter, HuffmanScanEncoder encoder, Span`1<byte> buffer, CancellationToken cancellationToken);
    private void WriteMarkerHeader(byte marker, int length, Span`1<byte> buffer);
    private void WriteDefineQuantizationTables(JpegQuantizationTableConfig[] configs, Nullable`1<int> optionsQuality, JpegMetadata metadata, Span`1<byte> tmpBuffer);
    private JpegFrameConfig GetFrameConfig(JpegMetadata metadata);
    [NullableContextAttribute("1")]
private static JpegFrameConfig[] CreateFrameConfigs();
    [CompilerGeneratedAttribute]
internal static int <WriteDefineQuantizationTables>g__GetQualityForTable|24_0(int destIndex, Nullable`1<int> encoderQuality, JpegMetadata metadata);
}
public enum SixLabors.ImageSharp.Formats.Jpeg.JpegEncodingColor : Enum {
    public byte value__;
    public static JpegEncodingColor YCbCrRatio420;
    public static JpegEncodingColor YCbCrRatio444;
    public static JpegEncodingColor YCbCrRatio422;
    public static JpegEncodingColor YCbCrRatio411;
    public static JpegEncodingColor YCbCrRatio410;
    public static JpegEncodingColor Luminance;
    public static JpegEncodingColor Rgb;
    public static JpegEncodingColor Cmyk;
    public static JpegEncodingColor Ycck;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Jpeg.JpegFormat : object {
    [CompilerGeneratedAttribute]
private static JpegFormat <Instance>k__BackingField;
    public static JpegFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static JpegFormat();
    [CompilerGeneratedAttribute]
public static JpegFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual JpegMetadata CreateDefaultFormatMetadata();
}
public class SixLabors.ImageSharp.Formats.Jpeg.JpegImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
    private static bool IsJfif(ReadOnlySpan`1<byte> header);
    private static bool IsExif(ReadOnlySpan`1<byte> header);
    private static bool IsJpeg(ReadOnlySpan`1<byte> header);
}
public class SixLabors.ImageSharp.Formats.Jpeg.JpegMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LuminanceQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChrominanceQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JpegEncodingColor> <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Interleaved>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Progressive>k__BackingField;
    internal Nullable`1<int> LuminanceQuality { get; internal set; }
    internal Nullable`1<int> ChrominanceQuality { get; internal set; }
    public int Quality { get; }
    public Nullable`1<JpegEncodingColor> ColorType { get; internal set; }
    public Nullable`1<bool> Interleaved { get; internal set; }
    public Nullable`1<bool> Progressive { get; internal set; }
    [NullableContextAttribute("1")]
private JpegMetadata(JpegMetadata other);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_LuminanceQuality();
    [CompilerGeneratedAttribute]
internal void set_LuminanceQuality(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_ChrominanceQuality();
    [CompilerGeneratedAttribute]
internal void set_ChrominanceQuality(Nullable`1<int> value);
    public int get_Quality();
    [CompilerGeneratedAttribute]
public Nullable`1<JpegEncodingColor> get_ColorType();
    [CompilerGeneratedAttribute]
internal void set_ColorType(Nullable`1<JpegEncodingColor> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Interleaved();
    [CompilerGeneratedAttribute]
internal void set_Interleaved(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Progressive();
    [CompilerGeneratedAttribute]
internal void set_Progressive(Nullable`1<bool> value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Jpeg.JpegThrowHelper : object {
    public static void ThrowNotSupportedException(string errorMessage);
    public static void ThrowInvalidImageContentException(string errorMessage);
    public static void ThrowBadMarker(string marker, int length);
    public static void ThrowNotEnoughBytesForMarker(byte marker);
    public static void ThrowBadQuantizationTableIndex(int index);
    public static void ThrowBadQuantizationTablePrecision(int precision);
    public static void ThrowBadSampling();
    public static void ThrowBadSampling(int factor);
    public static void ThrowBadProgressiveScan(int ss, int se, int ah, int al);
    public static void ThrowInvalidImageDimensions(int width, int height);
    public static void ThrowDimensionsTooLarge(int width, int height);
    public static void ThrowNotSupportedComponentCount(int componentCount);
    public static void ThrowNotSupportedColorSpace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Pbm.BinaryDecoder : object {
    private static L8 white;
    private static L8 black;
    private static BinaryDecoder();
    public static void Process(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream, PbmColorType colorType, PbmComponentType componentType);
    private static void ProcessGrayscale(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessWideGrayscale(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessRgb(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessWideRgb(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessBlackAndWhite(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Pbm.BinaryEncoder : object {
    public static void WritePixels(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image, PbmColorType colorType, PbmComponentType componentType);
    private static void WriteGrayscale(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteWideGrayscale(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteRgb(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteWideRgb(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteBlackAndWhite(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Formats.Pbm.BufferedReadStreamExtensions : object {
    [ExtensionAttribute]
public static bool SkipWhitespaceAndComments(BufferedReadStream stream);
    [ExtensionAttribute]
public static bool ReadDecimal(BufferedReadStream stream, Int32& value);
}
internal interface SixLabors.ImageSharp.Formats.Pbm.IPbmEncoderOptions {
    public Nullable`1<PbmEncoding> Encoding { get; }
    public Nullable`1<PbmColorType> ColorType { get; }
    public Nullable`1<PbmComponentType> ComponentType { get; }
    public abstract virtual Nullable`1<PbmEncoding> get_Encoding();
    public abstract virtual Nullable`1<PbmColorType> get_ColorType();
    public abstract virtual Nullable`1<PbmComponentType> get_ComponentType();
}
public enum SixLabors.ImageSharp.Formats.Pbm.PbmColorType : Enum {
    public byte value__;
    public static PbmColorType BlackAndWhite;
    public static PbmColorType Grayscale;
    public static PbmColorType Rgb;
}
public enum SixLabors.ImageSharp.Formats.Pbm.PbmComponentType : Enum {
    public byte value__;
    public static PbmComponentType Bit;
    public static PbmComponentType Byte;
    public static PbmComponentType Short;
}
public class SixLabors.ImageSharp.Formats.Pbm.PbmConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Pbm.PbmConstants : object {
    public static ushort MaxLength;
    public static IEnumerable`1<string> MimeTypes;
    public static IEnumerable`1<string> FileExtensions;
    private static PbmConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Pbm.PbmDecoder : ImageDecoder {
    [CompilerGeneratedAttribute]
private static PbmDecoder <Instance>k__BackingField;
    public static PbmDecoder Instance { get; }
    private static PbmDecoder();
    [CompilerGeneratedAttribute]
public static PbmDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Pbm.PbmDecoderCore : object {
    private int maxPixelValue;
    private Configuration configuration;
    private PbmColorType colorType;
    private Size pixelSize;
    private PbmComponentType componentType;
    private PbmEncoding encoding;
    [NullableAttribute("2")]
private ImageMetadata metadata;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public PbmDecoderCore(DecoderOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    [NullableContextAttribute("0")]
public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private void ProcessHeader(BufferedReadStream stream);
    [NullableContextAttribute("0")]
private void ProcessPixels(BufferedReadStream stream, Buffer2D`1<TPixel> pixels);
    [NullableContextAttribute("0")]
private void ProcessUpscaling(Image`1<TPixel> image);
    private bool NeedsUpscaling();
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <ProcessHeader>g__ThrowPrematureEof|15_0();
}
public class SixLabors.ImageSharp.Formats.Pbm.PbmEncoder : ImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<PbmEncoding> <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PbmColorType> <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PbmComponentType> <ComponentType>k__BackingField;
    public Nullable`1<PbmEncoding> Encoding { get; public set; }
    public Nullable`1<PbmColorType> ColorType { get; public set; }
    public Nullable`1<PbmComponentType> ComponentType { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<PbmEncoding> get_Encoding();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Encoding(Nullable`1<PbmEncoding> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PbmColorType> get_ColorType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorType(Nullable`1<PbmColorType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PbmComponentType> get_ComponentType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ComponentType(Nullable`1<PbmComponentType> value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Pbm.PbmEncoderCore : object {
    private static byte NewLine;
    private static byte Space;
    private static byte P;
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableAttribute("1")]
private PbmEncoder encoder;
    private PbmEncoding encoding;
    private PbmColorType colorType;
    private PbmComponentType componentType;
    [NullableContextAttribute("1")]
public PbmEncoderCore(Configuration configuration, PbmEncoder encoder);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private void SanitizeAndSetEncoderOptions(Image`1<TPixel> image);
    private byte DeduceSignature();
    [NullableContextAttribute("1")]
private void WriteHeader(Stream stream, byte signature, Size pixelSize);
    private void WritePixels(Stream stream, ImageFrame`1<TPixel> image);
}
public enum SixLabors.ImageSharp.Formats.Pbm.PbmEncoding : Enum {
    public byte value__;
    public static PbmEncoding Plain;
    public static PbmEncoding Binary;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Pbm.PbmFormat : object {
    [CompilerGeneratedAttribute]
private static PbmFormat <Instance>k__BackingField;
    public static PbmFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static PbmFormat();
    [CompilerGeneratedAttribute]
public static PbmFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual PbmMetadata CreateDefaultFormatMetadata();
}
public class SixLabors.ImageSharp.Formats.Pbm.PbmImageFormatDetector : object {
    private static byte P;
    private static byte Zero;
    private static byte Seven;
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private static bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
public class SixLabors.ImageSharp.Formats.Pbm.PbmMetadata : object {
    [CompilerGeneratedAttribute]
private PbmEncoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private PbmColorType <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private PbmComponentType <ComponentType>k__BackingField;
    public PbmEncoding Encoding { get; public set; }
    public PbmColorType ColorType { get; public set; }
    public PbmComponentType ComponentType { get; public set; }
    [NullableContextAttribute("1")]
private PbmMetadata(PbmMetadata other);
    [CompilerGeneratedAttribute]
public PbmEncoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(PbmEncoding value);
    [CompilerGeneratedAttribute]
public PbmColorType get_ColorType();
    [CompilerGeneratedAttribute]
public void set_ColorType(PbmColorType value);
    [CompilerGeneratedAttribute]
public PbmComponentType get_ComponentType();
    [CompilerGeneratedAttribute]
public void set_ComponentType(PbmComponentType value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Pbm.PlainDecoder : object {
    private static L8 White;
    private static L8 Black;
    private static PlainDecoder();
    public static void Process(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream, PbmColorType colorType, PbmComponentType componentType);
    private static void ProcessGrayscale(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessWideGrayscale(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessRgb(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessWideRgb(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
    private static void ProcessBlackAndWhite(Configuration configuration, Buffer2D`1<TPixel> pixels, BufferedReadStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Pbm.PlainEncoder : object {
    private static byte NewLine;
    private static byte Space;
    private static byte Zero;
    private static byte One;
    private static int MaxCharsPerPixelBlackAndWhite;
    private static int MaxCharsPerPixelGrayscale;
    private static int MaxCharsPerPixelGrayscaleWide;
    private static int MaxCharsPerPixelRgb;
    private static int MaxCharsPerPixelRgbWide;
    private static StandardFormat DecimalFormat;
    private static PlainEncoder();
    public static void WritePixels(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image, PbmColorType colorType, PbmComponentType componentType);
    private static void WriteGrayscale(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteWideGrayscale(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteRgb(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteWideRgb(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private static void WriteBlackAndWhite(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
}
public class SixLabors.ImageSharp.Formats.PixelTypeInfo : object {
    [CompilerGeneratedAttribute]
private int <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PixelAlphaRepresentation> <AlphaRepresentation>k__BackingField;
    public int BitsPerPixel { get; }
    public Nullable`1<PixelAlphaRepresentation> AlphaRepresentation { get; }
    public PixelTypeInfo(int bitsPerPixel);
    public PixelTypeInfo(int bitsPerPixel, PixelAlphaRepresentation alpha);
    [CompilerGeneratedAttribute]
public int get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public Nullable`1<PixelAlphaRepresentation> get_AlphaRepresentation();
    internal static PixelTypeInfo Create();
    internal static PixelTypeInfo Create(PixelAlphaRepresentation alpha);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Png.Adam7 : object {
    public static Int32[] ColumnIncrement;
    public static Int32[] FirstColumn;
    public static Int32[] FirstRow;
    public static Int32[] RowIncrement;
    private static Adam7();
    public static int ComputeBlockWidth(int width, int pass);
    public static int ComputeBlockHeight(int height, int pass);
    public static int ComputeColumns(int width, int passIndex);
    [CompilerGeneratedAttribute]
internal static UInt32 <ComputeColumns>g__Throw|6_0(int passIndex);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Png.Chunks.AnimationControl : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private UInt32 <NumberFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NumberPlays>k__BackingField;
    public UInt32 NumberFrames { get; }
    public UInt32 NumberPlays { get; }
    public AnimationControl(UInt32 numberFrames, UInt32 numberPlays);
    [CompilerGeneratedAttribute]
public UInt32 get_NumberFrames();
    [CompilerGeneratedAttribute]
public UInt32 get_NumberPlays();
    public void WriteTo(Span`1<byte> buffer);
    public static AnimationControl Parse(ReadOnlySpan`1<byte> data);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Png.Chunks.FrameControl : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private UInt32 <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <XOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <YOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DelayNumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DelayDenominator>k__BackingField;
    [CompilerGeneratedAttribute]
private PngDisposalMethod <DisposeOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private PngBlendMethod <BlendOperation>k__BackingField;
    public UInt32 SequenceNumber { get; }
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public UInt32 XOffset { get; }
    public UInt32 YOffset { get; }
    public UInt32 XMax { get; }
    public UInt32 YMax { get; }
    public ushort DelayNumerator { get; }
    public ushort DelayDenominator { get; }
    public PngDisposalMethod DisposeOperation { get; }
    public PngBlendMethod BlendOperation { get; }
    public Rectangle Bounds { get; }
    public FrameControl(UInt32 width, UInt32 height);
    public FrameControl(UInt32 sequenceNumber, UInt32 width, UInt32 height, UInt32 xOffset, UInt32 yOffset, ushort delayNumerator, ushort delayDenominator, PngDisposalMethod disposeOperation, PngBlendMethod blendOperation);
    [CompilerGeneratedAttribute]
public UInt32 get_SequenceNumber();
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public UInt32 get_XOffset();
    [CompilerGeneratedAttribute]
public UInt32 get_YOffset();
    public UInt32 get_XMax();
    public UInt32 get_YMax();
    [CompilerGeneratedAttribute]
public ushort get_DelayNumerator();
    [CompilerGeneratedAttribute]
public ushort get_DelayDenominator();
    [CompilerGeneratedAttribute]
public PngDisposalMethod get_DisposeOperation();
    [CompilerGeneratedAttribute]
public PngBlendMethod get_BlendOperation();
    public Rectangle get_Bounds();
    public void Validate(PngHeader header);
    public void WriteTo(Span`1<byte> buffer);
    public static FrameControl Parse(ReadOnlySpan`1<byte> data);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Png.Chunks.PngHeader : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <BitDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private PngColorType <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <FilterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private PngInterlaceMode <InterlaceMethod>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    public byte BitDepth { get; }
    public PngColorType ColorType { get; }
    public byte CompressionMethod { get; }
    public byte FilterMethod { get; }
    public PngInterlaceMode InterlaceMethod { get; }
    public PngHeader(int width, int height, byte bitDepth, PngColorType colorType, byte compressionMethod, byte filterMethod, PngInterlaceMode interlaceMethod);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public byte get_BitDepth();
    [CompilerGeneratedAttribute]
public PngColorType get_ColorType();
    [CompilerGeneratedAttribute]
public byte get_CompressionMethod();
    [CompilerGeneratedAttribute]
public byte get_FilterMethod();
    [CompilerGeneratedAttribute]
public PngInterlaceMode get_InterlaceMethod();
    public void Validate();
    public void WriteTo(Span`1<byte> buffer);
    public static PngHeader Parse(ReadOnlySpan`1<byte> data);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Png.Chunks.PngPhysical : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private UInt32 <XAxisPixelsPerUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <YAxisPixelsPerUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnitSpecifier>k__BackingField;
    public UInt32 XAxisPixelsPerUnit { get; }
    public UInt32 YAxisPixelsPerUnit { get; }
    public byte UnitSpecifier { get; }
    public PngPhysical(UInt32 x, UInt32 y, byte unitSpecifier);
    [CompilerGeneratedAttribute]
public UInt32 get_XAxisPixelsPerUnit();
    [CompilerGeneratedAttribute]
public UInt32 get_YAxisPixelsPerUnit();
    [CompilerGeneratedAttribute]
public byte get_UnitSpecifier();
    public static PngPhysical Parse(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public static PngPhysical FromMetadata(ImageMetadata meta);
    public void WriteTo(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Formats.Png.Chunks.PngTextData : ValueType {
    [CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TranslatedKeyword>k__BackingField;
    public string Keyword { get; }
    public string Value { get; }
    public string LanguageTag { get; }
    public string TranslatedKeyword { get; }
    public PngTextData(string keyword, string value, string languageTag, string translatedKeyword);
    [CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_LanguageTag();
    [CompilerGeneratedAttribute]
public string get_TranslatedKeyword();
    public static bool op_Equality(PngTextData left, PngTextData right);
    public static bool op_Inequality(PngTextData left, PngTextData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(PngTextData other);
}
internal static class SixLabors.ImageSharp.Formats.Png.Filters.AverageFilter : object {
    public static void Decode(Span`1<byte> scanline, Span`1<byte> previousScanline, int bytesPerPixel);
    private static void DecodeSse2(Span`1<byte> scanline, Span`1<byte> previousScanline);
    public static void DecodeArm(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeScalar(Span`1<byte> scanline, Span`1<byte> previousScanline, UInt32 bytesPerPixel);
    public static void Encode(ReadOnlySpan`1<byte> scanline, ReadOnlySpan`1<byte> previousScanline, Span`1<byte> result, UInt32 bytesPerPixel, Int32& sum);
    private static int Average(byte left, byte above);
}
internal enum SixLabors.ImageSharp.Formats.Png.Filters.FilterType : Enum {
    public int value__;
    public static FilterType None;
    public static FilterType Sub;
    public static FilterType Up;
    public static FilterType Average;
    public static FilterType Paeth;
}
internal static class SixLabors.ImageSharp.Formats.Png.Filters.NoneFilter : object {
    public static void Encode(ReadOnlySpan`1<byte> scanline, Span`1<byte> result);
}
internal static class SixLabors.ImageSharp.Formats.Png.Filters.PaethFilter : object {
    public static void Decode(Span`1<byte> scanline, Span`1<byte> previousScanline, int bytesPerPixel);
    private static void DecodeSsse3(Span`1<byte> scanline, Span`1<byte> previousScanline);
    public static void DecodeArm(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeScalar(Span`1<byte> scanline, Span`1<byte> previousScanline, UInt32 bytesPerPixel);
    public static void Encode(ReadOnlySpan`1<byte> scanline, ReadOnlySpan`1<byte> previousScanline, Span`1<byte> result, int bytesPerPixel, Int32& sum);
    private static byte PaethPredictor(byte left, byte above, byte upperLeft);
    private static Vector256`1<byte> PaethPredictor(Vector256`1<byte> left, Vector256`1<byte> above, Vector256`1<byte> upleft);
    private static Vector`1<byte> PaethPredictor(Vector`1<byte> left, Vector`1<byte> above, Vector`1<byte> upperLeft);
    private static Vector`1<short> PaethPredictor(Vector`1<short> left, Vector`1<short> above, Vector`1<short> upperLeft);
}
internal static class SixLabors.ImageSharp.Formats.Png.Filters.SubFilter : object {
    public static void Decode(Span`1<byte> scanline, int bytesPerPixel);
    private static void DecodeSse2(Span`1<byte> scanline);
    public static void DecodeArm(Span`1<byte> scanline);
    private static void DecodeScalar(Span`1<byte> scanline, UIntPtr bytesPerPixel);
    public static void Encode(ReadOnlySpan`1<byte> scanline, ReadOnlySpan`1<byte> result, int bytesPerPixel, Int32& sum);
}
internal static class SixLabors.ImageSharp.Formats.Png.Filters.UpFilter : object {
    public static void Decode(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeAvx2(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeSse2(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeArm(Span`1<byte> scanline, Span`1<byte> previousScanline);
    private static void DecodeScalar(Span`1<byte> scanline, Span`1<byte> previousScanline);
    public static void Encode(ReadOnlySpan`1<byte> scanline, ReadOnlySpan`1<byte> previousScanline, Span`1<byte> result, Int32& sum);
}
public enum SixLabors.ImageSharp.Formats.Png.PngBitDepth : Enum {
    public byte value__;
    public static PngBitDepth Bit1;
    public static PngBitDepth Bit2;
    public static PngBitDepth Bit4;
    public static PngBitDepth Bit8;
    public static PngBitDepth Bit16;
}
public enum SixLabors.ImageSharp.Formats.Png.PngBlendMethod : Enum {
    public int value__;
    public static PngBlendMethod Source;
    public static PngBlendMethod Over;
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Png.PngChunk : ValueType {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private PngChunkType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Data>k__BackingField;
    public int Length { get; }
    public PngChunkType Type { get; }
    public IMemoryOwner`1<byte> Data { get; }
    public PngChunk(int length, PngChunkType type, IMemoryOwner`1<byte> data);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public PngChunkType get_Type();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_Data();
    public bool IsCritical(PngCrcChunkHandling handling);
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Formats.Png.PngChunkFilter : Enum {
    public int value__;
    public static PngChunkFilter None;
    public static PngChunkFilter ExcludePhysicalChunk;
    public static PngChunkFilter ExcludeGammaChunk;
    public static PngChunkFilter ExcludeExifChunk;
    public static PngChunkFilter ExcludeTextChunks;
    public static PngChunkFilter ExcludeAll;
}
internal enum SixLabors.ImageSharp.Formats.Png.PngChunkType : Enum {
    public UInt32 value__;
    public static PngChunkType Data;
    public static PngChunkType End;
    public static PngChunkType Header;
    public static PngChunkType Palette;
    public static PngChunkType Exif;
    public static PngChunkType Gamma;
    public static PngChunkType Physical;
    public static PngChunkType Text;
    public static PngChunkType CompressedText;
    public static PngChunkType InternationalText;
    public static PngChunkType Transparency;
    public static PngChunkType Time;
    public static PngChunkType Background;
    public static PngChunkType EmbeddedColorProfile;
    public static PngChunkType SignificantBits;
    public static PngChunkType StandardRgbColourSpace;
    public static PngChunkType Histogram;
    public static PngChunkType SuggestedPalette;
    public static PngChunkType Chroma;
    public static PngChunkType Cicp;
    public static PngChunkType AnimationControl;
    public static PngChunkType FrameControl;
    public static PngChunkType FrameData;
    public static PngChunkType ProprietaryApple;
}
public enum SixLabors.ImageSharp.Formats.Png.PngColorType : Enum {
    public byte value__;
    public static PngColorType Grayscale;
    public static PngColorType Rgb;
    public static PngColorType Palette;
    public static PngColorType GrayscaleWithAlpha;
    public static PngColorType RgbWithAlpha;
}
[EditorBrowsableAttribute("1")]
public enum SixLabors.ImageSharp.Formats.Png.PngCompressionLevel : Enum {
    public int value__;
    public static PngCompressionLevel Level0;
    public static PngCompressionLevel NoCompression;
    public static PngCompressionLevel Level1;
    public static PngCompressionLevel BestSpeed;
    public static PngCompressionLevel Level2;
    public static PngCompressionLevel Level3;
    public static PngCompressionLevel Level4;
    public static PngCompressionLevel Level5;
    public static PngCompressionLevel Level6;
    public static PngCompressionLevel DefaultCompression;
    public static PngCompressionLevel Level7;
    public static PngCompressionLevel Level8;
    public static PngCompressionLevel Level9;
    public static PngCompressionLevel BestCompression;
}
public class SixLabors.ImageSharp.Formats.Png.PngConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Png.PngConstants : object {
    public static Encoding Encoding;
    public static Encoding LanguageEncoding;
    public static Encoding TranslatedEncoding;
    public static IEnumerable`1<string> MimeTypes;
    public static IEnumerable`1<string> FileExtensions;
    public static ulong HeaderValue;
    public static Dictionary`2<PngColorType, Byte[]> ColorTypes;
    public static int MaxTextKeywordLength;
    public static int MinTextKeywordLength;
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> HeaderBytes { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> XmpKeyword { get; }
    private static PngConstants();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_HeaderBytes();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_XmpKeyword();
}
public enum SixLabors.ImageSharp.Formats.Png.PngCrcChunkHandling : Enum {
    public int value__;
    public static PngCrcChunkHandling IgnoreNone;
    public static PngCrcChunkHandling IgnoreNonCritical;
    public static PngCrcChunkHandling IgnoreData;
    public static PngCrcChunkHandling IgnoreAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SixLabors.ImageSharp.Formats.Png.PngDecoder : SpecializedImageDecoder`1<PngDecoderOptions> {
    [CompilerGeneratedAttribute]
private static PngDecoder <Instance>k__BackingField;
    public static PngDecoder Instance { get; }
    private static PngDecoder();
    [CompilerGeneratedAttribute]
public static PngDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(PngDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(PngDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual PngDecoderOptions CreateDefaultSpecializedOptions(DecoderOptions options);
}
internal class SixLabors.ImageSharp.Formats.Png.PngDecoderCore : object {
    [NullableAttribute("1")]
private Configuration configuration;
    private UInt32 maxFrames;
    private bool skipMetadata;
    private bool colorMetadataOnly;
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    [NullableAttribute("1")]
private BufferedReadStream currentStream;
    private PngHeader header;
    private AnimationControl animationControl;
    private int bytesPerPixel;
    private int bytesPerSample;
    private int bytesPerScanline;
    [NullableAttribute("1")]
private Byte[] palette;
    [NullableAttribute("1")]
private Byte[] paletteAlpha;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> previousScanline;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> scanline;
    private PngColorType pngColorType;
    private Nullable`1<PngChunk> nextChunk;
    private PngCrcChunkHandling pngCrcChunkHandling;
    private int maxUncompressedLength;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    [NullableContextAttribute("1")]
public PngDecoderCore(PngDecoderOptions options);
    [NullableContextAttribute("1")]
internal PngDecoderCore(PngDecoderOptions options, bool colorMetadataOnly);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private static byte ReadByteLittleEndian(ReadOnlySpan`1<byte> buffer, int offset);
    private bool TryScaleUpTo8BitArray(ReadOnlySpan`1<byte> source, int bytesPerScanline, int bits, IMemoryOwner`1& buffer);
    private static void ReadPhysicalChunk(ImageMetadata metadata, ReadOnlySpan`1<byte> data);
    private static void ReadGammaChunk(PngMetadata pngMetadata, ReadOnlySpan`1<byte> data);
    private void InitializeImage(ImageMetadata metadata, FrameControl frameControl, Image`1& image);
    private void InitializeFrame(Nullable`1<FrameControl> previousFrameControl, FrameControl currentFrameControl, Image`1<TPixel> image, ImageFrame`1<TPixel> previousFrame, ImageFrame`1& frame);
    private int CalculateBitsPerPixel();
    private int CalculateBytesPerPixel();
    private int CalculateScanlineLength(int width);
    [NullableContextAttribute("1")]
private void ReadScanlines(int chunkLength, ImageFrame`1<TPixel> image, PngMetadata pngMetadata, Func`1<int> getData, FrameControl& frameControl, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private void DecodePixelData(FrameControl frameControl, DeflateStream compressedStream, ImageFrame`1<TPixel> imageFrame, PngMetadata pngMetadata, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private void DecodeInterlacedPixelData(FrameControl& frameControl, DeflateStream compressedStream, ImageFrame`1<TPixel> imageFrame, PngMetadata pngMetadata, CancellationToken cancellationToken);
    private void ProcessDefilteredScanline(FrameControl& frameControl, int currentRow, ReadOnlySpan`1<byte> scanline, ImageFrame`1<TPixel> pixels, PngMetadata pngMetadata, Span`1<TPixel> blendRowBuffer);
    private void ProcessInterlacedDefilteredScanline(FrameControl& frameControl, ReadOnlySpan`1<byte> scanline, Span`1<TPixel> destination, PngMetadata pngMetadata, Span`1<TPixel> blendRowBuffer, int pixelOffset, int increment);
    private static void AssignColorPalette(ReadOnlySpan`1<byte> palette, ReadOnlySpan`1<byte> alpha, PngMetadata pngMetadata);
    private void AssignTransparentMarkers(ReadOnlySpan`1<byte> alpha, PngMetadata pngMetadata);
    private void ReadAnimationControlChunk(PngMetadata pngMetadata, ReadOnlySpan`1<byte> data);
    private FrameControl ReadFrameControlChunk(ReadOnlySpan`1<byte> data);
    private void ReadHeaderChunk(PngMetadata pngMetadata, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
private void ReadTextChunk(ImageMetadata baseMetadata, PngMetadata metadata, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
private void ReadCompressedTextChunk(ImageMetadata baseMetadata, PngMetadata metadata, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
private static bool TryReadTextChunkMetadata(ImageMetadata baseMetadata, string chunkName, string chunkText);
    private static void ReadCicpChunk(ImageMetadata metadata, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
private static bool TryReadLegacyExifTextChunk(ImageMetadata metadata, string data);
    private void ReadColorProfileChunk(ImageMetadata metadata, ReadOnlySpan`1<byte> data);
    private bool TryDecompressZlibData(ReadOnlySpan`1<byte> compressedData, int maxLength, Byte[]& uncompressedBytesArray);
    private static bool StringEqualsInsensitive(ReadOnlySpan`1<char> span1, ReadOnlySpan`1<char> span2);
    private static int ParseInt32(ReadOnlySpan`1<char> span);
    [NullableContextAttribute("1")]
private static void MergeOrSetExifProfile(ImageMetadata metadata, ExifProfile newProfile, bool replaceExistingKeys);
    private void ReadInternationalTextChunk(ImageMetadata metadata, ReadOnlySpan`1<byte> data);
    private bool TryDecompressTextData(ReadOnlySpan`1<byte> compressedData, Encoding encoding, String& value);
    private int ReadNextDataChunk();
    private int ReadNextFrameDataChunk();
    private bool TryReadChunk(Span`1<byte> buffer, PngChunk& chunk);
    private void ValidateChunk(PngChunk& chunk, Span`1<byte> buffer);
    private UInt32 ReadChunkCrc(Span`1<byte> buffer);
    private void SkipChunkDataAndCrc(PngChunk& chunk);
    [NullableContextAttribute("1")]
private IMemoryOwner`1<byte> ReadChunkData(int length);
    private PngChunkType ReadChunkType(Span`1<byte> buffer);
    private bool TryReadChunkLength(Span`1<byte> buffer, Int32& result);
    private static bool TryReadTextKeyword(ReadOnlySpan`1<byte> keywordBytes, String& name);
    private static bool IsXmpTextData(ReadOnlySpan`1<byte> keywordBytes);
    private void SwapScanlineBuffers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Png.PngDecoderOptions : object {
    [CompilerGeneratedAttribute]
private DecoderOptions <GeneralOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private PngCrcChunkHandling <PngCrcChunkHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxUncompressedAncillaryChunkSizeBytes>k__BackingField;
    public DecoderOptions GeneralOptions { get; public set; }
    public PngCrcChunkHandling PngCrcChunkHandling { get; public set; }
    public int MaxUncompressedAncillaryChunkSizeBytes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_GeneralOptions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GeneralOptions(DecoderOptions value);
    [CompilerGeneratedAttribute]
public PngCrcChunkHandling get_PngCrcChunkHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PngCrcChunkHandling(PngCrcChunkHandling value);
    [CompilerGeneratedAttribute]
public int get_MaxUncompressedAncillaryChunkSizeBytes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaxUncompressedAncillaryChunkSizeBytes(int value);
}
public enum SixLabors.ImageSharp.Formats.Png.PngDisposalMethod : Enum {
    public int value__;
    public static PngDisposalMethod DoNotDispose;
    public static PngDisposalMethod RestoreToBackground;
    public static PngDisposalMethod RestoreToPrevious;
}
public class SixLabors.ImageSharp.Formats.Png.PngEncoder : QuantizingImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<PngBitDepth> <BitDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngColorType> <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngFilterMethod> <FilterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private PngCompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TextCompressionThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Gamma>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngInterlaceMode> <InterlaceMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngChunkFilter> <ChunkFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private PngTransparentColorMode <TransparentColorMode>k__BackingField;
    public Nullable`1<PngBitDepth> BitDepth { get; public set; }
    public Nullable`1<PngColorType> ColorType { get; public set; }
    public Nullable`1<PngFilterMethod> FilterMethod { get; public set; }
    public PngCompressionLevel CompressionLevel { get; public set; }
    public int TextCompressionThreshold { get; public set; }
    public Nullable`1<float> Gamma { get; public set; }
    public byte Threshold { get; public set; }
    public Nullable`1<PngInterlaceMode> InterlaceMethod { get; public set; }
    public Nullable`1<PngChunkFilter> ChunkFilter { get; public set; }
    public PngTransparentColorMode TransparentColorMode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<PngBitDepth> get_BitDepth();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitDepth(Nullable`1<PngBitDepth> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngColorType> get_ColorType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorType(Nullable`1<PngColorType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngFilterMethod> get_FilterMethod();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilterMethod(Nullable`1<PngFilterMethod> value);
    [CompilerGeneratedAttribute]
public PngCompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CompressionLevel(PngCompressionLevel value);
    [CompilerGeneratedAttribute]
public int get_TextCompressionThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextCompressionThreshold(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Gamma();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Gamma(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public byte get_Threshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Threshold(byte value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngInterlaceMode> get_InterlaceMethod();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InterlaceMethod(Nullable`1<PngInterlaceMode> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngChunkFilter> get_ChunkFilter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChunkFilter(Nullable`1<PngChunkFilter> value);
    [CompilerGeneratedAttribute]
public PngTransparentColorMode get_TransparentColorMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TransparentColorMode(PngTransparentColorMode value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Png.PngEncoderCore : object {
    private static int MaxBlockSize;
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    [NullableAttribute("1")]
private Configuration configuration;
    private ScratchBuffer chunkDataBuffer;
    [NullableAttribute("1")]
private PngEncoder encoder;
    private Nullable`1<float> gamma;
    private PngColorType colorType;
    private byte bitDepth;
    private PngFilterMethod filterMethod;
    private PngInterlaceMode interlaceMode;
    private PngChunkFilter chunkFilter;
    private bool use16Bit;
    private int bytesPerPixel;
    private int width;
    private int height;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> previousScanline;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> currentScanline;
    [NullableAttribute("1")]
private static string ColorProfileName;
    [NullableAttribute("2")]
private IQuantizer quantizer;
    private int derivedTransparencyIndex;
    [NullableContextAttribute("1")]
public PngEncoderCore(Configuration configuration, PngEncoder encoder);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private static PngMetadata GetPngMetadata(Image`1<TPixel> image);
    private static PngFrameMetadata GetPngFrameMetadata(ImageFrame`1<TPixel> frame);
    private static void ClearTransparentPixels(ImageFrame`1<TPixel> clone);
    private IndexedImageFrame`1<TPixel> CreateQuantizedImageAndUpdateBitDepth(PngMetadata metadata, ImageFrame`1<TPixel> frame, Rectangle bounds, Nullable`1<ReadOnlyMemory`1<TPixel>> previousPalette);
    private void CollectGrayscaleBytes(ReadOnlySpan`1<TPixel> rowSpan);
    private void CollectTPixelBytes(ReadOnlySpan`1<TPixel> rowSpan);
    private void CollectPixelBytes(ReadOnlySpan`1<TPixel> rowSpan, IndexedImageFrame`1<TPixel> quantized, int row);
    private void FilterPixelBytes(Span`1& filter, Span`1& attempt);
    private void CollectAndFilterPixelRow(ReadOnlySpan`1<TPixel> rowSpan, Span`1& filter, Span`1& attempt, IndexedImageFrame`1<TPixel> quantized, int row);
    private void EncodeAdam7IndexedPixelRow(ReadOnlySpan`1<byte> row, Span`1& filter, Span`1& attempt);
    private void ApplyOptimalFilteredScanline(Span`1& filter, Span`1& attempt);
    [NullableContextAttribute("1")]
private void WriteHeaderChunk(Stream stream);
    [NullableContextAttribute("1")]
private void WriteAnimationControlChunk(Stream stream, UInt32 framesCount, UInt32 playsCount);
    private void WritePaletteChunk(Stream stream, IndexedImageFrame`1<TPixel> quantized);
    [NullableContextAttribute("1")]
private void WritePhysicalChunk(Stream stream, ImageMetadata meta);
    [NullableContextAttribute("1")]
private void WriteExifChunk(Stream stream, ImageMetadata meta);
    [NullableContextAttribute("1")]
private void WriteXmpChunk(Stream stream, ImageMetadata meta);
    [NullableContextAttribute("1")]
private void WriteCicpChunk(Stream stream, ImageMetadata metaData);
    [NullableContextAttribute("1")]
private void WriteColorProfileChunk(Stream stream, ImageMetadata metaData);
    [NullableContextAttribute("1")]
private void WriteTextChunks(Stream stream, PngMetadata meta);
    [NullableContextAttribute("1")]
private Byte[] GetZlibCompressedBytes(Byte[] dataBytes);
    [NullableContextAttribute("1")]
private void WriteGammaChunk(Stream stream);
    [NullableContextAttribute("1")]
private void WriteTransparencyChunk(Stream stream, PngMetadata pngMetadata);
    [NullableContextAttribute("1")]
private FrameControl WriteFrameControlChunk(Stream stream, PngFrameMetadata frameMetadata, Rectangle bounds, UInt32 sequenceNumber);
    private UInt32 WriteDataChunks(FrameControl frameControl, Buffer2DRegion`1<TPixel> frame, IndexedImageFrame`1<TPixel> quantized, Stream stream, bool isFrame);
    private void AllocateScanlineBuffers(int bytesPerScanline);
    private void EncodePixels(Buffer2DRegion`1<TPixel> pixels, IndexedImageFrame`1<TPixel> quantized, ZlibDeflateStream deflateStream);
    private void EncodeAdam7Pixels(Buffer2DRegion`1<TPixel> pixels, ZlibDeflateStream deflateStream);
    private void EncodeAdam7IndexedPixels(IndexedImageFrame`1<TPixel> quantized, ZlibDeflateStream deflateStream);
    [NullableContextAttribute("1")]
private void WriteEndChunk(Stream stream);
    private void WriteChunk(Stream stream, PngChunkType type, Span`1<byte> data);
    private void WriteChunk(Stream stream, PngChunkType type, Span`1<byte> data, int offset, int length);
    private void WriteFrameDataChunk(Stream stream, UInt32 sequenceNumber, Span`1<byte> data, int offset, int length);
    private int CalculateScanlineLength(int width);
    private void SwapScanlineBuffers();
    [NullableContextAttribute("1")]
private void SanitizeAndSetEncoderOptions(PngEncoder encoder, PngMetadata pngMetadata, Boolean& use16Bit, Int32& bytesPerPixel);
    private IndexedImageFrame`1<TPixel> CreateQuantizedFrame(QuantizingImageEncoder encoder, PngColorType colorType, byte bitDepth, PngMetadata metadata, ImageFrame`1<TPixel> frame, Rectangle bounds, Nullable`1<ReadOnlyMemory`1<TPixel>> previousPalette);
    private static byte CalculateBitDepth(PngColorType colorType, byte bitDepth, IndexedImageFrame`1<TPixel> quantizedFrame);
    private static int CalculateBytesPerPixel(Nullable`1<PngColorType> pngColorType, bool use16Bit);
    private static PngColorType SuggestColorType();
    private static PngBitDepth SuggestBitDepth();
}
internal static class SixLabors.ImageSharp.Formats.Png.PngEncoderHelpers : object {
    public static void ScaleDownFrom8BitArray(ReadOnlySpan`1<byte> source, Span`1<byte> result, int bits, float scale);
}
public enum SixLabors.ImageSharp.Formats.Png.PngFilterMethod : Enum {
    public int value__;
    public static PngFilterMethod None;
    public static PngFilterMethod Sub;
    public static PngFilterMethod Up;
    public static PngFilterMethod Average;
    public static PngFilterMethod Paeth;
    public static PngFilterMethod Adaptive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Png.PngFormat : object {
    [CompilerGeneratedAttribute]
private static PngFormat <Instance>k__BackingField;
    public static PngFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static PngFormat();
    [CompilerGeneratedAttribute]
public static PngFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual PngMetadata CreateDefaultFormatMetadata();
    public sealed virtual PngFrameMetadata CreateDefaultFormatFrameMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Png.PngFrameMetadata : object {
    [CompilerGeneratedAttribute]
private Rational <FrameDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private PngDisposalMethod <DisposalMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private PngBlendMethod <BlendMethod>k__BackingField;
    public Rational FrameDelay { get; public set; }
    public PngDisposalMethod DisposalMethod { get; public set; }
    public PngBlendMethod BlendMethod { get; public set; }
    private PngFrameMetadata(PngFrameMetadata other);
    [CompilerGeneratedAttribute]
public Rational get_FrameDelay();
    [CompilerGeneratedAttribute]
public void set_FrameDelay(Rational value);
    [CompilerGeneratedAttribute]
public PngDisposalMethod get_DisposalMethod();
    [CompilerGeneratedAttribute]
public void set_DisposalMethod(PngDisposalMethod value);
    [CompilerGeneratedAttribute]
public PngBlendMethod get_BlendMethod();
    [CompilerGeneratedAttribute]
public void set_BlendMethod(PngBlendMethod value);
    internal void FromChunk(FrameControl& frameControl);
    public sealed virtual IDeepCloneable DeepClone();
    internal static PngFrameMetadata FromAnimatedMetadata(AnimatedImageFrameMetadata metadata);
    private static PngDisposalMethod GetMode(FrameDisposalMode mode);
}
public class SixLabors.ImageSharp.Formats.Png.PngImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
public enum SixLabors.ImageSharp.Formats.Png.PngInterlaceMode : Enum {
    public byte value__;
    public static PngInterlaceMode None;
    public static PngInterlaceMode Adam7;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Png.PngMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<PngBitDepth> <BitDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngColorType> <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PngInterlaceMode> <InterlaceMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Gamma>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<Color>> <ColorTable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <TransparentColor>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PngTextData> <TextData>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RepeatCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnimateRootFrame>k__BackingField;
    public Nullable`1<PngBitDepth> BitDepth { get; public set; }
    public Nullable`1<PngColorType> ColorType { get; public set; }
    public Nullable`1<PngInterlaceMode> InterlaceMethod { get; public set; }
    public float Gamma { get; public set; }
    [NullableAttribute("0")]
public Nullable`1<ReadOnlyMemory`1<Color>> ColorTable { get; public set; }
    public Nullable`1<Color> TransparentColor { get; public set; }
    public IList`1<PngTextData> TextData { get; public set; }
    public UInt32 RepeatCount { get; public set; }
    public bool AnimateRootFrame { get; public set; }
    private PngMetadata(PngMetadata other);
    [CompilerGeneratedAttribute]
public Nullable`1<PngBitDepth> get_BitDepth();
    [CompilerGeneratedAttribute]
public void set_BitDepth(Nullable`1<PngBitDepth> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngColorType> get_ColorType();
    [CompilerGeneratedAttribute]
public void set_ColorType(Nullable`1<PngColorType> value);
    [CompilerGeneratedAttribute]
public Nullable`1<PngInterlaceMode> get_InterlaceMethod();
    [CompilerGeneratedAttribute]
public void set_InterlaceMethod(Nullable`1<PngInterlaceMode> value);
    [CompilerGeneratedAttribute]
public float get_Gamma();
    [CompilerGeneratedAttribute]
public void set_Gamma(float value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<Color>> get_ColorTable();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_ColorTable(Nullable`1<ReadOnlyMemory`1<Color>> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_TransparentColor();
    [CompilerGeneratedAttribute]
public void set_TransparentColor(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
public IList`1<PngTextData> get_TextData();
    [CompilerGeneratedAttribute]
public void set_TextData(IList`1<PngTextData> value);
    [CompilerGeneratedAttribute]
public UInt32 get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_AnimateRootFrame();
    [CompilerGeneratedAttribute]
public void set_AnimateRootFrame(bool value);
    public sealed virtual IDeepCloneable DeepClone();
    internal static PngMetadata FromAnimatedMetadata(AnimatedImageMetadata metadata);
}
internal static class SixLabors.ImageSharp.Formats.Png.PngScanlineProcessor : object {
    public static void ProcessGrayscaleScanline(int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, Nullable`1<Color> transparentColor);
    public static void ProcessInterlacedGrayscaleScanline(int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 pixelOffset, UInt32 increment, Nullable`1<Color> transparentColor);
    public static void ProcessGrayscaleWithAlphaScanline(int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 bytesPerPixel, UInt32 bytesPerSample);
    public static void ProcessInterlacedGrayscaleWithAlphaScanline(int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 pixelOffset, UInt32 increment, UInt32 bytesPerPixel, UInt32 bytesPerSample);
    public static void ProcessPaletteScanline(FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, Nullable`1<ReadOnlyMemory`1<Color>> palette);
    public static void ProcessInterlacedPaletteScanline(FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 pixelOffset, UInt32 increment, Nullable`1<ReadOnlyMemory`1<Color>> palette);
    public static void ProcessRgbScanline(Configuration configuration, int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, int bytesPerPixel, int bytesPerSample, Nullable`1<Color> transparentColor);
    public static void ProcessInterlacedRgbScanline(Configuration configuration, int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 pixelOffset, UInt32 increment, int bytesPerPixel, int bytesPerSample, Nullable`1<Color> transparentColor);
    public static void ProcessRgbaScanline(Configuration configuration, int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, int bytesPerPixel, int bytesPerSample);
    public static void ProcessInterlacedRgbaScanline(Configuration configuration, int bitDepth, FrameControl& frameControl, ReadOnlySpan`1<byte> scanlineSpan, Span`1<TPixel> rowSpan, UInt32 pixelOffset, UInt32 increment, int bytesPerPixel, int bytesPerSample);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Png.PngThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowInvalidImageContentException(string errorMessage, Exception innerException);
    [DoesNotReturnAttribute]
public static void ThrowInvalidHeader();
    [DoesNotReturnAttribute]
public static void ThrowNoData();
    [DoesNotReturnAttribute]
public static void ThrowMissingDefaultData();
    [DoesNotReturnAttribute]
public static void ThrowInvalidAnimationControl();
    [DoesNotReturnAttribute]
public static void ThrowMissingFrameControl();
    [DoesNotReturnAttribute]
public static void ThrowMissingPalette();
    [DoesNotReturnAttribute]
public static void ThrowInvalidChunkType();
    [DoesNotReturnAttribute]
public static void ThrowInvalidChunkType(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidChunkCrc(string chunkTypeName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidParameter(object value, string message, string name);
    [DoesNotReturnAttribute]
public static void ThrowInvalidParameter(object value1, object value2, string message, string name1, string name2);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedColor();
    [DoesNotReturnAttribute]
public static void ThrowUnknownFilter();
}
public enum SixLabors.ImageSharp.Formats.Png.PngTransparentColorMode : Enum {
    public int value__;
    public static PngTransparentColorMode Preserve;
    public static PngTransparentColorMode Clear;
}
public enum SixLabors.ImageSharp.Formats.Qoi.QoiChannels : Enum {
    public int value__;
    public static QoiChannels Rgb;
    public static QoiChannels Rgba;
}
internal enum SixLabors.ImageSharp.Formats.Qoi.QoiChunk : Enum {
    public int value__;
    public static QoiChunk QoiOpRgb;
    public static QoiChunk QoiOpRgba;
    public static QoiChunk QoiOpIndex;
    public static QoiChunk QoiOpDiff;
    public static QoiChunk QoiOpLuma;
    public static QoiChunk QoiOpRun;
}
public enum SixLabors.ImageSharp.Formats.Qoi.QoiColorSpace : Enum {
    public int value__;
    public static QoiColorSpace SrgbWithLinearAlpha;
    public static QoiColorSpace AllChannelsLinear;
}
public class SixLabors.ImageSharp.Formats.Qoi.QoiConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Qoi.QoiConstants : object {
    private static Byte[] SMagic;
    [CompilerGeneratedAttribute]
private static String[] <MimeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static String[] <FileExtensions>k__BackingField;
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> Magic { get; }
    public static String[] MimeTypes { get; }
    public static String[] FileExtensions { get; }
    private static QoiConstants();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_Magic();
    [CompilerGeneratedAttribute]
public static String[] get_MimeTypes();
    [CompilerGeneratedAttribute]
public static String[] get_FileExtensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Qoi.QoiDecoder : ImageDecoder {
    [CompilerGeneratedAttribute]
private static QoiDecoder <Instance>k__BackingField;
    public static QoiDecoder Instance { get; }
    private static QoiDecoder();
    [CompilerGeneratedAttribute]
public static QoiDecoder get_Instance();
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Qoi.QoiDecoderCore : object {
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private QoiHeader header;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Dimensions>k__BackingField;
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public QoiDecoderCore(DecoderOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual Size get_Dimensions();
    [NullableContextAttribute("0")]
public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private void ProcessHeader(BufferedReadStream stream);
    [DoesNotReturnAttribute]
private static void ThrowInvalidImageContentException();
    [NullableContextAttribute("0")]
private void ProcessPixels(BufferedReadStream stream, Buffer2D`1<TPixel> pixels);
    private static int GetArrayPosition(Rgba32 pixel);
}
public class SixLabors.ImageSharp.Formats.Qoi.QoiEncoder : ImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<QoiChannels> <Channels>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<QoiColorSpace> <ColorSpace>k__BackingField;
    public Nullable`1<QoiChannels> Channels { get; public set; }
    public Nullable`1<QoiColorSpace> ColorSpace { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<QoiChannels> get_Channels();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Channels(Nullable`1<QoiChannels> value);
    [CompilerGeneratedAttribute]
public Nullable`1<QoiColorSpace> get_ColorSpace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorSpace(Nullable`1<QoiColorSpace> value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Qoi.QoiEncoderCore : object {
    private QoiEncoder encoder;
    private MemoryAllocator memoryAllocator;
    private Configuration configuration;
    public QoiEncoderCore(QoiEncoder encoder, Configuration configuration);
    [NullableContextAttribute("0")]
public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    private void WriteHeader(Image image, Stream stream);
    [NullableContextAttribute("0")]
private void WritePixels(Image`1<TPixel> image, Stream stream);
    private static void WriteEndOfStream(Stream stream);
    private static int GetArrayPosition(Rgba32 pixel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Qoi.QoiFormat : object {
    [CompilerGeneratedAttribute]
private static QoiFormat <Instance>k__BackingField;
    public static QoiFormat Instance { get; }
    public string DefaultMimeType { get; }
    public string Name { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static QoiFormat();
    [CompilerGeneratedAttribute]
public static QoiFormat get_Instance();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual QoiMetadata CreateDefaultFormatMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Qoi.QoiHeader : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private QoiChannels <Channels>k__BackingField;
    [CompilerGeneratedAttribute]
private QoiColorSpace <ColorSpace>k__BackingField;
    public Byte[] Magic { get; }
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public QoiChannels Channels { get; }
    public QoiColorSpace ColorSpace { get; }
    public QoiHeader(UInt32 width, UInt32 height, QoiChannels channels, QoiColorSpace colorSpace);
    [CompilerGeneratedAttribute]
public Byte[] get_Magic();
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public QoiChannels get_Channels();
    [CompilerGeneratedAttribute]
public QoiColorSpace get_ColorSpace();
}
public class SixLabors.ImageSharp.Formats.Qoi.QoiImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
public class SixLabors.ImageSharp.Formats.Qoi.QoiMetadata : object {
    [CompilerGeneratedAttribute]
private QoiChannels <Channels>k__BackingField;
    [CompilerGeneratedAttribute]
private QoiColorSpace <ColorSpace>k__BackingField;
    public QoiChannels Channels { get; public set; }
    public QoiColorSpace ColorSpace { get; public set; }
    [NullableContextAttribute("1")]
private QoiMetadata(QoiMetadata other);
    [CompilerGeneratedAttribute]
public QoiChannels get_Channels();
    [CompilerGeneratedAttribute]
public void set_Channels(QoiChannels value);
    [CompilerGeneratedAttribute]
public QoiColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
public void set_ColorSpace(QoiColorSpace value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Formats.QuantizingImageEncoder : ImageEncoder {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IQuantizer <Quantizer>k__BackingField;
    [CompilerGeneratedAttribute]
private IPixelSamplingStrategy <PixelSamplingStrategy>k__BackingField;
    [NullableAttribute("2")]
public IQuantizer Quantizer { get; public set; }
    public IPixelSamplingStrategy PixelSamplingStrategy { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IQuantizer get_Quantizer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Quantizer(IQuantizer value);
    [CompilerGeneratedAttribute]
public IPixelSamplingStrategy get_PixelSamplingStrategy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PixelSamplingStrategy(IPixelSamplingStrategy value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Formats.SpecializedImageDecoder`1 : ImageDecoder {
    public sealed virtual Image`1<TPixel> Decode(T options, Stream stream);
    public sealed virtual Image Decode(T options, Stream stream);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.SpecializedImageDecoder`1/<DecodeAsync>d__2`1")]
public sealed virtual Task`1<Image`1<TPixel>> DecodeAsync(T options, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Formats.SpecializedImageDecoder`1/<DecodeAsync>d__3")]
public sealed virtual Task`1<Image> DecodeAsync(T options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual Image`1<TPixel> Decode(T options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual Image Decode(T options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected abstract virtual T CreateDefaultSpecializedOptions(DecoderOptions options);
}
public enum SixLabors.ImageSharp.Formats.Tga.TgaBitsPerPixel : Enum {
    public byte value__;
    public static TgaBitsPerPixel Pixel8;
    public static TgaBitsPerPixel Pixel16;
    public static TgaBitsPerPixel Pixel24;
    public static TgaBitsPerPixel Pixel32;
}
public enum SixLabors.ImageSharp.Formats.Tga.TgaCompression : Enum {
    public int value__;
    public static TgaCompression None;
    public static TgaCompression RunLength;
}
public class SixLabors.ImageSharp.Formats.Tga.TgaConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Tga.TgaConstants : object {
    public static IEnumerable`1<string> MimeTypes;
    public static IEnumerable`1<string> FileExtensions;
    public static int FileHeaderLength;
    private static TgaConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Tga.TgaDecoder : ImageDecoder {
    [CompilerGeneratedAttribute]
private static TgaDecoder <Instance>k__BackingField;
    public static TgaDecoder Instance { get; }
    private static TgaDecoder();
    [CompilerGeneratedAttribute]
public static TgaDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Tga.TgaDecoderCore : object {
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableAttribute("2")]
private ImageMetadata metadata;
    [NullableAttribute("2")]
private TgaMetadata tgaMetadata;
    private TgaFileHeader fileHeader;
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    private bool hasAlpha;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    [NullableContextAttribute("1")]
public TgaDecoderCore(DecoderOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    private void ReadPaletted(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, Span`1<byte> palette, int colorMapPixelSizeInBytes, TgaImageOrigin origin);
    private void ReadPalettedRle(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, Span`1<byte> palette, int colorMapPixelSizeInBytes, TgaImageOrigin origin);
    private void ReadMonoChrome(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, TgaImageOrigin origin);
    private void ReadBgra16(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, TgaImageOrigin origin);
    private void ReadBgr24(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, TgaImageOrigin origin);
    private void ReadBgra32(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, TgaImageOrigin origin);
    private void ReadRle(BufferedReadStream stream, int width, int height, Buffer2D`1<TPixel> pixels, int bytesPerPixel, TgaImageOrigin origin);
    [NullableContextAttribute("1")]
public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private void ReadL8Row(BufferedReadStream stream, int width, Buffer2D`1<TPixel> pixels, Span`1<byte> row, int y);
    private static void ReadL8Pixel(BufferedReadStream stream, TPixel color, int x, Span`1<TPixel> pixelSpan);
    private static void ReadBgr24Pixel(BufferedReadStream stream, TPixel color, int x, Span`1<TPixel> pixelSpan, Span`1<byte> scratchBuffer);
    private void ReadBgr24Row(BufferedReadStream stream, int width, Buffer2D`1<TPixel> pixels, Span`1<byte> row, int y);
    private void ReadBgra32Pixel(BufferedReadStream stream, int x, TPixel color, Span`1<TPixel> pixelRow, Span`1<byte> scratchBuffer);
    private void ReadBgra32Row(BufferedReadStream stream, int width, Buffer2D`1<TPixel> pixels, Span`1<byte> row, int y);
    private void ReadPalettedBgra16Pixel(BufferedReadStream stream, Span`1<byte> palette, int colorMapPixelSizeInBytes, int x, TPixel color, Span`1<TPixel> pixelRow);
    private void ReadPalettedBgra16Pixel(Span`1<byte> palette, int index, int colorMapPixelSizeInBytes, TPixel& color);
    private static void ReadPalettedBgr24Pixel(BufferedReadStream stream, Span`1<byte> palette, int colorMapPixelSizeInBytes, int x, TPixel color, Span`1<TPixel> pixelRow);
    private static void ReadPalettedBgra32Pixel(BufferedReadStream stream, Span`1<byte> palette, int colorMapPixelSizeInBytes, int x, TPixel color, Span`1<TPixel> pixelRow);
    private void UncompressRle(BufferedReadStream stream, int width, int height, Span`1<byte> buffer, int bytesPerPixel);
    private static int InvertY(int y, int height, TgaImageOrigin origin);
    private static bool InvertY(TgaImageOrigin origin);
    private static int InvertX(int x, int width, TgaImageOrigin origin);
    private static bool InvertX(TgaImageOrigin origin);
    [NullableContextAttribute("1")]
[MemberNotNullAttribute("metadata")]
[MemberNotNullAttribute("tgaMetadata")]
private TgaImageOrigin ReadFileHeader(BufferedReadStream stream);
}
public class SixLabors.ImageSharp.Formats.Tga.TgaEncoder : ImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<TgaBitsPerPixel> <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private TgaCompression <Compression>k__BackingField;
    public Nullable`1<TgaBitsPerPixel> BitsPerPixel { get; public set; }
    public TgaCompression Compression { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TgaBitsPerPixel> get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitsPerPixel(Nullable`1<TgaBitsPerPixel> value);
    [CompilerGeneratedAttribute]
public TgaCompression get_Compression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Compression(TgaCompression value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Tga.TgaEncoderCore : object {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    private Nullable`1<TgaBitsPerPixel> bitsPerPixel;
    private TgaCompression compression;
    [NullableContextAttribute("1")]
public TgaEncoderCore(TgaEncoder encoder, MemoryAllocator memoryAllocator);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private void WriteImage(Configuration configuration, Stream stream, ImageFrame`1<TPixel> image);
    private void WriteRunLengthEncodedImage(Stream stream, ImageFrame`1<TPixel> image);
    private void WritePixel(Stream stream, TPixel currentPixel, Rgba32 color);
    private static byte FindEqualPixels(Span`1<TPixel> pixelRow, int xStart);
    private static byte FindUnEqualPixels(Span`1<TPixel> pixelRow, int xStart);
    [NullableContextAttribute("1")]
private IMemoryOwner`1<byte> AllocateRow(int width, int bytesPerPixel);
    [NullableContextAttribute("1")]
private void Write8Bit(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    [NullableContextAttribute("1")]
private void Write16Bit(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    [NullableContextAttribute("1")]
private void Write24Bit(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    [NullableContextAttribute("1")]
private void Write32Bit(Configuration configuration, Stream stream, Buffer2D`1<TPixel> pixels);
    public static int GetLuminance(TPixel sourcePixel);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Tga.TgaFileHeader : ValueType {
    public static int Size;
    [CompilerGeneratedAttribute]
private byte <IdLength>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ColorMapType>k__BackingField;
    [CompilerGeneratedAttribute]
private TgaImageType <ImageType>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CMapStart>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CMapLength>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <CMapDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private short <XOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <YOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <PixelDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ImageDescriptor>k__BackingField;
    public byte IdLength { get; }
    public byte ColorMapType { get; }
    public TgaImageType ImageType { get; }
    public short CMapStart { get; }
    public short CMapLength { get; }
    public byte CMapDepth { get; }
    public short XOffset { get; }
    public short YOffset { get; }
    public short Width { get; }
    public short Height { get; }
    public byte PixelDepth { get; }
    public byte ImageDescriptor { get; }
    public TgaFileHeader(byte idLength, byte colorMapType, TgaImageType imageType, short cMapStart, short cMapLength, byte cMapDepth, short xOffset, short yOffset, short width, short height, byte pixelDepth, byte imageDescriptor);
    [CompilerGeneratedAttribute]
public byte get_IdLength();
    [CompilerGeneratedAttribute]
public byte get_ColorMapType();
    [CompilerGeneratedAttribute]
public TgaImageType get_ImageType();
    [CompilerGeneratedAttribute]
public short get_CMapStart();
    [CompilerGeneratedAttribute]
public short get_CMapLength();
    [CompilerGeneratedAttribute]
public byte get_CMapDepth();
    [CompilerGeneratedAttribute]
public short get_XOffset();
    [CompilerGeneratedAttribute]
public short get_YOffset();
    [CompilerGeneratedAttribute]
public short get_Width();
    [CompilerGeneratedAttribute]
public short get_Height();
    [CompilerGeneratedAttribute]
public byte get_PixelDepth();
    [CompilerGeneratedAttribute]
public byte get_ImageDescriptor();
    public static TgaFileHeader Parse(Span`1<byte> data);
    public void WriteTo(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Tga.TgaFormat : object {
    [CompilerGeneratedAttribute]
private static TgaFormat <Instance>k__BackingField;
    public static TgaFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static TgaFormat();
    [CompilerGeneratedAttribute]
public static TgaFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual TgaMetadata CreateDefaultFormatMetadata();
}
public class SixLabors.ImageSharp.Formats.Tga.TgaImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
internal enum SixLabors.ImageSharp.Formats.Tga.TgaImageOrigin : Enum {
    public int value__;
    public static TgaImageOrigin BottomLeft;
    public static TgaImageOrigin BottomRight;
    public static TgaImageOrigin TopLeft;
    public static TgaImageOrigin TopRight;
}
public enum SixLabors.ImageSharp.Formats.Tga.TgaImageType : Enum {
    public byte value__;
    public static TgaImageType NoImageData;
    public static TgaImageType ColorMapped;
    public static TgaImageType TrueColor;
    public static TgaImageType BlackAndWhite;
    public static TgaImageType RleColorMapped;
    public static TgaImageType RleTrueColor;
    public static TgaImageType RleBlackAndWhite;
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Formats.Tga.TgaImageTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsRunLengthEncoded(TgaImageType imageType);
    [ExtensionAttribute]
public static bool IsValid(TgaImageType imageType);
}
public class SixLabors.ImageSharp.Formats.Tga.TgaMetadata : object {
    [CompilerGeneratedAttribute]
private TgaBitsPerPixel <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <AlphaChannelBits>k__BackingField;
    public TgaBitsPerPixel BitsPerPixel { get; public set; }
    public byte AlphaChannelBits { get; public set; }
    [NullableContextAttribute("1")]
private TgaMetadata(TgaMetadata other);
    [CompilerGeneratedAttribute]
public TgaBitsPerPixel get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(TgaBitsPerPixel value);
    [CompilerGeneratedAttribute]
public byte get_AlphaChannelBits();
    [CompilerGeneratedAttribute]
public void set_AlphaChannelBits(byte value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Tga.TgaThrowHelper : object {
    public static void ThrowInvalidImageContentException(string errorMessage);
    public static void ThrowInvalidImageContentException(string errorMessage, Exception innerException);
    public static void ThrowNotSupportedException(string errorMessage);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.BitWriterUtils : object {
    public static void WriteBits(Span`1<byte> buffer, IntPtr pos, IntPtr count, byte value);
    public static void WriteBit(Span`1<byte> buffer, IntPtr bufferPos, IntPtr bitPos);
    public static void WriteZeroBit(Span`1<byte> buffer, IntPtr bufferPos, IntPtr bitPos);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.DeflateCompressor : TiffBaseCompressor {
    private DeflateCompressionLevel compressionLevel;
    [NullableAttribute("1")]
private MemoryStream memoryStream;
    public TiffCompression Method { get; }
    [NullableContextAttribute("1")]
public DeflateCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel, TiffPredictor predictor, DeflateCompressionLevel compressionLevel);
    public virtual TiffCompression get_Method();
    public virtual void Initialize(int rowsPerStrip);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.LzwCompressor : TiffBaseCompressor {
    private TiffLzwEncoder lzwEncoder;
    public TiffCompression Method { get; }
    public LzwCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel, TiffPredictor predictor);
    public virtual TiffCompression get_Method();
    public virtual void Initialize(int rowsPerStrip);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.NoCompressor : TiffBaseCompressor {
    public TiffCompression Method { get; }
    [NullableContextAttribute("1")]
public NoCompressor(Stream output, MemoryAllocator memoryAllocator, int width, int bitsPerPixel);
    public virtual TiffCompression get_Method();
    public virtual void Initialize(int rowsPerStrip);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.PackBitsCompressor : TiffBaseCompressor {
    private IMemoryOwner`1<byte> pixelData;
    public TiffCompression Method { get; }
    public PackBitsCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel);
    public virtual TiffCompression get_Method();
    public virtual void Initialize(int rowsPerStrip);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected virtual void Dispose(bool disposing);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.PackBitsWriter : object {
    public static int PackBits(ReadOnlySpan`1<byte> rowSpan, Span`1<byte> compressedRowSpan);
    private static void WriteLiteralRun(ReadOnlySpan`1<byte> rowSpan, int end, int literalRunLength, Span`1<byte> compressedRowSpan, int compressedRowPos);
    private static void WriteRun(ReadOnlySpan`1<byte> rowSpan, int start, int runLength, Span`1<byte> compressedRowSpan, int compressedRowPos);
    private static bool IsReplicateRun(ReadOnlySpan`1<byte> rowSpan, int startPos);
    private static int FindRunLength(ReadOnlySpan`1<byte> rowSpan, int startPos, int maxRunLength);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.T4BitCompressor : TiffCcittCompressor {
    private bool useModifiedHuffman;
    public TiffCompression Method { get; }
    [NullableContextAttribute("1")]
public T4BitCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel, bool useModifiedHuffman);
    public virtual TiffCompression get_Method();
    protected virtual void CompressStrip(Span`1<byte> pixelsAsGray, int height, Span`1<byte> compressedData);
    private void WriteEndOfLine(Span`1<byte> compressedData);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.T6BitCompressor : TiffCcittCompressor {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] VerticalCodes;
    private IMemoryOwner`1<byte> referenceLineBuffer;
    public TiffCompression Method { get; }
    public T6BitCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel);
    private static T6BitCompressor();
    public virtual TiffCompression get_Method();
    protected virtual void CompressStrip(Span`1<byte> pixelsAsGray, int height, Span`1<byte> compressedData);
    protected virtual void Dispose(bool disposing);
    private static UInt32 FindRunEnd(Span`1<byte> row, UInt32 startIndex, Nullable`1<byte> color);
    public virtual void Initialize(int rowsPerStrip);
    private void WriteRun(UInt32 runLength, bool isWhiteRun, Span`1<byte> compressedData);
}
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.TiffCcittCompressor : TiffBaseCompressor {
    protected static UInt32 WhiteZeroRunTermCode;
    protected static UInt32 BlackZeroRunTermCode;
    private static UInt32[] MakeupRunLength;
    private static Dictionary`2<UInt32, UInt32> WhiteLen4TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen5TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen6TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen7TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen8TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen2TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen3TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen4TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen5TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen6TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen7TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen8TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen9TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen10TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen11TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen12TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen5MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen6MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen8MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen7MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen9MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen11MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen12MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen10MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen11MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen12MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen13MakeupCodes;
    private int bytePosition;
    private byte bitPosition;
    private IMemoryOwner`1<byte> compressedDataBuffer;
    protected TiffCcittCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel);
    private static TiffCcittCompressor();
    private static UInt32 GetWhiteMakeupCode(UInt32 runLength, UInt32& codeLength);
    private static UInt32 GetBlackMakeupCode(UInt32 runLength, UInt32& codeLength);
    private static UInt32 GetWhiteTermCode(UInt32 runLength, UInt32& codeLength);
    private static UInt32 GetBlackTermCode(UInt32 runLength, UInt32& codeLength);
    protected static UInt32 GetBestFittingMakeupRunLength(UInt32 runLength);
    protected static UInt32 GetTermCode(UInt32 runLength, UInt32& codeLength, bool isWhiteRun);
    protected static UInt32 GetMakeupCode(UInt32 runLength, UInt32& codeLength, bool isWhiteRun);
    protected void PadByte();
    protected void WriteCode(UInt32 codeLength, UInt32 code, Span`1<byte> compressedData);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected abstract virtual void CompressStrip(Span`1<byte> pixelsAsGray, int height, Span`1<byte> compressedData);
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize(int rowsPerStrip);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.TiffJpegCompressor : TiffBaseCompressor {
    public TiffCompression Method { get; }
    [NullableContextAttribute("1")]
public TiffJpegCompressor(Stream output, MemoryAllocator memoryAllocator, int width, int bitsPerPixel, TiffPredictor predictor);
    public virtual TiffCompression get_Method();
    public virtual void Initialize(int rowsPerStrip);
    public virtual void CompressStrip(Span`1<byte> rows, int height);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Compressors.TiffLzwEncoder : object {
    private static int ClearCode;
    private static int EoiCode;
    private static int MinBits;
    private static int MaxBits;
    private static int TableSize;
    private IMemoryOwner`1<int> children;
    private IMemoryOwner`1<int> siblings;
    private IMemoryOwner`1<int> suffixes;
    private int parent;
    private int bitsPerCode;
    private int nextValidCode;
    private int maxCode;
    private int bits;
    private int bitPos;
    private int bufferPosition;
    public TiffLzwEncoder(MemoryAllocator memoryAllocator);
    private static TiffLzwEncoder();
    [NullableContextAttribute("0")]
public void Encode(Span`1<byte> data, Stream stream);
    public sealed virtual void Dispose();
    private void Reset();
    [NullableContextAttribute("0")]
private byte ReadNextByte(Span`1<byte> data);
    private void IncreaseCodeSizeOrResetIfNeeded(Stream stream);
    private void WriteCode(Stream stream, int code);
    private void ResetTables();
    private static int MaxValue(int codeLen);
    private static int BitmaskFor(int bits);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.CcittReferenceScanline : ValueType {
    private ReadOnlySpan`1<byte> scanLine;
    private int width;
    private byte whiteByte;
    public bool IsEmpty { get; }
    public CcittReferenceScanline(bool whiteIsZero, ReadOnlySpan`1<byte> scanLine);
    public CcittReferenceScanline(bool whiteIsZero, int width);
    public bool get_IsEmpty();
    public int FindB1(int a0, byte a0Byte);
    public int FindB2(int b1);
    private int FindB1ForImaginaryWhiteLine(int a0, byte a0Byte);
    private int FindB1ForNormalLine(int a0, byte a0Byte);
    private int FindB2ForImaginaryWhiteLine();
    private int FindB2ForNormalLine(int b1);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Type = {Type}")]
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.CcittTwoDimensionalCode : ValueType {
    private ushort value;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    public CcittTwoDimensionalCodeType Type { get; }
    public int Code { get; }
    public CcittTwoDimensionalCode(int code, CcittTwoDimensionalCodeType type, int bitsRequired, int extensionBits);
    public CcittTwoDimensionalCodeType get_Type();
    [CompilerGeneratedAttribute]
public int get_Code();
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.CcittTwoDimensionalCodeType : Enum {
    public int value__;
    public static CcittTwoDimensionalCodeType None;
    public static CcittTwoDimensionalCodeType Pass;
    public static CcittTwoDimensionalCodeType Horizontal;
    public static CcittTwoDimensionalCodeType Vertical0;
    public static CcittTwoDimensionalCodeType VerticalR1;
    public static CcittTwoDimensionalCodeType VerticalR2;
    public static CcittTwoDimensionalCodeType VerticalR3;
    public static CcittTwoDimensionalCodeType VerticalL1;
    public static CcittTwoDimensionalCodeType VerticalL2;
    public static CcittTwoDimensionalCodeType VerticalL3;
    public static CcittTwoDimensionalCodeType Extensions1D;
    public static CcittTwoDimensionalCodeType Extensions2D;
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.DeflateTiffCompression : TiffBaseDecompressor {
    private bool isBigEndian;
    private TiffColorType colorType;
    [NullableContextAttribute("1")]
public DeflateTiffCompression(MemoryAllocator memoryAllocator, int width, int bitsPerPixel, TiffColorType colorType, TiffPredictor predictor, bool isBigEndian);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.GrayJpegSpectralConverter`1 : SpectralConverter`1<TPixel> {
    [NullableContextAttribute("1")]
public GrayJpegSpectralConverter`1(Configuration configuration);
    [NullableContextAttribute("1")]
protected virtual JpegColorConverterBase GetColorConverter(JpegFrame frame, IRawJpegData jpegData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.JpegCompressionUtils : object {
    public static void CopyImageBytesToBuffer(Configuration configuration, Span`1<byte> buffer, Buffer2D`1<Rgb24> pixelBuffer);
    public static void CopyImageBytesToBuffer(Configuration configuration, Span`1<byte> buffer, Buffer2D`1<L8> pixelBuffer);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.JpegTiffCompression : TiffBaseDecompressor {
    [NullableAttribute("1")]
private JpegDecoderOptions options;
    [NullableAttribute("1")]
private Byte[] jpegTables;
    private TiffPhotometricInterpretation photometricInterpretation;
    [NullableContextAttribute("1")]
public JpegTiffCompression(JpegDecoderOptions options, MemoryAllocator memoryAllocator, int width, int bitsPerPixel, Byte[] jpegTables, TiffPhotometricInterpretation photometricInterpretation);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    private void DecodeJpegData(BufferedReadStream stream, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
public class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.LzwString : object {
    private static LzwString Empty;
    private LzwString previous;
    private byte value;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <FirstChar>k__BackingField;
    public int Length { get; }
    public byte FirstChar { get; }
    public LzwString(byte code);
    private LzwString(byte value, byte firstChar, int length, LzwString previous);
    private static LzwString();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public byte get_FirstChar();
    public LzwString Concatenate(byte other);
    public int WriteTo(Span`1<byte> buffer, int offset);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.LzwTiffCompression : TiffBaseDecompressor {
    private bool isBigEndian;
    private TiffColorType colorType;
    [NullableContextAttribute("1")]
public LzwTiffCompression(MemoryAllocator memoryAllocator, int width, int bitsPerPixel, TiffColorType colorType, TiffPredictor predictor, bool isBigEndian);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.ModifiedHuffmanBitReader : T4BitReader {
    public bool HasMoreData { get; }
    public bool IsEndOfScanLine { get; }
    [NullableContextAttribute("1")]
public ModifiedHuffmanBitReader(BufferedReadStream input, TiffFillOrder fillOrder, int bytesToRead);
    public virtual bool get_HasMoreData();
    public virtual bool get_IsEndOfScanLine();
    public virtual void StartNewRow();
    protected virtual void ReadEolBeforeFirstData();
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.ModifiedHuffmanTiffCompression : TiffBaseDecompressor {
    private byte whiteValue;
    private byte blackValue;
    [CompilerGeneratedAttribute]
private TiffFillOrder <FillOrder>k__BackingField;
    private TiffFillOrder FillOrder { get; }
    [NullableContextAttribute("1")]
public ModifiedHuffmanTiffCompression(MemoryAllocator allocator, TiffFillOrder fillOrder, int width, int bitsPerPixel, TiffPhotometricInterpretation photometricInterpretation);
    [CompilerGeneratedAttribute]
private TiffFillOrder get_FillOrder();
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.NoneTiffCompression : TiffBaseDecompressor {
    [NullableContextAttribute("1")]
public NoneTiffCompression(MemoryAllocator memoryAllocator, int width, int bitsPerPixel);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.OldJpegTiffCompression : TiffBaseDecompressor {
    [NullableAttribute("1")]
private JpegDecoderOptions options;
    private UInt32 startOfImageMarker;
    private TiffPhotometricInterpretation photometricInterpretation;
    [NullableContextAttribute("1")]
public OldJpegTiffCompression(JpegDecoderOptions options, MemoryAllocator memoryAllocator, int width, int bitsPerPixel, UInt32 startOfImageMarker, TiffPhotometricInterpretation photometricInterpretation);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    private void DecodeJpegData(BufferedReadStream stream, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.PackBitsTiffCompression : TiffBaseDecompressor {
    private IMemoryOwner`1<byte> compressedDataMemory;
    public PackBitsTiffCompression(MemoryAllocator memoryAllocator, int width, int bitsPerPixel);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.RgbJpegSpectralConverter`1 : SpectralConverter`1<TPixel> {
    [NullableContextAttribute("1")]
public RgbJpegSpectralConverter`1(Configuration configuration);
    [NullableContextAttribute("1")]
protected virtual JpegColorConverterBase GetColorConverter(JpegFrame frame, IRawJpegData jpegData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.T4BitReader : object {
    private TiffFillOrder fillOrder;
    private bool isFirstScanLine;
    private bool terminationCodeFound;
    private bool isStartOfRow;
    private bool eolPadding;
    private static int MinCodeLength;
    private int maxCodeLength;
    private static Dictionary`2<UInt32, UInt32> WhiteLen4TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen5TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen6TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen7TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen8TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen2TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen3TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen4TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen5TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen6TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen7TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen8TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen9TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen10TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen11TermCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen12TermCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen5MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen6MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen8MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen7MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen9MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen11MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> WhiteLen12MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen10MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen11MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen12MakeupCodes;
    private static Dictionary`2<UInt32, UInt32> BlackLen13MakeupCodes;
    private BufferedReadStream stream;
    [CompilerGeneratedAttribute]
private byte <DataAtPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurValueBitsRead>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitsRead>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWhiteRun>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RunLength>k__BackingField;
    private byte DataAtPosition { get; private set; }
    protected UInt32 Value { get; private set; }
    protected int CurValueBitsRead { get; private set; }
    protected int BitsRead { get; private set; }
    protected int DataLength { get; }
    protected ulong Position { get; protected set; }
    public bool HasMoreData { get; }
    public bool IsWhiteRun { get; protected set; }
    public UInt32 RunLength { get; private set; }
    public bool IsEndOfScanLine { get; }
    public T4BitReader(BufferedReadStream input, TiffFillOrder fillOrder, int bytesToRead, bool eolPadding);
    private static T4BitReader();
    [CompilerGeneratedAttribute]
private byte get_DataAtPosition();
    [CompilerGeneratedAttribute]
private void set_DataAtPosition(byte value);
    [CompilerGeneratedAttribute]
protected UInt32 get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(UInt32 value);
    [CompilerGeneratedAttribute]
protected int get_CurValueBitsRead();
    [CompilerGeneratedAttribute]
private void set_CurValueBitsRead(int value);
    [CompilerGeneratedAttribute]
protected int get_BitsRead();
    [CompilerGeneratedAttribute]
private void set_BitsRead(int value);
    [CompilerGeneratedAttribute]
protected int get_DataLength();
    [CompilerGeneratedAttribute]
protected ulong get_Position();
    [CompilerGeneratedAttribute]
protected void set_Position(ulong value);
    public virtual bool get_HasMoreData();
    [CompilerGeneratedAttribute]
public bool get_IsWhiteRun();
    [CompilerGeneratedAttribute]
protected void set_IsWhiteRun(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_RunLength();
    [CompilerGeneratedAttribute]
private void set_RunLength(UInt32 value);
    public virtual bool get_IsEndOfScanLine();
    public void ReadNextRun();
    public virtual void StartNewRow();
    protected virtual void ReadEolBeforeFirstData();
    protected void Reset(bool resetRunLength);
    protected void ResetBitsRead();
    protected UInt32 ReadValue(int nBits);
    protected bool AdvancePosition();
    private UInt32 WhiteTerminatingCodeRunLength();
    private UInt32 BlackTerminatingCodeRunLength();
    private UInt32 WhiteMakeupCodeRunLength();
    private UInt32 BlackMakeupCodeRunLength();
    private bool IsMakeupCode();
    private bool IsWhiteMakeupCode();
    private bool IsBlackMakeupCode();
    private bool IsTerminatingCode();
    private bool IsWhiteTerminatingCode();
    private bool IsBlackTerminatingCode();
    private UInt32 GetBit();
    private bool LoadNewByte();
    private void ReadNextByte();
    private static byte ReverseBits(byte b);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.T4TiffCompression : TiffBaseDecompressor {
    private FaxCompressionOptions faxCompressionOptions;
    private byte whiteValue;
    private byte blackValue;
    private int width;
    [CompilerGeneratedAttribute]
private TiffFillOrder <FillOrder>k__BackingField;
    private TiffFillOrder FillOrder { get; }
    [NullableContextAttribute("1")]
public T4TiffCompression(MemoryAllocator allocator, TiffFillOrder fillOrder, int width, int bitsPerPixel, FaxCompressionOptions faxOptions, TiffPhotometricInterpretation photometricInterpretation);
    [CompilerGeneratedAttribute]
private TiffFillOrder get_FillOrder();
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    private void WritePixelRun(Span`1<byte> buffer, T4BitReader bitReader, IntPtr bitsWritten);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.T6BitReader : T4BitReader {
    private int maxCodeLength;
    private static CcittTwoDimensionalCode None;
    private static CcittTwoDimensionalCode Len1Code1;
    private static CcittTwoDimensionalCode Len3Code001;
    private static CcittTwoDimensionalCode Len3Code010;
    private static CcittTwoDimensionalCode Len3Code011;
    private static CcittTwoDimensionalCode Len4Code0001;
    private static CcittTwoDimensionalCode Len6Code000011;
    private static CcittTwoDimensionalCode Len6Code000010;
    private static CcittTwoDimensionalCode Len7Code0000011;
    private static CcittTwoDimensionalCode Len7Code0000010;
    private static CcittTwoDimensionalCode Len7Code0000001;
    private static CcittTwoDimensionalCode Len7Code0000000;
    [CompilerGeneratedAttribute]
private CcittTwoDimensionalCode <Code>k__BackingField;
    public bool HasMoreData { get; }
    public CcittTwoDimensionalCode Code { get; internal set; }
    [NullableContextAttribute("1")]
public T6BitReader(BufferedReadStream input, TiffFillOrder fillOrder, int bytesToRead);
    private static T6BitReader();
    public virtual bool get_HasMoreData();
    [CompilerGeneratedAttribute]
public CcittTwoDimensionalCode get_Code();
    [CompilerGeneratedAttribute]
internal void set_Code(CcittTwoDimensionalCode value);
    public bool ReadNextCodeWord();
    protected virtual void ReadEolBeforeFirstData();
    public void SwapColor();
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.T6TiffCompression : TiffBaseDecompressor {
    private bool isWhiteZero;
    private int width;
    private byte white;
    [CompilerGeneratedAttribute]
private TiffFillOrder <FillOrder>k__BackingField;
    private TiffFillOrder FillOrder { get; }
    [NullableContextAttribute("1")]
public T6TiffCompression(MemoryAllocator allocator, TiffFillOrder fillOrder, int width, int bitsPerPixel, TiffPhotometricInterpretation photometricInterpretation);
    [CompilerGeneratedAttribute]
private TiffFillOrder get_FillOrder();
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    private IntPtr WriteScanLine(Span`1<byte> buffer, Span`1<byte> scanLine, IntPtr bitsWritten);
    private static void Decode2DScanline(T6BitReader bitReader, bool whiteIsZero, CcittReferenceScanline referenceScanline, Span`1<byte> scanline);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.TiffJpegSpectralConverter`1 : SpectralConverter`1<TPixel> {
    private TiffPhotometricInterpretation photometricInterpretation;
    [NullableContextAttribute("1")]
public TiffJpegSpectralConverter`1(Configuration configuration, TiffPhotometricInterpretation photometricInterpretation);
    [NullableContextAttribute("1")]
protected virtual JpegColorConverterBase GetColorConverter(JpegFrame frame, IRawJpegData jpegData);
    private static JpegColorSpace GetJpegColorSpaceFromPhotometricInterpretation(TiffPhotometricInterpretation interpretation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.TiffLzwDecoder : object {
    private Stream stream;
    private static int ClearCode;
    private static int EoiCode;
    private static int MinBits;
    private static int MaxBits;
    private static int TableSize;
    private LzwString[] table;
    private int tableLength;
    private int bitsPerCode;
    private int oldCode;
    private int maxCode;
    private int bitMask;
    private int maxString;
    private bool eofReached;
    private int nextData;
    private int nextBits;
    public TiffLzwDecoder(Stream stream);
    private void Init();
    [NullableContextAttribute("0")]
public void DecodePixels(Span`1<byte> pixels);
    private void AddStringToTable(LzwString lzwString);
    private int GetNextCode();
    private bool IsInTable(int code);
    private int MaxCode();
    private static int BitmaskFor(int bits);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.TiffOldJpegSpectralConverter`1 : SpectralConverter`1<TPixel> {
    private TiffPhotometricInterpretation photometricInterpretation;
    [NullableContextAttribute("1")]
public TiffOldJpegSpectralConverter`1(Configuration configuration, TiffPhotometricInterpretation photometricInterpretation);
    [NullableContextAttribute("1")]
protected virtual JpegColorConverterBase GetColorConverter(JpegFrame frame, IRawJpegData jpegData);
    private static JpegColorSpace GetJpegColorSpaceFromPhotometricInterpretation(TiffPhotometricInterpretation interpretation);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Compression.Decompressors.WebpTiffCompression : TiffBaseDecompressor {
    [NullableAttribute("1")]
private DecoderOptions options;
    [NullableContextAttribute("1")]
public WebpTiffCompression(DecoderOptions options, MemoryAllocator memoryAllocator, int width, int bitsPerPixel, TiffPredictor predictor);
    protected virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    private static void CopyImageBytesToBuffer(Span`1<byte> buffer, Buffer2D`1<Rgb24> pixelBuffer);
    protected virtual void Dispose(bool disposing);
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Formats.Tiff.Compression.FaxCompressionOptions : Enum {
    public UInt32 value__;
    public static FaxCompressionOptions None;
    public static FaxCompressionOptions TwoDimensionalCoding;
    public static FaxCompressionOptions UncompressedMode;
    public static FaxCompressionOptions EolPadding;
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.HorizontalPredictor : object {
    public static void Undo(Span`1<byte> pixelBytes, int width, TiffColorType colorType, bool isBigEndian);
    public static void ApplyHorizontalPrediction(Span`1<byte> rows, int width, int bitsPerPixel);
    private static void ApplyHorizontalPrediction24Bit(Span`1<byte> rows, int width);
    private static void ApplyHorizontalPrediction16Bit(Span`1<byte> rows, int width);
    private static void ApplyHorizontalPrediction8Bit(Span`1<byte> rows, int width);
    private static void UndoGray8Bit(Span`1<byte> pixelBytes, int width);
    private static void UndoGray16Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
    private static void UndoGray32Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
    private static void UndoRgb24Bit(Span`1<byte> pixelBytes, int width);
    private static void UndoRgba32Bit(Span`1<byte> pixelBytes, int width);
    private static void UndoRgb48Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
    private static void UndoRgba64Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
    private static void UndoRgb96Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
    private static void UndoRgba128Bit(Span`1<byte> pixelBytes, int width, bool isBigEndian);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Compression.TiffBaseCompression : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BytesPerRow>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffPredictor <Predictor>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryAllocator <Allocator>k__BackingField;
    public int Width { get; }
    public int BitsPerPixel { get; }
    public int BytesPerRow { get; }
    public TiffPredictor Predictor { get; }
    protected MemoryAllocator Allocator { get; }
    protected TiffBaseCompression(MemoryAllocator allocator, int width, int bitsPerPixel, TiffPredictor predictor);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public int get_BytesPerRow();
    [CompilerGeneratedAttribute]
public TiffPredictor get_Predictor();
    [CompilerGeneratedAttribute]
protected MemoryAllocator get_Allocator();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Compression.TiffBaseCompressor : TiffBaseCompression {
    [CompilerGeneratedAttribute]
private Stream <Output>k__BackingField;
    public TiffCompression Method { get; }
    public Stream Output { get; }
    protected TiffBaseCompressor(Stream output, MemoryAllocator allocator, int width, int bitsPerPixel, TiffPredictor predictor);
    public abstract virtual TiffCompression get_Method();
    [CompilerGeneratedAttribute]
public Stream get_Output();
    public abstract virtual void Initialize(int rowsPerStrip);
    [NullableContextAttribute("0")]
public abstract virtual void CompressStrip(Span`1<byte> rows, int height);
}
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Compression.TiffBaseDecompressor : TiffBaseCompression {
    [NullableContextAttribute("1")]
protected TiffBaseDecompressor(MemoryAllocator memoryAllocator, int width, int bitsPerPixel, TiffPredictor predictor);
    public void Decompress(BufferedReadStream stream, ulong stripOffset, ulong stripByteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
    protected abstract virtual void Decompress(BufferedReadStream stream, int byteCount, int stripHeight, Span`1<byte> buffer, CancellationToken cancellationToken);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.TiffCompressorFactory : object {
    [NullableContextAttribute("1")]
public static TiffBaseCompressor Create(TiffCompression method, Stream output, MemoryAllocator allocator, int width, int bitsPerPixel, DeflateCompressionLevel compressionLevel, TiffPredictor predictor);
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Compression.TiffDecoderCompressionType : Enum {
    public int value__;
    public static TiffDecoderCompressionType None;
    public static TiffDecoderCompressionType PackBits;
    public static TiffDecoderCompressionType Deflate;
    public static TiffDecoderCompressionType Lzw;
    public static TiffDecoderCompressionType T4;
    public static TiffDecoderCompressionType T6;
    public static TiffDecoderCompressionType HuffmanRle;
    public static TiffDecoderCompressionType Jpeg;
    public static TiffDecoderCompressionType Webp;
    public static TiffDecoderCompressionType OldJpeg;
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Compression.TiffDecompressorsFactory : object {
    [NullableContextAttribute("1")]
public static TiffBaseDecompressor Create(DecoderOptions options, TiffDecoderCompressionType method, MemoryAllocator allocator, TiffPhotometricInterpretation photometricInterpretation, int width, int bitsPerPixel, TiffColorType colorType, TiffPredictor predictor, FaxCompressionOptions faxOptions, Byte[] jpegTables, UInt32 oldJpegStartOfImageMarker, TiffFillOrder fillOrder, ByteOrder byteOrder);
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffCompression : Enum {
    public ushort value__;
    public static TiffCompression Invalid;
    public static TiffCompression None;
    public static TiffCompression Ccitt1D;
    public static TiffCompression CcittGroup3Fax;
    public static TiffCompression CcittGroup4Fax;
    public static TiffCompression Lzw;
    public static TiffCompression OldJpeg;
    public static TiffCompression Jpeg;
    public static TiffCompression Deflate;
    public static TiffCompression ItuTRecT82;
    public static TiffCompression ItuTRecT43;
    public static TiffCompression NeXT;
    public static TiffCompression PackBits;
    public static TiffCompression ThunderScan;
    public static TiffCompression OldDeflate;
    public static TiffCompression Webp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Tiff.Constants.TiffConstants : object {
    public static byte ByteOrderLittleEndian;
    public static byte ByteOrderBigEndian;
    public static ushort ByteOrderLittleEndianShort;
    public static ushort ByteOrderBigEndianShort;
    public static ushort HeaderMagicNumber;
    public static ushort BigTiffHeaderMagicNumber;
    public static ushort BigTiffBytesize;
    public static int RowsPerStripInfinity;
    public static int SizeOfRational;
    public static int DefaultStripSize;
    public static TiffBitsPerSample BitsPerSample1Bit;
    public static TiffBitsPerSample BitsPerSample4Bit;
    public static TiffBitsPerSample BitsPerSample8Bit;
    public static TiffBitsPerSample BitsPerSample16Bit;
    public static TiffBitsPerSample BitsPerSampleRgb8Bit;
    public static IEnumerable`1<string> MimeTypes;
    public static IEnumerable`1<string> FileExtensions;
    private static TiffConstants();
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffExtraSamples : Enum {
    public int value__;
    public static TiffExtraSamples Unspecified;
    public static TiffExtraSamples AssociatedAlpha;
    public static TiffExtraSamples UnassociatedAlpha;
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffFillOrder : Enum {
    public ushort value__;
    public static TiffFillOrder MostSignificantBitFirst;
    public static TiffFillOrder LeastSignificantBitFirst;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffInkSet : Enum {
    public ushort value__;
    public static TiffInkSet Cmyk;
    public static TiffInkSet NotCmyk;
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffNewSubfileType : Enum {
    public UInt32 value__;
    public static TiffNewSubfileType FullImage;
    public static TiffNewSubfileType Preview;
    public static TiffNewSubfileType SinglePage;
    public static TiffNewSubfileType TransparencyMask;
    public static TiffNewSubfileType AlternativePreview;
    public static TiffNewSubfileType MixedRasterContent;
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffOrientation : Enum {
    public int value__;
    public static TiffOrientation TopLeft;
    public static TiffOrientation TopRight;
    public static TiffOrientation BottomRight;
    public static TiffOrientation BottomLeft;
    public static TiffOrientation LeftTop;
    public static TiffOrientation RightTop;
    public static TiffOrientation RightBottom;
    public static TiffOrientation LeftBottom;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffPhotometricInterpretation : Enum {
    public ushort value__;
    public static TiffPhotometricInterpretation WhiteIsZero;
    public static TiffPhotometricInterpretation BlackIsZero;
    public static TiffPhotometricInterpretation Rgb;
    public static TiffPhotometricInterpretation PaletteColor;
    public static TiffPhotometricInterpretation TransparencyMask;
    public static TiffPhotometricInterpretation Separated;
    public static TiffPhotometricInterpretation YCbCr;
    public static TiffPhotometricInterpretation CieLab;
    public static TiffPhotometricInterpretation IccLab;
    public static TiffPhotometricInterpretation ItuLab;
    public static TiffPhotometricInterpretation ColorFilterArray;
    public static TiffPhotometricInterpretation LinearRaw;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffPlanarConfiguration : Enum {
    public ushort value__;
    public static TiffPlanarConfiguration Chunky;
    public static TiffPlanarConfiguration Planar;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffPredictor : Enum {
    public ushort value__;
    public static TiffPredictor None;
    public static TiffPredictor Horizontal;
    public static TiffPredictor FloatingPoint;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffSampleFormat : Enum {
    public ushort value__;
    public static TiffSampleFormat UnsignedInteger;
    public static TiffSampleFormat SignedInteger;
    public static TiffSampleFormat Float;
    public static TiffSampleFormat Undefined;
    public static TiffSampleFormat ComplexInt;
    public static TiffSampleFormat ComplexFloat;
}
public enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffSubfileType : Enum {
    public ushort value__;
    public static TiffSubfileType FullImage;
    public static TiffSubfileType Preview;
    public static TiffSubfileType SinglePage;
}
internal enum SixLabors.ImageSharp.Formats.Tiff.Constants.TiffThresholding : Enum {
    public int value__;
    public static TiffThresholding None;
    public static TiffThresholding Ordered;
    public static TiffThresholding Random;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Tiff.DirectoryReader : object {
    private static int DirectoryMax;
    private Stream stream;
    private MemoryAllocator allocator;
    private ulong nextIfdOffset;
    [CompilerGeneratedAttribute]
private ByteOrder <ByteOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBigTiff>k__BackingField;
    public ByteOrder ByteOrder { get; private set; }
    public bool IsBigTiff { get; private set; }
    public DirectoryReader(Stream stream, MemoryAllocator allocator);
    [CompilerGeneratedAttribute]
public ByteOrder get_ByteOrder();
    [CompilerGeneratedAttribute]
private void set_ByteOrder(ByteOrder value);
    [CompilerGeneratedAttribute]
public bool get_IsBigTiff();
    [CompilerGeneratedAttribute]
private void set_IsBigTiff(bool value);
    public IList`1<ExifProfile> Read();
    private static ByteOrder ReadByteOrder(Stream stream);
    private IList`1<ExifProfile> ReadIfds(bool isBigTiff);
}
internal class SixLabors.ImageSharp.Formats.Tiff.EntryReader : BaseExifReader {
    [CompilerGeneratedAttribute]
private List`1<IExifValue> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NextIfdOffset>k__BackingField;
    public List`1<IExifValue> Values { get; }
    public ulong NextIfdOffset { get; private set; }
    public EntryReader(Stream stream, ByteOrder byteOrder, MemoryAllocator allocator);
    [CompilerGeneratedAttribute]
public List`1<IExifValue> get_Values();
    [CompilerGeneratedAttribute]
public ulong get_NextIfdOffset();
    [CompilerGeneratedAttribute]
private void set_NextIfdOffset(ulong value);
    public void ReadTags(bool isBigTiff, ulong ifdOffset);
    public void ReadBigValues();
}
internal class SixLabors.ImageSharp.Formats.Tiff.HeaderReader : BaseExifReader {
    [CompilerGeneratedAttribute]
private bool <IsBigTiff>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FirstIfdOffset>k__BackingField;
    public bool IsBigTiff { get; private set; }
    public ulong FirstIfdOffset { get; private set; }
    public HeaderReader(Stream stream, ByteOrder byteOrder);
    [CompilerGeneratedAttribute]
public bool get_IsBigTiff();
    [CompilerGeneratedAttribute]
private void set_IsBigTiff(bool value);
    [CompilerGeneratedAttribute]
public ulong get_FirstIfdOffset();
    [CompilerGeneratedAttribute]
private void set_FirstIfdOffset(ulong value);
    public void ReadFileHeader();
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero16TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableContextAttribute("1")]
public BlackIsZero16TiffColor`1(Configuration configuration, bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero1TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero24TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public BlackIsZero24TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero32FloatTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public BlackIsZero32FloatTiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero32TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public BlackIsZero32TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero4TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZero8TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableContextAttribute("1")]
public BlackIsZero8TiffColor`1(Configuration configuration);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.BlackIsZeroTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private ushort bitsPerSample0;
    private float factor;
    public BlackIsZeroTiffColor`1(TiffBitsPerSample bitsPerSample);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.CieLabPlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    [NullableAttribute("1")]
private static ColorSpaceConverter ColorSpaceConverter;
    private static float Inv255;
    private static CieLabPlanarTiffColor`1();
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.CieLabTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    [NullableAttribute("1")]
private static ColorSpaceConverter ColorSpaceConverter;
    private static float Inv255;
    private static CieLabTiffColor`1();
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.CmykTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private static float Inv255;
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.PaletteTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private ushort bitsPerSample0;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TPixel[] palette;
    private static float InvMax;
    [NullableContextAttribute("1")]
public PaletteTiffColor`1(TiffBitsPerSample bitsPerSample, UInt16[] colorMap);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
    [NullableContextAttribute("1")]
private static TPixel[] GeneratePalette(UInt16[] colorMap, int colorCount);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb161616TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableContextAttribute("1")]
public Rgb161616TiffColor`1(Configuration configuration, bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb16PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public Rgb16PlanarTiffColor`1(bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb242424TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public Rgb242424TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb24PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public Rgb24PlanarTiffColor`1(bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb323232TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public Rgb323232TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb32PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public Rgb32PlanarTiffColor`1(bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb444TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
    private static ushort ToBgraPackedValue(byte b, byte g, byte r);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgb888TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableContextAttribute("1")]
public Rgb888TiffColor`1(Configuration configuration);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba16161616TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba16161616TiffColor`1(Configuration configuration, MemoryAllocator memoryAllocator, Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba16PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba16PlanarTiffColor`1(Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba24242424TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba24242424TiffColor`1(Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba24PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba24PlanarTiffColor`1(Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba32323232TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba32323232TiffColor`1(Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba32PlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private bool isBigEndian;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba32PlanarTiffColor`1(Nullable`1<TiffExtraSampleType> extraSamplesType, bool isBigEndian);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.Rgba8888TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public Rgba8888TiffColor`1(Configuration configuration, MemoryAllocator memoryAllocator, Nullable`1<TiffExtraSampleType> extraSamplesType);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbaFloat32323232TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public RgbaFloat32323232TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbaPlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private float rFactor;
    private float gFactor;
    private float bFactor;
    private float aFactor;
    private ushort bitsPerSampleR;
    private ushort bitsPerSampleG;
    private ushort bitsPerSampleB;
    private ushort bitsPerSampleA;
    private Nullable`1<TiffExtraSampleType> extraSampleType;
    public RgbaPlanarTiffColor`1(Nullable`1<TiffExtraSampleType> extraSampleType, TiffBitsPerSample bitsPerSample);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbaTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private float rFactor;
    private float gFactor;
    private float bFactor;
    private float aFactor;
    private ushort bitsPerSampleR;
    private ushort bitsPerSampleG;
    private ushort bitsPerSampleB;
    private ushort bitsPerSampleA;
    private Nullable`1<TiffExtraSampleType> extraSamplesType;
    public RgbaTiffColor`1(Nullable`1<TiffExtraSampleType> extraSampleType, TiffBitsPerSample bitsPerSample);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbFloat323232TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public RgbFloat323232TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbPlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private float rFactor;
    private float gFactor;
    private float bFactor;
    private ushort bitsPerSampleR;
    private ushort bitsPerSampleG;
    private ushort bitsPerSampleB;
    public RgbPlanarTiffColor`1(TiffBitsPerSample bitsPerSample);
    [NullableContextAttribute("1")]
public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.RgbTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private float rFactor;
    private float gFactor;
    private float bFactor;
    private ushort bitsPerSampleR;
    private ushort bitsPerSampleG;
    private ushort bitsPerSampleB;
    public RgbTiffColor`1(TiffBitsPerSample bitsPerSample);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal abstract class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.TiffBaseColorDecoder`1 : object {
    public abstract virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal abstract class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.TiffBasePlanarColorDecoder`1 : object {
    [NullableContextAttribute("1")]
public abstract virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.TiffColorDecoderFactory`1 : object {
    [NullableContextAttribute("1")]
public static TiffBaseColorDecoder`1<TPixel> Create(Configuration configuration, MemoryAllocator memoryAllocator, TiffColorType colorType, TiffBitsPerSample bitsPerSample, Nullable`1<TiffExtraSampleType> extraSampleType, UInt16[] colorMap, Rational[] referenceBlackAndWhite, Rational[] ycbcrCoefficients, UInt16[] ycbcrSubSampling, ByteOrder byteOrder);
    [NullableContextAttribute("1")]
public static TiffBasePlanarColorDecoder`1<TPixel> CreatePlanar(TiffColorType colorType, TiffBitsPerSample bitsPerSample, Nullable`1<TiffExtraSampleType> extraSampleType, UInt16[] colorMap, Rational[] referenceBlackAndWhite, Rational[] ycbcrCoefficients, UInt16[] ycbcrSubSampling, ByteOrder byteOrder);
}
internal enum SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.TiffColorType : Enum {
    public int value__;
    public static TiffColorType BlackIsZero;
    public static TiffColorType BlackIsZero1;
    public static TiffColorType BlackIsZero4;
    public static TiffColorType BlackIsZero8;
    public static TiffColorType BlackIsZero16;
    public static TiffColorType BlackIsZero24;
    public static TiffColorType BlackIsZero32;
    public static TiffColorType BlackIsZero32Float;
    public static TiffColorType WhiteIsZero;
    public static TiffColorType WhiteIsZero1;
    public static TiffColorType WhiteIsZero4;
    public static TiffColorType WhiteIsZero8;
    public static TiffColorType WhiteIsZero16;
    public static TiffColorType WhiteIsZero24;
    public static TiffColorType WhiteIsZero32;
    public static TiffColorType WhiteIsZero32Float;
    public static TiffColorType PaletteColor;
    public static TiffColorType Rgb;
    public static TiffColorType Rgb222;
    public static TiffColorType Rgba2222;
    public static TiffColorType Rgb333;
    public static TiffColorType Rgba3333;
    public static TiffColorType Rgb444;
    public static TiffColorType Rgba4444;
    public static TiffColorType Rgb555;
    public static TiffColorType Rgba5555;
    public static TiffColorType Rgb666;
    public static TiffColorType Rgba6666;
    public static TiffColorType Rgb888;
    public static TiffColorType Rgba8888;
    public static TiffColorType Rgb101010;
    public static TiffColorType Rgba10101010;
    public static TiffColorType Rgb121212;
    public static TiffColorType Rgba12121212;
    public static TiffColorType Rgb141414;
    public static TiffColorType Rgba14141414;
    public static TiffColorType Rgb161616;
    public static TiffColorType Rgba16161616;
    public static TiffColorType Rgb242424;
    public static TiffColorType Rgba24242424;
    public static TiffColorType Rgb323232;
    public static TiffColorType Rgba32323232;
    public static TiffColorType RgbFloat323232;
    public static TiffColorType RgbaFloat32323232;
    public static TiffColorType Rgb888Planar;
    public static TiffColorType Rgba8888Planar;
    public static TiffColorType Rgb161616Planar;
    public static TiffColorType Rgba16161616Planar;
    public static TiffColorType Rgb242424Planar;
    public static TiffColorType Rgba24242424Planar;
    public static TiffColorType Rgb323232Planar;
    public static TiffColorType Rgba32323232Planar;
    public static TiffColorType YCbCr;
    public static TiffColorType YCbCrPlanar;
    public static TiffColorType CieLab;
    public static TiffColorType CieLabPlanar;
    public static TiffColorType Cmyk;
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero16TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public WhiteIsZero16TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero1TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero24TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public WhiteIsZero24TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero32FloatTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public WhiteIsZero32FloatTiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero32TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private bool isBigEndian;
    public WhiteIsZero32TiffColor`1(bool isBigEndian);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero4TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZero8TiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.WhiteIsZeroTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    private ushort bitsPerSample0;
    private float factor;
    public WhiteIsZeroTiffColor`1(TiffBitsPerSample bitsPerSample);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.YCbCrConverter : object {
    private CodingRangeExpander yExpander;
    private CodingRangeExpander cbExpander;
    private CodingRangeExpander crExpander;
    private YCbCrToRgbConverter converter;
    [NullableAttribute("1")]
private static Rational[] DefaultLuma;
    [NullableAttribute("1")]
private static Rational[] DefaultReferenceBlackWhite;
    [NullableContextAttribute("1")]
public YCbCrConverter(Rational[] referenceBlackAndWhite, Rational[] coefficients);
    private static YCbCrConverter();
    public Rgba32 ConvertToRgba32(byte y, byte cb, byte cr);
    private static byte RoundAndClampTo8Bit(float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.YCbCrPlanarTiffColor`1 : TiffBasePlanarColorDecoder`1<TPixel> {
    private YCbCrConverter converter;
    private UInt16[] ycbcrSubSampling;
    public YCbCrPlanarTiffColor`1(Rational[] referenceBlackAndWhite, Rational[] coefficients, UInt16[] ycbcrSubSampling);
    public virtual void Decode(IMemoryOwner`1[] data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
    [NullableContextAttribute("0")]
private static void ReverseChromaSubSampling(int width, int height, int horizontalSubSampling, int verticalSubSampling, Span`1<byte> planarCb, Span`1<byte> planarCr);
}
internal class SixLabors.ImageSharp.Formats.Tiff.PhotometricInterpretation.YCbCrTiffColor`1 : TiffBaseColorDecoder`1<TPixel> {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    [NullableAttribute("1")]
private YCbCrConverter converter;
    [NullableAttribute("1")]
private UInt16[] ycbcrSubSampling;
    [NullableContextAttribute("1")]
public YCbCrTiffColor`1(MemoryAllocator memoryAllocator, Rational[] referenceBlackAndWhite, Rational[] coefficients, UInt16[] ycbcrSubSampling);
    public virtual void Decode(ReadOnlySpan`1<byte> data, Buffer2D`1<TPixel> pixels, int left, int top, int width, int height);
    private void DecodeYCbCrData(Buffer2D`1<TPixel> pixels, int left, int top, int width, int height, ReadOnlySpan`1<byte> ycbcrData);
    private static void ReverseChromaSubSampling(int width, int height, int horizontalSubSampling, int verticalSubSampling, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
}
public enum SixLabors.ImageSharp.Formats.Tiff.TiffBitsPerPixel : Enum {
    public int value__;
    public static TiffBitsPerPixel Bit1;
    public static TiffBitsPerPixel Bit4;
    public static TiffBitsPerPixel Bit6;
    public static TiffBitsPerPixel Bit8;
    public static TiffBitsPerPixel Bit10;
    public static TiffBitsPerPixel Bit12;
    public static TiffBitsPerPixel Bit14;
    public static TiffBitsPerPixel Bit16;
    public static TiffBitsPerPixel Bit24;
    public static TiffBitsPerPixel Bit30;
    public static TiffBitsPerPixel Bit32;
    public static TiffBitsPerPixel Bit36;
    public static TiffBitsPerPixel Bit42;
    public static TiffBitsPerPixel Bit48;
    public static TiffBitsPerPixel Bit64;
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Formats.Tiff.TiffBitsPerSample : ValueType {
    [CompilerGeneratedAttribute]
private ushort <Channel0>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Channel1>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Channel2>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Channel3>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Channels>k__BackingField;
    public ushort Channel0 { get; }
    public ushort Channel1 { get; }
    public ushort Channel2 { get; }
    public ushort Channel3 { get; }
    public byte Channels { get; }
    public TiffBitsPerSample(ushort channel0, ushort channel1, ushort channel2, ushort channel3);
    [CompilerGeneratedAttribute]
public ushort get_Channel0();
    [CompilerGeneratedAttribute]
public ushort get_Channel1();
    [CompilerGeneratedAttribute]
public ushort get_Channel2();
    [CompilerGeneratedAttribute]
public ushort get_Channel3();
    [CompilerGeneratedAttribute]
public byte get_Channels();
    public static bool op_Equality(TiffBitsPerSample left, TiffBitsPerSample right);
    public static bool op_Inequality(TiffBitsPerSample left, TiffBitsPerSample right);
    [NullableContextAttribute("2")]
public static bool TryParse(UInt16[] value, TiffBitsPerSample& sample);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TiffBitsPerSample other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public UInt16[] ToArray();
    public TiffBitsPerPixel BitsPerPixel();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class SixLabors.ImageSharp.Formats.Tiff.TiffConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Tiff.TiffDecoder : ImageDecoder {
    [CompilerGeneratedAttribute]
private static TiffDecoder <Instance>k__BackingField;
    public static TiffDecoder Instance { get; }
    private static TiffDecoder();
    [CompilerGeneratedAttribute]
public static TiffDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Tiff.TiffDecoderCore : object {
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private bool skipMetadata;
    private UInt32 maxFrames;
    private BufferedReadStream inputStream;
    private ByteOrder byteOrder;
    private bool isBigTiff;
    [CompilerGeneratedAttribute]
private TiffBitsPerSample <BitsPerSample>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <ColorMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffColorType <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Rational[] <ReferenceBlackAndWhite>k__BackingField;
    [CompilerGeneratedAttribute]
private Rational[] <YcbcrCoefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <YcbcrSubSampling>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffDecoderCompressionType <CompressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private FaxCompressionOptions <FaxCompressionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffFillOrder <FillOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffExtraSampleType> <ExtraSamplesType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <JpegTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <OldJpegCompressionStartOfImageMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffPlanarConfiguration <PlanarConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffPhotometricInterpretation <PhotometricInterpretation>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffSampleFormat <SampleFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffPredictor <Predictor>k__BackingField;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Dimensions>k__BackingField;
    public TiffBitsPerSample BitsPerSample { get; public set; }
    public int BitsPerPixel { get; public set; }
    public UInt16[] ColorMap { get; public set; }
    public TiffColorType ColorType { get; public set; }
    public Rational[] ReferenceBlackAndWhite { get; public set; }
    public Rational[] YcbcrCoefficients { get; public set; }
    public UInt16[] YcbcrSubSampling { get; public set; }
    public TiffDecoderCompressionType CompressionType { get; public set; }
    public FaxCompressionOptions FaxCompressionOptions { get; public set; }
    public TiffFillOrder FillOrder { get; public set; }
    public Nullable`1<TiffExtraSampleType> ExtraSamplesType { get; public set; }
    public Byte[] JpegTables { get; public set; }
    public Nullable`1<UInt32> OldJpegCompressionStartOfImageMarker { get; public set; }
    public TiffPlanarConfiguration PlanarConfiguration { get; public set; }
    public TiffPhotometricInterpretation PhotometricInterpretation { get; public set; }
    public TiffSampleFormat SampleFormat { get; public set; }
    public TiffPredictor Predictor { get; public set; }
    public DecoderOptions Options { get; }
    public Size Dimensions { get; private set; }
    public TiffDecoderCore(DecoderOptions options);
    [CompilerGeneratedAttribute]
public TiffBitsPerSample get_BitsPerSample();
    [CompilerGeneratedAttribute]
public void set_BitsPerSample(TiffBitsPerSample value);
    [CompilerGeneratedAttribute]
public int get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(int value);
    [CompilerGeneratedAttribute]
public UInt16[] get_ColorMap();
    [CompilerGeneratedAttribute]
public void set_ColorMap(UInt16[] value);
    [CompilerGeneratedAttribute]
public TiffColorType get_ColorType();
    [CompilerGeneratedAttribute]
public void set_ColorType(TiffColorType value);
    [CompilerGeneratedAttribute]
public Rational[] get_ReferenceBlackAndWhite();
    [CompilerGeneratedAttribute]
public void set_ReferenceBlackAndWhite(Rational[] value);
    [CompilerGeneratedAttribute]
public Rational[] get_YcbcrCoefficients();
    [CompilerGeneratedAttribute]
public void set_YcbcrCoefficients(Rational[] value);
    [CompilerGeneratedAttribute]
public UInt16[] get_YcbcrSubSampling();
    [CompilerGeneratedAttribute]
public void set_YcbcrSubSampling(UInt16[] value);
    [CompilerGeneratedAttribute]
public TiffDecoderCompressionType get_CompressionType();
    [CompilerGeneratedAttribute]
public void set_CompressionType(TiffDecoderCompressionType value);
    [CompilerGeneratedAttribute]
public FaxCompressionOptions get_FaxCompressionOptions();
    [CompilerGeneratedAttribute]
public void set_FaxCompressionOptions(FaxCompressionOptions value);
    [CompilerGeneratedAttribute]
public TiffFillOrder get_FillOrder();
    [CompilerGeneratedAttribute]
public void set_FillOrder(TiffFillOrder value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffExtraSampleType> get_ExtraSamplesType();
    [CompilerGeneratedAttribute]
public void set_ExtraSamplesType(Nullable`1<TiffExtraSampleType> value);
    [CompilerGeneratedAttribute]
public Byte[] get_JpegTables();
    [CompilerGeneratedAttribute]
public void set_JpegTables(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_OldJpegCompressionStartOfImageMarker();
    [CompilerGeneratedAttribute]
public void set_OldJpegCompressionStartOfImageMarker(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public TiffPlanarConfiguration get_PlanarConfiguration();
    [CompilerGeneratedAttribute]
public void set_PlanarConfiguration(TiffPlanarConfiguration value);
    [CompilerGeneratedAttribute]
public TiffPhotometricInterpretation get_PhotometricInterpretation();
    [CompilerGeneratedAttribute]
public void set_PhotometricInterpretation(TiffPhotometricInterpretation value);
    [CompilerGeneratedAttribute]
public TiffSampleFormat get_SampleFormat();
    [CompilerGeneratedAttribute]
public void set_SampleFormat(TiffSampleFormat value);
    [CompilerGeneratedAttribute]
public TiffPredictor get_Predictor();
    [CompilerGeneratedAttribute]
public void set_Predictor(TiffPredictor value);
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual Size get_Dimensions();
    [CompilerGeneratedAttribute]
private void set_Dimensions(Size value);
    public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    private ImageFrame`1<TPixel> DecodeFrame(ExifProfile tags, CancellationToken cancellationToken);
    private ImageFrameMetadata CreateFrameMetadata(ExifProfile tags);
    private void DecodeImageWithStrips(ExifProfile tags, ImageFrame`1<TPixel> frame, CancellationToken cancellationToken);
    private void DecodeImageWithTiles(ExifProfile tags, ImageFrame`1<TPixel> frame, CancellationToken cancellationToken);
    private void DecodeStripsPlanar(ImageFrame`1<TPixel> frame, int rowsPerStrip, Span`1<ulong> stripOffsets, Span`1<ulong> stripByteCounts, CancellationToken cancellationToken);
    private void DecodeStripsChunky(ImageFrame`1<TPixel> frame, int rowsPerStrip, Span`1<ulong> stripOffsets, Span`1<ulong> stripByteCounts, CancellationToken cancellationToken);
    private void DecodeTilesPlanar(ImageFrame`1<TPixel> frame, int tileWidth, int tileLength, int tilesAcross, int tilesDown, Span`1<ulong> tileOffsets, Span`1<ulong> tileByteCounts, CancellationToken cancellationToken);
    private void DecodeTilesChunky(ImageFrame`1<TPixel> frame, int tileWidth, int tileLength, int tilesAcross, int tilesDown, Span`1<ulong> tileOffsets, Span`1<ulong> tileByteCounts, CancellationToken cancellationToken);
    private TiffBaseColorDecoder`1<TPixel> CreateChunkyColorDecoder();
    private TiffBasePlanarColorDecoder`1<TPixel> CreatePlanarColorDecoder();
    private TiffBaseDecompressor CreateDecompressor(int frameWidth, int bitsPerPixel);
    private IMemoryOwner`1<ulong> ConvertNumbers(Array array, Span`1& span);
    private int CalculateStripBufferSize(int width, int height, int plane);
    private static int GetImageWidth(ExifProfile exifProfile);
    private static int GetImageHeight(ExifProfile exifProfile);
    private static int RoundUpToMultipleOfEight(int value);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.TiffDecoderMetadataCreator : object {
    public static ImageMetadata Create(List`1<ImageFrameMetadata> frames, bool ignoreMetadata, ByteOrder byteOrder, bool isBigTiff);
    private static ImageMetadata Create(ByteOrder byteOrder, bool isBigTiff, ExifProfile exifProfile);
    private static void SetResolution(ImageMetadata imageMetaData, ExifProfile exifProfile);
    private static bool TryGetIptc(IReadOnlyList`1<IExifValue> exifValues, Byte[]& iptcBytes);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Formats.Tiff.TiffDecoderOptionsParser : object {
    private static TiffPlanarConfiguration DefaultPlanarConfiguration;
    [ExtensionAttribute]
public static bool VerifyAndParse(TiffDecoderCore options, ExifProfile exifProfile, TiffFrameMetadata frameMetadata);
    private static bool VerifyRequiredFieldsArePresent(ExifProfile exifProfile, TiffFrameMetadata frameMetadata, TiffPlanarConfiguration planarConfiguration);
    [ExtensionAttribute]
private static void ParseColorType(TiffDecoderCore options, ExifProfile exifProfile);
    [ExtensionAttribute]
private static void ParseCompression(TiffDecoderCore options, Nullable`1<TiffCompression> compression, ExifProfile exifProfile);
    private static bool IsBiColorCompression(Nullable`1<TiffCompression> compression);
}
public class SixLabors.ImageSharp.Formats.Tiff.TiffEncoder : QuantizingImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<TiffBitsPerPixel> <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffCompression> <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DeflateCompressionLevel> <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPhotometricInterpretation> <PhotometricInterpretation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPredictor> <HorizontalPredictor>k__BackingField;
    public Nullable`1<TiffBitsPerPixel> BitsPerPixel { get; public set; }
    public Nullable`1<TiffCompression> Compression { get; public set; }
    public Nullable`1<DeflateCompressionLevel> CompressionLevel { get; public set; }
    public Nullable`1<TiffPhotometricInterpretation> PhotometricInterpretation { get; public set; }
    public Nullable`1<TiffPredictor> HorizontalPredictor { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TiffBitsPerPixel> get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BitsPerPixel(Nullable`1<TiffBitsPerPixel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffCompression> get_Compression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Compression(Nullable`1<TiffCompression> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DeflateCompressionLevel> get_CompressionLevel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CompressionLevel(Nullable`1<DeflateCompressionLevel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffPhotometricInterpretation> get_PhotometricInterpretation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PhotometricInterpretation(Nullable`1<TiffPhotometricInterpretation> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffPredictor> get_HorizontalPredictor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HorizontalPredictor(Nullable`1<TiffPredictor> value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Tiff.TiffEncoderCore : object {
    private static ushort ByteOrderMarker;
    private MemoryAllocator memoryAllocator;
    private Configuration configuration;
    private IQuantizer quantizer;
    private IPixelSamplingStrategy pixelSamplingStrategy;
    private DeflateCompressionLevel compressionLevel;
    private static TiffPredictor DefaultPredictor;
    private static TiffBitsPerPixel DefaultBitsPerPixel;
    private static TiffCompression DefaultCompression;
    private static TiffPhotometricInterpretation DefaultPhotometricInterpretation;
    private bool skipMetadata;
    private List`1<ValueTuple`2<long, UInt32>> frameMarkers;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPhotometricInterpretation> <PhotometricInterpretation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffCompression> <CompressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPredictor> <HorizontalPredictor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffBitsPerPixel> <BitsPerPixel>k__BackingField;
    internal Nullable`1<TiffPhotometricInterpretation> PhotometricInterpretation { get; private set; }
    internal Nullable`1<TiffCompression> CompressionType { get; internal set; }
    internal Nullable`1<TiffPredictor> HorizontalPredictor { get; internal set; }
    internal Nullable`1<TiffBitsPerPixel> BitsPerPixel { get; private set; }
    public TiffEncoderCore(TiffEncoder options, MemoryAllocator memoryAllocator);
    private static TiffEncoderCore();
    [CompilerGeneratedAttribute]
internal Nullable`1<TiffPhotometricInterpretation> get_PhotometricInterpretation();
    [CompilerGeneratedAttribute]
private void set_PhotometricInterpretation(Nullable`1<TiffPhotometricInterpretation> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<TiffCompression> get_CompressionType();
    [CompilerGeneratedAttribute]
internal void set_CompressionType(Nullable`1<TiffCompression> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<TiffPredictor> get_HorizontalPredictor();
    [CompilerGeneratedAttribute]
internal void set_HorizontalPredictor(Nullable`1<TiffPredictor> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<TiffBitsPerPixel> get_BitsPerPixel();
    [CompilerGeneratedAttribute]
private void set_BitsPerPixel(Nullable`1<TiffBitsPerPixel> value);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
    public static long WriteHeader(TiffStreamWriter writer, Span`1<byte> buffer);
    private long WriteFrame(TiffStreamWriter writer, ImageFrame`1<TPixel> frame, ImageMetadata imageMetadata, Image`1<TPixel> image, long ifdOffset);
    private static int CalcRowsPerStrip(int height, int bytesPerRow, Nullable`1<TiffCompression> compression);
    private long WriteIfd(TiffStreamWriter writer, List`1<IExifValue> entries);
    private void SanitizeAndSetEncoderOptions(Nullable`1<TiffBitsPerPixel> bitsPerPixel, int inputBitsPerPixel, Nullable`1<TiffPhotometricInterpretation> photometricInterpretation, TiffCompression compression, TiffPredictor predictor);
    private void SetEncoderOptions(Nullable`1<TiffBitsPerPixel> bitsPerPixel, Nullable`1<TiffPhotometricInterpretation> photometricInterpretation, TiffCompression compression, TiffPredictor predictor);
    public static bool IsOneBitCompression(Nullable`1<TiffCompression> compression);
}
internal class SixLabors.ImageSharp.Formats.Tiff.TiffEncoderEntriesCollector : object {
    private static string SoftwareValue;
    [CompilerGeneratedAttribute]
private List`1<IExifValue> <Entries>k__BackingField;
    public List`1<IExifValue> Entries { get; }
    [CompilerGeneratedAttribute]
public List`1<IExifValue> get_Entries();
    public void ProcessMetadata(Image image, bool skipMetadata);
    public void ProcessMetadata(ImageFrame frame, bool skipMetadata);
    public void ProcessFrameInfo(ImageFrame frame, ImageMetadata imageMetadata);
    public void ProcessImageFormat(TiffEncoderCore encoder);
    public void AddOrReplace(IExifValue entry);
    private void Add(IExifValue entry);
}
internal enum SixLabors.ImageSharp.Formats.Tiff.TiffExtraSampleType : Enum {
    public int value__;
    public static TiffExtraSampleType UnspecifiedData;
    public static TiffExtraSampleType AssociatedAlphaData;
    public static TiffExtraSampleType UnassociatedAlphaData;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Tiff.TiffFormat : object {
    [CompilerGeneratedAttribute]
private static TiffFormat <Instance>k__BackingField;
    public static TiffFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static TiffFormat();
    [CompilerGeneratedAttribute]
public static TiffFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual TiffMetadata CreateDefaultFormatMetadata();
    public sealed virtual TiffFrameMetadata CreateDefaultFormatFrameMetadata();
}
public enum SixLabors.ImageSharp.Formats.Tiff.TiffFormatType : Enum {
    public int value__;
    public static TiffFormatType Default;
    public static TiffFormatType BigTIFF;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Tiff.TiffFrameMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TiffBitsPerPixel> <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffBitsPerSample> <BitsPerSample>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffCompression> <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPhotometricInterpretation> <PhotometricInterpretation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffPredictor> <Predictor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TiffInkSet> <InkSet>k__BackingField;
    public Nullable`1<TiffBitsPerPixel> BitsPerPixel { get; public set; }
    public Nullable`1<TiffBitsPerSample> BitsPerSample { get; public set; }
    public Nullable`1<TiffCompression> Compression { get; public set; }
    public Nullable`1<TiffPhotometricInterpretation> PhotometricInterpretation { get; public set; }
    public Nullable`1<TiffPredictor> Predictor { get; public set; }
    public Nullable`1<TiffInkSet> InkSet { get; public set; }
    private TiffFrameMetadata(TiffFrameMetadata other);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffBitsPerPixel> get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(Nullable`1<TiffBitsPerPixel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffBitsPerSample> get_BitsPerSample();
    [CompilerGeneratedAttribute]
public void set_BitsPerSample(Nullable`1<TiffBitsPerSample> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffCompression> get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(Nullable`1<TiffCompression> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffPhotometricInterpretation> get_PhotometricInterpretation();
    [CompilerGeneratedAttribute]
public void set_PhotometricInterpretation(Nullable`1<TiffPhotometricInterpretation> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffPredictor> get_Predictor();
    [CompilerGeneratedAttribute]
public void set_Predictor(Nullable`1<TiffPredictor> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TiffInkSet> get_InkSet();
    [CompilerGeneratedAttribute]
public void set_InkSet(Nullable`1<TiffInkSet> value);
    internal static TiffFrameMetadata Parse(ExifProfile profile);
    internal static void Parse(TiffFrameMetadata meta, ExifProfile profile);
    public sealed virtual IDeepCloneable DeepClone();
}
public class SixLabors.ImageSharp.Formats.Tiff.TiffImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
}
public class SixLabors.ImageSharp.Formats.Tiff.TiffMetadata : object {
    [CompilerGeneratedAttribute]
private ByteOrder <ByteOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffFormatType <FormatType>k__BackingField;
    public ByteOrder ByteOrder { get; public set; }
    public TiffFormatType FormatType { get; public set; }
    [NullableContextAttribute("1")]
private TiffMetadata(TiffMetadata other);
    [CompilerGeneratedAttribute]
public ByteOrder get_ByteOrder();
    [CompilerGeneratedAttribute]
public void set_ByteOrder(ByteOrder value);
    [CompilerGeneratedAttribute]
public TiffFormatType get_FormatType();
    [CompilerGeneratedAttribute]
public void set_FormatType(TiffFormatType value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Tiff.TiffThrowHelper : object {
    [DoesNotReturnAttribute]
public static Exception ThrowImageFormatException(string errorMessage);
    [DoesNotReturnAttribute]
public static Exception ThrowInvalidImageContentException(string errorMessage);
    [DoesNotReturnAttribute]
public static Exception NotSupportedDecompressor(string compressionType);
    [DoesNotReturnAttribute]
public static Exception NotSupportedCompressor(string compressionType);
    [DoesNotReturnAttribute]
public static Exception InvalidColorType(string colorType);
    [DoesNotReturnAttribute]
public static Exception ThrowInvalidHeader();
    [DoesNotReturnAttribute]
public static void ThrowNotSupported(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class SixLabors.ImageSharp.Formats.Tiff.Utils.BitReader : ValueType {
    private ReadOnlySpan`1<byte> array;
    private int offset;
    private int bitOffset;
    public BitReader(ReadOnlySpan`1<byte> array);
    public int ReadBits(UInt32 bits);
    public void NextRow();
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Utils.TiffUtils : object {
    private static float Scale24Bit;
    private static float Scale32Bit;
    [CompilerGeneratedAttribute]
private static Rgba64 <Rgba64Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static L16 <L16Default>k__BackingField;
    public static Rgba64 Rgba64Default { get; }
    public static L16 L16Default { get; }
    private static TiffUtils();
    [CompilerGeneratedAttribute]
public static Rgba64 get_Rgba64Default();
    [CompilerGeneratedAttribute]
public static L16 get_L16Default();
    public static ushort ConvertToUShortBigEndian(ReadOnlySpan`1<byte> buffer);
    public static ushort ConvertToUShortLittleEndian(ReadOnlySpan`1<byte> buffer);
    public static UInt32 ConvertToUIntBigEndian(ReadOnlySpan`1<byte> buffer);
    public static UInt32 ConvertToUIntLittleEndian(ReadOnlySpan`1<byte> buffer);
    public static TPixel ColorFromL8(L8 l8, byte intensity, TPixel color);
    public static TPixel ColorFromRgb64(Rgba64 rgba, ulong r, ulong g, ulong b, TPixel color);
    public static TPixel ColorFromRgba64(Rgba64 rgba, ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorFromRgba64Premultiplied(Rgba64 rgba, ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorScaleTo24Bit(ulong r, ulong g, ulong b, TPixel color);
    public static TPixel ColorScaleTo24Bit(ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorScaleTo24BitPremultiplied(ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorScaleTo32Bit(ulong r, ulong g, ulong b, TPixel color);
    public static TPixel ColorScaleTo32Bit(ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorScaleTo32BitPremultiplied(ulong r, ulong g, ulong b, ulong a, TPixel color);
    public static TPixel ColorFromL16(L16 l16, ushort intensity, TPixel color);
    public static TPixel ColorScaleTo24Bit(ulong intensity, TPixel color);
    public static TPixel ColorScaleTo32Bit(ulong intensity, TPixel color);
    public static TPixel UnPremultiply(Vector4& vector, TPixel color);
    public static int PaddingToNextInteger(int valueToRoundUp, int subSampling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffBaseColorWriter`1 : object {
    private bool isDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImageFrame`1<TPixel> <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryAllocator <MemoryAllocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffEncoderEntriesCollector <EntriesCollector>k__BackingField;
    public int BitsPerPixel { get; }
    public int BytesPerRow { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImageFrame`1<TPixel> Image { get; }
    protected MemoryAllocator MemoryAllocator { get; }
    protected Configuration Configuration { get; }
    protected TiffEncoderEntriesCollector EntriesCollector { get; }
    protected TiffBaseColorWriter`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    public abstract virtual int get_BitsPerPixel();
    public int get_BytesPerRow();
    [CompilerGeneratedAttribute]
protected ImageFrame`1<TPixel> get_Image();
    [CompilerGeneratedAttribute]
protected MemoryAllocator get_MemoryAllocator();
    [CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    [CompilerGeneratedAttribute]
protected TiffEncoderEntriesCollector get_EntriesCollector();
    public virtual void Write(TiffBaseCompressor compressor, int rowsPerStrip);
    public sealed virtual void Dispose();
    protected abstract virtual void EncodeStrip(int y, int height, TiffBaseCompressor compressor);
    private void AddStripTags(int rowsPerStrip, UInt32[] stripOffsets, UInt32[] stripByteCounts);
    protected abstract virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffBiColorWriter`1 : TiffBaseColorWriter`1<TPixel> {
    private Image`1<TPixel> imageBlackWhite;
    private IMemoryOwner`1<byte> pixelsAsGray;
    private IMemoryOwner`1<byte> bitStrip;
    public int BitsPerPixel { get; }
    public TiffBiColorWriter`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    public virtual int get_BitsPerPixel();
    protected virtual void EncodeStrip(int y, int height, TiffBaseCompressor compressor);
    protected virtual void Dispose(bool disposing);
}
internal static class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffColorWriterFactory : object {
    [NullableContextAttribute("1")]
public static TiffBaseColorWriter`1<TPixel> Create(Nullable`1<TiffPhotometricInterpretation> photometricInterpretation, ImageFrame`1<TPixel> image, IQuantizer quantizer, IPixelSamplingStrategy pixelSamplingStrategy, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector, int bitsPerPixel);
}
internal abstract class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffCompositeColorWriter`1 : TiffBaseColorWriter`1<TPixel> {
    private IMemoryOwner`1<byte> rowBuffer;
    protected TiffCompositeColorWriter`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    protected virtual void EncodeStrip(int y, int height, TiffBaseCompressor compressor);
    protected abstract virtual void EncodePixels(Span`1<TPixel> pixels, Span`1<byte> buffer);
    protected virtual void Dispose(bool disposing);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffGrayL16Writer`1 : TiffCompositeColorWriter`1<TPixel> {
    public int BitsPerPixel { get; }
    [NullableContextAttribute("1")]
public TiffGrayL16Writer`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    public virtual int get_BitsPerPixel();
    protected virtual void EncodePixels(Span`1<TPixel> pixels, Span`1<byte> buffer);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffGrayWriter`1 : TiffCompositeColorWriter`1<TPixel> {
    public int BitsPerPixel { get; }
    [NullableContextAttribute("1")]
public TiffGrayWriter`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    public virtual int get_BitsPerPixel();
    protected virtual void EncodePixels(Span`1<TPixel> pixels, Span`1<byte> buffer);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffPaletteWriter`1 : TiffBaseColorWriter`1<TPixel> {
    private int maxColors;
    private int colorPaletteSize;
    private int colorPaletteBytes;
    private IndexedImageFrame`1<TPixel> quantizedFrame;
    private IMemoryOwner`1<byte> indexedPixelsBuffer;
    [CompilerGeneratedAttribute]
private int <BitsPerPixel>k__BackingField;
    public int BitsPerPixel { get; }
    public TiffPaletteWriter`1(ImageFrame`1<TPixel> frame, IQuantizer quantizer, IPixelSamplingStrategy pixelSamplingStrategy, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector, int bitsPerPixel);
    [CompilerGeneratedAttribute]
public virtual int get_BitsPerPixel();
    protected virtual void EncodeStrip(int y, int height, TiffBaseCompressor compressor);
    protected virtual void Dispose(bool disposing);
    private void AddColorMapTag();
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffRgbWriter`1 : TiffCompositeColorWriter`1<TPixel> {
    public int BitsPerPixel { get; }
    [NullableContextAttribute("1")]
public TiffRgbWriter`1(ImageFrame`1<TPixel> image, MemoryAllocator memoryAllocator, Configuration configuration, TiffEncoderEntriesCollector entriesCollector);
    public virtual int get_BitsPerPixel();
    protected virtual void EncodePixels(Span`1<TPixel> pixels, Span`1<byte> buffer);
}
internal class SixLabors.ImageSharp.Formats.Tiff.Writers.TiffStreamWriter : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    public static bool IsLittleEndian { get; }
    public long Position { get; }
    [NullableAttribute("1")]
public Stream BaseStream { get; }
    [NullableContextAttribute("1")]
public TiffStreamWriter(Stream output);
    public static bool get_IsLittleEndian();
    public long get_Position();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Stream get_BaseStream();
    public long PlaceMarker(Span`1<byte> buffer);
    [NullableContextAttribute("1")]
public void Write(Byte[] value);
    public void Write(ReadOnlySpan`1<byte> value);
    public void Write(byte value);
    public void Write(ushort value, Span`1<byte> buffer);
    public void Write(UInt32 value, Span`1<byte> buffer);
    public void WritePadded(Span`1<byte> value);
    public void WriteMarker(long offset, UInt32 value, Span`1<byte> buffer);
    public void WriteMarkerFast(long offset, UInt32 value, Span`1<byte> buffer);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.AlphaDecoder : object {
    private MemoryAllocator memoryAllocator;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpAlphaFilterType <AlphaFilterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastRow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PrevRow>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8LDecoder <Vp8LDec>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compressed>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Data>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private WebpLosslessDecoder <LosslessDecoder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Use8BDecode>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    public WebpAlphaFilterType AlphaFilterType { get; }
    public int LastRow { get; public set; }
    public int PrevRow { get; public set; }
    public Vp8LDecoder Vp8LDec { get; }
    public IMemoryOwner`1<byte> Alpha { get; }
    [MemberNotNullWhenAttribute("True", "LosslessDecoder")]
private bool Compressed { get; }
    private IMemoryOwner`1<byte> Data { get; }
    [NullableAttribute("2")]
private WebpLosslessDecoder LosslessDecoder { get; }
    public bool Use8BDecode { get; }
    public AlphaDecoder(int width, int height, IMemoryOwner`1<byte> data, byte alphaChunkHeader, MemoryAllocator memoryAllocator, Configuration configuration);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public WebpAlphaFilterType get_AlphaFilterType();
    [CompilerGeneratedAttribute]
public int get_LastRow();
    [CompilerGeneratedAttribute]
public void set_LastRow(int value);
    [CompilerGeneratedAttribute]
public int get_PrevRow();
    [CompilerGeneratedAttribute]
public void set_PrevRow(int value);
    [CompilerGeneratedAttribute]
public Vp8LDecoder get_Vp8LDec();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_Alpha();
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "LosslessDecoder")]
private bool get_Compressed();
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private WebpLosslessDecoder get_LosslessDecoder();
    [CompilerGeneratedAttribute]
public bool get_Use8BDecode();
    public void Decode();
    [NullableContextAttribute("0")]
public void AlphaApplyFilter(int firstRow, int lastRow, Span`1<byte> dst, int stride);
    public void ExtractPalettedAlphaRows(int lastRow);
    private void ExtractAlphaRows(Vp8LDecoder dec);
    [NullableContextAttribute("0")]
private static void ColorIndexInverseTransformAlpha(Vp8LTransform transform, int yStart, int yEnd, Span`1<byte> src, Span`1<byte> dst);
    [NullableContextAttribute("0")]
private static void HorizontalUnfilter(Span`1<byte> prev, Span`1<byte> input, Span`1<byte> dst, int width);
    [NullableContextAttribute("0")]
private static void VerticalUnfilter(Span`1<byte> prev, Span`1<byte> input, Span`1<byte> dst, int width);
    [NullableContextAttribute("0")]
private static void GradientUnfilter(Span`1<byte> prev, Span`1<byte> input, Span`1<byte> dst, int width);
    private static bool Is8BOptimizable(Vp8LMetadata hdr);
    [NullableContextAttribute("0")]
private static void MapAlpha(Span`1<byte> src, Span`1<UInt32> colorMap, Span`1<byte> dst, int yStart, int yEnd, int width);
    private static byte GetAlphaValue(int val);
    private static int GradientPredictor(byte a, byte b, byte c);
    [NullableContextAttribute("0")]
private static void ExtractGreen(Span`1<UInt32> argb, Span`1<byte> alpha, int size);
    public sealed virtual void Dispose();
}
internal static class SixLabors.ImageSharp.Formats.Webp.AlphaEncoder : object {
    [NullableContextAttribute("1")]
public static IMemoryOwner`1<byte> EncodeAlpha(Buffer2DRegion`1<TPixel> frame, Configuration configuration, MemoryAllocator memoryAllocator, bool skipMetadata, bool compress, Int32& size);
    private static ImageFrame`1<Bgra32> DispatchAlphaToGreen(Configuration configuration, Buffer2DRegion`1<TPixel> frame, Span`1<byte> alphaData);
    [NullableContextAttribute("1")]
private static IMemoryOwner`1<byte> ExtractAlphaChannel(Buffer2DRegion`1<TPixel> frame, Configuration configuration, MemoryAllocator memoryAllocator);
}
public enum SixLabors.ImageSharp.Formats.Webp.BackgroundColorHandling : Enum {
    public int value__;
    public static BackgroundColorHandling Standard;
    public static BackgroundColorHandling Ignore;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Webp.BitReader.BitReaderBase : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Data>k__BackingField;
    public IMemoryOwner`1<byte> Data { get; }
    protected BitReaderBase(IMemoryOwner`1<byte> data);
    protected BitReaderBase(Stream inputStream, int imageDataSize, MemoryAllocator memoryAllocator);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_Data();
    protected static IMemoryOwner`1<byte> ReadImageDataFromStream(Stream input, int bytesToRead, MemoryAllocator memoryAllocator);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.BitReader.Vp8BitReader : BitReaderBase {
    private static int BitsCount;
    private ulong value;
    private UInt32 range;
    private int bits;
    private UInt32 bufferMax;
    private UInt32 bufferEnd;
    private bool eof;
    private long pos;
    [CompilerGeneratedAttribute]
private UInt32 <ImageDataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PartitionLength>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Remaining>k__BackingField;
    public int Pos { get; }
    public UInt32 ImageDataSize { get; }
    public UInt32 PartitionLength { get; }
    public UInt32 Remaining { get; public set; }
    public Vp8BitReader(Stream inputStream, UInt32 imageDataSize, MemoryAllocator memoryAllocator, UInt32 partitionLength, int startPos);
    public Vp8BitReader(IMemoryOwner`1<byte> imageData, UInt32 partitionLength, int startPos);
    public int get_Pos();
    [CompilerGeneratedAttribute]
public UInt32 get_ImageDataSize();
    [CompilerGeneratedAttribute]
public UInt32 get_PartitionLength();
    [CompilerGeneratedAttribute]
public UInt32 get_Remaining();
    [CompilerGeneratedAttribute]
public void set_Remaining(UInt32 value);
    public int GetBit(int prob);
    public int GetSigned(int v);
    public bool ReadBool();
    public UInt32 ReadValue(int nBits);
    public int ReadSignedValue(int nBits);
    private void InitBitreader(UInt32 size, int pos);
    private void LoadNewBytes();
    private void LoadFinalBytes();
    private static ulong ByteSwap64(ulong x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.BitReader.Vp8LBitReader : BitReaderBase {
    private static int Vp8LMaxNumBitRead;
    private static int Lbits;
    private static int Wbits;
    private static UInt32[] BitMask;
    private ulong value;
    private long len;
    private long pos;
    private int bitPos;
    [CompilerGeneratedAttribute]
private bool <Eos>k__BackingField;
    public bool Eos { get; public set; }
    public Vp8LBitReader(IMemoryOwner`1<byte> data);
    public Vp8LBitReader(Stream inputStream, UInt32 imageDataSize, MemoryAllocator memoryAllocator);
    private static Vp8LBitReader();
    [CompilerGeneratedAttribute]
public bool get_Eos();
    [CompilerGeneratedAttribute]
public void set_Eos(bool value);
    public UInt32 ReadValue(int nBits);
    public bool ReadBit();
    public void AdvanceBitPosition(int numberOfBits);
    public ulong PrefetchBits();
    public void FillBitWindow();
    public bool IsEndOfStream();
    private void DoFillBitWindow();
    private void ShiftBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Formats.Webp.BitWriter.BitWriterBase : object {
    private static UInt32 MaxDimension;
    private static ulong MaxCanvasPixels;
    private Byte[] buffer;
    public Byte[] Buffer { get; }
    public int NumBytes { get; }
    protected BitWriterBase(int expectedSize);
    private protected BitWriterBase(Byte[] buffer);
    public Byte[] get_Buffer();
    public abstract virtual int get_NumBytes();
    public void WriteToStream(Stream stream);
    [NullableContextAttribute("0")]
public void WriteToBuffer(Span`1<byte> dest);
    public abstract virtual void BitWriterResize(int extraSize);
    public abstract virtual void Finish();
    protected void ResizeBuffer(int maxBytes, int sizeRequired);
    [NullableContextAttribute("2")]
public static WebpVp8X WriteTrunksBeforeData(Stream stream, UInt32 width, UInt32 height, ExifProfile exifProfile, XmpProfile xmpProfile, IccProfile iccProfile, bool hasAlpha, bool hasAnimation);
    public abstract virtual void WriteEncodedImageToStream(Stream stream);
    [NullableContextAttribute("2")]
public static void WriteTrunksAfterData(Stream stream, WebpVp8X& vp8x, bool updateVp8x, long initialPosition, ExifProfile exifProfile, XmpProfile xmpProfile);
    public static void WriteAnimationParameter(Stream stream, Color background, ushort loopCount);
    [NullableContextAttribute("0")]
public static void WriteAlphaChunk(Stream stream, Span`1<byte> dataBytes, bool alphaDataIsCompressed);
    [NullableContextAttribute("2")]
protected static WebpVp8X WriteVp8XHeader(Stream stream, ExifProfile exifProfile, XmpProfile xmpProfile, IccProfile iccProfile, UInt32 width, UInt32 height, bool hasAlpha, bool hasAnimation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.BitWriter.Vp8BitWriter : BitWriterBase {
    private static int DC_PRED;
    private static int TM_PRED;
    private static int V_PRED;
    private static int H_PRED;
    private static int B_DC_PRED;
    private static int B_TM_PRED;
    private static int B_VE_PRED;
    private static int B_HE_PRED;
    private static int B_RD_PRED;
    private static int B_VR_PRED;
    private static int B_LD_PRED;
    private static int B_VL_PRED;
    private static int B_HD_PRED;
    private static int B_HU_PRED;
    private Vp8Encoder enc;
    private int range;
    private int value;
    private int run;
    private int nbBits;
    private UInt32 pos;
    private int maxPos;
    public int NumBytes { get; }
    public Vp8BitWriter(int expectedSize, Vp8Encoder enc);
    public virtual int get_NumBytes();
    public int PutCoeffs(int ctx, Vp8Residual residual);
    public virtual void BitWriterResize(int extraSize);
    public virtual void Finish();
    [NullableContextAttribute("0")]
public void PutSegment(int s, Span`1<byte> p);
    public void PutI16Mode(int mode);
    [NullableContextAttribute("0")]
public int PutI4Mode(int mode, Span`1<byte> prob);
    public void PutUvMode(int uvMode);
    private void PutBits(UInt32 value, int nbBits);
    private bool PutBit(bool bit, int prob);
    private bool PutBit(int bit, int prob);
    private int PutBitUniform(int bit);
    private void PutSignedBits(int value, int nbBits);
    private void Flush();
    public virtual void WriteEncodedImageToStream(Stream stream);
    private UInt32 GeneratePartition0();
    private void WriteSegmentHeader();
    private void WriteFilterHeader();
    private void WriteQuant();
    private void WriteProbas();
    private void CodeIntraModes();
    private void WriteVp8Header(Stream stream, UInt32 size);
    private void WriteFrameHeader(Stream stream, UInt32 size0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.BitWriter.Vp8LBitWriter : BitWriterBase {
    private static int MinExtraSize;
    private static int WriterBytes;
    private static int WriterBits;
    private ulong bits;
    private int used;
    private int cur;
    public int NumBytes { get; }
    public Vp8LBitWriter(int expectedSize);
    private Vp8LBitWriter(Byte[] buffer, ulong bits, int used, int cur);
    public virtual int get_NumBytes();
    public void PutBits(UInt32 bits, int nBits);
    public void Reset(Vp8LBitWriter bwInit);
    public void WriteHuffmanCode(HuffmanTreeCode code, int codeIndex);
    public void WriteHuffmanCodeWithExtraBits(HuffmanTreeCode code, int codeIndex, int bits, int nBits);
    public Vp8LBitWriter Clone();
    public virtual void Finish();
    public virtual void WriteEncodedImageToStream(Stream stream);
    private void PutBitsFlushBits();
    public virtual void BitWriterResize(int extraSize);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Webp.Chunks.WebpAnimationParameter : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LoopCount>k__BackingField;
    public UInt32 Background { get; }
    public ushort LoopCount { get; }
    public WebpAnimationParameter(UInt32 background, ushort loopCount);
    [CompilerGeneratedAttribute]
public UInt32 get_Background();
    [CompilerGeneratedAttribute]
public ushort get_LoopCount();
    [NullableContextAttribute("1")]
public void WriteTo(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Webp.Chunks.WebpFrameData : ValueType {
    public static UInt32 HeaderSize;
    [CompilerGeneratedAttribute]
private UInt32 <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <X>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpBlendMethod <BlendingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpDisposalMethod <DisposalMethod>k__BackingField;
    public UInt32 DataSize { get; }
    public UInt32 X { get; }
    public UInt32 Y { get; }
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public UInt32 Duration { get; }
    public WebpBlendMethod BlendingMethod { get; }
    public WebpDisposalMethod DisposalMethod { get; }
    public Rectangle Bounds { get; }
    public WebpFrameData(UInt32 dataSize, UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 duration, WebpBlendMethod blendingMethod, WebpDisposalMethod disposalMethod);
    public WebpFrameData(UInt32 dataSize, UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 duration, int flags);
    public WebpFrameData(UInt32 x, UInt32 y, UInt32 width, UInt32 height, UInt32 duration, WebpBlendMethod blendingMethod, WebpDisposalMethod disposalMethod);
    [CompilerGeneratedAttribute]
public UInt32 get_DataSize();
    [CompilerGeneratedAttribute]
public UInt32 get_X();
    [CompilerGeneratedAttribute]
public UInt32 get_Y();
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public UInt32 get_Duration();
    [CompilerGeneratedAttribute]
public WebpBlendMethod get_BlendingMethod();
    [CompilerGeneratedAttribute]
public WebpDisposalMethod get_DisposalMethod();
    public Rectangle get_Bounds();
    public long WriteHeaderTo(Stream stream);
    public static WebpFrameData Parse(Stream stream);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Formats.Webp.Chunks.WebpVp8X : ValueType {
    [CompilerGeneratedAttribute]
private bool <HasAnimation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasXmp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExif>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAlpha>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasIcc>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    public bool HasAnimation { get; }
    public bool HasXmp { get; }
    public bool HasExif { get; }
    public bool HasAlpha { get; }
    public bool HasIcc { get; }
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public WebpVp8X(bool hasAnimation, bool hasXmp, bool hasExif, bool hasAlpha, bool hasIcc, UInt32 width, UInt32 height);
    [CompilerGeneratedAttribute]
public bool get_HasAnimation();
    [CompilerGeneratedAttribute]
public bool get_HasXmp();
    [CompilerGeneratedAttribute]
public bool get_HasExif();
    [CompilerGeneratedAttribute]
public bool get_HasAlpha();
    [CompilerGeneratedAttribute]
public bool get_HasIcc();
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    public static bool op_Equality(WebpVp8X left, WebpVp8X right);
    public static bool op_Inequality(WebpVp8X left, WebpVp8X right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WebpVp8X other);
    public virtual int GetHashCode();
    public void Validate(UInt32 maxDimension, ulong maxCanvasPixels);
    public WebpVp8X WithAlpha(bool hasAlpha);
    [NullableContextAttribute("1")]
public void WriteTo(Stream stream);
}
internal enum SixLabors.ImageSharp.Formats.Webp.EntropyIx : Enum {
    public byte value__;
    public static EntropyIx Direct;
    public static EntropyIx Spatial;
    public static EntropyIx SubGreen;
    public static EntropyIx SpatialSubGreen;
    public static EntropyIx Palette;
    public static EntropyIx PaletteAndSpatial;
    public static EntropyIx NumEntropyIx;
}
internal enum SixLabors.ImageSharp.Formats.Webp.HistoIx : Enum {
    public byte value__;
    public static HistoIx HistoAlpha;
    public static HistoIx HistoAlphaPred;
    public static HistoIx HistoGreen;
    public static HistoIx HistoGreenPred;
    public static HistoIx HistoRed;
    public static HistoIx HistoRedPred;
    public static HistoIx HistoBlue;
    public static HistoIx HistoBluePred;
    public static HistoIx HistoRedSubGreen;
    public static HistoIx HistoRedPredSubGreen;
    public static HistoIx HistoBlueSubGreen;
    public static HistoIx HistoBluePredSubGreen;
    public static HistoIx HistoPalette;
    public static HistoIx HistoTotal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.BackwardReferenceEncoder : object {
    public static int MaxLengthBits;
    private static float MaxEntropy;
    private static int WindowOffsetsSizeMax;
    public static int MaxLength;
    private static int MinLength;
    public static Vp8LBackwardRefs GetBackwardReferences(int width, int height, ReadOnlySpan`1<UInt32> bgra, UInt32 quality, int lz77TypesToTry, Int32& cacheBits, MemoryAllocator memoryAllocator, Vp8LHashChain hashChain, Vp8LBackwardRefs best, Vp8LBackwardRefs worst);
    private static int CalculateBestCacheSize(MemoryAllocator memoryAllocator, Span`1<ColorCache> colorCache, ReadOnlySpan`1<UInt32> bgra, UInt32 quality, Vp8LBackwardRefs refs, int bestCacheBits);
    private static void BackwardReferencesTraceBackwards(int xSize, int ySize, MemoryAllocator memoryAllocator, ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LHashChain hashChain, Vp8LBackwardRefs refsSrc, Vp8LBackwardRefs refsDst);
    private static void BackwardReferencesHashChainDistanceOnly(int xSize, int ySize, MemoryAllocator memoryAllocator, ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LHashChain hashChain, Vp8LBackwardRefs refs, IMemoryOwner`1<ushort> distArrayBuffer);
    [NullableContextAttribute("0")]
private static int TraceBackwards(Span`1<ushort> distArray, int distArraySize);
    [NullableContextAttribute("0")]
private static void BackwardReferencesHashChainFollowChosenPath(ReadOnlySpan`1<UInt32> bgra, int cacheBits, Span`1<ushort> chosenPath, int chosenPathSize, Vp8LHashChain hashChain, Vp8LBackwardRefs backwardRefs);
    [NullableContextAttribute("0")]
private static void AddSingleLiteralWithCostModel(ReadOnlySpan`1<UInt32> bgra, ColorCache colorCache, CostModel costModel, int idx, bool useColorCache, float prevCost, Span`1<float> cost, Span`1<ushort> distArray);
    private static void BackwardReferencesLz77(int xSize, int ySize, ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LHashChain hashChain, Vp8LBackwardRefs refs);
    private static void BackwardReferencesLz77Box(int xSize, int ySize, ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LHashChain hashChainBest, Vp8LHashChain hashChain, Vp8LBackwardRefs refs);
    [NullableContextAttribute("0")]
private static void BackwardReferencesRle(int xSize, int ySize, ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LBackwardRefs refs);
    [NullableContextAttribute("0")]
private static void BackwardRefsWithLocalCache(ReadOnlySpan`1<UInt32> bgra, int cacheBits, Vp8LBackwardRefs refs);
    private static void BackwardReferences2DLocality(int xSize, Vp8LBackwardRefs refs);
    private static void AddSingleLiteral(UInt32 pixel, bool useColorCache, ColorCache colorCache, Vp8LBackwardRefs refs);
    public static int DistanceToPlaneCode(int xSize, int dist);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.ColorCache : object {
    private static UInt32 HashMul;
    [CompilerGeneratedAttribute]
private UInt32[] <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashShift>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashBits>k__BackingField;
    public UInt32[] Colors { get; }
    public int HashShift { get; }
    public int HashBits { get; }
    public ColorCache(int hashBits);
    [CompilerGeneratedAttribute]
public UInt32[] get_Colors();
    [CompilerGeneratedAttribute]
public int get_HashShift();
    [CompilerGeneratedAttribute]
public int get_HashBits();
    public void Insert(UInt32 bgra);
    public UInt32 Lookup(int key);
    public int Contains(UInt32 bgra);
    public int GetIndex(UInt32 bgra);
    public void Set(UInt32 key, UInt32 bgra);
    public static int HashPix(UInt32 argb, int shift);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.ColorSpaceTransformUtils : object {
    public static void CollectColorBlueTransforms(Span`1<UInt32> bgra, int stride, int tileWidth, int tileHeight, int greenToBlue, int redToBlue, Span`1<int> histo);
    private static void CollectColorBlueTransformsNoneVectorized(Span`1<UInt32> bgra, int stride, int tileWidth, int tileHeight, int greenToBlue, int redToBlue, Span`1<int> histo);
    public static void CollectColorRedTransforms(Span`1<UInt32> bgra, int stride, int tileWidth, int tileHeight, int greenToRed, Span`1<int> histo);
    private static void CollectColorRedTransformsNoneVectorized(Span`1<UInt32> bgra, int stride, int tileWidth, int tileHeight, int greenToRed, Span`1<int> histo);
}
[DebuggerDisplayAttribute("Start: {Start}, End: {End}, Cost: {Cost}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CostCacheInterval : object {
    [CompilerGeneratedAttribute]
private double <Cost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public double Cost { get; public set; }
    public int Start { get; public set; }
    public int End { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Cost();
    [CompilerGeneratedAttribute]
public void set_Cost(double value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Start: {Start}, End: {End}, Cost: {Cost}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CostInterval : object {
    [CompilerGeneratedAttribute]
private float <Cost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private CostInterval <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private CostInterval <Next>k__BackingField;
    public float Cost { get; public set; }
    public int Start { get; public set; }
    public int End { get; public set; }
    public int Index { get; public set; }
    public CostInterval Previous { get; public set; }
    public CostInterval Next { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Cost();
    [CompilerGeneratedAttribute]
public void set_Cost(float value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public CostInterval get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(CostInterval value);
    [CompilerGeneratedAttribute]
public CostInterval get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(CostInterval value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CostManager : object {
    [NullableAttribute("2")]
private CostInterval head;
    private static int FreeIntervalsStartCount;
    private Stack`1<CostInterval> freeIntervals;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <CostCache>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheIntervalsSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<float> <Costs>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<ushort> <DistArray>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CostCacheInterval> <CacheIntervals>k__BackingField;
    public int Count { get; public set; }
    public List`1<double> CostCache { get; }
    public int CacheIntervalsSize { get; }
    public IMemoryOwner`1<float> Costs { get; }
    public IMemoryOwner`1<ushort> DistArray { get; }
    public List`1<CostCacheInterval> CacheIntervals { get; }
    public CostManager(MemoryAllocator memoryAllocator, IMemoryOwner`1<ushort> distArray, int pixCount, CostModel costModel);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public List`1<double> get_CostCache();
    [CompilerGeneratedAttribute]
public int get_CacheIntervalsSize();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<float> get_Costs();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<ushort> get_DistArray();
    [CompilerGeneratedAttribute]
public List`1<CostCacheInterval> get_CacheIntervals();
    public void UpdateCostAtIndex(int i, bool doCleanIntervals);
    public void PushInterval(double distanceCost, int position, int len);
    [NullableContextAttribute("2")]
private void PopInterval(CostInterval interval);
    [NullableContextAttribute("2")]
private void InsertInterval(CostInterval intervalIn, float cost, int position, int start, int end);
    private void PositionOrphanInterval(CostInterval current, CostInterval previous);
    [NullableContextAttribute("2")]
private void ConnectIntervals(CostInterval prev, CostInterval next);
    private void UpdateCost(int i, int position, float cost);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CostModel : object {
    private MemoryAllocator memoryAllocator;
    private static int ValuesInBytes;
    [CompilerGeneratedAttribute]
private Double[] <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Red>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Blue>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Literal>k__BackingField;
    public Double[] Alpha { get; }
    public Double[] Red { get; }
    public Double[] Blue { get; }
    public Double[] Distance { get; }
    public Double[] Literal { get; }
    public CostModel(MemoryAllocator memoryAllocator, int literalArraySize);
    [CompilerGeneratedAttribute]
public Double[] get_Alpha();
    [CompilerGeneratedAttribute]
public Double[] get_Red();
    [CompilerGeneratedAttribute]
public Double[] get_Blue();
    [CompilerGeneratedAttribute]
public Double[] get_Distance();
    [CompilerGeneratedAttribute]
public Double[] get_Literal();
    public void Build(int xSize, int cacheBits, Vp8LBackwardRefs backwardRefs);
    public double GetLengthCost(int length);
    public double GetDistanceCost(int distance);
    public double GetCacheCost(UInt32 idx);
    public double GetLiteralCost(UInt32 v);
    [NullableContextAttribute("0")]
private static void ConvertPopulationCountTableToBitEstimates(int numSymbols, Span`1<UInt32> populationCounts, Double[] output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CrunchConfig : object {
    [CompilerGeneratedAttribute]
private EntropyIx <EntropyIdx>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CrunchSubConfig> <SubConfigs>k__BackingField;
    public EntropyIx EntropyIdx { get; public set; }
    public List`1<CrunchSubConfig> SubConfigs { get; }
    [CompilerGeneratedAttribute]
public EntropyIx get_EntropyIdx();
    [CompilerGeneratedAttribute]
public void set_EntropyIdx(EntropyIx value);
    [CompilerGeneratedAttribute]
public List`1<CrunchSubConfig> get_SubConfigs();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.CrunchSubConfig : object {
    [CompilerGeneratedAttribute]
private int <Lz77>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotCache>k__BackingField;
    public int Lz77 { get; public set; }
    public bool DoNotCache { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Lz77();
    [CompilerGeneratedAttribute]
public void set_Lz77(int value);
    [CompilerGeneratedAttribute]
public bool get_DoNotCache();
    [CompilerGeneratedAttribute]
public void set_DoNotCache(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.DominantCostRange : object {
    [CompilerGeneratedAttribute]
private double <LiteralMax>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LiteralMin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RedMax>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RedMin>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BlueMax>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BlueMin>k__BackingField;
    public double LiteralMax { get; public set; }
    public double LiteralMin { get; public set; }
    public double RedMax { get; public set; }
    public double RedMin { get; public set; }
    public double BlueMax { get; public set; }
    public double BlueMin { get; public set; }
    [CompilerGeneratedAttribute]
public double get_LiteralMax();
    [CompilerGeneratedAttribute]
public void set_LiteralMax(double value);
    [CompilerGeneratedAttribute]
public double get_LiteralMin();
    [CompilerGeneratedAttribute]
public void set_LiteralMin(double value);
    [CompilerGeneratedAttribute]
public double get_RedMax();
    [CompilerGeneratedAttribute]
public void set_RedMax(double value);
    [CompilerGeneratedAttribute]
public double get_RedMin();
    [CompilerGeneratedAttribute]
public void set_RedMin(double value);
    [CompilerGeneratedAttribute]
public double get_BlueMax();
    [CompilerGeneratedAttribute]
public void set_BlueMax(double value);
    [CompilerGeneratedAttribute]
public double get_BlueMin();
    [CompilerGeneratedAttribute]
public void set_BlueMin(double value);
    public void UpdateDominantCostRange(Vp8LHistogram h);
    public int GetHistoBinIndex(Vp8LHistogram h, int numPartitions);
    private static int GetBinIdForEntropy(double min, double max, double val, int numPartitions);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HistogramBinInfo : ValueType {
    public short First;
    public ushort NumCombineFailures;
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.HistogramEncoder : object {
    private static int NumPartitions;
    private static int BinSize;
    private static int MaxHistoGreedy;
    private static UInt32 NonTrivialSym;
    private static ushort InvalidHistogramSymbol;
    public static void GetHistoImageSymbols(MemoryAllocator memoryAllocator, int xSize, int ySize, Vp8LBackwardRefs refs, UInt32 quality, int histoBits, int cacheBits, Vp8LHistogramSet imageHisto, Vp8LHistogram tmpHisto, Span`1<ushort> histogramSymbols);
    private static void RemoveEmptyHistograms(Vp8LHistogramSet histograms);
    private static void HistogramBuild(int xSize, int histoBits, Vp8LBackwardRefs backwardRefs, Vp8LHistogramSet histograms);
    private static void HistogramAnalyzeEntropyBin(Vp8LHistogramSet histograms, Span`1<ushort> binMap);
    private static int HistogramCopyAndAnalyze(Vp8LHistogramSet origHistograms, Vp8LHistogramSet histograms, Span`1<ushort> histogramSymbols);
    private static void HistogramCombineEntropyBin(Vp8LHistogramSet histograms, Span`1<ushort> clusters, Span`1<ushort> clusterMappings, Vp8LHistogram curCombo, ReadOnlySpan`1<ushort> binMap, int numBins, double combineCostFactor);
    private static void OptimizeHistogramSymbols(Span`1<ushort> clusterMappings, int numClusters, Span`1<ushort> clusterMappingsTmp, Span`1<ushort> symbols);
    private static bool HistogramCombineStochastic(Vp8LHistogramSet histograms, int minClusterSize);
    private static void HistogramCombineGreedy(Vp8LHistogramSet histograms);
    private static void HistogramRemap(Vp8LHistogramSet input, Vp8LHistogramSet output, Span`1<ushort> symbols);
    private static double HistoPriorityListPush(List`1<HistogramPair> histoList, int maxSize, Vp8LHistogramSet histograms, int idx1, int idx2, double threshold, Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy);
    private static void HistoListUpdatePair(Vp8LHistogram h1, Vp8LHistogram h2, Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy, double threshold, HistogramPair pair);
    private static void HistoListUpdateHead(List`1<HistogramPair> histoList, HistogramPair pair);
    private static void HistogramAdd(Vp8LHistogram a, Vp8LHistogram b, Vp8LHistogram output);
    private static double GetCombineCostFactor(int histoSize, UInt32 quality);
    private static UInt32 MyRand(UInt32& seed);
}
[DebuggerDisplayAttribute("Idx1: {Idx1}, Idx2: {Idx2}, CostDiff: {CostDiff}, CostCombo: {CostCombo}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HistogramPair : object {
    [CompilerGeneratedAttribute]
private int <Idx1>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Idx2>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CostDiff>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CostCombo>k__BackingField;
    public int Idx1 { get; public set; }
    public int Idx2 { get; public set; }
    public double CostDiff { get; public set; }
    public double CostCombo { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Idx1();
    [CompilerGeneratedAttribute]
public void set_Idx1(int value);
    [CompilerGeneratedAttribute]
public int get_Idx2();
    [CompilerGeneratedAttribute]
public void set_Idx2(int value);
    [CompilerGeneratedAttribute]
public double get_CostDiff();
    [CompilerGeneratedAttribute]
public void set_CostDiff(double value);
    [CompilerGeneratedAttribute]
public double get_CostCombo();
    [CompilerGeneratedAttribute]
public void set_CostCombo(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HTreeGroup : ValueType {
    [CompilerGeneratedAttribute]
private List`1<HuffmanCode[]> <HTrees>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrivialLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LiteralArb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrivialCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePackedTable>k__BackingField;
    [CompilerGeneratedAttribute]
private HuffmanCode[] <PackedTable>k__BackingField;
    public List`1<HuffmanCode[]> HTrees { get; }
    public bool IsTrivialLiteral { get; public set; }
    public UInt32 LiteralArb { get; public set; }
    public bool IsTrivialCode { get; public set; }
    public bool UsePackedTable { get; public set; }
    public HuffmanCode[] PackedTable { get; public set; }
    public HTreeGroup(UInt32 packedTableSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public List`1<HuffmanCode[]> get_HTrees();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTrivialLiteral();
    [CompilerGeneratedAttribute]
public void set_IsTrivialLiteral(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LiteralArb();
    [CompilerGeneratedAttribute]
public void set_LiteralArb(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTrivialCode();
    [CompilerGeneratedAttribute]
public void set_IsTrivialCode(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UsePackedTable();
    [CompilerGeneratedAttribute]
public void set_UsePackedTable(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public HuffmanCode[] get_PackedTable();
    [CompilerGeneratedAttribute]
public void set_PackedTable(HuffmanCode[] value);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffIndex : object {
    public static int Green;
    public static int Red;
    public static int Blue;
    public static int Alpha;
    public static int Dist;
}
[DebuggerDisplayAttribute("BitsUsed: {BitsUsed}, Value: {Value}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffmanCode : ValueType {
    [CompilerGeneratedAttribute]
private int <BitsUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public int BitsUsed { get; public set; }
    public UInt32 Value { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BitsUsed();
    [CompilerGeneratedAttribute]
public void set_BitsUsed(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(UInt32 value);
}
[DebuggerDisplayAttribute("TotalCount = {TotalCount}, Value = {Value}, Left = {PoolIndexLeft}, Right = {PoolIndexRight}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffmanTree : ValueType {
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PoolIndexLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PoolIndexRight>k__BackingField;
    public int TotalCount { get; public set; }
    public int Value { get; public set; }
    public int PoolIndexLeft { get; public set; }
    public int PoolIndexRight { get; public set; }
    private HuffmanTree(HuffmanTree other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_PoolIndexLeft();
    [CompilerGeneratedAttribute]
public void set_PoolIndexLeft(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_PoolIndexRight();
    [CompilerGeneratedAttribute]
public void set_PoolIndexRight(int value);
    public static int Compare(HuffmanTree t1, HuffmanTree t2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffmanTreeCode : ValueType {
    [CompilerGeneratedAttribute]
private int <NumSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CodeLengths>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <Codes>k__BackingField;
    public int NumSymbols { get; public set; }
    public Byte[] CodeLengths { get; public set; }
    public Int16[] Codes { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumSymbols();
    [CompilerGeneratedAttribute]
public void set_NumSymbols(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_CodeLengths();
    [CompilerGeneratedAttribute]
public void set_CodeLengths(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Int16[] get_Codes();
    [CompilerGeneratedAttribute]
public void set_Codes(Int16[] value);
}
[DebuggerDisplayAttribute("Code = {Code}, ExtraBits = {ExtraBits}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffmanTreeToken : object {
    [CompilerGeneratedAttribute]
private byte <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ExtraBits>k__BackingField;
    public byte Code { get; public set; }
    public byte ExtraBits { get; public set; }
    [CompilerGeneratedAttribute]
public byte get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(byte value);
    [CompilerGeneratedAttribute]
public byte get_ExtraBits();
    [CompilerGeneratedAttribute]
public void set_ExtraBits(byte value);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.HuffmanUtils : object {
    public static int HuffmanTableBits;
    public static int HuffmanPackedBits;
    public static int HuffmanTableMask;
    public static UInt32 HuffmanPackedTableSize;
    [NullableAttribute("1")]
private static Byte[] ReversedBits;
    private static HuffmanUtils();
    public static void CreateHuffmanTree(Span`1<UInt32> histogram, int treeDepthLimit, Boolean[] bufRle, Span`1<HuffmanTree> huffTree, HuffmanTreeCode huffCode);
    public static void OptimizeHuffmanForRle(int length, Boolean[] goodForRle, Span`1<UInt32> counts);
    public static void GenerateOptimalTree(Span`1<HuffmanTree> tree, Span`1<UInt32> histogram, int histogramSize, int treeDepthLimit, Byte[] bitDepths);
    [NullableContextAttribute("1")]
public static int CreateCompressedHuffmanTree(HuffmanTreeCode tree, HuffmanTreeToken[] tokensArray);
    public static int BuildHuffmanTable(Span`1<HuffmanCode> table, int rootBits, Int32[] codeLengths, int codeLengthsSize);
    private static int CodeRepeatedZeros(int repetitions, Span`1<HuffmanTreeToken> tokens);
    private static int CodeRepeatedValues(int repetitions, Span`1<HuffmanTreeToken> tokens, int value, int prevValue);
    private static void ConvertBitDepthsToSymbols(HuffmanTreeCode tree);
    private static void SetBitDepths(Span`1<HuffmanTree> tree, Span`1<HuffmanTree> pool, Byte[] bitDepths, int level);
    private static UInt32 ReverseBits(int numBits, UInt32 bits);
    private static int NextTableBitSize(ReadOnlySpan`1<int> count, int len, int rootBits);
    private static void ReplicateValue(Span`1<HuffmanCode> table, int step, int end, HuffmanCode code);
    private static int GetNextKey(int key, int len);
    private static bool ValuesShouldBeCollapsedToStrideAverage(int a, int b);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.LosslessUtils : object {
    private static int PrefixLookupIdxMax;
    private static int LogLookupIdxMax;
    private static int ApproxLogMax;
    private static int ApproxLogWithCorrectionMax;
    private static double Log2Reciprocal;
    public static int FindMatchLength(ReadOnlySpan`1<UInt32> array1, ReadOnlySpan`1<UInt32> array2, int bestLenMatch, int maxLimit);
    public static int VectorMismatch(ReadOnlySpan`1<UInt32> array1, ReadOnlySpan`1<UInt32> array2, int length);
    public static int MaxFindCopyLength(int len);
    public static int PrefixEncodeBits(int distance, Int32& extraBits);
    public static int PrefixEncode(int distance, Int32& extraBits, Int32& extraBitsValue);
    public static void AddGreenToBlueAndRed(Span`1<UInt32> pixelData);
    private static void AddGreenToBlueAndRedScalar(Span`1<UInt32> pixelData);
    public static void SubtractGreenFromBlueAndRed(Span`1<UInt32> pixelData);
    private static void SubtractGreenFromBlueAndRedScalar(Span`1<UInt32> pixelData);
    public static void ColorIndexInverseTransform(Vp8LTransform transform, Span`1<UInt32> pixelData);
    public static void ColorSpaceInverseTransform(Vp8LTransform transform, Span`1<UInt32> pixelData);
    public static void TransformColor(Vp8LMultipliers m, Span`1<UInt32> pixelData, int numPixels);
    private static void TransformColorScalar(Vp8LMultipliers m, Span`1<UInt32> data, int numPixels);
    public static void TransformColorInverse(Vp8LMultipliers m, Span`1<UInt32> pixelData);
    private static void TransformColorInverseScalar(Vp8LMultipliers m, Span`1<UInt32> pixelData);
    public static void PredictorInverseTransform(Vp8LTransform transform, Span`1<UInt32> pixelData, Span`1<UInt32> outputSpan);
    public static void ExpandColorMap(int numColors, Span`1<UInt32> transformData, Span`1<UInt32> newColorMap);
    public static UInt32 SubPixels(UInt32 a, UInt32 b);
    public static void BundleColorMap(Span`1<byte> row, int width, int xBits, Span`1<UInt32> dst);
    public static float CombinedShannonEntropy(Span`1<int> x, Span`1<int> y);
    public static byte TransformColorRed(sbyte greenToRed, UInt32 argb);
    public static byte TransformColorBlue(sbyte greenToBlue, sbyte redToBlue, UInt32 argb);
    public static float FastLog2(UInt32 v);
    public static float FastSLog2(UInt32 v);
    public static void ColorCodeToMultipliers(UInt32 colorCode, Vp8LMultipliers& m);
    public static int NearLosslessBits(int nearLosslessQuality);
    private static float FastSLog2Slow(UInt32 v);
    private static float FastLog2Slow(UInt32 v);
    private static int PrefixEncodeBitsNoLut(int distance, Int32& extraBits);
    private static int PrefixEncodeNoLut(int distance, Int32& extraBits, Int32& extraBitsValue);
    private static void PredictorAdd0(UInt32* input, int numberOfPixels, UInt32* output);
    private static void PredictorAdd1(UInt32* input, int numberOfPixels, UInt32* output);
    private static void PredictorAdd2(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd3(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd4(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd5(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd6(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd7(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd8(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd9(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd10(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd11(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output, Span`1<short> scratch);
    private static void PredictorAdd12(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    private static void PredictorAdd13(UInt32* input, UInt32* upper, int numberOfPixels, UInt32* output);
    public static UInt32 Predictor2(UInt32 left, UInt32* top);
    public static UInt32 Predictor3(UInt32 left, UInt32* top);
    public static UInt32 Predictor4(UInt32 left, UInt32* top);
    public static UInt32 Predictor5(UInt32 left, UInt32* top);
    public static UInt32 Predictor6(UInt32 left, UInt32* top);
    public static UInt32 Predictor7(UInt32 left, UInt32* top);
    public static UInt32 Predictor8(UInt32 left, UInt32* top);
    public static UInt32 Predictor9(UInt32 left, UInt32* top);
    public static UInt32 Predictor10(UInt32 left, UInt32* top);
    public static UInt32 Predictor11(UInt32 left, UInt32* top, Span`1<short> scratch);
    public static UInt32 Predictor12(UInt32 left, UInt32* top);
    public static UInt32 Predictor13(UInt32 left, UInt32* top);
    public static void PredictorSub0(UInt32* input, int numPixels, UInt32* output);
    public static void PredictorSub1(UInt32* input, int numPixels, UInt32* output);
    public static void PredictorSub2(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub3(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub4(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub5(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub6(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub7(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub8(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub9(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub10(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub11(UInt32* input, UInt32* upper, int numPixels, UInt32* output, Span`1<short> scratch);
    public static void PredictorSub12(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static void PredictorSub13(UInt32* input, UInt32* upper, int numPixels, UInt32* output);
    public static int SubSampleSize(int size, int samplingBits);
    public static UInt32 AddPixels(UInt32 a, UInt32 b);
    public static short Cst5b(int x);
    private static UInt32 ClampedAddSubtractFull(UInt32 c0, UInt32 c1, UInt32 c2);
    private static UInt32 ClampedAddSubtractHalf(UInt32 c0, UInt32 c1, UInt32 c2);
    private static int AddSubtractComponentHalf(int a, int b);
    private static int AddSubtractComponentFull(int a, int b, int c);
    private static UInt32 Clip255(UInt32 a);
    private static Vector128`1<int> MkCst16(int hi, int lo);
    private static Vector256`1<int> MkCst32(int hi, int lo);
    private static UInt32 Select(UInt32 a, UInt32 b, UInt32 c, Span`1<short> scratch);
    private static int Sub3(int a, int b, int c);
    private static UInt32 Average2(UInt32 a0, UInt32 a1);
    private static UInt32 Average3(UInt32 a0, UInt32 a1, UInt32 a2);
    private static UInt32 Average4(UInt32 a0, UInt32 a1, UInt32 a2, UInt32 a3);
    private static UInt32 GetArgbIndex(UInt32 idx);
    private static int ColorTransformDelta(sbyte colorPred, sbyte color);
    private static sbyte U32ToS8(UInt32 v);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.NearLosslessEnc : object {
    private static int MinDimForNearLossless;
    public static void ApplyNearLossless(int xSize, int ySize, int quality, Span`1<UInt32> argbSrc, Span`1<UInt32> argbDst, int stride);
    private static void NearLossless(int xSize, int ySize, Span`1<UInt32> argbSrc, int stride, int limitBits, Span`1<UInt32> copyBuffer, Span`1<UInt32> argbDst);
    private static UInt32 ClosestDiscretizedArgb(UInt32 a, int bits);
    private static UInt32 FindClosestDiscretized(UInt32 a, int bits);
    private static bool IsSmooth(Span`1<UInt32> prevRow, Span`1<UInt32> currRow, Span`1<UInt32> nextRow, int ix, int limit);
    private static bool IsNear(UInt32 a, UInt32 b, int limit);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.OwnedVp8LHistogram : Vp8LHistogram {
    [NullableAttribute("1")]
private IMemoryOwner`1<UInt32> bufferOwner;
    private MemoryHandle bufferHandle;
    private bool isDisposed;
    private OwnedVp8LHistogram(IMemoryOwner`1<UInt32> bufferOwner, MemoryHandle& bufferHandle, UInt32* basePointer, int paletteCodeBits);
    [NullableContextAttribute("1")]
public static OwnedVp8LHistogram Create(MemoryAllocator memoryAllocator, int paletteCodeBits);
    [NullableContextAttribute("1")]
public static OwnedVp8LHistogram Create(MemoryAllocator memoryAllocator, Vp8LBackwardRefs refs, int paletteCodeBits);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Mode: {Mode}, Len: {Len}, BgraOrDistance: {BgraOrDistance}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.PixOrCopy : object {
    [CompilerGeneratedAttribute]
private PixOrCopyMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Len>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BgraOrDistance>k__BackingField;
    public PixOrCopyMode Mode { get; public set; }
    public ushort Len { get; public set; }
    public UInt32 BgraOrDistance { get; public set; }
    [CompilerGeneratedAttribute]
public PixOrCopyMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(PixOrCopyMode value);
    [CompilerGeneratedAttribute]
public ushort get_Len();
    [CompilerGeneratedAttribute]
public void set_Len(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_BgraOrDistance();
    [CompilerGeneratedAttribute]
public void set_BgraOrDistance(UInt32 value);
    public static PixOrCopy CreateCacheIdx(int idx);
    public static PixOrCopy CreateLiteral(UInt32 bgra);
    public static PixOrCopy CreateCopy(UInt32 distance, ushort len);
    public int Literal(int component);
    public UInt32 CacheIdx();
    public ushort Length();
    public UInt32 Distance();
    public bool IsLiteral();
    public bool IsCacheIdx();
    public bool IsCopy();
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossless.PixOrCopyMode : Enum {
    public byte value__;
    public static PixOrCopyMode Literal;
    public static PixOrCopyMode CacheIdx;
    public static PixOrCopyMode Copy;
    public static PixOrCopyMode None;
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossless.PredictorEncoder : object {
    [NullableAttribute("1")]
private static SByte[][] Offset;
    private static int GreenRedToBlueNumAxis;
    private static int GreenRedToBlueMaxIters;
    private static float MaxDiffCost;
    private static UInt32 MaskAlpha;
    private static float SpatialPredictorBias;
    private static int PredLowEffort;
    private static ReadOnlySpan`1<sbyte> DeltaLut { get; }
    private static PredictorEncoder();
    private static ReadOnlySpan`1<sbyte> get_DeltaLut();
    public static void ResidualImage(int width, int height, int bits, Span`1<UInt32> bgra, Span`1<UInt32> bgraScratch, Span`1<UInt32> image, Int32[][] histoArgb, Int32[][] bestHisto, bool nearLossless, int nearLosslessQuality, WebpTransparentColorMode transparentColorMode, bool usedSubtractGreen, bool lowEffort);
    public static void ColorSpaceTransform(int width, int height, int bits, UInt32 quality, Span`1<UInt32> bgra, Span`1<UInt32> image, Span`1<int> scratch);
    private static int GetBestPredictorForTile(int width, int height, int tileX, int tileY, int bits, Int32[][] accumulated, Span`1<UInt32> argbScratch, Span`1<UInt32> argb, Int32[][] histoArgb, Int32[][] bestHisto, int maxQuantization, WebpTransparentColorMode transparentColorMode, bool usedSubtractGreen, bool nearLossless, Span`1<UInt32> modes, Span`1<short> scratch);
    private static void GetResidual(int width, int height, Span`1<UInt32> upperRowSpan, Span`1<UInt32> currentRowSpan, Span`1<byte> maxDiffs, int mode, int xStart, int xEnd, int y, int maxQuantization, WebpTransparentColorMode transparentColorMode, bool usedSubtractGreen, bool nearLossless, Span`1<UInt32> output, Span`1<short> scratch);
    private static UInt32 NearLossless(UInt32 value, UInt32 predict, int maxQuantization, int maxDiff, bool usedSubtractGreen);
    private static byte NearLosslessComponent(byte value, byte predict, byte boundary, int quantization);
    private static void CopyImageWithPrediction(int width, int height, int bits, Span`1<UInt32> modes, Span`1<UInt32> argbScratch, Span`1<UInt32> argb, int maxQuantization, WebpTransparentColorMode transparentColorMode, bool usedSubtractGreen, bool nearLossless, bool lowEffort);
    private static void PredictBatch(int mode, int xStart, int y, int numPixels, Span`1<UInt32> currentSpan, Span`1<UInt32> upperSpan, Span`1<UInt32> outputSpan, Span`1<short> scratch);
    private static void MaxDiffsForRow(int width, int stride, Span`1<UInt32> argb, int offset, Span`1<byte> maxDiffs, bool usedSubtractGreen);
    private static int MaxDiffBetweenPixels(UInt32 p1, UInt32 p2);
    private static int MaxDiffAroundPixel(UInt32 current, UInt32 up, UInt32 down, UInt32 left, UInt32 right);
    [NullableContextAttribute("1")]
private static void UpdateHisto(Int32[][] histoArgb, UInt32 argb);
    private static UInt32 AddGreenToBlueAndRed(UInt32 argb);
    private static void CopyTileWithColorTransform(int xSize, int ySize, int tileX, int tileY, int maxTileSize, Vp8LMultipliers colorTransform, Span`1<UInt32> argb);
    private static Vp8LMultipliers GetBestColorTransformForTile(int tileX, int tileY, int bits, Vp8LMultipliers prevX, Vp8LMultipliers prevY, UInt32 quality, int xSize, int ySize, Int32[] accumulatedRedHisto, Int32[] accumulatedBlueHisto, Span`1<UInt32> argb, Span`1<int> scratch);
    private static void GetBestGreenToRed(Span`1<UInt32> argb, int stride, Span`1<int> scratch, int tileWidth, int tileHeight, Vp8LMultipliers prevX, Vp8LMultipliers prevY, UInt32 quality, Int32[] accumulatedRedHisto, Vp8LMultipliers& bestTx);
    private static void GetBestGreenRedToBlue(Span`1<UInt32> argb, int stride, Span`1<int> scratch, int tileWidth, int tileHeight, Vp8LMultipliers prevX, Vp8LMultipliers prevY, UInt32 quality, Int32[] accumulatedBlueHisto, Vp8LMultipliers& bestTx);
    private static double GetPredictionCostCrossColorRed(Span`1<UInt32> argb, int stride, Span`1<int> scratch, int tileWidth, int tileHeight, Vp8LMultipliers prevX, Vp8LMultipliers prevY, int greenToRed, Int32[] accumulatedRedHisto);
    private static double GetPredictionCostCrossColorBlue(Span`1<UInt32> argb, int stride, Span`1<int> scratch, int tileWidth, int tileHeight, Vp8LMultipliers prevX, Vp8LMultipliers prevY, int greenToBlue, int redToBlue, Int32[] accumulatedBlueHisto);
    [NullableContextAttribute("1")]
private static float PredictionCostSpatialHistogram(Int32[][] accumulated, Int32[][] tile);
    private static double PredictionCostCrossColor(Int32[] accumulated, Span`1<int> counts);
    private static float PredictionCostSpatial(Span`1<int> counts, int weight0, double expVal);
    private static byte NearLosslessDiff(byte a, byte b);
    private static UInt32 MultipliersToColorCode(Vp8LMultipliers m);
    private static int GetMin(int a, int b);
    private static int GetMax(int a, int b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LBackwardRefs : object {
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PixOrCopy> <Refs>k__BackingField;
    public int BlockSize { get; public set; }
    public List`1<PixOrCopy> Refs { get; }
    public Vp8LBackwardRefs(int pixels);
    [CompilerGeneratedAttribute]
public int get_BlockSize();
    [CompilerGeneratedAttribute]
public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public List`1<PixOrCopy> get_Refs();
    public void Add(PixOrCopy pixOrCopy);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LBitEntropy : object {
    private static UInt32 NonTrivialSym;
    [CompilerGeneratedAttribute]
private double <Entropy>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NoneZeros>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxVal>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NoneZeroCode>k__BackingField;
    public double Entropy { get; public set; }
    public UInt32 Sum { get; public set; }
    public int NoneZeros { get; public set; }
    public UInt32 MaxVal { get; public set; }
    public UInt32 NoneZeroCode { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Entropy();
    [CompilerGeneratedAttribute]
public void set_Entropy(double value);
    [CompilerGeneratedAttribute]
public UInt32 get_Sum();
    [CompilerGeneratedAttribute]
public void set_Sum(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_NoneZeros();
    [CompilerGeneratedAttribute]
public void set_NoneZeros(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxVal();
    [CompilerGeneratedAttribute]
public void set_MaxVal(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NoneZeroCode();
    [CompilerGeneratedAttribute]
public void set_NoneZeroCode(UInt32 value);
    public void Init();
    public double BitsEntropyRefine();
    public void BitsEntropyUnrefined(Span`1<UInt32> array, int n);
    public void BitsEntropyUnrefined(Span`1<UInt32> x, int length, Vp8LStreaks stats);
    public void GetCombinedEntropyUnrefined(Span`1<UInt32> x, Span`1<UInt32> y, int length, Vp8LStreaks stats);
    public void GetEntropyUnrefined(Span`1<UInt32> x, int length, Vp8LStreaks stats);
    [NullableContextAttribute("1")]
private void GetEntropyUnrefined(UInt32 val, int i, UInt32& valPrev, Int32& iPrev, Vp8LStreaks stats);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LDecoder : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8LMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Vp8LTransform> <Transforms>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <Pixels>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public Vp8LMetadata Metadata { get; public set; }
    public List`1<Vp8LTransform> Transforms { get; public set; }
    public IMemoryOwner`1<UInt32> Pixels { get; }
    public Vp8LDecoder(int width, int height, MemoryAllocator memoryAllocator);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public Vp8LMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(Vp8LMetadata value);
    [CompilerGeneratedAttribute]
public List`1<Vp8LTransform> get_Transforms();
    [CompilerGeneratedAttribute]
public void set_Transforms(List`1<Vp8LTransform> value);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_Pixels();
    public sealed virtual void Dispose();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LEncoder : object {
    private ScratchBuffer scratch;
    private Int32[][] histoArgb;
    private Int32[][] bestHisto;
    private MemoryAllocator memoryAllocator;
    private Configuration configuration;
    private static int MaxRefsBlockPerImage;
    private static int MinBlockSize;
    private Vp8LBitWriter bitWriter;
    private UInt32 quality;
    private WebpEncodingMethod method;
    private WebpTransparentColorMode transparentColorMode;
    private bool skipMetadata;
    private bool nearLossless;
    private int nearLosslessQuality;
    private static int ApplyPaletteGreedyMax;
    private static int PaletteInvSizeBits;
    private static int PaletteInvSize;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <Bgra>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <EncodedData>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <BgraScratch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HistoBits>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransformBits>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <TransformData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheBits>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCrossColorTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSubtractGreenTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePredictorTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePalette>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaletteSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <Palette>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8LBackwardRefs[] <Refs>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8LHashChain <HashChain>k__BackingField;
    private static ReadOnlySpan`1<byte> StorageOrder { get; }
    private static ReadOnlySpan`1<byte> Order { get; }
    public IMemoryOwner`1<UInt32> Bgra { get; }
    public IMemoryOwner`1<UInt32> EncodedData { get; }
    public IMemoryOwner`1<UInt32> BgraScratch { get; public set; }
    public int CurrentWidth { get; public set; }
    public int HistoBits { get; public set; }
    public int TransformBits { get; public set; }
    public IMemoryOwner`1<UInt32> TransformData { get; public set; }
    public int CacheBits { get; public set; }
    public bool UseCrossColorTransform { get; public set; }
    public bool UseSubtractGreenTransform { get; public set; }
    public bool UsePredictorTransform { get; public set; }
    public bool UsePalette { get; public set; }
    public int PaletteSize { get; public set; }
    public IMemoryOwner`1<UInt32> Palette { get; }
    public Vp8LBackwardRefs[] Refs { get; }
    public Vp8LHashChain HashChain { get; }
    public Vp8LEncoder(MemoryAllocator memoryAllocator, Configuration configuration, int width, int height, UInt32 quality, bool skipMetadata, WebpEncodingMethod method, WebpTransparentColorMode transparentColorMode, bool nearLossless, int nearLosslessQuality);
    private static ReadOnlySpan`1<byte> get_StorageOrder();
    private static ReadOnlySpan`1<byte> get_Order();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_Bgra();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_EncodedData();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_BgraScratch();
    [CompilerGeneratedAttribute]
public void set_BgraScratch(IMemoryOwner`1<UInt32> value);
    [CompilerGeneratedAttribute]
public int get_CurrentWidth();
    [CompilerGeneratedAttribute]
public void set_CurrentWidth(int value);
    [CompilerGeneratedAttribute]
public int get_HistoBits();
    [CompilerGeneratedAttribute]
public void set_HistoBits(int value);
    [CompilerGeneratedAttribute]
public int get_TransformBits();
    [CompilerGeneratedAttribute]
public void set_TransformBits(int value);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_TransformData();
    [CompilerGeneratedAttribute]
public void set_TransformData(IMemoryOwner`1<UInt32> value);
    [CompilerGeneratedAttribute]
public int get_CacheBits();
    [CompilerGeneratedAttribute]
public void set_CacheBits(int value);
    [CompilerGeneratedAttribute]
public bool get_UseCrossColorTransform();
    [CompilerGeneratedAttribute]
public void set_UseCrossColorTransform(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSubtractGreenTransform();
    [CompilerGeneratedAttribute]
public void set_UseSubtractGreenTransform(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsePredictorTransform();
    [CompilerGeneratedAttribute]
public void set_UsePredictorTransform(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsePalette();
    [CompilerGeneratedAttribute]
public void set_UsePalette(bool value);
    [CompilerGeneratedAttribute]
public int get_PaletteSize();
    [CompilerGeneratedAttribute]
public void set_PaletteSize(int value);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_Palette();
    [CompilerGeneratedAttribute]
public Vp8LBackwardRefs[] get_Refs();
    [CompilerGeneratedAttribute]
public Vp8LHashChain get_HashChain();
    public WebpVp8X EncodeHeader(Image`1<TPixel> image, Stream stream, bool hasAnimation);
    public void EncodeFooter(Image`1<TPixel> image, WebpVp8X& vp8x, bool hasAlpha, Stream stream, long initialPosition);
    public bool Encode(ImageFrame`1<TPixel> frame, Rectangle bounds, WebpFrameMetadata frameMetadata, Stream stream, bool hasAnimation);
    public int EncodeAlphaImageData(Buffer2DRegion`1<TPixel> frame, IMemoryOwner`1<byte> alphaData);
    private void WriteImageSize(int inputImgWidth, int inputImgHeight);
    private void WriteAlphaAndVersion(bool hasAlpha);
    private void EncodeStream(int width, int height);
    public bool ConvertPixelsToBgra(Buffer2DRegion`1<TPixel> pixels);
    private CrunchConfig[] EncoderAnalyze(ReadOnlySpan`1<UInt32> bgra, int width, int height, Boolean& redAndBlueAlwaysZero);
    private void EncodeImage(int width, int height, bool useCache, CrunchConfig config, int cacheBits, bool lowEffort);
    private void EncodePalette(bool lowEffort);
    private void ApplySubtractGreen();
    private void ApplyPredictFilter(int width, int height, bool lowEffort);
    private void ApplyCrossColorFilter(int width, int height, bool lowEffort);
    private void EncodeImageNoHuffman(Span`1<UInt32> bgra, Vp8LHashChain hashChain, Vp8LBackwardRefs refsTmp1, Vp8LBackwardRefs refsTmp2, int width, int height, UInt32 quality, bool lowEffort);
    private void StoreHuffmanCode(Span`1<HuffmanTree> huffTree, HuffmanTreeToken[] tokens, HuffmanTreeCode huffmanCode);
    private void StoreFullHuffmanCode(Span`1<HuffmanTree> huffTree, HuffmanTreeToken[] tokens, HuffmanTreeCode tree);
    private void StoreHuffmanTreeToBitMask(HuffmanTreeToken[] tokens, int numTokens, HuffmanTreeCode huffmanCode);
    private void StoreHuffmanTreeOfHuffmanTreeToBitMask(Byte[] codeLengthBitDepth);
    private void StoreImageToBitMask(int width, int histoBits, Vp8LBackwardRefs backwardRefs, Span`1<ushort> histogramSymbols, HuffmanTreeCode[] huffmanCodes);
    private EntropyIx AnalyzeEntropy(ReadOnlySpan`1<UInt32> bgra, int width, int height, bool usePalette, int paletteSize, int transformBits, Boolean& redAndBlueAlwaysZero);
    private bool AnalyzeAndCreatePalette(ReadOnlySpan`1<UInt32> bgra, int width, int height);
    private static int GetColorPalette(ReadOnlySpan`1<UInt32> bgra, int width, int height, Span`1<UInt32> palette);
    private void MapImageFromPalette(int width, int height);
    private void ApplyPalette(Span`1<UInt32> src, int srcStride, Span`1<UInt32> dst, int dstStride, Span`1<UInt32> palette, int paletteSize, int width, int height, int xBits);
    private static void ApplyPaletteFor(int width, int height, Span`1<UInt32> palette, int hashIdx, Span`1<UInt32> src, int srcStride, Span`1<UInt32> dst, int dstStride, Span`1<byte> tmpRow, UInt32[] buffer, int xBits);
    private static void ApplyPaletteForWithIdxMap(int width, int height, Span`1<UInt32> palette, Span`1<UInt32> src, int srcStride, Span`1<UInt32> dst, int dstStride, Span`1<byte> tmpRow, UInt32[] idxMap, int xBits, UInt32[] paletteSorted, int paletteSize);
    private static void PrepareMapToPalette(Span`1<UInt32> palette, int numColors, UInt32[] sorted, UInt32[] idxMap);
    private static int SearchColorNoIdx(UInt32[] sorted, UInt32 color, int hi);
    private static void ClearHuffmanTreeIfOnlyOneSymbol(HuffmanTreeCode huffmanCode);
    private static bool PaletteHasNonMonotonousDeltas(Span`1<UInt32> palette, int numColors);
    private static void GreedyMinimizeDeltas(Span`1<UInt32> palette, int numColors);
    private static void GetHuffBitLengthsAndCodes(Vp8LHistogramSet histogramImage, HuffmanTreeCode[] huffmanCodes);
    private static UInt32 PaletteColorDistance(UInt32 col1, UInt32 col2);
    private static int GetHistoBits(WebpEncodingMethod method, bool usePalette, int width, int height);
    private static void BundleColorMap(Span`1<byte> row, int width, int xBits, Span`1<UInt32> dst);
    private static void BitWriterSwap(Vp8LBitWriter& src, Vp8LBitWriter& dst);
    private static int GetTransformBits(WebpEncodingMethod method, int histoBits);
    private static void AddSingle(UInt32 p, Span`1<UInt32> a, Span`1<UInt32> r, Span`1<UInt32> g, Span`1<UInt32> b);
    private static void AddSingleSubGreen(UInt32 p, Span`1<UInt32> r, Span`1<UInt32> b);
    private static UInt32 SearchColorGreedy(Span`1<UInt32> palette, UInt32 color);
    private static UInt32 ApplyPaletteHash0(UInt32 color);
    private static UInt32 ApplyPaletteHash1(UInt32 color);
    private static UInt32 ApplyPaletteHash2(UInt32 color);
    private static UInt32 HashPix(UInt32 pix);
    private static int PaletteCompareColorsForSort(UInt32 p1, UInt32 p2);
    private static UInt32 PaletteComponentDistance(UInt32 v);
    public void AllocateTransformBuffer(int width, int height);
    public void ClearRefs();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LHashChain : object {
    private static UInt32 HashMultiplierHi;
    private static UInt32 HashMultiplierLo;
    private static int HashBits;
    private static int HashSize;
    private static int WindowSizeBits;
    private static int WindowSize;
    private MemoryAllocator memoryAllocator;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <OffsetLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public IMemoryOwner`1<UInt32> OffsetLength { get; }
    public int Size { get; }
    public Vp8LHashChain(MemoryAllocator memoryAllocator, int size);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_OffsetLength();
    [CompilerGeneratedAttribute]
public int get_Size();
    [NullableContextAttribute("0")]
public void Fill(ReadOnlySpan`1<UInt32> bgra, UInt32 quality, int xSize, int ySize, bool lowEffort);
    public int FindLength(int basePosition);
    public int FindOffset(int basePosition);
    [NullableContextAttribute("0")]
private static UInt32 GetPixPairHash64(ReadOnlySpan`1<UInt32> bgra);
    private static int GetMaxItersForQuality(UInt32 quality);
    private static int GetWindowSizeForHashChain(UInt32 quality, int xSize);
    public sealed virtual void Dispose();
}
internal abstract class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LHistogram : object {
    private static UInt32 NonTrivialSym;
    private UInt32* red;
    private UInt32* blue;
    private UInt32* alpha;
    private UInt32* distance;
    private UInt32* literal;
    private UInt32* isUsed;
    private static int RedSize;
    private static int BlueSize;
    private static int AlphaSize;
    private static int DistanceSize;
    public static int LiteralSize;
    private static int UsedSize;
    public static int BufferSize;
    [CompilerGeneratedAttribute]
private int <PaletteCodeBits>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BitCost>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LiteralCost>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RedCost>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BlueCost>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TrivialSymbol>k__BackingField;
    public int PaletteCodeBits { get; public set; }
    public double BitCost { get; public set; }
    public double LiteralCost { get; public set; }
    public double RedCost { get; public set; }
    public double BlueCost { get; public set; }
    public Span`1<UInt32> Red { get; }
    public Span`1<UInt32> Blue { get; }
    public Span`1<UInt32> Alpha { get; }
    public Span`1<UInt32> Distance { get; }
    public Span`1<UInt32> Literal { get; }
    public UInt32 TrivialSymbol { get; public set; }
    private Span`1<UInt32> IsUsedSpan { get; }
    private Span`1<UInt32> TotalSpan { get; }
    protected Vp8LHistogram(UInt32* basePointer, Vp8LBackwardRefs refs, int paletteCodeBits);
    protected Vp8LHistogram(UInt32* basePointer, int paletteCodeBits);
    [CompilerGeneratedAttribute]
public int get_PaletteCodeBits();
    [CompilerGeneratedAttribute]
public void set_PaletteCodeBits(int value);
    [CompilerGeneratedAttribute]
public double get_BitCost();
    [CompilerGeneratedAttribute]
public void set_BitCost(double value);
    [CompilerGeneratedAttribute]
public double get_LiteralCost();
    [CompilerGeneratedAttribute]
public void set_LiteralCost(double value);
    [CompilerGeneratedAttribute]
public double get_RedCost();
    [CompilerGeneratedAttribute]
public void set_RedCost(double value);
    [CompilerGeneratedAttribute]
public double get_BlueCost();
    [CompilerGeneratedAttribute]
public void set_BlueCost(double value);
    public Span`1<UInt32> get_Red();
    public Span`1<UInt32> get_Blue();
    public Span`1<UInt32> get_Alpha();
    public Span`1<UInt32> get_Distance();
    public Span`1<UInt32> get_Literal();
    [CompilerGeneratedAttribute]
public UInt32 get_TrivialSymbol();
    [CompilerGeneratedAttribute]
public void set_TrivialSymbol(UInt32 value);
    private Span`1<UInt32> get_IsUsedSpan();
    private Span`1<UInt32> get_TotalSpan();
    public bool IsUsed(int index);
    public void IsUsed(int index, bool value);
    [NullableContextAttribute("1")]
public void CopyTo(Vp8LHistogram other);
    public void Clear();
    [NullableContextAttribute("1")]
public void StoreRefs(Vp8LBackwardRefs refs);
    [NullableContextAttribute("1")]
public void AddSinglePixOrCopy(PixOrCopy v, bool useDistanceModifier, int xSize);
    public int NumCodes();
    [NullableContextAttribute("1")]
public double EstimateBits(Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy);
    [NullableContextAttribute("1")]
public void UpdateHistogramCost(Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy);
    [NullableContextAttribute("1")]
public double AddEval(Vp8LHistogram b, Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy, double costThreshold, Vp8LHistogram output);
    [NullableContextAttribute("1")]
public double AddThresh(Vp8LHistogram b, Vp8LStreaks stats, Vp8LBitEntropy bitsEntropy, double costThreshold);
    [NullableContextAttribute("1")]
public void Add(Vp8LHistogram b, Vp8LHistogram output);
    [NullableContextAttribute("1")]
public bool GetCombinedHistogramEntropy(Vp8LHistogram b, Vp8LStreaks stats, Vp8LBitEntropy bitEntropy, double costThreshold, double costInitial, Double& cost);
    [NullableContextAttribute("1")]
private void AddLiteral(Vp8LHistogram b, Vp8LHistogram output, int literalSize);
    [NullableContextAttribute("1")]
private void AddRed(Vp8LHistogram b, Vp8LHistogram output, int size);
    [NullableContextAttribute("1")]
private void AddBlue(Vp8LHistogram b, Vp8LHistogram output, int size);
    [NullableContextAttribute("1")]
private void AddAlpha(Vp8LHistogram b, Vp8LHistogram output, int size);
    [NullableContextAttribute("1")]
private void AddDistance(Vp8LHistogram b, Vp8LHistogram output, int size);
    private static double GetCombinedEntropy(Span`1<UInt32> x, Span`1<UInt32> y, int length, bool isXUsed, bool isYUsed, bool trivialAtEnd, Vp8LStreaks stats, Vp8LBitEntropy bitEntropy);
    private static double ExtraCostCombined(Span`1<UInt32> x, Span`1<UInt32> y, int length);
    [NullableContextAttribute("1")]
private double PopulationCost(Span`1<UInt32> population, int length, UInt32& trivialSym, int isUsedIndex, Vp8LStreaks stats, Vp8LBitEntropy bitEntropy);
    private static double ExtraCost(Span`1<UInt32> population, int length);
    private static void AddVector(Span`1<UInt32> a, Span`1<UInt32> b, Span`1<UInt32> output, int count);
}
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LHistogramSet : object {
    private IMemoryOwner`1<UInt32> buffer;
    private MemoryHandle bufferHandle;
    private List`1<Vp8LHistogram> items;
    private bool isDisposed;
    public int Count { get; }
    public Vp8LHistogram Item { get; public set; }
    public Vp8LHistogramSet(MemoryAllocator memoryAllocator, int capacity, int cacheBits);
    public Vp8LHistogramSet(MemoryAllocator memoryAllocator, Vp8LBackwardRefs refs, int capacity, int cacheBits);
    public Vp8LHistogramSet(int capacity);
    public int get_Count();
    public Vp8LHistogram get_Item(int index);
    public void set_Item(int index, Vp8LHistogram value);
    public void RemoveAt(int index);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<Vp8LHistogram> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ConditionalAttribute("DEBUG")]
private void CheckDisposed();
    private static void ThrowDisposed();
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LLz77Type : Enum {
    public int value__;
    public static Vp8LLz77Type Lz77Standard;
    public static Vp8LLz77Type Lz77Rle;
    public static Vp8LLz77Type Lz77Box;
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LMetadata : object {
    [CompilerGeneratedAttribute]
private int <ColorCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorCache <ColorCache>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HuffmanMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HuffmanSubSampleBits>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HuffmanXSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <HuffmanImage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumHTreeGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private HTreeGroup[] <HTreeGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private HuffmanCode[] <HuffmanTables>k__BackingField;
    public int ColorCacheSize { get; public set; }
    public ColorCache ColorCache { get; public set; }
    public int HuffmanMask { get; public set; }
    public int HuffmanSubSampleBits { get; public set; }
    public int HuffmanXSize { get; public set; }
    public IMemoryOwner`1<UInt32> HuffmanImage { get; public set; }
    public int NumHTreeGroups { get; public set; }
    public HTreeGroup[] HTreeGroups { get; public set; }
    public HuffmanCode[] HuffmanTables { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ColorCacheSize();
    [CompilerGeneratedAttribute]
public void set_ColorCacheSize(int value);
    [CompilerGeneratedAttribute]
public ColorCache get_ColorCache();
    [CompilerGeneratedAttribute]
public void set_ColorCache(ColorCache value);
    [CompilerGeneratedAttribute]
public int get_HuffmanMask();
    [CompilerGeneratedAttribute]
public void set_HuffmanMask(int value);
    [CompilerGeneratedAttribute]
public int get_HuffmanSubSampleBits();
    [CompilerGeneratedAttribute]
public void set_HuffmanSubSampleBits(int value);
    [CompilerGeneratedAttribute]
public int get_HuffmanXSize();
    [CompilerGeneratedAttribute]
public void set_HuffmanXSize(int value);
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_HuffmanImage();
    [CompilerGeneratedAttribute]
public void set_HuffmanImage(IMemoryOwner`1<UInt32> value);
    [CompilerGeneratedAttribute]
public int get_NumHTreeGroups();
    [CompilerGeneratedAttribute]
public void set_NumHTreeGroups(int value);
    [CompilerGeneratedAttribute]
public HTreeGroup[] get_HTreeGroups();
    [CompilerGeneratedAttribute]
public void set_HTreeGroups(HTreeGroup[] value);
    [CompilerGeneratedAttribute]
public HuffmanCode[] get_HuffmanTables();
    [CompilerGeneratedAttribute]
public void set_HuffmanTables(HuffmanCode[] value);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LMultipliers : ValueType {
    public byte GreenToRed;
    public byte GreenToBlue;
    public byte RedToBlue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LStreaks : object {
    [CompilerGeneratedAttribute]
private Int32[] <Counts>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[][] <Streaks>k__BackingField;
    public Int32[] Counts { get; }
    public Int32[][] Streaks { get; }
    [CompilerGeneratedAttribute]
public Int32[] get_Counts();
    [CompilerGeneratedAttribute]
public Int32[][] get_Streaks();
    public void Clear();
    public double FinalHuffmanCost();
    private static double InitialHuffmanCost();
}
[DebuggerDisplayAttribute("Transformtype: {TransformType}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LTransform : object {
    [CompilerGeneratedAttribute]
private Vp8LTransformType <TransformType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private int <XSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<UInt32> <Data>k__BackingField;
    public Vp8LTransformType TransformType { get; }
    public int Bits { get; public set; }
    public int XSize { get; public set; }
    public int YSize { get; }
    public IMemoryOwner`1<UInt32> Data { get; public set; }
    public Vp8LTransform(Vp8LTransformType transformType, int xSize, int ySize);
    [CompilerGeneratedAttribute]
public Vp8LTransformType get_TransformType();
    [CompilerGeneratedAttribute]
public int get_Bits();
    [CompilerGeneratedAttribute]
public void set_Bits(int value);
    [CompilerGeneratedAttribute]
public int get_XSize();
    [CompilerGeneratedAttribute]
public void set_XSize(int value);
    [CompilerGeneratedAttribute]
public int get_YSize();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<UInt32> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(IMemoryOwner`1<UInt32> value);
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossless.Vp8LTransformType : Enum {
    public UInt32 value__;
    public static Vp8LTransformType PredictorTransform;
    public static Vp8LTransformType CrossColorTransform;
    public static Vp8LTransformType SubtractGreen;
    public static Vp8LTransformType ColorIndexingTransform;
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossless.WebpLosslessDecoder : object {
    private Vp8LBitReader bitReader;
    private Configuration configuration;
    private MemoryAllocator memoryAllocator;
    private static int BitsSpecialMarker;
    private static UInt32 PackedNonLiteralCode;
    private static int CodeToPlaneCodes;
    private static int FixedTableSize;
    private static Int32[] TableSize;
    private static int NumCodeLengthCodes;
    private static ReadOnlySpan`1<byte> CodeLengthCodeOrder { get; }
    private static ReadOnlySpan`1<byte> LiteralMap { get; }
    public WebpLosslessDecoder(Vp8LBitReader bitReader, MemoryAllocator memoryAllocator, Configuration configuration);
    private static WebpLosslessDecoder();
    private static ReadOnlySpan`1<byte> get_CodeLengthCodeOrder();
    private static ReadOnlySpan`1<byte> get_LiteralMap();
    public void Decode(Buffer2D`1<TPixel> pixels, int width, int height);
    public IMemoryOwner`1<UInt32> DecodeImageStream(Vp8LDecoder decoder, int xSize, int ySize, bool isLevel0);
    private void DecodePixelValues(Vp8LDecoder decoder, Buffer2D`1<TPixel> pixels, int width, int height);
    public void DecodeImageData(Vp8LDecoder decoder, Span`1<UInt32> pixelData);
    private static void AdvanceByOne(Int32& col, Int32& row, int width, ColorCache colorCache, Int32& decodedPixels, Span`1<UInt32> pixelData, Int32& lastCached);
    private void ReadHuffmanCodes(Vp8LDecoder decoder, int xSize, int ySize, int colorCacheBits, bool allowRecursion);
    private int ReadHuffmanCode(int alphabetSize, Int32[] codeLengths, Span`1<HuffmanCode> table);
    private void ReadHuffmanCodeLengths(Span`1<HuffmanCode> table, Int32[] codeLengthCodeLengths, int numSymbols, Int32[] codeLengths);
    private void ReadTransformation(int xSize, int ySize, Vp8LDecoder decoder);
    public static void ApplyInverseTransforms(Vp8LDecoder decoder, Span`1<UInt32> pixelData, MemoryAllocator memoryAllocator);
    public void DecodeAlphaData(AlphaDecoder dec);
    private static void UpdateDecoder(Vp8LDecoder decoder, int width, int height);
    private UInt32 ReadPackedSymbols(Span`1<HTreeGroup> group, Span`1<UInt32> pixelData, int decodedPixels);
    private static void BuildPackedTable(HTreeGroup hTreeGroup);
    private UInt32 ReadSymbol(Span`1<HuffmanCode> table);
    private int GetCopyLength(int lengthSymbol);
    private int GetCopyDistance(int distanceSymbol);
    private static Span`1<HTreeGroup> GetHTreeGroupForPos(Vp8LMetadata metadata, int x, int y);
    private static UInt32 GetMetaIndex(IMemoryOwner`1<UInt32> huffmanImage, int xSize, int bits, int x, int y);
    private static int PlaneCodeToDistance(int xSize, int planeCode);
    private static void CopyBlock(Span`1<UInt32> pixelData, int decodedPixels, int dist, int length);
    private static void CopyBlock8B(Span`1<byte> data, int pos, int dist, int length);
    private static int AccumulateHCode(HuffmanCode hCode, int shift, HuffmanCode& huff);
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossy.IntraPredictionMode : Enum {
    public int value__;
    public static IntraPredictionMode DcPrediction;
    public static IntraPredictionMode TrueMotion;
    public static IntraPredictionMode VPrediction;
    public static IntraPredictionMode HPrediction;
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossy.LoopFilter : Enum {
    public int value__;
    public static LoopFilter None;
    public static LoopFilter Simple;
    public static LoopFilter Complex;
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossy.LossyUtils : object {
    public static int Vp8_Sse16x16(Span`1<byte> a, Span`1<byte> b);
    public static int Vp8_Sse16x8(Span`1<byte> a, Span`1<byte> b);
    public static int Vp8_Sse4x4(Span`1<byte> a, Span`1<byte> b);
    public static int Vp8_SseNxN(Span`1<byte> a, Span`1<byte> b, int w, int h);
    private static int Vp8_Sse16xN_Sse2(Span`1<byte> a, Span`1<byte> b, int numPairs);
    private static int Vp8_Sse16xN_Avx2(Span`1<byte> a, Span`1<byte> b, int numPairs);
    private static int Vp8_Sse16x16_Neon(Span`1<byte> a, Span`1<byte> b);
    private static int Vp8_Sse16x8_Neon(Span`1<byte> a, Span`1<byte> b);
    private static int Vp8_Sse4x4_Neon(Span`1<byte> a, Span`1<byte> b);
    private static Vector128`1<UInt32> Load4x4Neon(Span`1<byte> src);
    private static Vector128`1<UInt32> AccumulateSSE16Neon(Byte* a, Byte* b, Vector128`1<UInt32> sum);
    private static Vector128`1<int> SubtractAndAccumulate(Vector128`1<byte> a, Vector128`1<byte> b);
    private static Vector256`1<int> SubtractAndAccumulate(Vector256`1<byte> a, Vector256`1<byte> b);
    public static void Vp8Copy4X4(Span`1<byte> src, Span`1<byte> dst);
    public static void Vp8Copy16X8(Span`1<byte> src, Span`1<byte> dst);
    public static void Copy(Span`1<byte> src, Span`1<byte> dst, int w, int h);
    public static int Vp8Disto16X16(Span`1<byte> a, Span`1<byte> b, Span`1<ushort> w, Span`1<int> scratch);
    public static int Vp8Disto4X4(Span`1<byte> a, Span`1<byte> b, Span`1<ushort> w, Span`1<int> scratch);
    public static void DC16(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void TM16(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void VE16(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void HE16(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC16NoTop(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC16NoLeft(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC16NoTopLeft(Span`1<byte> dst);
    public static void DC8uv(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void TM8uv(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void VE8uv(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void HE8uv(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC8uvNoTop(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC8uvNoLeft(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void DC8uvNoTopLeft(Span`1<byte> dst);
    public static void DC4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void TM4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void VE4(Span`1<byte> dst, Span`1<byte> yuv, int offset, Span`1<byte> vals);
    public static void HE4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void RD4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void VR4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void LD4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void VL4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void HD4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void HU4(Span`1<byte> dst, Span`1<byte> yuv, int offset);
    public static void TransformWht(Span`1<short> input, Span`1<short> output, Span`1<int> scratch);
    public static int TTransform(Span`1<byte> input, Span`1<ushort> w, Span`1<int> scratch);
    public static int TTransformSse41(Span`1<byte> inputA, Span`1<byte> inputB, Span`1<ushort> w);
    public static void Vp8Transpose_2_4x4_16b(Vector128`1<short> b0, Vector128`1<short> b1, Vector128`1<short> b2, Vector128`1<short> b3, Vector128`1& output0, Vector128`1& output1, Vector128`1& output2, Vector128`1& output3);
    public static void TransformTwo(Span`1<short> src, Span`1<byte> dst, Span`1<int> scratch);
    public static void TransformOne(Span`1<short> src, Span`1<byte> dst, Span`1<int> scratch);
    public static void TransformDc(Span`1<short> src, Span`1<byte> dst);
    public static void TransformAc3(Span`1<short> src, Span`1<byte> dst);
    public static void TransformUv(Span`1<short> src, Span`1<byte> dst, Span`1<int> scratch);
    public static void TransformDcuv(Span`1<short> src, Span`1<byte> dst);
    public static void SimpleVFilter16(Span`1<byte> p, int offset, int stride, int thresh);
    public static void SimpleHFilter16(Span`1<byte> p, int offset, int stride, int thresh);
    public static void SimpleVFilter16i(Span`1<byte> p, int offset, int stride, int thresh);
    public static void SimpleHFilter16i(Span`1<byte> p, int offset, int stride, int thresh);
    public static void VFilter16(Span`1<byte> p, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void HFilter16(Span`1<byte> p, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void VFilter16i(Span`1<byte> p, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void HFilter16i(Span`1<byte> p, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void VFilter8(Span`1<byte> u, Span`1<byte> v, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void HFilter8(Span`1<byte> u, Span`1<byte> v, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void VFilter8i(Span`1<byte> u, Span`1<byte> v, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void HFilter8i(Span`1<byte> u, Span`1<byte> v, int offset, int stride, int thresh, int ithresh, int hevThresh);
    public static void Mean16x4(Span`1<byte> input, Span`1<UInt32> dc);
    public static byte Avg2(byte a, byte b);
    public static byte Avg3(byte a, byte b, byte c);
    public static void Dst(Span`1<byte> dst, int x, int y, byte v);
    public static byte Clip8B(int v);
    public static int Vp8BitCost(int bit, byte proba);
    private static void Put16(int v, Span`1<byte> dst);
    private static void TrueMotion(Span`1<byte> dst, Span`1<byte> yuv, int offset, int size);
    private static void FilterLoop24(Span`1<byte> p, int offset, int hStride, int vStride, int size, int thresh, int ithresh, int hevThresh);
    private static void FilterLoop26(Span`1<byte> p, int offset, int hStride, int vStride, int size, int thresh, int ithresh, int hevThresh);
    private static void DoFilter2(Span`1<byte> p, int offset, int step);
    private static void DoFilter2Sse2(Vector128`1& p1, Vector128`1& p0, Vector128`1& q0, Vector128`1& q1, int thresh);
    private static void DoFilter4Sse2(Vector128`1& p1, Vector128`1& p0, Vector128`1& q0, Vector128`1& q1, Vector128`1<byte> mask, int tresh);
    private static void DoFilter6Sse2(Vector128`1& p2, Vector128`1& p1, Vector128`1& p0, Vector128`1& q0, Vector128`1& q1, Vector128`1& q2, Vector128`1<byte> mask, int tresh);
    private static void DoSimpleFilterSse2(Vector128`1& p0, Vector128`1& q0, Vector128`1<byte> fl);
    private static Vector128`1<byte> GetNotHev(Vector128`1& p1, Vector128`1& p0, Vector128`1& q0, Vector128`1& q1, int hevThresh);
    private static void DoFilter4(Span`1<byte> p, int offset, int step);
    private static void DoFilter6(Span`1<byte> p, int offset, int step);
    private static bool NeedsFilter(Span`1<byte> p, int offset, int step, int t);
    private static bool NeedsFilter2(Span`1<byte> p, int offset, int step, int t, int it);
    private static Vector128`1<byte> NeedsFilter(Vector128`1<byte> p1, Vector128`1<byte> p0, Vector128`1<byte> q0, Vector128`1<byte> q1, int thresh);
    private static void Load16x4(Byte& r0, Byte& r8, int stride, Vector128`1& p1, Vector128`1& p0, Vector128`1& q0, Vector128`1& q1);
    private static void Load8x4(Byte& bRef, UIntPtr stride, Vector128`1& p, Vector128`1& q);
    private static void Store16x4(Vector128`1<byte> p1, Vector128`1<byte> p0, Vector128`1<byte> q0, Vector128`1<byte> q1, Byte& r0Ref, Byte& r8Ref, int stride);
    private static void Store4x4(Vector128`1<byte> x, Byte& dstRef, int stride);
    private static Vector128`1<sbyte> GetBaseDelta(Vector128`1<sbyte> p1, Vector128`1<sbyte> p0, Vector128`1<sbyte> q0, Vector128`1<sbyte> q1);
    private static Vector128`1<sbyte> SignedShift8b(Vector128`1<byte> x);
    private static void ComplexMask(Vector128`1<byte> p1, Vector128`1<byte> p0, Vector128`1<byte> q0, Vector128`1<byte> q1, int thresh, int ithresh, Vector128`1& mask);
    private static void Update2Pixels(Vector128`1& pi, Vector128`1& qi, Vector128`1<short> a0Low, Vector128`1<short> a0High);
    private static Vector128`1<byte> LoadUvEdge(Byte& uRef, Byte& vRef, int offset);
    private static void StoreUv(Vector128`1<byte> x, Byte& uRef, Byte& vRef, int offset);
    private static Vector128`1<byte> Abs(Vector128`1<byte> p, Vector128`1<byte> q);
    private static bool Hev(Span`1<byte> p, int offset, int step, int thresh);
    private static void Store(Span`1<byte> dst, int x, int y, int v);
    private static void Store2(Span`1<byte> dst, int y, int dc, int d, int c);
    private static int Mul1(int a);
    private static int Mul2(int a);
    private static void Put8x8uv(byte value, Span`1<byte> dst);
    private static void Memset(Span`1<byte> dst, byte value, int startIdx, int count);
    private static int Clamp255(int x);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.PassStats : object {
    [CompilerGeneratedAttribute]
private bool <IsFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Dq>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LastQ>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Qmin>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Qmax>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LastValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoSizeSearch>k__BackingField;
    public bool IsFirst { get; public set; }
    public float Dq { get; public set; }
    public float Q { get; public set; }
    public float LastQ { get; public set; }
    public float Qmin { get; }
    public float Qmax { get; }
    public double Value { get; public set; }
    public double LastValue { get; public set; }
    public double Target { get; }
    public bool DoSizeSearch { get; }
    public PassStats(long targetSize, float targetPsnr, int qMin, int qMax, UInt32 quality);
    [CompilerGeneratedAttribute]
public bool get_IsFirst();
    [CompilerGeneratedAttribute]
public void set_IsFirst(bool value);
    [CompilerGeneratedAttribute]
public float get_Dq();
    [CompilerGeneratedAttribute]
public void set_Dq(float value);
    [CompilerGeneratedAttribute]
public float get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(float value);
    [CompilerGeneratedAttribute]
public float get_LastQ();
    [CompilerGeneratedAttribute]
public void set_LastQ(float value);
    [CompilerGeneratedAttribute]
public float get_Qmin();
    [CompilerGeneratedAttribute]
public float get_Qmax();
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    [CompilerGeneratedAttribute]
public double get_LastValue();
    [CompilerGeneratedAttribute]
public void set_LastValue(double value);
    [CompilerGeneratedAttribute]
public double get_Target();
    [CompilerGeneratedAttribute]
public bool get_DoSizeSearch();
    public float ComputeNextQ();
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossy.QuantEnc : object {
    [NullableAttribute("1")]
private static UInt16[] WeightY;
    private static int MaxLevel;
    private static int C1;
    private static int C2;
    private static int DSHIFT;
    private static int DSCALE;
    private static ReadOnlySpan`1<byte> Zigzag { get; }
    private static QuantEnc();
    private static ReadOnlySpan`1<byte> get_Zigzag();
    [NullableContextAttribute("1")]
public static void PickBestIntra16(Vp8EncIterator it, Vp8ModeScore& rd, Vp8SegmentInfo[] segmentInfos, Vp8EncProba proba);
    [NullableContextAttribute("1")]
public static bool PickBestIntra4(Vp8EncIterator it, Vp8ModeScore& rd, Vp8SegmentInfo[] segmentInfos, Vp8EncProba proba, int maxI4HeaderBits);
    [NullableContextAttribute("1")]
public static void PickBestUv(Vp8EncIterator it, Vp8ModeScore& rd, Vp8SegmentInfo[] segmentInfos, Vp8EncProba proba);
    [NullableContextAttribute("1")]
public static int ReconstructIntra16(Vp8EncIterator it, Vp8SegmentInfo dqm, Vp8ModeScore rd, Span`1<byte> yuvOut, int mode);
    public static int ReconstructIntra4(Vp8EncIterator it, Vp8SegmentInfo dqm, Span`1<short> levels, Span`1<byte> src, Span`1<byte> yuvOut, int mode);
    [NullableContextAttribute("1")]
public static int ReconstructUv(Vp8EncIterator it, Vp8SegmentInfo dqm, Vp8ModeScore rd, Span`1<byte> yuvOut, int mode);
    [NullableContextAttribute("1")]
public static void RefineUsingDistortion(Vp8EncIterator it, Vp8SegmentInfo[] segmentInfos, Vp8ModeScore rd, bool tryBothModes, bool refineUvMode, int mbHeaderLimit);
    public static int Quantize2Blocks(Span`1<short> input, Span`1<short> output, Vp8Matrix& mtx);
    public static int QuantizeBlock(Span`1<short> input, Span`1<short> output, Vp8Matrix& mtx);
    public static int QuantizeSingle(Span`1<short> v, Vp8Matrix& mtx);
    [NullableContextAttribute("1")]
public static void CorrectDcValues(Vp8EncIterator it, Vp8Matrix& mtx, Span`1<short> tmp, Vp8ModeScore rd);
    private static bool IsFlatSource16(Span`1<byte> src);
    private static bool IsFlat(Span`1<short> levels, int numBlocks, int thresh);
    private static int Mult8B(int a, int b);
    private static int QuantDiv(UInt32 n, UInt32 iQ, UInt32 b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8BandProbas : object {
    [CompilerGeneratedAttribute]
private Vp8ProbaArray[] <Probabilities>k__BackingField;
    public Vp8ProbaArray[] Probabilities { get; }
    [CompilerGeneratedAttribute]
public Vp8ProbaArray[] get_Probabilities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8CostArray : object {
    [CompilerGeneratedAttribute]
private UInt16[] <Costs>k__BackingField;
    public UInt16[] Costs { get; }
    [CompilerGeneratedAttribute]
public UInt16[] get_Costs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Costs : object {
    [CompilerGeneratedAttribute]
private Vp8CostArray[] <Costs>k__BackingField;
    public Vp8CostArray[] Costs { get; }
    [CompilerGeneratedAttribute]
public Vp8CostArray[] get_Costs();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Decoder : object {
    private Vp8MacroBlock leftMacroBlock;
    [CompilerGeneratedAttribute]
private Vp8FrameHeader <FrameHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8PictureHeader <PictureHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8FilterHeader <FilterHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8SegmentHeader <SegmentHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumPartsMinusOne>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BitReader[] <Vp8BitReaders>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8QuantMatrix[] <DeQuantMatrices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSkipProbability>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <SkipProbability>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Proba <Probabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IntraT>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IntraL>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TopLeftMbX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TopLeftMbY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomRightMbX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BottomRightMbY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbY>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8MacroBlockData[] <MacroBlockData>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8MacroBlock[] <MacroBlockInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LoopFilter <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8FilterInfo[0...,0...] <FilterStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <YuvBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8TopSamples[] <YuvTopSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <CacheY>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <CacheU>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <CacheV>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheYOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheUvOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheYStride>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CacheUvStride>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <TmpYBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <TmpUBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <TmpVBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Pixels>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8FilterInfo[] <FilterInfo>k__BackingField;
    public Vp8FrameHeader FrameHeader { get; }
    public Vp8PictureHeader PictureHeader { get; }
    public Vp8FilterHeader FilterHeader { get; }
    public Vp8SegmentHeader SegmentHeader { get; }
    public int NumPartsMinusOne { get; public set; }
    public Vp8BitReader[] Vp8BitReaders { get; }
    public Vp8QuantMatrix[] DeQuantMatrices { get; }
    public bool UseSkipProbability { get; public set; }
    public byte SkipProbability { get; public set; }
    public Vp8Proba Probabilities { get; public set; }
    public Byte[] IntraT { get; public set; }
    public Byte[] IntraL { get; }
    public int MbWidth { get; }
    public int MbHeight { get; }
    public int TopLeftMbX { get; public set; }
    public int TopLeftMbY { get; public set; }
    public int BottomRightMbX { get; public set; }
    public int BottomRightMbY { get; public set; }
    public int MbX { get; public set; }
    public int MbY { get; public set; }
    public Vp8MacroBlockData[] MacroBlockData { get; }
    public Vp8MacroBlock[] MacroBlockInfo { get; }
    public LoopFilter Filter { get; public set; }
    public Vp8FilterInfo[0...,0...] FilterStrength { get; }
    public IMemoryOwner`1<byte> YuvBuffer { get; }
    public Vp8TopSamples[] YuvTopSamples { get; }
    public IMemoryOwner`1<byte> CacheY { get; }
    public IMemoryOwner`1<byte> CacheU { get; }
    public IMemoryOwner`1<byte> CacheV { get; }
    public int CacheYOffset { get; public set; }
    public int CacheUvOffset { get; public set; }
    public int CacheYStride { get; }
    public int CacheUvStride { get; }
    public IMemoryOwner`1<byte> TmpYBuffer { get; }
    public IMemoryOwner`1<byte> TmpUBuffer { get; }
    public IMemoryOwner`1<byte> TmpVBuffer { get; }
    public IMemoryOwner`1<byte> Pixels { get; }
    public Vp8FilterInfo[] FilterInfo { get; public set; }
    public Vp8MacroBlock CurrentMacroBlock { get; }
    public Vp8MacroBlock LeftMacroBlock { get; }
    public Vp8MacroBlockData CurrentBlockData { get; }
    public Vp8Decoder(Vp8FrameHeader frameHeader, Vp8PictureHeader pictureHeader, Vp8SegmentHeader segmentHeader, Vp8Proba probabilities, MemoryAllocator memoryAllocator);
    [CompilerGeneratedAttribute]
public Vp8FrameHeader get_FrameHeader();
    [CompilerGeneratedAttribute]
public Vp8PictureHeader get_PictureHeader();
    [CompilerGeneratedAttribute]
public Vp8FilterHeader get_FilterHeader();
    [CompilerGeneratedAttribute]
public Vp8SegmentHeader get_SegmentHeader();
    [CompilerGeneratedAttribute]
public int get_NumPartsMinusOne();
    [CompilerGeneratedAttribute]
public void set_NumPartsMinusOne(int value);
    [CompilerGeneratedAttribute]
public Vp8BitReader[] get_Vp8BitReaders();
    [CompilerGeneratedAttribute]
public Vp8QuantMatrix[] get_DeQuantMatrices();
    [CompilerGeneratedAttribute]
public bool get_UseSkipProbability();
    [CompilerGeneratedAttribute]
public void set_UseSkipProbability(bool value);
    [CompilerGeneratedAttribute]
public byte get_SkipProbability();
    [CompilerGeneratedAttribute]
public void set_SkipProbability(byte value);
    [CompilerGeneratedAttribute]
public Vp8Proba get_Probabilities();
    [CompilerGeneratedAttribute]
public void set_Probabilities(Vp8Proba value);
    [CompilerGeneratedAttribute]
public Byte[] get_IntraT();
    [CompilerGeneratedAttribute]
public void set_IntraT(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_IntraL();
    [CompilerGeneratedAttribute]
public int get_MbWidth();
    [CompilerGeneratedAttribute]
public int get_MbHeight();
    [CompilerGeneratedAttribute]
public int get_TopLeftMbX();
    [CompilerGeneratedAttribute]
public void set_TopLeftMbX(int value);
    [CompilerGeneratedAttribute]
public int get_TopLeftMbY();
    [CompilerGeneratedAttribute]
public void set_TopLeftMbY(int value);
    [CompilerGeneratedAttribute]
public int get_BottomRightMbX();
    [CompilerGeneratedAttribute]
public void set_BottomRightMbX(int value);
    [CompilerGeneratedAttribute]
public int get_BottomRightMbY();
    [CompilerGeneratedAttribute]
public void set_BottomRightMbY(int value);
    [CompilerGeneratedAttribute]
public int get_MbX();
    [CompilerGeneratedAttribute]
public void set_MbX(int value);
    [CompilerGeneratedAttribute]
public int get_MbY();
    [CompilerGeneratedAttribute]
public void set_MbY(int value);
    [CompilerGeneratedAttribute]
public Vp8MacroBlockData[] get_MacroBlockData();
    [CompilerGeneratedAttribute]
public Vp8MacroBlock[] get_MacroBlockInfo();
    [CompilerGeneratedAttribute]
public LoopFilter get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(LoopFilter value);
    [CompilerGeneratedAttribute]
public Vp8FilterInfo[0...,0...] get_FilterStrength();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_YuvBuffer();
    [CompilerGeneratedAttribute]
public Vp8TopSamples[] get_YuvTopSamples();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_CacheY();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_CacheU();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_CacheV();
    [CompilerGeneratedAttribute]
public int get_CacheYOffset();
    [CompilerGeneratedAttribute]
public void set_CacheYOffset(int value);
    [CompilerGeneratedAttribute]
public int get_CacheUvOffset();
    [CompilerGeneratedAttribute]
public void set_CacheUvOffset(int value);
    [CompilerGeneratedAttribute]
public int get_CacheYStride();
    [CompilerGeneratedAttribute]
public int get_CacheUvStride();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_TmpYBuffer();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_TmpUBuffer();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_TmpVBuffer();
    [CompilerGeneratedAttribute]
public IMemoryOwner`1<byte> get_Pixels();
    [CompilerGeneratedAttribute]
public Vp8FilterInfo[] get_FilterInfo();
    [CompilerGeneratedAttribute]
public void set_FilterInfo(Vp8FilterInfo[] value);
    public Vp8MacroBlock get_CurrentMacroBlock();
    public Vp8MacroBlock get_LeftMacroBlock();
    public Vp8MacroBlockData get_CurrentBlockData();
    public void PrecomputeFilterStrengths();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8EncIterator : object {
    public static int YOffEnc;
    public static int UOffEnc;
    public static int VOffEnc;
    private static int MaxIntra16Mode;
    private static int MaxIntra4Mode;
    private static int MaxUvMode;
    private static int DefaultAlpha;
    private int mbw;
    private int mbh;
    private int predsWidth;
    private Byte[] vp8TopLeftI4;
    private int currentMbIdx;
    private int nzIdx;
    private int yTopIdx;
    private int uvTopIdx;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YuvIn>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YuvOut>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YuvOut2>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YuvP>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <UvLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private SByte[] <LeftDerr>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YTop>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <UvTop>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Preds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PredIdx>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <Nz>k__BackingField;
    [CompilerGeneratedAttribute]
private SByte[] <TopDerr>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <I4Boundary>k__BackingField;
    [CompilerGeneratedAttribute]
private int <I4BoundaryIdx>k__BackingField;
    [CompilerGeneratedAttribute]
private int <I4>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <TopNz>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <LeftNz>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LumaBits>k__BackingField;
    [CompilerGeneratedAttribute]
private Int64[0...,0...] <BitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UvBits>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountDown>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Scratch>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <Scratch2>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Scratch3>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8MacroBlockInfo[] <Mb>k__BackingField;
    public int X { get; public set; }
    public int Y { get; public set; }
    public Byte[] YuvIn { get; }
    public Byte[] YuvOut { get; public set; }
    public Byte[] YuvOut2 { get; public set; }
    public Byte[] YuvP { get; }
    public Byte[] YLeft { get; }
    public Byte[] UvLeft { get; }
    public SByte[] LeftDerr { get; }
    public Byte[] YTop { get; }
    public Byte[] UvTop { get; }
    public Byte[] Preds { get; }
    public int PredIdx { get; private set; }
    public UInt32[] Nz { get; }
    public SByte[] TopDerr { get; }
    public Byte[] I4Boundary { get; }
    public int I4BoundaryIdx { get; public set; }
    public int I4 { get; public set; }
    public Int32[] TopNz { get; }
    public Int32[] LeftNz { get; }
    public long LumaBits { get; public set; }
    public Int64[0...,0...] BitCount { get; }
    public long UvBits { get; public set; }
    public int CountDown { get; public set; }
    public Byte[] Scratch { get; }
    public Int16[] Scratch2 { get; }
    public Int32[] Scratch3 { get; }
    public Vp8MacroBlockInfo CurrentMacroBlockInfo { get; }
    private Vp8MacroBlockInfo[] Mb { get; }
    public Vp8EncIterator(Vp8Encoder enc);
    public Vp8EncIterator(Byte[] yTop, Byte[] uvTop, UInt32[] nz, Vp8MacroBlockInfo[] mb, Byte[] preds, SByte[] topDerr, int mbw, int mbh);
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_YuvIn();
    [CompilerGeneratedAttribute]
public Byte[] get_YuvOut();
    [CompilerGeneratedAttribute]
public void set_YuvOut(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_YuvOut2();
    [CompilerGeneratedAttribute]
public void set_YuvOut2(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_YuvP();
    [CompilerGeneratedAttribute]
public Byte[] get_YLeft();
    [CompilerGeneratedAttribute]
public Byte[] get_UvLeft();
    [CompilerGeneratedAttribute]
public SByte[] get_LeftDerr();
    [CompilerGeneratedAttribute]
public Byte[] get_YTop();
    [CompilerGeneratedAttribute]
public Byte[] get_UvTop();
    [CompilerGeneratedAttribute]
public Byte[] get_Preds();
    [CompilerGeneratedAttribute]
public int get_PredIdx();
    [CompilerGeneratedAttribute]
private void set_PredIdx(int value);
    [CompilerGeneratedAttribute]
public UInt32[] get_Nz();
    [CompilerGeneratedAttribute]
public SByte[] get_TopDerr();
    [CompilerGeneratedAttribute]
public Byte[] get_I4Boundary();
    [CompilerGeneratedAttribute]
public int get_I4BoundaryIdx();
    [CompilerGeneratedAttribute]
public void set_I4BoundaryIdx(int value);
    [CompilerGeneratedAttribute]
public int get_I4();
    [CompilerGeneratedAttribute]
public void set_I4(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_TopNz();
    [CompilerGeneratedAttribute]
public Int32[] get_LeftNz();
    [CompilerGeneratedAttribute]
public long get_LumaBits();
    [CompilerGeneratedAttribute]
public void set_LumaBits(long value);
    [CompilerGeneratedAttribute]
public Int64[0...,0...] get_BitCount();
    [CompilerGeneratedAttribute]
public long get_UvBits();
    [CompilerGeneratedAttribute]
public void set_UvBits(long value);
    [CompilerGeneratedAttribute]
public int get_CountDown();
    [CompilerGeneratedAttribute]
public void set_CountDown(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Scratch();
    [CompilerGeneratedAttribute]
public Int16[] get_Scratch2();
    [CompilerGeneratedAttribute]
public Int32[] get_Scratch3();
    public Vp8MacroBlockInfo get_CurrentMacroBlockInfo();
    [CompilerGeneratedAttribute]
private Vp8MacroBlockInfo[] get_Mb();
    public void Init();
    public static void InitFilter();
    public void StartI4();
    [NullableContextAttribute("0")]
public void Import(Span`1<byte> y, Span`1<byte> u, Span`1<byte> v, int yStride, int uvStride, int width, int height, bool importBoundarySamples);
    public int FastMbAnalyze(UInt32 quality);
    public int MbAnalyzeBestIntra16Mode();
    public int MbAnalyzeBestIntra4Mode(int bestAlpha);
    public int MbAnalyzeBestUvMode();
    public void SetIntra16Mode(int mode);
    [NullableContextAttribute("0")]
public void SetIntra4Mode(ReadOnlySpan`1<byte> modes);
    public int GetCostLuma16(Vp8ModeScore rd, Vp8EncProba proba, Vp8Residual res);
    public Int16[] GetCostModeI4(Byte[] modes);
    public int GetCostLuma4(Span`1<short> levels, Vp8EncProba proba, Vp8Residual res);
    public int GetCostUv(Vp8ModeScore rd, Vp8EncProba proba, Vp8Residual res);
    public void SetIntraUvMode(int mode);
    public void SetSkip(bool skip);
    public void SetSegment(int segment);
    public void StoreDiffusionErrors(Vp8ModeScore rd);
    public bool IsDone();
    public bool Next();
    public void SaveBoundary();
    [NullableContextAttribute("0")]
public bool RotateI4(Span`1<byte> yuvOut);
    public void ResetAfterSkip();
    public void MakeLuma16Preds();
    public void MakeChroma8Preds();
    public void MakeIntra4Preds();
    public void SwapOut();
    public void NzToBytes();
    public void BytesToNz();
    [NullableContextAttribute("0")]
private static void ImportBlock(Span`1<byte> src, int srcStride, Span`1<byte> dst, int w, int h, int size);
    [NullableContextAttribute("0")]
private static void ImportLine(Span`1<byte> src, int srcStride, Span`1<byte> dst, int len, int totalLen);
    private void Reset();
    private void SetRow(int y);
    private void InitLeft();
    private void InitTop();
    private static int Bit(UInt32 nz, int n);
    private void SetCountDown(int countDown);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Encoder : object {
    private MemoryAllocator memoryAllocator;
    private Configuration configuration;
    private UInt32 quality;
    private WebpEncodingMethod method;
    private int entropyPasses;
    private int filterStrength;
    private int spatialNoiseShaping;
    private Vp8BitWriter bitWriter;
    private bool skipMetadata;
    private Vp8RdLevel rdOptLevel;
    private int maxI4HeaderBits;
    private int alpha;
    private int uvAlpha;
    private bool alphaCompression;
    private static int NumMbSegments;
    private static int MaxItersKMeans;
    private static float DqLimit;
    private static ulong Partition0SizeLimit;
    private static long HeaderSizeEstimate;
    private static int QMin;
    private static int QMax;
    [CompilerGeneratedAttribute]
private int <BaseQuant>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8EncProba <Proba>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8EncSegmentHeader <SegmentHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8SegmentInfo[] <SegmentInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8MacroBlockInfo[] <MbInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8FilterHeader <FilterHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PredsWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Mbw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Mbh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DqY1Dc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DqY2Ac>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DqY2Dc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DqUvAc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DqUvDc>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <U>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> <V>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <YTop>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <UvTop>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <Nz>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Preds>k__BackingField;
    [CompilerGeneratedAttribute]
private SByte[] <TopDerr>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbHeaderLimit>k__BackingField;
    private static ReadOnlySpan`1<byte> AverageBytesPerMb { get; }
    public int BaseQuant { get; public set; }
    public Vp8EncProba Proba { get; }
    public Vp8EncSegmentHeader SegmentHeader { get; private set; }
    public Vp8SegmentInfo[] SegmentInfos { get; }
    public Vp8MacroBlockInfo[] MbInfo { get; }
    public Vp8FilterHeader FilterHeader { get; }
    public int Alpha { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public int PredsWidth { get; }
    public int Mbw { get; }
    public int Mbh { get; }
    public int DqY1Dc { get; private set; }
    public int DqY2Ac { get; private set; }
    public int DqY2Dc { get; private set; }
    public int DqUvAc { get; private set; }
    public int DqUvDc { get; private set; }
    private IMemoryOwner`1<byte> Y { get; }
    private IMemoryOwner`1<byte> U { get; }
    private IMemoryOwner`1<byte> V { get; }
    public Byte[] YTop { get; }
    public Byte[] UvTop { get; }
    public UInt32[] Nz { get; }
    public Byte[] Preds { get; }
    public SByte[] TopDerr { get; }
    private int MbHeaderLimit { get; }
    public Vp8Encoder(MemoryAllocator memoryAllocator, Configuration configuration, int width, int height, UInt32 quality, bool skipMetadata, WebpEncodingMethod method, int entropyPasses, int filterStrength, int spatialNoiseShaping, bool alphaCompression);
    private static ReadOnlySpan`1<byte> get_AverageBytesPerMb();
    [CompilerGeneratedAttribute]
public int get_BaseQuant();
    [CompilerGeneratedAttribute]
public void set_BaseQuant(int value);
    [CompilerGeneratedAttribute]
public Vp8EncProba get_Proba();
    [CompilerGeneratedAttribute]
public Vp8EncSegmentHeader get_SegmentHeader();
    [CompilerGeneratedAttribute]
private void set_SegmentHeader(Vp8EncSegmentHeader value);
    [CompilerGeneratedAttribute]
public Vp8SegmentInfo[] get_SegmentInfos();
    [CompilerGeneratedAttribute]
public Vp8MacroBlockInfo[] get_MbInfo();
    [CompilerGeneratedAttribute]
public Vp8FilterHeader get_FilterHeader();
    [CompilerGeneratedAttribute]
public int get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(int value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public int get_PredsWidth();
    [CompilerGeneratedAttribute]
public int get_Mbw();
    [CompilerGeneratedAttribute]
public int get_Mbh();
    [CompilerGeneratedAttribute]
public int get_DqY1Dc();
    [CompilerGeneratedAttribute]
private void set_DqY1Dc(int value);
    [CompilerGeneratedAttribute]
public int get_DqY2Ac();
    [CompilerGeneratedAttribute]
private void set_DqY2Ac(int value);
    [CompilerGeneratedAttribute]
public int get_DqY2Dc();
    [CompilerGeneratedAttribute]
private void set_DqY2Dc(int value);
    [CompilerGeneratedAttribute]
public int get_DqUvAc();
    [CompilerGeneratedAttribute]
private void set_DqUvAc(int value);
    [CompilerGeneratedAttribute]
public int get_DqUvDc();
    [CompilerGeneratedAttribute]
private void set_DqUvDc(int value);
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> get_Y();
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> get_U();
    [CompilerGeneratedAttribute]
private IMemoryOwner`1<byte> get_V();
    [CompilerGeneratedAttribute]
public Byte[] get_YTop();
    [CompilerGeneratedAttribute]
public Byte[] get_UvTop();
    [CompilerGeneratedAttribute]
public UInt32[] get_Nz();
    [CompilerGeneratedAttribute]
public Byte[] get_Preds();
    [CompilerGeneratedAttribute]
public SByte[] get_TopDerr();
    [CompilerGeneratedAttribute]
private int get_MbHeaderLimit();
    public WebpVp8X EncodeHeader(Image`1<TPixel> image, Stream stream, bool hasAlpha, bool hasAnimation);
    public void EncodeFooter(Image`1<TPixel> image, WebpVp8X& vp8x, bool hasAlpha, Stream stream, long initialPosition);
    public bool EncodeAnimation(ImageFrame`1<TPixel> frame, Stream stream, Rectangle bounds, WebpFrameMetadata frameMetadata);
    public void EncodeStatic(Stream stream, Image`1<TPixel> image);
    private bool Encode(Stream stream, ImageFrame`1<TPixel> frame, Rectangle bounds, WebpFrameMetadata frameMetadata, bool hasAnimation, Image`1<TPixel> image);
    public sealed virtual void Dispose();
    private void StatLoop(int width, int height, int yStride, int uvStride);
    private long OneStatPass(int width, int height, int yStride, int uvStride, Vp8RdLevel rdOpt, int nbMbs, PassStats stats);
    private void SetLoopParams(float q);
    private void AdjustFilterStrength();
    private void ResetBoundaryPredictions();
    private void AssignSegments(ReadOnlySpan`1<int> alphas);
    private void SetSegmentAlphas(ReadOnlySpan`1<int> centers, int mid);
    private void SetSegmentParams(float quality);
    private void SetupFilterStrength();
    private void SetSegmentProbas();
    private void ResetSegments();
    private void ResetStats();
    private void SetupMatrices(Vp8SegmentInfo[] dqm);
    private int MacroBlockAnalysis(int width, int height, Vp8EncIterator it, Span`1<byte> y, Span`1<byte> u, Span`1<byte> v, int yStride, int uvStride, Span`1<int> alphas, Int32& uvAlpha);
    private int MbAnalyze(Vp8EncIterator it, Span`1<int> alphas, Int32& bestUvAlpha);
    private bool Decimate(Vp8EncIterator it, Vp8ModeScore& rd, Vp8RdLevel rdOpt);
    private void CodeResiduals(Vp8EncIterator it, Vp8ModeScore rd, Vp8Residual residual);
    private void RecordResiduals(Vp8EncIterator it, Vp8ModeScore rd);
    private static int FinalAlphaValue(int alpha);
    private static double QualityToCompression(double c);
    private static int FilterStrengthFromDelta(int sharpness, int delta);
    private static double GetPsnr(long mse, long size);
    private static int GetProba(int a, int b);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Encoding : object {
    private static int KC1;
    private static int KC2;
    [NullableAttribute("1")]
private static Byte[] Clip1;
    private static int I16DC16;
    private static int I16TM16;
    private static int I16VE16;
    private static int I16HE16;
    private static int C8DC8;
    private static int C8TM8;
    private static int C8VE8;
    private static int C8HE8;
    [NullableAttribute("1")]
public static Int32[] Vp8I16ModeOffsets;
    [NullableAttribute("1")]
public static Int32[] Vp8UvModeOffsets;
    private static int I4DC4;
    private static int I4TM4;
    private static int I4VE4;
    private static int I4HE4;
    private static int I4RD4;
    private static int I4VR4;
    private static int I4LD4;
    private static int I4VL4;
    private static int I4HD4;
    private static int I4HU4;
    [NullableAttribute("1")]
public static Int32[] Vp8I4ModeOffsets;
    private static Vp8Encoding();
    [NullableContextAttribute("1")]
private static Byte[] GetClip1();
    public static void ITransformTwo(Span`1<byte> reference, Span`1<short> input, Span`1<byte> dst, Span`1<int> scratch);
    public static void ITransformOne(Span`1<byte> reference, Span`1<short> input, Span`1<byte> dst, Span`1<int> scratch);
    private static void InverseTransformVerticalPass(Vector128`1<long> in0, Vector128`1<long> in2, Vector128`1<long> in1, Vector128`1<long> in3, Vector128`1& tmp0, Vector128`1& tmp1, Vector128`1& tmp2, Vector128`1& tmp3);
    private static void InverseTransformHorizontalPass(Vector128`1<long> t0, Vector128`1<long> t2, Vector128`1<long> t1, Vector128`1<long> t3, Vector128`1& shifted0, Vector128`1& shifted1, Vector128`1& shifted2, Vector128`1& shifted3);
    public static void FTransform2(Span`1<byte> src, Span`1<byte> reference, Span`1<short> output, Span`1<short> output2, Span`1<int> scratch);
    public static void FTransform(Span`1<byte> src, Span`1<byte> reference, Span`1<short> output, Span`1<int> scratch);
    public static void FTransformPass1SSE2(Vector128`1<short> row01, Vector128`1<short> row23, Vector128`1& out01, Vector128`1& out32);
    public static void FTransformPass2SSE2(Vector128`1<int> v01, Vector128`1<int> v32, Span`1<short> output);
    public static void FTransformWht(Span`1<short> input, Span`1<short> output, Span`1<int> scratch);
    public static void EncPredLuma16(Span`1<byte> dst, Span`1<byte> left, Span`1<byte> top);
    public static void EncPredChroma8(Span`1<byte> dst, Span`1<byte> left, Span`1<byte> top);
    public static void EncPredLuma4(Span`1<byte> dst, Span`1<byte> top, int topOffset, Span`1<byte> vals);
    private static void VerticalPred(Span`1<byte> dst, Span`1<byte> top, int size);
    public static void HorizontalPred(Span`1<byte> dst, Span`1<byte> left, int size);
    public static void TrueMotion(Span`1<byte> dst, Span`1<byte> left, Span`1<byte> top, int size);
    private static void DcMode(Span`1<byte> dst, Span`1<byte> left, Span`1<byte> top, int size, int round, int shift);
    private static void Dc4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Tm4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Ve4(Span`1<byte> dst, Span`1<byte> top, int topOffset, Span`1<byte> vals);
    private static void He4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Rd4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Vr4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Ld4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Vl4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Hd4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Hu4(Span`1<byte> dst, Span`1<byte> top, int topOffset);
    private static void Fill(Span`1<byte> dst, int value, int size);
    private static byte Clip8b(int v);
    private static void Store(Span`1<byte> dst, Span`1<byte> reference, int x, int y, int v);
    private static int Mul(int a, int b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8EncProba : object {
    private static int MaxVariableLevel;
    private static int SkipProbaThreshold;
    [CompilerGeneratedAttribute]
private Byte[] <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <SkipProba>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSkipProba>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BandProbas[][] <Coeffs>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Stats[][] <Stats>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Costs[][] <LevelCost>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Costs[][] <RemappedCosts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NbSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Dirty>k__BackingField;
    public Byte[] Segments { get; }
    public byte SkipProba { get; public set; }
    public bool UseSkipProba { get; public set; }
    public Vp8BandProbas[][] Coeffs { get; }
    public Vp8Stats[][] Stats { get; }
    public Vp8Costs[][] LevelCost { get; }
    public Vp8Costs[][] RemappedCosts { get; }
    public int NbSkip { get; public set; }
    public bool Dirty { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Segments();
    [CompilerGeneratedAttribute]
public byte get_SkipProba();
    [CompilerGeneratedAttribute]
public void set_SkipProba(byte value);
    [CompilerGeneratedAttribute]
public bool get_UseSkipProba();
    [CompilerGeneratedAttribute]
public void set_UseSkipProba(bool value);
    [CompilerGeneratedAttribute]
public Vp8BandProbas[][] get_Coeffs();
    [CompilerGeneratedAttribute]
public Vp8Stats[][] get_Stats();
    [CompilerGeneratedAttribute]
public Vp8Costs[][] get_LevelCost();
    [CompilerGeneratedAttribute]
public Vp8Costs[][] get_RemappedCosts();
    [CompilerGeneratedAttribute]
public int get_NbSkip();
    [CompilerGeneratedAttribute]
public void set_NbSkip(int value);
    [CompilerGeneratedAttribute]
public bool get_Dirty();
    [CompilerGeneratedAttribute]
public void set_Dirty(bool value);
    public void CalculateLevelCosts();
    public int FinalizeTokenProbas();
    public int FinalizeSkipProba(int mbw, int mbh);
    public void ResetTokenStats();
    private static int CalcSkipProba(long nb, long total);
    [NullableContextAttribute("0")]
private static int VariableLevelCost(int level, Span`1<byte> probas);
    private static int CalcTokenProba(int nb, int total);
    private static int BranchCost(int nb, int total, int proba);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8EncSegmentHeader : object {
    [CompilerGeneratedAttribute]
private int <NumSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateMap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public int NumSegments { get; }
    public bool UpdateMap { get; public set; }
    public int Size { get; public set; }
    public Vp8EncSegmentHeader(int numSegments);
    [CompilerGeneratedAttribute]
public int get_NumSegments();
    [CompilerGeneratedAttribute]
public bool get_UpdateMap();
    [CompilerGeneratedAttribute]
public void set_UpdateMap(bool value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8FilterHeader : object {
    private static int NumRefLfDeltas;
    private static int NumModeLfDeltas;
    private int filterLevel;
    private int sharpness;
    [CompilerGeneratedAttribute]
private LoopFilter <LoopFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Simple>k__BackingField;
    [CompilerGeneratedAttribute]
private int <I4x4LfDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLfDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <RefLfDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <ModeLfDelta>k__BackingField;
    public LoopFilter LoopFilter { get; public set; }
    public int FilterLevel { get; public set; }
    public int Sharpness { get; public set; }
    public bool Simple { get; public set; }
    public int I4x4LfDelta { get; public set; }
    public bool UseLfDelta { get; public set; }
    public Int32[] RefLfDelta { get; }
    public Int32[] ModeLfDelta { get; }
    [CompilerGeneratedAttribute]
public LoopFilter get_LoopFilter();
    [CompilerGeneratedAttribute]
public void set_LoopFilter(LoopFilter value);
    public int get_FilterLevel();
    public void set_FilterLevel(int value);
    public int get_Sharpness();
    public void set_Sharpness(int value);
    [CompilerGeneratedAttribute]
public bool get_Simple();
    [CompilerGeneratedAttribute]
public void set_Simple(bool value);
    [CompilerGeneratedAttribute]
public int get_I4x4LfDelta();
    [CompilerGeneratedAttribute]
public void set_I4x4LfDelta(int value);
    [CompilerGeneratedAttribute]
public bool get_UseLfDelta();
    [CompilerGeneratedAttribute]
public void set_UseLfDelta(bool value);
    [CompilerGeneratedAttribute]
public Int32[] get_RefLfDelta();
    [CompilerGeneratedAttribute]
public Int32[] get_ModeLfDelta();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8FilterInfo : object {
    private byte limit;
    private byte innerLevel;
    private byte highEdgeVarianceThreshold;
    [CompilerGeneratedAttribute]
private bool <UseInnerFiltering>k__BackingField;
    public byte Limit { get; public set; }
    public byte InnerLevel { get; public set; }
    public bool UseInnerFiltering { get; public set; }
    public byte HighEdgeVarianceThreshold { get; public set; }
    [NullableContextAttribute("1")]
public Vp8FilterInfo(Vp8FilterInfo other);
    public byte get_Limit();
    public void set_Limit(byte value);
    public byte get_InnerLevel();
    public void set_InnerLevel(byte value);
    [CompilerGeneratedAttribute]
public bool get_UseInnerFiltering();
    [CompilerGeneratedAttribute]
public void set_UseInnerFiltering(bool value);
    public byte get_HighEdgeVarianceThreshold();
    public void set_HighEdgeVarianceThreshold(byte value);
    [NullableContextAttribute("1")]
public sealed virtual IDeepCloneable DeepClone();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8FrameHeader : object {
    [CompilerGeneratedAttribute]
private bool <KeyFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PartitionLength>k__BackingField;
    public bool KeyFrame { get; public set; }
    public sbyte Profile { get; public set; }
    public UInt32 PartitionLength { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_KeyFrame();
    [CompilerGeneratedAttribute]
public void set_KeyFrame(bool value);
    [CompilerGeneratedAttribute]
public sbyte get_Profile();
    [CompilerGeneratedAttribute]
public void set_Profile(sbyte value);
    [CompilerGeneratedAttribute]
public UInt32 get_PartitionLength();
    [CompilerGeneratedAttribute]
public void set_PartitionLength(UInt32 value);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Histogram : object {
    private static int MaxCoeffThresh;
    private int maxValue;
    private int lastNonZero;
    public int GetAlpha();
    public void CollectHistogram(Span`1<byte> reference, Span`1<byte> pred, int startBlock, int endBlock);
    [NullableContextAttribute("1")]
public void Merge(Vp8Histogram other);
    private void SetHistogramData(ReadOnlySpan`1<int> distribution);
    private static int ClipMax(int v, int max);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Io : ValueType {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbW>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MbH>k__BackingField;
    [CompilerGeneratedAttribute]
private Span`1<byte> <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private Span`1<byte> <U>k__BackingField;
    [CompilerGeneratedAttribute]
private Span`1<byte> <V>k__BackingField;
    [CompilerGeneratedAttribute]
private int <YStride>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UvStride>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseScaling>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScaledWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScaledHeight>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public int MbY { get; public set; }
    public int MbW { get; public set; }
    public int MbH { get; public set; }
    public Span`1<byte> Y { get; public set; }
    public Span`1<byte> U { get; public set; }
    public Span`1<byte> V { get; public set; }
    public int YStride { get; public set; }
    public int UvStride { get; public set; }
    public bool UseScaling { get; public set; }
    public int ScaledWidth { get; public set; }
    public int ScaledHeight { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MbY();
    [CompilerGeneratedAttribute]
public void set_MbY(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MbW();
    [CompilerGeneratedAttribute]
public void set_MbW(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MbH();
    [CompilerGeneratedAttribute]
public void set_MbH(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Span`1<byte> get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(Span`1<byte> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Span`1<byte> get_U();
    [CompilerGeneratedAttribute]
public void set_U(Span`1<byte> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Span`1<byte> get_V();
    [CompilerGeneratedAttribute]
public void set_V(Span`1<byte> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_YStride();
    [CompilerGeneratedAttribute]
public void set_YStride(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_UvStride();
    [CompilerGeneratedAttribute]
public void set_UvStride(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_UseScaling();
    [CompilerGeneratedAttribute]
public void set_UseScaling(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ScaledWidth();
    [CompilerGeneratedAttribute]
public void set_ScaledWidth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_ScaledHeight();
    [CompilerGeneratedAttribute]
public void set_ScaledHeight(int value);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8MacroBlock : object {
    [CompilerGeneratedAttribute]
private UInt32 <NoneZeroAcDcCoeffs>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NoneZeroDcCoeffs>k__BackingField;
    public UInt32 NoneZeroAcDcCoeffs { get; public set; }
    public UInt32 NoneZeroDcCoeffs { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_NoneZeroAcDcCoeffs();
    [CompilerGeneratedAttribute]
public void set_NoneZeroAcDcCoeffs(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NoneZeroDcCoeffs();
    [CompilerGeneratedAttribute]
public void set_NoneZeroDcCoeffs(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8MacroBlockData : object {
    [CompilerGeneratedAttribute]
private Int16[] <Coeffs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsI4x4>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Modes>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UvMode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NonZeroY>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NonZeroUv>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skip>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Segment>k__BackingField;
    public Int16[] Coeffs { get; public set; }
    public bool IsI4x4 { get; public set; }
    public Byte[] Modes { get; }
    public byte UvMode { get; public set; }
    public UInt32 NonZeroY { get; public set; }
    public UInt32 NonZeroUv { get; public set; }
    public bool Skip { get; public set; }
    public byte Segment { get; public set; }
    [CompilerGeneratedAttribute]
public Int16[] get_Coeffs();
    [CompilerGeneratedAttribute]
public void set_Coeffs(Int16[] value);
    [CompilerGeneratedAttribute]
public bool get_IsI4x4();
    [CompilerGeneratedAttribute]
public void set_IsI4x4(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_Modes();
    [CompilerGeneratedAttribute]
public byte get_UvMode();
    [CompilerGeneratedAttribute]
public void set_UvMode(byte value);
    [CompilerGeneratedAttribute]
public UInt32 get_NonZeroY();
    [CompilerGeneratedAttribute]
public void set_NonZeroY(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NonZeroUv();
    [CompilerGeneratedAttribute]
public void set_NonZeroUv(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_Skip();
    [CompilerGeneratedAttribute]
public void set_Skip(bool value);
    [CompilerGeneratedAttribute]
public byte get_Segment();
    [CompilerGeneratedAttribute]
public void set_Segment(byte value);
}
[DebuggerDisplayAttribute("Type: {MacroBlockType}, Alpha: {Alpha}, UvMode: {UvMode}")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8MacroBlockInfo : object {
    [CompilerGeneratedAttribute]
private Vp8MacroBlockType <MacroBlockType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UvMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skip>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Segment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Alpha>k__BackingField;
    public Vp8MacroBlockType MacroBlockType { get; public set; }
    public int UvMode { get; public set; }
    public bool Skip { get; public set; }
    public int Segment { get; public set; }
    public int Alpha { get; public set; }
    [CompilerGeneratedAttribute]
public Vp8MacroBlockType get_MacroBlockType();
    [CompilerGeneratedAttribute]
public void set_MacroBlockType(Vp8MacroBlockType value);
    [CompilerGeneratedAttribute]
public int get_UvMode();
    [CompilerGeneratedAttribute]
public void set_UvMode(int value);
    [CompilerGeneratedAttribute]
public bool get_Skip();
    [CompilerGeneratedAttribute]
public void set_Skip(bool value);
    [CompilerGeneratedAttribute]
public int get_Segment();
    [CompilerGeneratedAttribute]
public void set_Segment(int value);
    [CompilerGeneratedAttribute]
public int get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(int value);
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8MacroBlockType : Enum {
    public int value__;
    public static Vp8MacroBlockType I4X4;
    public static Vp8MacroBlockType I16X16;
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Matrix : ValueType {
    [NullableAttribute("1")]
private static Int32[][] BiasMatrices;
    private static int SharpenBits;
    [FixedBufferAttribute("System.UInt16", "16")]
public <Q>e__FixedBuffer Q;
    [FixedBufferAttribute("System.UInt16", "16")]
public <IQ>e__FixedBuffer IQ;
    [FixedBufferAttribute("System.UInt32", "16")]
public <Bias>e__FixedBuffer Bias;
    [FixedBufferAttribute("System.UInt32", "16")]
public <ZThresh>e__FixedBuffer ZThresh;
    [FixedBufferAttribute("System.Int16", "16")]
public <Sharpen>e__FixedBuffer Sharpen;
    private static ReadOnlySpan`1<byte> FreqSharpening { get; }
    private static Vp8Matrix();
    private static ReadOnlySpan`1<byte> get_FreqSharpening();
    public int Expand(int type);
    private static int BIAS(int b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8ModeScore : object {
    public static long MaxCost;
    private static int RdDistoMult;
    [CompilerGeneratedAttribute]
private long <D>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SD>k__BackingField;
    [CompilerGeneratedAttribute]
private long <H>k__BackingField;
    [CompilerGeneratedAttribute]
private long <R>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <YDcLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <YAcLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <UvLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ModeI16>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ModesI4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ModeUv>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Nz>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[0...,0...] <Derr>k__BackingField;
    public long D { get; public set; }
    public long SD { get; public set; }
    public long H { get; public set; }
    public long R { get; public set; }
    public long Score { get; public set; }
    public Int16[] YDcLevels { get; }
    public Int16[] YAcLevels { get; }
    public Int16[] UvLevels { get; }
    public int ModeI16 { get; public set; }
    public Byte[] ModesI4 { get; }
    public int ModeUv { get; public set; }
    public UInt32 Nz { get; public set; }
    public Int32[0...,0...] Derr { get; }
    [CompilerGeneratedAttribute]
public long get_D();
    [CompilerGeneratedAttribute]
public void set_D(long value);
    [CompilerGeneratedAttribute]
public long get_SD();
    [CompilerGeneratedAttribute]
public void set_SD(long value);
    [CompilerGeneratedAttribute]
public long get_H();
    [CompilerGeneratedAttribute]
public void set_H(long value);
    [CompilerGeneratedAttribute]
public long get_R();
    [CompilerGeneratedAttribute]
public void set_R(long value);
    [CompilerGeneratedAttribute]
public long get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(long value);
    [CompilerGeneratedAttribute]
public Int16[] get_YDcLevels();
    [CompilerGeneratedAttribute]
public Int16[] get_YAcLevels();
    [CompilerGeneratedAttribute]
public Int16[] get_UvLevels();
    [CompilerGeneratedAttribute]
public int get_ModeI16();
    [CompilerGeneratedAttribute]
public void set_ModeI16(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_ModesI4();
    [CompilerGeneratedAttribute]
public int get_ModeUv();
    [CompilerGeneratedAttribute]
public void set_ModeUv(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_Nz();
    [CompilerGeneratedAttribute]
public void set_Nz(UInt32 value);
    [CompilerGeneratedAttribute]
public Int32[0...,0...] get_Derr();
    public void Clear();
    public void InitScore();
    public void CopyScore(Vp8ModeScore other);
    public void AddScore(Vp8ModeScore other);
    public void SetRdScore(int lambda);
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8PictureHeader : object {
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <XScale>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <YScale>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <ClampType>k__BackingField;
    public UInt32 Width { get; public set; }
    public UInt32 Height { get; public set; }
    public sbyte XScale { get; public set; }
    public sbyte YScale { get; public set; }
    public sbyte ColorSpace { get; public set; }
    public sbyte ClampType { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(UInt32 value);
    [CompilerGeneratedAttribute]
public sbyte get_XScale();
    [CompilerGeneratedAttribute]
public void set_XScale(sbyte value);
    [CompilerGeneratedAttribute]
public sbyte get_YScale();
    [CompilerGeneratedAttribute]
public void set_YScale(sbyte value);
    [CompilerGeneratedAttribute]
public sbyte get_ColorSpace();
    [CompilerGeneratedAttribute]
public void set_ColorSpace(sbyte value);
    [CompilerGeneratedAttribute]
public sbyte get_ClampType();
    [CompilerGeneratedAttribute]
public void set_ClampType(sbyte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Proba : object {
    private static int MbFeatureTreeProbs;
    [CompilerGeneratedAttribute]
private UInt32[] <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BandProbas[0...,0...] <Bands>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BandProbas[][] <BandsPtr>k__BackingField;
    public UInt32[] Segments { get; }
    public Vp8BandProbas[0...,0...] Bands { get; }
    public Vp8BandProbas[][] BandsPtr { get; }
    [CompilerGeneratedAttribute]
public UInt32[] get_Segments();
    [CompilerGeneratedAttribute]
public Vp8BandProbas[0...,0...] get_Bands();
    [CompilerGeneratedAttribute]
public Vp8BandProbas[][] get_BandsPtr();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8ProbaArray : object {
    [CompilerGeneratedAttribute]
private Byte[] <Probabilities>k__BackingField;
    public Byte[] Probabilities { get; }
    [CompilerGeneratedAttribute]
public Byte[] get_Probabilities();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8QuantMatrix : object {
    private int dither;
    [CompilerGeneratedAttribute]
private Int32[] <Y1Mat>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Y2Mat>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <UvMat>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UvQuant>k__BackingField;
    public Int32[] Y1Mat { get; }
    public Int32[] Y2Mat { get; }
    public Int32[] UvMat { get; }
    public int UvQuant { get; public set; }
    public int Dither { get; public set; }
    [CompilerGeneratedAttribute]
public Int32[] get_Y1Mat();
    [CompilerGeneratedAttribute]
public Int32[] get_Y2Mat();
    [CompilerGeneratedAttribute]
public Int32[] get_UvMat();
    [CompilerGeneratedAttribute]
public int get_UvQuant();
    [CompilerGeneratedAttribute]
public void set_UvQuant(int value);
    public int get_Dither();
    public void set_Dither(int value);
}
internal enum SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8RdLevel : Enum {
    public int value__;
    public static Vp8RdLevel RdOptNone;
    public static Vp8RdLevel RdOptBasic;
    public static Vp8RdLevel RdOptTrellis;
    public static Vp8RdLevel RdOptTrellisAll;
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Residual : object {
    [CompilerGeneratedAttribute]
private int <First>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Last>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoeffType>k__BackingField;
    [CompilerGeneratedAttribute]
private Int16[] <Coeffs>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BandProbas[] <Prob>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Stats[] <Stats>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8Costs[] <Costs>k__BackingField;
    public int First { get; public set; }
    public int Last { get; public set; }
    public int CoeffType { get; public set; }
    public Int16[] Coeffs { get; }
    public Vp8BandProbas[] Prob { get; public set; }
    public Vp8Stats[] Stats { get; public set; }
    public Vp8Costs[] Costs { get; public set; }
    [CompilerGeneratedAttribute]
public int get_First();
    [CompilerGeneratedAttribute]
public void set_First(int value);
    [CompilerGeneratedAttribute]
public int get_Last();
    [CompilerGeneratedAttribute]
public void set_Last(int value);
    [CompilerGeneratedAttribute]
public int get_CoeffType();
    [CompilerGeneratedAttribute]
public void set_CoeffType(int value);
    [CompilerGeneratedAttribute]
public Int16[] get_Coeffs();
    [CompilerGeneratedAttribute]
public Vp8BandProbas[] get_Prob();
    [CompilerGeneratedAttribute]
public void set_Prob(Vp8BandProbas[] value);
    [CompilerGeneratedAttribute]
public Vp8Stats[] get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(Vp8Stats[] value);
    [CompilerGeneratedAttribute]
public Vp8Costs[] get_Costs();
    [CompilerGeneratedAttribute]
public void set_Costs(Vp8Costs[] value);
    public void Init(int first, int coeffType, Vp8EncProba prob);
    public void SetCoeffs(Span`1<short> coeffs);
    public int RecordCoeffs(int ctx);
    public int GetResidualCost(int ctx0);
    private static int LevelCost(Span`1<ushort> table, int level);
    private static int RecordStats(int bit, Vp8StatsArray statsArr, int idx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8SegmentHeader : object {
    private static int NumMbSegments;
    [CompilerGeneratedAttribute]
private bool <UseSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Quantizer>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FilterStrength>k__BackingField;
    public bool UseSegment { get; public set; }
    public bool UpdateMap { get; public set; }
    public bool Delta { get; public set; }
    public Byte[] Quantizer { get; }
    public Byte[] FilterStrength { get; }
    [CompilerGeneratedAttribute]
public bool get_UseSegment();
    [CompilerGeneratedAttribute]
public void set_UseSegment(bool value);
    [CompilerGeneratedAttribute]
public bool get_UpdateMap();
    [CompilerGeneratedAttribute]
public void set_UpdateMap(bool value);
    [CompilerGeneratedAttribute]
public bool get_Delta();
    [CompilerGeneratedAttribute]
public void set_Delta(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_Quantizer();
    [CompilerGeneratedAttribute]
public Byte[] get_FilterStrength();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8SegmentInfo : object {
    public Vp8Matrix Y1;
    public Vp8Matrix Y2;
    public Vp8Matrix Uv;
    [CompilerGeneratedAttribute]
private int <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Beta>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Quant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxEdge>k__BackingField;
    [CompilerGeneratedAttribute]
private long <I4Penalty>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinDisto>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LambdaI16>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LambdaI4>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TLambda>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LambdaUv>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LambdaMode>k__BackingField;
    public int Alpha { get; public set; }
    public int Beta { get; public set; }
    public int Quant { get; public set; }
    public int FStrength { get; public set; }
    public int MaxEdge { get; public set; }
    public long I4Penalty { get; public set; }
    public int MinDisto { get; public set; }
    public int LambdaI16 { get; public set; }
    public int LambdaI4 { get; public set; }
    public int TLambda { get; public set; }
    public int LambdaUv { get; public set; }
    public int LambdaMode { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(int value);
    [CompilerGeneratedAttribute]
public int get_Beta();
    [CompilerGeneratedAttribute]
public void set_Beta(int value);
    [CompilerGeneratedAttribute]
public int get_Quant();
    [CompilerGeneratedAttribute]
public void set_Quant(int value);
    [CompilerGeneratedAttribute]
public int get_FStrength();
    [CompilerGeneratedAttribute]
public void set_FStrength(int value);
    [CompilerGeneratedAttribute]
public int get_MaxEdge();
    [CompilerGeneratedAttribute]
public void set_MaxEdge(int value);
    [CompilerGeneratedAttribute]
public long get_I4Penalty();
    [CompilerGeneratedAttribute]
public void set_I4Penalty(long value);
    [CompilerGeneratedAttribute]
public int get_MinDisto();
    [CompilerGeneratedAttribute]
public void set_MinDisto(int value);
    [CompilerGeneratedAttribute]
public int get_LambdaI16();
    [CompilerGeneratedAttribute]
public void set_LambdaI16(int value);
    [CompilerGeneratedAttribute]
public int get_LambdaI4();
    [CompilerGeneratedAttribute]
public void set_LambdaI4(int value);
    [CompilerGeneratedAttribute]
public int get_TLambda();
    [CompilerGeneratedAttribute]
public void set_TLambda(int value);
    [CompilerGeneratedAttribute]
public int get_LambdaUv();
    [CompilerGeneratedAttribute]
public void set_LambdaUv(int value);
    [CompilerGeneratedAttribute]
public int get_LambdaMode();
    [CompilerGeneratedAttribute]
public void set_LambdaMode(int value);
    public void StoreMaxDelta(Span`1<short> dcs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8Stats : object {
    [CompilerGeneratedAttribute]
private Vp8StatsArray[] <Stats>k__BackingField;
    public Vp8StatsArray[] Stats { get; }
    [CompilerGeneratedAttribute]
public Vp8StatsArray[] get_Stats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8StatsArray : object {
    [CompilerGeneratedAttribute]
private UInt32[] <Stats>k__BackingField;
    public UInt32[] Stats { get; }
    [CompilerGeneratedAttribute]
public UInt32[] get_Stats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.Vp8TopSamples : object {
    [CompilerGeneratedAttribute]
private Byte[] <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <U>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <V>k__BackingField;
    public Byte[] Y { get; }
    public Byte[] U { get; }
    public Byte[] V { get; }
    [CompilerGeneratedAttribute]
public Byte[] get_Y();
    [CompilerGeneratedAttribute]
public Byte[] get_U();
    [CompilerGeneratedAttribute]
public Byte[] get_V();
}
internal class SixLabors.ImageSharp.Formats.Webp.Lossy.WebpLossyDecoder : object {
    private Vp8BitReader bitReader;
    private MemoryAllocator memoryAllocator;
    private Configuration configuration;
    public WebpLossyDecoder(Vp8BitReader bitReader, MemoryAllocator memoryAllocator, Configuration configuration);
    public void Decode(Buffer2D`1<TPixel> pixels, int width, int height, WebpImageInfo info, IMemoryOwner`1<byte> alphaData);
    private void DecodePixelValues(int width, int height, Span`1<byte> pixelData, Buffer2D`1<TPixel> decodedPixels);
    private static void DecodePixelValues(int width, int height, Span`1<byte> pixelData, Buffer2D`1<TPixel> decodedPixels, IMemoryOwner`1<byte> alpha);
    private void ParseFrame(Vp8Decoder dec, Vp8Io io);
    private void ParseIntraMode(Vp8Decoder dec, int mbX);
    private static void InitScanline(Vp8Decoder dec);
    private void ProcessRow(Vp8Decoder dec, Vp8Io io);
    private void ReconstructRow(Vp8Decoder dec);
    private static void FilterRow(Vp8Decoder dec);
    private static void DoFilter(Vp8Decoder dec, int mbx, int mby);
    private static void FinishRow(Vp8Decoder dec, Vp8Io io);
    private static int EmitRgb(Vp8Decoder dec, Vp8Io io);
    private static void DoTransform(UInt32 bits, Span`1<short> src, Span`1<byte> dst, Span`1<int> scratch);
    private static void DoUVTransform(UInt32 bits, Span`1<short> src, Span`1<byte> dst, Span`1<int> scratch);
    private void DecodeMacroBlock(Vp8Decoder dec, Vp8BitReader bitreader);
    private bool ParseResiduals(Vp8Decoder dec, Vp8BitReader br, Vp8MacroBlock mb);
    private static int GetCoeffs(Vp8BitReader br, Vp8BandProbas[] prob, int ctx, Int32[] dq, int n, Span`1<short> coeffs);
    private static int GetLargeValue(Vp8BitReader br, Byte[] p);
    private Vp8SegmentHeader ParseSegmentHeader(Vp8Proba proba);
    private void ParseFilterHeader(Vp8Decoder dec);
    private void ParsePartitions(Vp8Decoder dec);
    private void ParseDequantizationIndices(Vp8Decoder decoder);
    private void ParseProbabilities(Vp8Decoder dec);
    private static Vp8Io InitializeVp8Io(Vp8Decoder dec, Vp8PictureHeader pictureHeader);
    private static UInt32 NzCodeBits(UInt32 nzCoeffs, int nz, int dcNz);
    private static int CheckMode(int mbx, int mby, int mode);
    private static int Clip(int value, int max);
}
internal static class SixLabors.ImageSharp.Formats.Webp.Lossy.YuvConversion : object {
    private static int YuvFix;
    private static int YuvHalf;
    public static void UpSample(Span`1<byte> topY, Span`1<byte> bottomY, Span`1<byte> topU, Span`1<byte> topV, Span`1<byte> curU, Span`1<byte> curV, Span`1<byte> topDst, Span`1<byte> bottomDst, int len, Byte[] uvBuffer);
    private static void UpSampleScalar(Span`1<byte> topY, Span`1<byte> bottomY, Span`1<byte> topU, Span`1<byte> topV, Span`1<byte> curU, Span`1<byte> curV, Span`1<byte> topDst, Span`1<byte> bottomDst, int len);
    private static void UpSampleSse41(Span`1<byte> topY, Span`1<byte> bottomY, Span`1<byte> topU, Span`1<byte> topV, Span`1<byte> curU, Span`1<byte> curV, Span`1<byte> topDst, Span`1<byte> bottomDst, int len, Byte[] uvBuffer);
    private static void UpSample32Pixels(Byte& r1, Byte& r2, Span`1<byte> output);
    private static void UpSampleLastBlock(Span`1<byte> tb, Span`1<byte> bb, int numPixels, Span`1<byte> output);
    private static Vector128`1<byte> GetM(Vector128`1<byte> k, Vector128`1<byte> st, Vector128`1<byte> ij, Vector128`1<byte> input);
    private static void PackAndStore(Vector128`1<byte> a, Vector128`1<byte> b, Vector128`1<byte> da, Vector128`1<byte> db, Span`1<byte> output);
    public static bool ConvertRgbToYuv(Buffer2DRegion`1<TPixel> frame, Configuration configuration, MemoryAllocator memoryAllocator, Span`1<byte> y, Span`1<byte> u, Span`1<byte> v);
    public static void ConvertRgbaToY(Span`1<Bgra32> rowSpan, Span`1<byte> y, int width);
    public static void ConvertRgbaToUv(Span`1<ushort> rgb, Span`1<byte> u, Span`1<byte> v, int width);
    public static void AccumulateRgb(Span`1<Bgra32> rowSpan, Span`1<Bgra32> nextRowSpan, Span`1<ushort> dst, int width);
    public static void AccumulateRgba(Span`1<Bgra32> rowSpan, Span`1<Bgra32> nextRowSpan, Span`1<ushort> dst, int width);
    private static int LinearToGammaWeighted(byte rgb0, byte rgb1, byte rgb2, byte rgb3, byte a0, byte a1, byte a2, byte a3, UInt32 totalA);
    private static int LinearToGamma(UInt32 baseValue, int shift);
    private static UInt32 GammaToLinear(byte v);
    private static int Interpolate(int v);
    private static int RgbToY(byte r, byte g, byte b, int rounding);
    private static int RgbToU(int r, int g, int b, int rounding);
    private static int RgbToV(int r, int g, int b, int rounding);
    private static int ClipUv(int uv, int rounding);
    public static UInt32 LoadUv(byte u, byte v);
    public static void YuvToBgr(int y, int u, int v, Span`1<byte> bgr);
    private static void ConvertYuvToBgrSse41(Span`1<byte> topY, Span`1<byte> topDst, Span`1<byte> ru, Span`1<byte> rv, int curX, int step);
    private static void ConvertYuvToBgrWithBottomYSse41(Span`1<byte> topY, Span`1<byte> bottomY, Span`1<byte> topDst, Span`1<byte> bottomDst, Span`1<byte> ru, Span`1<byte> rv, int curX, int step);
    private static void YuvToBgrSse41(Span`1<byte> y, Span`1<byte> u, Span`1<byte> v, Span`1<byte> dst);
    private static void PlanarTo24bSse41(Vector128`1<byte> input0, Vector128`1<byte> input1, Vector128`1<byte> input2, Vector128`1<byte> input3, Vector128`1<byte> input4, Vector128`1<byte> input5, Span`1<byte> rgb);
    private static void ChannelMixing(Vector128`1<byte> input0, Vector128`1<byte> input1, Vector128`1<byte> shuffle0, Vector128`1<byte> shuffle1, Vector128`1<byte> shuffle2, Vector128`1& output0, Vector128`1& output1, Vector128`1& output2, Vector128`1& output3, Vector128`1& output4, Vector128`1& output5);
    private static void ConvertYuv444ToBgrSse41(Byte& y, Byte& u, Byte& v, Vector128`1& r, Vector128`1& g, Vector128`1& b);
    public static int YuvToB(int y, int u);
    public static int YuvToG(int y, int u, int v);
    public static int YuvToR(int y, int v);
    private static int MultHi(int v, int coeff);
    private static byte Clip8(int v);
}
internal enum SixLabors.ImageSharp.Formats.Webp.WebpAlphaCompressionMethod : Enum {
    public int value__;
    public static WebpAlphaCompressionMethod NoCompression;
    public static WebpAlphaCompressionMethod WebpLosslessCompression;
}
internal enum SixLabors.ImageSharp.Formats.Webp.WebpAlphaFilterType : Enum {
    public int value__;
    public static WebpAlphaFilterType None;
    public static WebpAlphaFilterType Horizontal;
    public static WebpAlphaFilterType Vertical;
    public static WebpAlphaFilterType Gradient;
}
internal class SixLabors.ImageSharp.Formats.Webp.WebpAnimationDecoder : object {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    [NullableAttribute("1")]
private Configuration configuration;
    private UInt32 maxFrames;
    private Nullable`1<Rectangle> restoreArea;
    [NullableAttribute("2")]
private ImageMetadata metadata;
    [NullableAttribute("2")]
private WebpMetadata webpMetadata;
    [NullableAttribute("2")]
private IMemoryOwner`1<byte> alphaData;
    private BackgroundColorHandling backgroundColorHandling;
    [NullableContextAttribute("1")]
public WebpAnimationDecoder(MemoryAllocator memoryAllocator, Configuration configuration, UInt32 maxFrames, BackgroundColorHandling backgroundColorHandling);
    [NullableContextAttribute("1")]
public Image`1<TPixel> Decode(BufferedReadStream stream, WebpFeatures features, UInt32 width, UInt32 height, UInt32 completeDataSize);
    private UInt32 ReadFrame(BufferedReadStream stream, Image`1& image, ImageFrame`1& previousFrame, UInt32 width, UInt32 height, Color backgroundColor);
    [NullableContextAttribute("1")]
private static void SetFrameMetadata(ImageFrameMetadata meta, WebpFrameData frameData);
    [NullableContextAttribute("1")]
private byte ReadAlphaData(BufferedReadStream stream);
    private Buffer2D`1<TPixel> DecodeImageFrameData(WebpFrameData frameData, WebpImageInfo webpInfo);
    private static void DrawDecodedImageFrameOnCanvas(Buffer2D`1<TPixel> decodedImageFrame, ImageFrame`1<TPixel> imageFrame, Rectangle restoreArea, bool blend);
    private void RestoreToBackground(ImageFrame`1<TPixel> imageFrame, Color backgroundColor);
    public sealed virtual void Dispose();
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpBitsPerPixel : Enum {
    public short value__;
    public static WebpBitsPerPixel Pixel24;
    public static WebpBitsPerPixel Pixel32;
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpBlendMethod : Enum {
    public int value__;
    public static WebpBlendMethod Source;
    public static WebpBlendMethod Over;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Webp.WebpChunkParsingUtils : object {
    public static WebpImageInfo ReadVp8Header(MemoryAllocator memoryAllocator, BufferedReadStream stream, Span`1<byte> buffer, WebpFeatures features);
    public static WebpImageInfo ReadVp8LHeader(MemoryAllocator memoryAllocator, BufferedReadStream stream, Span`1<byte> buffer, WebpFeatures features);
    public static WebpImageInfo ReadVp8XHeader(BufferedReadStream stream, Span`1<byte> buffer, WebpFeatures features);
    [NullableContextAttribute("0")]
public static UInt32 ReadUInt24LittleEndian(Stream stream, Span`1<byte> buffer);
    public static void WriteUInt24LittleEndian(Stream stream, UInt32 data);
    [NullableContextAttribute("0")]
public static UInt32 ReadChunkSize(Stream stream, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public static WebpChunkType ReadChunkType(BufferedReadStream stream, Span`1<byte> buffer);
    public static void ParseOptionalChunks(BufferedReadStream stream, WebpChunkType chunkType, ImageMetadata metadata, bool ignoreMetaData, Span`1<byte> buffer);
    public static bool IsOptionalVp8XChunk(WebpChunkType chunkType);
}
internal enum SixLabors.ImageSharp.Formats.Webp.WebpChunkType : Enum {
    public UInt32 value__;
    public static WebpChunkType Vp8;
    public static WebpChunkType Vp8L;
    public static WebpChunkType Vp8X;
    public static WebpChunkType Alpha;
    public static WebpChunkType Iccp;
    public static WebpChunkType Exif;
    public static WebpChunkType Xmp;
    public static WebpChunkType AnimationParameter;
    public static WebpChunkType FrameData;
}
internal static class SixLabors.ImageSharp.Formats.Webp.WebpCommonUtils : object {
    public static WebpMetadata GetWebpMetadata(Image`1<TPixel> image);
    public static WebpFrameMetadata GetWebpFrameMetadata(ImageFrame`1<TPixel> frame);
    public static bool CheckNonOpaque(Span`1<Bgra32> row);
    private static bool IsNoneOpaque64Bytes(Byte* src, int i);
    private static bool IsNoneOpaque32Bytes(Byte* src, int i);
}
public class SixLabors.ImageSharp.Formats.Webp.WebpConfigurationModule : object {
    [NullableContextAttribute("1")]
public sealed virtual void Configure(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Webp.WebpConstants : object {
    public static IEnumerable`1<string> FileExtensions;
    public static IEnumerable`1<string> MimeTypes;
    public static Byte[] Vp8HeaderMagicBytes;
    public static byte Vp8LHeaderMagicByte;
    public static Byte[] RiffFourCc;
    public static Byte[] WebpHeader;
    public static string WebpFourCc;
    public static int Vp8LVersionBits;
    public static int Vp8LImageSizeBits;
    public static int Vp8FrameHeaderSize;
    public static int ChunkHeaderSize;
    public static int RiffHeaderSize;
    public static int TagSize;
    public static int Vp8LVersion;
    public static int MaxHuffImageSize;
    public static int MinHuffmanBits;
    public static int MaxHuffmanBits;
    public static int MaxPaletteSize;
    public static int MaxColorCacheBits;
    public static int MaxNumberOfTransforms;
    public static int MaxTransformBits;
    public static int TransformPresent;
    public static int MaxDimension;
    public static int MaxAllowedCodeLength;
    public static int DefaultCodeLength;
    public static int HuffmanCodesPerMetaCode;
    public static UInt32 ArgbBlack;
    public static int NumArgbCacheRows;
    public static int NumLiteralCodes;
    public static int NumLengthCodes;
    public static int NumDistanceCodes;
    public static int CodeLengthCodes;
    public static int LengthTableBits;
    public static UInt32 CodeLengthLiterals;
    public static int CodeLengthRepeatCode;
    public static Int32[] CodeLengthExtraBits;
    public static Int32[] CodeLengthRepeatOffsets;
    public static Int32[] AlphabetSize;
    public static int NumMbSegments;
    public static int MaxNumPartitions;
    public static int NumTypes;
    public static int NumBands;
    public static int NumProbas;
    public static int NumPredModes;
    public static int NumBModes;
    public static int NumCtx;
    public static int MaxVariableLevel;
    public static int FlatnessLimitI16;
    public static int FlatnessLimitIUv;
    public static int FlatnessLimitI4;
    public static int FlatnessPenality;
    public static int Bps;
    public static double Gamma;
    public static int GammaFix;
    public static int GammaScale;
    public static int GammaTabFix;
    public static int GammaTabSize;
    public static int GammaTabScale;
    public static int GammaTabRounder;
    public static int AlphaFix;
    public static int MaxAlpha;
    public static int AlphaScale;
    public static int QuantEncMidAlpha;
    public static int QuantEncMinAlpha;
    public static int QuantEncMaxAlpha;
    public static double SnsToDq;
    public static int QuantEncMaxDqUv;
    public static int QuantEncMinDqUv;
    public static int QFix;
    public static int MaxDelzaSize;
    public static int FilterStrengthCutoff;
    public static int Vp8MaxPartition0Size;
    public static Int16[] Vp8FixedCostsUv;
    public static Int16[] Vp8FixedCostsI16;
    public static int RdDistoMult;
    public static Byte[] FilterExtraRows;
    public static Int32[] Vp8EncBands;
    public static Int16[] Scan;
    public static Byte[] Cat3;
    public static Byte[] Cat4;
    public static Byte[] Cat5;
    public static Byte[] Cat6;
    public static Byte[] Zigzag;
    public static SByte[] YModesIntra4;
    private static WebpConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class SixLabors.ImageSharp.Formats.Webp.WebpDecoder : SpecializedImageDecoder`1<WebpDecoderOptions> {
    [CompilerGeneratedAttribute]
private static WebpDecoder <Instance>k__BackingField;
    public static WebpDecoder Instance { get; }
    private static WebpDecoder();
    [CompilerGeneratedAttribute]
public static WebpDecoder get_Instance();
    protected virtual ImageInfo Identify(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image`1<TPixel> Decode(WebpDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(WebpDecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual Image Decode(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    protected virtual WebpDecoderOptions CreateDefaultSpecializedOptions(DecoderOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.WebpDecoderCore : object {
    private Configuration configuration;
    private bool skipMetadata;
    private UInt32 maxFrames;
    [NullableAttribute("2")]
private IMemoryOwner`1<byte> alphaData;
    private MemoryAllocator memoryAllocator;
    [NullableAttribute("2")]
private WebpImageInfo webImageInfo;
    private BackgroundColorHandling backgroundColorHandling;
    [CompilerGeneratedAttribute]
private DecoderOptions <Options>k__BackingField;
    public DecoderOptions Options { get; }
    public Size Dimensions { get; }
    public WebpDecoderCore(WebpDecoderOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_Options();
    public sealed virtual Size get_Dimensions();
    [NullableContextAttribute("0")]
public sealed virtual Image`1<TPixel> Decode(BufferedReadStream stream, CancellationToken cancellationToken);
    public sealed virtual ImageInfo Identify(BufferedReadStream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static UInt32 ReadImageHeader(BufferedReadStream stream, Span`1<byte> buffer);
    private WebpImageInfo ReadVp8Info(BufferedReadStream stream, ImageMetadata metadata, bool ignoreAlpha);
    private bool ParseOptionalExtendedChunks(BufferedReadStream stream, ImageMetadata metadata, WebpChunkType chunkType, WebpFeatures features, bool ignoreAlpha, Span`1<byte> buffer);
    private void ParseOptionalChunks(BufferedReadStream stream, ImageMetadata metadata, WebpFeatures features, Span`1<byte> buffer);
    private void ReadExifProfile(BufferedReadStream stream, ImageMetadata metadata, Span`1<byte> buffer);
    private static double GetExifResolutionValue(ExifProfile exifProfile, ExifTag`1<Rational> tag);
    private void ReadXmpProfile(BufferedReadStream stream, ImageMetadata metadata, Span`1<byte> buffer);
    private void ReadIccProfile(BufferedReadStream stream, ImageMetadata metadata, Span`1<byte> buffer);
    private static void ReadAnimationParameters(BufferedReadStream stream, WebpFeatures features, Span`1<byte> buffer);
    private void ReadAlphaData(BufferedReadStream stream, WebpFeatures features, bool ignoreAlpha, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
private static WebpChunkType ReadChunkType(BufferedReadStream stream, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
private static UInt32 ReadChunkSize(BufferedReadStream stream, Span`1<byte> buffer);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Webp.WebpDecoderOptions : object {
    [CompilerGeneratedAttribute]
private DecoderOptions <GeneralOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundColorHandling <BackgroundColorHandling>k__BackingField;
    public DecoderOptions GeneralOptions { get; public set; }
    public BackgroundColorHandling BackgroundColorHandling { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual DecoderOptions get_GeneralOptions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GeneralOptions(DecoderOptions value);
    [CompilerGeneratedAttribute]
public BackgroundColorHandling get_BackgroundColorHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BackgroundColorHandling(BackgroundColorHandling value);
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpDisposalMethod : Enum {
    public int value__;
    public static WebpDisposalMethod DoNotDispose;
    public static WebpDisposalMethod RestoreToBackground;
}
public class SixLabors.ImageSharp.Formats.Webp.WebpEncoder : ImageEncoder {
    [CompilerGeneratedAttribute]
private Nullable`1<WebpFileFormatType> <FileFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Quality>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpEncodingMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAlphaCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EntropyPasses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpatialNoiseShaping>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FilterStrength>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpTransparentColorMode <TransparentColorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NearLossless>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NearLosslessQuality>k__BackingField;
    public Nullable`1<WebpFileFormatType> FileFormat { get; public set; }
    public int Quality { get; public set; }
    public WebpEncodingMethod Method { get; public set; }
    public bool UseAlphaCompression { get; public set; }
    public int EntropyPasses { get; public set; }
    public int SpatialNoiseShaping { get; public set; }
    public int FilterStrength { get; public set; }
    public WebpTransparentColorMode TransparentColorMode { get; public set; }
    public bool NearLossless { get; public set; }
    public int NearLosslessQuality { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<WebpFileFormatType> get_FileFormat();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileFormat(Nullable`1<WebpFileFormatType> value);
    [CompilerGeneratedAttribute]
public int get_Quality();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Quality(int value);
    [CompilerGeneratedAttribute]
public WebpEncodingMethod get_Method();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Method(WebpEncodingMethod value);
    [CompilerGeneratedAttribute]
public bool get_UseAlphaCompression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseAlphaCompression(bool value);
    [CompilerGeneratedAttribute]
public int get_EntropyPasses();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EntropyPasses(int value);
    [CompilerGeneratedAttribute]
public int get_SpatialNoiseShaping();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SpatialNoiseShaping(int value);
    [CompilerGeneratedAttribute]
public int get_FilterStrength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilterStrength(int value);
    [CompilerGeneratedAttribute]
public WebpTransparentColorMode get_TransparentColorMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TransparentColorMode(WebpTransparentColorMode value);
    [CompilerGeneratedAttribute]
public bool get_NearLossless();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NearLossless(bool value);
    [CompilerGeneratedAttribute]
public int get_NearLosslessQuality();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NearLosslessQuality(int value);
    protected virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
internal class SixLabors.ImageSharp.Formats.Webp.WebpEncoderCore : object {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    private bool alphaCompression;
    private UInt32 quality;
    private WebpEncodingMethod method;
    private int entropyPasses;
    private int spatialNoiseShaping;
    private int filterStrength;
    private WebpTransparentColorMode transparentColorMode;
    private bool skipMetadata;
    private bool nearLossless;
    private int nearLosslessQuality;
    private Nullable`1<WebpFileFormatType> fileFormat;
    [NullableAttribute("1")]
private Configuration configuration;
    [NullableContextAttribute("1")]
public WebpEncoderCore(WebpEncoder encoder, Configuration configuration);
    public sealed virtual void Encode(Image`1<TPixel> image, Stream stream, CancellationToken cancellationToken);
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpEncodingMethod : Enum {
    public int value__;
    public static WebpEncodingMethod Level0;
    public static WebpEncodingMethod Fastest;
    public static WebpEncodingMethod Level1;
    public static WebpEncodingMethod Level2;
    public static WebpEncodingMethod Level3;
    public static WebpEncodingMethod Level4;
    public static WebpEncodingMethod Default;
    public static WebpEncodingMethod Level5;
    public static WebpEncodingMethod Level6;
    public static WebpEncodingMethod BestQuality;
}
internal class SixLabors.ImageSharp.Formats.Webp.WebpFeatures : object {
    [CompilerGeneratedAttribute]
private bool <IccProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <AlphaChunkHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExifProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmpMetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Animation>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AnimationLoopCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <AnimationBackgroundColor>k__BackingField;
    public bool IccProfile { get; public set; }
    public bool Alpha { get; public set; }
    public byte AlphaChunkHeader { get; public set; }
    public bool ExifProfile { get; public set; }
    public bool XmpMetaData { get; public set; }
    public bool Animation { get; public set; }
    public ushort AnimationLoopCount { get; public set; }
    public Nullable`1<Color> AnimationBackgroundColor { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IccProfile();
    [CompilerGeneratedAttribute]
public void set_IccProfile(bool value);
    [CompilerGeneratedAttribute]
public bool get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(bool value);
    [CompilerGeneratedAttribute]
public byte get_AlphaChunkHeader();
    [CompilerGeneratedAttribute]
public void set_AlphaChunkHeader(byte value);
    [CompilerGeneratedAttribute]
public bool get_ExifProfile();
    [CompilerGeneratedAttribute]
public void set_ExifProfile(bool value);
    [CompilerGeneratedAttribute]
public bool get_XmpMetaData();
    [CompilerGeneratedAttribute]
public void set_XmpMetaData(bool value);
    [CompilerGeneratedAttribute]
public bool get_Animation();
    [CompilerGeneratedAttribute]
public void set_Animation(bool value);
    [CompilerGeneratedAttribute]
public ushort get_AnimationLoopCount();
    [CompilerGeneratedAttribute]
public void set_AnimationLoopCount(ushort value);
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_AnimationBackgroundColor();
    [CompilerGeneratedAttribute]
public void set_AnimationBackgroundColor(Nullable`1<Color> value);
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpFileFormatType : Enum {
    public int value__;
    public static WebpFileFormatType Lossless;
    public static WebpFileFormatType Lossy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Webp.WebpFormat : object {
    [CompilerGeneratedAttribute]
private static WebpFormat <Instance>k__BackingField;
    public static WebpFormat Instance { get; }
    public string Name { get; }
    public string DefaultMimeType { get; }
    public IEnumerable`1<string> MimeTypes { get; }
    public IEnumerable`1<string> FileExtensions { get; }
    private static WebpFormat();
    [CompilerGeneratedAttribute]
public static WebpFormat get_Instance();
    public sealed virtual string get_Name();
    public sealed virtual string get_DefaultMimeType();
    public sealed virtual IEnumerable`1<string> get_MimeTypes();
    public sealed virtual IEnumerable`1<string> get_FileExtensions();
    public sealed virtual WebpMetadata CreateDefaultFormatMetadata();
    public sealed virtual WebpFrameMetadata CreateDefaultFormatFrameMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Webp.WebpFrameMetadata : object {
    [CompilerGeneratedAttribute]
private WebpBlendMethod <BlendMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpDisposalMethod <DisposalMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FrameDelay>k__BackingField;
    public WebpBlendMethod BlendMethod { get; public set; }
    public WebpDisposalMethod DisposalMethod { get; public set; }
    public UInt32 FrameDelay { get; public set; }
    private WebpFrameMetadata(WebpFrameMetadata other);
    [CompilerGeneratedAttribute]
public WebpBlendMethod get_BlendMethod();
    [CompilerGeneratedAttribute]
public void set_BlendMethod(WebpBlendMethod value);
    [CompilerGeneratedAttribute]
public WebpDisposalMethod get_DisposalMethod();
    [CompilerGeneratedAttribute]
public void set_DisposalMethod(WebpDisposalMethod value);
    [CompilerGeneratedAttribute]
public UInt32 get_FrameDelay();
    [CompilerGeneratedAttribute]
public void set_FrameDelay(UInt32 value);
    public sealed virtual IDeepCloneable DeepClone();
    internal static WebpFrameMetadata FromAnimatedMetadata(AnimatedImageFrameMetadata metadata);
}
public class SixLabors.ImageSharp.Formats.Webp.WebpImageFormatDetector : object {
    public int HeaderSize { get; }
    public sealed virtual int get_HeaderSize();
    public sealed virtual bool TryDetectFormat(ReadOnlySpan`1<byte> header, IImageFormat& format);
    private bool IsSupportedFileFormat(ReadOnlySpan`1<byte> header);
    private static bool IsRiffContainer(ReadOnlySpan`1<byte> header);
    private static bool IsWebpFile(ReadOnlySpan`1<byte> header);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Formats.Webp.WebpImageInfo : object {
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <XScale>k__BackingField;
    [CompilerGeneratedAttribute]
private sbyte <YScale>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpBitsPerPixel <BitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLossless>k__BackingField;
    [CompilerGeneratedAttribute]
private WebpFeatures <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Vp8Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8FrameHeader <Vp8FrameHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8LBitReader <Vp8LBitReader>k__BackingField;
    [CompilerGeneratedAttribute]
private Vp8BitReader <Vp8BitReader>k__BackingField;
    public UInt32 Width { get; public set; }
    public UInt32 Height { get; public set; }
    public sbyte XScale { get; public set; }
    public sbyte YScale { get; public set; }
    public WebpBitsPerPixel BitsPerPixel { get; public set; }
    public bool IsLossless { get; public set; }
    public WebpFeatures Features { get; public set; }
    public int Vp8Profile { get; public set; }
    public Vp8FrameHeader Vp8FrameHeader { get; public set; }
    public Vp8LBitReader Vp8LBitReader { get; public set; }
    public Vp8BitReader Vp8BitReader { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(UInt32 value);
    [CompilerGeneratedAttribute]
public sbyte get_XScale();
    [CompilerGeneratedAttribute]
public void set_XScale(sbyte value);
    [CompilerGeneratedAttribute]
public sbyte get_YScale();
    [CompilerGeneratedAttribute]
public void set_YScale(sbyte value);
    [CompilerGeneratedAttribute]
public WebpBitsPerPixel get_BitsPerPixel();
    [CompilerGeneratedAttribute]
public void set_BitsPerPixel(WebpBitsPerPixel value);
    [CompilerGeneratedAttribute]
public bool get_IsLossless();
    [CompilerGeneratedAttribute]
public void set_IsLossless(bool value);
    [CompilerGeneratedAttribute]
public WebpFeatures get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(WebpFeatures value);
    [CompilerGeneratedAttribute]
public int get_Vp8Profile();
    [CompilerGeneratedAttribute]
public void set_Vp8Profile(int value);
    [CompilerGeneratedAttribute]
public Vp8FrameHeader get_Vp8FrameHeader();
    [CompilerGeneratedAttribute]
public void set_Vp8FrameHeader(Vp8FrameHeader value);
    [CompilerGeneratedAttribute]
public Vp8LBitReader get_Vp8LBitReader();
    [CompilerGeneratedAttribute]
public void set_Vp8LBitReader(Vp8LBitReader value);
    [CompilerGeneratedAttribute]
public Vp8BitReader get_Vp8BitReader();
    [CompilerGeneratedAttribute]
public void set_Vp8BitReader(Vp8BitReader value);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Webp.WebpLookupTables : object {
    public static Byte[][0...,0...] ModesProba;
    public static UInt16[] GammaToLinearTab;
    public static Int32[] LinearToGammaTab;
    public static Int16[][0...,0...] Vp8FixedCostsI4;
    public static Int32[] Vp8DspScan;
    public static Int16[] Vp8Scan;
    public static Int16[] Vp8ScanUv;
    public static Int16[] Vp8LevelFixedCosts;
    public static Byte[0...,0...] LevelsFromDelta;
    public static UInt16[] Vp8EntropyCost;
    public static UInt16[][] Vp8LevelCodes;
    public static Single[] Log2Table;
    public static Single[] SLog2Table;
    public static Int32[] CodeToPlane;
    public static UInt32[] PlaneToCodeLut;
    public static UInt16[] AcTable;
    public static UInt16[] AcTable2;
    public static Byte[0...,0...,0...,0...] CoeffsUpdateProba;
    public static Byte[0...,0...,0...,0...] DefaultCoeffsProba;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ValueTuple`2[] PrefixEncodeCode;
    public static UInt32[] InvAlpha;
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> Norm { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> NewRange { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> LogTable8Bit { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> DcTable { get; }
    [NullableAttribute("0")]
public static ReadOnlySpan`1<byte> PrefixEncodeExtraBitsValue { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> Abs0Table { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> Clip1Table { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<sbyte> Sclip1Table { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<sbyte> Sclip2Table { get; }
    private static WebpLookupTables();
    public static byte Abs0(int x);
    public static sbyte Sclip1(int x);
    public static sbyte Sclip2(int x);
    public static byte Clip1(int x);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_Norm();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_NewRange();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_LogTable8Bit();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_DcTable();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> get_PrefixEncodeExtraBitsValue();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_Abs0Table();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_Clip1Table();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<sbyte> get_Sclip1Table();
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<sbyte> get_Sclip2Table();
    private static void InitializeModesProbabilities();
    private static void InitializeFixedCostsI4();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Formats.Webp.WebpMetadata : object {
    [CompilerGeneratedAttribute]
private Nullable`1<WebpFileFormatType> <FileFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RepeatCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <BackgroundColor>k__BackingField;
    public Nullable`1<WebpFileFormatType> FileFormat { get; public set; }
    public ushort RepeatCount { get; public set; }
    public Color BackgroundColor { get; public set; }
    private WebpMetadata(WebpMetadata other);
    [CompilerGeneratedAttribute]
public Nullable`1<WebpFileFormatType> get_FileFormat();
    [CompilerGeneratedAttribute]
public void set_FileFormat(Nullable`1<WebpFileFormatType> value);
    [CompilerGeneratedAttribute]
public ushort get_RepeatCount();
    [CompilerGeneratedAttribute]
public void set_RepeatCount(ushort value);
    [CompilerGeneratedAttribute]
public Color get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Color value);
    public sealed virtual IDeepCloneable DeepClone();
    internal static WebpMetadata FromAnimatedMetadata(AnimatedImageMetadata metadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Formats.Webp.WebpThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowInvalidImageContentException(string errorMessage);
    [DoesNotReturnAttribute]
public static void ThrowImageFormatException(string errorMessage);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(string errorMessage);
    [DoesNotReturnAttribute]
public static void ThrowInvalidImageDimensions(string errorMessage);
}
public enum SixLabors.ImageSharp.Formats.Webp.WebpTransparentColorMode : Enum {
    public int value__;
    public static WebpTransparentColorMode Clear;
    public static WebpTransparentColorMode Preserve;
}
public static class SixLabors.ImageSharp.GeometryUtilities : object {
    public static float DegreeToRadian(float degree);
    public static float RadianToDegree(float radian);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.GraphicOptionsDefaultsExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext SetGraphicsOptions(IImageProcessingContext context, Action`1<GraphicsOptions> optionsBuilder);
    [ExtensionAttribute]
public static void SetGraphicsOptions(Configuration configuration, Action`1<GraphicsOptions> optionsBuilder);
    [ExtensionAttribute]
public static IImageProcessingContext SetGraphicsOptions(IImageProcessingContext context, GraphicsOptions options);
    [ExtensionAttribute]
public static void SetGraphicsOptions(Configuration configuration, GraphicsOptions options);
    [ExtensionAttribute]
public static GraphicsOptions GetGraphicsOptions(IImageProcessingContext context);
    [ExtensionAttribute]
public static GraphicsOptions GetGraphicsOptions(Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.GraphicsOptions : object {
    private int antialiasSubpixelDepth;
    private float blendPercentage;
    [CompilerGeneratedAttribute]
private bool <Antialias>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelColorBlendingMode <ColorBlendingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelAlphaCompositionMode <AlphaCompositionMode>k__BackingField;
    public bool Antialias { get; public set; }
    public int AntialiasSubpixelDepth { get; public set; }
    public float BlendPercentage { get; public set; }
    public PixelColorBlendingMode ColorBlendingMode { get; public set; }
    public PixelAlphaCompositionMode AlphaCompositionMode { get; public set; }
    private GraphicsOptions(GraphicsOptions source);
    [CompilerGeneratedAttribute]
public bool get_Antialias();
    [CompilerGeneratedAttribute]
public void set_Antialias(bool value);
    public int get_AntialiasSubpixelDepth();
    public void set_AntialiasSubpixelDepth(int value);
    public float get_BlendPercentage();
    public void set_BlendPercentage(float value);
    [CompilerGeneratedAttribute]
public PixelColorBlendingMode get_ColorBlendingMode();
    [CompilerGeneratedAttribute]
public void set_ColorBlendingMode(PixelColorBlendingMode value);
    [CompilerGeneratedAttribute]
public PixelAlphaCompositionMode get_AlphaCompositionMode();
    [CompilerGeneratedAttribute]
public void set_AlphaCompositionMode(PixelAlphaCompositionMode value);
    public sealed virtual GraphicsOptions DeepClone();
}
internal interface SixLabors.ImageSharp.IComponentShuffle {
    public abstract virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public abstract virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.IDeepCloneable {
    public abstract virtual IDeepCloneable DeepClone();
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.IDeepCloneable`1 {
    public abstract virtual T DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Image : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelTypeInfo <PixelType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    public Configuration Configuration { get; }
    public PixelTypeInfo PixelType { get; }
    public int Width { get; }
    public int Height { get; }
    public ImageMetadata Metadata { get; }
    public Size Size { get; internal set; }
    public Rectangle Bounds { get; }
    protected ImageFrameCollection NonGenericFrameCollection { get; }
    public ImageFrameCollection Frames { get; }
    protected Image(Configuration configuration, PixelTypeInfo pixelType, ImageMetadata metadata, Size size);
    internal Image(Configuration configuration, PixelTypeInfo pixelType, ImageMetadata metadata, int width, int height);
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public PixelTypeInfo get_PixelType();
    public int get_Width();
    public int get_Height();
    [CompilerGeneratedAttribute]
public ImageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(Size value);
    public Rectangle get_Bounds();
    protected abstract virtual ImageFrameCollection get_NonGenericFrameCollection();
    public ImageFrameCollection get_Frames();
    public sealed virtual void Dispose();
    public void Save(Stream stream, IImageEncoder encoder);
    public Task SaveAsync(Stream stream, IImageEncoder encoder, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Image`1<TPixel2> CloneAs();
    [NullableContextAttribute("0")]
public abstract virtual Image`1<TPixel2> CloneAs(Configuration configuration);
    protected void UpdateSize(Size size);
    protected abstract virtual void Dispose(bool disposing);
    internal void EnsureNotDisposed();
    internal abstract virtual void Accept(IImageVisitor visitor);
    internal abstract virtual Task AcceptAsync(IImageVisitorAsync visitor, CancellationToken cancellationToken);
    private static void ThrowObjectDisposedException(Type type);
    internal static Image`1<TPixel> CreateUninitialized(Configuration configuration, int width, int height, ImageMetadata metadata);
    private static IImageFormat InternalDetectFormat(Configuration configuration, Stream stream);
    private static IImageDecoder DiscoverDecoder(DecoderOptions options, Stream stream);
    private static Image`1<TPixel> Decode(DecoderOptions options, Stream stream);
    private static Task`1<Image`1<TPixel>> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    private static Image Decode(DecoderOptions options, Stream stream);
    private static Task`1<Image> DecodeAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    private static ImageInfo InternalIdentify(DecoderOptions options, Stream stream);
    private static Task`1<ImageInfo> InternalIdentifyAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static IImageFormat DetectFormat(ReadOnlySpan`1<byte> buffer);
    public static IImageFormat DetectFormat(DecoderOptions options, ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public static ImageInfo Identify(ReadOnlySpan`1<byte> buffer);
    public static ImageInfo Identify(DecoderOptions options, ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public static Image Load(ReadOnlySpan`1<byte> buffer);
    public static Image Load(DecoderOptions options, ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> Load(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> Load(DecoderOptions options, ReadOnlySpan`1<byte> data);
    public static IImageFormat DetectFormat(string path);
    public static IImageFormat DetectFormat(DecoderOptions options, string path);
    public static Task`1<IImageFormat> DetectFormatAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Image/<DetectFormatAsync>d__58")]
public static Task`1<IImageFormat> DetectFormatAsync(DecoderOptions options, string path, CancellationToken cancellationToken);
    public static ImageInfo Identify(string path);
    public static ImageInfo Identify(DecoderOptions options, string path);
    public static Task`1<ImageInfo> IdentifyAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Image/<IdentifyAsync>d__62")]
public static Task`1<ImageInfo> IdentifyAsync(DecoderOptions options, string path, CancellationToken cancellationToken);
    public static Image Load(string path);
    public static Image Load(DecoderOptions options, string path);
    public static Task`1<Image> LoadAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Image/<LoadAsync>d__66")]
public static Task`1<Image> LoadAsync(DecoderOptions options, string path, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> Load(string path);
    public static Image`1<TPixel> Load(DecoderOptions options, string path);
    [NullableContextAttribute("0")]
public static Task`1<Image`1<TPixel>> LoadAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Image/<LoadAsync>d__70`1")]
public static Task`1<Image`1<TPixel>> LoadAsync(DecoderOptions options, string path, CancellationToken cancellationToken);
    public static IImageFormat DetectFormat(Stream stream);
    public static IImageFormat DetectFormat(DecoderOptions options, Stream stream);
    public static Task`1<IImageFormat> DetectFormatAsync(Stream stream, CancellationToken cancellationToken);
    public static Task`1<IImageFormat> DetectFormatAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    public static ImageInfo Identify(Stream stream);
    public static ImageInfo Identify(DecoderOptions options, Stream stream);
    public static Task`1<ImageInfo> IdentifyAsync(Stream stream, CancellationToken cancellationToken);
    public static Task`1<ImageInfo> IdentifyAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    public static Image Load(Stream stream);
    public static Image Load(DecoderOptions options, Stream stream);
    public static Task`1<Image> LoadAsync(Stream stream, CancellationToken cancellationToken);
    public static Task`1<Image> LoadAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> Load(Stream stream);
    public static Image`1<TPixel> Load(DecoderOptions options, Stream stream);
    [NullableContextAttribute("0")]
public static Task`1<Image`1<TPixel>> LoadAsync(Stream stream, CancellationToken cancellationToken);
    public static Task`1<Image`1<TPixel>> LoadAsync(DecoderOptions options, Stream stream, CancellationToken cancellationToken);
    internal static T WithSeekableStream(DecoderOptions options, Stream stream, Func`2<Stream, T> action);
    [AsyncStateMachineAttribute("SixLabors.ImageSharp.Image/<WithSeekableStreamAsync>d__88`1")]
internal static Task`1<T> WithSeekableStreamAsync(DecoderOptions options, Stream stream, Func`3<Stream, CancellationToken, Task`1<T>> action, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> LoadPixelData(ReadOnlySpan`1<TPixel> data, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> LoadPixelData(ReadOnlySpan`1<byte> data, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> LoadPixelData(Configuration configuration, ReadOnlySpan`1<byte> data, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> LoadPixelData(Configuration configuration, ReadOnlySpan`1<TPixel> data, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Memory`1<TPixel> pixelMemory, int width, int height, ImageMetadata metadata);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Memory`1<TPixel> pixelMemory, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Memory`1<TPixel> pixelMemory, int width, int height);
    public static Image`1<TPixel> WrapMemory(Configuration configuration, IMemoryOwner`1<TPixel> pixelMemoryOwner, int width, int height, ImageMetadata metadata);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, IMemoryOwner`1<TPixel> pixelMemoryOwner, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(IMemoryOwner`1<TPixel> pixelMemoryOwner, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Memory`1<byte> byteMemory, int width, int height, ImageMetadata metadata);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Memory`1<byte> byteMemory, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Memory`1<byte> byteMemory, int width, int height);
    public static Image`1<TPixel> WrapMemory(Configuration configuration, IMemoryOwner`1<byte> byteMemoryOwner, int width, int height, ImageMetadata metadata);
    public static Image`1<TPixel> WrapMemory(Configuration configuration, IMemoryOwner`1<byte> byteMemoryOwner, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(IMemoryOwner`1<byte> byteMemoryOwner, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Void* pointer, int bufferSizeInBytes, int width, int height, ImageMetadata metadata);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Configuration configuration, Void* pointer, int bufferSizeInBytes, int width, int height);
    [NullableContextAttribute("0")]
public static Image`1<TPixel> WrapMemory(Void* pointer, int bufferSizeInBytes, int width, int height);
}
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.Image`1 : Image {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImageFrameCollection`1<TPixel> frames;
    [NullableAttribute("1")]
protected ImageFrameCollection NonGenericFrameCollection { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImageFrameCollection`1<TPixel> Frames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IPixelSource`1<TPixel> PixelSourceUnsafe { get; }
    public TPixel Item { get; public set; }
    [NullableContextAttribute("1")]
public Image`1(Configuration configuration, int width, int height);
    public Image`1(Configuration configuration, int width, int height, TPixel backgroundColor);
    public Image`1(int width, int height, TPixel backgroundColor);
    public Image`1(int width, int height);
    [NullableContextAttribute("1")]
internal Image`1(Configuration configuration, int width, int height, ImageMetadata metadata);
    [NullableContextAttribute("1")]
internal Image`1(Configuration configuration, Buffer2D`1<TPixel> pixelBuffer, ImageMetadata metadata);
    [NullableContextAttribute("1")]
internal Image`1(Configuration configuration, MemoryGroup`1<TPixel> memoryGroup, int width, int height, ImageMetadata metadata);
    internal Image`1(Configuration configuration, int width, int height, TPixel backgroundColor, ImageMetadata metadata);
    [NullableContextAttribute("1")]
internal Image`1(Configuration configuration, ImageMetadata metadata, IEnumerable`1<ImageFrame`1<TPixel>> frames);
    [NullableContextAttribute("1")]
protected virtual ImageFrameCollection get_NonGenericFrameCollection();
    public ImageFrameCollection`1<TPixel> get_Frames();
    private IPixelSource`1<TPixel> get_PixelSourceUnsafe();
    public TPixel get_Item(int x, int y);
    public void set_Item(int x, int y, TPixel value);
    public void ProcessPixelRows(PixelAccessorAction`1<TPixel> processPixels);
    public void ProcessPixelRows(Image`1<TPixel2> image2, PixelAccessorAction`2<TPixel, TPixel2> processPixels);
    public void ProcessPixelRows(Image`1<TPixel2> image2, Image`1<TPixel3> image3, PixelAccessorAction`3<TPixel, TPixel2, TPixel3> processPixels);
    public void CopyPixelDataTo(Span`1<TPixel> destination);
    public void CopyPixelDataTo(Span`1<byte> destination);
    public bool DangerousTryGetSinglePixelMemory(Memory`1& memory);
    public Image`1<TPixel> Clone();
    [NullableContextAttribute("1")]
public Image`1<TPixel> Clone(Configuration configuration);
    public virtual Image`1<TPixel2> CloneAs(Configuration configuration);
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal virtual void Accept(IImageVisitor visitor);
    [NullableContextAttribute("1")]
internal virtual Task AcceptAsync(IImageVisitorAsync visitor, CancellationToken cancellationToken);
    internal void SwapOrCopyPixelsBuffersFrom(Image`1<TPixel> pixelSource);
    private static Size ValidateFramesAndGetSize(IEnumerable`1<ImageFrame`1<TPixel>> frames);
    private void VerifyCoords(int x, int y);
    [NullableContextAttribute("1")]
private static void ThrowArgumentOutOfRangeException(string paramName);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.ImageExtensions : object {
    [ExtensionAttribute]
public static void SaveAsBmp(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsBmpAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsBmpAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsBmp(Image source, string path, BmpEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsBmpAsync(Image source, string path, BmpEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsBmp(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsBmpAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsBmp(Image source, Stream stream, BmpEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsBmpAsync(Image source, Stream stream, BmpEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsGif(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsGifAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsGifAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsGif(Image source, string path, GifEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsGifAsync(Image source, string path, GifEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsGif(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsGifAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsGif(Image source, Stream stream, GifEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsGifAsync(Image source, Stream stream, GifEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsJpeg(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsJpegAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsJpegAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsJpeg(Image source, string path, JpegEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsJpegAsync(Image source, string path, JpegEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsJpeg(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsJpegAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsJpeg(Image source, Stream stream, JpegEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsJpegAsync(Image source, Stream stream, JpegEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPbm(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsPbmAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsPbmAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPbm(Image source, string path, PbmEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsPbmAsync(Image source, string path, PbmEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPbm(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsPbmAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPbm(Image source, Stream stream, PbmEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsPbmAsync(Image source, Stream stream, PbmEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPng(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsPngAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsPngAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPng(Image source, string path, PngEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsPngAsync(Image source, string path, PngEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPng(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsPngAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsPng(Image source, Stream stream, PngEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsPngAsync(Image source, Stream stream, PngEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsQoi(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsQoiAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsQoiAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsQoi(Image source, string path, QoiEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsQoiAsync(Image source, string path, QoiEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsQoi(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsQoiAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsQoi(Image source, Stream stream, QoiEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsQoiAsync(Image source, Stream stream, QoiEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTga(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsTgaAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsTgaAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTga(Image source, string path, TgaEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsTgaAsync(Image source, string path, TgaEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTga(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsTgaAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTga(Image source, Stream stream, TgaEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsTgaAsync(Image source, Stream stream, TgaEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTiff(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsTiffAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsTiffAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTiff(Image source, string path, TiffEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsTiffAsync(Image source, string path, TiffEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTiff(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsTiffAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsTiff(Image source, Stream stream, TiffEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsTiffAsync(Image source, Stream stream, TiffEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsWebp(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsWebpAsync(Image source, string path);
    [ExtensionAttribute]
public static Task SaveAsWebpAsync(Image source, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsWebp(Image source, string path, WebpEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsWebpAsync(Image source, string path, WebpEncoder encoder, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsWebp(Image source, Stream stream);
    [ExtensionAttribute]
public static Task SaveAsWebpAsync(Image source, Stream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void SaveAsWebp(Image source, Stream stream, WebpEncoder encoder);
    [ExtensionAttribute]
public static Task SaveAsWebpAsync(Image source, Stream stream, WebpEncoder encoder, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Save(Image source, string path);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task SaveAsync(Image source, string path, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Save(Image source, string path, IImageEncoder encoder);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("SixLabors.ImageSharp.ImageExtensions/<SaveAsync>d__84")]
[ExtensionAttribute]
public static Task SaveAsync(Image source, string path, IImageEncoder encoder, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Save(Image source, Stream stream, IImageFormat format);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task SaveAsync(Image source, Stream stream, IImageFormat format, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToBase64String(Image source, IImageFormat format);
    [ExtensionAttribute]
internal static Buffer2D`1<TPixel> GetRootFramePixelBuffer(Image`1<TPixel> image);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.ImageFormatException : Exception {
    internal ImageFormatException(string errorMessage);
    internal ImageFormatException(string errorMessage, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.ImageFrame : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageFrameMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    public int Width { get; private set; }
    public int Height { get; private set; }
    public ImageFrameMetadata Metadata { get; }
    public Configuration Configuration { get; }
    protected ImageFrame(Configuration configuration, int width, int height, ImageFrameMetadata metadata);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(int value);
    [CompilerGeneratedAttribute]
public ImageFrameMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    public Size Size();
    public Rectangle Bounds();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    [NullableContextAttribute("0")]
internal abstract virtual void CopyPixelsTo(MemoryGroup`1<TDestinationPixel> destination);
    internal void UpdateSize(Size size);
    [NullableContextAttribute("0")]
internal static ImageFrame`1<TPixel> LoadPixelData(Configuration configuration, ReadOnlySpan`1<byte> data, int width, int height);
    [NullableContextAttribute("0")]
internal static ImageFrame`1<TPixel> LoadPixelData(Configuration configuration, ReadOnlySpan`1<TPixel> data, int width, int height);
}
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.ImageFrame`1 : ImageFrame {
    private bool isDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Buffer2D`1<TPixel> <PixelBuffer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Buffer2D`1<TPixel> PixelBuffer { get; }
    public TPixel Item { get; public set; }
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, Size size);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, int width, int height);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, Size size, ImageFrameMetadata metadata);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, int width, int height, ImageFrameMetadata metadata);
    internal ImageFrame`1(Configuration configuration, int width, int height, TPixel backgroundColor);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, int width, int height, TPixel backgroundColor, ImageFrameMetadata metadata);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, int width, int height, MemoryGroup`1<TPixel> memorySource);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, int width, int height, MemoryGroup`1<TPixel> memorySource, ImageFrameMetadata metadata);
    [NullableContextAttribute("1")]
internal ImageFrame`1(Configuration configuration, ImageFrame`1<TPixel> source);
    [CompilerGeneratedAttribute]
public sealed virtual Buffer2D`1<TPixel> get_PixelBuffer();
    public TPixel get_Item(int x, int y);
    public void set_Item(int x, int y, TPixel value);
    public void ProcessPixelRows(PixelAccessorAction`1<TPixel> processPixels);
    public void ProcessPixelRows(ImageFrame`1<TPixel2> frame2, PixelAccessorAction`2<TPixel, TPixel2> processPixels);
    public void ProcessPixelRows(ImageFrame`1<TPixel2> frame2, ImageFrame`1<TPixel3> frame3, PixelAccessorAction`3<TPixel, TPixel2, TPixel3> processPixels);
    public void CopyPixelDataTo(Span`1<TPixel> destination);
    public void CopyPixelDataTo(Span`1<byte> destination);
    public bool DangerousTryGetSinglePixelMemory(Memory`1& memory);
    internal TPixel& GetPixelReference(int x, int y);
    internal void CopyTo(Buffer2D`1<TPixel> target);
    internal void SwapOrCopyPixelsBufferFrom(ImageFrame`1<TPixel> pixelSource);
    protected virtual void Dispose(bool disposing);
    internal virtual void CopyPixelsTo(MemoryGroup`1<TDestinationPixel> destination);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal ImageFrame`1<TPixel> Clone();
    [NullableContextAttribute("1")]
internal ImageFrame`1<TPixel> Clone(Configuration configuration);
    internal ImageFrame`1<TPixel2> CloneAs();
    internal ImageFrame`1<TPixel2> CloneAs(Configuration configuration);
    internal void Clear(TPixel value);
    private void VerifyCoords(int x, int y);
    [NullableContextAttribute("1")]
private static void ThrowArgumentOutOfRangeException(string paramName);
    [CompilerGeneratedAttribute]
private void <CopyPixelsTo>b__26_1(ReadOnlySpan`1<TPixel> s, Span`1<TDestinationPixel> d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class SixLabors.ImageSharp.ImageFrameCollection : object {
    private bool isDisposed;
    public int Count { get; }
    public ImageFrame RootFrame { get; }
    protected ImageFrame NonGenericRootFrame { get; }
    public ImageFrame Item { get; }
    public abstract virtual int get_Count();
    public ImageFrame get_RootFrame();
    protected abstract virtual ImageFrame get_NonGenericRootFrame();
    public ImageFrame get_Item(int index);
    public abstract virtual int IndexOf(ImageFrame frame);
    public ImageFrame InsertFrame(int index, ImageFrame source);
    public ImageFrame AddFrame(ImageFrame source);
    public abstract virtual void RemoveFrame(int index);
    public abstract virtual bool Contains(ImageFrame frame);
    public abstract virtual void MoveFrame(int sourceIndex, int destinationIndex);
    public Image ExportFrame(int index);
    public Image CloneFrame(int index);
    public ImageFrame CreateFrame();
    public ImageFrame CreateFrame(Color backgroundColor);
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator`1<ImageFrame> System.Collections.Generic.IEnumerable<SixLabors.ImageSharp.ImageFrame>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected void EnsureNotDisposed();
    protected abstract virtual void Dispose(bool disposing);
    protected abstract virtual IEnumerator`1<ImageFrame> NonGenericGetEnumerator();
    protected abstract virtual ImageFrame NonGenericGetFrame(int index);
    protected abstract virtual ImageFrame NonGenericInsertFrame(int index, ImageFrame source);
    protected abstract virtual ImageFrame NonGenericAddFrame(ImageFrame source);
    protected abstract virtual Image NonGenericExportFrame(int index);
    protected abstract virtual Image NonGenericCloneFrame(int index);
    protected abstract virtual ImageFrame NonGenericCreateFrame();
    protected abstract virtual ImageFrame NonGenericCreateFrame(Color backgroundColor);
    private static void ThrowObjectDisposedException(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.ImageFrameCollection`1 : ImageFrameCollection {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ImageFrame`1<TPixel>> frames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Image`1<TPixel> parent;
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImageFrame`1<TPixel> RootFrame { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImageFrame`1<TPixel> RootFrameUnsafe { get; }
    protected ImageFrame NonGenericRootFrame { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImageFrame`1<TPixel> Item { get; }
    [NullableContextAttribute("0")]
internal ImageFrameCollection`1(Image`1<TPixel> parent, int width, int height, TPixel backgroundColor);
    internal ImageFrameCollection`1(Image`1<TPixel> parent, int width, int height, MemoryGroup`1<TPixel> memorySource);
    internal ImageFrameCollection`1(Image`1<TPixel> parent, IEnumerable`1<ImageFrame`1<TPixel>> frames);
    public virtual int get_Count();
    public ImageFrame`1<TPixel> get_RootFrame();
    internal ImageFrame`1<TPixel> get_RootFrameUnsafe();
    protected virtual ImageFrame get_NonGenericRootFrame();
    public ImageFrame`1<TPixel> get_Item(int index);
    public virtual int IndexOf(ImageFrame frame);
    public int IndexOf(ImageFrame`1<TPixel> frame);
    public ImageFrame`1<TPixel> InsertFrame(int index, ImageFrame`1<TPixel> source);
    public ImageFrame`1<TPixel> AddFrame(ImageFrame`1<TPixel> source);
    [NullableContextAttribute("0")]
public ImageFrame`1<TPixel> AddFrame(ReadOnlySpan`1<TPixel> source);
    public ImageFrame`1<TPixel> AddFrame(TPixel[] source);
    public virtual void RemoveFrame(int index);
    public virtual bool Contains(ImageFrame frame);
    public bool Contains(ImageFrame`1<TPixel> frame);
    public virtual void MoveFrame(int sourceIndex, int destinationIndex);
    public Image`1<TPixel> ExportFrame(int index);
    public Image`1<TPixel> CloneFrame(int index);
    public ImageFrame`1<TPixel> CreateFrame();
    protected virtual IEnumerator`1<ImageFrame> NonGenericGetEnumerator();
    protected virtual ImageFrame NonGenericGetFrame(int index);
    protected virtual ImageFrame NonGenericInsertFrame(int index, ImageFrame source);
    protected virtual ImageFrame NonGenericAddFrame(ImageFrame source);
    protected virtual Image NonGenericExportFrame(int index);
    protected virtual Image NonGenericCloneFrame(int index);
    protected virtual ImageFrame NonGenericCreateFrame(Color backgroundColor);
    protected virtual ImageFrame NonGenericCreateFrame();
    [NullableContextAttribute("0")]
public ImageFrame`1<TPixel> CreateFrame(TPixel backgroundColor);
    public sealed virtual IEnumerator`1<ImageFrame`1<TPixel>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ValidateFrame(ImageFrame`1<TPixel> frame);
    protected virtual void Dispose(bool disposing);
    private ImageFrame`1<TPixel> CopyNonCompatibleFrame(ImageFrame source);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.ImageFrameCollectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ImageFrame`1<TPixel>> AsEnumerable(ImageFrameCollection`1<TPixel> source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImageFrameCollection`1<TPixel> source, Func`2<ImageFrame`1<TPixel>, TResult> selector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.ImageInfo : object {
    [CompilerGeneratedAttribute]
private PixelTypeInfo <PixelType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ImageFrameMetadata> <FrameMetadataCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    public PixelTypeInfo PixelType { get; }
    public int Width { get; }
    public int Height { get; }
    public ImageMetadata Metadata { get; }
    public IReadOnlyList`1<ImageFrameMetadata> FrameMetadataCollection { get; }
    public Size Size { get; internal set; }
    public Rectangle Bounds { get; }
    public ImageInfo(PixelTypeInfo pixelType, Size size, ImageMetadata metadata);
    public ImageInfo(PixelTypeInfo pixelType, Size size, ImageMetadata metadata, IReadOnlyList`1<ImageFrameMetadata> frameMetadataCollection);
    [CompilerGeneratedAttribute]
public PixelTypeInfo get_PixelType();
    public int get_Width();
    public int get_Height();
    [CompilerGeneratedAttribute]
public ImageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ImageFrameMetadata> get_FrameMetadataCollection();
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(Size value);
    public Rectangle get_Bounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.ImageProcessingException : Exception {
    public ImageProcessingException(string errorMessage);
    public ImageProcessingException(string errorMessage, Exception innerException);
}
public class SixLabors.ImageSharp.IndexedImageFrame`1 : object {
    [NullableAttribute("1")]
private Buffer2D`1<byte> pixelBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryOwner`1<TPixel> paletteOwner;
    private bool isDisposed;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<TPixel> <Palette>k__BackingField;
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    public int Width { get; }
    public int Height { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    [NullableAttribute("1")]
private Buffer2D`1<byte> SixLabors.ImageSharp.Advanced.IPixelSource.PixelBuffer { get; }
    internal IndexedImageFrame`1(Configuration configuration, int width, int height, ReadOnlyMemory`1<TPixel> palette);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<TPixel> get_Palette();
    [NullableContextAttribute("1")]
private sealed virtual override Buffer2D`1<byte> SixLabors.ImageSharp.Advanced.IPixelSource.get_PixelBuffer();
    public ReadOnlySpan`1<byte> DangerousGetRowSpan(int rowIndex);
    public Span`1<byte> GetWritablePixelRowSpanUnsafe(int rowIndex);
    public sealed virtual void Dispose();
}
internal static class SixLabors.ImageSharp.InliningOptions : object {
    public static MethodImplOptions AlwaysInline;
    public static MethodImplOptions HotPath;
    public static MethodImplOptions ShortMethod;
    public static MethodImplOptions ColdPath;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.InvalidImageContentException : ImageFormatException {
    public InvalidImageContentException(string errorMessage);
    public InvalidImageContentException(string errorMessage, Exception innerException);
    internal InvalidImageContentException(Size size, InvalidMemoryOperationException memoryException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.IO.BufferedReadStream : Stream {
    private CancellationToken cancellationToken;
    private int maxBufferIndex;
    private Byte[] readBuffer;
    private MemoryHandle readBufferHandle;
    [NullableAttribute("0")]
private Byte* pinnedReadBuffer;
    private int readBufferIndex;
    private long readerPosition;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private int <EofHitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    public int EofHitCount { get; private set; }
    public int BufferSize { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long RemainingBytes { get; }
    public Stream BaseStream { get; }
    public BufferedReadStream(Configuration configuration, Stream stream, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public int get_EofHitCount();
    [CompilerGeneratedAttribute]
private void set_EofHitCount(int value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public long get_RemainingBytes();
    [CompilerGeneratedAttribute]
public Stream get_BaseStream();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private bool IsInReadBuffer(long newPosition, Int64& index);
    private void FillReadBuffer();
    [NullableContextAttribute("0")]
private int ReadToBufferViaCopyFast(Span`1<byte> buffer);
    private int ReadToBufferViaCopyFast(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
private int ReadToBufferViaCopySlow(Span`1<byte> buffer);
    private int ReadToBufferViaCopySlow(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
private int ReadToBufferDirectSlow(Span`1<byte> buffer);
    private int ReadToBufferDirectSlow(Byte[] buffer, int offset, int count);
    private int GetCopyCount(int count);
    private void CopyBytes(Byte[] buffer, int offset, int count);
    private void CheckEof(int read);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.IO.ChunkedMemoryStream : Stream {
    private MemoryAllocator allocator;
    [NullableAttribute("2")]
private MemoryChunk memoryChunk;
    private int chunkCount;
    private int allocatorCapacity;
    private bool isDisposed;
    [NullableAttribute("2")]
private MemoryChunk writeChunk;
    private int writeOffset;
    [NullableAttribute("2")]
private MemoryChunk readChunk;
    private int readOffset;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ChunkedMemoryStream(MemoryAllocator allocator);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
private int ReadImpl(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
private void WriteImpl(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public Byte[] ToArray();
    public void WriteTo(Stream stream);
    private void EnsureNotDisposed();
    private static void ThrowDisposed();
    private static void ThrowArgumentOutOfRange(string value);
    private static void ThrowInvalidSeek();
    private MemoryChunk AllocateMemoryChunk();
    [NullableContextAttribute("2")]
private static void ReleaseMemoryChunks(MemoryChunk chunk);
    private static int GetChunkSize(int i);
}
[NullableContextAttribute("1")]
internal interface SixLabors.ImageSharp.IO.IFileSystem {
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual Stream OpenReadAsynchronous(string path);
    public abstract virtual Stream Create(string path);
    public abstract virtual Stream CreateAsynchronous(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.IO.LocalFileSystem : object {
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual Stream OpenReadAsynchronous(string path);
    public sealed virtual Stream Create(string path);
    public sealed virtual Stream CreateAsynchronous(string path);
}
internal interface SixLabors.ImageSharp.IPad3Shuffle4 {
}
internal interface SixLabors.ImageSharp.IShuffle3 {
}
internal interface SixLabors.ImageSharp.IShuffle4 {
}
internal interface SixLabors.ImageSharp.IShuffle4Slice3 {
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.LongRational : ValueType {
    [CompilerGeneratedAttribute]
private long <Numerator>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Denominator>k__BackingField;
    public long Numerator { get; }
    public long Denominator { get; }
    public bool IsIndeterminate { get; }
    public bool IsInteger { get; }
    public bool IsNegativeInfinity { get; }
    public bool IsPositiveInfinity { get; }
    public bool IsZero { get; }
    public LongRational(long numerator, long denominator);
    [CompilerGeneratedAttribute]
public long get_Numerator();
    [CompilerGeneratedAttribute]
public long get_Denominator();
    public bool get_IsIndeterminate();
    public bool get_IsInteger();
    public bool get_IsNegativeInfinity();
    public bool get_IsPositiveInfinity();
    public bool get_IsZero();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LongRational other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    public static LongRational FromDouble(double value, bool bestPrecision);
    private static long GreatestCommonDivisor(long left, long right);
    public LongRational Simplify();
}
public static class SixLabors.ImageSharp.Matrix3x2Extensions : object {
    public static Matrix3x2 CreateTranslation(PointF position);
    public static Matrix3x2 CreateScale(float xScale, float yScale, PointF centerPoint);
    public static Matrix3x2 CreateScale(SizeF scales);
    public static Matrix3x2 CreateScale(SizeF scales, PointF centerPoint);
    public static Matrix3x2 CreateScale(float scale, PointF centerPoint);
    public static Matrix3x2 CreateSkewDegrees(float degreesX, float degreesY);
    public static Matrix3x2 CreateSkew(float radiansX, float radiansY, PointF centerPoint);
    public static Matrix3x2 CreateSkewDegrees(float degreesX, float degreesY, PointF centerPoint);
    public static Matrix3x2 CreateRotationDegrees(float degrees);
    public static Matrix3x2 CreateRotation(float radians, PointF centerPoint);
    public static Matrix3x2 CreateRotationDegrees(float degrees, PointF centerPoint);
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Memory.AllocationOptions : Enum {
    public int value__;
    public static AllocationOptions None;
    public static AllocationOptions Clean;
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Memory.AllocationOptionsExtensions : object {
    [ExtensionAttribute]
public static bool Has(AllocationOptions options, AllocationOptions flag);
}
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.Memory.Buffer2D`1 : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MemoryGroup`1<T> <FastMemoryGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public int Width { get; private set; }
    public int Height { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IMemoryGroup`1<T> MemoryGroup { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal MemoryGroup`1<T> FastMemoryGroup { get; private set; }
    internal bool IsDisposed { get; private set; }
    public T& Item { get; }
    internal Buffer2D`1(MemoryGroup`1<T> memoryGroup, int width, int height);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(int value);
    public IMemoryGroup`1<T> get_MemoryGroup();
    [CompilerGeneratedAttribute]
internal MemoryGroup`1<T> get_FastMemoryGroup();
    [CompilerGeneratedAttribute]
private void set_FastMemoryGroup(MemoryGroup`1<T> value);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public T& get_Item(int x, int y);
    public sealed virtual void Dispose();
    public Span`1<T> DangerousGetRowSpan(int y);
    internal bool DangerousTryGetPaddedRowSpan(int y, int padding, Span`1& paddedSpan);
    internal T& GetElementUnsafe(int x, int y);
    internal Memory`1<T> GetSafeRowMemory(int y);
    internal Span`1<T> DangerousGetSingleSpan();
    internal Memory`1<T> DangerousGetSingleMemory();
    internal static bool SwapOrCopyContent(Buffer2D`1<T> destination, Buffer2D`1<T> source);
    private void ThrowYOutOfRangeException(int y);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Memory.Buffer2DExtensions : object {
    [ExtensionAttribute]
public static IMemoryGroup`1<T> GetMemoryGroup(Buffer2D`1<T> buffer);
    [ExtensionAttribute]
internal static void DangerousCopyColumns(Buffer2D`1<T> buffer, int sourceIndex, int destIndex, int columnCount);
    [ExtensionAttribute]
internal static Rectangle FullRectangle(Buffer2D`1<T> buffer);
    [ExtensionAttribute]
internal static Buffer2DRegion`1<T> GetRegion(Buffer2D`1<T> buffer, Rectangle rectangle);
    [ExtensionAttribute]
internal static Buffer2DRegion`1<T> GetRegion(Buffer2D`1<T> buffer, int x, int y, int width, int height);
    [ExtensionAttribute]
internal static Buffer2DRegion`1<T> GetRegion(Buffer2D`1<T> buffer);
    [ExtensionAttribute]
internal static Size Size(Buffer2D`1<T> buffer);
    [ExtensionAttribute]
internal static Rectangle Bounds(Buffer2D`1<T> buffer);
    [ConditionalAttribute("DEBUG")]
private static void CheckColumnRegionsDoNotOverlap(Buffer2D`1<T> buffer, int sourceIndex, int destIndex, int columnCount);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class SixLabors.ImageSharp.Memory.Buffer2DRegion`1 : ValueType {
    [CompilerGeneratedAttribute]
private Rectangle <Rectangle>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Buffer2D`1<T> <Buffer>k__BackingField;
    public Rectangle Rectangle { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Buffer2D`1<T> Buffer { get; }
    public int Width { get; }
    public int Height { get; }
    public int Stride { get; }
    internal Size Size { get; }
    internal bool IsFullBufferArea { get; }
    internal T& Item { get; }
    public Buffer2DRegion`1(Buffer2D`1<T> buffer, Rectangle rectangle);
    public Buffer2DRegion`1(Buffer2D`1<T> buffer);
    [CompilerGeneratedAttribute]
public Rectangle get_Rectangle();
    [CompilerGeneratedAttribute]
public Buffer2D`1<T> get_Buffer();
    public int get_Width();
    public int get_Height();
    public int get_Stride();
    internal Size get_Size();
    internal bool get_IsFullBufferArea();
    internal T& get_Item(int x, int y);
    public Span`1<T> DangerousGetRowSpan(int y);
    public Buffer2DRegion`1<T> GetSubRegion(int x, int y, int width, int height);
    public Buffer2DRegion`1<T> GetSubRegion(Rectangle rectangle);
    internal T& GetReferenceToOrigin();
    internal void Clear();
    internal void Fill(T value);
}
internal class SixLabors.ImageSharp.Memory.ByteMemoryManager`1 : MemoryManager`1<T> {
    private Memory`1<byte> memory;
    public ByteMemoryManager`1(Memory`1<byte> memory);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
internal class SixLabors.ImageSharp.Memory.ByteMemoryOwner`1 : object {
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> memoryOwner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ByteMemoryManager`1<T> memoryManager;
    private bool disposedValue;
    public Memory`1<T> Memory { get; }
    [NullableContextAttribute("1")]
public ByteMemoryOwner`1(IMemoryOwner`1<byte> memoryOwner);
    public sealed virtual Memory`1<T> get_Memory();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public interface SixLabors.ImageSharp.Memory.IMemoryGroup`1 {
    public int BufferLength { get; }
    public long TotalLength { get; }
    public bool IsValid { get; }
    public abstract virtual int get_BufferLength();
    public abstract virtual long get_TotalLength();
    public abstract virtual bool get_IsValid();
    public abstract virtual MemoryGroupEnumerator`1<T> GetEnumerator();
}
internal class SixLabors.ImageSharp.Memory.Internals.BasicArrayBuffer`1 : ManagedBufferBase`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private T[] <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public T[] Array { get; }
    public int Length { get; }
    public BasicArrayBuffer`1(T[] array, int length);
    public BasicArrayBuffer`1(T[] array);
    [CompilerGeneratedAttribute]
public T[] get_Array();
    [CompilerGeneratedAttribute]
public int get_Length();
    public virtual Span`1<T> GetSpan();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("1")]
protected virtual object GetPinnableObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Memory.Internals.Gen2GcCallback : CriticalFinalizerObject {
    [NullableAttribute("2")]
private Func`1<bool> callback0;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, bool> callback1;
    private GCHandle weakTargetObj;
    private Gen2GcCallback(Func`1<bool> callback);
    private Gen2GcCallback(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
    public static void Register(Func`1<bool> callback);
    public static void Register(Func`2<object, bool> callback, object targetObj);
}
internal interface SixLabors.ImageSharp.Memory.Internals.IRefCounted {
    public abstract virtual void AddRef();
    public abstract virtual void ReleaseRef();
}
internal abstract class SixLabors.ImageSharp.Memory.Internals.ManagedBufferBase`1 : MemoryManager`1<T> {
    private GCHandle pinHandle;
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    [NullableContextAttribute("1")]
protected abstract virtual object GetPinnableObject();
}
internal abstract class SixLabors.ImageSharp.Memory.Internals.RefCountedMemoryLifetimeGuard : object {
    private int refCount;
    private int disposed;
    private int released;
    [NullableAttribute("2")]
private string allocationStackTrace;
    public bool IsDisposed { get; }
    protected virtual override void Finalize();
    public bool get_IsDisposed();
    public void AddRef();
    public void ReleaseRef();
    public sealed virtual void Dispose();
    protected abstract virtual void Release();
    private void ReleaseRef(bool finalizing);
}
internal class SixLabors.ImageSharp.Memory.Internals.SharedArrayPoolBuffer`1 : ManagedBufferBase`1<T> {
    private int lengthInBytes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LifetimeGuard<T> lifetimeGuard;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Array>k__BackingField;
    [NullableAttribute("2")]
public Byte[] Array { get; private set; }
    public SharedArrayPoolBuffer`1(int lengthInElements);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Array();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Array(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    [NullableContextAttribute("1")]
protected virtual object GetPinnableObject();
    public sealed virtual void AddRef();
    public sealed virtual void ReleaseRef();
    [ConditionalAttribute("DEBUG")]
[MemberNotNullAttribute("Array")]
private void CheckDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Memory.Internals.UniformUnmanagedMemoryPool : CriticalFinalizerObject {
    private static int minTrimPeriodMilliseconds;
    private static List`1<WeakReference`1<UniformUnmanagedMemoryPool>> AllPools;
    [NullableAttribute("2")]
private static Timer trimTimer;
    private static Stopwatch Stopwatch;
    private TrimSettings trimSettings;
    private UnmanagedMemoryHandle[] buffers;
    private int index;
    private long lastTrimTimestamp;
    private int finalized;
    [CompilerGeneratedAttribute]
private int <BufferLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public int BufferLength { get; }
    public int Capacity { get; }
    private bool Finalized { get; }
    public UniformUnmanagedMemoryPool(int bufferLength, int capacity);
    public UniformUnmanagedMemoryPool(int bufferLength, int capacity, TrimSettings trimSettings);
    private static UniformUnmanagedMemoryPool();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public int get_BufferLength();
    [CompilerGeneratedAttribute]
public int get_Capacity();
    private bool get_Finalized();
    public UnmanagedMemoryHandle Rent();
    [NullableContextAttribute("2")]
public UnmanagedMemoryHandle[] Rent(int bufferCount);
    public bool Return(UnmanagedMemoryHandle bufferHandle);
    [NullableContextAttribute("0")]
public bool Return(Span`1<UnmanagedMemoryHandle> bufferHandles);
    public void Release();
    [ConditionalAttribute("DEBUG")]
private void DebugThrowInvalidReturn();
    private static void UpdateTimer(TrimSettings settings, UniformUnmanagedMemoryPool pool);
    private static void TimerCallback();
    private bool Trim();
    private void TrimAll(UnmanagedMemoryHandle[] buffersLocal);
    private bool TrimLowPressure(UnmanagedMemoryHandle[] buffersLocal);
    private bool IsHighMemoryPressure();
    [NullableContextAttribute("0")]
public UnmanagedBuffer`1<T> CreateGuardedBuffer(UnmanagedMemoryHandle handle, int lengthInElements, bool clear);
    public RefCountedMemoryLifetimeGuard CreateGroupLifetimeGuard(UnmanagedMemoryHandle[] handles);
}
internal class SixLabors.ImageSharp.Memory.Internals.UnmanagedBuffer`1 : MemoryManager`1<T> {
    private int lengthInElements;
    [NullableAttribute("1")]
private UnmanagedBufferLifetimeGuard lifetimeGuard;
    private int disposed;
    public Void* Pointer { get; }
    [NullableContextAttribute("1")]
public UnmanagedBuffer`1(int lengthInElements, UnmanagedBufferLifetimeGuard lifetimeGuard);
    public Void* get_Pointer();
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    protected virtual void Dispose(bool disposing);
    public virtual void Unpin();
    public sealed virtual void AddRef();
    public sealed virtual void ReleaseRef();
    public static UnmanagedBuffer`1<T> Allocate(int lengthInElements);
}
internal abstract class SixLabors.ImageSharp.Memory.Internals.UnmanagedBufferLifetimeGuard : RefCountedMemoryLifetimeGuard {
    private UnmanagedMemoryHandle handle;
    public UnmanagedMemoryHandle& Handle { get; }
    protected UnmanagedBufferLifetimeGuard(UnmanagedMemoryHandle handle);
    public UnmanagedMemoryHandle& get_Handle();
}
internal class SixLabors.ImageSharp.Memory.Internals.UnmanagedMemoryHandle : ValueType {
    private static int MaxAllocationAttempts;
    private static int totalOutstandingHandles;
    private static long totalOomRetries;
    [NullableAttribute("2")]
private static object lowMemoryMonitor;
    public static UnmanagedMemoryHandle NullHandle;
    private IntPtr handle;
    private int lengthInBytes;
    public IntPtr Handle { get; }
    public bool IsInvalid { get; }
    public bool IsValid { get; }
    public Void* Pointer { get; }
    internal static int TotalOutstandingHandles { get; }
    internal static long TotalOomRetries { get; }
    private UnmanagedMemoryHandle(IntPtr handle, int lengthInBytes);
    public IntPtr get_Handle();
    public bool get_IsInvalid();
    public bool get_IsValid();
    public Void* get_Pointer();
    internal static int get_TotalOutstandingHandles();
    internal static long get_TotalOomRetries();
    public static bool op_Equality(UnmanagedMemoryHandle a, UnmanagedMemoryHandle b);
    public static bool op_Inequality(UnmanagedMemoryHandle a, UnmanagedMemoryHandle b);
    public static UnmanagedMemoryHandle Allocate(int lengthInBytes);
    private static IntPtr AllocateHandle(int lengthInBytes);
    public void Free();
    public sealed virtual bool Equals(UnmanagedMemoryHandle other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.Memory.InvalidMemoryOperationException : InvalidOperationException {
    [NullableContextAttribute("1")]
public InvalidMemoryOperationException(string message);
    [DoesNotReturnAttribute]
internal static void ThrowNegativeAllocationException(long length);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidAlignmentException(long alignment);
    [DoesNotReturnAttribute]
internal static void ThrowAllocationOverLimitException(ulong length, long limit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Memory.MemoryAllocator : object {
    private static int OneGigabyte;
    [CompilerGeneratedAttribute]
private static MemoryAllocator <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryGroupAllocationLimitBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SingleBufferAllocationLimitBytes>k__BackingField;
    public static MemoryAllocator Default { get; }
    internal long MemoryGroupAllocationLimitBytes { get; private set; }
    internal int SingleBufferAllocationLimitBytes { get; private set; }
    private static MemoryAllocator();
    [CompilerGeneratedAttribute]
public static MemoryAllocator get_Default();
    [CompilerGeneratedAttribute]
internal long get_MemoryGroupAllocationLimitBytes();
    [CompilerGeneratedAttribute]
private void set_MemoryGroupAllocationLimitBytes(long value);
    [CompilerGeneratedAttribute]
internal int get_SingleBufferAllocationLimitBytes();
    [CompilerGeneratedAttribute]
private void set_SingleBufferAllocationLimitBytes(int value);
    protected internal abstract virtual int GetBufferCapacityInBytes();
    public static MemoryAllocator Create();
    public static MemoryAllocator Create(MemoryAllocatorOptions options);
    [NullableContextAttribute("0")]
public abstract virtual IMemoryOwner`1<T> Allocate(int length, AllocationOptions options);
    public virtual void ReleaseRetainedResources();
    [NullableContextAttribute("0")]
internal MemoryGroup`1<T> AllocateGroup(long totalLength, int bufferAlignment, AllocationOptions options);
    [NullableContextAttribute("0")]
internal virtual MemoryGroup`1<T> AllocateGroupCore(long totalLengthInElements, long totalLengthInBytes, int bufferAlignment, AllocationOptions options);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Memory.MemoryAllocatorExtensions : object {
    [ExtensionAttribute]
public static Buffer2D`1<T> Allocate2D(MemoryAllocator memoryAllocator, int width, int height, bool preferContiguosImageBuffers, AllocationOptions options);
    [ExtensionAttribute]
public static Buffer2D`1<T> Allocate2D(MemoryAllocator memoryAllocator, int width, int height, AllocationOptions options);
    [ExtensionAttribute]
public static Buffer2D`1<T> Allocate2D(MemoryAllocator memoryAllocator, Size size, bool preferContiguosImageBuffers, AllocationOptions options);
    [ExtensionAttribute]
public static Buffer2D`1<T> Allocate2D(MemoryAllocator memoryAllocator, Size size, AllocationOptions options);
    [ExtensionAttribute]
internal static Buffer2D`1<T> Allocate2DOveraligned(MemoryAllocator memoryAllocator, int width, int height, int alignmentMultiplier, AllocationOptions options);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IMemoryOwner`1<byte> AllocatePaddedPixelRowBuffer(MemoryAllocator memoryAllocator, int width, int pixelSizeInBytes, int paddingInBytes);
}
public class SixLabors.ImageSharp.Memory.MemoryAllocatorOptions : ValueType {
    private Nullable`1<int> maximumPoolSizeMegabytes;
    private Nullable`1<int> allocationLimitMegabytes;
    public Nullable`1<int> MaximumPoolSizeMegabytes { get; public set; }
    public Nullable`1<int> AllocationLimitMegabytes { get; public set; }
    public Nullable`1<int> get_MaximumPoolSizeMegabytes();
    public void set_MaximumPoolSizeMegabytes(Nullable`1<int> value);
    public Nullable`1<int> get_AllocationLimitMegabytes();
    public void set_AllocationLimitMegabytes(Nullable`1<int> value);
}
[DefaultMemberAttribute("Item")]
internal abstract class SixLabors.ImageSharp.Memory.MemoryGroup`1 : object {
    private static int ElementSize;
    private MemoryGroupSpanCache memoryGroupSpanCache;
    [CompilerGeneratedAttribute]
private int <BufferLength>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MemoryGroupView`1<T> <View>k__BackingField;
    public int Count { get; }
    public int BufferLength { get; }
    public long TotalLength { get; }
    public bool IsValid { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MemoryGroupView`1<T> View { get; private set; }
    public Memory`1<T> Item { get; }
    private MemoryGroup`1(int bufferLength, long totalLength);
    private static MemoryGroup`1();
    public abstract virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual int get_BufferLength();
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalLength();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public MemoryGroupView`1<T> get_View();
    [CompilerGeneratedAttribute]
private void set_View(MemoryGroupView`1<T> value);
    public abstract virtual Memory`1<T> get_Item(int index);
    public abstract virtual void Dispose();
    public abstract virtual MemoryGroupEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<Memory`1<T>> System.Collections.Generic.IEnumerable<System.Memory<T>>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public static MemoryGroup`1<T> Allocate(MemoryAllocator allocator, long totalLengthInElements, int bufferAlignmentInElements, AllocationOptions options);
    public static MemoryGroup`1<T> CreateContiguous(IMemoryOwner`1<T> buffer, bool clear);
    [NullableContextAttribute("1")]
public static bool TryAllocate(UniformUnmanagedMemoryPool pool, long totalLengthInElements, int bufferAlignmentInElements, AllocationOptions options, MemoryGroup`1& memoryGroup);
    public static MemoryGroup`1<T> Wrap(Memory`1[] source);
    public static MemoryGroup`1<T> Wrap(IMemoryOwner`1[] source);
    public Span`1<T> GetRowSpanCoreUnsafe(int y, int width);
    public Span`1<T> GetRemainingSliceOfBuffer(long start);
    public static bool CanSwapContent(MemoryGroup`1<T> target, MemoryGroup`1<T> source);
    public virtual void RecreateViewAfterSwap();
    public virtual void IncreaseRefCounts();
    public virtual void DecreaseRefCounts();
    private void GetMultiBufferPosition(int y, int width, Int32& bufferIdx, Int32& bufferStart);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[EditorBrowsableAttribute("1")]
public class SixLabors.ImageSharp.Memory.MemoryGroupEnumerator`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryGroup`1<T> memoryGroup;
    private int count;
    private int index;
    public Memory`1<T> Current { get; }
    internal MemoryGroupEnumerator`1(Owned<T> memoryGroup);
    internal MemoryGroupEnumerator`1(Consumed<T> memoryGroup);
    internal MemoryGroupEnumerator`1(MemoryGroupView`1<T> memoryGroup);
    public Memory`1<T> get_Current();
    public bool MoveNext();
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Memory.MemoryGroupExtensions : object {
    [ExtensionAttribute]
internal static void Fill(IMemoryGroup`1<T> group, T value);
    [ExtensionAttribute]
internal static void Clear(IMemoryGroup`1<T> group);
    [ExtensionAttribute]
internal static Memory`1<T> GetBoundedMemorySlice(IMemoryGroup`1<T> group, long start, int length);
    [ExtensionAttribute]
internal static void CopyTo(IMemoryGroup`1<T> source, Span`1<T> target);
    [ExtensionAttribute]
internal static void CopyTo(Span`1<T> source, IMemoryGroup`1<T> target);
    [ExtensionAttribute]
internal static void CopyTo(ReadOnlySpan`1<T> source, IMemoryGroup`1<T> target);
    [ExtensionAttribute]
internal static void CopyTo(IMemoryGroup`1<T> source, IMemoryGroup`1<T> target);
    [ExtensionAttribute]
internal static void TransformTo(IMemoryGroup`1<TSource> source, IMemoryGroup`1<TTarget> target, TransformItemsDelegate`2<TSource, TTarget> transform);
    [ExtensionAttribute]
internal static void TransformInplace(IMemoryGroup`1<T> memoryGroup, TransformItemsInplaceDelegate`1<T> transform);
    [ExtensionAttribute]
internal static bool IsEmpty(IMemoryGroup`1<T> group);
}
internal class SixLabors.ImageSharp.Memory.MemoryGroupSpanCache : ValueType {
    public SpanCacheMode Mode;
    [NullableAttribute("2")]
public Byte[] SingleArray;
    public Void* SinglePointer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Void*[] MultiPointer;
    public static MemoryGroupSpanCache Create(IMemoryOwner`1[] memoryOwners);
}
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Memory.MemoryGroupView`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MemoryGroup`1<T> owner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MemoryOwnerWrapper[] memoryWrappers;
    public int Count { get; }
    public int BufferLength { get; }
    public long TotalLength { get; }
    [MemberNotNullWhenAttribute("True", "owner")]
public bool IsValid { get; }
    public Memory`1<T> Item { get; }
    public MemoryGroupView`1(MemoryGroup`1<T> owner);
    public sealed virtual int get_Count();
    public sealed virtual int get_BufferLength();
    public sealed virtual long get_TotalLength();
    [MemberNotNullWhenAttribute("True", "owner")]
public sealed virtual bool get_IsValid();
    public sealed virtual Memory`1<T> get_Item(int index);
    public sealed virtual MemoryGroupEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Memory.MemoryGroupView`1/<System-Collections-Generic-IEnumerable<System-Memory<T>>-GetEnumerator>d__14")]
private sealed virtual override IEnumerator`1<Memory`1<T>> System.Collections.Generic.IEnumerable<System.Memory<T>>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Invalidate();
    [MemberNotNullAttribute("owner")]
private void EnsureIsValid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Memory.MemoryOwnerExtensions : object {
    [ExtensionAttribute]
public static Span`1<T> GetSpan(IMemoryOwner`1<T> buffer);
    [ExtensionAttribute]
public static int Length(IMemoryOwner`1<T> buffer);
    [ExtensionAttribute]
public static Span`1<T> Slice(IMemoryOwner`1<T> buffer, int start);
    [ExtensionAttribute]
public static Span`1<T> Slice(IMemoryOwner`1<T> buffer, int start, int length);
    [ExtensionAttribute]
public static void Clear(IMemoryOwner`1<T> buffer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static T& GetReference(IMemoryOwner`1<T> buffer);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Memory.RowInterval : ValueType {
    [CompilerGeneratedAttribute]
private int <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Max>k__BackingField;
    public int Min { get; }
    public int Max { get; }
    public int Height { get; }
    public RowInterval(int min, int max);
    [CompilerGeneratedAttribute]
public int get_Min();
    [CompilerGeneratedAttribute]
public int get_Max();
    public int get_Height();
    public static bool op_Equality(RowInterval left, RowInterval right);
    public static bool op_Inequality(RowInterval left, RowInterval right);
    public sealed virtual bool Equals(RowInterval other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal RowInterval Slice(int start);
    internal RowInterval Slice(int start, int length);
}
public class SixLabors.ImageSharp.Memory.SimpleGcMemoryAllocator : MemoryAllocator {
    protected internal virtual int GetBufferCapacityInBytes();
    public virtual IMemoryOwner`1<T> Allocate(int length, AllocationOptions options);
}
internal enum SixLabors.ImageSharp.Memory.SpanCacheMode : Enum {
    public int value__;
    public static SpanCacheMode Default;
    public static SpanCacheMode SingleArray;
    public static SpanCacheMode SinglePointer;
    public static SpanCacheMode MultiPointer;
}
internal class SixLabors.ImageSharp.Memory.TransformItemsDelegate`2 : MulticastDelegate {
    public TransformItemsDelegate`2(object object, IntPtr method);
    public virtual void Invoke(ReadOnlySpan`1<TSource> source, Span`1<TTarget> target);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<TSource> source, Span`1<TTarget> target, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class SixLabors.ImageSharp.Memory.TransformItemsInplaceDelegate`1 : MulticastDelegate {
    public TransformItemsInplaceDelegate`1(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> data);
    public virtual IAsyncResult BeginInvoke(Span`1<T> data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Memory.UniformUnmanagedMemoryPoolMemoryAllocator : MemoryAllocator {
    private static int OneMegabyte;
    private static int DefaultContiguousPoolBlockSizeBytes;
    private static int DefaultNonPoolBlockSizeBytes;
    private int sharedArrayPoolThresholdInBytes;
    private int poolBufferSizeInBytes;
    private int poolCapacity;
    private TrimSettings trimSettings;
    private UniformUnmanagedMemoryPool pool;
    private UnmanagedMemoryAllocator nonPoolAllocator;
    [CompilerGeneratedAttribute]
private static Func`1<long> <GetTotalAvailableMemoryBytes>k__BackingField;
    internal static Func`1<long> GetTotalAvailableMemoryBytes { get; internal set; }
    public UniformUnmanagedMemoryPoolMemoryAllocator(Nullable`1<int> maxPoolSizeMegabytes);
    public UniformUnmanagedMemoryPoolMemoryAllocator(int poolBufferSizeInBytes, long maxPoolSizeInBytes, int unmanagedBufferSizeInBytes);
    internal UniformUnmanagedMemoryPoolMemoryAllocator(int sharedArrayPoolThresholdInBytes, int poolBufferSizeInBytes, long maxPoolSizeInBytes, int unmanagedBufferSizeInBytes);
    internal UniformUnmanagedMemoryPoolMemoryAllocator(int sharedArrayPoolThresholdInBytes, int poolBufferSizeInBytes, long maxPoolSizeInBytes, int unmanagedBufferSizeInBytes, TrimSettings trimSettings);
    private static UniformUnmanagedMemoryPoolMemoryAllocator();
    [CompilerGeneratedAttribute]
internal static Func`1<long> get_GetTotalAvailableMemoryBytes();
    [CompilerGeneratedAttribute]
internal static void set_GetTotalAvailableMemoryBytes(Func`1<long> value);
    protected internal virtual int GetBufferCapacityInBytes();
    [NullableContextAttribute("0")]
public virtual IMemoryOwner`1<T> Allocate(int length, AllocationOptions options);
    [NullableContextAttribute("0")]
internal virtual MemoryGroup`1<T> AllocateGroupCore(long totalLengthInElements, long totalLengthInBytes, int bufferAlignment, AllocationOptions options);
    public virtual void ReleaseRetainedResources();
    private static long GetDefaultMaxPoolSizeBytes();
}
internal class SixLabors.ImageSharp.Memory.UnmanagedMemoryAllocator : MemoryAllocator {
    private int bufferCapacityInBytes;
    public UnmanagedMemoryAllocator(int bufferCapacityInBytes);
    protected internal virtual int GetBufferCapacityInBytes();
    public virtual IMemoryOwner`1<T> Allocate(int length, AllocationOptions options);
}
internal class SixLabors.ImageSharp.Memory.UnmanagedMemoryManager`1 : MemoryManager`1<T> {
    private Void* pointer;
    private int length;
    public UnmanagedMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.ImageFrameMetadata : object {
    [NullableAttribute("1")]
private Dictionary`2<IImageFormat, IDeepCloneable> formatMetadata;
    [CompilerGeneratedAttribute]
private ExifProfile <ExifProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private XmpProfile <XmpProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfile <IccProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private IptcProfile <IptcProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private CicpProfile <CicpProfile>k__BackingField;
    public ExifProfile ExifProfile { get; public set; }
    public XmpProfile XmpProfile { get; public set; }
    public IccProfile IccProfile { get; public set; }
    public IptcProfile IptcProfile { get; public set; }
    public CicpProfile CicpProfile { get; public set; }
    [NullableContextAttribute("1")]
internal ImageFrameMetadata(ImageFrameMetadata other);
    [CompilerGeneratedAttribute]
public ExifProfile get_ExifProfile();
    [CompilerGeneratedAttribute]
public void set_ExifProfile(ExifProfile value);
    [CompilerGeneratedAttribute]
public XmpProfile get_XmpProfile();
    [CompilerGeneratedAttribute]
public void set_XmpProfile(XmpProfile value);
    [CompilerGeneratedAttribute]
public IccProfile get_IccProfile();
    [CompilerGeneratedAttribute]
public void set_IccProfile(IccProfile value);
    [CompilerGeneratedAttribute]
public IptcProfile get_IptcProfile();
    [CompilerGeneratedAttribute]
public void set_IptcProfile(IptcProfile value);
    [CompilerGeneratedAttribute]
public CicpProfile get_CicpProfile();
    [CompilerGeneratedAttribute]
public void set_CicpProfile(CicpProfile value);
    [NullableContextAttribute("1")]
public sealed virtual ImageFrameMetadata DeepClone();
    [NullableContextAttribute("1")]
public TFormatFrameMetadata GetFormatMetadata(IImageFormat`2<TFormatMetadata, TFormatFrameMetadata> key);
    [NullableContextAttribute("1")]
public bool TryGetFormatMetadata(IImageFormat`2<TFormatMetadata, TFormatFrameMetadata> key, TFormatFrameMetadata& metadata);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.ImageMetadata : object {
    public static double DefaultHorizontalResolution;
    public static double DefaultVerticalResolution;
    public static PixelResolutionUnit DefaultPixelResolutionUnits;
    [NullableAttribute("1")]
private Dictionary`2<IImageFormat, IDeepCloneable> formatMetadata;
    private double horizontalResolution;
    private double verticalResolution;
    [CompilerGeneratedAttribute]
private PixelResolutionUnit <ResolutionUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private ExifProfile <ExifProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private XmpProfile <XmpProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfile <IccProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private IptcProfile <IptcProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private CicpProfile <CicpProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private IImageFormat <DecodedImageFormat>k__BackingField;
    public double HorizontalResolution { get; public set; }
    public double VerticalResolution { get; public set; }
    public PixelResolutionUnit ResolutionUnits { get; public set; }
    public ExifProfile ExifProfile { get; public set; }
    public XmpProfile XmpProfile { get; public set; }
    public IccProfile IccProfile { get; public set; }
    public IptcProfile IptcProfile { get; public set; }
    public CicpProfile CicpProfile { get; public set; }
    public IImageFormat DecodedImageFormat { get; internal set; }
    [NullableContextAttribute("1")]
private ImageMetadata(ImageMetadata other);
    public double get_HorizontalResolution();
    public void set_HorizontalResolution(double value);
    public double get_VerticalResolution();
    public void set_VerticalResolution(double value);
    [CompilerGeneratedAttribute]
public PixelResolutionUnit get_ResolutionUnits();
    [CompilerGeneratedAttribute]
public void set_ResolutionUnits(PixelResolutionUnit value);
    [CompilerGeneratedAttribute]
public ExifProfile get_ExifProfile();
    [CompilerGeneratedAttribute]
public void set_ExifProfile(ExifProfile value);
    [CompilerGeneratedAttribute]
public XmpProfile get_XmpProfile();
    [CompilerGeneratedAttribute]
public void set_XmpProfile(XmpProfile value);
    [CompilerGeneratedAttribute]
public IccProfile get_IccProfile();
    [CompilerGeneratedAttribute]
public void set_IccProfile(IccProfile value);
    [CompilerGeneratedAttribute]
public IptcProfile get_IptcProfile();
    [CompilerGeneratedAttribute]
public void set_IptcProfile(IptcProfile value);
    [CompilerGeneratedAttribute]
public CicpProfile get_CicpProfile();
    [CompilerGeneratedAttribute]
public void set_CicpProfile(CicpProfile value);
    [CompilerGeneratedAttribute]
public IImageFormat get_DecodedImageFormat();
    [CompilerGeneratedAttribute]
internal void set_DecodedImageFormat(IImageFormat value);
    [NullableContextAttribute("1")]
public TFormatMetadata GetFormatMetadata(IImageFormat`1<TFormatMetadata> key);
    [NullableContextAttribute("1")]
public bool TryGetFormatMetadata(IImageFormat`1<TFormatMetadata> key, TFormatMetadata& metadata);
    [NullableContextAttribute("1")]
public sealed virtual ImageMetadata DeepClone();
    internal void SyncProfiles();
}
public enum SixLabors.ImageSharp.Metadata.PixelResolutionUnit : Enum {
    public byte value__;
    public static PixelResolutionUnit AspectRatio;
    public static PixelResolutionUnit PixelsPerInch;
    public static PixelResolutionUnit PixelsPerCentimeter;
    public static PixelResolutionUnit PixelsPerMeter;
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Cicp.CicpColorPrimaries : Enum {
    public byte value__;
    public static CicpColorPrimaries ItuRBt709_6;
    public static CicpColorPrimaries Unspecified;
    public static CicpColorPrimaries ItuRBt470_6M;
    public static CicpColorPrimaries ItuRBt601_7_625;
    public static CicpColorPrimaries ItuRBt601_7_525;
    public static CicpColorPrimaries SmpteSt240;
    public static CicpColorPrimaries GenericFilm;
    public static CicpColorPrimaries ItuRBt2020_2;
    public static CicpColorPrimaries SmpteSt428_1;
    public static CicpColorPrimaries SmpteRp431_2;
    public static CicpColorPrimaries SmpteEg432_1;
    public static CicpColorPrimaries EbuTech3213E;
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Cicp.CicpMatrixCoefficients : Enum {
    public byte value__;
    public static CicpMatrixCoefficients Identity;
    public static CicpMatrixCoefficients ItuRBt709_6;
    public static CicpMatrixCoefficients Unspecified;
    public static CicpMatrixCoefficients Fcc47;
    public static CicpMatrixCoefficients ItuRBt601_7_625;
    public static CicpMatrixCoefficients ItuRBt601_7_525;
    public static CicpMatrixCoefficients SmpteSt240;
    public static CicpMatrixCoefficients YCgCo;
    public static CicpMatrixCoefficients ItuRBt2020_2_Ncl;
    public static CicpMatrixCoefficients ItuRBt2020_2_Cl;
    public static CicpMatrixCoefficients SmpteSt2085;
    public static CicpMatrixCoefficients ChromaDerivedNcl;
    public static CicpMatrixCoefficients ChromaDerivedCl;
    public static CicpMatrixCoefficients ICtCp;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Cicp.CicpProfile : object {
    [CompilerGeneratedAttribute]
private CicpColorPrimaries <ColorPrimaries>k__BackingField;
    [CompilerGeneratedAttribute]
private CicpTransferCharacteristics <TransferCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private CicpMatrixCoefficients <MatrixCoefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FullRange>k__BackingField;
    public CicpColorPrimaries ColorPrimaries { get; public set; }
    public CicpTransferCharacteristics TransferCharacteristics { get; public set; }
    public CicpMatrixCoefficients MatrixCoefficients { get; public set; }
    public bool FullRange { get; public set; }
    public CicpProfile(byte colorPrimaries, byte transferCharacteristics, byte matrixCoefficients, Nullable`1<bool> fullRange);
    private CicpProfile(CicpProfile other);
    [CompilerGeneratedAttribute]
public CicpColorPrimaries get_ColorPrimaries();
    [CompilerGeneratedAttribute]
public void set_ColorPrimaries(CicpColorPrimaries value);
    [CompilerGeneratedAttribute]
public CicpTransferCharacteristics get_TransferCharacteristics();
    [CompilerGeneratedAttribute]
public void set_TransferCharacteristics(CicpTransferCharacteristics value);
    [CompilerGeneratedAttribute]
public CicpMatrixCoefficients get_MatrixCoefficients();
    [CompilerGeneratedAttribute]
public void set_MatrixCoefficients(CicpMatrixCoefficients value);
    [CompilerGeneratedAttribute]
public bool get_FullRange();
    [CompilerGeneratedAttribute]
public void set_FullRange(bool value);
    public sealed virtual CicpProfile DeepClone();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Cicp.CicpTransferCharacteristics : Enum {
    public byte value__;
    public static CicpTransferCharacteristics ItuRBt709_6;
    public static CicpTransferCharacteristics Unspecified;
    public static CicpTransferCharacteristics Gamma2_2;
    public static CicpTransferCharacteristics Gamma2_8;
    public static CicpTransferCharacteristics ItuRBt601_7;
    public static CicpTransferCharacteristics SmpteSt240;
    public static CicpTransferCharacteristics Linear;
    public static CicpTransferCharacteristics Log100;
    public static CicpTransferCharacteristics Log100Sqrt;
    public static CicpTransferCharacteristics Iec61966_2_4;
    public static CicpTransferCharacteristics ItuRBt1361_0;
    public static CicpTransferCharacteristics Iec61966_2_1;
    public static CicpTransferCharacteristics ItuRBt2020_2_10bit;
    public static CicpTransferCharacteristics ItuRBt2020_2_12bit;
    public static CicpTransferCharacteristics SmpteSt2084;
    public static CicpTransferCharacteristics SmpteSt428_1;
    public static CicpTransferCharacteristics AribStdB67;
}
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Exif.BaseExifReader : object {
    [NullableAttribute("2")]
private MemoryAllocator allocator;
    [NullableAttribute("1")]
private Stream data;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ExifTag> invalidTags;
    [NullableAttribute("2")]
private List`1<ulong> subIfds;
    [CompilerGeneratedAttribute]
private UInt32 <ThumbnailLength>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ThumbnailOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBigEndian>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`4<ulong, ExifDataType, ulong, ExifValue>> <BigValues>k__BackingField;
    [NullableAttribute("1")]
public IReadOnlyList`1<ExifTag> InvalidTags { get; }
    public UInt32 ThumbnailLength { get; protected set; }
    public UInt32 ThumbnailOffset { get; protected set; }
    public bool IsBigEndian { get; protected set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`4<ulong, ExifDataType, ulong, ExifValue>> BigValues { get; }
    [NullableContextAttribute("1")]
protected BaseExifReader(Stream stream, MemoryAllocator allocator);
    [NullableContextAttribute("1")]
public IReadOnlyList`1<ExifTag> get_InvalidTags();
    [CompilerGeneratedAttribute]
public UInt32 get_ThumbnailLength();
    [CompilerGeneratedAttribute]
protected void set_ThumbnailLength(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_ThumbnailOffset();
    [CompilerGeneratedAttribute]
protected void set_ThumbnailOffset(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsBigEndian();
    [CompilerGeneratedAttribute]
protected void set_IsBigEndian(bool value);
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`4<ulong, ExifDataType, ulong, ExifValue>> get_BigValues();
    [NullableContextAttribute("1")]
protected void ReadBigValues(List`1<IExifValue> values);
    [NullableContextAttribute("1")]
protected void ReadValues(List`1<IExifValue> values, UInt32 offset);
    [NullableContextAttribute("1")]
protected void ReadSubIfd(List`1<IExifValue> values);
    [NullableContextAttribute("1")]
protected void ReadValues64(List`1<IExifValue> values, ulong offset);
    protected void ReadBigValue(IList`1<IExifValue> values, ValueTuple`4<ulong, ExifDataType, ulong, ExifValue> tag, Span`1<byte> buffer);
    [NullableContextAttribute("1")]
private static TDataType[] ToArray(ExifDataType dataType, ReadOnlySpan`1<byte> data, ConverterMethod`1<TDataType> converter);
    [NullableContextAttribute("1")]
private static string ConvertToString(Encoding encoding, ReadOnlySpan`1<byte> buffer);
    private static byte ConvertToByte(ReadOnlySpan`1<byte> buffer);
    private object ConvertValue(ExifDataType dataType, ReadOnlySpan`1<byte> buffer, bool isArray);
    private void ReadValue(List`1<IExifValue> values, Span`1<byte> offsetBuffer);
    private void ReadValue64(List`1<IExifValue> values, Span`1<byte> offsetBuffer);
    [NullableContextAttribute("1")]
private void Add(IList`1<IExifValue> values, IExifValue exif, object value);
    [NullableContextAttribute("1")]
private void AddInvalidTag(ExifTag tag);
    [NullableContextAttribute("2")]
private void AddSubIfd(object val);
    private void Seek(ulong pos);
    private bool TryReadSpan(Span`1<byte> span);
    protected ulong ReadUInt64();
    protected UInt32 ReadUInt32();
    protected ushort ReadUInt16();
    private long ConvertToInt64(ReadOnlySpan`1<byte> buffer);
    private ulong ConvertToUInt64(ReadOnlySpan`1<byte> buffer);
    private double ConvertToDouble(ReadOnlySpan`1<byte> buffer);
    private UInt32 ConvertToUInt32(ReadOnlySpan`1<byte> buffer);
    private ushort ConvertToShort(ReadOnlySpan`1<byte> buffer);
    private float ConvertToSingle(ReadOnlySpan`1<byte> buffer);
    private Rational ToRational(ReadOnlySpan`1<byte> buffer);
    private sbyte ConvertToSignedByte(ReadOnlySpan`1<byte> buffer);
    private int ConvertToInt32(ReadOnlySpan`1<byte> buffer);
    private SignedRational ToSignedRational(ReadOnlySpan`1<byte> buffer);
    private short ConvertToSignedShort(ReadOnlySpan`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Metadata.Profiles.Exif.EncodedString : ValueType {
    [CompilerGeneratedAttribute]
private CharacterCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public CharacterCode Code { get; }
    public string Text { get; }
    public EncodedString(string text);
    public EncodedString(CharacterCode code, string text);
    [CompilerGeneratedAttribute]
public CharacterCode get_Code();
    [CompilerGeneratedAttribute]
public string get_Text();
    public static EncodedString op_Implicit(string text);
    public static string op_Explicit(EncodedString encodedString);
    public static bool op_Equality(EncodedString left, EncodedString right);
    public static bool op_Inequality(EncodedString left, EncodedString right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EncodedString other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifArrayValue`1 : ExifValue {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TValueType[] <Value>k__BackingField;
    public bool IsArray { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TValueType[] Value { get; public set; }
    [NullableContextAttribute("1")]
protected ExifArrayValue`1(ExifTag`1<TValueType[]> tag);
    protected ExifArrayValue`1(ExifTagValue tag);
    [NullableContextAttribute("1")]
internal ExifArrayValue`1(ExifArrayValue`1<TValueType> value);
    public virtual bool get_IsArray();
    [CompilerGeneratedAttribute]
public sealed virtual TValueType[] get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(TValueType[] value);
    public virtual object GetValue();
    public virtual bool TrySetValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifByte : ExifValue`1<byte> {
    [CompilerGeneratedAttribute]
private ExifDataType <DataType>k__BackingField;
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifByte(ExifTag`1<byte> tag, ExifDataType dataType);
    public ExifByte(ExifTagValue tag, ExifDataType dataType);
    private ExifByte(ExifByte value);
    [CompilerGeneratedAttribute]
public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifByteArray : ExifArrayValue`1<byte> {
    [CompilerGeneratedAttribute]
private ExifDataType <DataType>k__BackingField;
    public ExifDataType DataType { get; }
    public ExifByteArray(ExifTag`1<Byte[]> tag, ExifDataType dataType);
    public ExifByteArray(ExifTagValue tag, ExifDataType dataType);
    private ExifByteArray(ExifByteArray value);
    [CompilerGeneratedAttribute]
public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool TrySetSignedIntArray(Int32[] intArrayValue);
}
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifConstants : object {
    public static ReadOnlySpan`1<byte> LittleEndianByteOrderMarker { get; }
    public static ReadOnlySpan`1<byte> BigEndianByteOrderMarker { get; }
    [NullableAttribute("1")]
public static Encoding DefaultEncoding { get; }
    public static ReadOnlySpan`1<byte> get_LittleEndianByteOrderMarker();
    public static ReadOnlySpan`1<byte> get_BigEndianByteOrderMarker();
    [NullableContextAttribute("1")]
public static Encoding get_DefaultEncoding();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifDataType : Enum {
    public int value__;
    public static ExifDataType Unknown;
    public static ExifDataType Byte;
    public static ExifDataType Ascii;
    public static ExifDataType Short;
    public static ExifDataType Long;
    public static ExifDataType Rational;
    public static ExifDataType SignedByte;
    public static ExifDataType Undefined;
    public static ExifDataType SignedShort;
    public static ExifDataType SignedLong;
    public static ExifDataType SignedRational;
    public static ExifDataType SingleFloat;
    public static ExifDataType DoubleFloat;
    public static ExifDataType Ifd;
    public static ExifDataType Long8;
    public static ExifDataType SignedLong8;
    public static ExifDataType Ifd8;
}
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifDataTypes : object {
    public static UInt32 GetSize(ExifDataType dataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifDouble : ExifValue`1<double> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifDouble(ExifTag`1<double> tag);
    public ExifDouble(ExifTagValue tag);
    private ExifDouble(ExifDouble value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifDoubleArray : ExifArrayValue`1<double> {
    public ExifDataType DataType { get; }
    public ExifDoubleArray(ExifTag`1<Double[]> tag);
    public ExifDoubleArray(ExifTagValue tag);
    private ExifDoubleArray(ExifDoubleArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifEncodedString : ExifValue`1<EncodedString> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifEncodedString(ExifTag`1<EncodedString> tag);
    public ExifEncodedString(ExifTagValue tag);
    private ExifEncodedString(ExifEncodedString value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifEncodedStringHelpers : object {
    public static int CharacterCodeBytesLength;
    private static ulong AsciiCode;
    private static ulong JISCode;
    private static ulong UnicodeCode;
    private static ulong UndefinedCode;
    private static ReadOnlySpan`1<byte> AsciiCodeBytes { get; }
    private static ReadOnlySpan`1<byte> JISCodeBytes { get; }
    private static ReadOnlySpan`1<byte> UnicodeCodeBytes { get; }
    private static ReadOnlySpan`1<byte> UndefinedCodeBytes { get; }
    [NullableAttribute("1")]
private static Encoding JIS0208Encoding { get; }
    private static ReadOnlySpan`1<byte> get_AsciiCodeBytes();
    private static ReadOnlySpan`1<byte> get_JISCodeBytes();
    private static ReadOnlySpan`1<byte> get_UnicodeCodeBytes();
    private static ReadOnlySpan`1<byte> get_UndefinedCodeBytes();
    [NullableContextAttribute("1")]
private static Encoding get_JIS0208Encoding();
    public static bool IsEncodedString(ExifTagValue tag);
    public static ReadOnlySpan`1<byte> GetCodeBytes(CharacterCode code);
    [NullableContextAttribute("1")]
public static Encoding GetEncoding(CharacterCode code);
    public static bool TryParse(ReadOnlySpan`1<byte> buffer, EncodedString& encodedString);
    public static UInt32 GetDataLength(EncodedString encodedString);
    public static int Write(EncodedString encodedString, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static int Write(Encoding encoding, string value, Span`1<byte> destination);
    private static bool TryDetect(ReadOnlySpan`1<byte> buffer, CharacterCode& code);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifFloat : ExifValue`1<float> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifFloat(ExifTagValue tag);
    private ExifFloat(ExifFloat value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifFloatArray : ExifArrayValue`1<float> {
    public ExifDataType DataType { get; }
    public ExifFloatArray(ExifTagValue tag);
    private ExifFloatArray(ExifFloatArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifLong : ExifValue`1<UInt32> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifLong(ExifTag`1<UInt32> tag);
    public ExifLong(ExifTagValue tag);
    private ExifLong(ExifLong value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifLong8 : ExifValue`1<ulong> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifLong8(ExifTag`1<ulong> tag);
    public ExifLong8(ExifTagValue tag);
    private ExifLong8(ExifLong8 value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifLong8Array : ExifArrayValue`1<ulong> {
    public ExifDataType DataType { get; }
    public ExifLong8Array(ExifTagValue tag);
    private ExifLong8Array(ExifLong8Array value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool SetSingle(ulong value);
    private bool SetArray(Int64[] values);
    private bool SetArray(UInt64[] values);
    private bool SetArray(Int32[] values);
    private bool SetArray(UInt32[] values);
    private bool SetArray(Int16[] values);
    private bool SetArray(UInt16[] values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifLongArray : ExifArrayValue`1<UInt32> {
    public ExifDataType DataType { get; }
    public ExifLongArray(ExifTag`1<UInt32[]> tag);
    public ExifLongArray(ExifTagValue tag);
    private ExifLongArray(ExifLongArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifNumber : ExifValue`1<Number> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifNumber(ExifTag`1<Number> tag);
    private ExifNumber(ExifNumber value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifNumberArray : ExifArrayValue`1<Number> {
    public ExifDataType DataType { get; }
    public ExifNumberArray(ExifTag`1<Number[]> tag);
    private ExifNumberArray(ExifNumberArray value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool SetSingle(Number value);
    private bool SetArray(Int32[] values);
    private bool SetArray(UInt32[] values);
    private bool SetArray(Int16[] values);
    private bool SetArray(UInt16[] values);
}
public static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifOrientationMode : object {
    public static ushort Unknown;
    public static ushort TopLeft;
    public static ushort TopRight;
    public static ushort BottomRight;
    public static ushort BottomLeft;
    public static ushort LeftTop;
    public static ushort RightTop;
    public static ushort RightBottom;
    public static ushort LeftBottom;
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifParts : Enum {
    public int value__;
    public static ExifParts None;
    public static ExifParts IfdTags;
    public static ExifParts ExifTags;
    public static ExifParts GpsTags;
    public static ExifParts All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifProfile : object {
    [NullableAttribute("2")]
private Byte[] data;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IExifValue> values;
    private int thumbnailOffset;
    private int thumbnailLength;
    [CompilerGeneratedAttribute]
private ExifParts <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExifTag> <InvalidTags>k__BackingField;
    public ExifParts Parts { get; public set; }
    public IReadOnlyList`1<ExifTag> InvalidTags { get; private set; }
    [MemberNotNullAttribute("values")]
public IReadOnlyList`1<IExifValue> Values { get; }
    [NullableContextAttribute("2")]
public ExifProfile(Byte[] data);
    internal ExifProfile(List`1<IExifValue> values, IReadOnlyList`1<ExifTag> invalidTags);
    private ExifProfile(ExifProfile other);
    [CompilerGeneratedAttribute]
public ExifParts get_Parts();
    [CompilerGeneratedAttribute]
public void set_Parts(ExifParts value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ExifTag> get_InvalidTags();
    [CompilerGeneratedAttribute]
private void set_InvalidTags(IReadOnlyList`1<ExifTag> value);
    [MemberNotNullAttribute("values")]
public IReadOnlyList`1<IExifValue> get_Values();
    [NullableContextAttribute("2")]
public bool TryCreateThumbnail(Image& image);
    [NullableContextAttribute("0")]
public bool TryCreateThumbnail(Image`1& image);
    public bool TryGetValue(ExifTag`1<TValueType> tag, IExifValue`1& exifValue);
    public bool RemoveValue(ExifTag tag);
    public void SetValue(ExifTag`1<TValueType> tag, TValueType value);
    [NullableContextAttribute("2")]
public Byte[] ToByteArray();
    public sealed virtual ExifProfile DeepClone();
    internal IExifValue GetValueInternal(ExifTag tag);
    internal void SetValueInternal(ExifTag tag, object value);
    internal void Sync(ImageMetadata metadata);
    private void SyncResolution(ExifTag`1<Rational> tag, double resolution);
    [MemberNotNullAttribute("values")]
private void InitializeValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifRational : ExifValue`1<Rational> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifRational(ExifTag`1<Rational> tag);
    public ExifRational(ExifTagValue tag);
    private ExifRational(ExifRational value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifRationalArray : ExifArrayValue`1<Rational> {
    public ExifDataType DataType { get; }
    public ExifRationalArray(ExifTag`1<Rational[]> tag);
    public ExifRationalArray(ExifTagValue tag);
    private ExifRationalArray(ExifRationalArray value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool TrySetSignedArray(SignedRational[] signed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifReader : BaseExifReader {
    public ExifReader(Byte[] exifData);
    public ExifReader(Byte[] exifData, MemoryAllocator allocator);
    public List`1<IExifValue> ReadValues();
    private void GetThumbnail(UInt32 offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifShort : ExifValue`1<ushort> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifShort(ExifTag`1<ushort> tag);
    public ExifShort(ExifTagValue tag);
    private ExifShort(ExifShort value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifShortArray : ExifArrayValue`1<ushort> {
    public ExifDataType DataType { get; }
    public ExifShortArray(ExifTag`1<UInt16[]> tag);
    public ExifShortArray(ExifTagValue tag);
    private ExifShortArray(ExifShortArray value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool TrySetSignedIntArray(Int32[] signed);
    private bool TrySetSignedShortArray(Int16[] signed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedByte : ExifValue`1<sbyte> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifSignedByte(ExifTagValue tag);
    private ExifSignedByte(ExifSignedByte value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedByteArray : ExifArrayValue`1<sbyte> {
    public ExifDataType DataType { get; }
    public ExifSignedByteArray(ExifTagValue tag);
    private ExifSignedByteArray(ExifSignedByteArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedLong : ExifValue`1<int> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifSignedLong(ExifTagValue tag);
    private ExifSignedLong(ExifSignedLong value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedLong8 : ExifValue`1<long> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifSignedLong8(ExifTagValue tag);
    private ExifSignedLong8(ExifSignedLong8 value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedLong8Array : ExifArrayValue`1<long> {
    public ExifDataType DataType { get; }
    public ExifSignedLong8Array(ExifTagValue tag);
    private ExifSignedLong8Array(ExifSignedLong8Array value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedLongArray : ExifArrayValue`1<int> {
    public ExifDataType DataType { get; }
    public ExifSignedLongArray(ExifTagValue tag);
    private ExifSignedLongArray(ExifSignedLongArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedRational : ExifValue`1<SignedRational> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    internal ExifSignedRational(ExifTag`1<SignedRational> tag);
    internal ExifSignedRational(ExifTagValue tag);
    private ExifSignedRational(ExifSignedRational value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedRationalArray : ExifArrayValue`1<SignedRational> {
    public ExifDataType DataType { get; }
    public ExifSignedRationalArray(ExifTag`1<SignedRational[]> tag);
    public ExifSignedRationalArray(ExifTagValue tag);
    private ExifSignedRationalArray(ExifSignedRationalArray value);
    public virtual ExifDataType get_DataType();
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedShort : ExifValue`1<short> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    public ExifSignedShort(ExifTagValue tag);
    private ExifSignedShort(ExifSignedShort value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifSignedShortArray : ExifArrayValue`1<short> {
    public ExifDataType DataType { get; }
    public ExifSignedShortArray(ExifTag`1<Int16[]> tag);
    public ExifSignedShortArray(ExifTagValue tag);
    private ExifSignedShortArray(ExifSignedShortArray value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
    private bool TrySetSignedArray(Int32[] intArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifString : ExifValue`1<string> {
    public ExifDataType DataType { get; }
    [NullableAttribute("2")]
protected string StringValue { get; }
    public ExifString(ExifTag`1<string> tag);
    public ExifString(ExifTagValue tag);
    private ExifString(ExifString value);
    public virtual ExifDataType get_DataType();
    [NullableContextAttribute("2")]
protected virtual string get_StringValue();
    [NullableContextAttribute("2")]
public virtual bool TrySetValue(object value);
    public virtual IExifValue DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifTag : object {
    [CompilerGeneratedAttribute]
private static ExifTag`1<byte> <FaxProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<byte> <ModeNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<byte> <GPSAltitudeRef>k__BackingField;
    private ushort value;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Double[]> <PixelScale>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Double[]> <IntergraphMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Double[]> <ModelTiePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Double[]> <ModelTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<EncodedString> <UserComment>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<EncodedString> <GPSProcessingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<EncodedString> <GPSAreaInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <SubfileType>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <SubIFDOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <GPSIFDOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <T4Options>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <T6Options>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <XClipPathUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <YClipPathUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <ProfileType>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <CodingMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <T82ptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <JPEGInterchangeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <JPEGInterchangeFormatLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <MDFileTag>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <StandardOutputSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <RecommendedExposureIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <ISOSpeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <ISOSpeedLatitudeyyy>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <ISOSpeedLatitudezzz>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <FaxRecvParams>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <FaxRecvTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32> <ImageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <FreeOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <FreeByteCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <ColorResponseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <SMinSampleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <SMaxSampleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <JPEGQTables>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <JPEGDCTables>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <JPEGACTables>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <StripRowCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <IntergraphRegisters>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt32[]> <SubIFDs>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <ImageWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <ImageLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <RowsPerStrip>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <TileWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <TileLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <BadFaxLines>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <ConsecutiveBadFaxLines>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <PixelXDimension>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number> <PixelYDimension>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number[]> <StripOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number[]> <StripByteCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number[]> <TileByteCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number[]> <TileOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Number[]> <ImageLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <XPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <YPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <XResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <YResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <BatteryLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <ExposureTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <MDScalePixel>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <CompressedBitsPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <ApertureValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <MaxApertureValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <SubjectDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FocalLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FlashEnergy2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FocalPlaneXResolution2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FocalPlaneYResolution2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <ExposureIndex2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <Humidity>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <Pressure>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <Acceleration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FlashEnergy>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FocalPlaneXResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <FocalPlaneYResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <ExposureIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <DigitalZoomRatio>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSAltitude>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSDOP>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSSpeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSTrack>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSImgDirection>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSDestBearing>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSDestDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational> <GPSHPositioningError>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <WhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <PrimaryChromaticities>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <YCbCrCoefficients>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <ReferenceBlackWhite>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <GPSLatitude>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <GPSLongitude>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <GPSTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <GPSDestLatitude>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <GPSDestLongitude>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Rational[]> <LensSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <OldSubfileType>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <PhotometricInterpretation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Thresholding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <CellWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <CellLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <FillOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Orientation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SamplesPerPixel>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <PlanarConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Predictor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <GrayResponseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <ResolutionUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <CleanFaxData>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <InkSet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <NumberOfInks>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <DotRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Indexed>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <OPIProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <JPEGProc>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <JPEGRestartInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <YCbCrPositioning>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Rating>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <RatingPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <ExposureProgram>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Interlace>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SelfTimerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SensitivityType>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <MeteringMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <LightSource>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <FocalPlaneResolutionUnit2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SensingMethod2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Flash>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <ColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <FocalPlaneResolutionUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SensingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <CustomRendered>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <ExposureMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <WhiteBalance>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <FocalLengthIn35mmFilm>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SceneCaptureType>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <GainControl>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Contrast>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Saturation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <Sharpness>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <SubjectDistanceRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<ushort> <GPSDifferential>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <BitsPerSample>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <MinSampleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <MaxSampleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <GrayResponseCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <ColorMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <ExtraSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <TransferFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <HalftoneHints>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <SampleFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <TransferRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <DefaultImageColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <JPEGLosslessPredictors>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <JPEGPointTransforms>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <YCbCrSubsampling>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <CFARepeatPatternDim>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <IntergraphPacketData>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <ISOSpeedRatings>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <SubjectArea>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<UInt16[]> <SubjectLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <ShutterSpeedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <BrightnessValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <ExposureBiasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <AmbientTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <WaterDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational> <CameraElevationAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<SignedRational[]> <Decode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Int16[]> <TimeZoneOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <ImageDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <Make>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <Software>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <Artist>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <HostComputer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <DocumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <PageName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <InkNames>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <TargetPrinter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <ImageID>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <MDLabName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <MDSampleInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <MDPrepDate>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <MDPrepTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <MDFileUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SEMInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SpectralSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <DateTimeOriginal>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <DateTimeDigitized>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SubsecTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SubsecTimeOriginal>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SubsecTimeDigitized>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <RelatedSoundFile>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <FaxSubaddress>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <OffsetTime>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <OffsetTimeOriginal>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <OffsetTimeDigitized>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SecurityClassification>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <ImageHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <ImageUniqueID>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <OwnerName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <LensMake>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <LensModel>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <LensSerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GDALMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GDALNoData>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSLatitudeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSLongitudeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSSatellites>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSMeasureMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSSpeedRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSTrackRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSImgDirectionRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSMapDatum>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSDestLatitudeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSDestLongitudeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSDestBearingRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSDestDistanceRef>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<string> <GPSDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <JPEGTables>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <OECF>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <ExifVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <ComponentsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <MakerNote>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <FlashpixVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <SpatialFrequencyResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <SpatialFrequencyResponse2>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <Noise>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <CFAPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <DeviceSettingDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<Byte[]> <ImageSourceData>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<byte> <FileSource>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExifTag`1<byte> <SceneType>k__BackingField;
    public static ExifTag`1<byte> FaxProfile { get; }
    public static ExifTag`1<byte> ModeNumber { get; }
    public static ExifTag`1<byte> GPSAltitudeRef { get; }
    public static ExifTag`1<Byte[]> ClipPath { get; }
    public static ExifTag`1<Byte[]> VersionYear { get; }
    public static ExifTag`1<Byte[]> XMP { get; }
    public static ExifTag`1<Byte[]> IPTC { get; }
    public static ExifTag`1<Byte[]> IccProfile { get; }
    public static ExifTag`1<Byte[]> CFAPattern2 { get; }
    public static ExifTag`1<Byte[]> TIFFEPStandardID { get; }
    public static ExifTag`1<Byte[]> GPSVersionID { get; }
    public static ExifTag`1<Double[]> PixelScale { get; }
    public static ExifTag`1<Double[]> IntergraphMatrix { get; }
    public static ExifTag`1<Double[]> ModelTiePoint { get; }
    public static ExifTag`1<Double[]> ModelTransform { get; }
    public static ExifTag`1<EncodedString> UserComment { get; }
    public static ExifTag`1<EncodedString> GPSProcessingMethod { get; }
    public static ExifTag`1<EncodedString> GPSAreaInformation { get; }
    public static ExifTag`1<UInt32> SubfileType { get; }
    public static ExifTag`1<UInt32> SubIFDOffset { get; }
    public static ExifTag`1<UInt32> GPSIFDOffset { get; }
    public static ExifTag`1<UInt32> T4Options { get; }
    public static ExifTag`1<UInt32> T6Options { get; }
    public static ExifTag`1<UInt32> XClipPathUnits { get; }
    public static ExifTag`1<UInt32> YClipPathUnits { get; }
    public static ExifTag`1<UInt32> ProfileType { get; }
    public static ExifTag`1<UInt32> CodingMethods { get; }
    public static ExifTag`1<UInt32> T82ptions { get; }
    public static ExifTag`1<UInt32> JPEGInterchangeFormat { get; }
    public static ExifTag`1<UInt32> JPEGInterchangeFormatLength { get; }
    public static ExifTag`1<UInt32> MDFileTag { get; }
    public static ExifTag`1<UInt32> StandardOutputSensitivity { get; }
    public static ExifTag`1<UInt32> RecommendedExposureIndex { get; }
    public static ExifTag`1<UInt32> ISOSpeed { get; }
    public static ExifTag`1<UInt32> ISOSpeedLatitudeyyy { get; }
    public static ExifTag`1<UInt32> ISOSpeedLatitudezzz { get; }
    public static ExifTag`1<UInt32> FaxRecvParams { get; }
    public static ExifTag`1<UInt32> FaxRecvTime { get; }
    public static ExifTag`1<UInt32> ImageNumber { get; }
    public static ExifTag`1<UInt32[]> FreeOffsets { get; }
    public static ExifTag`1<UInt32[]> FreeByteCounts { get; }
    public static ExifTag`1<UInt32[]> ColorResponseUnit { get; }
    public static ExifTag`1<UInt32[]> SMinSampleValue { get; }
    public static ExifTag`1<UInt32[]> SMaxSampleValue { get; }
    public static ExifTag`1<UInt32[]> JPEGQTables { get; }
    public static ExifTag`1<UInt32[]> JPEGDCTables { get; }
    public static ExifTag`1<UInt32[]> JPEGACTables { get; }
    public static ExifTag`1<UInt32[]> StripRowCounts { get; }
    public static ExifTag`1<UInt32[]> IntergraphRegisters { get; }
    public static ExifTag`1<UInt32[]> SubIFDs { get; }
    public static ExifTag`1<Number> ImageWidth { get; }
    public static ExifTag`1<Number> ImageLength { get; }
    public static ExifTag`1<Number> RowsPerStrip { get; }
    public static ExifTag`1<Number> TileWidth { get; }
    public static ExifTag`1<Number> TileLength { get; }
    public static ExifTag`1<Number> BadFaxLines { get; }
    public static ExifTag`1<Number> ConsecutiveBadFaxLines { get; }
    public static ExifTag`1<Number> PixelXDimension { get; }
    public static ExifTag`1<Number> PixelYDimension { get; }
    public static ExifTag`1<Number[]> StripOffsets { get; }
    public static ExifTag`1<Number[]> StripByteCounts { get; }
    public static ExifTag`1<Number[]> TileByteCounts { get; }
    public static ExifTag`1<Number[]> TileOffsets { get; }
    public static ExifTag`1<Number[]> ImageLayer { get; }
    public static ExifTag`1<Rational> XPosition { get; }
    public static ExifTag`1<Rational> YPosition { get; }
    public static ExifTag`1<Rational> XResolution { get; }
    public static ExifTag`1<Rational> YResolution { get; }
    public static ExifTag`1<Rational> BatteryLevel { get; }
    public static ExifTag`1<Rational> ExposureTime { get; }
    public static ExifTag`1<Rational> FNumber { get; }
    public static ExifTag`1<Rational> MDScalePixel { get; }
    public static ExifTag`1<Rational> CompressedBitsPerPixel { get; }
    public static ExifTag`1<Rational> ApertureValue { get; }
    public static ExifTag`1<Rational> MaxApertureValue { get; }
    public static ExifTag`1<Rational> SubjectDistance { get; }
    public static ExifTag`1<Rational> FocalLength { get; }
    public static ExifTag`1<Rational> FlashEnergy2 { get; }
    public static ExifTag`1<Rational> FocalPlaneXResolution2 { get; }
    public static ExifTag`1<Rational> FocalPlaneYResolution2 { get; }
    public static ExifTag`1<Rational> ExposureIndex2 { get; }
    public static ExifTag`1<Rational> Humidity { get; }
    public static ExifTag`1<Rational> Pressure { get; }
    public static ExifTag`1<Rational> Acceleration { get; }
    public static ExifTag`1<Rational> FlashEnergy { get; }
    public static ExifTag`1<Rational> FocalPlaneXResolution { get; }
    public static ExifTag`1<Rational> FocalPlaneYResolution { get; }
    public static ExifTag`1<Rational> ExposureIndex { get; }
    public static ExifTag`1<Rational> DigitalZoomRatio { get; }
    public static ExifTag`1<Rational> GPSAltitude { get; }
    public static ExifTag`1<Rational> GPSDOP { get; }
    public static ExifTag`1<Rational> GPSSpeed { get; }
    public static ExifTag`1<Rational> GPSTrack { get; }
    public static ExifTag`1<Rational> GPSImgDirection { get; }
    public static ExifTag`1<Rational> GPSDestBearing { get; }
    public static ExifTag`1<Rational> GPSDestDistance { get; }
    public static ExifTag`1<Rational> GPSHPositioningError { get; }
    public static ExifTag`1<Rational[]> WhitePoint { get; }
    public static ExifTag`1<Rational[]> PrimaryChromaticities { get; }
    public static ExifTag`1<Rational[]> YCbCrCoefficients { get; }
    public static ExifTag`1<Rational[]> ReferenceBlackWhite { get; }
    public static ExifTag`1<Rational[]> GPSLatitude { get; }
    public static ExifTag`1<Rational[]> GPSLongitude { get; }
    public static ExifTag`1<Rational[]> GPSTimestamp { get; }
    public static ExifTag`1<Rational[]> GPSDestLatitude { get; }
    public static ExifTag`1<Rational[]> GPSDestLongitude { get; }
    public static ExifTag`1<Rational[]> LensSpecification { get; }
    public static ExifTag`1<ushort> OldSubfileType { get; }
    public static ExifTag`1<ushort> Compression { get; }
    public static ExifTag`1<ushort> PhotometricInterpretation { get; }
    public static ExifTag`1<ushort> Thresholding { get; }
    public static ExifTag`1<ushort> CellWidth { get; }
    public static ExifTag`1<ushort> CellLength { get; }
    public static ExifTag`1<ushort> FillOrder { get; }
    public static ExifTag`1<ushort> Orientation { get; }
    public static ExifTag`1<ushort> SamplesPerPixel { get; }
    public static ExifTag`1<ushort> PlanarConfiguration { get; }
    public static ExifTag`1<ushort> Predictor { get; }
    public static ExifTag`1<ushort> GrayResponseUnit { get; }
    public static ExifTag`1<ushort> ResolutionUnit { get; }
    public static ExifTag`1<ushort> CleanFaxData { get; }
    public static ExifTag`1<ushort> InkSet { get; }
    public static ExifTag`1<ushort> NumberOfInks { get; }
    public static ExifTag`1<ushort> DotRange { get; }
    public static ExifTag`1<ushort> Indexed { get; }
    public static ExifTag`1<ushort> OPIProxy { get; }
    public static ExifTag`1<ushort> JPEGProc { get; }
    public static ExifTag`1<ushort> JPEGRestartInterval { get; }
    public static ExifTag`1<ushort> YCbCrPositioning { get; }
    public static ExifTag`1<ushort> Rating { get; }
    public static ExifTag`1<ushort> RatingPercent { get; }
    public static ExifTag`1<ushort> ExposureProgram { get; }
    public static ExifTag`1<ushort> Interlace { get; }
    public static ExifTag`1<ushort> SelfTimerMode { get; }
    public static ExifTag`1<ushort> SensitivityType { get; }
    public static ExifTag`1<ushort> MeteringMode { get; }
    public static ExifTag`1<ushort> LightSource { get; }
    public static ExifTag`1<ushort> FocalPlaneResolutionUnit2 { get; }
    public static ExifTag`1<ushort> SensingMethod2 { get; }
    public static ExifTag`1<ushort> Flash { get; }
    public static ExifTag`1<ushort> ColorSpace { get; }
    public static ExifTag`1<ushort> FocalPlaneResolutionUnit { get; }
    public static ExifTag`1<ushort> SensingMethod { get; }
    public static ExifTag`1<ushort> CustomRendered { get; }
    public static ExifTag`1<ushort> ExposureMode { get; }
    public static ExifTag`1<ushort> WhiteBalance { get; }
    public static ExifTag`1<ushort> FocalLengthIn35mmFilm { get; }
    public static ExifTag`1<ushort> SceneCaptureType { get; }
    public static ExifTag`1<ushort> GainControl { get; }
    public static ExifTag`1<ushort> Contrast { get; }
    public static ExifTag`1<ushort> Saturation { get; }
    public static ExifTag`1<ushort> Sharpness { get; }
    public static ExifTag`1<ushort> SubjectDistanceRange { get; }
    public static ExifTag`1<ushort> GPSDifferential { get; }
    public static ExifTag`1<UInt16[]> BitsPerSample { get; }
    public static ExifTag`1<UInt16[]> MinSampleValue { get; }
    public static ExifTag`1<UInt16[]> MaxSampleValue { get; }
    public static ExifTag`1<UInt16[]> GrayResponseCurve { get; }
    public static ExifTag`1<UInt16[]> ColorMap { get; }
    public static ExifTag`1<UInt16[]> ExtraSamples { get; }
    public static ExifTag`1<UInt16[]> PageNumber { get; }
    public static ExifTag`1<UInt16[]> TransferFunction { get; }
    public static ExifTag`1<UInt16[]> HalftoneHints { get; }
    public static ExifTag`1<UInt16[]> SampleFormat { get; }
    public static ExifTag`1<UInt16[]> TransferRange { get; }
    public static ExifTag`1<UInt16[]> DefaultImageColor { get; }
    public static ExifTag`1<UInt16[]> JPEGLosslessPredictors { get; }
    public static ExifTag`1<UInt16[]> JPEGPointTransforms { get; }
    public static ExifTag`1<UInt16[]> YCbCrSubsampling { get; }
    public static ExifTag`1<UInt16[]> CFARepeatPatternDim { get; }
    public static ExifTag`1<UInt16[]> IntergraphPacketData { get; }
    public static ExifTag`1<UInt16[]> ISOSpeedRatings { get; }
    public static ExifTag`1<UInt16[]> SubjectArea { get; }
    public static ExifTag`1<UInt16[]> SubjectLocation { get; }
    public static ExifTag`1<SignedRational> ShutterSpeedValue { get; }
    public static ExifTag`1<SignedRational> BrightnessValue { get; }
    public static ExifTag`1<SignedRational> ExposureBiasValue { get; }
    public static ExifTag`1<SignedRational> AmbientTemperature { get; }
    public static ExifTag`1<SignedRational> WaterDepth { get; }
    public static ExifTag`1<SignedRational> CameraElevationAngle { get; }
    public static ExifTag`1<SignedRational[]> Decode { get; }
    public static ExifTag`1<Int16[]> TimeZoneOffset { get; }
    public static ExifTag`1<string> ImageDescription { get; }
    public static ExifTag`1<string> Make { get; }
    public static ExifTag`1<string> Model { get; }
    public static ExifTag`1<string> Software { get; }
    public static ExifTag`1<string> DateTime { get; }
    public static ExifTag`1<string> Artist { get; }
    public static ExifTag`1<string> HostComputer { get; }
    public static ExifTag`1<string> Copyright { get; }
    public static ExifTag`1<string> DocumentName { get; }
    public static ExifTag`1<string> PageName { get; }
    public static ExifTag`1<string> InkNames { get; }
    public static ExifTag`1<string> TargetPrinter { get; }
    public static ExifTag`1<string> ImageID { get; }
    public static ExifTag`1<string> MDLabName { get; }
    public static ExifTag`1<string> MDSampleInfo { get; }
    public static ExifTag`1<string> MDPrepDate { get; }
    public static ExifTag`1<string> MDPrepTime { get; }
    public static ExifTag`1<string> MDFileUnits { get; }
    public static ExifTag`1<string> SEMInfo { get; }
    public static ExifTag`1<string> SpectralSensitivity { get; }
    public static ExifTag`1<string> DateTimeOriginal { get; }
    public static ExifTag`1<string> DateTimeDigitized { get; }
    public static ExifTag`1<string> SubsecTime { get; }
    public static ExifTag`1<string> SubsecTimeOriginal { get; }
    public static ExifTag`1<string> SubsecTimeDigitized { get; }
    public static ExifTag`1<string> RelatedSoundFile { get; }
    public static ExifTag`1<string> FaxSubaddress { get; }
    public static ExifTag`1<string> OffsetTime { get; }
    public static ExifTag`1<string> OffsetTimeOriginal { get; }
    public static ExifTag`1<string> OffsetTimeDigitized { get; }
    public static ExifTag`1<string> SecurityClassification { get; }
    public static ExifTag`1<string> ImageHistory { get; }
    public static ExifTag`1<string> ImageUniqueID { get; }
    public static ExifTag`1<string> OwnerName { get; }
    public static ExifTag`1<string> SerialNumber { get; }
    public static ExifTag`1<string> LensMake { get; }
    public static ExifTag`1<string> LensModel { get; }
    public static ExifTag`1<string> LensSerialNumber { get; }
    public static ExifTag`1<string> GDALMetadata { get; }
    public static ExifTag`1<string> GDALNoData { get; }
    public static ExifTag`1<string> GPSLatitudeRef { get; }
    public static ExifTag`1<string> GPSLongitudeRef { get; }
    public static ExifTag`1<string> GPSSatellites { get; }
    public static ExifTag`1<string> GPSStatus { get; }
    public static ExifTag`1<string> GPSMeasureMode { get; }
    public static ExifTag`1<string> GPSSpeedRef { get; }
    public static ExifTag`1<string> GPSTrackRef { get; }
    public static ExifTag`1<string> GPSImgDirectionRef { get; }
    public static ExifTag`1<string> GPSMapDatum { get; }
    public static ExifTag`1<string> GPSDestLatitudeRef { get; }
    public static ExifTag`1<string> GPSDestLongitudeRef { get; }
    public static ExifTag`1<string> GPSDestBearingRef { get; }
    public static ExifTag`1<string> GPSDestDistanceRef { get; }
    public static ExifTag`1<string> GPSDateStamp { get; }
    public static ExifTag`1<string> XPTitle { get; }
    public static ExifTag`1<string> XPComment { get; }
    public static ExifTag`1<string> XPAuthor { get; }
    public static ExifTag`1<string> XPKeywords { get; }
    public static ExifTag`1<string> XPSubject { get; }
    public static ExifTag`1<Byte[]> JPEGTables { get; }
    public static ExifTag`1<Byte[]> OECF { get; }
    public static ExifTag`1<Byte[]> ExifVersion { get; }
    public static ExifTag`1<Byte[]> ComponentsConfiguration { get; }
    public static ExifTag`1<Byte[]> MakerNote { get; }
    public static ExifTag`1<Byte[]> FlashpixVersion { get; }
    public static ExifTag`1<Byte[]> SpatialFrequencyResponse { get; }
    public static ExifTag`1<Byte[]> SpatialFrequencyResponse2 { get; }
    public static ExifTag`1<Byte[]> Noise { get; }
    public static ExifTag`1<Byte[]> CFAPattern { get; }
    public static ExifTag`1<Byte[]> DeviceSettingDescription { get; }
    public static ExifTag`1<Byte[]> ImageSourceData { get; }
    public static ExifTag`1<byte> FileSource { get; }
    public static ExifTag`1<byte> SceneType { get; }
    internal ExifTag(ushort value);
    private static ExifTag();
    [CompilerGeneratedAttribute]
public static ExifTag`1<byte> get_FaxProfile();
    [CompilerGeneratedAttribute]
public static ExifTag`1<byte> get_ModeNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<byte> get_GPSAltitudeRef();
    public static ExifTag`1<Byte[]> get_ClipPath();
    public static ExifTag`1<Byte[]> get_VersionYear();
    public static ExifTag`1<Byte[]> get_XMP();
    public static ExifTag`1<Byte[]> get_IPTC();
    public static ExifTag`1<Byte[]> get_IccProfile();
    public static ExifTag`1<Byte[]> get_CFAPattern2();
    public static ExifTag`1<Byte[]> get_TIFFEPStandardID();
    public static ExifTag`1<Byte[]> get_GPSVersionID();
    public static ushort op_Explicit(ExifTag tag);
    public static bool op_Equality(ExifTag left, ExifTag right);
    public static bool op_Inequality(ExifTag left, ExifTag right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExifTag other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Double[]> get_PixelScale();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Double[]> get_IntergraphMatrix();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Double[]> get_ModelTiePoint();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Double[]> get_ModelTransform();
    [CompilerGeneratedAttribute]
public static ExifTag`1<EncodedString> get_UserComment();
    [CompilerGeneratedAttribute]
public static ExifTag`1<EncodedString> get_GPSProcessingMethod();
    [CompilerGeneratedAttribute]
public static ExifTag`1<EncodedString> get_GPSAreaInformation();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_SubfileType();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_SubIFDOffset();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_GPSIFDOffset();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_T4Options();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_T6Options();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_XClipPathUnits();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_YClipPathUnits();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_ProfileType();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_CodingMethods();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_T82ptions();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_JPEGInterchangeFormat();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_JPEGInterchangeFormatLength();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_MDFileTag();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_StandardOutputSensitivity();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_RecommendedExposureIndex();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_ISOSpeed();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_ISOSpeedLatitudeyyy();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_ISOSpeedLatitudezzz();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_FaxRecvParams();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_FaxRecvTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32> get_ImageNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_FreeOffsets();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_FreeByteCounts();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_ColorResponseUnit();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_SMinSampleValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_SMaxSampleValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_JPEGQTables();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_JPEGDCTables();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_JPEGACTables();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_StripRowCounts();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_IntergraphRegisters();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt32[]> get_SubIFDs();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_ImageWidth();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_ImageLength();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_RowsPerStrip();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_TileWidth();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_TileLength();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_BadFaxLines();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_ConsecutiveBadFaxLines();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_PixelXDimension();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number> get_PixelYDimension();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number[]> get_StripOffsets();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number[]> get_StripByteCounts();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number[]> get_TileByteCounts();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number[]> get_TileOffsets();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Number[]> get_ImageLayer();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_XPosition();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_YPosition();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_XResolution();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_YResolution();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_BatteryLevel();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_ExposureTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_MDScalePixel();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_CompressedBitsPerPixel();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_ApertureValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_MaxApertureValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_SubjectDistance();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FocalLength();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FlashEnergy2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FocalPlaneXResolution2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FocalPlaneYResolution2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_ExposureIndex2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_Humidity();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_Pressure();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_Acceleration();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FlashEnergy();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FocalPlaneXResolution();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_FocalPlaneYResolution();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_ExposureIndex();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_DigitalZoomRatio();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSAltitude();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSDOP();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSSpeed();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSTrack();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSImgDirection();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSDestBearing();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSDestDistance();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational> get_GPSHPositioningError();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_WhitePoint();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_PrimaryChromaticities();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_YCbCrCoefficients();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_ReferenceBlackWhite();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_GPSLatitude();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_GPSLongitude();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_GPSTimestamp();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_GPSDestLatitude();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_GPSDestLongitude();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Rational[]> get_LensSpecification();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_OldSubfileType();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Compression();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_PhotometricInterpretation();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Thresholding();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_CellWidth();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_CellLength();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_FillOrder();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Orientation();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SamplesPerPixel();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_PlanarConfiguration();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Predictor();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_GrayResponseUnit();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_ResolutionUnit();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_CleanFaxData();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_InkSet();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_NumberOfInks();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_DotRange();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Indexed();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_OPIProxy();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_JPEGProc();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_JPEGRestartInterval();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_YCbCrPositioning();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Rating();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_RatingPercent();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_ExposureProgram();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Interlace();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SelfTimerMode();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SensitivityType();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_MeteringMode();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_LightSource();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_FocalPlaneResolutionUnit2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SensingMethod2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Flash();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_ColorSpace();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_FocalPlaneResolutionUnit();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SensingMethod();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_CustomRendered();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_ExposureMode();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_WhiteBalance();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_FocalLengthIn35mmFilm();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SceneCaptureType();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_GainControl();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Contrast();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Saturation();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_Sharpness();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_SubjectDistanceRange();
    [CompilerGeneratedAttribute]
public static ExifTag`1<ushort> get_GPSDifferential();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_BitsPerSample();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_MinSampleValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_MaxSampleValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_GrayResponseCurve();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_ColorMap();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_ExtraSamples();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_PageNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_TransferFunction();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_HalftoneHints();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_SampleFormat();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_TransferRange();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_DefaultImageColor();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_JPEGLosslessPredictors();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_JPEGPointTransforms();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_YCbCrSubsampling();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_CFARepeatPatternDim();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_IntergraphPacketData();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_ISOSpeedRatings();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_SubjectArea();
    [CompilerGeneratedAttribute]
public static ExifTag`1<UInt16[]> get_SubjectLocation();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_ShutterSpeedValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_BrightnessValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_ExposureBiasValue();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_AmbientTemperature();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_WaterDepth();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational> get_CameraElevationAngle();
    [CompilerGeneratedAttribute]
public static ExifTag`1<SignedRational[]> get_Decode();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Int16[]> get_TimeZoneOffset();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_ImageDescription();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_Make();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_Model();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_Software();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_DateTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_Artist();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_HostComputer();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_Copyright();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_DocumentName();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_PageName();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_InkNames();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_TargetPrinter();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_ImageID();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_MDLabName();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_MDSampleInfo();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_MDPrepDate();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_MDPrepTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_MDFileUnits();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SEMInfo();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SpectralSensitivity();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_DateTimeOriginal();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_DateTimeDigitized();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SubsecTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SubsecTimeOriginal();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SubsecTimeDigitized();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_RelatedSoundFile();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_FaxSubaddress();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_OffsetTime();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_OffsetTimeOriginal();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_OffsetTimeDigitized();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SecurityClassification();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_ImageHistory();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_ImageUniqueID();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_OwnerName();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_SerialNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_LensMake();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_LensModel();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_LensSerialNumber();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GDALMetadata();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GDALNoData();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSLatitudeRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSLongitudeRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSSatellites();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSStatus();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSMeasureMode();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSSpeedRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSTrackRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSImgDirectionRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSMapDatum();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSDestLatitudeRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSDestLongitudeRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSDestBearingRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSDestDistanceRef();
    [CompilerGeneratedAttribute]
public static ExifTag`1<string> get_GPSDateStamp();
    public static ExifTag`1<string> get_XPTitle();
    public static ExifTag`1<string> get_XPComment();
    public static ExifTag`1<string> get_XPAuthor();
    public static ExifTag`1<string> get_XPKeywords();
    public static ExifTag`1<string> get_XPSubject();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_JPEGTables();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_OECF();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_ExifVersion();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_ComponentsConfiguration();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_MakerNote();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_FlashpixVersion();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_SpatialFrequencyResponse();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_SpatialFrequencyResponse2();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_Noise();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_CFAPattern();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_DeviceSettingDescription();
    [CompilerGeneratedAttribute]
public static ExifTag`1<Byte[]> get_ImageSourceData();
    [CompilerGeneratedAttribute]
public static ExifTag`1<byte> get_FileSource();
    [CompilerGeneratedAttribute]
public static ExifTag`1<byte> get_SceneType();
}
public class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifTag`1 : ExifTag {
    internal ExifTag`1(ExifTagValue value);
}
[AttributeUsageAttribute("256")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifTagDescriptionAttribute : Attribute {
    [NullableContextAttribute("1")]
public ExifTagDescriptionAttribute(object value, string description);
    [NullableContextAttribute("2")]
public static bool TryGetDescription(ExifTag tag, object value, String& description);
}
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifTags : object {
    [NullableContextAttribute("1")]
public static ExifParts GetPart(ExifTag tag);
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifTagValue : Enum {
    public int value__;
    public static ExifTagValue Unknown;
    public static ExifTagValue SubIFDOffset;
    public static ExifTagValue GPSIFDOffset;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Indicates a file conforming to R98 file specification of Recommended Exif Interoperability Rules (ExifR98) or to DCF basic file stipulated by Design Rule for Camera File System.")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Indicates a file conforming to DCF thumbnail file stipulated by Design rule for Camera File System.")]
public static ExifTagValue InteroperabilityIndex;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Full-resolution Image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Reduced-resolution image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Single page of multi-page image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Single page of multi-page reduced-resolution image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Transparency mask")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Transparency mask of reduced-resolution image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Transparency mask of multi-page image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Transparency mask of reduced-resolution multi-page image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Alternate reduced-resolution image ")]
public static ExifTagValue SubfileType;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Full-resolution Image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Reduced-resolution image")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Single page of multi-page image")]
public static ExifTagValue OldSubfileType;
    public static ExifTagValue ImageWidth;
    public static ExifTagValue ImageLength;
    public static ExifTagValue BitsPerSample;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Uncompressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "CCITT 1D")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "T4/Group 3 Fax")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "T6/Group 4 Fax")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "LZW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JPEG (old-style)")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JPEG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Adobe Deflate")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG B&W")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG Color")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JPEG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Kodak 262")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Next")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Sony ARW Compressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Packed RAW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Samsung SRW Compressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "CCIRLEW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Samsung SRW Compressed 2")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "PackBits")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Thunderscan")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Kodak KDC Compressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "IT8CTPAD")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "IT8LW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "IT8MP")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "IT8BL")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "PixarFilm")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "PixarLog")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Deflate")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "DCS")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "SGILog")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "SGILog24")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JPEG 2000")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Nikon NEF Compressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG2 TIFF FX")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Microsoft Document Imaging (MDI) Binary Level Codec")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Microsoft Document Imaging (MDI) Progressive Transform Codec")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Microsoft Document Imaging (MDI) Vector")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Lossy JPEG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Kodak DCR Compressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Pentax PEF Compressed")]
public static ExifTagValue Compression;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "WhiteIsZero")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "BlackIsZero")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "RGB")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "RGB Palette")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Transparency Mask")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "CMYK")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "YCbCr")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "CIELab")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "ICCLab")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "TULab")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Color Filter Array")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Pixar LogL")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Pixar LogLuv")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Linear Raw")]
public static ExifTagValue PhotometricInterpretation;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "No dithering or halftoning")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Ordered dither or halftone")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Randomized dither")]
public static ExifTagValue Thresholding;
    public static ExifTagValue CellWidth;
    public static ExifTagValue CellLength;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Normal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Reversed")]
public static ExifTagValue FillOrder;
    public static ExifTagValue DocumentName;
    public static ExifTagValue ImageDescription;
    public static ExifTagValue Make;
    public static ExifTagValue Model;
    public static ExifTagValue StripOffsets;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Horizontal (normal)")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Mirror horizontal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Rotate 180")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Mirror vertical")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Mirror horizontal and rotate 270 CW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Rotate 90 CW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Mirror horizontal and rotate 90 CW")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Rotate 270 CW")]
public static ExifTagValue Orientation;
    public static ExifTagValue SamplesPerPixel;
    public static ExifTagValue RowsPerStrip;
    public static ExifTagValue StripByteCounts;
    public static ExifTagValue MinSampleValue;
    public static ExifTagValue MaxSampleValue;
    public static ExifTagValue XResolution;
    public static ExifTagValue YResolution;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Chunky")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Planar")]
public static ExifTagValue PlanarConfiguration;
    public static ExifTagValue PageName;
    public static ExifTagValue XPosition;
    public static ExifTagValue YPosition;
    public static ExifTagValue FreeOffsets;
    public static ExifTagValue FreeByteCounts;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "0.1")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "0.001")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "0.0001")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "1e-05")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "1e-06")]
public static ExifTagValue GrayResponseUnit;
    public static ExifTagValue GrayResponseCurve;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "2-Dimensional encoding")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Uncompressed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fill bits added")]
public static ExifTagValue T4Options;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Uncompressed")]
public static ExifTagValue T6Options;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "None")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Inches")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Centimeter")]
public static ExifTagValue ResolutionUnit;
    public static ExifTagValue PageNumber;
    public static ExifTagValue ColorResponseUnit;
    public static ExifTagValue TransferFunction;
    public static ExifTagValue Software;
    public static ExifTagValue DateTime;
    public static ExifTagValue Artist;
    public static ExifTagValue HostComputer;
    public static ExifTagValue Predictor;
    public static ExifTagValue WhitePoint;
    public static ExifTagValue PrimaryChromaticities;
    public static ExifTagValue ColorMap;
    public static ExifTagValue HalftoneHints;
    public static ExifTagValue TileWidth;
    public static ExifTagValue TileLength;
    public static ExifTagValue TileOffsets;
    public static ExifTagValue TileByteCounts;
    public static ExifTagValue BadFaxLines;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Clean")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Regenerated")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unclean")]
public static ExifTagValue CleanFaxData;
    public static ExifTagValue ConsecutiveBadFaxLines;
    public static ExifTagValue SubIFDs;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "CMYK")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Not CMYK")]
public static ExifTagValue InkSet;
    public static ExifTagValue InkNames;
    public static ExifTagValue NumberOfInks;
    public static ExifTagValue DotRange;
    public static ExifTagValue TargetPrinter;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unspecified")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Associated Alpha")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unassociated Alpha")]
public static ExifTagValue ExtraSamples;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unsigned")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Signed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Float")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Undefined")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Complex int")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Complex float")]
public static ExifTagValue SampleFormat;
    public static ExifTagValue SMinSampleValue;
    public static ExifTagValue SMaxSampleValue;
    public static ExifTagValue TransferRange;
    public static ExifTagValue ClipPath;
    public static ExifTagValue XClipPathUnits;
    public static ExifTagValue YClipPathUnits;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Not indexed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Indexed")]
public static ExifTagValue Indexed;
    public static ExifTagValue JPEGTables;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Higher resolution image does not exist")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Higher resolution image exists")]
public static ExifTagValue OPIProxy;
    public static ExifTagValue GlobalParametersIFD;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unspecified")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Group 3 FAX")]
public static ExifTagValue ProfileType;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unknown")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Minimal B&W lossless, S")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Extended B&W lossless, F")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Lossless JBIG B&W, J")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Lossy color and grayscale, C")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Lossless color and grayscale, L")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Mixed raster content, M")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Profile T")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Multi Profiles")]
public static ExifTagValue FaxProfile;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unspecified compression")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Modified Huffman")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Modified Read")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Modified MR")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Baseline JPEG")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "JBIG color")]
public static ExifTagValue CodingMethods;
    public static ExifTagValue VersionYear;
    public static ExifTagValue ModeNumber;
    public static ExifTagValue Decode;
    public static ExifTagValue DefaultImageColor;
    public static ExifTagValue T82ptions;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Baseline")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Lossless")]
public static ExifTagValue JPEGProc;
    public static ExifTagValue JPEGInterchangeFormat;
    public static ExifTagValue JPEGInterchangeFormatLength;
    public static ExifTagValue JPEGRestartInterval;
    public static ExifTagValue JPEGLosslessPredictors;
    public static ExifTagValue JPEGPointTransforms;
    public static ExifTagValue JPEGQTables;
    public static ExifTagValue JPEGDCTables;
    public static ExifTagValue JPEGACTables;
    public static ExifTagValue YCbCrCoefficients;
    public static ExifTagValue YCbCrSubsampling;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Centered")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Co-sited")]
public static ExifTagValue YCbCrPositioning;
    public static ExifTagValue ReferenceBlackWhite;
    public static ExifTagValue StripRowCounts;
    public static ExifTagValue XMP;
    public static ExifTagValue Rating;
    public static ExifTagValue RatingPercent;
    public static ExifTagValue ImageID;
    public static ExifTagValue WangAnnotation;
    public static ExifTagValue CFARepeatPatternDim;
    public static ExifTagValue CFAPattern2;
    public static ExifTagValue BatteryLevel;
    public static ExifTagValue Copyright;
    public static ExifTagValue ExposureTime;
    public static ExifTagValue FNumber;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Squary root data format")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Linear data format")]
public static ExifTagValue MDFileTag;
    public static ExifTagValue MDScalePixel;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "lowest possible")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "low range")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "high range")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "highest possible")]
public static ExifTagValue MDColorTable;
    public static ExifTagValue MDLabName;
    public static ExifTagValue MDSampleInfo;
    public static ExifTagValue MDPrepDate;
    public static ExifTagValue MDPrepTime;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Densitometer")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "PhosphorImager")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "FluorImager")]
public static ExifTagValue MDFileUnits;
    public static ExifTagValue PixelScale;
    public static ExifTagValue IPTC;
    public static ExifTagValue IntergraphPacketData;
    public static ExifTagValue IntergraphRegisters;
    public static ExifTagValue IntergraphMatrix;
    public static ExifTagValue ModelTiePoint;
    public static ExifTagValue SEMInfo;
    public static ExifTagValue ModelTransform;
    public static ExifTagValue Photoshop;
    public static ExifTagValue IccProfile;
    public static ExifTagValue GeoKeyDirectoryTag;
    public static ExifTagValue GeoDoubleParamsTag;
    public static ExifTagValue GeoAsciiParamsTag;
    public static ExifTagValue ImageLayer;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Not Defined")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Manual")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Program AE")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Aperture-priority AE")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Shutter speed priority AE")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Creative (Slow speed)")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Action (High speed)")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Portrait")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Landscape")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Bulb")]
public static ExifTagValue ExposureProgram;
    public static ExifTagValue SpectralSensitivity;
    public static ExifTagValue ISOSpeedRatings;
    public static ExifTagValue OECF;
    public static ExifTagValue Interlace;
    public static ExifTagValue TimeZoneOffset;
    public static ExifTagValue SelfTimerMode;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unknown")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Output Sensitivity")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Recommended Exposure Index")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "ISO Speed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Output Sensitivity and Recommended Exposure Index")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Output Sensitivity and ISO Speed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Recommended Exposure Index and ISO Speed")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Output Sensitivity, Recommended Exposure Index and ISO Speed")]
public static ExifTagValue SensitivityType;
    public static ExifTagValue StandardOutputSensitivity;
    public static ExifTagValue RecommendedExposureIndex;
    public static ExifTagValue ISOSpeed;
    public static ExifTagValue ISOSpeedLatitudeyyy;
    public static ExifTagValue ISOSpeedLatitudezzz;
    public static ExifTagValue FaxRecvParams;
    public static ExifTagValue FaxSubaddress;
    public static ExifTagValue FaxRecvTime;
    public static ExifTagValue ExifVersion;
    public static ExifTagValue DateTimeOriginal;
    public static ExifTagValue DateTimeDigitized;
    public static ExifTagValue OffsetTime;
    public static ExifTagValue OffsetTimeOriginal;
    public static ExifTagValue OffsetTimeDigitized;
    public static ExifTagValue ComponentsConfiguration;
    public static ExifTagValue CompressedBitsPerPixel;
    public static ExifTagValue ShutterSpeedValue;
    public static ExifTagValue ApertureValue;
    public static ExifTagValue BrightnessValue;
    public static ExifTagValue ExposureBiasValue;
    public static ExifTagValue MaxApertureValue;
    public static ExifTagValue SubjectDistance;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unknown")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Average")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Center-weighted average")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Spot")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Multi-spot")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Multi-segment")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Partial")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Other")]
public static ExifTagValue MeteringMode;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unknown")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Daylight")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Tungsten (Incandescent)")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Flash")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fine Weather")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Cloudy")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Shade")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Daylight Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Day White Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Cool White Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "White Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Warm White Fluorescent")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Light A")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Light B")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard Light C")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "D55")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "D65")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "D75")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "D50")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "ISO Studio Tungsten")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Other")]
public static ExifTagValue LightSource;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "No Flash")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired, Return detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Did not fire")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Fired")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Return detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Off, Did not fire")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Off, Did not fire, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Did not fire")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired, Return detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "No flash function")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Off, No flash function")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired, Red-eye reduction")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired, Red-eye reduction, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Fired, Red-eye reduction, Return detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Red-eye reduction")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Red-eye reduction, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "On, Red-eye reduction, Return detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Off, Red-eye reduction")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Did not fire, Red-eye reduction")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired, Red-eye reduction")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired, Red-eye reduction, Return not detected")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto, Fired, Red-eye reduction, Return detected")]
public static ExifTagValue Flash;
    public static ExifTagValue FocalLength;
    public static ExifTagValue FlashEnergy2;
    public static ExifTagValue SpatialFrequencyResponse2;
    public static ExifTagValue Noise;
    public static ExifTagValue FocalPlaneXResolution2;
    public static ExifTagValue FocalPlaneYResolution2;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "None")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Inches")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Centimeter")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Millimeter")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Micrometer")]
public static ExifTagValue FocalPlaneResolutionUnit2;
    public static ExifTagValue ImageNumber;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Confidential")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Restricted")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Secret")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Top Secret")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unclassified")]
public static ExifTagValue SecurityClassification;
    public static ExifTagValue ImageHistory;
    public static ExifTagValue SubjectArea;
    public static ExifTagValue ExposureIndex2;
    public static ExifTagValue TIFFEPStandardID;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Not defined")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "One-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Two-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Three-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Color sequential area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Trilinear")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Color sequential linear")]
public static ExifTagValue SensingMethod2;
    public static ExifTagValue MakerNote;
    public static ExifTagValue UserComment;
    public static ExifTagValue SubsecTime;
    public static ExifTagValue SubsecTimeOriginal;
    public static ExifTagValue SubsecTimeDigitized;
    public static ExifTagValue ImageSourceData;
    public static ExifTagValue AmbientTemperature;
    public static ExifTagValue Humidity;
    public static ExifTagValue Pressure;
    public static ExifTagValue WaterDepth;
    public static ExifTagValue Acceleration;
    public static ExifTagValue CameraElevationAngle;
    public static ExifTagValue XPTitle;
    public static ExifTagValue XPComment;
    public static ExifTagValue XPAuthor;
    public static ExifTagValue XPKeywords;
    public static ExifTagValue XPSubject;
    public static ExifTagValue FlashpixVersion;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "sRGB")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Adobe RGB")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Wide Gamut RGB")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "ICC Profile")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Uncalibrated")]
public static ExifTagValue ColorSpace;
    public static ExifTagValue PixelXDimension;
    public static ExifTagValue PixelYDimension;
    public static ExifTagValue RelatedSoundFile;
    public static ExifTagValue InteroperabilityIFD;
    public static ExifTagValue FlashEnergy;
    public static ExifTagValue SpatialFrequencyResponse;
    public static ExifTagValue FocalPlaneXResolution;
    public static ExifTagValue FocalPlaneYResolution;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "None")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Inches")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Centimeter")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Millimeter")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Micrometer")]
public static ExifTagValue FocalPlaneResolutionUnit;
    public static ExifTagValue SubjectLocation;
    public static ExifTagValue ExposureIndex;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Not defined")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "One-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Two-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Three-chip color area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Color sequential area")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Trilinear")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Color sequential linear")]
public static ExifTagValue SensingMethod;
    public static ExifTagValue FileSource;
    public static ExifTagValue SceneType;
    public static ExifTagValue CFAPattern;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Normal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Custom")]
public static ExifTagValue CustomRendered;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Manual")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto bracket")]
public static ExifTagValue ExposureMode;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Auto")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Manual")]
public static ExifTagValue WhiteBalance;
    public static ExifTagValue DigitalZoomRatio;
    public static ExifTagValue FocalLengthIn35mmFilm;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Standard")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Landscape")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Portrait")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Night")]
public static ExifTagValue SceneCaptureType;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "None")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Low gain up")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "High gain up")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Low gain down")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "High gain down")]
public static ExifTagValue GainControl;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Normal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Low")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "High")]
public static ExifTagValue Contrast;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Normal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Low")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "High")]
public static ExifTagValue Saturation;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Normal")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Soft")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Hard")]
public static ExifTagValue Sharpness;
    public static ExifTagValue DeviceSettingDescription;
    [ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Unknown")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Macro")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Close")]
[ExifTagDescriptionAttribute("Mono.Cecil.CustomAttributeArgument", "Distant")]
public static ExifTagValue SubjectDistanceRange;
    public static ExifTagValue ImageUniqueID;
    public static ExifTagValue OwnerName;
    public static ExifTagValue SerialNumber;
    public static ExifTagValue LensSpecification;
    public static ExifTagValue LensMake;
    public static ExifTagValue LensModel;
    public static ExifTagValue LensSerialNumber;
    public static ExifTagValue GDALMetadata;
    public static ExifTagValue GDALNoData;
    public static ExifTagValue GPSVersionID;
    public static ExifTagValue GPSLatitudeRef;
    public static ExifTagValue GPSLatitude;
    public static ExifTagValue GPSLongitudeRef;
    public static ExifTagValue GPSLongitude;
    public static ExifTagValue GPSAltitudeRef;
    public static ExifTagValue GPSAltitude;
    public static ExifTagValue GPSTimestamp;
    public static ExifTagValue GPSSatellites;
    public static ExifTagValue GPSStatus;
    public static ExifTagValue GPSMeasureMode;
    public static ExifTagValue GPSDOP;
    public static ExifTagValue GPSSpeedRef;
    public static ExifTagValue GPSSpeed;
    public static ExifTagValue GPSTrackRef;
    public static ExifTagValue GPSTrack;
    public static ExifTagValue GPSImgDirectionRef;
    public static ExifTagValue GPSImgDirection;
    public static ExifTagValue GPSMapDatum;
    public static ExifTagValue GPSDestLatitudeRef;
    public static ExifTagValue GPSDestLatitude;
    public static ExifTagValue GPSDestLongitudeRef;
    public static ExifTagValue GPSDestLongitude;
    public static ExifTagValue GPSDestBearingRef;
    public static ExifTagValue GPSDestBearing;
    public static ExifTagValue GPSDestDistanceRef;
    public static ExifTagValue GPSDestDistance;
    public static ExifTagValue GPSProcessingMethod;
    public static ExifTagValue GPSAreaInformation;
    public static ExifTagValue GPSDateStamp;
    public static ExifTagValue GPSDifferential;
    public static ExifTagValue GPSHPositioningError;
    public static ExifTagValue OceScanjobDescription;
    public static ExifTagValue OceApplicationSelector;
    public static ExifTagValue OceIdentificationNumber;
    public static ExifTagValue OceImageLogicCharacteristics;
    public static ExifTagValue AliasLayerMetadata;
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifUcs2String : ExifValue`1<string> {
    public ExifDataType DataType { get; }
    protected string StringValue { get; }
    [NullableContextAttribute("1")]
public ExifUcs2String(ExifTag`1<string> tag);
    public ExifUcs2String(ExifTagValue tag);
    [NullableContextAttribute("1")]
private ExifUcs2String(ExifUcs2String value);
    public virtual ExifDataType get_DataType();
    protected virtual string get_StringValue();
    public virtual object GetValue();
    public virtual bool TrySetValue(object value);
    [NullableContextAttribute("1")]
public virtual IExifValue DeepClone();
}
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifUcs2StringHelpers : object {
    [NullableAttribute("1")]
public static Encoding Ucs2Encoding { get; }
    [NullableContextAttribute("1")]
public static Encoding get_Ucs2Encoding();
    public static bool IsUcs2Tag(ExifTagValue tag);
    public static int Write(string value, Span`1<byte> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifValue : object {
    [CompilerGeneratedAttribute]
private ExifDataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private ExifTag <Tag>k__BackingField;
    public ExifDataType DataType { get; }
    public bool IsArray { get; }
    public ExifTag Tag { get; }
    protected ExifValue(ExifTag tag);
    protected ExifValue(ExifTagValue tag);
    internal ExifValue(ExifValue other);
    [CompilerGeneratedAttribute]
public virtual ExifDataType get_DataType();
    [CompilerGeneratedAttribute]
public virtual bool get_IsArray();
    [CompilerGeneratedAttribute]
public sealed virtual ExifTag get_Tag();
    public static bool op_Equality(ExifValue left, ExifTag right);
    public static bool op_Inequality(ExifValue left, ExifTag right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExifTag other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public abstract virtual object GetValue();
    [NullableContextAttribute("2")]
public abstract virtual bool TrySetValue(object value);
    public abstract virtual IExifValue DeepClone();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifValue`1 : ExifValue {
    [CompilerGeneratedAttribute]
private TValueType <Value>k__BackingField;
    public TValueType Value { get; public set; }
    protected string StringValue { get; }
    [NullableContextAttribute("1")]
protected ExifValue`1(ExifTag`1<TValueType> tag);
    protected ExifValue`1(ExifTagValue tag);
    [NullableContextAttribute("1")]
internal ExifValue`1(ExifValue value);
    [CompilerGeneratedAttribute]
public sealed virtual TValueType get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(TValueType value);
    protected abstract virtual string get_StringValue();
    public virtual object GetValue();
    public virtual bool TrySetValue(object value);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifValues : object {
    public static ExifValue Create(ExifTagValue tag);
    [NullableContextAttribute("1")]
public static ExifValue Create(ExifTag tag);
    public static ExifValue Create(ExifTagValue tag, ExifDataType dataType, ulong numberOfComponents);
    public static ExifValue Create(ExifTagValue tag, ExifDataType dataType, bool isArray);
    private static object CreateValue(ExifTagValue tag);
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.ExifWriter : object {
    private ExifParts allowedParts;
    [NullableAttribute("1")]
private IList`1<IExifValue> values;
    [NullableAttribute("2")]
private List`1<int> dataOffsets;
    [NullableAttribute("1")]
private List`1<IExifValue> ifdValues;
    [NullableAttribute("1")]
private List`1<IExifValue> exifValues;
    [NullableAttribute("1")]
private List`1<IExifValue> gpsValues;
    [NullableContextAttribute("1")]
public ExifWriter(IList`1<IExifValue> values, ExifParts allowedParts);
    [NullableContextAttribute("1")]
public Byte[] GetData();
    private static int WriteSingle(float value, Span`1<byte> destination, int offset);
    private static int WriteDouble(double value, Span`1<byte> destination, int offset);
    private static int Write(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int offset);
    private static int WriteInt16(short value, Span`1<byte> destination, int offset);
    private static int WriteUInt16(ushort value, Span`1<byte> destination, int offset);
    private static int WriteUInt32(UInt32 value, Span`1<byte> destination, int offset);
    private static int WriteInt64(long value, Span`1<byte> destination, int offset);
    private static int WriteUInt64(ulong value, Span`1<byte> destination, int offset);
    private static int WriteInt32(int value, Span`1<byte> destination, int offset);
    [NullableContextAttribute("1")]
private static IExifValue GetOffsetValue(List`1<IExifValue> ifdValues, List`1<IExifValue> values, ExifTag offset);
    [NullableContextAttribute("1")]
private List`1<IExifValue> GetPartValues(ExifParts part);
    [NullableContextAttribute("1")]
private static bool HasValue(IExifValue exifValue);
    [NullableContextAttribute("1")]
private static UInt32 GetLength(IList`1<IExifValue> values);
    [NullableContextAttribute("1")]
internal static UInt32 GetLength(IExifValue value);
    [NullableContextAttribute("1")]
internal static UInt32 GetNumberOfComponents(IExifValue exifValue);
    private static int WriteArray(IExifValue value, Span`1<byte> destination, int offset);
    private int WriteData(UInt32 startIndex, List`1<IExifValue> values, Span`1<byte> destination, int offset);
    private int WriteHeaders(List`1<IExifValue> values, Span`1<byte> destination, int offset);
    private static void WriteRational(Span`1<byte> destination, Rational& value);
    private static void WriteSignedRational(Span`1<byte> destination, SignedRational& value);
    private static int WriteValue(ExifDataType dataType, object value, Span`1<byte> destination, int offset);
    internal static int WriteValue(IExifValue exifValue, Span`1<byte> destination, int offset);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Metadata.Profiles.Exif.IExifValue {
    public ExifDataType DataType { get; }
    public bool IsArray { get; }
    public ExifTag Tag { get; }
    public abstract virtual ExifDataType get_DataType();
    public abstract virtual bool get_IsArray();
    public abstract virtual ExifTag get_Tag();
    [NullableContextAttribute("2")]
public abstract virtual object GetValue();
    [NullableContextAttribute("2")]
public abstract virtual bool TrySetValue(object value);
}
[NullableContextAttribute("2")]
public interface SixLabors.ImageSharp.Metadata.Profiles.Exif.IExifValue`1 {
    public TValueType Value { get; public set; }
    public abstract virtual TValueType get_Value();
    public abstract virtual void set_Value(TValueType value);
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Exif.UnkownExifTag : ExifTag {
    internal UnkownExifTag(ExifTagValue value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccBAcsProcessElement : IccMultiProcessElement {
    public IccBAcsProcessElement(int inChannelCount, int outChannelCount);
    public sealed virtual bool Equals(IccBAcsProcessElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccChromaticityTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccColorantEncoding <ColorantType>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[][] <ChannelValues>k__BackingField;
    public int ChannelCount { get; }
    public IccColorantEncoding ColorantType { get; }
    public Double[][] ChannelValues { get; }
    public IccChromaticityTagDataEntry(IccColorantEncoding colorantType);
    public IccChromaticityTagDataEntry(Double[][] channelValues);
    public IccChromaticityTagDataEntry(IccColorantEncoding colorantType, IccProfileTag tagSignature);
    public IccChromaticityTagDataEntry(Double[][] channelValues, IccProfileTag tagSignature);
    private IccChromaticityTagDataEntry(IccColorantEncoding colorantType, Double[][] channelValues, IccProfileTag tagSignature);
    public int get_ChannelCount();
    [CompilerGeneratedAttribute]
public IccColorantEncoding get_ColorantType();
    [CompilerGeneratedAttribute]
public Double[][] get_ChannelValues();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccChromaticityTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static Double[][] GetColorantArray(IccColorantEncoding colorantType);
    private bool EqualsChannelValues(IccChromaticityTagDataEntry entry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccClut : object {
    [CompilerGeneratedAttribute]
private Single[][] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private IccClutDataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <GridPointCount>k__BackingField;
    public Single[][] Values { get; }
    public IccClutDataType DataType { get; }
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public Byte[] GridPointCount { get; }
    public IccClut(Single[][] values, Byte[] gridPointCount, IccClutDataType type);
    public IccClut(UInt16[][] values, Byte[] gridPointCount);
    public IccClut(Byte[][] values, Byte[] gridPointCount);
    [CompilerGeneratedAttribute]
public Single[][] get_Values();
    [CompilerGeneratedAttribute]
public IccClutDataType get_DataType();
    [CompilerGeneratedAttribute]
public int get_InputChannelCount();
    [CompilerGeneratedAttribute]
public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public Byte[] get_GridPointCount();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccClut other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool EqualsValuesArray(IccClut other);
    private void CheckValues();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <CheckValues>b__22_0(Single[] t);
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccClutDataType : Enum {
    public int value__;
    public static IccClutDataType Float;
    public static IccClutDataType UInt8;
    public static IccClutDataType UInt16;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccClutProcessElement : IccMultiProcessElement {
    [CompilerGeneratedAttribute]
private IccClut <ClutValue>k__BackingField;
    public IccClut ClutValue { get; }
    public IccClutProcessElement(IccClut clutValue);
    [CompilerGeneratedAttribute]
public IccClut get_ClutValue();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccMultiProcessElement other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccClutProcessElement other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccColorantEncoding : Enum {
    public ushort value__;
    public static IccColorantEncoding Unknown;
    public static IccColorantEncoding ItuRBt709_2;
    public static IccColorantEncoding SmpteRp145;
    public static IccColorantEncoding EbuTech3213E;
    public static IccColorantEncoding P22;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccColorantOrderTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Byte[] <ColorantNumber>k__BackingField;
    public Byte[] ColorantNumber { get; }
    public IccColorantOrderTagDataEntry(Byte[] colorantNumber);
    public IccColorantOrderTagDataEntry(Byte[] colorantNumber, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Byte[] get_ColorantNumber();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccColorantOrderTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccColorantTableEntry : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Pcs1>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Pcs2>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Pcs3>k__BackingField;
    public string Name { get; }
    public ushort Pcs1 { get; }
    public ushort Pcs2 { get; }
    public ushort Pcs3 { get; }
    public IccColorantTableEntry(string name);
    public IccColorantTableEntry(string name, ushort pcs1, ushort pcs2, ushort pcs3);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ushort get_Pcs1();
    [CompilerGeneratedAttribute]
public ushort get_Pcs2();
    [CompilerGeneratedAttribute]
public ushort get_Pcs3();
    public static bool op_Equality(IccColorantTableEntry left, IccColorantTableEntry right);
    public static bool op_Inequality(IccColorantTableEntry left, IccColorantTableEntry right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccColorantTableEntry other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccColorantTableTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccColorantTableEntry[] <ColorantData>k__BackingField;
    public IccColorantTableEntry[] ColorantData { get; }
    public IccColorantTableTagDataEntry(IccColorantTableEntry[] colorantData);
    public IccColorantTableTagDataEntry(IccColorantTableEntry[] colorantData, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccColorantTableEntry[] get_ColorantData();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccColorantTableTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccColorSpaceType : Enum {
    public UInt32 value__;
    public static IccColorSpaceType CieXyz;
    public static IccColorSpaceType CieLab;
    public static IccColorSpaceType CieLuv;
    public static IccColorSpaceType YCbCr;
    public static IccColorSpaceType CieYxy;
    public static IccColorSpaceType Rgb;
    public static IccColorSpaceType Gray;
    public static IccColorSpaceType Hsv;
    public static IccColorSpaceType Hls;
    public static IccColorSpaceType Cmyk;
    public static IccColorSpaceType Cmy;
    public static IccColorSpaceType Color2;
    public static IccColorSpaceType Color3;
    public static IccColorSpaceType Color4;
    public static IccColorSpaceType Color5;
    public static IccColorSpaceType Color6;
    public static IccColorSpaceType Color7;
    public static IccColorSpaceType Color8;
    public static IccColorSpaceType Color9;
    public static IccColorSpaceType Color10;
    public static IccColorSpaceType Color11;
    public static IccColorSpaceType Color12;
    public static IccColorSpaceType Color13;
    public static IccColorSpaceType Color14;
    public static IccColorSpaceType Color15;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCrdInfoTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private string <PostScriptProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RenderingIntent0Crd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RenderingIntent1Crd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RenderingIntent2Crd>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RenderingIntent3Crd>k__BackingField;
    public string PostScriptProductName { get; }
    public string RenderingIntent0Crd { get; }
    public string RenderingIntent1Crd { get; }
    public string RenderingIntent2Crd { get; }
    public string RenderingIntent3Crd { get; }
    public IccCrdInfoTagDataEntry(string postScriptProductName, string renderingIntent0Crd, string renderingIntent1Crd, string renderingIntent2Crd, string renderingIntent3Crd);
    public IccCrdInfoTagDataEntry(string postScriptProductName, string renderingIntent0Crd, string renderingIntent1Crd, string renderingIntent2Crd, string renderingIntent3Crd, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public string get_PostScriptProductName();
    [CompilerGeneratedAttribute]
public string get_RenderingIntent0Crd();
    [CompilerGeneratedAttribute]
public string get_RenderingIntent1Crd();
    [CompilerGeneratedAttribute]
public string get_RenderingIntent2Crd();
    [CompilerGeneratedAttribute]
public string get_RenderingIntent3Crd();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccCrdInfoTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCurveMeasurementEncodings : Enum {
    public UInt32 value__;
    public static IccCurveMeasurementEncodings StatusA;
    public static IccCurveMeasurementEncodings StatusE;
    public static IccCurveMeasurementEncodings StatusI;
    public static IccCurveMeasurementEncodings StatusT;
    public static IccCurveMeasurementEncodings StatusM;
    public static IccCurveMeasurementEncodings DinE;
    public static IccCurveMeasurementEncodings DinEPol;
    public static IccCurveMeasurementEncodings DinI;
    public static IccCurveMeasurementEncodings DinIPol;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCurveSegment : object {
    [CompilerGeneratedAttribute]
private IccCurveSegmentSignature <Signature>k__BackingField;
    public IccCurveSegmentSignature Signature { get; }
    protected IccCurveSegment(IccCurveSegmentSignature signature);
    [CompilerGeneratedAttribute]
public IccCurveSegmentSignature get_Signature();
    public virtual bool Equals(IccCurveSegment other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCurveSegmentSignature : Enum {
    public UInt32 value__;
    public static IccCurveSegmentSignature FormulaCurve;
    public static IccCurveSegmentSignature SampledCurve;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCurveSetProcessElement : IccMultiProcessElement {
    [CompilerGeneratedAttribute]
private IccOneDimensionalCurve[] <Curves>k__BackingField;
    public IccOneDimensionalCurve[] Curves { get; }
    public IccCurveSetProcessElement(IccOneDimensionalCurve[] curves);
    [CompilerGeneratedAttribute]
public IccOneDimensionalCurve[] get_Curves();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccMultiProcessElement other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccCurveSetProcessElement other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccCurveTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Single[] <CurveData>k__BackingField;
    public Single[] CurveData { get; }
    public float Gamma { get; }
    public bool IsIdentityResponse { get; }
    public bool IsGamma { get; }
    public IccCurveTagDataEntry(float gamma);
    public IccCurveTagDataEntry(Single[] curveData);
    public IccCurveTagDataEntry(IccProfileTag tagSignature);
    public IccCurveTagDataEntry(float gamma, IccProfileTag tagSignature);
    public IccCurveTagDataEntry(Single[] curveData, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Single[] get_CurveData();
    public float get_Gamma();
    public bool get_IsIdentityResponse();
    public bool get_IsGamma();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccCurveTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDataReader : object {
    [NullableAttribute("1")]
private Byte[] data;
    private int currentIndex;
    public int DataLength { get; }
    [NullableContextAttribute("1")]
public IccDataReader(Byte[] data);
    public int get_DataLength();
    public void SetIndex(int index);
    private int AddIndex(int increment);
    private void AddPadding();
    private int CalcPadding();
    private static bool GetBit(byte value, int position);
    [NullableContextAttribute("1")]
public IccOneDimensionalCurve ReadOneDimensionalCurve();
    [NullableContextAttribute("1")]
public IccResponseCurve ReadResponseCurve(int channelCount);
    [NullableContextAttribute("1")]
public IccParametricCurve ReadParametricCurve();
    [NullableContextAttribute("1")]
public IccCurveSegment ReadCurveSegment();
    [NullableContextAttribute("1")]
public IccFormulaCurveElement ReadFormulaCurveElement();
    [NullableContextAttribute("1")]
public IccSampledCurveElement ReadSampledCurveElement();
    [NullableContextAttribute("1")]
private IccTagDataEntry[] ReadCurves(int count);
    public IccLut ReadLut8();
    public IccLut ReadLut16(int count);
    [NullableContextAttribute("1")]
public IccClut ReadClut(int inChannelCount, int outChannelCount, bool isFloat);
    [NullableContextAttribute("1")]
public IccClut ReadClut8(int inChannelCount, int outChannelCount, Byte[] gridPointCount);
    [NullableContextAttribute("1")]
public IccClut ReadClut16(int inChannelCount, int outChannelCount, Byte[] gridPointCount);
    [NullableContextAttribute("1")]
public IccClut ReadClutF32(int inChCount, int outChCount, Byte[] gridPointCount);
    [NullableContextAttribute("1")]
public Single[0...,0...] ReadMatrix(int xCount, int yCount, bool isSingle);
    [NullableContextAttribute("1")]
public Single[] ReadMatrix(int yCount, bool isSingle);
    [NullableContextAttribute("1")]
public IccMultiProcessElement ReadMultiProcessElement();
    [NullableContextAttribute("1")]
public IccCurveSetProcessElement ReadCurveSetProcessElement(int inChannelCount, int outChannelCount);
    [NullableContextAttribute("1")]
public IccMatrixProcessElement ReadMatrixProcessElement(int inChannelCount, int outChannelCount);
    [NullableContextAttribute("1")]
public IccClutProcessElement ReadClutProcessElement(int inChannelCount, int outChannelCount);
    public DateTime ReadDateTime();
    public IccVersion ReadVersionNumber();
    public Vector3 ReadXyzNumber();
    public IccProfileId ReadProfileId();
    public IccPositionNumber ReadPositionNumber();
    public IccResponseNumber ReadResponseNumber();
    public IccNamedColor ReadNamedColor(UInt32 deviceCoordCount);
    public IccProfileDescription ReadProfileDescription();
    public IccColorantTableEntry ReadColorantTableEntry();
    public IccScreeningChannel ReadScreeningChannel();
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public float ReadSingle();
    public double ReadDouble();
    [NullableContextAttribute("1")]
public string ReadAsciiString(int length);
    [NullableContextAttribute("1")]
public string ReadUnicodeString(int length);
    public float ReadFix16();
    public float ReadUFix16();
    public float ReadU1Fix15();
    public float ReadUFix8();
    [NullableContextAttribute("1")]
public Byte[] ReadBytes(int count);
    public IccTagDataEntry ReadTagDataEntry(IccTagTableEntry info);
    public IccTypeSignature ReadTagDataEntryHeader();
    public void ReadCheckTagDataEntryHeader(IccTypeSignature expected);
    public IccUnknownTagDataEntry ReadUnknownTagDataEntry(UInt32 size);
    public IccChromaticityTagDataEntry ReadChromaticityTagDataEntry();
    public IccColorantOrderTagDataEntry ReadColorantOrderTagDataEntry();
    public IccColorantTableTagDataEntry ReadColorantTableTagDataEntry();
    public IccCurveTagDataEntry ReadCurveTagDataEntry();
    public IccDataTagDataEntry ReadDataTagDataEntry(UInt32 size);
    public IccDateTimeTagDataEntry ReadDateTimeTagDataEntry();
    public IccLut16TagDataEntry ReadLut16TagDataEntry();
    public IccLut8TagDataEntry ReadLut8TagDataEntry();
    public IccLutAToBTagDataEntry ReadLutAtoBTagDataEntry();
    public IccLutBToATagDataEntry ReadLutBtoATagDataEntry();
    public IccMeasurementTagDataEntry ReadMeasurementTagDataEntry();
    public IccMultiLocalizedUnicodeTagDataEntry ReadMultiLocalizedUnicodeTagDataEntry();
    public IccMultiProcessElementsTagDataEntry ReadMultiProcessElementsTagDataEntry();
    public IccNamedColor2TagDataEntry ReadNamedColor2TagDataEntry();
    public IccParametricCurveTagDataEntry ReadParametricCurveTagDataEntry();
    public IccProfileSequenceDescTagDataEntry ReadProfileSequenceDescTagDataEntry();
    public IccProfileSequenceIdentifierTagDataEntry ReadProfileSequenceIdentifierTagDataEntry();
    public IccResponseCurveSet16TagDataEntry ReadResponseCurveSet16TagDataEntry();
    public IccFix16ArrayTagDataEntry ReadFix16ArrayTagDataEntry(UInt32 size);
    public IccSignatureTagDataEntry ReadSignatureTagDataEntry();
    public IccTextTagDataEntry ReadTextTagDataEntry(UInt32 size);
    public IccUFix16ArrayTagDataEntry ReadUFix16ArrayTagDataEntry(UInt32 size);
    public IccUInt16ArrayTagDataEntry ReadUInt16ArrayTagDataEntry(UInt32 size);
    public IccUInt32ArrayTagDataEntry ReadUInt32ArrayTagDataEntry(UInt32 size);
    public IccUInt64ArrayTagDataEntry ReadUInt64ArrayTagDataEntry(UInt32 size);
    public IccUInt8ArrayTagDataEntry ReadUInt8ArrayTagDataEntry(UInt32 size);
    public IccViewingConditionsTagDataEntry ReadViewingConditionsTagDataEntry();
    public IccXyzTagDataEntry ReadXyzTagDataEntry(UInt32 size);
    public IccTextDescriptionTagDataEntry ReadTextDescriptionTagDataEntry();
    public IccCrdInfoTagDataEntry ReadCrdInfoTagDataEntry();
    public IccScreeningTagDataEntry ReadScreeningTagDataEntry();
    public IccUcrBgTagDataEntry ReadUcrBgTagDataEntry(UInt32 size);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IccMultiLocalizedUnicodeTagDataEntry <ReadProfileDescription>g__ReadText|36_0();
    [CompilerGeneratedAttribute]
internal static CultureInfo <ReadMultiLocalizedUnicodeTagDataEntry>g__ReadCulture|69_0(string language, string country);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDataTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAscii>k__BackingField;
    public Byte[] Data { get; }
    public bool IsAscii { get; }
    [NullableAttribute("2")]
public string AsciiString { get; }
    public IccDataTagDataEntry(Byte[] data);
    public IccDataTagDataEntry(Byte[] data, bool isAscii);
    public IccDataTagDataEntry(Byte[] data, bool isAscii, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsAscii();
    [NullableContextAttribute("2")]
public string get_AsciiString();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccDataTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDataType : Enum {
    public int value__;
    public static IccDataType DateTime;
    public static IccDataType Float32;
    public static IccDataType Position;
    public static IccDataType Response16;
    public static IccDataType S15Fixed16;
    public static IccDataType U16Fixed16;
    public static IccDataType U1Fixed15;
    public static IccDataType U8Fixed8;
    public static IccDataType UInt16;
    public static IccDataType UInt32;
    public static IccDataType UInt64;
    public static IccDataType UInt8;
    public static IccDataType Xyz;
    public static IccDataType Ascii;
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDataWriter : object {
    [NullableAttribute("1")]
private MemoryStream dataStream;
    private bool isDisposed;
    public UInt32 Length { get; }
    public UInt32 get_Length();
    [NullableContextAttribute("1")]
public Byte[] GetData();
    public void SetIndex(int index);
    [NullableContextAttribute("1")]
public int WriteArray(Byte[] data);
    [NullableContextAttribute("1")]
public int WriteArray(UInt16[] data);
    [NullableContextAttribute("1")]
public int WriteArray(Int16[] data);
    [NullableContextAttribute("1")]
public int WriteArray(UInt32[] data);
    [NullableContextAttribute("1")]
public int WriteArray(Int32[] data);
    [NullableContextAttribute("1")]
public int WriteArray(UInt64[] data);
    public int WriteEmpty(int length);
    public int WritePadding();
    public sealed virtual void Dispose();
    private int WriteBytes(Byte* data, int length);
    private int WriteBytesDirect(Byte* data, int length);
    [NullableContextAttribute("1")]
private int WriteCurves(IccTagDataEntry[] curves);
    private void Dispose(bool disposing);
    [NullableContextAttribute("1")]
public int WriteOneDimensionalCurve(IccOneDimensionalCurve value);
    [NullableContextAttribute("1")]
public int WriteResponseCurve(IccResponseCurve value);
    [NullableContextAttribute("1")]
public int WriteParametricCurve(IccParametricCurve value);
    [NullableContextAttribute("1")]
public int WriteCurveSegment(IccCurveSegment value);
    [NullableContextAttribute("1")]
public int WriteFormulaCurveElement(IccFormulaCurveElement value);
    [NullableContextAttribute("1")]
public int WriteSampledCurveElement(IccSampledCurveElement value);
    public int WriteLut8(IccLut value);
    public int WriteLut16(IccLut value);
    [NullableContextAttribute("1")]
public int WriteClut(IccClut value);
    [NullableContextAttribute("1")]
public int WriteClut8(IccClut value);
    [NullableContextAttribute("1")]
public int WriteClut16(IccClut value);
    [NullableContextAttribute("1")]
public int WriteClutF32(IccClut value);
    public int WriteMatrix(Matrix4x4 value, bool isSingle);
    public int WriteMatrix(DenseMatrix`1& value, bool isSingle);
    [NullableContextAttribute("1")]
public int WriteMatrix(Single[0...,0...] value, bool isSingle);
    public int WriteMatrix(Vector3 value, bool isSingle);
    [NullableContextAttribute("1")]
public int WriteMatrix(Single[] value, bool isSingle);
    [NullableContextAttribute("1")]
public int WriteMultiProcessElement(IccMultiProcessElement value);
    [NullableContextAttribute("1")]
public int WriteCurveSetProcessElement(IccCurveSetProcessElement value);
    [NullableContextAttribute("1")]
public int WriteMatrixProcessElement(IccMatrixProcessElement value);
    [NullableContextAttribute("1")]
public int WriteClutProcessElement(IccClutProcessElement value);
    public int WriteDateTime(DateTime value);
    public int WriteVersionNumber(IccVersion& value);
    public int WriteXyzNumber(Vector3 value);
    public int WriteProfileId(IccProfileId& value);
    public int WritePositionNumber(IccPositionNumber& value);
    public int WriteResponseNumber(IccResponseNumber& value);
    public int WriteNamedColor(IccNamedColor& value);
    public int WriteProfileDescription(IccProfileDescription& value);
    public int WriteScreeningChannel(IccScreeningChannel& value);
    public int WriteByte(byte value);
    public int WriteUInt16(ushort value);
    public int WriteInt16(short value);
    public int WriteUInt32(UInt32 value);
    public int WriteInt32(int value);
    public int WriteUInt64(ulong value);
    public int WriteInt64(long value);
    public int WriteSingle(float value);
    public int WriteDouble(double value);
    public int WriteFix16(double value);
    public int WriteUFix16(double value);
    public int WriteU1Fix15(double value);
    public int WriteUFix8(double value);
    [NullableContextAttribute("1")]
public int WriteAsciiString(string value);
    [NullableContextAttribute("1")]
public int WriteAsciiString(string value, int length, bool ensureNullTerminator);
    [NullableContextAttribute("1")]
public int WriteUnicodeString(string value);
    public int WriteTagDataEntry(IccTagDataEntry data, IccTagTableEntry& table);
    public int WriteTagDataEntry(IccTagDataEntry entry);
    public int WriteTagDataEntryHeader(IccTypeSignature signature);
    public int WriteUnknownTagDataEntry(IccUnknownTagDataEntry value);
    public int WriteChromaticityTagDataEntry(IccChromaticityTagDataEntry value);
    public int WriteColorantOrderTagDataEntry(IccColorantOrderTagDataEntry value);
    public int WriteColorantTableTagDataEntry(IccColorantTableTagDataEntry value);
    public int WriteCurveTagDataEntry(IccCurveTagDataEntry value);
    public int WriteDataTagDataEntry(IccDataTagDataEntry value);
    public int WriteDateTimeTagDataEntry(IccDateTimeTagDataEntry value);
    public int WriteLut16TagDataEntry(IccLut16TagDataEntry value);
    public int WriteLut8TagDataEntry(IccLut8TagDataEntry value);
    public int WriteLutAtoBTagDataEntry(IccLutAToBTagDataEntry value);
    public int WriteLutBtoATagDataEntry(IccLutBToATagDataEntry value);
    public int WriteMeasurementTagDataEntry(IccMeasurementTagDataEntry value);
    public int WriteMultiLocalizedUnicodeTagDataEntry(IccMultiLocalizedUnicodeTagDataEntry value);
    public int WriteMultiProcessElementsTagDataEntry(IccMultiProcessElementsTagDataEntry value);
    public int WriteNamedColor2TagDataEntry(IccNamedColor2TagDataEntry value);
    public int WriteParametricCurveTagDataEntry(IccParametricCurveTagDataEntry value);
    public int WriteProfileSequenceDescTagDataEntry(IccProfileSequenceDescTagDataEntry value);
    public int WriteProfileSequenceIdentifierTagDataEntry(IccProfileSequenceIdentifierTagDataEntry value);
    public int WriteResponseCurveSet16TagDataEntry(IccResponseCurveSet16TagDataEntry value);
    public int WriteFix16ArrayTagDataEntry(IccFix16ArrayTagDataEntry value);
    public int WriteSignatureTagDataEntry(IccSignatureTagDataEntry value);
    public int WriteTextTagDataEntry(IccTextTagDataEntry value);
    public int WriteUFix16ArrayTagDataEntry(IccUFix16ArrayTagDataEntry value);
    public int WriteUInt16ArrayTagDataEntry(IccUInt16ArrayTagDataEntry value);
    public int WriteUInt32ArrayTagDataEntry(IccUInt32ArrayTagDataEntry value);
    public int WriteUInt64ArrayTagDataEntry(IccUInt64ArrayTagDataEntry value);
    public int WriteUInt8ArrayTagDataEntry(IccUInt8ArrayTagDataEntry value);
    public int WriteViewingConditionsTagDataEntry(IccViewingConditionsTagDataEntry value);
    public int WriteXyzTagDataEntry(IccXyzTagDataEntry value);
    public int WriteTextDescriptionTagDataEntry(IccTextDescriptionTagDataEntry value);
    public int WriteCrdInfoTagDataEntry(IccCrdInfoTagDataEntry value);
    public int WriteScreeningTagDataEntry(IccScreeningTagDataEntry value);
    public int WriteUcrBgTagDataEntry(IccUcrBgTagDataEntry value);
    [CompilerGeneratedAttribute]
private void <WriteCrdInfoTagDataEntry>g__WriteString|99_0(string text, <>c__DisplayClass99_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDateTimeTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private DateTime <Value>k__BackingField;
    public DateTime Value { get; }
    public IccDateTimeTagDataEntry(DateTime value);
    public IccDateTimeTagDataEntry(DateTime value, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public DateTime get_Value();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccDateTimeTagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccDeviceAttribute : Enum {
    public long value__;
    public static IccDeviceAttribute OpacityTransparent;
    public static IccDeviceAttribute OpacityReflective;
    public static IccDeviceAttribute ReflectivityMatte;
    public static IccDeviceAttribute ReflectivityGlossy;
    public static IccDeviceAttribute PolarityNegative;
    public static IccDeviceAttribute PolarityPositive;
    public static IccDeviceAttribute ChromaBlackWhite;
    public static IccDeviceAttribute ChromaColor;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccEAcsProcessElement : IccMultiProcessElement {
    public IccEAcsProcessElement(int inChannelCount, int outChannelCount);
    public sealed virtual bool Equals(IccEAcsProcessElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccFix16ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Single[] <Data>k__BackingField;
    public Single[] Data { get; }
    public IccFix16ArrayTagDataEntry(Single[] data);
    public IccFix16ArrayTagDataEntry(Single[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Single[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccFix16ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccFormulaCurveElement : IccCurveSegment {
    [CompilerGeneratedAttribute]
private IccFormulaCurveType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Gamma>k__BackingField;
    [CompilerGeneratedAttribute]
private float <A>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <D>k__BackingField;
    [CompilerGeneratedAttribute]
private float <E>k__BackingField;
    public IccFormulaCurveType Type { get; }
    public float Gamma { get; }
    public float A { get; }
    public float B { get; }
    public float C { get; }
    public float D { get; }
    public float E { get; }
    public IccFormulaCurveElement(IccFormulaCurveType type, float gamma, float a, float b, float c, float d, float e);
    [CompilerGeneratedAttribute]
public IccFormulaCurveType get_Type();
    [CompilerGeneratedAttribute]
public float get_Gamma();
    [CompilerGeneratedAttribute]
public float get_A();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_D();
    [CompilerGeneratedAttribute]
public float get_E();
    public virtual bool Equals(IccCurveSegment other);
    public sealed virtual bool Equals(IccFormulaCurveElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccFormulaCurveType : Enum {
    public ushort value__;
    public static IccFormulaCurveType Type1;
    public static IccFormulaCurveType Type2;
    public static IccFormulaCurveType Type3;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLocalizedString : ValueType {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    public string Text { get; }
    public CultureInfo Culture { get; }
    public IccLocalizedString(string text);
    public IccLocalizedString(CultureInfo culture, string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    public sealed virtual bool Equals(IccLocalizedString other);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLut : ValueType {
    [CompilerGeneratedAttribute]
private Single[] <Values>k__BackingField;
    public Single[] Values { get; }
    public IccLut(Single[] values);
    public IccLut(UInt16[] values);
    public IccLut(Byte[] values);
    [CompilerGeneratedAttribute]
public Single[] get_Values();
    public sealed virtual bool Equals(IccLut other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLut16TagDataEntry : IccTagDataEntry {
    private static Single[0...,0...] IdentityMatrix;
    [CompilerGeneratedAttribute]
private Matrix4x4 <Matrix>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLut[] <InputValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccClut <ClutValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLut[] <OutputValues>k__BackingField;
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public Matrix4x4 Matrix { get; }
    public IccLut[] InputValues { get; }
    public IccClut ClutValues { get; }
    public IccLut[] OutputValues { get; }
    public IccLut16TagDataEntry(IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues);
    public IccLut16TagDataEntry(IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues, IccProfileTag tagSignature);
    public IccLut16TagDataEntry(Single[0...,0...] matrix, IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues);
    public IccLut16TagDataEntry(Single[0...,0...] matrix, IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues, IccProfileTag tagSignature);
    private static IccLut16TagDataEntry();
    public int get_InputChannelCount();
    public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public Matrix4x4 get_Matrix();
    [CompilerGeneratedAttribute]
public IccLut[] get_InputValues();
    [CompilerGeneratedAttribute]
public IccClut get_ClutValues();
    [CompilerGeneratedAttribute]
public IccLut[] get_OutputValues();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccLut16TagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static Matrix4x4 CreateMatrix(Single[0...,0...] matrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLut8TagDataEntry : IccTagDataEntry {
    private static Single[0...,0...] IdentityMatrix;
    [CompilerGeneratedAttribute]
private Matrix4x4 <Matrix>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLut[] <InputValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccClut <ClutValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLut[] <OutputValues>k__BackingField;
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public Matrix4x4 Matrix { get; }
    public IccLut[] InputValues { get; }
    public IccClut ClutValues { get; }
    public IccLut[] OutputValues { get; }
    public IccLut8TagDataEntry(IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues);
    public IccLut8TagDataEntry(IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues, IccProfileTag tagSignature);
    public IccLut8TagDataEntry(Single[0...,0...] matrix, IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues);
    public IccLut8TagDataEntry(Single[0...,0...] matrix, IccLut[] inputValues, IccClut clutValues, IccLut[] outputValues, IccProfileTag tagSignature);
    private static IccLut8TagDataEntry();
    public int get_InputChannelCount();
    public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public Matrix4x4 get_Matrix();
    [CompilerGeneratedAttribute]
public IccLut[] get_InputValues();
    [CompilerGeneratedAttribute]
public IccClut get_ClutValues();
    [CompilerGeneratedAttribute]
public IccLut[] get_OutputValues();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccLut8TagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static Matrix4x4 CreateMatrix(Single[0...,0...] matrix);
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLutAToBTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private int <InputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Matrix4x4> <Matrix3x3>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Vector3> <Matrix3x1>k__BackingField;
    [CompilerGeneratedAttribute]
private IccClut <ClutValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveB>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveM>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveA>k__BackingField;
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public Nullable`1<Matrix4x4> Matrix3x3 { get; }
    public Nullable`1<Vector3> Matrix3x1 { get; }
    public IccClut ClutValues { get; }
    public IccTagDataEntry[] CurveB { get; }
    public IccTagDataEntry[] CurveM { get; }
    public IccTagDataEntry[] CurveA { get; }
    public IccLutAToBTagDataEntry(IccTagDataEntry[] curveB, Single[0...,0...] matrix3x3, Single[] matrix3x1, IccTagDataEntry[] curveM, IccClut clutValues, IccTagDataEntry[] curveA);
    public IccLutAToBTagDataEntry(IccTagDataEntry[] curveB, Single[0...,0...] matrix3x3, Single[] matrix3x1, IccTagDataEntry[] curveM, IccClut clutValues, IccTagDataEntry[] curveA, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public int get_InputChannelCount();
    [CompilerGeneratedAttribute]
public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public Nullable`1<Matrix4x4> get_Matrix3x3();
    [CompilerGeneratedAttribute]
public Nullable`1<Vector3> get_Matrix3x1();
    [CompilerGeneratedAttribute]
public IccClut get_ClutValues();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveB();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveM();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveA();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccLutAToBTagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool EqualsCurve(IccTagDataEntry[] thisCurves, IccTagDataEntry[] entryCurves);
    private bool IsAClutMMatrixB();
    private bool IsMMatrixB();
    private bool IsAClutB();
    private bool IsB();
    private void VerifyCurve(IccTagDataEntry[] curves, string name);
    private static void VerifyMatrix(Single[0...,0...] matrix3x3, Single[] matrix3x1);
    private static Nullable`1<Vector3> CreateMatrix3x1(Single[] matrix);
    private static Nullable`1<Matrix4x4> CreateMatrix3x3(Single[0...,0...] matrix);
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccLutBToATagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private int <InputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Matrix4x4> <Matrix3x3>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Vector3> <Matrix3x1>k__BackingField;
    [CompilerGeneratedAttribute]
private IccClut <ClutValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveB>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveM>k__BackingField;
    [CompilerGeneratedAttribute]
private IccTagDataEntry[] <CurveA>k__BackingField;
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public Nullable`1<Matrix4x4> Matrix3x3 { get; }
    public Nullable`1<Vector3> Matrix3x1 { get; }
    public IccClut ClutValues { get; }
    public IccTagDataEntry[] CurveB { get; }
    public IccTagDataEntry[] CurveM { get; }
    public IccTagDataEntry[] CurveA { get; }
    public IccLutBToATagDataEntry(IccTagDataEntry[] curveB, Single[0...,0...] matrix3x3, Single[] matrix3x1, IccTagDataEntry[] curveM, IccClut clutValues, IccTagDataEntry[] curveA);
    public IccLutBToATagDataEntry(IccTagDataEntry[] curveB, Single[0...,0...] matrix3x3, Single[] matrix3x1, IccTagDataEntry[] curveM, IccClut clutValues, IccTagDataEntry[] curveA, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public int get_InputChannelCount();
    [CompilerGeneratedAttribute]
public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public Nullable`1<Matrix4x4> get_Matrix3x3();
    [CompilerGeneratedAttribute]
public Nullable`1<Vector3> get_Matrix3x1();
    [CompilerGeneratedAttribute]
public IccClut get_ClutValues();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveB();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveM();
    [CompilerGeneratedAttribute]
public IccTagDataEntry[] get_CurveA();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccLutBToATagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool EqualsCurve(IccTagDataEntry[] thisCurves, IccTagDataEntry[] entryCurves);
    private bool IsBMatrixMClutA();
    private bool IsBMatrixM();
    private bool IsBClutA();
    private bool IsB();
    private void VerifyCurve(IccTagDataEntry[] curves, string name);
    private static void VerifyMatrix(Single[0...,0...] matrix3x3, Single[] matrix3x1);
    private static Nullable`1<Vector3> CreateMatrix3x1(Single[] matrix);
    private static Nullable`1<Matrix4x4> CreateMatrix3x3(Single[0...,0...] matrix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMatrixProcessElement : IccMultiProcessElement {
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private DenseMatrix`1<float> <MatrixIxO>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[] <MatrixOx1>k__BackingField;
    [NullableAttribute("0")]
public DenseMatrix`1<float> MatrixIxO { get; }
    public Single[] MatrixOx1 { get; }
    public IccMatrixProcessElement(Single[0...,0...] matrixIxO, Single[] matrixOx1);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_MatrixIxO();
    [CompilerGeneratedAttribute]
public Single[] get_MatrixOx1();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccMultiProcessElement other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccMatrixProcessElement other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool EqualsMatrix(IccMatrixProcessElement element);
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMeasurementGeometry : Enum {
    public UInt32 value__;
    public static IccMeasurementGeometry Unknown;
    public static IccMeasurementGeometry Degree0To45Or45To0;
    public static IccMeasurementGeometry Degree0ToDOrDTo0;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMeasurementTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccStandardObserver <Observer>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <XyzBacking>k__BackingField;
    [CompilerGeneratedAttribute]
private IccMeasurementGeometry <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Flare>k__BackingField;
    [CompilerGeneratedAttribute]
private IccStandardIlluminant <Illuminant>k__BackingField;
    public IccStandardObserver Observer { get; }
    public Vector3 XyzBacking { get; }
    public IccMeasurementGeometry Geometry { get; }
    public float Flare { get; }
    public IccStandardIlluminant Illuminant { get; }
    public IccMeasurementTagDataEntry(IccStandardObserver observer, Vector3 xyzBacking, IccMeasurementGeometry geometry, float flare, IccStandardIlluminant illuminant);
    public IccMeasurementTagDataEntry(IccStandardObserver observer, Vector3 xyzBacking, IccMeasurementGeometry geometry, float flare, IccStandardIlluminant illuminant, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccStandardObserver get_Observer();
    [CompilerGeneratedAttribute]
public Vector3 get_XyzBacking();
    [CompilerGeneratedAttribute]
public IccMeasurementGeometry get_Geometry();
    [CompilerGeneratedAttribute]
public float get_Flare();
    [CompilerGeneratedAttribute]
public IccStandardIlluminant get_Illuminant();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccMeasurementTagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMultiLocalizedUnicodeTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccLocalizedString[] <Texts>k__BackingField;
    public IccLocalizedString[] Texts { get; }
    public IccMultiLocalizedUnicodeTagDataEntry(IccLocalizedString[] texts);
    public IccMultiLocalizedUnicodeTagDataEntry(IccLocalizedString[] texts, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccLocalizedString[] get_Texts();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccMultiLocalizedUnicodeTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMultiProcessElement : object {
    [CompilerGeneratedAttribute]
private IccMultiProcessElementSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputChannelCount>k__BackingField;
    public IccMultiProcessElementSignature Signature { get; }
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    protected IccMultiProcessElement(IccMultiProcessElementSignature signature, int inChannelCount, int outChannelCount);
    [CompilerGeneratedAttribute]
public IccMultiProcessElementSignature get_Signature();
    [CompilerGeneratedAttribute]
public int get_InputChannelCount();
    [CompilerGeneratedAttribute]
public int get_OutputChannelCount();
    public virtual bool Equals(IccMultiProcessElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMultiProcessElementSignature : Enum {
    public UInt32 value__;
    public static IccMultiProcessElementSignature CurveSet;
    public static IccMultiProcessElementSignature Matrix;
    public static IccMultiProcessElementSignature Clut;
    public static IccMultiProcessElementSignature BAcs;
    public static IccMultiProcessElementSignature EAcs;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccMultiProcessElementsTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private int <InputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IccMultiProcessElement[] <Data>k__BackingField;
    public int InputChannelCount { get; }
    public int OutputChannelCount { get; }
    public IccMultiProcessElement[] Data { get; }
    public IccMultiProcessElementsTagDataEntry(IccMultiProcessElement[] data);
    public IccMultiProcessElementsTagDataEntry(IccMultiProcessElement[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public int get_InputChannelCount();
    [CompilerGeneratedAttribute]
public int get_OutputChannelCount();
    [CompilerGeneratedAttribute]
public IccMultiProcessElement[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccMultiProcessElementsTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <.ctor>b__1_0(IccMultiProcessElement t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccNamedColor : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <PcsCoordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <DeviceCoordinates>k__BackingField;
    public string Name { get; }
    public UInt16[] PcsCoordinates { get; }
    public UInt16[] DeviceCoordinates { get; }
    public IccNamedColor(string name, UInt16[] pcsCoordinates, UInt16[] deviceCoordinates);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public UInt16[] get_PcsCoordinates();
    [CompilerGeneratedAttribute]
public UInt16[] get_DeviceCoordinates();
    public static bool op_Equality(IccNamedColor left, IccNamedColor right);
    public static bool op_Inequality(IccNamedColor left, IccNamedColor right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccNamedColor other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccNamedColor2TagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private int <CoordinateCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VendorFlags>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IccNamedColor[] <Colors>k__BackingField;
    public int CoordinateCount { get; }
    public string Prefix { get; }
    public string Suffix { get; }
    public int VendorFlags { get; }
    [NullableAttribute("1")]
public IccNamedColor[] Colors { get; }
    [NullableContextAttribute("1")]
public IccNamedColor2TagDataEntry(IccNamedColor[] colors);
    [NullableContextAttribute("1")]
public IccNamedColor2TagDataEntry(string prefix, string suffix, IccNamedColor[] colors);
    [NullableContextAttribute("1")]
public IccNamedColor2TagDataEntry(int vendorFlags, string prefix, string suffix, IccNamedColor[] colors);
    [NullableContextAttribute("1")]
public IccNamedColor2TagDataEntry(IccNamedColor[] colors, IccProfileTag tagSignature);
    [NullableContextAttribute("1")]
public IccNamedColor2TagDataEntry(string prefix, string suffix, IccNamedColor[] colors, IccProfileTag tagSignature);
    public IccNamedColor2TagDataEntry(int vendorFlags, string prefix, string suffix, IccNamedColor[] colors, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public int get_CoordinateCount();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public int get_VendorFlags();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IccNamedColor[] get_Colors();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccNamedColor2TagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccOneDimensionalCurve : object {
    [CompilerGeneratedAttribute]
private Single[] <BreakPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private IccCurveSegment[] <Segments>k__BackingField;
    public Single[] BreakPoints { get; }
    public IccCurveSegment[] Segments { get; }
    public IccOneDimensionalCurve(Single[] breakPoints, IccCurveSegment[] segments);
    [CompilerGeneratedAttribute]
public Single[] get_BreakPoints();
    [CompilerGeneratedAttribute]
public IccCurveSegment[] get_Segments();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccOneDimensionalCurve other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccParametricCurve : object {
    [CompilerGeneratedAttribute]
private IccParametricCurveType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private float <G>k__BackingField;
    [CompilerGeneratedAttribute]
private float <A>k__BackingField;
    [CompilerGeneratedAttribute]
private float <B>k__BackingField;
    [CompilerGeneratedAttribute]
private float <C>k__BackingField;
    [CompilerGeneratedAttribute]
private float <D>k__BackingField;
    [CompilerGeneratedAttribute]
private float <E>k__BackingField;
    [CompilerGeneratedAttribute]
private float <F>k__BackingField;
    public IccParametricCurveType Type { get; }
    public float G { get; }
    public float A { get; }
    public float B { get; }
    public float C { get; }
    public float D { get; }
    public float E { get; }
    public float F { get; }
    public IccParametricCurve(float g);
    public IccParametricCurve(float g, float a, float b);
    public IccParametricCurve(float g, float a, float b, float c);
    public IccParametricCurve(float g, float a, float b, float c, float d);
    public IccParametricCurve(float g, float a, float b, float c, float d, float e, float f);
    private IccParametricCurve(IccParametricCurveType type, float g, float a, float b, float c, float d, float e, float f);
    [CompilerGeneratedAttribute]
public IccParametricCurveType get_Type();
    [CompilerGeneratedAttribute]
public float get_G();
    [CompilerGeneratedAttribute]
public float get_A();
    [CompilerGeneratedAttribute]
public float get_B();
    [CompilerGeneratedAttribute]
public float get_C();
    [CompilerGeneratedAttribute]
public float get_D();
    [CompilerGeneratedAttribute]
public float get_E();
    [CompilerGeneratedAttribute]
public float get_F();
    public sealed virtual bool Equals(IccParametricCurve other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccParametricCurveTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccParametricCurve <Curve>k__BackingField;
    public IccParametricCurve Curve { get; }
    public IccParametricCurveTagDataEntry(IccParametricCurve curve);
    public IccParametricCurveTagDataEntry(IccParametricCurve curve, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccParametricCurve get_Curve();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccParametricCurveTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccParametricCurveType : Enum {
    public ushort value__;
    public static IccParametricCurveType Type1;
    public static IccParametricCurveType Cie122_1996;
    public static IccParametricCurveType Iec61966_3;
    public static IccParametricCurveType SRgb;
    public static IccParametricCurveType Type5;
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccPositionNumber : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    public UInt32 Offset { get; }
    public UInt32 Size { get; }
    public IccPositionNumber(UInt32 offset, UInt32 size);
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    public static bool op_Equality(IccPositionNumber left, IccPositionNumber right);
    public static bool op_Inequality(IccPositionNumber left, IccPositionNumber right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccPositionNumber other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccPrimaryPlatformType : Enum {
    public UInt32 value__;
    public static IccPrimaryPlatformType NotIdentified;
    public static IccPrimaryPlatformType AppleComputerInc;
    public static IccPrimaryPlatformType MicrosoftCorporation;
    public static IccPrimaryPlatformType SiliconGraphicsInc;
    public static IccPrimaryPlatformType SunMicrosystemsInc;
}
public class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfile : object {
    private Byte[] data;
    private IccTagDataEntry[] entries;
    private IccProfileHeader header;
    public IccProfileHeader Header { get; public set; }
    public IccTagDataEntry[] Entries { get; }
    public IccProfile(Byte[] data);
    internal IccProfile(IccProfileHeader header, IccTagDataEntry[] entries);
    private IccProfile(IccProfile other);
    public IccProfileHeader get_Header();
    public void set_Header(IccProfileHeader value);
    public IccTagDataEntry[] get_Entries();
    public sealed virtual IccProfile DeepClone();
    public static IccProfileId CalculateHash(Byte[] data);
    public bool CheckIsValid();
    public Byte[] ToByteArray();
    private void InitializeHeader();
    private void InitializeEntries();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileClass : Enum {
    public UInt32 value__;
    public static IccProfileClass InputDevice;
    public static IccProfileClass DisplayDevice;
    public static IccProfileClass OutputDevice;
    public static IccProfileClass DeviceLink;
    public static IccProfileClass ColorSpace;
    public static IccProfileClass Abstract;
    public static IccProfileClass NamedColor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileDescription : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <DeviceManufacturer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IccDeviceAttribute <DeviceAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfileTag <TechnologyInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLocalizedString[] <DeviceManufacturerInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLocalizedString[] <DeviceModelInfo>k__BackingField;
    public UInt32 DeviceManufacturer { get; }
    public UInt32 DeviceModel { get; }
    public IccDeviceAttribute DeviceAttributes { get; }
    public IccProfileTag TechnologyInformation { get; }
    public IccLocalizedString[] DeviceManufacturerInfo { get; }
    public IccLocalizedString[] DeviceModelInfo { get; }
    public IccProfileDescription(UInt32 deviceManufacturer, UInt32 deviceModel, IccDeviceAttribute deviceAttributes, IccProfileTag technologyInformation, IccLocalizedString[] deviceManufacturerInfo, IccLocalizedString[] deviceModelInfo);
    [CompilerGeneratedAttribute]
public UInt32 get_DeviceManufacturer();
    [CompilerGeneratedAttribute]
public UInt32 get_DeviceModel();
    [CompilerGeneratedAttribute]
public IccDeviceAttribute get_DeviceAttributes();
    [CompilerGeneratedAttribute]
public IccProfileTag get_TechnologyInformation();
    [CompilerGeneratedAttribute]
public IccLocalizedString[] get_DeviceManufacturerInfo();
    [CompilerGeneratedAttribute]
public IccLocalizedString[] get_DeviceModelInfo();
    public sealed virtual bool Equals(IccProfileDescription other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileFlag : Enum {
    public int value__;
    public static IccProfileFlag None;
    public static IccProfileFlag Embedded;
    public static IccProfileFlag NotEmbedded;
    public static IccProfileFlag NotIndependent;
    public static IccProfileFlag Independent;
}
public class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileHeader : object {
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CmmType>k__BackingField;
    [CompilerGeneratedAttribute]
private IccVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfileClass <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private IccColorSpaceType <DataColorSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private IccColorSpaceType <ProfileConnectionSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private IccPrimaryPlatformType <PrimaryPlatformSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfileFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DeviceManufacturer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IccDeviceAttribute <DeviceAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IccRenderingIntent <RenderingIntent>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <PcsIlluminant>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreatorSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfileId <Id>k__BackingField;
    public UInt32 Size { get; public set; }
    public string CmmType { get; public set; }
    public IccVersion Version { get; public set; }
    public IccProfileClass Class { get; public set; }
    public IccColorSpaceType DataColorSpace { get; public set; }
    public IccColorSpaceType ProfileConnectionSpace { get; public set; }
    public DateTime CreationDate { get; public set; }
    public string FileSignature { get; public set; }
    public IccPrimaryPlatformType PrimaryPlatformSignature { get; public set; }
    public IccProfileFlag Flags { get; public set; }
    public UInt32 DeviceManufacturer { get; public set; }
    public UInt32 DeviceModel { get; public set; }
    public IccDeviceAttribute DeviceAttributes { get; public set; }
    public IccRenderingIntent RenderingIntent { get; public set; }
    public Vector3 PcsIlluminant { get; public set; }
    public string CreatorSignature { get; public set; }
    public IccProfileId Id { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_CmmType();
    [CompilerGeneratedAttribute]
public void set_CmmType(string value);
    [CompilerGeneratedAttribute]
public IccVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(IccVersion value);
    [CompilerGeneratedAttribute]
public IccProfileClass get_Class();
    [CompilerGeneratedAttribute]
public void set_Class(IccProfileClass value);
    [CompilerGeneratedAttribute]
public IccColorSpaceType get_DataColorSpace();
    [CompilerGeneratedAttribute]
public void set_DataColorSpace(IccColorSpaceType value);
    [CompilerGeneratedAttribute]
public IccColorSpaceType get_ProfileConnectionSpace();
    [CompilerGeneratedAttribute]
public void set_ProfileConnectionSpace(IccColorSpaceType value);
    [CompilerGeneratedAttribute]
public DateTime get_CreationDate();
    [CompilerGeneratedAttribute]
public void set_CreationDate(DateTime value);
    [CompilerGeneratedAttribute]
public string get_FileSignature();
    [CompilerGeneratedAttribute]
public void set_FileSignature(string value);
    [CompilerGeneratedAttribute]
public IccPrimaryPlatformType get_PrimaryPlatformSignature();
    [CompilerGeneratedAttribute]
public void set_PrimaryPlatformSignature(IccPrimaryPlatformType value);
    [CompilerGeneratedAttribute]
public IccProfileFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(IccProfileFlag value);
    [CompilerGeneratedAttribute]
public UInt32 get_DeviceManufacturer();
    [CompilerGeneratedAttribute]
public void set_DeviceManufacturer(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_DeviceModel();
    [CompilerGeneratedAttribute]
public void set_DeviceModel(UInt32 value);
    [CompilerGeneratedAttribute]
public IccDeviceAttribute get_DeviceAttributes();
    [CompilerGeneratedAttribute]
public void set_DeviceAttributes(IccDeviceAttribute value);
    [CompilerGeneratedAttribute]
public IccRenderingIntent get_RenderingIntent();
    [CompilerGeneratedAttribute]
public void set_RenderingIntent(IccRenderingIntent value);
    [CompilerGeneratedAttribute]
public Vector3 get_PcsIlluminant();
    [CompilerGeneratedAttribute]
public void set_PcsIlluminant(Vector3 value);
    [CompilerGeneratedAttribute]
public string get_CreatorSignature();
    [CompilerGeneratedAttribute]
public void set_CreatorSignature(string value);
    [CompilerGeneratedAttribute]
public IccProfileId get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(IccProfileId value);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileId : ValueType {
    public static IccProfileId Zero;
    [CompilerGeneratedAttribute]
private UInt32 <Part1>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Part2>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Part3>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Part4>k__BackingField;
    public UInt32 Part1 { get; }
    public UInt32 Part2 { get; }
    public UInt32 Part3 { get; }
    public UInt32 Part4 { get; }
    public bool IsSet { get; }
    public IccProfileId(UInt32 p1, UInt32 p2, UInt32 p3, UInt32 p4);
    [CompilerGeneratedAttribute]
public UInt32 get_Part1();
    [CompilerGeneratedAttribute]
public UInt32 get_Part2();
    [CompilerGeneratedAttribute]
public UInt32 get_Part3();
    [CompilerGeneratedAttribute]
public UInt32 get_Part4();
    public bool get_IsSet();
    public static bool op_Equality(IccProfileId left, IccProfileId right);
    public static bool op_Inequality(IccProfileId left, IccProfileId right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccProfileId other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private static string ToHex(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileSequenceDescTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccProfileDescription[] <Descriptions>k__BackingField;
    public IccProfileDescription[] Descriptions { get; }
    public IccProfileSequenceDescTagDataEntry(IccProfileDescription[] descriptions);
    public IccProfileSequenceDescTagDataEntry(IccProfileDescription[] descriptions, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccProfileDescription[] get_Descriptions();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccProfileSequenceDescTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileSequenceIdentifier : ValueType {
    [CompilerGeneratedAttribute]
private IccProfileId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IccLocalizedString[] <Description>k__BackingField;
    public IccProfileId Id { get; }
    public IccLocalizedString[] Description { get; }
    public IccProfileSequenceIdentifier(IccProfileId id, IccLocalizedString[] description);
    [CompilerGeneratedAttribute]
public IccProfileId get_Id();
    [CompilerGeneratedAttribute]
public IccLocalizedString[] get_Description();
    public sealed virtual bool Equals(IccProfileSequenceIdentifier other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileSequenceIdentifierTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccProfileSequenceIdentifier[] <Data>k__BackingField;
    public IccProfileSequenceIdentifier[] Data { get; }
    public IccProfileSequenceIdentifierTagDataEntry(IccProfileSequenceIdentifier[] data);
    public IccProfileSequenceIdentifierTagDataEntry(IccProfileSequenceIdentifier[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccProfileSequenceIdentifier[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccProfileSequenceIdentifierTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccProfileTag : Enum {
    public UInt32 value__;
    public static IccProfileTag Unknown;
    public static IccProfileTag AToB0;
    public static IccProfileTag AToB1;
    public static IccProfileTag AToB2;
    public static IccProfileTag BlueMatrixColumn;
    public static IccProfileTag BlueTrc;
    public static IccProfileTag BToA0;
    public static IccProfileTag BToA1;
    public static IccProfileTag BToA2;
    public static IccProfileTag BToD0;
    public static IccProfileTag BToD1;
    public static IccProfileTag BToD2;
    public static IccProfileTag BToD3;
    public static IccProfileTag CalibrationDateTime;
    public static IccProfileTag CharTarget;
    public static IccProfileTag ChromaticAdaptation;
    public static IccProfileTag Chromaticity;
    public static IccProfileTag ColorantOrder;
    public static IccProfileTag ColorantTable;
    public static IccProfileTag ColorantTableOut;
    public static IccProfileTag ColorimetricIntentImageStat;
    public static IccProfileTag Copyright;
    public static IccProfileTag CrdInfo;
    public static IccProfileTag Data;
    public static IccProfileTag DateTime;
    public static IccProfileTag DeviceManufacturerDescription;
    public static IccProfileTag DeviceModelDescription;
    public static IccProfileTag DeviceSettings;
    public static IccProfileTag DToB0;
    public static IccProfileTag DToB1;
    public static IccProfileTag DToB2;
    public static IccProfileTag DToB3;
    public static IccProfileTag Gamut;
    public static IccProfileTag GrayTrc;
    public static IccProfileTag GreenMatrixColumn;
    public static IccProfileTag GreenTrc;
    public static IccProfileTag Luminance;
    public static IccProfileTag Measurement;
    public static IccProfileTag MediaBlackPoint;
    public static IccProfileTag MediaWhitePoint;
    public static IccProfileTag NamedColor;
    public static IccProfileTag NamedColor2;
    public static IccProfileTag OutputResponse;
    public static IccProfileTag PerceptualRenderingIntentGamut;
    public static IccProfileTag Preview0;
    public static IccProfileTag Preview1;
    public static IccProfileTag Preview2;
    public static IccProfileTag ProfileDescription;
    public static IccProfileTag ProfileSequenceDescription;
    public static IccProfileTag PostScript2Crd0;
    public static IccProfileTag PostScript2Crd1;
    public static IccProfileTag PostScript2Crd2;
    public static IccProfileTag PostScript2Crd3;
    public static IccProfileTag PostScript2Csa;
    public static IccProfileTag PostScript2RenderingIntent;
    public static IccProfileTag RedMatrixColumn;
    public static IccProfileTag RedTrc;
    public static IccProfileTag SaturationRenderingIntentGamut;
    public static IccProfileTag ScreeningDescription;
    public static IccProfileTag Screening;
    public static IccProfileTag Technology;
    public static IccProfileTag UcrBgSpecification;
    public static IccProfileTag ViewingCondDescription;
    public static IccProfileTag ViewingConditions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccReader : object {
    public static IccProfile Read(Byte[] data);
    public static IccProfileHeader ReadHeader(Byte[] data);
    public static IccTagDataEntry[] ReadTagData(Byte[] data);
    private static IccProfileHeader ReadHeader(IccDataReader reader);
    private static IccTagDataEntry[] ReadTagData(IccDataReader reader);
    private static IccTagTableEntry[] ReadTagTable(IccDataReader reader);
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccRenderingIntent : Enum {
    public UInt32 value__;
    public static IccRenderingIntent Perceptual;
    public static IccRenderingIntent MediaRelativeColorimetric;
    public static IccRenderingIntent Saturation;
    public static IccRenderingIntent AbsoluteColorimetric;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccResponseCurve : object {
    [CompilerGeneratedAttribute]
private IccCurveMeasurementEncodings <CurveType>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3[] <XyzValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IccResponseNumber[][] <ResponseArrays>k__BackingField;
    public IccCurveMeasurementEncodings CurveType { get; }
    public Vector3[] XyzValues { get; }
    public IccResponseNumber[][] ResponseArrays { get; }
    public IccResponseCurve(IccCurveMeasurementEncodings curveType, Vector3[] xyzValues, IccResponseNumber[][] responseArrays);
    [CompilerGeneratedAttribute]
public IccCurveMeasurementEncodings get_CurveType();
    [CompilerGeneratedAttribute]
public Vector3[] get_XyzValues();
    [CompilerGeneratedAttribute]
public IccResponseNumber[][] get_ResponseArrays();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccResponseCurve other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool EqualsResponseArray(IccResponseCurve other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccResponseCurveSet16TagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private ushort <ChannelCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IccResponseCurve[] <Curves>k__BackingField;
    public ushort ChannelCount { get; }
    public IccResponseCurve[] Curves { get; }
    public IccResponseCurveSet16TagDataEntry(IccResponseCurve[] curves);
    public IccResponseCurveSet16TagDataEntry(IccResponseCurve[] curves, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public ushort get_ChannelCount();
    [CompilerGeneratedAttribute]
public IccResponseCurve[] get_Curves();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccResponseCurveSet16TagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <.ctor>b__1_0(IccResponseCurve t);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccResponseNumber : ValueType {
    [CompilerGeneratedAttribute]
private ushort <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MeasurementValue>k__BackingField;
    public ushort DeviceCode { get; }
    public float MeasurementValue { get; }
    public IccResponseNumber(ushort deviceCode, float measurementValue);
    [CompilerGeneratedAttribute]
public ushort get_DeviceCode();
    [CompilerGeneratedAttribute]
public float get_MeasurementValue();
    public static bool op_Equality(IccResponseNumber left, IccResponseNumber right);
    public static bool op_Inequality(IccResponseNumber left, IccResponseNumber right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccResponseNumber other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccSampledCurveElement : IccCurveSegment {
    [CompilerGeneratedAttribute]
private Single[] <CurveEntries>k__BackingField;
    public Single[] CurveEntries { get; }
    public IccSampledCurveElement(Single[] curveEntries);
    [CompilerGeneratedAttribute]
public Single[] get_CurveEntries();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccCurveSegment other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccSampledCurveElement other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccScreeningChannel : ValueType {
    [CompilerGeneratedAttribute]
private float <Frequency>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Angle>k__BackingField;
    [CompilerGeneratedAttribute]
private IccScreeningSpotType <SpotShape>k__BackingField;
    public float Frequency { get; }
    public float Angle { get; }
    public IccScreeningSpotType SpotShape { get; }
    public IccScreeningChannel(float frequency, float angle, IccScreeningSpotType spotShape);
    [CompilerGeneratedAttribute]
public float get_Frequency();
    [CompilerGeneratedAttribute]
public float get_Angle();
    [CompilerGeneratedAttribute]
public IccScreeningSpotType get_SpotShape();
    public static bool op_Equality(IccScreeningChannel left, IccScreeningChannel right);
    public static bool op_Inequality(IccScreeningChannel left, IccScreeningChannel right);
    public sealed virtual bool Equals(IccScreeningChannel other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccScreeningFlag : Enum {
    public int value__;
    public static IccScreeningFlag None;
    public static IccScreeningFlag DefaultScreens;
    public static IccScreeningFlag NotDefaultScreens;
    public static IccScreeningFlag UnitLinesPerInch;
    public static IccScreeningFlag UnitLinesPerCm;
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccScreeningSpotType : Enum {
    public int value__;
    public static IccScreeningSpotType Unknown;
    public static IccScreeningSpotType PrinterDefault;
    public static IccScreeningSpotType Round;
    public static IccScreeningSpotType Diamond;
    public static IccScreeningSpotType Ellipse;
    public static IccScreeningSpotType Line;
    public static IccScreeningSpotType Square;
    public static IccScreeningSpotType Cross;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccScreeningTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private IccScreeningFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private IccScreeningChannel[] <Channels>k__BackingField;
    public IccScreeningFlag Flags { get; }
    public IccScreeningChannel[] Channels { get; }
    public IccScreeningTagDataEntry(IccScreeningFlag flags, IccScreeningChannel[] channels);
    public IccScreeningTagDataEntry(IccScreeningFlag flags, IccScreeningChannel[] channels, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccScreeningFlag get_Flags();
    [CompilerGeneratedAttribute]
public IccScreeningChannel[] get_Channels();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccScreeningTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccSignatureName : Enum {
    public UInt32 value__;
    public static IccSignatureName Unknown;
    public static IccSignatureName SceneColorimetryEstimates;
    public static IccSignatureName SceneAppearanceEstimates;
    public static IccSignatureName FocalPlaneColorimetryEstimates;
    public static IccSignatureName ReflectionHardcopyOriginalColorimetry;
    public static IccSignatureName ReflectionPrintOutputColorimetry;
    public static IccSignatureName PerceptualReferenceMediumGamut;
    public static IccSignatureName FilmScanner;
    public static IccSignatureName DigitalCamera;
    public static IccSignatureName ReflectiveScanner;
    public static IccSignatureName InkJetPrinter;
    public static IccSignatureName ThermalWaxPrinter;
    public static IccSignatureName ElectrophotographicPrinter;
    public static IccSignatureName ElectrostaticPrinter;
    public static IccSignatureName DyeSublimationPrinter;
    public static IccSignatureName PhotographicPaperPrinter;
    public static IccSignatureName FilmWriter;
    public static IccSignatureName VideoMonitor;
    public static IccSignatureName VideoCamera;
    public static IccSignatureName ProjectionTelevision;
    public static IccSignatureName CathodeRayTubeDisplay;
    public static IccSignatureName PassiveMatrixDisplay;
    public static IccSignatureName ActiveMatrixDisplay;
    public static IccSignatureName PhotoCD;
    public static IccSignatureName PhotographicImageSetter;
    public static IccSignatureName Gravure;
    public static IccSignatureName OffsetLithography;
    public static IccSignatureName Silkscreen;
    public static IccSignatureName Flexography;
    public static IccSignatureName MotionPictureFilmScanner;
    public static IccSignatureName MotionPictureFilmRecorder;
    public static IccSignatureName DigitalMotionPictureCamera;
    public static IccSignatureName DigitalCinemaProjector;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccSignatureTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private string <SignatureData>k__BackingField;
    public string SignatureData { get; }
    public IccSignatureTagDataEntry(string signatureData);
    public IccSignatureTagDataEntry(string signatureData, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public string get_SignatureData();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccSignatureTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccStandardIlluminant : Enum {
    public UInt32 value__;
    public static IccStandardIlluminant Unknown;
    public static IccStandardIlluminant D50;
    public static IccStandardIlluminant D65;
    public static IccStandardIlluminant D93;
    public static IccStandardIlluminant F2;
    public static IccStandardIlluminant D55;
    public static IccStandardIlluminant A;
    public static IccStandardIlluminant EquiPowerE;
    public static IccStandardIlluminant F8;
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccStandardObserver : Enum {
    public UInt32 value__;
    public static IccStandardObserver Unknown;
    public static IccStandardObserver Cie1931Observer;
    public static IccStandardObserver Cie1964Observer;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccTagDataEntry : object {
    [CompilerGeneratedAttribute]
private IccTypeSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private IccProfileTag <TagSignature>k__BackingField;
    public IccTypeSignature Signature { get; }
    public IccProfileTag TagSignature { get; public set; }
    protected IccTagDataEntry(IccTypeSignature signature);
    protected IccTagDataEntry(IccTypeSignature signature, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public IccTypeSignature get_Signature();
    [CompilerGeneratedAttribute]
public IccProfileTag get_TagSignature();
    [CompilerGeneratedAttribute]
public void set_TagSignature(IccProfileTag value);
    public virtual bool Equals(object obj);
    public virtual bool Equals(IccTagDataEntry other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccTagTableEntry : ValueType {
    [CompilerGeneratedAttribute]
private IccProfileTag <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DataSize>k__BackingField;
    public IccProfileTag Signature { get; }
    public UInt32 Offset { get; }
    public UInt32 DataSize { get; }
    public IccTagTableEntry(IccProfileTag signature, UInt32 offset, UInt32 dataSize);
    [CompilerGeneratedAttribute]
public IccProfileTag get_Signature();
    [CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public UInt32 get_DataSize();
    public static bool op_Equality(IccTagTableEntry left, IccTagTableEntry right);
    public static bool op_Inequality(IccTagTableEntry left, IccTagTableEntry right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccTagTableEntry other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccTextDescriptionTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private string <Ascii>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Unicode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UnicodeLanguageCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ScriptCodeCode>k__BackingField;
    public string Ascii { get; }
    public string Unicode { get; }
    public string ScriptCode { get; }
    public UInt32 UnicodeLanguageCode { get; }
    public ushort ScriptCodeCode { get; }
    public IccTextDescriptionTagDataEntry(string ascii, string unicode, string scriptCode, UInt32 unicodeLanguageCode, ushort scriptCodeCode);
    public IccTextDescriptionTagDataEntry(string ascii, string unicode, string scriptCode, UInt32 unicodeLanguageCode, ushort scriptCodeCode, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public string get_Ascii();
    [CompilerGeneratedAttribute]
public string get_Unicode();
    [CompilerGeneratedAttribute]
public string get_ScriptCode();
    [CompilerGeneratedAttribute]
public UInt32 get_UnicodeLanguageCode();
    [CompilerGeneratedAttribute]
public ushort get_ScriptCodeCode();
    public static IccMultiLocalizedUnicodeTagDataEntry op_Explicit(IccTextDescriptionTagDataEntry textEntry);
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccTextDescriptionTagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static CultureInfo <op_Explicit>g__GetCulture|17_0(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccTextTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public IccTextTagDataEntry(string text);
    public IccTextTagDataEntry(string text, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public string get_Text();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccTextTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Icc.IccTypeSignature : Enum {
    public UInt32 value__;
    public static IccTypeSignature Unknown;
    public static IccTypeSignature Chromaticity;
    public static IccTypeSignature ColorantOrder;
    public static IccTypeSignature ColorantTable;
    public static IccTypeSignature Curve;
    public static IccTypeSignature Data;
    public static IccTypeSignature DateTime;
    public static IccTypeSignature Lut16;
    public static IccTypeSignature Lut8;
    public static IccTypeSignature LutAToB;
    public static IccTypeSignature LutBToA;
    public static IccTypeSignature Measurement;
    public static IccTypeSignature MultiLocalizedUnicode;
    public static IccTypeSignature MultiProcessElements;
    public static IccTypeSignature NamedColor2;
    public static IccTypeSignature ParametricCurve;
    public static IccTypeSignature ProfileSequenceDesc;
    public static IccTypeSignature ProfileSequenceIdentifier;
    public static IccTypeSignature ResponseCurveSet16;
    public static IccTypeSignature S15Fixed16Array;
    public static IccTypeSignature Signature;
    public static IccTypeSignature Text;
    public static IccTypeSignature U16Fixed16Array;
    public static IccTypeSignature UInt16Array;
    public static IccTypeSignature UInt32Array;
    public static IccTypeSignature UInt64Array;
    public static IccTypeSignature UInt8Array;
    public static IccTypeSignature ViewingConditions;
    public static IccTypeSignature Xyz;
    public static IccTypeSignature TextDescription;
    public static IccTypeSignature CrdInfo;
    public static IccTypeSignature Screening;
    public static IccTypeSignature UcrBg;
    public static IccTypeSignature DeviceSettings;
    public static IccTypeSignature NamedColor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUcrBgTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private UInt16[] <UcrCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <BgCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public UInt16[] UcrCurve { get; }
    public UInt16[] BgCurve { get; }
    public string Description { get; }
    public IccUcrBgTagDataEntry(UInt16[] ucrCurve, UInt16[] bgCurve, string description);
    public IccUcrBgTagDataEntry(UInt16[] ucrCurve, UInt16[] bgCurve, string description, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public UInt16[] get_UcrCurve();
    [CompilerGeneratedAttribute]
public UInt16[] get_BgCurve();
    [CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUcrBgTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUFix16ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Single[] <Data>k__BackingField;
    public Single[] Data { get; }
    public IccUFix16ArrayTagDataEntry(Single[] data);
    public IccUFix16ArrayTagDataEntry(Single[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Single[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUFix16ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUInt16ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private UInt16[] <Data>k__BackingField;
    public UInt16[] Data { get; }
    public IccUInt16ArrayTagDataEntry(UInt16[] data);
    public IccUInt16ArrayTagDataEntry(UInt16[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public UInt16[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUInt16ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUInt32ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private UInt32[] <Data>k__BackingField;
    public UInt32[] Data { get; }
    public IccUInt32ArrayTagDataEntry(UInt32[] data);
    public IccUInt32ArrayTagDataEntry(UInt32[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public UInt32[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUInt32ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUInt64ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private UInt64[] <Data>k__BackingField;
    public UInt64[] Data { get; }
    public IccUInt64ArrayTagDataEntry(UInt64[] data);
    public IccUInt64ArrayTagDataEntry(UInt64[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public UInt64[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUInt64ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUInt8ArrayTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public Byte[] Data { get; }
    public IccUInt8ArrayTagDataEntry(Byte[] data);
    public IccUInt8ArrayTagDataEntry(Byte[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUInt8ArrayTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccUnknownTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public Byte[] Data { get; }
    public IccUnknownTagDataEntry(Byte[] data);
    public IccUnknownTagDataEntry(Byte[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccUnknownTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccVersion : ValueType {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public IccVersion(int major, int minor, int patch);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    public static bool op_Equality(IccVersion left, IccVersion right);
    public static bool op_Inequality(IccVersion left, IccVersion right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IccVersion other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccViewingConditionsTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Vector3 <IlluminantXyz>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <SurroundXyz>k__BackingField;
    [CompilerGeneratedAttribute]
private IccStandardIlluminant <Illuminant>k__BackingField;
    public Vector3 IlluminantXyz { get; }
    public Vector3 SurroundXyz { get; }
    public IccStandardIlluminant Illuminant { get; }
    public IccViewingConditionsTagDataEntry(Vector3 illuminantXyz, Vector3 surroundXyz, IccStandardIlluminant illuminant);
    public IccViewingConditionsTagDataEntry(Vector3 illuminantXyz, Vector3 surroundXyz, IccStandardIlluminant illuminant, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Vector3 get_IlluminantXyz();
    [CompilerGeneratedAttribute]
public Vector3 get_SurroundXyz();
    [CompilerGeneratedAttribute]
public IccStandardIlluminant get_Illuminant();
    public virtual bool Equals(IccTagDataEntry other);
    public sealed virtual bool Equals(IccViewingConditionsTagDataEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccWriter : object {
    public static Byte[] Write(IccProfile profile);
    private static void WriteHeader(IccDataWriter writer, IccProfileHeader header);
    private static void WriteTagTable(IccDataWriter writer, IccTagTableEntry[] table);
    private static IccTagTableEntry[] WriteTagData(IccDataWriter writer, IccTagDataEntry[] entries);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Metadata.Profiles.Icc.IccXyzTagDataEntry : IccTagDataEntry {
    [CompilerGeneratedAttribute]
private Vector3[] <Data>k__BackingField;
    public Vector3[] Data { get; }
    public IccXyzTagDataEntry(Vector3[] data);
    public IccXyzTagDataEntry(Vector3[] data, IccProfileTag tagSignature);
    [CompilerGeneratedAttribute]
public Vector3[] get_Data();
    [NullableContextAttribute("2")]
public virtual bool Equals(IccTagDataEntry other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IccXyzTagDataEntry other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Icc.InvalidIccProfileException : Exception {
    public InvalidIccProfileException(string message);
    public InvalidIccProfileException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Iptc.IptcProfile : object {
    private Collection`1<IptcValue> values;
    private static byte IptcTagMarkerByte;
    private static UInt32 MaxStandardDataTagSize;
    private static byte IptcEnvelopeCodedCharacterSet;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> CodedCharacterSetUtf8Value { get; }
    [NullableAttribute("2")]
public Byte[] Data { get; private set; }
    public IEnumerable`1<IptcValue> Values { get; }
    [NullableContextAttribute("2")]
public IptcProfile(Byte[] data);
    private IptcProfile(IptcProfile other);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_CodedCharacterSetUtf8Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Data();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    public IEnumerable`1<IptcValue> get_Values();
    public sealed virtual IptcProfile DeepClone();
    public List`1<IptcValue> GetValues(IptcTag tag);
    public bool RemoveValue(IptcTag tag);
    public bool RemoveValue(IptcTag tag, string value);
    public void SetEncoding(Encoding encoding);
    public void SetValue(IptcTag tag, Encoding encoding, string value, bool strict);
    public void SetValue(IptcTag tag, string value, bool strict);
    public void SetDateTimeValue(IptcTag tag, DateTimeOffset dateTimeOffset);
    public void UpdateData();
    [NullableContextAttribute("0")]
private int WriteRecord(int offset, ReadOnlySpan`1<byte> recordData, IptcRecordNumber recordNumber, byte recordBinaryRepresentation);
    private void Initialize();
    private bool HasValuesInUtf8();
}
internal enum SixLabors.ImageSharp.Metadata.Profiles.IPTC.IptcRecordNumber : Enum {
    public byte value__;
    public static IptcRecordNumber Envelope;
    public static IptcRecordNumber Application;
}
public enum SixLabors.ImageSharp.Metadata.Profiles.Iptc.IptcTag : Enum {
    public int value__;
    public static IptcTag Unknown;
    public static IptcTag RecordVersion;
    public static IptcTag ObjectType;
    public static IptcTag ObjectAttribute;
    public static IptcTag Name;
    public static IptcTag EditStatus;
    public static IptcTag EditorialUpdate;
    public static IptcTag Urgency;
    public static IptcTag SubjectReference;
    public static IptcTag Category;
    public static IptcTag SupplementalCategories;
    public static IptcTag FixtureIdentifier;
    public static IptcTag Keywords;
    public static IptcTag LocationCode;
    public static IptcTag LocationName;
    public static IptcTag ReleaseDate;
    public static IptcTag ReleaseTime;
    public static IptcTag ExpirationDate;
    public static IptcTag ExpirationTime;
    public static IptcTag SpecialInstructions;
    public static IptcTag ActionAdvised;
    public static IptcTag ReferenceService;
    public static IptcTag ReferenceDate;
    public static IptcTag ReferenceNumber;
    public static IptcTag CreatedDate;
    public static IptcTag CreatedTime;
    public static IptcTag DigitalCreationDate;
    public static IptcTag DigitalCreationTime;
    public static IptcTag OriginatingProgram;
    public static IptcTag ProgramVersion;
    public static IptcTag ObjectCycle;
    public static IptcTag Byline;
    public static IptcTag BylineTitle;
    public static IptcTag City;
    public static IptcTag SubLocation;
    public static IptcTag ProvinceState;
    public static IptcTag CountryCode;
    public static IptcTag Country;
    public static IptcTag OriginalTransmissionReference;
    public static IptcTag Headline;
    public static IptcTag Credit;
    public static IptcTag Source;
    public static IptcTag CopyrightNotice;
    public static IptcTag Contact;
    public static IptcTag Caption;
    public static IptcTag LocalCaption;
    public static IptcTag CaptionWriter;
    public static IptcTag ImageType;
    public static IptcTag ImageOrientation;
    public static IptcTag CustomField1;
    public static IptcTag CustomField2;
    public static IptcTag CustomField3;
    public static IptcTag CustomField4;
    public static IptcTag CustomField5;
    public static IptcTag CustomField6;
    public static IptcTag CustomField7;
    public static IptcTag CustomField8;
    public static IptcTag CustomField9;
    public static IptcTag CustomField10;
    public static IptcTag CustomField11;
    public static IptcTag CustomField12;
    public static IptcTag CustomField13;
    public static IptcTag CustomField14;
    public static IptcTag CustomField15;
    public static IptcTag CustomField16;
    public static IptcTag CustomField17;
    public static IptcTag CustomField18;
    public static IptcTag CustomField19;
    public static IptcTag CustomField20;
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Metadata.Profiles.Iptc.IptcTagExtensions : object {
    [ExtensionAttribute]
public static int MaxLength(IptcTag tag);
    [ExtensionAttribute]
public static bool IsRepeatable(IptcTag tag);
    [ExtensionAttribute]
public static bool IsDate(IptcTag tag);
    [ExtensionAttribute]
public static bool IsTime(IptcTag tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Iptc.IptcValue : object {
    private Byte[] data;
    private Encoding encoding;
    [CompilerGeneratedAttribute]
private IptcTag <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    public Encoding Encoding { get; public set; }
    public IptcTag Tag { get; }
    public bool Strict { get; public set; }
    public string Value { get; public set; }
    public int Length { get; }
    internal IptcValue(IptcValue other);
    internal IptcValue(IptcTag tag, Byte[] value, bool strict);
    internal IptcValue(IptcTag tag, Encoding encoding, string value, bool strict);
    internal IptcValue(IptcTag tag, string value, bool strict);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public IptcTag get_Tag();
    [CompilerGeneratedAttribute]
public bool get_Strict();
    [CompilerGeneratedAttribute]
public void set_Strict(bool value);
    public string get_Value();
    public void set_Value(string value);
    public int get_Length();
    public sealed virtual IptcValue DeepClone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(IptcValue other);
    public virtual int GetHashCode();
    public Byte[] ToByteArray();
    public virtual string ToString();
    public string ToString(Encoding encoding);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Metadata.Profiles.Xmp.XmpProfile : object {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal Byte[] Data { get; private set; }
    public XmpProfile(Byte[] data);
    [NullableContextAttribute("1")]
private XmpProfile(XmpProfile other);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    public XDocument GetDocument();
    [NullableContextAttribute("1")]
public Byte[] ToByteArray();
    [NullableContextAttribute("1")]
public sealed virtual XmpProfile DeepClone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.MetadataExtensions : object {
    [ExtensionAttribute]
public static BmpMetadata GetBmpMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static GifMetadata GetGifMetadata(ImageMetadata source);
    [ExtensionAttribute]
public static bool TryGetGifMetadata(ImageMetadata source, GifMetadata& metadata);
    [ExtensionAttribute]
public static GifFrameMetadata GetGifMetadata(ImageFrameMetadata source);
    [ExtensionAttribute]
public static bool TryGetGifMetadata(ImageFrameMetadata source, GifFrameMetadata& metadata);
    [ExtensionAttribute]
internal static AnimatedImageMetadata ToAnimatedImageMetadata(GifMetadata source);
    [ExtensionAttribute]
internal static AnimatedImageFrameMetadata ToAnimatedImageFrameMetadata(GifFrameMetadata source);
    private static FrameDisposalMode GetMode(GifDisposalMethod method);
    [ExtensionAttribute]
public static JpegMetadata GetJpegMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static PbmMetadata GetPbmMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static PngMetadata GetPngMetadata(ImageMetadata source);
    [ExtensionAttribute]
public static bool TryGetPngMetadata(ImageMetadata source, PngMetadata& metadata);
    [ExtensionAttribute]
public static PngFrameMetadata GetPngMetadata(ImageFrameMetadata source);
    [ExtensionAttribute]
public static bool TryGetPngMetadata(ImageFrameMetadata source, PngFrameMetadata& metadata);
    [ExtensionAttribute]
internal static AnimatedImageMetadata ToAnimatedImageMetadata(PngMetadata source);
    [ExtensionAttribute]
internal static AnimatedImageFrameMetadata ToAnimatedImageFrameMetadata(PngFrameMetadata source);
    private static FrameDisposalMode GetMode(PngDisposalMethod method);
    [ExtensionAttribute]
public static QoiMetadata GetQoiMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static TgaMetadata GetTgaMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static TiffMetadata GetTiffMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static TiffFrameMetadata GetTiffMetadata(ImageFrameMetadata metadata);
    [ExtensionAttribute]
public static WebpMetadata GetWebpMetadata(ImageMetadata metadata);
    [ExtensionAttribute]
public static bool TryGetWebpMetadata(ImageMetadata source, WebpMetadata& metadata);
    [ExtensionAttribute]
public static WebpFrameMetadata GetWebpMetadata(ImageFrameMetadata metadata);
    [ExtensionAttribute]
public static bool TryGetWebpFrameMetadata(ImageFrameMetadata source, WebpFrameMetadata& metadata);
    [ExtensionAttribute]
internal static AnimatedImageMetadata ToAnimatedImageMetadata(WebpMetadata source);
    [ExtensionAttribute]
internal static AnimatedImageFrameMetadata ToAnimatedImageFrameMetadata(WebpFrameMetadata source);
    private static FrameDisposalMode GetMode(WebpDisposalMethod method);
}
public class SixLabors.ImageSharp.Number : ValueType {
    private int signedValue;
    private UInt32 unsignedValue;
    private bool isSigned;
    public Number(int value);
    public Number(UInt32 value);
    public static Number op_Implicit(int value);
    public static Number op_Implicit(UInt32 value);
    public static Number op_Implicit(ushort value);
    public static int op_Explicit(Number number);
    public static UInt32 op_Explicit(Number number);
    public static ushort op_Explicit(Number number);
    public static bool op_Equality(Number left, Number right);
    public static bool op_Inequality(Number left, Number right);
    public static bool op_GreaterThan(Number left, Number right);
    public static bool op_LessThan(Number left, Number right);
    public static bool op_GreaterThanOrEqual(Number left, Number right);
    public static bool op_LessThanOrEqual(Number left, Number right);
    public sealed virtual int CompareTo(Number other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Number other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Numerics : object {
    public static int BlendAlphaControl;
    private static int ShuffleAlphaControl;
    public static int GreatestCommonDivisor(int a, int b);
    public static int LeastCommonMultiple(int a, int b);
    public static int Modulo2(int x);
    public static int Modulo4(int x);
    public static IntPtr Modulo4(IntPtr x);
    public static int Modulo8(int x);
    public static IntPtr Modulo8(IntPtr x);
    public static int Modulo64(int x);
    public static IntPtr Modulo64(IntPtr x);
    public static int Modulo256(int x);
    public static IntPtr Modulo256(IntPtr x);
    public static int ModuloP2(int x, int m);
    public static int Abs(int x);
    public static float Pow2(float x);
    public static float Pow3(float x);
    public static float Gaussian(float x, float sigma);
    public static float SinC(float f);
    public static byte Clamp(byte value, byte min, byte max);
    public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    public static int Clamp(int value, int min, int max);
    public static float Clamp(float value, float min, float max);
    public static double Clamp(double value, double min, double max);
    public static Vector4 Clamp(Vector4 value, Vector4 min, Vector4 max);
    public static void Clamp(Span`1<byte> span, byte min, byte max);
    public static void Clamp(Span`1<UInt32> span, UInt32 min, UInt32 max);
    public static void Clamp(Span`1<int> span, int min, int max);
    public static void Clamp(Span`1<float> span, float min, float max);
    public static void Clamp(Span`1<double> span, double min, double max);
    private static int ClampReduce(Span`1<T> span, T min, T max);
    private static void ClampImpl(Span`1<T> span, T min, T max);
    public static void Premultiply(Vector4& source);
    public static void Premultiply(Span`1<Vector4> vectors);
    public static void UnPremultiply(Vector4& source);
    public static void UnPremultiply(Vector4& source, Vector4 alpha);
    public static void UnPremultiply(Span`1<Vector4> vectors);
    public static Vector256`1<float> UnPremultiply(Vector256`1<float> source, Vector256`1<float> alpha);
    public static Vector4 PermuteW(Vector4 value);
    public static Vector4 WithW(Vector4 value, Vector4 w);
    public static void CubePowOnXYZ(Span`1<Vector4> vectors);
    public static void CubeRootOnXYZ(Span`1<Vector4> vectors);
    public static Vector256`1<float> Lerp(Vector256`1& value1, Vector256`1& value2, Vector256`1& amount);
    public static float Lerp(float value1, float value2, float amount);
    public static void Accumulate(Vector`1& accumulator, Vector`1<byte> values);
    public static int ReduceSum(Vector128`1<int> accumulator);
    public static int ReduceSum(Vector256`1<int> accumulator);
    public static int ReduceSumArm(Vector128`1<UInt32> accumulator);
    public static int EvenReduceSum(Vector128`1<int> accumulator);
    public static int EvenReduceSum(Vector256`1<int> accumulator);
    public static UInt32 DivideCeil(UInt32 value, UInt32 divisor);
    public static bool IsOutOfRange(int value, int min, int max);
    [ExtensionAttribute]
public static UIntPtr VectorCount(Span`1<byte> span);
    [ExtensionAttribute]
public static UIntPtr Vector128Count(Span`1<byte> span);
    [ExtensionAttribute]
public static UIntPtr Vector128Count(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static UIntPtr Vector256Count(Span`1<byte> span);
    [ExtensionAttribute]
public static UIntPtr Vector256Count(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static UIntPtr VectorCount(Span`1<float> span);
    [ExtensionAttribute]
public static UIntPtr Vector128Count(Span`1<float> span);
    [ExtensionAttribute]
public static UIntPtr Vector256Count(Span`1<float> span);
    public static UIntPtr Vector256Count(int length);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class SixLabors.ImageSharp.PixelAccessor`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> buffer;
    public int Width { get; }
    public int Height { get; }
    internal PixelAccessor`1(Buffer2D`1<TPixel> buffer);
    public int get_Width();
    public int get_Height();
    public Span`1<TPixel> GetRowSpan(int rowIndex);
}
public class SixLabors.ImageSharp.PixelAccessorAction`1 : MulticastDelegate {
    public PixelAccessorAction`1(object object, IntPtr method);
    public virtual void Invoke(PixelAccessor`1<TPixel> pixelAccessor);
    public virtual IAsyncResult BeginInvoke(PixelAccessor`1<TPixel> pixelAccessor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SixLabors.ImageSharp.PixelAccessorAction`2 : MulticastDelegate {
    public PixelAccessorAction`2(object object, IntPtr method);
    public virtual void Invoke(PixelAccessor`1<TPixel1> pixelAccessor1, PixelAccessor`1<TPixel2> pixelAccessor2);
    public virtual IAsyncResult BeginInvoke(PixelAccessor`1<TPixel1> pixelAccessor1, PixelAccessor`1<TPixel2> pixelAccessor2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SixLabors.ImageSharp.PixelAccessorAction`3 : MulticastDelegate {
    public PixelAccessorAction`3(object object, IntPtr method);
    public virtual void Invoke(PixelAccessor`1<TPixel1> pixelAccessor1, PixelAccessor`1<TPixel2> pixelAccessor2, PixelAccessor`1<TPixel3> pixelAccessor3);
    public virtual IAsyncResult BeginInvoke(PixelAccessor`1<TPixel1> pixelAccessor1, PixelAccessor`1<TPixel2> pixelAccessor2, PixelAccessor`1<TPixel3> pixelAccessor3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SixLabors.ImageSharp.PixelFormats.A8 : ValueType {
    [CompilerGeneratedAttribute]
private byte <PackedValue>k__BackingField;
    public byte PackedValue { get; public set; }
    public A8(byte alpha);
    public A8(float alpha);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual byte get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(byte value);
    public static bool op_Equality(A8 left, A8 right);
    public static bool op_Inequality(A8 left, A8 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<A8> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(A8 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static byte Pack(float alpha);
}
public class SixLabors.ImageSharp.PixelFormats.Abgr32 : ValueType {
    public byte A;
    public byte B;
    public byte G;
    public byte R;
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public UInt32 Abgr { get; public set; }
    public UInt32 PackedValue { get; public set; }
    public Abgr32(byte r, byte g, byte b);
    public Abgr32(byte r, byte g, byte b, byte a);
    public Abgr32(float r, float g, float b, float a);
    public Abgr32(Vector3 vector);
    public Abgr32(Vector4 vector);
    public Abgr32(UInt32 packed);
    private static Abgr32();
    [IsReadOnlyAttribute]
public UInt32 get_Abgr();
    public void set_Abgr(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 get_PackedValue();
    public sealed virtual void set_PackedValue(UInt32 value);
    public static Color op_Implicit(Abgr32 source);
    public static Abgr32 op_Implicit(Color color);
    public static bool op_Equality(Abgr32 left, Abgr32 right);
    public static bool op_Inequality(Abgr32 left, Abgr32 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Abgr32> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Abgr32 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private void Pack(float x, float y, float z, float w);
    private void Pack(Vector3& vector);
    private void Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Argb32 : ValueType {
    public byte A;
    public byte R;
    public byte G;
    public byte B;
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public UInt32 Argb { get; public set; }
    public UInt32 PackedValue { get; public set; }
    public Argb32(byte r, byte g, byte b);
    public Argb32(byte r, byte g, byte b, byte a);
    public Argb32(float r, float g, float b, float a);
    public Argb32(Vector3 vector);
    public Argb32(Vector4 vector);
    public Argb32(UInt32 packed);
    private static Argb32();
    [IsReadOnlyAttribute]
public UInt32 get_Argb();
    public void set_Argb(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 get_PackedValue();
    public sealed virtual void set_PackedValue(UInt32 value);
    public static Color op_Implicit(Argb32 source);
    public static Argb32 op_Implicit(Color color);
    public static bool op_Equality(Argb32 left, Argb32 right);
    public static bool op_Inequality(Argb32 left, Argb32 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Argb32> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Argb32 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private void Pack(float x, float y, float z, float w);
    private void Pack(Vector3& vector);
    private void Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Bgr24 : ValueType {
    public byte B;
    public byte G;
    public byte R;
    public Bgr24(byte r, byte g, byte b);
    public static Color op_Implicit(Bgr24 source);
    public static Bgr24 op_Implicit(Color color);
    public static bool op_Equality(Bgr24 left, Bgr24 right);
    public static bool op_Inequality(Bgr24 left, Bgr24 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Bgr24> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Bgr24 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.PixelFormats.Bgr565 : ValueType {
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public Bgr565(float x, float y, float z);
    public Bgr565(Vector3 vector);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(Bgr565 left, Bgr565 right);
    public static bool op_Inequality(Bgr565 left, Bgr565 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Bgr565> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector3 ToVector3();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Bgr565 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static ushort Pack(Vector3& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Bgra32 : ValueType {
    public byte B;
    public byte G;
    public byte R;
    public byte A;
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public UInt32 Bgra { get; public set; }
    public UInt32 PackedValue { get; public set; }
    public Bgra32(byte r, byte g, byte b);
    public Bgra32(byte r, byte g, byte b, byte a);
    private static Bgra32();
    [IsReadOnlyAttribute]
public UInt32 get_Bgra();
    public void set_Bgra(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 get_PackedValue();
    public sealed virtual void set_PackedValue(UInt32 value);
    public static Color op_Implicit(Bgra32 source);
    public static Bgra32 op_Implicit(Color color);
    public static bool op_Equality(Bgra32 left, Bgra32 right);
    public static bool op_Inequality(Bgra32 left, Bgra32 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Bgra32> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Bgra32 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private void Pack(Vector4 vector);
}
public class SixLabors.ImageSharp.PixelFormats.Bgra4444 : ValueType {
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public Bgra4444(float x, float y, float z, float w);
    public Bgra4444(Vector4 vector);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(Bgra4444 left, Bgra4444 right);
    public static bool op_Inequality(Bgra4444 left, Bgra4444 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Bgra4444> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Bgra4444 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static ushort Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Bgra5551 : ValueType {
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public Bgra5551(float x, float y, float z, float w);
    public Bgra5551(Vector4 vector);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(Bgra5551 left, Bgra5551 right);
    public static bool op_Inequality(Bgra5551 left, Bgra5551 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Bgra5551> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Bgra5551 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static ushort Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Byte4 : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public Byte4(Vector4 vector);
    public Byte4(float x, float y, float z, float w);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(Byte4 left, Byte4 right);
    public static bool op_Inequality(Byte4 left, Byte4 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Byte4> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Byte4 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static UInt32 Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.HalfSingle : ValueType {
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public HalfSingle(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(HalfSingle left, HalfSingle right);
    public static bool op_Inequality(HalfSingle left, HalfSingle right);
    [NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<HalfSingle> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public float ToSingle();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(HalfSingle other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal static class SixLabors.ImageSharp.PixelFormats.HalfTypeHelper : object {
    internal static ushort Pack(float value);
    internal static float Unpack(ushort value);
}
public class SixLabors.ImageSharp.PixelFormats.HalfVector2 : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public HalfVector2(float x, float y);
    public HalfVector2(Vector2 vector);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(HalfVector2 left, HalfVector2 right);
    public static bool op_Inequality(HalfVector2 left, HalfVector2 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<HalfVector2> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector2 ToVector2();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(HalfVector2 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static UInt32 Pack(float x, float y);
}
public class SixLabors.ImageSharp.PixelFormats.HalfVector4 : ValueType {
    [CompilerGeneratedAttribute]
private ulong <PackedValue>k__BackingField;
    public ulong PackedValue { get; public set; }
    public HalfVector4(float x, float y, float z, float w);
    public HalfVector4(Vector4 vector);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ulong value);
    public static bool op_Equality(HalfVector4 left, HalfVector4 right);
    public static bool op_Inequality(HalfVector4 left, HalfVector4 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<HalfVector4> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(HalfVector4 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static ulong Pack(Vector4& vector);
}
public interface SixLabors.ImageSharp.PixelFormats.IPackedVector`1 {
    public TPacked PackedValue { get; public set; }
    public abstract virtual TPacked get_PackedValue();
    public abstract virtual void set_PackedValue(TPacked value);
}
public interface SixLabors.ImageSharp.PixelFormats.IPixel {
    public abstract virtual void FromScaledVector4(Vector4 vector);
    public abstract virtual Vector4 ToScaledVector4();
    public abstract virtual void FromVector4(Vector4 vector);
    public abstract virtual Vector4 ToVector4();
    public abstract virtual void FromArgb32(Argb32 source);
    public abstract virtual void FromBgra5551(Bgra5551 source);
    public abstract virtual void FromBgr24(Bgr24 source);
    public abstract virtual void FromBgra32(Bgra32 source);
    public abstract virtual void FromAbgr32(Abgr32 source);
    public abstract virtual void FromL8(L8 source);
    public abstract virtual void FromL16(L16 source);
    public abstract virtual void FromLa16(La16 source);
    public abstract virtual void FromLa32(La32 source);
    public abstract virtual void FromRgb24(Rgb24 source);
    public abstract virtual void FromRgba32(Rgba32 source);
    public abstract virtual void ToRgba32(Rgba32& dest);
    public abstract virtual void FromRgb48(Rgb48 source);
    public abstract virtual void FromRgba64(Rgba64 source);
}
public interface SixLabors.ImageSharp.PixelFormats.IPixel`1 {
    public abstract virtual PixelOperations`1<TSelf> CreatePixelOperations();
}
public class SixLabors.ImageSharp.PixelFormats.L16 : ValueType {
    private static float Max;
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public L16(ushort luminance);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(L16 left, L16 right);
    public static bool op_Inequality(L16 left, L16 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<L16> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(L16 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    internal void ConvertFromRgbaScaledVector4(Vector4 vector);
}
public class SixLabors.ImageSharp.PixelFormats.L8 : ValueType {
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    [CompilerGeneratedAttribute]
private byte <PackedValue>k__BackingField;
    public byte PackedValue { get; public set; }
    public L8(byte luminance);
    private static L8();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual byte get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(byte value);
    public static bool op_Equality(L8 left, L8 right);
    public static bool op_Inequality(L8 left, L8 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<L8> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(L8 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    internal void ConvertFromRgbaScaledVector4(Vector4 vector);
}
public class SixLabors.ImageSharp.PixelFormats.La16 : ValueType {
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public byte L;
    public byte A;
    public ushort PackedValue { get; public set; }
    public La16(byte l, byte a);
    private static La16();
    [IsReadOnlyAttribute]
public sealed virtual ushort get_PackedValue();
    public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(La16 left, La16 right);
    public static bool op_Inequality(La16 left, La16 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<La16> CreatePixelOperations();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(La16 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    public sealed virtual void FromScaledVector4(Vector4 vector);
    public sealed virtual void FromVector4(Vector4 vector);
    public sealed virtual void ToRgba32(Rgba32& dest);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    internal void ConvertFromRgbaScaledVector4(Vector4 vector);
}
public class SixLabors.ImageSharp.PixelFormats.La32 : ValueType {
    private static float Max;
    public ushort L;
    public ushort A;
    public UInt32 PackedValue { get; public set; }
    public La32(ushort l, ushort a);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 get_PackedValue();
    public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(La32 left, La32 right);
    public static bool op_Inequality(La32 left, La32 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<La32> CreatePixelOperations();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(La32 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    public sealed virtual void FromScaledVector4(Vector4 vector);
    public sealed virtual void FromVector4(Vector4 vector);
    public sealed virtual void ToRgba32(Rgba32& dest);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    internal void ConvertFromRgbaScaledVector4(Vector4 vector);
}
public class SixLabors.ImageSharp.PixelFormats.NormalizedByte2 : ValueType {
    private static float MaxPos;
    private static Vector2 Half;
    private static Vector2 MinusOne;
    [CompilerGeneratedAttribute]
private ushort <PackedValue>k__BackingField;
    public ushort PackedValue { get; public set; }
    public NormalizedByte2(float x, float y);
    public NormalizedByte2(Vector2 vector);
    private static NormalizedByte2();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ushort get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ushort value);
    public static bool op_Equality(NormalizedByte2 left, NormalizedByte2 right);
    public static bool op_Inequality(NormalizedByte2 left, NormalizedByte2 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<NormalizedByte2> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector2 ToVector2();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(NormalizedByte2 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static ushort Pack(Vector2 vector);
}
public class SixLabors.ImageSharp.PixelFormats.NormalizedByte4 : ValueType {
    private static float MaxPos;
    private static Vector4 Half;
    private static Vector4 MinusOne;
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public NormalizedByte4(float x, float y, float z, float w);
    public NormalizedByte4(Vector4 vector);
    private static NormalizedByte4();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(NormalizedByte4 left, NormalizedByte4 right);
    public static bool op_Inequality(NormalizedByte4 left, NormalizedByte4 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<NormalizedByte4> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(NormalizedByte4 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static UInt32 Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.NormalizedShort2 : ValueType {
    private static float MaxPos;
    private static Vector2 Max;
    private static Vector2 Min;
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public NormalizedShort2(float x, float y);
    public NormalizedShort2(Vector2 vector);
    private static NormalizedShort2();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(NormalizedShort2 left, NormalizedShort2 right);
    public static bool op_Inequality(NormalizedShort2 left, NormalizedShort2 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<NormalizedShort2> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector2 ToVector2();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(NormalizedShort2 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static UInt32 Pack(Vector2 vector);
}
public class SixLabors.ImageSharp.PixelFormats.NormalizedShort4 : ValueType {
    private static float MaxPos;
    private static Vector4 Max;
    private static Vector4 Min;
    [CompilerGeneratedAttribute]
private ulong <PackedValue>k__BackingField;
    public ulong PackedValue { get; public set; }
    public NormalizedShort4(float x, float y, float z, float w);
    public NormalizedShort4(Vector4 vector);
    private static NormalizedShort4();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ulong value);
    public static bool op_Equality(NormalizedShort4 left, NormalizedShort4 right);
    public static bool op_Inequality(NormalizedShort4 left, NormalizedShort4 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<NormalizedShort4> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(NormalizedShort4 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static ulong Pack(Vector4& vector);
}
public enum SixLabors.ImageSharp.PixelFormats.PixelAlphaCompositionMode : Enum {
    public int value__;
    public static PixelAlphaCompositionMode SrcOver;
    public static PixelAlphaCompositionMode Src;
    public static PixelAlphaCompositionMode SrcAtop;
    public static PixelAlphaCompositionMode SrcIn;
    public static PixelAlphaCompositionMode SrcOut;
    public static PixelAlphaCompositionMode Dest;
    public static PixelAlphaCompositionMode DestAtop;
    public static PixelAlphaCompositionMode DestOver;
    public static PixelAlphaCompositionMode DestIn;
    public static PixelAlphaCompositionMode DestOut;
    public static PixelAlphaCompositionMode Clear;
    public static PixelAlphaCompositionMode Xor;
}
public enum SixLabors.ImageSharp.PixelFormats.PixelAlphaRepresentation : Enum {
    public int value__;
    public static PixelAlphaRepresentation None;
    public static PixelAlphaRepresentation Associated;
    public static PixelAlphaRepresentation Unassociated;
}
public abstract class SixLabors.ImageSharp.PixelFormats.PixelBlender`1 : object {
    public abstract virtual TPixel Blend(TPixel background, TPixel source, float amount);
    public void Blend(Configuration configuration, Span`1<TPixel> destination, ReadOnlySpan`1<TPixel> background, ReadOnlySpan`1<TPixelSrc> source, float amount);
    public void Blend(Configuration configuration, Span`1<TPixel> destination, ReadOnlySpan`1<TPixel> background, ReadOnlySpan`1<TPixel> source, ReadOnlySpan`1<float> amount);
    public void Blend(Configuration configuration, Span`1<TPixel> destination, ReadOnlySpan`1<TPixel> background, ReadOnlySpan`1<TPixelSrc> source, ReadOnlySpan`1<float> amount);
    protected abstract virtual void BlendFunction(Span`1<Vector4> destination, ReadOnlySpan`1<Vector4> background, ReadOnlySpan`1<Vector4> source, float amount);
    protected abstract virtual void BlendFunction(Span`1<Vector4> destination, ReadOnlySpan`1<Vector4> background, ReadOnlySpan`1<Vector4> source, ReadOnlySpan`1<float> amount);
}
internal static class SixLabors.ImageSharp.PixelFormats.PixelBlenders.DefaultPixelBlenders`1 : object {
}
internal static class SixLabors.ImageSharp.PixelFormats.PixelBlenders.PorterDuffFunctions : object {
    private static int BlendAlphaControl;
    private static int ShuffleAlphaControl;
    public static Vector4 Normal(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Normal(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Multiply(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Multiply(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Add(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Add(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Subtract(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Subtract(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Screen(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Screen(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Darken(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Darken(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Lighten(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Lighten(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Overlay(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> Overlay(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 HardLight(Vector4 backdrop, Vector4 source);
    public static Vector256`1<float> HardLight(Vector256`1<float> backdrop, Vector256`1<float> source);
    private static float OverlayValueFunction(float backdrop, float source);
    public static Vector256`1<float> OverlayValueFunction(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 Over(Vector4 destination, Vector4 source, Vector4 blend);
    public static Vector256`1<float> Over(Vector256`1<float> destination, Vector256`1<float> source, Vector256`1<float> blend);
    public static Vector4 Atop(Vector4 destination, Vector4 source, Vector4 blend);
    public static Vector256`1<float> Atop(Vector256`1<float> destination, Vector256`1<float> source, Vector256`1<float> blend);
    public static Vector4 In(Vector4 destination, Vector4 source);
    public static Vector256`1<float> In(Vector256`1<float> destination, Vector256`1<float> source);
    public static Vector4 Out(Vector4 destination, Vector4 source);
    public static Vector256`1<float> Out(Vector256`1<float> destination, Vector256`1<float> source);
    public static Vector4 Xor(Vector4 destination, Vector4 source);
    public static Vector256`1<float> Xor(Vector256`1<float> destination, Vector256`1<float> source);
    private static Vector4 Clear(Vector4 backdrop, Vector4 source);
    private static Vector256`1<float> Clear(Vector256`1<float> backdrop, Vector256`1<float> source);
    public static Vector4 NormalSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 NormalClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> NormalClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel NormalSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel NormalXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 MultiplySrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplySrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplySrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplySrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplySrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplySrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplySrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplySrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplySrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplySrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 MultiplyClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> MultiplyClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel MultiplySrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplySrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplySrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplySrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplySrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel MultiplyXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 AddSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 AddClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> AddClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel AddSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel AddXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 SubtractSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 SubtractClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> SubtractClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel SubtractSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel SubtractXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 ScreenSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 ScreenClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> ScreenClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel ScreenSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel ScreenXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 DarkenSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 DarkenClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> DarkenClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel DarkenSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel DarkenXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 LightenSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 LightenClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> LightenClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel LightenSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel LightenXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 OverlaySrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlaySrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlaySrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlaySrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlaySrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlaySrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlaySrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlaySrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlaySrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlaySrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 OverlayClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> OverlayClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel OverlaySrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlaySrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlaySrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlaySrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlaySrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel OverlayXor(TPixel backdrop, TPixel source, float opacity);
    public static Vector4 HardLightSrc(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightSrc(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightSrcAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightSrcAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightSrcOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightSrcOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightSrcIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightSrcIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightSrcOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightSrcOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightDest(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightDest(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightDestAtop(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightDestAtop(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightDestOver(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightDestOver(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightDestIn(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightDestIn(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightDestOut(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightDestOut(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightXor(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightXor(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static Vector4 HardLightClear(Vector4 backdrop, Vector4 source, float opacity);
    public static Vector256`1<float> HardLightClear(Vector256`1<float> backdrop, Vector256`1<float> source, Vector256`1<float> opacity);
    public static TPixel HardLightSrc(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightSrcAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightSrcOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightSrcIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightSrcOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightDest(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightDestAtop(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightDestOver(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightDestIn(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightDestOut(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightClear(TPixel backdrop, TPixel source, float opacity);
    public static TPixel HardLightXor(TPixel backdrop, TPixel source, float opacity);
}
public enum SixLabors.ImageSharp.PixelFormats.PixelColorBlendingMode : Enum {
    public int value__;
    public static PixelColorBlendingMode Normal;
    public static PixelColorBlendingMode Multiply;
    public static PixelColorBlendingMode Add;
    public static PixelColorBlendingMode Subtract;
    public static PixelColorBlendingMode Screen;
    public static PixelColorBlendingMode Darken;
    public static PixelColorBlendingMode Lighten;
    public static PixelColorBlendingMode Overlay;
    public static PixelColorBlendingMode HardLight;
}
[FlagsAttribute]
public enum SixLabors.ImageSharp.PixelFormats.PixelConversionModifiers : Enum {
    public int value__;
    public static PixelConversionModifiers None;
    public static PixelConversionModifiers Scale;
    public static PixelConversionModifiers Premultiply;
    public static PixelConversionModifiers SRgbCompand;
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.PixelFormats.PixelConversionModifiersExtensions : object {
    [ExtensionAttribute]
public static bool IsDefined(PixelConversionModifiers modifiers, PixelConversionModifiers expected);
    [ExtensionAttribute]
public static PixelConversionModifiers Remove(PixelConversionModifiers modifiers, PixelConversionModifiers removeThis);
    [ExtensionAttribute]
public static PixelConversionModifiers ApplyCompanding(PixelConversionModifiers originalModifiers, bool compand);
}
public class SixLabors.ImageSharp.PixelFormats.PixelOperations`1 : object {
    [NullableAttribute("1")]
private static Lazy`1<PixelTypeInfo> LazyInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<PixelOperations`1<TPixel>> LazyInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PixelOperations`1<TPixel> Instance { get; }
    private static PixelOperations`1();
    public static PixelOperations`1<TPixel> get_Instance();
    [NullableContextAttribute("1")]
public virtual PixelTypeInfo GetPixelTypeInfo();
    public virtual void FromVector4Destructive(Configuration configuration, Span`1<Vector4> sourceVectors, Span`1<TPixel> destinationPixels, PixelConversionModifiers modifiers);
    public void FromVector4Destructive(Configuration configuration, Span`1<Vector4> sourceVectors, Span`1<TPixel> destinationPixels);
    public virtual void ToVector4(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Vector4> destinationVectors, PixelConversionModifiers modifiers);
    public void ToVector4(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Vector4> destinationVectors);
    public virtual void From(Configuration configuration, ReadOnlySpan`1<TSourcePixel> sourcePixels, Span`1<TPixel> destinationPixels);
    public virtual void To(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<TDestinationPixel> destinationPixels);
    internal virtual void PackFromRgbPlanes(ReadOnlySpan`1<byte> redChannel, ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<TPixel> destination);
    internal virtual void UnpackIntoRgbPlanes(Span`1<float> redChannel, Span`1<float> greenChannel, Span`1<float> blueChannel, ReadOnlySpan`1<TPixel> source);
    internal static void GuardUnpackIntoRgbPlanes(Span`1<float> redChannel, Span`1<float> greenChannel, Span`1<float> blueChannel, ReadOnlySpan`1<TPixel> source);
    internal static void GuardPackFromRgbPlanes(ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<TPixel> destination, int count);
    public virtual void FromArgb32(Configuration configuration, ReadOnlySpan`1<Argb32> source, Span`1<TPixel> destinationPixels);
    public void FromArgb32Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToArgb32(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Argb32> destinationPixels);
    public void ToArgb32Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromAbgr32(Configuration configuration, ReadOnlySpan`1<Abgr32> source, Span`1<TPixel> destinationPixels);
    public void FromAbgr32Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToAbgr32(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Abgr32> destinationPixels);
    public void ToAbgr32Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromBgr24(Configuration configuration, ReadOnlySpan`1<Bgr24> source, Span`1<TPixel> destinationPixels);
    public void FromBgr24Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToBgr24(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Bgr24> destinationPixels);
    public void ToBgr24Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromBgra32(Configuration configuration, ReadOnlySpan`1<Bgra32> source, Span`1<TPixel> destinationPixels);
    public void FromBgra32Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToBgra32(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Bgra32> destinationPixels);
    public void ToBgra32Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromL8(Configuration configuration, ReadOnlySpan`1<L8> source, Span`1<TPixel> destinationPixels);
    public void FromL8Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToL8(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<L8> destinationPixels);
    public void ToL8Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromL16(Configuration configuration, ReadOnlySpan`1<L16> source, Span`1<TPixel> destinationPixels);
    public void FromL16Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToL16(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<L16> destinationPixels);
    public void ToL16Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromLa16(Configuration configuration, ReadOnlySpan`1<La16> source, Span`1<TPixel> destinationPixels);
    public void FromLa16Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToLa16(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<La16> destinationPixels);
    public void ToLa16Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromLa32(Configuration configuration, ReadOnlySpan`1<La32> source, Span`1<TPixel> destinationPixels);
    public void FromLa32Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToLa32(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<La32> destinationPixels);
    public void ToLa32Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromRgb24(Configuration configuration, ReadOnlySpan`1<Rgb24> source, Span`1<TPixel> destinationPixels);
    public void FromRgb24Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToRgb24(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Rgb24> destinationPixels);
    public void ToRgb24Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromRgba32(Configuration configuration, ReadOnlySpan`1<Rgba32> source, Span`1<TPixel> destinationPixels);
    public void FromRgba32Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToRgba32(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Rgba32> destinationPixels);
    public void ToRgba32Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromRgb48(Configuration configuration, ReadOnlySpan`1<Rgb48> source, Span`1<TPixel> destinationPixels);
    public void FromRgb48Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToRgb48(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Rgb48> destinationPixels);
    public void ToRgb48Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromRgba64(Configuration configuration, ReadOnlySpan`1<Rgba64> source, Span`1<TPixel> destinationPixels);
    public void FromRgba64Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToRgba64(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Rgba64> destinationPixels);
    public void ToRgba64Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    public virtual void FromBgra5551(Configuration configuration, ReadOnlySpan`1<Bgra5551> source, Span`1<TPixel> destinationPixels);
    public void FromBgra5551Bytes(Configuration configuration, ReadOnlySpan`1<byte> sourceBytes, Span`1<TPixel> destinationPixels, int count);
    public virtual void ToBgra5551(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<Bgra5551> destinationPixels);
    public void ToBgra5551Bytes(Configuration configuration, ReadOnlySpan`1<TPixel> sourcePixels, Span`1<byte> destBytes, int count);
    [NullableContextAttribute("1")]
public PixelBlender`1<TPixel> GetPixelBlender(GraphicsOptions options);
    public virtual PixelBlender`1<TPixel> GetPixelBlender(PixelColorBlendingMode colorMode, PixelAlphaCompositionMode alphaMode);
}
public class SixLabors.ImageSharp.PixelFormats.Rg32 : ValueType {
    private static Vector2 Max;
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public Rg32(float x, float y);
    public Rg32(Vector2 vector);
    private static Rg32();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(Rg32 left, Rg32 right);
    public static bool op_Inequality(Rg32 left, Rg32 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rg32> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector2 ToVector2();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rg32 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static UInt32 Pack(Vector2 vector);
}
public class SixLabors.ImageSharp.PixelFormats.Rgb24 : ValueType {
    public byte R;
    public byte G;
    public byte B;
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public Rgb24(byte r, byte g, byte b);
    private static Rgb24();
    public static Color op_Implicit(Rgb24 source);
    public static Rgb24 op_Implicit(Color color);
    public static Rgb24 op_Implicit(Rgb color);
    public static bool op_Equality(Rgb24 left, Rgb24 right);
    public static bool op_Inequality(Rgb24 left, Rgb24 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rgb24> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rgb24 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private void Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Rgb48 : ValueType {
    private static float Max;
    public ushort R;
    public ushort G;
    public ushort B;
    public Rgb48(ushort r, ushort g, ushort b);
    public static bool op_Equality(Rgb48 left, Rgb48 right);
    public static bool op_Inequality(Rgb48 left, Rgb48 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rgb48> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rgb48 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.PixelFormats.Rgba1010102 : ValueType {
    private static Vector4 Multiplier;
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public Rgba1010102(float x, float y, float z, float w);
    public Rgba1010102(Vector4 vector);
    private static Rgba1010102();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(Rgba1010102 left, Rgba1010102 right);
    public static bool op_Inequality(Rgba1010102 left, Rgba1010102 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rgba1010102> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rgba1010102 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static UInt32 Pack(Vector4& vector);
}
public class SixLabors.ImageSharp.PixelFormats.Rgba32 : ValueType {
    public byte R;
    public byte G;
    public byte B;
    public byte A;
    private static Vector4 MaxBytes;
    private static Vector4 Half;
    public UInt32 Rgba { get; public set; }
    public Rgb24 Rgb { get; public set; }
    public Bgr24 Bgr { get; public set; }
    public UInt32 PackedValue { get; public set; }
    public Rgba32(byte r, byte g, byte b);
    public Rgba32(byte r, byte g, byte b, byte a);
    public Rgba32(float r, float g, float b, float a);
    public Rgba32(Vector3 vector);
    public Rgba32(Vector4 vector);
    public Rgba32(UInt32 packed);
    private static Rgba32();
    [IsReadOnlyAttribute]
public UInt32 get_Rgba();
    public void set_Rgba(UInt32 value);
    [IsReadOnlyAttribute]
public Rgb24 get_Rgb();
    public void set_Rgb(Rgb24 value);
    [IsReadOnlyAttribute]
public Bgr24 get_Bgr();
    public void set_Bgr(Bgr24 value);
    [IsReadOnlyAttribute]
public sealed virtual UInt32 get_PackedValue();
    public sealed virtual void set_PackedValue(UInt32 value);
    public static Color op_Implicit(Rgba32 source);
    public static Rgba32 op_Implicit(Color color);
    public static Rgba32 op_Implicit(Rgb color);
    public static bool op_Equality(Rgba32 left, Rgba32 right);
    public static bool op_Inequality(Rgba32 left, Rgba32 right);
    [NullableContextAttribute("1")]
public static Rgba32 ParseHex(string hex);
    [NullableContextAttribute("2")]
public static bool TryParseHex(string hex, Rgba32& result);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rgba32> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public string ToHex();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rgba32 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    private static Rgba32 PackNew(Vector4& vector);
    private void Pack(float x, float y, float z, float w);
    private void Pack(Vector3& vector);
    private void Pack(Vector4& vector);
    [NullableContextAttribute("1")]
private static string ToRgbaHex(string hex);
}
public class SixLabors.ImageSharp.PixelFormats.Rgba64 : ValueType {
    private static float Max;
    public ushort R;
    public ushort G;
    public ushort B;
    public ushort A;
    public Rgb48 Rgb { get; public set; }
    public ulong PackedValue { get; public set; }
    public Rgba64(ushort r, ushort g, ushort b, ushort a);
    public Rgba64(Rgba32 source);
    public Rgba64(Bgra32 source);
    public Rgba64(Argb32 source);
    public Rgba64(Abgr32 source);
    public Rgba64(Rgb24 source);
    public Rgba64(Bgr24 source);
    public Rgba64(Vector4 vector);
    [IsReadOnlyAttribute]
public Rgb48 get_Rgb();
    public void set_Rgb(Rgb48 value);
    [IsReadOnlyAttribute]
public sealed virtual ulong get_PackedValue();
    public sealed virtual void set_PackedValue(ulong value);
    public static Color op_Implicit(Rgba64 source);
    public static Rgba64 op_Implicit(Color color);
    public static bool op_Equality(Rgba64 left, Rgba64 right);
    public static bool op_Inequality(Rgba64 left, Rgba64 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Rgba64> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Rgba32 ToRgba32();
    [IsReadOnlyAttribute]
public Bgra32 ToBgra32();
    [IsReadOnlyAttribute]
public Argb32 ToArgb32();
    [IsReadOnlyAttribute]
public Abgr32 ToAbgr32();
    [IsReadOnlyAttribute]
public Rgb24 ToRgb24();
    [IsReadOnlyAttribute]
public Bgr24 ToBgr24();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Rgba64 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.PixelFormats.RgbaVector : ValueType {
    public float R;
    public float G;
    public float B;
    public float A;
    private static float MaxBytes;
    private static Vector4 Max;
    private static Vector4 Half;
    public RgbaVector(float r, float g, float b, float a);
    private static RgbaVector();
    public static bool op_Equality(RgbaVector left, RgbaVector right);
    public static bool op_Inequality(RgbaVector left, RgbaVector right);
    [NullableContextAttribute("1")]
public static RgbaVector FromHex(string hex);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<RgbaVector> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public string ToHex();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(RgbaVector other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.PixelFormats.Short2 : ValueType {
    private static float MaxPos;
    private static float MinNeg;
    private static Vector2 Max;
    private static Vector2 Min;
    [CompilerGeneratedAttribute]
private UInt32 <PackedValue>k__BackingField;
    public UInt32 PackedValue { get; public set; }
    public Short2(float x, float y);
    public Short2(Vector2 vector);
    private static Short2();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual UInt32 get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(UInt32 value);
    public static bool op_Equality(Short2 left, Short2 right);
    public static bool op_Inequality(Short2 left, Short2 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Short2> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
public Vector2 ToVector2();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Short2 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static UInt32 Pack(Vector2 vector);
}
public class SixLabors.ImageSharp.PixelFormats.Short4 : ValueType {
    private static float MaxPos;
    private static float MinNeg;
    private static Vector4 Max;
    private static Vector4 Min;
    [CompilerGeneratedAttribute]
private ulong <PackedValue>k__BackingField;
    public ulong PackedValue { get; public set; }
    public Short4(float x, float y, float z, float w);
    public Short4(Vector4 vector);
    private static Short4();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ulong get_PackedValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackedValue(ulong value);
    public static bool op_Equality(Short4 left, Short4 right);
    public static bool op_Inequality(Short4 left, Short4 right);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public sealed virtual PixelOperations`1<Short4> CreatePixelOperations();
    public sealed virtual void FromScaledVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToScaledVector4();
    public sealed virtual void FromVector4(Vector4 vector);
    [IsReadOnlyAttribute]
public sealed virtual Vector4 ToVector4();
    public sealed virtual void FromArgb32(Argb32 source);
    public sealed virtual void FromBgr24(Bgr24 source);
    public sealed virtual void FromBgra32(Bgra32 source);
    public sealed virtual void FromAbgr32(Abgr32 source);
    public sealed virtual void FromBgra5551(Bgra5551 source);
    public sealed virtual void FromL8(L8 source);
    public sealed virtual void FromL16(L16 source);
    public sealed virtual void FromLa16(La16 source);
    public sealed virtual void FromLa32(La32 source);
    public sealed virtual void FromRgb24(Rgb24 source);
    public sealed virtual void FromRgba32(Rgba32 source);
    public sealed virtual void ToRgba32(Rgba32& dest);
    public sealed virtual void FromRgb48(Rgb48 source);
    public sealed virtual void FromRgba64(Rgba64 source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Short4 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    private static ulong Pack(Vector4& vector);
}
internal static class SixLabors.ImageSharp.PixelFormats.Utils.PixelConverter : object {
}
internal static class SixLabors.ImageSharp.PixelFormats.Utils.Vector4Converters : object {
    internal static void ApplyForwardConversionModifiers(Span`1<Vector4> vectors, PixelConversionModifiers modifiers);
    internal static void ApplyBackwardConversionModifiers(Span`1<Vector4> vectors, PixelConversionModifiers modifiers);
}
public class SixLabors.ImageSharp.Point : ValueType {
    public static Point Empty;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    public int X { get; public set; }
    public int Y { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public Point(int value);
    public Point(int x, int y);
    public Point(Size size);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
    public bool get_IsEmpty();
    public static PointF op_Implicit(Point point);
    public static Vector2 op_Implicit(Point point);
    public static Size op_Explicit(Point point);
    public static Point op_UnaryNegation(Point value);
    public static Point op_Addition(Point point, Size size);
    public static Point op_Subtraction(Point point, Size size);
    public static Point op_Multiply(int left, Point right);
    public static Point op_Multiply(Point left, int right);
    public static Point op_Division(Point left, int right);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point Add(Point point, Size size);
    public static Point Multiply(Point point, int value);
    public static Point Subtract(Point point, Size size);
    public static Point Ceiling(PointF point);
    public static Point Round(PointF point);
    public static Point Round(Vector2 vector);
    public static Point Truncate(PointF point);
    public static Point Transform(Point point, Matrix3x2 matrix);
    public void Deconstruct(Int32& x, Int32& y);
    public void Offset(int dx, int dy);
    public void Offset(Point point);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Point other);
    private static short HighInt16(int n);
    private static short LowInt16(int n);
}
public class SixLabors.ImageSharp.PointF : ValueType {
    public static PointF Empty;
    [CompilerGeneratedAttribute]
private float <X>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    public float X { get; public set; }
    public float Y { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public PointF(float x, float y);
    public PointF(SizeF size);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_X();
    [CompilerGeneratedAttribute]
public void set_X(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(float value);
    public bool get_IsEmpty();
    public static PointF op_Implicit(Vector2 vector);
    public static Vector2 op_Implicit(PointF point);
    public static Point op_Explicit(PointF point);
    public static PointF op_UnaryNegation(PointF value);
    public static PointF op_Addition(PointF point, SizeF size);
    public static PointF op_Subtraction(PointF point, PointF size);
    public static PointF op_Addition(PointF point, PointF size);
    public static PointF op_Subtraction(PointF point, SizeF size);
    public static PointF op_Multiply(float left, PointF right);
    public static PointF op_Multiply(PointF left, float right);
    public static PointF op_Division(PointF left, float right);
    public static bool op_Equality(PointF left, PointF right);
    public static bool op_Inequality(PointF left, PointF right);
    public static PointF Add(PointF point, SizeF size);
    public static PointF Add(PointF point, PointF pointb);
    public static PointF Subtract(PointF point, SizeF size);
    public static PointF Subtract(PointF point, PointF pointb);
    public static PointF Multiply(PointF point, float right);
    public static PointF Transform(PointF point, Matrix3x2 matrix);
    public void Deconstruct(Single& x, Single& y);
    public void Offset(float dx, float dy);
    public void Offset(PointF point);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PointF other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.AdaptiveThresholdExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source, float thresholdLimit);
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source, Color upper, Color lower);
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source, Color upper, Color lower, float thresholdLimit);
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source, Color upper, Color lower, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext AdaptiveThreshold(IImageProcessingContext source, Color upper, Color lower, float thresholdLimit, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.AffineTransformBuilder : object {
    private List`1<Func`2<Size, Matrix3x2>> transformMatrixFactories;
    private List`1<Func`2<Size, Matrix3x2>> boundsMatrixFactories;
    public AffineTransformBuilder PrependRotationDegrees(float degrees);
    public AffineTransformBuilder PrependRotationRadians(float radians);
    public AffineTransformBuilder PrependRotationDegrees(float degrees, Vector2 origin);
    public AffineTransformBuilder PrependRotationRadians(float radians, Vector2 origin);
    public AffineTransformBuilder AppendRotationDegrees(float degrees);
    public AffineTransformBuilder AppendRotationRadians(float radians);
    public AffineTransformBuilder AppendRotationDegrees(float degrees, Vector2 origin);
    public AffineTransformBuilder AppendRotationRadians(float radians, Vector2 origin);
    public AffineTransformBuilder PrependScale(float scale);
    public AffineTransformBuilder PrependScale(SizeF scale);
    public AffineTransformBuilder PrependScale(Vector2 scales);
    public AffineTransformBuilder AppendScale(float scale);
    public AffineTransformBuilder AppendScale(SizeF scales);
    public AffineTransformBuilder AppendScale(Vector2 scales);
    public AffineTransformBuilder PrependSkewDegrees(float degreesX, float degreesY);
    public AffineTransformBuilder PrependSkewRadians(float radiansX, float radiansY);
    public AffineTransformBuilder PrependSkewDegrees(float degreesX, float degreesY, Vector2 origin);
    public AffineTransformBuilder PrependSkewRadians(float radiansX, float radiansY, Vector2 origin);
    public AffineTransformBuilder AppendSkewDegrees(float degreesX, float degreesY);
    public AffineTransformBuilder AppendSkewRadians(float radiansX, float radiansY);
    public AffineTransformBuilder AppendSkewDegrees(float degreesX, float degreesY, Vector2 origin);
    public AffineTransformBuilder AppendSkewRadians(float radiansX, float radiansY, Vector2 origin);
    public AffineTransformBuilder PrependTranslation(PointF position);
    public AffineTransformBuilder PrependTranslation(Vector2 position);
    public AffineTransformBuilder AppendTranslation(PointF position);
    public AffineTransformBuilder AppendTranslation(Vector2 position);
    public AffineTransformBuilder PrependMatrix(Matrix3x2 matrix);
    public AffineTransformBuilder AppendMatrix(Matrix3x2 matrix);
    public Matrix3x2 BuildMatrix(Size sourceSize);
    public Matrix3x2 BuildMatrix(Rectangle sourceRectangle);
    public Size GetTransformedSize(Rectangle sourceRectangle);
    private static void CheckDegenerate(Matrix3x2 matrix);
    private AffineTransformBuilder Prepend(Func`2<Size, Matrix3x2> transformFactory, Func`2<Size, Matrix3x2> boundsFactory);
    private AffineTransformBuilder Append(Func`2<Size, Matrix3x2> transformFactory, Func`2<Size, Matrix3x2> boundsFactory);
}
public enum SixLabors.ImageSharp.Processing.AnchorPositionMode : Enum {
    public int value__;
    public static AnchorPositionMode Center;
    public static AnchorPositionMode Top;
    public static AnchorPositionMode Bottom;
    public static AnchorPositionMode Left;
    public static AnchorPositionMode Right;
    public static AnchorPositionMode TopLeft;
    public static AnchorPositionMode TopRight;
    public static AnchorPositionMode BottomRight;
    public static AnchorPositionMode BottomLeft;
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.AutoOrientExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageProcessingContext AutoOrient(IImageProcessingContext source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BackgroundColorExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BackgroundColor(IImageProcessingContext source, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext BackgroundColor(IImageProcessingContext source, Color color, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BackgroundColor(IImageProcessingContext source, GraphicsOptions options, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext BackgroundColor(IImageProcessingContext source, GraphicsOptions options, Color color, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BinaryDitherExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BinaryDither(IImageProcessingContext source, IDither dither);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryDither(IImageProcessingContext source, IDither dither, Color upperColor, Color lowerColor);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryDither(IImageProcessingContext source, IDither dither, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryDither(IImageProcessingContext source, IDither dither, Color upperColor, Color lowerColor, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BinaryThresholdExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, BinaryThresholdMode mode);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, BinaryThresholdMode mode, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, Color upperColor, Color lowerColor);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, Color upperColor, Color lowerColor, BinaryThresholdMode mode);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, Color upperColor, Color lowerColor, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BinaryThreshold(IImageProcessingContext source, float threshold, Color upperColor, Color lowerColor, BinaryThresholdMode mode, Rectangle rectangle);
}
public enum SixLabors.ImageSharp.Processing.BinaryThresholdMode : Enum {
    public int value__;
    public static BinaryThresholdMode Luminance;
    public static BinaryThresholdMode Saturation;
    public static BinaryThresholdMode MaxChroma;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BlackWhiteExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BlackWhite(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext BlackWhite(IImageProcessingContext source, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BokehBlurExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BokehBlur(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext BokehBlur(IImageProcessingContext source, int radius, int components, float gamma);
    [ExtensionAttribute]
public static IImageProcessingContext BokehBlur(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BokehBlur(IImageProcessingContext source, int radius, int components, float gamma, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BoxBlurExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext BoxBlur(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext BoxBlur(IImageProcessingContext source, int radius);
    [ExtensionAttribute]
public static IImageProcessingContext BoxBlur(IImageProcessingContext source, int radius, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext BoxBlur(IImageProcessingContext source, int radius, Rectangle rectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.BrightnessExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Brightness(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Brightness(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.ColorBlindnessExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext ColorBlindness(IImageProcessingContext source, ColorBlindnessMode colorBlindness);
    [ExtensionAttribute]
public static IImageProcessingContext ColorBlindness(IImageProcessingContext source, ColorBlindnessMode colorBlindnessMode, Rectangle rectangle);
    private static IImageProcessor GetProcessor(ColorBlindnessMode colorBlindness);
}
public enum SixLabors.ImageSharp.Processing.ColorBlindnessMode : Enum {
    public int value__;
    public static ColorBlindnessMode Achromatomaly;
    public static ColorBlindnessMode Achromatopsia;
    public static ColorBlindnessMode Deuteranomaly;
    public static ColorBlindnessMode Deuteranopia;
    public static ColorBlindnessMode Protanomaly;
    public static ColorBlindnessMode Protanopia;
    public static ColorBlindnessMode Tritanomaly;
    public static ColorBlindnessMode Tritanopia;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.ContrastExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Contrast(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Contrast(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.CropExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Crop(IImageProcessingContext source, int width, int height);
    [ExtensionAttribute]
public static IImageProcessingContext Crop(IImageProcessingContext source, Rectangle cropRectangle);
}
internal class SixLabors.ImageSharp.Processing.DefaultImageOperationsProviderFactory : object {
    public sealed virtual IInternalImageProcessingContext`1<TPixel> CreateImageProcessingContext(Configuration configuration, Image`1<TPixel> source, bool mutate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.DefaultImageProcessorContext`1 : object {
    private bool mutate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Image`1<TPixel> source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Image`1<TPixel> destination;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Properties>k__BackingField;
    public Configuration Configuration { get; }
    public IDictionary`2<object, object> Properties { get; }
    public DefaultImageProcessorContext`1(Configuration configuration, Image`1<TPixel> source, bool mutate);
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Properties();
    public sealed virtual Image`1<TPixel> GetResultImage();
    public sealed virtual Size GetCurrentSize();
    public sealed virtual IImageProcessingContext ApplyProcessor(IImageProcessor processor);
    public sealed virtual IImageProcessingContext ApplyProcessor(IImageProcessor processor, Rectangle rectangle);
    private Rectangle GetCurrentBounds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.DetectEdgesExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetector2DKernel kernel);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetector2DKernel kernel, bool grayscale);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetector2DKernel kernel, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetector2DKernel kernel, bool grayscale, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorKernel kernel);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorKernel kernel, bool grayscale);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorKernel kernel, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorKernel kernel, bool grayscale, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorCompassKernel kernel);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorCompassKernel kernel, bool grayscale);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorCompassKernel kernel, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext DetectEdges(IImageProcessingContext source, EdgeDetectorCompassKernel kernel, bool grayscale, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.DitherExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, float ditherScale);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, ReadOnlyMemory`1<Color> palette);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, float ditherScale, ReadOnlyMemory`1<Color> palette);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, float ditherScale, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, ReadOnlyMemory`1<Color> palette, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Dither(IImageProcessingContext source, IDither dither, float ditherScale, ReadOnlyMemory`1<Color> palette, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.DrawImageExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Rectangle foregroundRectangle, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, PixelColorBlendingMode colorBlending, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlending, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, PixelColorBlendingMode colorBlending, PixelAlphaCompositionMode alphaComposition, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlending, PixelAlphaCompositionMode alphaComposition, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Rectangle foregroundRectangle, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, Rectangle foregroundRectangle, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, PixelColorBlendingMode colorBlending, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlending, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, Rectangle foregroundRectangle, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, PixelColorBlendingMode colorBlending, PixelAlphaCompositionMode alphaComposition, float opacity);
    [ExtensionAttribute]
public static IImageProcessingContext DrawImage(IImageProcessingContext source, Image foreground, Point backgroundLocation, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlending, PixelAlphaCompositionMode alphaComposition, float opacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.EntropyCropExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext EntropyCrop(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext EntropyCrop(IImageProcessingContext source, float threshold);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.FilterExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Filter(IImageProcessingContext source, ColorMatrix matrix);
    [ExtensionAttribute]
public static IImageProcessingContext Filter(IImageProcessingContext source, ColorMatrix matrix, Rectangle rectangle);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.FlipExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageProcessingContext Flip(IImageProcessingContext source, FlipMode flipMode);
}
public enum SixLabors.ImageSharp.Processing.FlipMode : Enum {
    public int value__;
    public static FlipMode None;
    public static FlipMode Horizontal;
    public static FlipMode Vertical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.GaussianBlurExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext GaussianBlur(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianBlur(IImageProcessingContext source, float sigma);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianBlur(IImageProcessingContext source, float sigma, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianBlur(IImageProcessingContext source, float sigma, Rectangle rectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.GaussianSharpenExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext GaussianSharpen(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianSharpen(IImageProcessingContext source, float sigma);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianSharpen(IImageProcessingContext source, float sigma, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext GaussianSharpen(IImageProcessingContext source, float sigma, Rectangle rectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.GlowExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, float radius);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, Color color, float radius, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, float radius);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, Color color, float radius, Rectangle rectangle);
    [ExtensionAttribute]
private static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, Color color, ValueSize radius, Rectangle rectangle);
    [ExtensionAttribute]
private static IImageProcessingContext Glow(IImageProcessingContext source, GraphicsOptions options, Color color, ValueSize radius);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.GrayscaleExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, GrayscaleMode mode);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, GrayscaleMode mode, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, float amount, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, GrayscaleMode mode, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Grayscale(IImageProcessingContext source, GrayscaleMode mode, float amount, Rectangle rectangle);
}
public enum SixLabors.ImageSharp.Processing.GrayscaleMode : Enum {
    public int value__;
    public static GrayscaleMode Bt709;
    public static GrayscaleMode Bt601;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.HistogramEqualizationExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext HistogramEqualization(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext HistogramEqualization(IImageProcessingContext source, HistogramEqualizationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.HueExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Hue(IImageProcessingContext source, float degrees);
    [ExtensionAttribute]
public static IImageProcessingContext Hue(IImageProcessingContext source, float degrees, Rectangle rectangle);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Processing.IImageProcessingContext {
    public Configuration Configuration { get; }
    public IDictionary`2<object, object> Properties { get; }
    public abstract virtual Configuration get_Configuration();
    public abstract virtual IDictionary`2<object, object> get_Properties();
    public abstract virtual Size GetCurrentSize();
    public abstract virtual IImageProcessingContext ApplyProcessor(IImageProcessor processor, Rectangle rectangle);
    public abstract virtual IImageProcessingContext ApplyProcessor(IImageProcessor processor);
}
internal interface SixLabors.ImageSharp.Processing.IImageProcessingContextFactory {
    public abstract virtual IInternalImageProcessingContext`1<TPixel> CreateImageProcessingContext(Configuration configuration, Image`1<TPixel> source, bool mutate);
}
internal interface SixLabors.ImageSharp.Processing.IInternalImageProcessingContext`1 {
    public abstract virtual Image`1<TPixel> GetResultImage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.InvertExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Invert(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Invert(IImageProcessingContext source, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Processing.KnownDitherings : object {
    [CompilerGeneratedAttribute]
private static IDither <Bayer2x2>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Ordered3x3>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Bayer4x4>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Bayer8x8>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Bayer16x16>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Atkinson>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Burks>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <FloydSteinberg>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <JarvisJudiceNinke>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Sierra2>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Sierra3>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <SierraLite>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <StevensonArce>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDither <Stucki>k__BackingField;
    public static IDither Bayer2x2 { get; }
    public static IDither Ordered3x3 { get; }
    public static IDither Bayer4x4 { get; }
    public static IDither Bayer8x8 { get; }
    public static IDither Bayer16x16 { get; }
    public static IDither Atkinson { get; }
    public static IDither Burks { get; }
    public static IDither FloydSteinberg { get; }
    public static IDither JarvisJudiceNinke { get; }
    public static IDither Sierra2 { get; }
    public static IDither Sierra3 { get; }
    public static IDither SierraLite { get; }
    public static IDither StevensonArce { get; }
    public static IDither Stucki { get; }
    private static KnownDitherings();
    [CompilerGeneratedAttribute]
public static IDither get_Bayer2x2();
    [CompilerGeneratedAttribute]
public static IDither get_Ordered3x3();
    [CompilerGeneratedAttribute]
public static IDither get_Bayer4x4();
    [CompilerGeneratedAttribute]
public static IDither get_Bayer8x8();
    [CompilerGeneratedAttribute]
public static IDither get_Bayer16x16();
    [CompilerGeneratedAttribute]
public static IDither get_Atkinson();
    [CompilerGeneratedAttribute]
public static IDither get_Burks();
    [CompilerGeneratedAttribute]
public static IDither get_FloydSteinberg();
    [CompilerGeneratedAttribute]
public static IDither get_JarvisJudiceNinke();
    [CompilerGeneratedAttribute]
public static IDither get_Sierra2();
    [CompilerGeneratedAttribute]
public static IDither get_Sierra3();
    [CompilerGeneratedAttribute]
public static IDither get_SierraLite();
    [CompilerGeneratedAttribute]
public static IDither get_StevensonArce();
    [CompilerGeneratedAttribute]
public static IDither get_Stucki();
}
public static class SixLabors.ImageSharp.Processing.KnownEdgeDetectorKernels : object {
    [CompilerGeneratedAttribute]
private static EdgeDetector2DKernel <Kayyali>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetectorCompassKernel <Kirsch>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetectorKernel <Laplacian3x3>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetectorKernel <Laplacian5x5>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetectorKernel <LaplacianOfGaussian>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetector2DKernel <Prewitt>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetector2DKernel <RobertsCross>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetectorCompassKernel <Robinson>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetector2DKernel <Scharr>k__BackingField;
    [CompilerGeneratedAttribute]
private static EdgeDetector2DKernel <Sobel>k__BackingField;
    public static EdgeDetector2DKernel Kayyali { get; }
    public static EdgeDetectorCompassKernel Kirsch { get; }
    public static EdgeDetectorKernel Laplacian3x3 { get; }
    public static EdgeDetectorKernel Laplacian5x5 { get; }
    public static EdgeDetectorKernel LaplacianOfGaussian { get; }
    public static EdgeDetector2DKernel Prewitt { get; }
    public static EdgeDetector2DKernel RobertsCross { get; }
    public static EdgeDetectorCompassKernel Robinson { get; }
    public static EdgeDetector2DKernel Scharr { get; }
    public static EdgeDetector2DKernel Sobel { get; }
    private static KnownEdgeDetectorKernels();
    [CompilerGeneratedAttribute]
public static EdgeDetector2DKernel get_Kayyali();
    [CompilerGeneratedAttribute]
public static EdgeDetectorCompassKernel get_Kirsch();
    [CompilerGeneratedAttribute]
public static EdgeDetectorKernel get_Laplacian3x3();
    [CompilerGeneratedAttribute]
public static EdgeDetectorKernel get_Laplacian5x5();
    [CompilerGeneratedAttribute]
public static EdgeDetectorKernel get_LaplacianOfGaussian();
    [CompilerGeneratedAttribute]
public static EdgeDetector2DKernel get_Prewitt();
    [CompilerGeneratedAttribute]
public static EdgeDetector2DKernel get_RobertsCross();
    [CompilerGeneratedAttribute]
public static EdgeDetectorCompassKernel get_Robinson();
    [CompilerGeneratedAttribute]
public static EdgeDetector2DKernel get_Scharr();
    [CompilerGeneratedAttribute]
public static EdgeDetector2DKernel get_Sobel();
}
public static class SixLabors.ImageSharp.Processing.KnownFilterMatrices : object {
    [CompilerGeneratedAttribute]
private static ColorMatrix <AchromatomalyFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <AchromatopsiaFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <DeuteranomalyFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <DeuteranopiaFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <ProtanomalyFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <ProtanopiaFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <TritanomalyFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <TritanopiaFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <BlackWhiteFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <KodachromeFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <LomographFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private static ColorMatrix <PolaroidFilter>k__BackingField;
    public static ColorMatrix AchromatomalyFilter { get; }
    public static ColorMatrix AchromatopsiaFilter { get; }
    public static ColorMatrix DeuteranomalyFilter { get; }
    public static ColorMatrix DeuteranopiaFilter { get; }
    public static ColorMatrix ProtanomalyFilter { get; }
    public static ColorMatrix ProtanopiaFilter { get; }
    public static ColorMatrix TritanomalyFilter { get; }
    public static ColorMatrix TritanopiaFilter { get; }
    public static ColorMatrix BlackWhiteFilter { get; }
    public static ColorMatrix KodachromeFilter { get; }
    public static ColorMatrix LomographFilter { get; }
    public static ColorMatrix PolaroidFilter { get; }
    private static KnownFilterMatrices();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_AchromatomalyFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_AchromatopsiaFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_DeuteranomalyFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_DeuteranopiaFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_ProtanomalyFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_ProtanopiaFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_TritanomalyFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_TritanopiaFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_BlackWhiteFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_KodachromeFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_LomographFilter();
    [CompilerGeneratedAttribute]
public static ColorMatrix get_PolaroidFilter();
    public static ColorMatrix CreateBrightnessFilter(float amount);
    public static ColorMatrix CreateContrastFilter(float amount);
    public static ColorMatrix CreateGrayscaleBt601Filter(float amount);
    public static ColorMatrix CreateGrayscaleBt709Filter(float amount);
    public static ColorMatrix CreateHueFilter(float degrees);
    public static ColorMatrix CreateInvertFilter(float amount);
    public static ColorMatrix CreateOpacityFilter(float amount);
    public static ColorMatrix CreateSaturateFilter(float amount);
    public static ColorMatrix CreateLightnessFilter(float amount);
    public static ColorMatrix CreateSepiaFilter(float amount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Processing.KnownQuantizers : object {
    [CompilerGeneratedAttribute]
private static IQuantizer <Octree>k__BackingField;
    [CompilerGeneratedAttribute]
private static IQuantizer <Wu>k__BackingField;
    [CompilerGeneratedAttribute]
private static IQuantizer <WebSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private static IQuantizer <Werner>k__BackingField;
    public static IQuantizer Octree { get; }
    public static IQuantizer Wu { get; }
    public static IQuantizer WebSafe { get; }
    public static IQuantizer Werner { get; }
    private static KnownQuantizers();
    [CompilerGeneratedAttribute]
public static IQuantizer get_Octree();
    [CompilerGeneratedAttribute]
public static IQuantizer get_Wu();
    [CompilerGeneratedAttribute]
public static IQuantizer get_WebSafe();
    [CompilerGeneratedAttribute]
public static IQuantizer get_Werner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Processing.KnownResamplers : object {
    [CompilerGeneratedAttribute]
private static IResampler <Bicubic>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Box>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <CatmullRom>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Hermite>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Lanczos2>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Lanczos3>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Lanczos5>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Lanczos8>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <MitchellNetravali>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <NearestNeighbor>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Robidoux>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <RobidouxSharp>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Spline>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Triangle>k__BackingField;
    [CompilerGeneratedAttribute]
private static IResampler <Welch>k__BackingField;
    public static IResampler Bicubic { get; }
    public static IResampler Box { get; }
    public static IResampler CatmullRom { get; }
    public static IResampler Hermite { get; }
    public static IResampler Lanczos2 { get; }
    public static IResampler Lanczos3 { get; }
    public static IResampler Lanczos5 { get; }
    public static IResampler Lanczos8 { get; }
    public static IResampler MitchellNetravali { get; }
    public static IResampler NearestNeighbor { get; }
    public static IResampler Robidoux { get; }
    public static IResampler RobidouxSharp { get; }
    public static IResampler Spline { get; }
    public static IResampler Triangle { get; }
    public static IResampler Welch { get; }
    private static KnownResamplers();
    [CompilerGeneratedAttribute]
public static IResampler get_Bicubic();
    [CompilerGeneratedAttribute]
public static IResampler get_Box();
    [CompilerGeneratedAttribute]
public static IResampler get_CatmullRom();
    [CompilerGeneratedAttribute]
public static IResampler get_Hermite();
    [CompilerGeneratedAttribute]
public static IResampler get_Lanczos2();
    [CompilerGeneratedAttribute]
public static IResampler get_Lanczos3();
    [CompilerGeneratedAttribute]
public static IResampler get_Lanczos5();
    [CompilerGeneratedAttribute]
public static IResampler get_Lanczos8();
    [CompilerGeneratedAttribute]
public static IResampler get_MitchellNetravali();
    [CompilerGeneratedAttribute]
public static IResampler get_NearestNeighbor();
    [CompilerGeneratedAttribute]
public static IResampler get_Robidoux();
    [CompilerGeneratedAttribute]
public static IResampler get_RobidouxSharp();
    [CompilerGeneratedAttribute]
public static IResampler get_Spline();
    [CompilerGeneratedAttribute]
public static IResampler get_Triangle();
    [CompilerGeneratedAttribute]
public static IResampler get_Welch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.KodachromeExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Kodachrome(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Kodachrome(IImageProcessingContext source, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.LightnessExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Lightness(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Lightness(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.LomographExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Lomograph(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Lomograph(IImageProcessingContext source, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.MedianBlurExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext MedianBlur(IImageProcessingContext source, int radius, bool preserveAlpha);
    [ExtensionAttribute]
public static IImageProcessingContext MedianBlur(IImageProcessingContext source, int radius, bool preserveAlpha, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.OilPaintExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext OilPaint(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext OilPaint(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext OilPaint(IImageProcessingContext source, int levels, int brushSize);
    [ExtensionAttribute]
public static IImageProcessingContext OilPaint(IImageProcessingContext source, int levels, int brushSize, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.OpacityExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Opacity(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Opacity(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.PadExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Pad(IImageProcessingContext source, int width, int height);
    [ExtensionAttribute]
public static IImageProcessingContext Pad(IImageProcessingContext source, int width, int height, Color color);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.PixelateExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Pixelate(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Pixelate(IImageProcessingContext source, int size);
    [ExtensionAttribute]
public static IImageProcessingContext Pixelate(IImageProcessingContext source, int size, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.PixelRowDelegateExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation rowOperation);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation rowOperation, PixelConversionModifiers modifiers);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation rowOperation, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation rowOperation, Rectangle rectangle, PixelConversionModifiers modifiers);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation`1<Point> rowOperation);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation`1<Point> rowOperation, PixelConversionModifiers modifiers);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation`1<Point> rowOperation, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext ProcessPixelRowsAsVector4(IImageProcessingContext source, PixelRowOperation`1<Point> rowOperation, Rectangle rectangle, PixelConversionModifiers modifiers);
}
public class SixLabors.ImageSharp.Processing.PixelRowOperation : MulticastDelegate {
    public PixelRowOperation(object object, IntPtr method);
    public virtual void Invoke(Span`1<Vector4> span);
    public virtual IAsyncResult BeginInvoke(Span`1<Vector4> span, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SixLabors.ImageSharp.Processing.PixelRowOperation`1 : MulticastDelegate {
    public PixelRowOperation`1(object object, IntPtr method);
    public virtual void Invoke(Span`1<Vector4> span, T value);
    public virtual IAsyncResult BeginInvoke(Span`1<Vector4> span, T value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.PolaroidExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Polaroid(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Polaroid(IImageProcessingContext source, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.ProcessingExtensions : object {
    [ExtensionAttribute]
public static void Mutate(Image source, Action`1<IImageProcessingContext> operation);
    [ExtensionAttribute]
public static void Mutate(Image source, Configuration configuration, Action`1<IImageProcessingContext> operation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void Mutate(Image`1<TPixel> source, Action`1<IImageProcessingContext> operation);
    [ExtensionAttribute]
public static void Mutate(Image`1<TPixel> source, Configuration configuration, Action`1<IImageProcessingContext> operation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void Mutate(Image`1<TPixel> source, IImageProcessor[] operations);
    [ExtensionAttribute]
public static void Mutate(Image`1<TPixel> source, Configuration configuration, IImageProcessor[] operations);
    [ExtensionAttribute]
public static Image Clone(Image source, Action`1<IImageProcessingContext> operation);
    [ExtensionAttribute]
public static Image Clone(Image source, Configuration configuration, Action`1<IImageProcessingContext> operation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Image`1<TPixel> Clone(Image`1<TPixel> source, Action`1<IImageProcessingContext> operation);
    [ExtensionAttribute]
public static Image`1<TPixel> Clone(Image`1<TPixel> source, Configuration configuration, Action`1<IImageProcessingContext> operation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Image`1<TPixel> Clone(Image`1<TPixel> source, IImageProcessor[] operations);
    [ExtensionAttribute]
public static Image`1<TPixel> Clone(Image`1<TPixel> source, Configuration configuration, IImageProcessor[] operations);
    [ExtensionAttribute]
public static IImageProcessingContext ApplyProcessors(IImageProcessingContext source, IImageProcessor[] operations);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Buffer2D`1<ulong> CalculateIntegralImage(Image`1<TPixel> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Buffer2D`1<ulong> CalculateIntegralImage(Image`1<TPixel> source, Rectangle bounds);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Buffer2D`1<ulong> CalculateIntegralImage(ImageFrame`1<TPixel> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Buffer2D`1<ulong> CalculateIntegralImage(ImageFrame`1<TPixel> source, Rectangle bounds);
}
public class SixLabors.ImageSharp.Processing.Processors.Binarization.AdaptiveThresholdProcessor : object {
    [CompilerGeneratedAttribute]
private Color <Upper>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ThresholdLimit>k__BackingField;
    public Color Upper { get; public set; }
    public Color Lower { get; public set; }
    public float ThresholdLimit { get; public set; }
    public AdaptiveThresholdProcessor(float thresholdLimit);
    public AdaptiveThresholdProcessor(Color upper, Color lower);
    public AdaptiveThresholdProcessor(Color upper, Color lower, float thresholdLimit);
    [CompilerGeneratedAttribute]
public Color get_Upper();
    [CompilerGeneratedAttribute]
public void set_Upper(Color value);
    [CompilerGeneratedAttribute]
public Color get_Lower();
    [CompilerGeneratedAttribute]
public void set_Lower(Color value);
    [CompilerGeneratedAttribute]
public float get_ThresholdLimit();
    [CompilerGeneratedAttribute]
public void set_ThresholdLimit(float value);
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Binarization.AdaptiveThresholdProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private AdaptiveThresholdProcessor definition;
    [NullableContextAttribute("1")]
public AdaptiveThresholdProcessor`1(Configuration configuration, AdaptiveThresholdProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Binarization.BinaryThresholdProcessor : object {
    [CompilerGeneratedAttribute]
private float <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <UpperColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <LowerColor>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryThresholdMode <Mode>k__BackingField;
    public float Threshold { get; }
    public Color UpperColor { get; }
    public Color LowerColor { get; }
    public BinaryThresholdMode Mode { get; }
    public BinaryThresholdProcessor(float threshold, BinaryThresholdMode mode);
    public BinaryThresholdProcessor(float threshold);
    public BinaryThresholdProcessor(float threshold, Color upperColor, Color lowerColor, BinaryThresholdMode mode);
    public BinaryThresholdProcessor(float threshold, Color upperColor, Color lowerColor);
    [CompilerGeneratedAttribute]
public float get_Threshold();
    [CompilerGeneratedAttribute]
public Color get_UpperColor();
    [CompilerGeneratedAttribute]
public Color get_LowerColor();
    [CompilerGeneratedAttribute]
public BinaryThresholdMode get_Mode();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Binarization.BinaryThresholdProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private BinaryThresholdProcessor definition;
    [NullableContextAttribute("1")]
public BinaryThresholdProcessor`1(Configuration configuration, BinaryThresholdProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public abstract class SixLabors.ImageSharp.Processing.Processors.CloningImageProcessor : object {
    public abstract virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    private sealed virtual override IImageProcessor`1<TPixel> SixLabors.ImageSharp.Processing.Processors.IImageProcessor.CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
public abstract class SixLabors.ImageSharp.Processing.Processors.CloningImageProcessor`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Image`1<TPixel> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <SourceRectangle>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Image`1<TPixel> Source { get; }
    protected Rectangle SourceRectangle { get; }
    [NullableAttribute("1")]
protected Configuration Configuration { get; }
    [NullableContextAttribute("1")]
protected CloningImageProcessor`1(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
protected Image`1<TPixel> get_Source();
    [CompilerGeneratedAttribute]
protected Rectangle get_SourceRectangle();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    private sealed virtual override Image`1<TPixel> SixLabors.ImageSharp.Processing.Processors.ICloningImageProcessor<TPixel>.CloneAndExecute();
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.IImageProcessor<TPixel>.Execute();
    public sealed virtual void Dispose();
    protected abstract virtual Size GetDestinationSize();
    protected virtual void BeforeImageApply(Image`1<TPixel> destination);
    protected virtual void BeforeFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    protected abstract virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    protected virtual void AfterFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    protected virtual void AfterImageApply(Image`1<TPixel> destination);
    protected virtual void Dispose(bool disposing);
    private Image`1<TPixel> CreateTarget();
    private void CheckFrameCount(Image`1<TPixel> a, Image`1<TPixel> b);
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.BokehBlurProcessor : object {
    public static int DefaultRadius;
    public static int DefaultComponents;
    public static float DefaultGamma;
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Gamma>k__BackingField;
    public int Radius { get; }
    public int Components { get; }
    public float Gamma { get; }
    public BokehBlurProcessor(int radius, int components, float gamma);
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public int get_Components();
    [CompilerGeneratedAttribute]
public float get_Gamma();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.BokehBlurProcessor`1 : ImageProcessor`1<TPixel> {
    private float gamma;
    private int kernelSize;
    private Vector4[] kernelParameters;
    private Complex64[][] kernels;
    public IReadOnlyList`1<Complex64[]> Kernels { get; }
    public IReadOnlyList`1<Vector4> KernelParameters { get; }
    public BokehBlurProcessor`1(Configuration configuration, BokehBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    public IReadOnlyList`1<Complex64[]> get_Kernels();
    public IReadOnlyList`1<Vector4> get_KernelParameters();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private void OnFrameApplyCore(ImageFrame`1<TPixel> source, Rectangle sourceRectangle, Configuration configuration, Buffer2D`1<Vector4> processingBuffer);
}
public enum SixLabors.ImageSharp.Processing.Processors.Convolution.BorderWrappingMode : Enum {
    public byte value__;
    public static BorderWrappingMode Repeat;
    public static BorderWrappingMode Wrap;
    public static BorderWrappingMode Mirror;
    public static BorderWrappingMode Bounce;
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.BoxBlurProcessor : object {
    public static int DefaultRadius;
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public int Radius { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public BoxBlurProcessor(int radius, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    public BoxBlurProcessor(int radius);
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.BoxBlurProcessor`1 : ImageProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private Single[] <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public Single[] Kernel { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public BoxBlurProcessor`1(Configuration configuration, BoxBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    public BoxBlurProcessor`1(Configuration configuration, BoxBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [CompilerGeneratedAttribute]
public Single[] get_Kernel();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static Single[] CreateBoxKernel(int kernelSize);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Convolution2DProcessor`1 : ImageProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelX>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelY>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveAlpha>k__BackingField;
    public DenseMatrix`1<float> KernelX { get; }
    public DenseMatrix`1<float> KernelY { get; }
    public bool PreserveAlpha { get; }
    public Convolution2DProcessor`1(Configuration configuration, DenseMatrix`1& kernelX, DenseMatrix`1& kernelY, bool preserveAlpha, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelX();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelY();
    [CompilerGeneratedAttribute]
public bool get_PreserveAlpha();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Convolution2DRowOperation`1 : ValueType {
    private Rectangle bounds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> targetPixels;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> sourcePixels;
    [NullableAttribute("1")]
private KernelSamplingMap map;
    private DenseMatrix`1<float> kernelMatrixY;
    private DenseMatrix`1<float> kernelMatrixX;
    [NullableAttribute("1")]
private Configuration configuration;
    private bool preserveAlpha;
    public Convolution2DRowOperation`1(Rectangle bounds, Buffer2D`1<TPixel> targetPixels, Buffer2D`1<TPixel> sourcePixels, KernelSamplingMap map, DenseMatrix`1<float> kernelMatrixY, DenseMatrix`1<float> kernelMatrixX, Configuration configuration, bool preserveAlpha);
    public sealed virtual int GetRequiredBufferLength(Rectangle bounds);
    public sealed virtual void Invoke(int y, Span`1<Vector4> span);
    private void Convolve3(int y, Span`1<Vector4> span);
    private void Convolve4(int y, Span`1<Vector4> span);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Convolution2DState : ValueType {
    private Span`1<int> rowOffsetMap;
    private Span`1<int> columnOffsetMap;
    private UInt32 kernelHeight;
    private UInt32 kernelWidth;
    [CompilerGeneratedAttribute]
private ReadOnlyKernel <KernelY>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyKernel <KernelX>k__BackingField;
    public ReadOnlyKernel KernelY { get; }
    public ReadOnlyKernel KernelX { get; }
    public Convolution2DState(DenseMatrix`1& kernelY, DenseMatrix`1& kernelX, KernelSamplingMap map);
    [CompilerGeneratedAttribute]
public ReadOnlyKernel get_KernelY();
    [CompilerGeneratedAttribute]
public ReadOnlyKernel get_KernelX();
    public Int32& GetSampleRow(UInt32 row);
    public Int32& GetSampleColumn(UInt32 column);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Convolution2PassProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Single[] <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveAlpha>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    [NullableAttribute("1")]
public Single[] Kernel { get; }
    public bool PreserveAlpha { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    [NullableContextAttribute("1")]
public Convolution2PassProcessor`1(Configuration configuration, Single[] kernel, bool preserveAlpha, Image`1<TPixel> source, Rectangle sourceRectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Single[] get_Kernel();
    [CompilerGeneratedAttribute]
public bool get_PreserveAlpha();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.ConvolutionProcessor`1 : ImageProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelXY>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveAlpha>k__BackingField;
    public DenseMatrix`1<float> KernelXY { get; }
    public bool PreserveAlpha { get; }
    public ConvolutionProcessor`1(Configuration configuration, DenseMatrix`1& kernelXY, bool preserveAlpha, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelXY();
    [CompilerGeneratedAttribute]
public bool get_PreserveAlpha();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.ConvolutionProcessorHelpers : object {
    internal static int GetDefaultGaussianRadius(float sigma);
    internal static Single[] CreateGaussianBlurKernel(int size, float weight);
    internal static Single[] CreateGaussianSharpenKernel(int size, float weight);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryGetLinearlySeparableComponents(DenseMatrix`1<float> matrix, Single[]& row, Single[]& column);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.ConvolutionState : ValueType {
    private Span`1<int> rowOffsetMap;
    private Span`1<int> columnOffsetMap;
    private UInt32 kernelHeight;
    private UInt32 kernelWidth;
    [CompilerGeneratedAttribute]
private ReadOnlyKernel <Kernel>k__BackingField;
    public ReadOnlyKernel Kernel { get; }
    public ConvolutionState(DenseMatrix`1& kernel, KernelSamplingMap map);
    [CompilerGeneratedAttribute]
public ReadOnlyKernel get_Kernel();
    public Int32& GetSampleRow(UInt32 row);
    public Int32& GetSampleColumn(UInt32 column);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetector2DKernel : ValueType {
    public static EdgeDetector2DKernel KayyaliKernel;
    public static EdgeDetector2DKernel PrewittKernel;
    public static EdgeDetector2DKernel RobertsCrossKernel;
    public static EdgeDetector2DKernel ScharrKernel;
    public static EdgeDetector2DKernel SobelKernel;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelX>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelY>k__BackingField;
    public DenseMatrix`1<float> KernelX { get; }
    public DenseMatrix`1<float> KernelY { get; }
    public EdgeDetector2DKernel(DenseMatrix`1<float> kernelX, DenseMatrix`1<float> kernelY);
    private static EdgeDetector2DKernel();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelX();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelY();
    public static bool op_Equality(EdgeDetector2DKernel left, EdgeDetector2DKernel right);
    public static bool op_Inequality(EdgeDetector2DKernel left, EdgeDetector2DKernel right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EdgeDetector2DKernel other);
    public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetector2DProcessor : object {
    [CompilerGeneratedAttribute]
private EdgeDetector2DKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Grayscale>k__BackingField;
    public EdgeDetector2DKernel Kernel { get; }
    public bool Grayscale { get; }
    public EdgeDetector2DProcessor(EdgeDetector2DKernel kernel, bool grayscale);
    [CompilerGeneratedAttribute]
public EdgeDetector2DKernel get_Kernel();
    [CompilerGeneratedAttribute]
public bool get_Grayscale();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetector2DProcessor`1 : ImageProcessor`1<TPixel> {
    private DenseMatrix`1<float> kernelX;
    private DenseMatrix`1<float> kernelY;
    private bool grayscale;
    [NullableContextAttribute("1")]
public EdgeDetector2DProcessor`1(Configuration configuration, EdgeDetector2DProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorCompassKernel : ValueType {
    public static EdgeDetectorCompassKernel Kirsch;
    public static EdgeDetectorCompassKernel Robinson;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <North>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <NorthWest>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <West>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <SouthWest>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <South>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <SouthEast>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <East>k__BackingField;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <NorthEast>k__BackingField;
    public DenseMatrix`1<float> North { get; }
    public DenseMatrix`1<float> NorthWest { get; }
    public DenseMatrix`1<float> West { get; }
    public DenseMatrix`1<float> SouthWest { get; }
    public DenseMatrix`1<float> South { get; }
    public DenseMatrix`1<float> SouthEast { get; }
    public DenseMatrix`1<float> East { get; }
    public DenseMatrix`1<float> NorthEast { get; }
    public EdgeDetectorCompassKernel(DenseMatrix`1<float> north, DenseMatrix`1<float> northWest, DenseMatrix`1<float> west, DenseMatrix`1<float> southWest, DenseMatrix`1<float> south, DenseMatrix`1<float> southEast, DenseMatrix`1<float> east, DenseMatrix`1<float> northEast);
    private static EdgeDetectorCompassKernel();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_North();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_NorthWest();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_West();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_SouthWest();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_South();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_SouthEast();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_East();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_NorthEast();
    public static bool op_Equality(EdgeDetectorCompassKernel left, EdgeDetectorCompassKernel right);
    public static bool op_Inequality(EdgeDetectorCompassKernel left, EdgeDetectorCompassKernel right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EdgeDetectorCompassKernel other);
    public virtual int GetHashCode();
    internal DenseMatrix`1[] Flatten();
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorCompassProcessor : object {
    [CompilerGeneratedAttribute]
private EdgeDetectorCompassKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Grayscale>k__BackingField;
    public EdgeDetectorCompassKernel Kernel { get; }
    public bool Grayscale { get; }
    public EdgeDetectorCompassProcessor(EdgeDetectorCompassKernel kernel, bool grayscale);
    [CompilerGeneratedAttribute]
public EdgeDetectorCompassKernel get_Kernel();
    [CompilerGeneratedAttribute]
public bool get_Grayscale();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorCompassProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DenseMatrix`1[] kernels;
    private bool grayscale;
    [NullableContextAttribute("1")]
internal EdgeDetectorCompassProcessor`1(Configuration configuration, EdgeDetectorCompassProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorKernel : ValueType {
    public static EdgeDetectorKernel Laplacian3x3;
    public static EdgeDetectorKernel Laplacian5x5;
    public static EdgeDetectorKernel LaplacianOfGaussian;
    [CompilerGeneratedAttribute]
private DenseMatrix`1<float> <KernelXY>k__BackingField;
    public DenseMatrix`1<float> KernelXY { get; }
    public EdgeDetectorKernel(DenseMatrix`1<float> kernelXY);
    private static EdgeDetectorKernel();
    [CompilerGeneratedAttribute]
public DenseMatrix`1<float> get_KernelXY();
    public static bool op_Equality(EdgeDetectorKernel left, EdgeDetectorKernel right);
    public static bool op_Inequality(EdgeDetectorKernel left, EdgeDetectorKernel right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EdgeDetectorKernel other);
    public virtual int GetHashCode();
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorProcessor : object {
    [CompilerGeneratedAttribute]
private EdgeDetectorKernel <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Grayscale>k__BackingField;
    public EdgeDetectorKernel Kernel { get; }
    public bool Grayscale { get; }
    public EdgeDetectorProcessor(EdgeDetectorKernel kernel, bool grayscale);
    [CompilerGeneratedAttribute]
public EdgeDetectorKernel get_Kernel();
    [CompilerGeneratedAttribute]
public bool get_Grayscale();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.EdgeDetectorProcessor`1 : ImageProcessor`1<TPixel> {
    private bool grayscale;
    private DenseMatrix`1<float> kernelXY;
    [NullableContextAttribute("1")]
public EdgeDetectorProcessor`1(Configuration configuration, EdgeDetectorProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.GaussianBlurProcessor : object {
    public static float DefaultSigma;
    [CompilerGeneratedAttribute]
private float <Sigma>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public float Sigma { get; }
    public int Radius { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public GaussianBlurProcessor(float sigma);
    public GaussianBlurProcessor(float sigma, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    public GaussianBlurProcessor(int radius);
    public GaussianBlurProcessor(float sigma, int radius);
    public GaussianBlurProcessor(float sigma, int radius, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [CompilerGeneratedAttribute]
public float get_Sigma();
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.GaussianBlurProcessor`1 : ImageProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private Single[] <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public Single[] Kernel { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public GaussianBlurProcessor`1(Configuration configuration, GaussianBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    public GaussianBlurProcessor`1(Configuration configuration, GaussianBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [CompilerGeneratedAttribute]
public Single[] get_Kernel();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.GaussianSharpenProcessor : object {
    public static float DefaultSigma;
    [CompilerGeneratedAttribute]
private float <Sigma>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public float Sigma { get; }
    public int Radius { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public GaussianSharpenProcessor(float sigma);
    public GaussianSharpenProcessor(float sigma, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    public GaussianSharpenProcessor(int radius);
    public GaussianSharpenProcessor(float sigma, int radius);
    public GaussianSharpenProcessor(float sigma, int radius, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [CompilerGeneratedAttribute]
public float get_Sigma();
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.GaussianSharpenProcessor`1 : ImageProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private Single[] <Kernel>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public Single[] Kernel { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public GaussianSharpenProcessor`1(Configuration configuration, GaussianSharpenProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    public GaussianSharpenProcessor`1(Configuration configuration, GaussianSharpenProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle, BorderWrappingMode borderWrapModeX, BorderWrappingMode borderWrapModeY);
    [CompilerGeneratedAttribute]
public Single[] get_Kernel();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.KayyaliKernels : object {
    public static DenseMatrix`1<float> KayyaliX { get; }
    public static DenseMatrix`1<float> KayyaliY { get; }
    public static DenseMatrix`1<float> get_KayyaliX();
    public static DenseMatrix`1<float> get_KayyaliY();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Kernel`1 : ValueType {
    private Span`1<T> values;
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rows>k__BackingField;
    public int Columns { get; }
    public int Rows { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public T Item { get; public set; }
    public Kernel`1(DenseMatrix`1<T> matrix);
    [CompilerGeneratedAttribute]
public int get_Columns();
    [CompilerGeneratedAttribute]
public int get_Rows();
    public ReadOnlySpan`1<T> get_Span();
    public T get_Item(int row, int column);
    public void set_Item(int row, int column, T value);
    public void SetValue(int index, T value);
    public void Clear();
    [ConditionalAttribute("DEBUG")]
private void CheckCoordinates(int row, int column);
    [ConditionalAttribute("DEBUG")]
private void CheckIndex(int index);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.KernelSamplingMap : object {
    [NullableAttribute("1")]
private MemoryAllocator allocator;
    private bool isDisposed;
    [NullableAttribute("2")]
private IMemoryOwner`1<int> yOffsets;
    [NullableAttribute("2")]
private IMemoryOwner`1<int> xOffsets;
    [NullableContextAttribute("1")]
public KernelSamplingMap(MemoryAllocator allocator);
    public void BuildSamplingOffsetMap(DenseMatrix`1<float> kernel, Rectangle bounds);
    public void BuildSamplingOffsetMap(int kernelHeight, int kernelWidth, Rectangle bounds);
    public void BuildSamplingOffsetMap(int kernelHeight, int kernelWidth, Rectangle bounds, BorderWrappingMode xBorderMode, BorderWrappingMode yBorderMode);
    public Span`1<int> GetRowOffsetSpan();
    public Span`1<int> GetColumnOffsetSpan();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
private static void BuildOffsets(IMemoryOwner`1<int> offsets, int boundsSize, int kernelSize, int min, int max, BorderWrappingMode borderMode);
    private static void CorrectBorder(Span`1<int> span, int kernelSize, int min, int max, BorderWrappingMode borderMode);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.KirschKernels : object {
    public static DenseMatrix`1<float> North { get; }
    public static DenseMatrix`1<float> NorthWest { get; }
    public static DenseMatrix`1<float> West { get; }
    public static DenseMatrix`1<float> SouthWest { get; }
    public static DenseMatrix`1<float> South { get; }
    public static DenseMatrix`1<float> SouthEast { get; }
    public static DenseMatrix`1<float> East { get; }
    public static DenseMatrix`1<float> NorthEast { get; }
    public static DenseMatrix`1<float> get_North();
    public static DenseMatrix`1<float> get_NorthWest();
    public static DenseMatrix`1<float> get_West();
    public static DenseMatrix`1<float> get_SouthWest();
    public static DenseMatrix`1<float> get_South();
    public static DenseMatrix`1<float> get_SouthEast();
    public static DenseMatrix`1<float> get_East();
    public static DenseMatrix`1<float> get_NorthEast();
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.LaplacianKernelFactory : object {
    public static DenseMatrix`1<float> CreateKernel(UInt32 length);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.LaplacianKernels : object {
    public static DenseMatrix`1<float> Laplacian3x3 { get; }
    public static DenseMatrix`1<float> Laplacian5x5 { get; }
    public static DenseMatrix`1<float> LaplacianOfGaussianXY { get; }
    public static DenseMatrix`1<float> get_Laplacian3x3();
    public static DenseMatrix`1<float> get_Laplacian5x5();
    public static DenseMatrix`1<float> get_LaplacianOfGaussianXY();
}
public class SixLabors.ImageSharp.Processing.Processors.Convolution.MedianBlurProcessor : object {
    [CompilerGeneratedAttribute]
private int <Radius>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveAlpha>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeX>k__BackingField;
    [CompilerGeneratedAttribute]
private BorderWrappingMode <BorderWrapModeY>k__BackingField;
    public int Radius { get; }
    public bool PreserveAlpha { get; }
    public BorderWrappingMode BorderWrapModeX { get; }
    public BorderWrappingMode BorderWrapModeY { get; }
    public MedianBlurProcessor(int radius, bool preserveAlpha);
    [CompilerGeneratedAttribute]
public int get_Radius();
    [CompilerGeneratedAttribute]
public bool get_PreserveAlpha();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeX();
    [CompilerGeneratedAttribute]
public BorderWrappingMode get_BorderWrapModeY();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.MedianBlurProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private MedianBlurProcessor definition;
    [NullableContextAttribute("1")]
public MedianBlurProcessor`1(Configuration configuration, MedianBlurProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.MedianConvolutionState : ValueType {
    private Span`1<int> rowOffsetMap;
    private Span`1<int> columnOffsetMap;
    private int kernelHeight;
    private int kernelWidth;
    [CompilerGeneratedAttribute]
private Kernel`1<Vector4> <Kernel>k__BackingField;
    public Kernel`1<Vector4> Kernel { get; }
    public MedianConvolutionState(DenseMatrix`1& kernel, KernelSamplingMap map);
    [CompilerGeneratedAttribute]
public Kernel`1<Vector4> get_Kernel();
    public Int32& GetSampleRow(int row);
    public Int32& GetSampleColumn(int column);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.MedianRowOperation`1 : ValueType {
    private int yChannelStart;
    private int zChannelStart;
    private int wChannelStart;
    [NullableAttribute("1")]
private Configuration configuration;
    private Rectangle bounds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> targetPixels;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> sourcePixels;
    [NullableAttribute("1")]
private KernelSamplingMap map;
    private int kernelSize;
    private bool preserveAlpha;
    [NullableContextAttribute("1")]
public MedianRowOperation`1(Rectangle bounds, Buffer2D`1<TPixel> targetPixels, Buffer2D`1<TPixel> sourcePixels, KernelSamplingMap map, int kernelSize, Configuration configuration, bool preserveAlpha);
    public sealed virtual int GetRequiredBufferLength(Rectangle bounds);
    public sealed virtual void Invoke(int y, Span`1<Vector4> span);
    private static Vector4 FindMedian3(ReadOnlySpan`1<Vector4> kernelSpan, Span`1<float> xChannel, Span`1<float> yChannel, Span`1<float> zChannel);
    private static Vector4 FindMedian4(ReadOnlySpan`1<Vector4> kernelSpan, Span`1<float> xChannel, Span`1<float> yChannel, Span`1<float> zChannel, Span`1<float> wChannel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Parameters.BokehBlurKernelData : ValueType {
    public Vector4[] Parameters;
    public Complex64[][] Kernels;
    public BokehBlurKernelData(Vector4[] parameters, Complex64[][] kernels);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.Parameters.BokehBlurKernelDataProvider : object {
    private static ConcurrentDictionary`2<BokehBlurParameters, BokehBlurKernelData> Cache;
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<float> <KernelScales>k__BackingField;
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<Vector4[]> <KernelComponents>k__BackingField;
    private static IReadOnlyList`1<float> KernelScales { get; }
    private static IReadOnlyList`1<Vector4[]> KernelComponents { get; }
    private static BokehBlurKernelDataProvider();
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<float> get_KernelScales();
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<Vector4[]> get_KernelComponents();
    public static BokehBlurKernelData GetBokehBlurKernelData(int radius, int kernelSize, int componentsCount);
    private static ValueTuple`2<Vector4[], float> GetParameters(int componentsCount);
    private static Complex64[][] CreateComplexKernels(Vector4[] kernelParameters, int radius, int kernelSize, float kernelsScale);
    private static Complex64[] CreateComplex1DKernel(int radius, int kernelSize, float kernelsScale, float a, float b);
    private static void NormalizeKernels(Complex64[][] kernels, Vector4[] kernelParameters);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.Parameters.BokehBlurParameters : ValueType {
    public int Radius;
    public int Components;
    public BokehBlurParameters(int radius, int components);
    public sealed virtual bool Equals(BokehBlurParameters other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.PrewittKernels : object {
    public static DenseMatrix`1<float> PrewittX { get; }
    public static DenseMatrix`1<float> PrewittY { get; }
    public static DenseMatrix`1<float> get_PrewittX();
    public static DenseMatrix`1<float> get_PrewittY();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class SixLabors.ImageSharp.Processing.Processors.Convolution.ReadOnlyKernel : ValueType {
    private ReadOnlySpan`1<float> values;
    [CompilerGeneratedAttribute]
private UInt32 <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Rows>k__BackingField;
    public UInt32 Columns { get; }
    public UInt32 Rows { get; }
    public float Item { get; }
    public ReadOnlyKernel(DenseMatrix`1<float> matrix);
    [CompilerGeneratedAttribute]
public UInt32 get_Columns();
    [CompilerGeneratedAttribute]
public UInt32 get_Rows();
    public float get_Item(UInt32 row, UInt32 column);
    [ConditionalAttribute("DEBUG")]
private void CheckCoordinates(UInt32 row, UInt32 column);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.RobertsCrossKernels : object {
    public static DenseMatrix`1<float> RobertsCrossX { get; }
    public static DenseMatrix`1<float> RobertsCrossY { get; }
    public static DenseMatrix`1<float> get_RobertsCrossX();
    public static DenseMatrix`1<float> get_RobertsCrossY();
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.RobinsonKernels : object {
    public static DenseMatrix`1<float> North { get; }
    public static DenseMatrix`1<float> NorthWest { get; }
    public static DenseMatrix`1<float> West { get; }
    public static DenseMatrix`1<float> SouthWest { get; }
    public static DenseMatrix`1<float> South { get; }
    public static DenseMatrix`1<float> SouthEast { get; }
    public static DenseMatrix`1<float> East { get; }
    public static DenseMatrix`1<float> NorthEast { get; }
    public static DenseMatrix`1<float> get_North();
    public static DenseMatrix`1<float> get_NorthWest();
    public static DenseMatrix`1<float> get_West();
    public static DenseMatrix`1<float> get_SouthWest();
    public static DenseMatrix`1<float> get_South();
    public static DenseMatrix`1<float> get_SouthEast();
    public static DenseMatrix`1<float> get_East();
    public static DenseMatrix`1<float> get_NorthEast();
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.ScharrKernels : object {
    public static DenseMatrix`1<float> ScharrX { get; }
    public static DenseMatrix`1<float> ScharrY { get; }
    public static DenseMatrix`1<float> get_ScharrX();
    public static DenseMatrix`1<float> get_ScharrY();
}
internal static class SixLabors.ImageSharp.Processing.Processors.Convolution.SobelKernels : object {
    public static DenseMatrix`1<float> SobelX { get; }
    public static DenseMatrix`1<float> SobelY { get; }
    public static DenseMatrix`1<float> get_SobelX();
    public static DenseMatrix`1<float> get_SobelY();
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Dithering.ErrorDither : ValueType {
    public static ErrorDither Atkinson;
    public static ErrorDither Burkes;
    public static ErrorDither FloydSteinberg;
    public static ErrorDither JarvisJudiceNinke;
    public static ErrorDither Sierra2;
    public static ErrorDither Sierra3;
    public static ErrorDither SierraLite;
    public static ErrorDither StevensonArce;
    public static ErrorDither Stucki;
    private int offset;
    private DenseMatrix`1<float> matrix;
    public ErrorDither(DenseMatrix`1& matrix, int offset);
    private static ErrorDither();
    private static ErrorDither CreateAtkinson();
    private static ErrorDither CreateBurks();
    private static ErrorDither CreateFloydSteinberg();
    private static ErrorDither CreateJarvisJudiceNinke();
    private static ErrorDither CreateSierra2();
    private static ErrorDither CreateSierra3();
    private static ErrorDither CreateSierraLite();
    private static ErrorDither CreateStevensonArce();
    private static ErrorDither CreateStucki();
    [NullableContextAttribute("1")]
public static bool op_Equality(IDither left, ErrorDither right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(IDither left, ErrorDither right);
    [NullableContextAttribute("1")]
public static bool op_Equality(ErrorDither left, IDither right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(ErrorDither left, IDither right);
    public static bool op_Equality(ErrorDither left, ErrorDither right);
    public static bool op_Inequality(ErrorDither left, ErrorDither right);
    public sealed virtual void ApplyQuantizationDither(TFrameQuantizer& quantizer, ImageFrame`1<TPixel> source, IndexedImageFrame`1<TPixel> destination, Rectangle bounds);
    public void ApplyPaletteDither(TPaletteDitherImageProcessor& processor, ImageFrame`1<TPixel> source, Rectangle bounds);
    internal TPixel Dither(ImageFrame`1<TPixel> image, Rectangle bounds, TPixel source, TPixel transformed, int x, int y, float scale);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ErrorDither other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IDither other);
    public virtual int GetHashCode();
    private static void ThrowDefaultInstance();
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.Dithering.IDither.ApplyPaletteDither(TPaletteDitherImageProcessor& modreq(System.Runtime.InteropServices.InAttribute) processor, ImageFrame`1<TPixel> source, Rectangle bounds);
}
public interface SixLabors.ImageSharp.Processing.Processors.Dithering.IDither {
    public abstract virtual void ApplyQuantizationDither(TFrameQuantizer& quantizer, ImageFrame`1<TPixel> source, IndexedImageFrame`1<TPixel> destination, Rectangle bounds);
    public abstract virtual void ApplyPaletteDither(TPaletteDitherImageProcessor& modreq(System.Runtime.InteropServices.InAttribute) processor, ImageFrame`1<TPixel> source, Rectangle bounds);
}
public interface SixLabors.ImageSharp.Processing.Processors.Dithering.IPaletteDitherImageProcessor`1 {
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    public float DitherScale { get; }
    [NullableContextAttribute("1")]
public abstract virtual Configuration get_Configuration();
    public abstract virtual ReadOnlyMemory`1<TPixel> get_Palette();
    public abstract virtual float get_DitherScale();
    public abstract virtual TPixel GetPaletteColor(TPixel color);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Dithering.OrderedDither : ValueType {
    private DenseMatrix`1<float> thresholdMatrix;
    private int modulusX;
    private int modulusY;
    public static OrderedDither Bayer2x2;
    public static OrderedDither Bayer4x4;
    public static OrderedDither Bayer8x8;
    public static OrderedDither Bayer16x16;
    public static OrderedDither Ordered3x3;
    public OrderedDither(UInt32 length);
    private static OrderedDither();
    [NullableContextAttribute("1")]
public static bool op_Equality(IDither left, OrderedDither right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(IDither left, OrderedDither right);
    [NullableContextAttribute("1")]
public static bool op_Equality(OrderedDither left, IDither right);
    [NullableContextAttribute("1")]
public static bool op_Inequality(OrderedDither left, IDither right);
    public static bool op_Equality(OrderedDither left, OrderedDither right);
    public static bool op_Inequality(OrderedDither left, OrderedDither right);
    public sealed virtual void ApplyQuantizationDither(TFrameQuantizer& quantizer, ImageFrame`1<TPixel> source, IndexedImageFrame`1<TPixel> destination, Rectangle bounds);
    public void ApplyPaletteDither(TPaletteDitherImageProcessor& processor, ImageFrame`1<TPixel> source, Rectangle bounds);
    internal static int CalculatePaletteSpread(int colors);
    internal TPixel Dither(TPixel source, int x, int y, int spread, float scale);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OrderedDither other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IDither other);
    public virtual int GetHashCode();
    private static void ThrowDefaultInstance();
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.Dithering.IDither.ApplyPaletteDither(TPaletteDitherImageProcessor& modreq(System.Runtime.InteropServices.InAttribute) processor, ImageFrame`1<TPixel> source, Rectangle bounds);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Dithering.OrderedDitherFactory : object {
    public static DenseMatrix`1<UInt32> CreateDitherMatrix(UInt32 length);
    private static UInt32 Bayer(UInt32 x, UInt32 y, UInt32 order);
}
public class SixLabors.ImageSharp.Processing.Processors.Dithering.PaletteDitherProcessor : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDither <Dither>k__BackingField;
    [CompilerGeneratedAttribute]
private float <DitherScale>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<Color> <Palette>k__BackingField;
    [NullableAttribute("1")]
public IDither Dither { get; }
    public float DitherScale { get; }
    public ReadOnlyMemory`1<Color> Palette { get; }
    [NullableContextAttribute("1")]
public PaletteDitherProcessor(IDither dither);
    [NullableContextAttribute("1")]
public PaletteDitherProcessor(IDither dither, float ditherScale);
    public PaletteDitherProcessor(IDither dither, ReadOnlyMemory`1<Color> palette);
    public PaletteDitherProcessor(IDither dither, float ditherScale, ReadOnlyMemory`1<Color> palette);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IDither get_Dither();
    [CompilerGeneratedAttribute]
public float get_DitherScale();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<Color> get_Palette();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Dithering.PaletteDitherProcessor`1 : ImageProcessor`1<TPixel> {
    private DitherProcessor<TPixel> ditherProcessor;
    [NullableAttribute("1")]
private IDither dither;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryOwner`1<TPixel> paletteOwner;
    private bool isDisposed;
    [NullableContextAttribute("1")]
public PaletteDitherProcessor`1(Configuration configuration, PaletteDitherProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Drawing.DrawImageProcessor : object {
    [CompilerGeneratedAttribute]
private Image <ForeGround>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <BackgroundLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <ForegroundRectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelColorBlendingMode <ColorBlendingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelAlphaCompositionMode <AlphaCompositionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Opacity>k__BackingField;
    public Image ForeGround { get; }
    public Point BackgroundLocation { get; }
    public Rectangle ForegroundRectangle { get; }
    public PixelColorBlendingMode ColorBlendingMode { get; }
    public PixelAlphaCompositionMode AlphaCompositionMode { get; }
    public float Opacity { get; }
    public DrawImageProcessor(Image foreground, Point backgroundLocation, PixelColorBlendingMode colorBlendingMode, PixelAlphaCompositionMode alphaCompositionMode, float opacity);
    public DrawImageProcessor(Image foreground, Point backgroundLocation, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlendingMode, PixelAlphaCompositionMode alphaCompositionMode, float opacity);
    [CompilerGeneratedAttribute]
public Image get_ForeGround();
    [CompilerGeneratedAttribute]
public Point get_BackgroundLocation();
    [CompilerGeneratedAttribute]
public Rectangle get_ForegroundRectangle();
    [CompilerGeneratedAttribute]
public PixelColorBlendingMode get_ColorBlendingMode();
    [CompilerGeneratedAttribute]
public PixelAlphaCompositionMode get_AlphaCompositionMode();
    [CompilerGeneratedAttribute]
public float get_Opacity();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixelBg> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixelBg> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Drawing.DrawImageProcessor`2 : ImageProcessor`1<TPixelBg> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Image`1<TPixelFg> <ForegroundImage>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <ForegroundRectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Opacity>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private PixelBlender`1<TPixelBg> <Blender>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <BackgroundLocation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Image`1<TPixelFg> ForegroundImage { get; }
    public Rectangle ForegroundRectangle { get; }
    public float Opacity { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public PixelBlender`1<TPixelBg> Blender { get; }
    public Point BackgroundLocation { get; }
    [NullableContextAttribute("1")]
public DrawImageProcessor`2(Configuration configuration, Image`1<TPixelFg> foregroundImage, Image`1<TPixelBg> backgroundImage, Point backgroundLocation, Rectangle foregroundRectangle, PixelColorBlendingMode colorBlendingMode, PixelAlphaCompositionMode alphaCompositionMode, float opacity);
    [CompilerGeneratedAttribute]
public Image`1<TPixelFg> get_ForegroundImage();
    [CompilerGeneratedAttribute]
public Rectangle get_ForegroundRectangle();
    [CompilerGeneratedAttribute]
public float get_Opacity();
    [CompilerGeneratedAttribute]
public PixelBlender`1<TPixelBg> get_Blender();
    [CompilerGeneratedAttribute]
public Point get_BackgroundLocation();
    protected virtual void OnFrameApply(ImageFrame`1<TPixelBg> source);
}
public interface SixLabors.ImageSharp.Processing.Processors.Effects.IPixelRowDelegate {
    public abstract virtual void Invoke(Span`1<Vector4> span, Point offset);
}
public class SixLabors.ImageSharp.Processing.Processors.Effects.OilPaintingProcessor : object {
    [CompilerGeneratedAttribute]
private int <Levels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BrushSize>k__BackingField;
    public int Levels { get; }
    public int BrushSize { get; }
    public OilPaintingProcessor(int levels, int brushSize);
    [CompilerGeneratedAttribute]
public int get_Levels();
    [CompilerGeneratedAttribute]
public int get_BrushSize();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Effects.OilPaintingProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private OilPaintingProcessor definition;
    [NullableContextAttribute("1")]
public OilPaintingProcessor`1(Configuration configuration, OilPaintingProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Effects.PixelateProcessor : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public int Size { get; }
    public PixelateProcessor(int size);
    [CompilerGeneratedAttribute]
public int get_Size();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Effects.PixelateProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private PixelateProcessor definition;
    private int Size { get; }
    [NullableContextAttribute("1")]
public PixelateProcessor`1(Configuration configuration, PixelateProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    private int get_Size();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
internal class SixLabors.ImageSharp.Processing.Processors.Effects.PixelRowDelegateProcessor : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private PixelRowOperation <PixelRowOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelConversionModifiers <Modifiers>k__BackingField;
    [NullableAttribute("1")]
public PixelRowOperation PixelRowOperation { get; }
    public PixelConversionModifiers Modifiers { get; }
    [NullableContextAttribute("1")]
public PixelRowDelegateProcessor(PixelRowOperation pixelRowOperation, PixelConversionModifiers modifiers);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public PixelRowOperation get_PixelRowOperation();
    [CompilerGeneratedAttribute]
public PixelConversionModifiers get_Modifiers();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Effects.PixelRowDelegateProcessor`2 : ImageProcessor`1<TPixel> {
    private TDelegate rowDelegate;
    private PixelConversionModifiers modifiers;
    public PixelRowDelegateProcessor`2(TDelegate& rowDelegate, Configuration configuration, PixelConversionModifiers modifiers, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
internal class SixLabors.ImageSharp.Processing.Processors.Effects.PositionAwarePixelRowDelegateProcessor : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private PixelRowOperation`1<Point> <PixelRowOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelConversionModifiers <Modifiers>k__BackingField;
    [NullableAttribute("1")]
public PixelRowOperation`1<Point> PixelRowOperation { get; }
    public PixelConversionModifiers Modifiers { get; }
    [NullableContextAttribute("1")]
public PositionAwarePixelRowDelegateProcessor(PixelRowOperation`1<Point> pixelRowOperation, PixelConversionModifiers modifiers);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public PixelRowOperation`1<Point> get_PixelRowOperation();
    [CompilerGeneratedAttribute]
public PixelConversionModifiers get_Modifiers();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.AchromatomalyProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.AchromatopsiaProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.BlackWhiteProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.BrightnessProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public BrightnessProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.ContrastProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public ContrastProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.DeuteranomalyProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.DeuteranopiaProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.FilterProcessor : object {
    [CompilerGeneratedAttribute]
private ColorMatrix <Matrix>k__BackingField;
    public ColorMatrix Matrix { get; }
    public FilterProcessor(ColorMatrix matrix);
    [CompilerGeneratedAttribute]
public ColorMatrix get_Matrix();
    public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Filters.FilterProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private FilterProcessor definition;
    [NullableContextAttribute("1")]
public FilterProcessor`1(Configuration configuration, FilterProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.GrayscaleBt601Processor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public GrayscaleBt601Processor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.GrayscaleBt709Processor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public GrayscaleBt709Processor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.HueProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Degrees>k__BackingField;
    public float Degrees { get; }
    public HueProcessor(float degrees);
    [CompilerGeneratedAttribute]
public float get_Degrees();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.InvertProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public InvertProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.KodachromeProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.LightnessProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public LightnessProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Filters.LomographProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private GraphicsOptions <GraphicsOptions>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; }
    public LomographProcessor(GraphicsOptions graphicsOptions);
    [CompilerGeneratedAttribute]
public GraphicsOptions get_GraphicsOptions();
    [NullableContextAttribute("0")]
public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Filters.LomographProcessor`1 : FilterProcessor`1<TPixel> {
    private static Color VeryDarkGreen;
    [NullableAttribute("1")]
private LomographProcessor definition;
    [NullableContextAttribute("1")]
public LomographProcessor`1(Configuration configuration, LomographProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    private static LomographProcessor`1();
    protected virtual void AfterImageApply();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.OpacityProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public OpacityProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
internal class SixLabors.ImageSharp.Processing.Processors.Filters.OpaqueProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableContextAttribute("1")]
public OpaqueProcessor`1(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Filters.PolaroidProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private GraphicsOptions <GraphicsOptions>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; }
    public PolaroidProcessor(GraphicsOptions graphicsOptions);
    [CompilerGeneratedAttribute]
public GraphicsOptions get_GraphicsOptions();
    [NullableContextAttribute("0")]
public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Filters.PolaroidProcessor`1 : FilterProcessor`1<TPixel> {
    private static Color LightOrange;
    private static Color VeryDarkOrange;
    [NullableAttribute("1")]
private PolaroidProcessor definition;
    [NullableContextAttribute("1")]
public PolaroidProcessor`1(Configuration configuration, PolaroidProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    private static PolaroidProcessor`1();
    protected virtual void AfterImageApply();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.ProtanomalyProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.ProtanopiaProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.SaturateProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public SaturateProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.SepiaProcessor : FilterProcessor {
    [CompilerGeneratedAttribute]
private float <Amount>k__BackingField;
    public float Amount { get; }
    public SepiaProcessor(float amount);
    [CompilerGeneratedAttribute]
public float get_Amount();
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.TritanomalyProcessor : FilterProcessor {
}
public class SixLabors.ImageSharp.Processing.Processors.Filters.TritanopiaProcessor : FilterProcessor {
}
public interface SixLabors.ImageSharp.Processing.Processors.ICloningImageProcessor {
    public abstract virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
public interface SixLabors.ImageSharp.Processing.Processors.ICloningImageProcessor`1 {
    public abstract virtual Image`1<TPixel> CloneAndExecute();
}
public interface SixLabors.ImageSharp.Processing.Processors.IImageProcessor {
    public abstract virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
public interface SixLabors.ImageSharp.Processing.Processors.IImageProcessor`1 {
    public abstract virtual void Execute();
}
public abstract class SixLabors.ImageSharp.Processing.Processors.ImageProcessor`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Image`1<TPixel> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <SourceRectangle>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Image`1<TPixel> Source { get; }
    protected Rectangle SourceRectangle { get; }
    [NullableAttribute("1")]
protected Configuration Configuration { get; }
    [NullableContextAttribute("1")]
protected ImageProcessor`1(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
protected Image`1<TPixel> get_Source();
    [CompilerGeneratedAttribute]
protected Rectangle get_SourceRectangle();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.IImageProcessor<TPixel>.Execute();
    public void Apply(ImageFrame`1<TPixel> source);
    public sealed virtual void Dispose();
    protected virtual void BeforeImageApply();
    protected virtual void BeforeFrameApply(ImageFrame`1<TPixel> source);
    protected abstract virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    protected virtual void AfterFrameApply(ImageFrame`1<TPixel> source);
    protected virtual void AfterImageApply();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Processing.Processors.ImageProcessorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Execute(IImageProcessor processor, Configuration configuration, Image source, Rectangle sourceRectangle);
}
public class SixLabors.ImageSharp.Processing.Processors.Normalization.AdaptiveHistogramEqualizationProcessor : HistogramEqualizationProcessor {
    [CompilerGeneratedAttribute]
private int <NumberOfTiles>k__BackingField;
    public int NumberOfTiles { get; }
    public AdaptiveHistogramEqualizationProcessor(int luminanceLevels, bool clipHistogram, int clipLimit, int numberOfTiles);
    [CompilerGeneratedAttribute]
public int get_NumberOfTiles();
    public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Normalization.AdaptiveHistogramEqualizationProcessor`1 : HistogramEqualizationProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private int <Tiles>k__BackingField;
    private int Tiles { get; }
    [NullableContextAttribute("1")]
public AdaptiveHistogramEqualizationProcessor`1(Configuration configuration, int luminanceLevels, bool clipHistogram, int clipLimit, int tiles, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
private int get_Tiles();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static void ProcessCornerTile(Buffer2D`1<TPixel> source, CdfTileData<TPixel> cdfData, int cdfX, int cdfY, int xStart, int xEnd, int yStart, int yEnd, int luminanceLevels);
    private static void ProcessBorderColumn(Buffer2D`1<TPixel> source, CdfTileData<TPixel> cdfData, int cdfX, int sourceHeight, int tileCount, int tileHeight, int xStart, int xEnd, int luminanceLevels);
    private static void ProcessBorderRow(Buffer2D`1<TPixel> source, CdfTileData<TPixel> cdfData, int cdfY, int sourceWidth, int tileCount, int tileWidth, int yStart, int yEnd, int luminanceLevels);
    private static float InterpolateBetweenFourTiles(TPixel sourcePixel, CdfTileData<TPixel> cdfData, int tileCountX, int tileCountY, int tileX, int tileY, int cdfX, int cdfY, int tileWidth, int tileHeight, int luminanceLevels);
    private static float InterpolateBetweenTwoTiles(TPixel sourcePixel, CdfTileData<TPixel> cdfData, int tileX1, int tileY1, int tileX2, int tileY2, int tilePos, int tileWidth, int luminanceLevels);
    private static float BilinearInterpolation(float tx, float ty, float lt, float rt, float lb, float rb);
    private static float LinearInterpolation(float left, float right, float t);
}
public class SixLabors.ImageSharp.Processing.Processors.Normalization.AdaptiveHistogramEqualizationSlidingWindowProcessor : HistogramEqualizationProcessor {
    [CompilerGeneratedAttribute]
private int <NumberOfTiles>k__BackingField;
    public int NumberOfTiles { get; }
    public AdaptiveHistogramEqualizationSlidingWindowProcessor(int luminanceLevels, bool clipHistogram, int clipLimit, int numberOfTiles);
    [CompilerGeneratedAttribute]
public int get_NumberOfTiles();
    public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Normalization.AdaptiveHistogramEqualizationSlidingWindowProcessor`1 : HistogramEqualizationProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private int <Tiles>k__BackingField;
    private int Tiles { get; }
    [NullableContextAttribute("1")]
public AdaptiveHistogramEqualizationSlidingWindowProcessor`1(Configuration configuration, int luminanceLevels, bool clipHistogram, int clipLimit, int tiles, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
private int get_Tiles();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static void CopyPixelRow(ImageFrame`1<TPixel> source, Span`1<Vector4> rowPixels, int x, int y, int tileWidth, Configuration configuration);
    private static void CopyPixelRowFast(Buffer2D`1<TPixel> source, Span`1<Vector4> rowPixels, int x, int y, int tileWidth, Configuration configuration);
    private static void AddPixelsToHistogram(Vector4& greyValuesBase, Int32& histogramBase, int luminanceLevels, int length);
    private static void RemovePixelsFromHistogram(Vector4& greyValuesBase, Int32& histogramBase, int luminanceLevels, int length);
}
public class SixLabors.ImageSharp.Processing.Processors.Normalization.AutoLevelProcessor : HistogramEqualizationProcessor {
    [CompilerGeneratedAttribute]
private bool <SyncChannels>k__BackingField;
    public bool SyncChannels { get; }
    public AutoLevelProcessor(int luminanceLevels, bool clipHistogram, int clipLimit, bool syncChannels);
    [CompilerGeneratedAttribute]
public bool get_SyncChannels();
    public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Normalization.AutoLevelProcessor`1 : HistogramEqualizationProcessor`1<TPixel> {
    [CompilerGeneratedAttribute]
private bool <SyncChannels>k__BackingField;
    private bool SyncChannels { get; }
    [NullableContextAttribute("1")]
public AutoLevelProcessor`1(Configuration configuration, int luminanceLevels, bool clipHistogram, int clipLimit, bool syncChannels, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
private bool get_SyncChannels();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Normalization.GlobalHistogramEqualizationProcessor : HistogramEqualizationProcessor {
    public GlobalHistogramEqualizationProcessor(int luminanceLevels, bool clipHistogram, int clipLimit);
    public virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Normalization.GlobalHistogramEqualizationProcessor`1 : HistogramEqualizationProcessor`1<TPixel> {
    [NullableContextAttribute("1")]
public GlobalHistogramEqualizationProcessor`1(Configuration configuration, int luminanceLevels, bool clipHistogram, int clipLimit, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Normalization.GrayscaleLevelsRowOperation`1 : ValueType {
    [NullableAttribute("1")]
private Configuration configuration;
    private Rectangle bounds;
    [NullableAttribute("1")]
private IMemoryOwner`1<int> histogramBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Buffer2D`1<TPixel> source;
    private int luminanceLevels;
    [NullableContextAttribute("1")]
public GrayscaleLevelsRowOperation`1(Configuration configuration, Rectangle bounds, IMemoryOwner`1<int> histogramBuffer, Buffer2D`1<TPixel> source, int luminanceLevels);
    public sealed virtual int GetRequiredBufferLength(Rectangle bounds);
    public sealed virtual void Invoke(int y, Span`1<Vector4> span);
}
public enum SixLabors.ImageSharp.Processing.Processors.Normalization.HistogramEqualizationMethod : Enum {
    public int value__;
    public static HistogramEqualizationMethod Global;
    public static HistogramEqualizationMethod AdaptiveTileInterpolation;
    public static HistogramEqualizationMethod AdaptiveSlidingWindow;
    public static HistogramEqualizationMethod AutoLevel;
}
public class SixLabors.ImageSharp.Processing.Processors.Normalization.HistogramEqualizationOptions : object {
    [CompilerGeneratedAttribute]
private HistogramEqualizationMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LuminanceLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClipHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClipLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfTiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SyncChannels>k__BackingField;
    public HistogramEqualizationMethod Method { get; public set; }
    public int LuminanceLevels { get; public set; }
    public bool ClipHistogram { get; public set; }
    public int ClipLimit { get; public set; }
    public int NumberOfTiles { get; public set; }
    public bool SyncChannels { get; public set; }
    [CompilerGeneratedAttribute]
public HistogramEqualizationMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(HistogramEqualizationMethod value);
    [CompilerGeneratedAttribute]
public int get_LuminanceLevels();
    [CompilerGeneratedAttribute]
public void set_LuminanceLevels(int value);
    [CompilerGeneratedAttribute]
public bool get_ClipHistogram();
    [CompilerGeneratedAttribute]
public void set_ClipHistogram(bool value);
    [CompilerGeneratedAttribute]
public int get_ClipLimit();
    [CompilerGeneratedAttribute]
public void set_ClipLimit(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfTiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfTiles(int value);
    [CompilerGeneratedAttribute]
public bool get_SyncChannels();
    [CompilerGeneratedAttribute]
public void set_SyncChannels(bool value);
}
public abstract class SixLabors.ImageSharp.Processing.Processors.Normalization.HistogramEqualizationProcessor : object {
    [CompilerGeneratedAttribute]
private int <LuminanceLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClipHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClipLimit>k__BackingField;
    public int LuminanceLevels { get; }
    public bool ClipHistogram { get; }
    public int ClipLimit { get; }
    protected HistogramEqualizationProcessor(int luminanceLevels, bool clipHistogram, int clipLimit);
    [CompilerGeneratedAttribute]
public int get_LuminanceLevels();
    [CompilerGeneratedAttribute]
public bool get_ClipHistogram();
    [CompilerGeneratedAttribute]
public int get_ClipLimit();
    public abstract virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    [NullableContextAttribute("1")]
public static HistogramEqualizationProcessor FromOptions(HistogramEqualizationOptions options);
}
internal abstract class SixLabors.ImageSharp.Processing.Processors.Normalization.HistogramEqualizationProcessor`1 : ImageProcessor`1<TPixel> {
    private float luminanceLevelsFloat;
    [CompilerGeneratedAttribute]
private int <LuminanceLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClipHistogramEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClipLimit>k__BackingField;
    public int LuminanceLevels { get; }
    public bool ClipHistogramEnabled { get; }
    public int ClipLimit { get; }
    [NullableContextAttribute("1")]
protected HistogramEqualizationProcessor`1(Configuration configuration, int luminanceLevels, bool clipHistogram, int clipLimit, Image`1<TPixel> source, Rectangle sourceRectangle);
    [CompilerGeneratedAttribute]
public int get_LuminanceLevels();
    [CompilerGeneratedAttribute]
public bool get_ClipHistogramEnabled();
    [CompilerGeneratedAttribute]
public int get_ClipLimit();
    public static int CalculateCdf(Int32& cdfBase, Int32& histogramBase, int maxIdx);
    public void ClipHistogram(Span`1<int> histogram, int clipLimit);
    public static int GetLuminance(TPixel sourcePixel, int luminanceLevels);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Overlays.BackgroundColorProcessor : object {
    [CompilerGeneratedAttribute]
private GraphicsOptions <GraphicsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; }
    public Color Color { get; }
    public BackgroundColorProcessor(GraphicsOptions options, Color color);
    [CompilerGeneratedAttribute]
public GraphicsOptions get_GraphicsOptions();
    [CompilerGeneratedAttribute]
public Color get_Color();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Overlays.BackgroundColorProcessor`1 : ImageProcessor`1<TPixel> {
    private BackgroundColorProcessor definition;
    public BackgroundColorProcessor`1(Configuration configuration, BackgroundColorProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Overlays.GlowProcessor : object {
    [CompilerGeneratedAttribute]
private GraphicsOptions <GraphicsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <GlowColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSize <Radius>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; }
    public Color GlowColor { get; }
    internal ValueSize Radius { get; }
    public GlowProcessor(GraphicsOptions options, Color color);
    internal GlowProcessor(GraphicsOptions options, Color color, ValueSize radius);
    [CompilerGeneratedAttribute]
public GraphicsOptions get_GraphicsOptions();
    [CompilerGeneratedAttribute]
public Color get_GlowColor();
    [CompilerGeneratedAttribute]
internal ValueSize get_Radius();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Overlays.GlowProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PixelBlender`1<TPixel> blender;
    [NullableAttribute("1")]
private GlowProcessor definition;
    [NullableContextAttribute("1")]
public GlowProcessor`1(Configuration configuration, GlowProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Overlays.VignetteProcessor : object {
    [CompilerGeneratedAttribute]
private GraphicsOptions <GraphicsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <VignetteColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSize <RadiusX>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSize <RadiusY>k__BackingField;
    public GraphicsOptions GraphicsOptions { get; }
    public Color VignetteColor { get; }
    internal ValueSize RadiusX { get; }
    internal ValueSize RadiusY { get; }
    public VignetteProcessor(GraphicsOptions options, Color color);
    internal VignetteProcessor(GraphicsOptions options, Color color, ValueSize radiusX, ValueSize radiusY);
    [CompilerGeneratedAttribute]
public GraphicsOptions get_GraphicsOptions();
    [CompilerGeneratedAttribute]
public Color get_VignetteColor();
    [CompilerGeneratedAttribute]
internal ValueSize get_RadiusX();
    [CompilerGeneratedAttribute]
internal ValueSize get_RadiusY();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Overlays.VignetteProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PixelBlender`1<TPixel> blender;
    [NullableAttribute("1")]
private VignetteProcessor definition;
    [NullableContextAttribute("1")]
public VignetteProcessor`1(Configuration configuration, VignetteProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.DefaultPixelSamplingStrategy : object {
    private static int DefaultMaximumPixels;
    [CompilerGeneratedAttribute]
private long <MaximumPixels>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinimumScanRatio>k__BackingField;
    public long MaximumPixels { get; }
    public double MinimumScanRatio { get; }
    public DefaultPixelSamplingStrategy(int maximumPixels, double minimumScanRatio);
    [CompilerGeneratedAttribute]
public long get_MaximumPixels();
    [CompilerGeneratedAttribute]
public double get_MinimumScanRatio();
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Processing.Processors.Quantization.DefaultPixelSamplingStrategy/<EnumeratePixelRegions>d__9`1")]
public sealed virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(Image`1<TPixel> image);
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Processing.Processors.Quantization.DefaultPixelSamplingStrategy/<EnumeratePixelRegions>d__10`1")]
public sealed virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(ImageFrame`1<TPixel> frame);
    [CompilerGeneratedAttribute]
internal static Buffer2DRegion`1<TPixel> <EnumeratePixelRegions>g__GetRow|9_0(int pos, <>c__DisplayClass9_0`1& );
    [CompilerGeneratedAttribute]
internal static Buffer2DRegion`1<TPixel> <EnumeratePixelRegions>g__GetRow|10_0(int pos, <>c__DisplayClass10_0`1& );
}
internal class SixLabors.ImageSharp.Processing.Processors.Quantization.EuclideanPixelMap`1 : object {
    [NullableAttribute("1")]
private Rgba32[] rgbaPalette;
    private int transparentIndex;
    private TPixel transparentMatch;
    private ColorDistanceCache<TPixel> cache;
    [NullableAttribute("1")]
private Configuration configuration;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<TPixel> <Palette>k__BackingField;
    public ReadOnlyMemory`1<TPixel> Palette { get; private set; }
    public EuclideanPixelMap`1(Configuration configuration, ReadOnlyMemory`1<TPixel> palette);
    public EuclideanPixelMap`1(Configuration configuration, ReadOnlyMemory`1<TPixel> palette, int transparentIndex);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<TPixel> get_Palette();
    [CompilerGeneratedAttribute]
private void set_Palette(ReadOnlyMemory`1<TPixel> value);
    public int GetClosestColor(TPixel color, TPixel& match);
    public void Clear(ReadOnlyMemory`1<TPixel> palette);
    public void SetTransparentIndex(int index);
    private int GetClosestColorSlow(Rgba32 rgba, TPixel& paletteRef, TPixel& match);
    private static float DistanceSquared(Rgba32 a, Rgba32 b);
    public sealed virtual void Dispose();
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.ExtensivePixelSamplingStrategy : object {
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Processing.Processors.Quantization.ExtensivePixelSamplingStrategy/<EnumeratePixelRegions>d__0`1")]
public sealed virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(Image`1<TPixel> image);
    [IteratorStateMachineAttribute("SixLabors.ImageSharp.Processing.Processors.Quantization.ExtensivePixelSamplingStrategy/<EnumeratePixelRegions>d__1`1")]
public sealed virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(ImageFrame`1<TPixel> frame);
}
public interface SixLabors.ImageSharp.Processing.Processors.Quantization.IPixelSamplingStrategy {
    public abstract virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(Image`1<TPixel> image);
    public abstract virtual IEnumerable`1<Buffer2DRegion`1<TPixel>> EnumeratePixelRegions(ImageFrame`1<TPixel> frame);
}
[NullableContextAttribute("1")]
public interface SixLabors.ImageSharp.Processing.Processors.Quantization.IQuantizer {
    public QuantizerOptions Options { get; }
    public abstract virtual QuantizerOptions get_Options();
    [NullableContextAttribute("0")]
public abstract virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration);
    public abstract virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration, QuantizerOptions options);
}
public interface SixLabors.ImageSharp.Processing.Processors.Quantization.IQuantizer`1 {
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    [NullableAttribute("1")]
public QuantizerOptions Options { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    [NullableContextAttribute("1")]
public abstract virtual Configuration get_Configuration();
    [NullableContextAttribute("1")]
public abstract virtual QuantizerOptions get_Options();
    public abstract virtual ReadOnlyMemory`1<TPixel> get_Palette();
    public abstract virtual void AddPaletteColors(Buffer2DRegion`1<TPixel> pixelRegion);
    public abstract virtual IndexedImageFrame`1<TPixel> QuantizeFrame(ImageFrame`1<TPixel> source, Rectangle bounds);
    public abstract virtual byte GetQuantizedColor(TPixel color, TPixel& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Quantization.OctreeQuantizer : object {
    [CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    public QuantizerOptions Options { get; }
    public OctreeQuantizer(QuantizerOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    [NullableContextAttribute("0")]
public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration);
    public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration, QuantizerOptions options);
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.OctreeQuantizer`1 : ValueType {
    private int maxColors;
    private int bitDepth;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Octree<TPixel> octree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryOwner`1<TPixel> paletteOwner;
    private ReadOnlyMemory`1<TPixel> palette;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EuclideanPixelMap`1<TPixel> pixelMap;
    private bool isDithering;
    private bool isDisposed;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    [NullableAttribute("1")]
public QuantizerOptions Options { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    [NullableContextAttribute("1")]
public OctreeQuantizer`1(Configuration configuration, QuantizerOptions options);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    [IsReadOnlyAttribute]
public sealed virtual ReadOnlyMemory`1<TPixel> get_Palette();
    public sealed virtual void AddPaletteColors(Buffer2DRegion`1<TPixel> pixelRegion);
    [IsReadOnlyAttribute]
public sealed virtual IndexedImageFrame`1<TPixel> QuantizeFrame(ImageFrame`1<TPixel> source, Rectangle bounds);
    [IsReadOnlyAttribute]
public sealed virtual byte GetQuantizedColor(TPixel color, TPixel& match);
    public sealed virtual void Dispose();
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.PaletteQuantizer : object {
    private ReadOnlyMemory`1<Color> colorPalette;
    private int transparentIndex;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public QuantizerOptions Options { get; }
    public PaletteQuantizer(ReadOnlyMemory`1<Color> palette);
    public PaletteQuantizer(ReadOnlyMemory`1<Color> palette, QuantizerOptions options);
    internal PaletteQuantizer(ReadOnlyMemory`1<Color> palette, QuantizerOptions options, int transparentIndex);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration);
    [NullableContextAttribute("1")]
public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration, QuantizerOptions options);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Quantization.PaletteQuantizer`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EuclideanPixelMap`1<TPixel> pixelMap;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    [NullableAttribute("1")]
public QuantizerOptions Options { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    [NullableContextAttribute("1")]
public PaletteQuantizer`1(Configuration configuration, QuantizerOptions options, ReadOnlyMemory`1<TPixel> palette, int transparentIndex);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    public sealed virtual ReadOnlyMemory`1<TPixel> get_Palette();
    public sealed virtual IndexedImageFrame`1<TPixel> QuantizeFrame(ImageFrame`1<TPixel> source, Rectangle bounds);
    public sealed virtual void AddPaletteColors(Buffer2DRegion`1<TPixel> pixelRegion);
    public void SetTransparentIndex(int index);
    public sealed virtual byte GetQuantizedColor(TPixel color, TPixel& match);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Quantization.QuantizeProcessor : object {
    [CompilerGeneratedAttribute]
private IQuantizer <Quantizer>k__BackingField;
    public IQuantizer Quantizer { get; }
    public QuantizeProcessor(IQuantizer quantizer);
    [CompilerGeneratedAttribute]
public IQuantizer get_Quantizer();
    [NullableContextAttribute("0")]
public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Quantization.QuantizeProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private IQuantizer quantizer;
    [NullableContextAttribute("1")]
public QuantizeProcessor`1(Configuration configuration, IQuantizer quantizer, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class SixLabors.ImageSharp.Processing.Processors.Quantization.QuantizerConstants : object {
    public static int MinColors;
    public static int MaxColors;
    public static float MinDitherScale;
    public static float MaxDitherScale;
    [CompilerGeneratedAttribute]
private static IDither <DefaultDither>k__BackingField;
    public static IDither DefaultDither { get; }
    private static QuantizerConstants();
    [CompilerGeneratedAttribute]
public static IDither get_DefaultDither();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Quantization.QuantizerOptions : object {
    private float ditherScale;
    private int maxColors;
    [CompilerGeneratedAttribute]
private IDither <Dither>k__BackingField;
    public IDither Dither { get; public set; }
    public float DitherScale { get; public set; }
    public int MaxColors { get; public set; }
    [CompilerGeneratedAttribute]
public IDither get_Dither();
    [CompilerGeneratedAttribute]
public void set_Dither(IDither value);
    public float get_DitherScale();
    public void set_DitherScale(float value);
    public int get_MaxColors();
    public void set_MaxColors(int value);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.Processors.Quantization.QuantizerUtilities : object {
    public static void CheckPaletteState(ReadOnlyMemory`1& palette);
    [ExtensionAttribute]
public static IndexedImageFrame`1<TPixel> BuildPaletteAndQuantizeFrame(IQuantizer`1<TPixel> quantizer, ImageFrame`1<TPixel> source, Rectangle bounds);
    public static IndexedImageFrame`1<TPixel> QuantizeFrame(TFrameQuantizer& quantizer, ImageFrame`1<TPixel> source, Rectangle bounds);
    [ExtensionAttribute]
public static void BuildPalette(IQuantizer`1<TPixel> quantizer, IPixelSamplingStrategy pixelSamplingStrategy, Image`1<TPixel> source);
    [ExtensionAttribute]
public static void BuildPalette(IQuantizer`1<TPixel> quantizer, IPixelSamplingStrategy pixelSamplingStrategy, ImageFrame`1<TPixel> source);
    private static void SecondPass(TFrameQuantizer& quantizer, ImageFrame`1<TPixel> source, IndexedImageFrame`1<TPixel> destination, Rectangle bounds);
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.WebSafePaletteQuantizer : PaletteQuantizer {
    [NullableContextAttribute("1")]
public WebSafePaletteQuantizer(QuantizerOptions options);
}
public class SixLabors.ImageSharp.Processing.Processors.Quantization.WernerPaletteQuantizer : PaletteQuantizer {
    [NullableContextAttribute("1")]
public WernerPaletteQuantizer(QuantizerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Quantization.WuQuantizer : object {
    [CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    public QuantizerOptions Options { get; }
    public WuQuantizer(QuantizerOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    [NullableContextAttribute("0")]
public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration);
    public sealed virtual IQuantizer`1<TPixel> CreatePixelSpecificQuantizer(Configuration configuration, QuantizerOptions options);
}
internal class SixLabors.ImageSharp.Processing.Processors.Quantization.WuQuantizer`1 : ValueType {
    [NullableAttribute("1")]
private MemoryAllocator memoryAllocator;
    private static int IndexBits;
    private static int IndexAlphaBits;
    private static int IndexCount;
    private static int IndexAlphaCount;
    private static int TableLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryOwner`1<Moment<TPixel>> momentsOwner;
    [NullableAttribute("1")]
private IMemoryOwner`1<byte> tagsOwner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IMemoryOwner`1<TPixel> paletteOwner;
    private ReadOnlyMemory`1<TPixel> palette;
    private int maxColors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Box[] colorCube;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EuclideanPixelMap`1<TPixel> pixelMap;
    private bool isDithering;
    private bool isDisposed;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private QuantizerOptions <Options>k__BackingField;
    [NullableAttribute("1")]
public Configuration Configuration { get; }
    [NullableAttribute("1")]
public QuantizerOptions Options { get; }
    public ReadOnlyMemory`1<TPixel> Palette { get; }
    [NullableContextAttribute("1")]
public WuQuantizer`1(Configuration configuration, QuantizerOptions options);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual QuantizerOptions get_Options();
    [IsReadOnlyAttribute]
public sealed virtual ReadOnlyMemory`1<TPixel> get_Palette();
    public sealed virtual void AddPaletteColors(Buffer2DRegion`1<TPixel> pixelRegion);
    [IsReadOnlyAttribute]
public sealed virtual IndexedImageFrame`1<TPixel> QuantizeFrame(ImageFrame`1<TPixel> source, Rectangle bounds);
    [IsReadOnlyAttribute]
public sealed virtual byte GetQuantizedColor(TPixel color, TPixel& match);
    public sealed virtual void Dispose();
    private static int GetPaletteIndex(int r, int g, int b, int a);
    private static Moment<TPixel> Volume(Box& cube, ReadOnlySpan`1<Moment<TPixel>> moments);
    private static Moment<TPixel> Bottom(Box& cube, int direction, ReadOnlySpan`1<Moment<TPixel>> moments);
    private static Moment<TPixel> Top(Box& cube, int direction, int position, ReadOnlySpan`1<Moment<TPixel>> moments);
    [IsReadOnlyAttribute]
private void Build3DHistogram(Buffer2DRegion`1<TPixel> source);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private void Get3DMoments(MemoryAllocator allocator);
    [IsReadOnlyAttribute]
private double Variance(Box& cube);
    [IsReadOnlyAttribute]
private float Maximize(Box& cube, int direction, int first, int last, Int32& cut, Moment<TPixel> whole);
    private bool Cut(Box& set1, Box& set2);
    [IsReadOnlyAttribute]
private void Mark(Box& cube, byte label);
    private void BuildCube();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.AffineTransformProcessor : CloningImageProcessor {
    [CompilerGeneratedAttribute]
private IResampler <Sampler>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix3x2 <TransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DestinationSize>k__BackingField;
    public IResampler Sampler { get; }
    public Matrix3x2 TransformMatrix { get; }
    public Size DestinationSize { get; }
    public AffineTransformProcessor(Matrix3x2 matrix, IResampler sampler, Size targetDimensions);
    [CompilerGeneratedAttribute]
public IResampler get_Sampler();
    [CompilerGeneratedAttribute]
public Matrix3x2 get_TransformMatrix();
    [CompilerGeneratedAttribute]
public Size get_DestinationSize();
    [NullableContextAttribute("0")]
public virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.AffineTransformProcessor`1 : TransformProcessor`1<TPixel> {
    private Size destinationSize;
    private Matrix3x2 transformMatrix;
    [NullableAttribute("1")]
private IResampler resampler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImageFrame`1<TPixel> source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImageFrame`1<TPixel> destination;
    [NullableContextAttribute("1")]
public AffineTransformProcessor`1(Configuration configuration, AffineTransformProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual Size GetDestinationSize();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    public void ApplyTransform(TResampler& sampler);
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.Transforms.IResamplingTransformImageProcessor<TPixel>.ApplyTransform(TResampler& modreq(System.Runtime.InteropServices.InAttribute) sampler);
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.AutoOrientProcessor : object {
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.AutoOrientProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableContextAttribute("1")]
public AutoOrientProcessor`1(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> sourceBase);
    private static ushort GetExifOrientation(Image`1<TPixel> source);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.BicubicResampler : ValueType {
    public float Radius { get; }
    public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.BoxResampler : ValueType {
    public float Radius { get; }
    public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.CropProcessor : CloningImageProcessor {
    [CompilerGeneratedAttribute]
private Rectangle <CropRectangle>k__BackingField;
    public Rectangle CropRectangle { get; }
    public CropProcessor(Rectangle cropRectangle, Size sourceSize);
    [CompilerGeneratedAttribute]
public Rectangle get_CropRectangle();
    public virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.CropProcessor`1 : TransformProcessor`1<TPixel> {
    private Rectangle cropRectangle;
    [NullableContextAttribute("1")]
public CropProcessor`1(Configuration configuration, CropProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual Size GetDestinationSize();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.CubicResampler : ValueType {
    private float bspline;
    private float cardinal;
    public static CubicResampler CatmullRom;
    public static CubicResampler Hermite;
    public static CubicResampler MitchellNetravali;
    public static CubicResampler Robidoux;
    public static CubicResampler RobidouxSharp;
    public static CubicResampler Spline;
    [CompilerGeneratedAttribute]
private float <Radius>k__BackingField;
    public float Radius { get; }
    public CubicResampler(float radius, float bspline, float cardinal);
    private static CubicResampler();
    [CompilerGeneratedAttribute]
public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.DegenerateTransformException : Exception {
    public DegenerateTransformException(string message);
    public DegenerateTransformException(string message, Exception innerException);
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.EntropyCropProcessor : object {
    [CompilerGeneratedAttribute]
private float <Threshold>k__BackingField;
    public float Threshold { get; }
    public EntropyCropProcessor(float threshold);
    [CompilerGeneratedAttribute]
public float get_Threshold();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.EntropyCropProcessor`1 : ImageProcessor`1<TPixel> {
    [NullableAttribute("1")]
private EntropyCropProcessor definition;
    [NullableContextAttribute("1")]
public EntropyCropProcessor`1(Configuration configuration, EntropyCropProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void BeforeImageApply();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static Rectangle GetBoundingRectangle(Point topLeft, Point bottomRight);
    private static Rectangle GetFilteredBoundingRectangle(ImageFrame`1<TPixel> bitmap, float componentValue, RgbaComponent channel);
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__GetMinY|5_0(ImageFrame`1<TPixel> pixels, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__GetMaxY|5_1(ImageFrame`1<TPixel> pixels, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__GetMinX|5_2(ImageFrame`1<TPixel> pixels, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static int <GetFilteredBoundingRectangle>g__GetMaxX|5_3(ImageFrame`1<TPixel> pixels, <>c__DisplayClass5_0& );
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.FlipProcessor : object {
    [CompilerGeneratedAttribute]
private FlipMode <FlipMode>k__BackingField;
    public FlipMode FlipMode { get; }
    public FlipProcessor(FlipMode flipMode);
    [CompilerGeneratedAttribute]
public FlipMode get_FlipMode();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.FlipProcessor`1 : ImageProcessor`1<TPixel> {
    private FlipProcessor definition;
    public FlipProcessor`1(Configuration configuration, FlipProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source);
    private static void FlipX(Buffer2D`1<TPixel> source, Configuration configuration);
    private static void FlipY(ImageFrame`1<TPixel> source, Configuration configuration);
}
public interface SixLabors.ImageSharp.Processing.Processors.Transforms.IResampler {
    public float Radius { get; }
    public abstract virtual float get_Radius();
    public abstract virtual float GetValue(float x);
    public abstract virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
public interface SixLabors.ImageSharp.Processing.Processors.Transforms.IResamplingTransformImageProcessor`1 {
    public abstract virtual void ApplyTransform(TResampler& modreq(System.Runtime.InteropServices.InAttribute) sampler);
}
public interface SixLabors.ImageSharp.Processing.Processors.Transforms.ISwizzler {
    public Size DestinationSize { get; }
    public abstract virtual Size get_DestinationSize();
    public abstract virtual Point Transform(Point point);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.LanczosResampler : ValueType {
    public static LanczosResampler Lanczos2;
    public static LanczosResampler Lanczos3;
    public static LanczosResampler Lanczos5;
    public static LanczosResampler Lanczos8;
    [CompilerGeneratedAttribute]
private float <Radius>k__BackingField;
    public float Radius { get; }
    public LanczosResampler(float radius);
    private static LanczosResampler();
    [CompilerGeneratedAttribute]
public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Transforms.LinearTransformUtility : object {
    public static float GetSamplingRadius(TResampler& sampler, int sourceSize, int destinationSize);
    public static int GetRangeStart(float radius, float center, int min, int max);
    public static int GetRangeEnd(float radius, float center, int min, int max);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.NearestNeighborResampler : ValueType {
    public float Radius { get; }
    public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.ProjectiveTransformProcessor : CloningImageProcessor {
    [CompilerGeneratedAttribute]
private IResampler <Sampler>k__BackingField;
    [CompilerGeneratedAttribute]
private Matrix4x4 <TransformMatrix>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DestinationSize>k__BackingField;
    public IResampler Sampler { get; }
    public Matrix4x4 TransformMatrix { get; }
    public Size DestinationSize { get; }
    public ProjectiveTransformProcessor(Matrix4x4 matrix, IResampler sampler, Size targetDimensions);
    [CompilerGeneratedAttribute]
public IResampler get_Sampler();
    [CompilerGeneratedAttribute]
public Matrix4x4 get_TransformMatrix();
    [CompilerGeneratedAttribute]
public Size get_DestinationSize();
    [NullableContextAttribute("0")]
public virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.ProjectiveTransformProcessor`1 : TransformProcessor`1<TPixel> {
    private Size destinationSize;
    [NullableAttribute("1")]
private IResampler resampler;
    private Matrix4x4 transformMatrix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImageFrame`1<TPixel> source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImageFrame`1<TPixel> destination;
    [NullableContextAttribute("1")]
public ProjectiveTransformProcessor`1(Configuration configuration, ProjectiveTransformProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual Size GetDestinationSize();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    public void ApplyTransform(TResampler& sampler);
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.Transforms.IResamplingTransformImageProcessor<TPixel>.ApplyTransform(TResampler& modreq(System.Runtime.InteropServices.InAttribute) sampler);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeHelper : object {
    public static int CalculateResizeWorkerHeightInWindowBands(int windowBandHeight, int width, int sizeLimitHintInBytes);
    public static ValueTuple`2<Size, Rectangle> CalculateTargetLocationAndBounds(Size sourceSize, ResizeOptions options);
    private static ValueTuple`2<Size, Rectangle> CalculateBoxPadRectangle(Size source, ResizeOptions options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateCropRectangle(Size source, ResizeOptions options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateMaxRectangle(Size source, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateMinRectangle(Size source, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculatePadRectangle(Size sourceSize, ResizeOptions options, int width, int height);
    private static ValueTuple`2<Size, Rectangle> CalculateManualRectangle(ResizeOptions options, int width, int height);
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
private static void ThrowInvalid(string message);
    private static int Sanitize(int input);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeKernel : ValueType {
    private Single* bufferPtr;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int StartIndex { get; }
    public int Length { get; }
    public Span`1<float> Values { get; }
    internal ResizeKernel(int startIndex, Single* bufferPtr, int length);
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
public int get_Length();
    public Span`1<float> get_Values();
    public Vector4 Convolve(Span`1<Vector4> rowSpan);
    public Vector4 ConvolveCore(Vector4& rowStartRef);
    internal ResizeKernel AlterLeftValue(int left);
    internal void Fill(Span`1<double> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeKernelMap : object {
    private static TolerantMath TolerantMath;
    private int sourceLength;
    private double ratio;
    private double scale;
    private int radius;
    private MemoryHandle pinHandle;
    private Buffer2D`1<float> data;
    private ResizeKernel[] kernels;
    private bool isDisposed;
    private Double[] tempValues;
    [CompilerGeneratedAttribute]
private int <DestinationLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDiameter>k__BackingField;
    public int DestinationLength { get; }
    public int MaxDiameter { get; }
    internal string Info { get; }
    private ResizeKernelMap(MemoryAllocator memoryAllocator, int sourceLength, int destinationLength, int bufferHeight, double ratio, double scale, int radius);
    private static ResizeKernelMap();
    [CompilerGeneratedAttribute]
public int get_DestinationLength();
    [CompilerGeneratedAttribute]
public int get_MaxDiameter();
    internal virtual string get_Info();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal ResizeKernel& GetKernel(UIntPtr destIdx);
    public static ResizeKernelMap Calculate(TResampler& sampler, int destinationSize, int sourceSize, MemoryAllocator memoryAllocator);
    [NullableContextAttribute("0")]
protected internal virtual void Initialize(TResampler& modreq(System.Runtime.InteropServices.InAttribute) sampler);
    [NullableContextAttribute("0")]
private ResizeKernel BuildKernel(TResampler& sampler, int destRowIndex, int dataRowIndex);
    private ResizeKernel CreateKernel(int dataRowIndex, int left, int right);
    [ConditionalAttribute("DEBUG")]
private void ValidateSizesForCreateKernel(int length, int dataRowIndex, int left, int right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeProcessor : CloningImageProcessor {
    [CompilerGeneratedAttribute]
private int <DestinationWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DestinationHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <DestinationRectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private ResizeOptions <Options>k__BackingField;
    public int DestinationWidth { get; }
    public int DestinationHeight { get; }
    public Rectangle DestinationRectangle { get; }
    public ResizeOptions Options { get; }
    public ResizeProcessor(ResizeOptions options, Size sourceSize);
    [CompilerGeneratedAttribute]
public int get_DestinationWidth();
    [CompilerGeneratedAttribute]
public int get_DestinationHeight();
    [CompilerGeneratedAttribute]
public Rectangle get_DestinationRectangle();
    [CompilerGeneratedAttribute]
public ResizeOptions get_Options();
    [NullableContextAttribute("0")]
public virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeProcessor`1 : TransformProcessor`1<TPixel> {
    [NullableAttribute("1")]
private ResizeOptions options;
    private int destinationWidth;
    private int destinationHeight;
    [NullableAttribute("1")]
private IResampler resampler;
    private Rectangle destinationRectangle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Image`1<TPixel> destination;
    [NullableContextAttribute("1")]
public ResizeProcessor`1(Configuration configuration, ResizeProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual Size GetDestinationSize();
    protected virtual void BeforeImageApply(Image`1<TPixel> destination);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    public void ApplyTransform(TResampler& sampler);
    [NullableContextAttribute("1")]
private static void ApplyNNResizeFrameTransform(Configuration configuration, ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, Rectangle sourceRectangle, Rectangle destinationRectangle, Rectangle interest);
    private static PixelConversionModifiers GetModifiers(bool compand, bool premultiplyAlpha);
    [NullableContextAttribute("1")]
private static void ApplyResizeFrameTransform(Configuration configuration, ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, ResizeKernelMap horizontalKernelMap, ResizeKernelMap verticalKernelMap, Rectangle sourceRectangle, Rectangle destinationRectangle, Rectangle interest, bool compand, bool premultiplyAlpha);
    private sealed virtual override void SixLabors.ImageSharp.Processing.Processors.Transforms.IResamplingTransformImageProcessor<TPixel>.ApplyTransform(TResampler& modreq(System.Runtime.InteropServices.InAttribute) sampler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.ResizeWorker`1 : object {
    private Buffer2D`1<Vector4> transposedFirstPassBuffer;
    private Configuration configuration;
    private PixelConversionModifiers conversionModifiers;
    private ResizeKernelMap horizontalKernelMap;
    [NullableAttribute("0")]
private Buffer2DRegion`1<TPixel> source;
    private Rectangle sourceRectangle;
    private IMemoryOwner`1<Vector4> tempRowBuffer;
    private IMemoryOwner`1<Vector4> tempColumnBuffer;
    private ResizeKernelMap verticalKernelMap;
    private Rectangle targetWorkingRect;
    private Point targetOrigin;
    private int windowBandHeight;
    private int workerHeight;
    private RowInterval currentWindow;
    public ResizeWorker`1(Configuration configuration, Buffer2DRegion`1<TPixel> source, PixelConversionModifiers conversionModifiers, ResizeKernelMap horizontalKernelMap, ResizeKernelMap verticalKernelMap, Rectangle targetWorkingRect, Point targetOrigin);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
public Span`1<Vector4> GetColumnSpan(int x, int startY);
    public void Initialize();
    public void FillDestinationPixels(RowInterval rowInterval, Buffer2D`1<TPixel> destination);
    private void Slide();
    private void CalculateFirstPassValues(RowInterval calculationInterval);
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.RotateProcessor : AffineTransformProcessor {
    [CompilerGeneratedAttribute]
private float <Degrees>k__BackingField;
    public float Degrees { get; }
    public RotateProcessor(float degrees, Size sourceSize);
    [NullableContextAttribute("1")]
public RotateProcessor(float degrees, IResampler sampler, Size sourceSize);
    [NullableContextAttribute("1")]
private RotateProcessor(Matrix3x2 rotationMatrix, Matrix3x2 boundsMatrix, IResampler sampler, Size sourceSize);
    [CompilerGeneratedAttribute]
public float get_Degrees();
    public virtual ICloningImageProcessor`1<TPixel> CreatePixelSpecificCloningProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.RotateProcessor`1 : AffineTransformProcessor`1<TPixel> {
    private float degrees;
    [NullableContextAttribute("1")]
public RotateProcessor`1(Configuration configuration, RotateProcessor definition, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
    protected virtual void AfterImageApply(Image`1<TPixel> destination);
    private static float WrapDegrees(float degrees);
    [NullableContextAttribute("1")]
private bool OptimizedApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, Configuration configuration);
    [NullableContextAttribute("1")]
private static void Rotate180(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, Configuration configuration);
    [NullableContextAttribute("1")]
private static void Rotate270(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, Configuration configuration);
    [NullableContextAttribute("1")]
private static void Rotate90(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination, Configuration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.SkewProcessor : AffineTransformProcessor {
    [CompilerGeneratedAttribute]
private float <DegreesX>k__BackingField;
    [CompilerGeneratedAttribute]
private float <DegreesY>k__BackingField;
    public float DegreesX { get; }
    public float DegreesY { get; }
    public SkewProcessor(float degreesX, float degreesY, Size sourceSize);
    public SkewProcessor(float degreesX, float degreesY, IResampler sampler, Size sourceSize);
    private SkewProcessor(Matrix3x2 skewMatrix, Matrix3x2 boundsMatrix, IResampler sampler, Size sourceSize);
    [CompilerGeneratedAttribute]
public float get_DegreesX();
    [CompilerGeneratedAttribute]
public float get_DegreesY();
}
public class SixLabors.ImageSharp.Processing.Processors.Transforms.SwizzleProcessor`1 : object {
    [CompilerGeneratedAttribute]
private TSwizzler <Swizzler>k__BackingField;
    public TSwizzler Swizzler { get; }
    public SwizzleProcessor`1(TSwizzler swizzler);
    [CompilerGeneratedAttribute]
public TSwizzler get_Swizzler();
    public sealed virtual IImageProcessor`1<TPixel> CreatePixelSpecificProcessor(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
}
internal class SixLabors.ImageSharp.Processing.Processors.Transforms.SwizzleProcessor`2 : TransformProcessor`1<TPixel> {
    private TSwizzler swizzler;
    private Size destinationSize;
    public SwizzleProcessor`2(Configuration configuration, TSwizzler swizzler, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual Size GetDestinationSize();
    protected virtual void OnFrameApply(ImageFrame`1<TPixel> source, ImageFrame`1<TPixel> destination);
}
internal abstract class SixLabors.ImageSharp.Processing.Processors.Transforms.TransformProcessor`1 : CloningImageProcessor`1<TPixel> {
    [NullableContextAttribute("1")]
protected TransformProcessor`1(Configuration configuration, Image`1<TPixel> source, Rectangle sourceRectangle);
    protected virtual void AfterImageApply(Image`1<TPixel> destination);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Transforms.TransformProcessorHelpers : object {
    public static void UpdateDimensionalMetadata(Image`1<TPixel> image);
}
internal static class SixLabors.ImageSharp.Processing.Processors.Transforms.TransformUtils : object {
    public static bool IsDegenerate(Matrix3x2 matrix);
    public static bool IsDegenerate(Matrix4x4 matrix);
    private static bool IsZero(float a);
    public static bool IsNaN(Matrix3x2 matrix);
    public static bool IsNaN(Matrix4x4 matrix);
    public static Vector2 ProjectiveTransform2D(float x, float y, Matrix4x4 matrix);
    public static Matrix3x2 CreateRotationTransformMatrixDegrees(float degrees, Size size);
    public static Matrix3x2 CreateRotationTransformMatrixRadians(float radians, Size size);
    public static Matrix3x2 CreateRotationBoundsMatrixDegrees(float degrees, Size size);
    public static Matrix3x2 CreateRotationBoundsMatrixRadians(float radians, Size size);
    public static Matrix3x2 CreateSkewTransformMatrixDegrees(float degreesX, float degreesY, Size size);
    public static Matrix3x2 CreateSkewTransformMatrixRadians(float radiansX, float radiansY, Size size);
    public static Matrix3x2 CreateSkewBoundsMatrixDegrees(float degreesX, float degreesY, Size size);
    public static Matrix3x2 CreateSkewBoundsMatrixRadians(float radiansX, float radiansY, Size size);
    public static Matrix3x2 CreateCenteredTransformMatrix(Rectangle sourceRectangle, Matrix3x2 matrix);
    public static Matrix3x2 CreateCenteredBoundsMatrix(Rectangle sourceRectangle, Matrix3x2 matrix);
    public static Matrix4x4 CreateTaperMatrix(Size size, TaperSide side, TaperCorner corner, float fraction);
    public static Rectangle GetTransformedBoundingRectangle(Rectangle rectangle, Matrix3x2 matrix);
    public static Rectangle GetTransformedRectangle(Rectangle rectangle, Matrix3x2 matrix);
    public static Size GetTransformedSize(Size size, Matrix3x2 matrix);
    public static Rectangle GetTransformedRectangle(Rectangle rectangle, Matrix4x4 matrix);
    public static Size GetTransformedSize(Size size, Matrix4x4 matrix);
    private static Size ConstrainSize(Rectangle rectangle);
    private static Rectangle GetBoundingRectangle(Vector2 tl, Vector2 tr, Vector2 bl, Vector2 br);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.TriangleResampler : ValueType {
    public float Radius { get; }
    public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Processing.Processors.Transforms.WelchResampler : ValueType {
    public float Radius { get; }
    public sealed virtual float get_Radius();
    public sealed virtual float GetValue(float x);
    public sealed virtual void ApplyTransform(IResamplingTransformImageProcessor`1<TPixel> processor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.ProjectiveTransformBuilder : object {
    private List`1<Func`2<Size, Matrix4x4>> transformMatrixFactories;
    private List`1<Func`2<Size, Matrix4x4>> boundsMatrixFactories;
    public ProjectiveTransformBuilder PrependTaper(TaperSide side, TaperCorner corner, float fraction);
    public ProjectiveTransformBuilder AppendTaper(TaperSide side, TaperCorner corner, float fraction);
    public ProjectiveTransformBuilder PrependRotationDegrees(float degrees);
    public ProjectiveTransformBuilder PrependRotationRadians(float radians);
    internal ProjectiveTransformBuilder PrependRotationDegrees(float degrees, Vector2 origin);
    internal ProjectiveTransformBuilder PrependRotationRadians(float radians, Vector2 origin);
    public ProjectiveTransformBuilder AppendRotationDegrees(float degrees);
    public ProjectiveTransformBuilder AppendRotationRadians(float radians);
    internal ProjectiveTransformBuilder AppendRotationDegrees(float degrees, Vector2 origin);
    internal ProjectiveTransformBuilder AppendRotationRadians(float radians, Vector2 origin);
    public ProjectiveTransformBuilder PrependScale(float scale);
    public ProjectiveTransformBuilder PrependScale(SizeF scale);
    public ProjectiveTransformBuilder PrependScale(Vector2 scales);
    public ProjectiveTransformBuilder AppendScale(float scale);
    public ProjectiveTransformBuilder AppendScale(SizeF scales);
    public ProjectiveTransformBuilder AppendScale(Vector2 scales);
    internal ProjectiveTransformBuilder PrependSkewDegrees(float degreesX, float degreesY);
    public ProjectiveTransformBuilder PrependSkewRadians(float radiansX, float radiansY);
    public ProjectiveTransformBuilder PrependSkewDegrees(float degreesX, float degreesY, Vector2 origin);
    public ProjectiveTransformBuilder PrependSkewRadians(float radiansX, float radiansY, Vector2 origin);
    internal ProjectiveTransformBuilder AppendSkewDegrees(float degreesX, float degreesY);
    public ProjectiveTransformBuilder AppendSkewRadians(float radiansX, float radiansY);
    public ProjectiveTransformBuilder AppendSkewDegrees(float degreesX, float degreesY, Vector2 origin);
    public ProjectiveTransformBuilder AppendSkewRadians(float radiansX, float radiansY, Vector2 origin);
    public ProjectiveTransformBuilder PrependTranslation(PointF position);
    public ProjectiveTransformBuilder PrependTranslation(Vector2 position);
    public ProjectiveTransformBuilder AppendTranslation(PointF position);
    public ProjectiveTransformBuilder AppendTranslation(Vector2 position);
    public ProjectiveTransformBuilder PrependMatrix(Matrix4x4 matrix);
    public ProjectiveTransformBuilder AppendMatrix(Matrix4x4 matrix);
    public Matrix4x4 BuildMatrix(Size sourceSize);
    public Matrix4x4 BuildMatrix(Rectangle sourceRectangle);
    public Size GetTransformedSize(Rectangle sourceRectangle);
    private static void CheckDegenerate(Matrix4x4 matrix);
    private ProjectiveTransformBuilder Prepend(Func`2<Size, Matrix4x4> transformFactory, Func`2<Size, Matrix4x4> boundsFactory);
    private ProjectiveTransformBuilder Append(Func`2<Size, Matrix4x4> transformFactory, Func`2<Size, Matrix4x4> boundsFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.QuantizeExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Quantize(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Quantize(IImageProcessingContext source, IQuantizer quantizer);
    [ExtensionAttribute]
public static IImageProcessingContext Quantize(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Quantize(IImageProcessingContext source, IQuantizer quantizer, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.ResizeExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, Size size);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, Size size, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, Size size, IResampler sampler, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height, IResampler sampler, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height, IResampler sampler, Rectangle sourceRectangle, Rectangle targetRectangle, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, int width, int height, IResampler sampler, Rectangle targetRectangle, bool compand);
    [ExtensionAttribute]
public static IImageProcessingContext Resize(IImageProcessingContext source, ResizeOptions options);
}
public enum SixLabors.ImageSharp.Processing.ResizeMode : Enum {
    public int value__;
    public static ResizeMode Crop;
    public static ResizeMode Pad;
    public static ResizeMode BoxPad;
    public static ResizeMode Max;
    public static ResizeMode Min;
    public static ResizeMode Stretch;
    public static ResizeMode Manual;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class SixLabors.ImageSharp.Processing.ResizeOptions : object {
    [CompilerGeneratedAttribute]
private ResizeMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private AnchorPositionMode <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PointF> <CenterCoordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private IResampler <Sampler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compand>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Rectangle> <TargetRectangle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PremultiplyAlpha>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <PadColor>k__BackingField;
    public ResizeMode Mode { get; public set; }
    public AnchorPositionMode Position { get; public set; }
    public Nullable`1<PointF> CenterCoordinates { get; public set; }
    public Size Size { get; public set; }
    public IResampler Sampler { get; public set; }
    public bool Compand { get; public set; }
    public Nullable`1<Rectangle> TargetRectangle { get; public set; }
    public bool PremultiplyAlpha { get; public set; }
    public Color PadColor { get; public set; }
    [CompilerGeneratedAttribute]
public ResizeMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(ResizeMode value);
    [CompilerGeneratedAttribute]
public AnchorPositionMode get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(AnchorPositionMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<PointF> get_CenterCoordinates();
    [CompilerGeneratedAttribute]
public void set_CenterCoordinates(Nullable`1<PointF> value);
    [CompilerGeneratedAttribute]
public Size get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Size value);
    [CompilerGeneratedAttribute]
public IResampler get_Sampler();
    [CompilerGeneratedAttribute]
public void set_Sampler(IResampler value);
    [CompilerGeneratedAttribute]
public bool get_Compand();
    [CompilerGeneratedAttribute]
public void set_Compand(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<Rectangle> get_TargetRectangle();
    [CompilerGeneratedAttribute]
public void set_TargetRectangle(Nullable`1<Rectangle> value);
    [CompilerGeneratedAttribute]
public bool get_PremultiplyAlpha();
    [CompilerGeneratedAttribute]
public void set_PremultiplyAlpha(bool value);
    [CompilerGeneratedAttribute]
public Color get_PadColor();
    [CompilerGeneratedAttribute]
public void set_PadColor(Color value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.RotateExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Rotate(IImageProcessingContext source, RotateMode rotateMode);
    [ExtensionAttribute]
public static IImageProcessingContext Rotate(IImageProcessingContext source, float degrees);
    [ExtensionAttribute]
public static IImageProcessingContext Rotate(IImageProcessingContext source, float degrees, IResampler sampler);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.RotateFlipExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageProcessingContext RotateFlip(IImageProcessingContext source, RotateMode rotateMode, FlipMode flipMode);
}
public enum SixLabors.ImageSharp.Processing.RotateMode : Enum {
    public int value__;
    public static RotateMode None;
    public static RotateMode Rotate90;
    public static RotateMode Rotate180;
    public static RotateMode Rotate270;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.SaturateExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Saturate(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Saturate(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.SepiaExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Sepia(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Sepia(IImageProcessingContext source, float amount);
    [ExtensionAttribute]
public static IImageProcessingContext Sepia(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Sepia(IImageProcessingContext source, float amount, Rectangle rectangle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.SkewExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Skew(IImageProcessingContext source, float degreesX, float degreesY);
    [ExtensionAttribute]
public static IImageProcessingContext Skew(IImageProcessingContext source, float degreesX, float degreesY, IResampler sampler);
}
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.SwizzleExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IImageProcessingContext Swizzle(IImageProcessingContext source, TSwizzler swizzler);
}
public enum SixLabors.ImageSharp.Processing.TaperCorner : Enum {
    public int value__;
    public static TaperCorner LeftOrTop;
    public static TaperCorner RightOrBottom;
    public static TaperCorner Both;
}
public enum SixLabors.ImageSharp.Processing.TaperSide : Enum {
    public int value__;
    public static TaperSide Left;
    public static TaperSide Top;
    public static TaperSide Right;
    public static TaperSide Bottom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.TransformExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, AffineTransformBuilder builder);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, AffineTransformBuilder builder, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, Rectangle sourceRectangle, AffineTransformBuilder builder, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, Rectangle sourceRectangle, Matrix3x2 transform, Size targetDimensions, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, ProjectiveTransformBuilder builder);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, ProjectiveTransformBuilder builder, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, Rectangle sourceRectangle, ProjectiveTransformBuilder builder, IResampler sampler);
    [ExtensionAttribute]
public static IImageProcessingContext Transform(IImageProcessingContext source, Rectangle sourceRectangle, Matrix4x4 transform, Size targetDimensions, IResampler sampler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class SixLabors.ImageSharp.Processing.VignetteExtensions : object {
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, float radiusX, float radiusY);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, Color color, float radiusX, float radiusY, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, GraphicsOptions options);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, GraphicsOptions options, Color color);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, GraphicsOptions options, float radiusX, float radiusY);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, GraphicsOptions options, Rectangle rectangle);
    [ExtensionAttribute]
public static IImageProcessingContext Vignette(IImageProcessingContext source, GraphicsOptions options, Color color, float radiusX, float radiusY, Rectangle rectangle);
    [ExtensionAttribute]
private static IImageProcessingContext VignetteInternal(IImageProcessingContext source, GraphicsOptions options, Color color, ValueSize radiusX, ValueSize radiusY, Rectangle rectangle);
    [ExtensionAttribute]
private static IImageProcessingContext VignetteInternal(IImageProcessingContext source, GraphicsOptions options, Color color, ValueSize radiusX, ValueSize radiusY);
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.Rational : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Numerator>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Denominator>k__BackingField;
    public UInt32 Numerator { get; }
    public UInt32 Denominator { get; }
    public Rational(UInt32 value);
    public Rational(UInt32 numerator, UInt32 denominator);
    public Rational(UInt32 numerator, UInt32 denominator, bool simplify);
    public Rational(double value);
    public Rational(double value, bool bestPrecision);
    [CompilerGeneratedAttribute]
public UInt32 get_Numerator();
    [CompilerGeneratedAttribute]
public UInt32 get_Denominator();
    public static bool op_Equality(Rational left, Rational right);
    public static bool op_Inequality(Rational left, Rational right);
    public static Rational FromDouble(double value);
    public static Rational FromDouble(double value, bool bestPrecision);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rational other);
    public virtual int GetHashCode();
    public double ToDouble();
    public float ToSingle();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
}
public enum SixLabors.ImageSharp.ReadOrigin : Enum {
    public int value__;
    public static ReadOrigin Begin;
    public static ReadOrigin Current;
}
public class SixLabors.ImageSharp.Rectangle : ValueType {
    public static Rectangle Empty;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    [EditorBrowsableAttribute("1")]
public Point Location { get; public set; }
    [EditorBrowsableAttribute("1")]
public Size Size { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public int Top { get; }
    public int Right { get; }
    public int Bottom { get; }
    public int Left { get; }
    public Rectangle(int x, int y, int width, int height);
    public Rectangle(Point point, Size size);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    public Point get_Location();
    public void set_Location(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public bool get_IsEmpty();
    public int get_Top();
    public int get_Right();
    public int get_Bottom();
    public int get_Left();
    public static RectangleF op_Implicit(Rectangle rectangle);
    public static Vector4 op_Implicit(Rectangle rectangle);
    public static bool op_Equality(Rectangle left, Rectangle right);
    public static bool op_Inequality(Rectangle left, Rectangle right);
    public static Rectangle FromLTRB(int left, int top, int right, int bottom);
    public static Point Center(Rectangle rectangle);
    public static Rectangle Intersect(Rectangle a, Rectangle b);
    public static Rectangle Inflate(Rectangle rectangle, int x, int y);
    public static Rectangle Ceiling(RectangleF rectangle);
    public static RectangleF Transform(Rectangle rectangle, Matrix3x2 matrix);
    public static Rectangle Truncate(RectangleF rectangle);
    public static Rectangle Round(RectangleF rectangle);
    public static Rectangle Union(Rectangle a, Rectangle b);
    public void Deconstruct(Int32& x, Int32& y, Int32& width, Int32& height);
    public void Intersect(Rectangle rectangle);
    public void Inflate(int width, int height);
    public void Inflate(Size size);
    public bool Contains(int x, int y);
    public bool Contains(Point point);
    public bool Contains(Rectangle rectangle);
    public bool IntersectsWith(Rectangle rectangle);
    public void Offset(Point point);
    public void Offset(int dx, int dy);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rectangle other);
}
public class SixLabors.ImageSharp.RectangleF : ValueType {
    public static RectangleF Empty;
    [CompilerGeneratedAttribute]
private float <X>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Height>k__BackingField;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    [EditorBrowsableAttribute("1")]
public PointF Location { get; public set; }
    [EditorBrowsableAttribute("1")]
public SizeF Size { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public float Top { get; }
    public float Right { get; }
    public float Bottom { get; }
    public float Left { get; }
    public RectangleF(float x, float y, float width, float height);
    public RectangleF(PointF point, SizeF size);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_X();
    [CompilerGeneratedAttribute]
public void set_X(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    public PointF get_Location();
    public void set_Location(PointF value);
    public SizeF get_Size();
    public void set_Size(SizeF value);
    public bool get_IsEmpty();
    public float get_Top();
    public float get_Right();
    public float get_Bottom();
    public float get_Left();
    public static Rectangle op_Explicit(RectangleF rectangle);
    public static bool op_Equality(RectangleF left, RectangleF right);
    public static bool op_Inequality(RectangleF left, RectangleF right);
    public static RectangleF FromLTRB(float left, float top, float right, float bottom);
    public static PointF Center(RectangleF rectangle);
    public static RectangleF Intersect(RectangleF a, RectangleF b);
    public static RectangleF Inflate(RectangleF rectangle, float x, float y);
    public static RectangleF Transform(RectangleF rectangle, Matrix3x2 matrix);
    public static RectangleF Union(RectangleF a, RectangleF b);
    public void Deconstruct(Single& x, Single& y, Single& width, Single& height);
    public void Intersect(RectangleF rectangle);
    public void Inflate(float width, float height);
    public void Inflate(SizeF size);
    public bool Contains(float x, float y);
    public bool Contains(PointF point);
    public bool Contains(RectangleF rectangle);
    public bool IntersectsWith(RectangleF rectangle);
    public void Offset(PointF point);
    public void Offset(float dx, float dy);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RectangleF other);
}
internal enum SixLabors.ImageSharp.RgbaComponent : Enum {
    public int value__;
    public static RgbaComponent R;
    public static RgbaComponent G;
    public static RgbaComponent B;
    public static RgbaComponent A;
}
[IsReadOnlyAttribute]
public class SixLabors.ImageSharp.SignedRational : ValueType {
    [CompilerGeneratedAttribute]
private int <Numerator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Denominator>k__BackingField;
    public int Numerator { get; }
    public int Denominator { get; }
    public SignedRational(int value);
    public SignedRational(int numerator, int denominator);
    public SignedRational(int numerator, int denominator, bool simplify);
    public SignedRational(double value);
    public SignedRational(double value, bool bestPrecision);
    [CompilerGeneratedAttribute]
public int get_Numerator();
    [CompilerGeneratedAttribute]
public int get_Denominator();
    public static bool op_Equality(SignedRational left, SignedRational right);
    public static bool op_Inequality(SignedRational left, SignedRational right);
    public static SignedRational FromDouble(double value);
    public static SignedRational FromDouble(double value, bool bestPrecision);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignedRational other);
    public virtual int GetHashCode();
    public double ToDouble();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.SimdUtils : object {
    [CompilerGeneratedAttribute]
private static bool <HasVector8>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasVector4>k__BackingField;
    public static bool HasVector8 { get; }
    public static bool HasVector4 { get; }
    private static SimdUtils();
    [CompilerGeneratedAttribute]
public static bool get_HasVector8();
    [CompilerGeneratedAttribute]
public static bool get_HasVector4();
    [ExtensionAttribute]
internal static Vector4 PseudoRound(Vector4 v);
    [ExtensionAttribute]
internal static Vector`1<float> FastRound(Vector`1<float> v);
    internal static void ByteToNormalizedFloat(ReadOnlySpan`1<byte> source, Span`1<float> dest);
    internal static void NormalizedFloatToByteSaturate(ReadOnlySpan`1<float> source, Span`1<byte> dest);
    private static void ConvertByteToNormalizedFloatRemainder(ReadOnlySpan`1<byte> source, Span`1<float> dest);
    private static void ConvertNormalizedFloatToByteRemainder(ReadOnlySpan`1<float> source, Span`1<byte> dest);
    private static byte ConvertToByte(float f);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
private static void VerifyHasVector8(string operation);
    [ConditionalAttribute("DEBUG")]
private static void VerifySpanInput(ReadOnlySpan`1<byte> source, Span`1<float> dest, int shouldBeDivisibleBy);
    [ConditionalAttribute("DEBUG")]
private static void VerifySpanInput(ReadOnlySpan`1<float> source, Span`1<byte> dest, int shouldBeDivisibleBy);
    internal static void PackFromRgbPlanes(ReadOnlySpan`1<byte> redChannel, ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<Rgb24> destination);
    internal static void PackFromRgbPlanes(ReadOnlySpan`1<byte> redChannel, ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<Rgba32> destination);
    internal static void UnpackToRgbPlanes(Span`1<float> redChannel, Span`1<float> greenChannel, Span`1<float> blueChannel, ReadOnlySpan`1<Rgb24> source);
    private static void PackFromRgbPlanesScalarBatchedReduce(ReadOnlySpan`1& redChannel, ReadOnlySpan`1& greenChannel, ReadOnlySpan`1& blueChannel, Span`1& destination);
    private static void PackFromRgbPlanesScalarBatchedReduce(ReadOnlySpan`1& redChannel, ReadOnlySpan`1& greenChannel, ReadOnlySpan`1& blueChannel, Span`1& destination);
    private static void PackFromRgbPlanesRemainder(ReadOnlySpan`1<byte> redChannel, ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<Rgb24> destination);
    private static void PackFromRgbPlanesRemainder(ReadOnlySpan`1<byte> redChannel, ReadOnlySpan`1<byte> greenChannel, ReadOnlySpan`1<byte> blueChannel, Span`1<Rgba32> destination);
    private static void UnpackToRgbPlanesScalar(Span`1<float> redChannel, Span`1<float> greenChannel, Span`1<float> blueChannel, ReadOnlySpan`1<Rgb24> source);
    public static void Shuffle4(ReadOnlySpan`1<float> source, Span`1<float> dest, byte control);
    public static void Shuffle4(ReadOnlySpan`1<byte> source, Span`1<byte> dest, TShuffle shuffle);
    public static void Shuffle3(ReadOnlySpan`1<byte> source, Span`1<byte> dest, TShuffle shuffle);
    public static void Pad3Shuffle4(ReadOnlySpan`1<byte> source, Span`1<byte> dest, TShuffle shuffle);
    public static void Shuffle4Slice3(ReadOnlySpan`1<byte> source, Span`1<byte> dest, TShuffle shuffle);
    private static void Shuffle4Remainder(ReadOnlySpan`1<float> source, Span`1<float> dest, byte control);
    [ConditionalAttribute("DEBUG")]
internal static void VerifyShuffle4SpanInput(ReadOnlySpan`1<T> source, Span`1<T> dest);
    [ConditionalAttribute("DEBUG")]
private static void VerifyShuffle3SpanInput(ReadOnlySpan`1<T> source, Span`1<T> dest);
    [ConditionalAttribute("DEBUG")]
private static void VerifyPad3Shuffle4SpanInput(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
    [ConditionalAttribute("DEBUG")]
private static void VerifyShuffle4Slice3SpanInput(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
public class SixLabors.ImageSharp.Size : ValueType {
    public static Size Empty;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public Size(int value);
    public Size(int width, int height);
    public Size(Size size);
    public Size(Point point);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    public bool get_IsEmpty();
    public static SizeF op_Implicit(Size size);
    public static Point op_Explicit(Size size);
    public static Size op_Addition(Size left, Size right);
    public static Size op_Subtraction(Size left, Size right);
    public static Size op_Multiply(int left, Size right);
    public static Size op_Multiply(Size left, int right);
    public static Size op_Division(Size left, int right);
    public static SizeF op_Multiply(float left, Size right);
    public static SizeF op_Multiply(Size left, float right);
    public static SizeF op_Division(Size left, float right);
    public static bool op_Equality(Size left, Size right);
    public static bool op_Inequality(Size left, Size right);
    public static Size Add(Size left, Size right);
    public static Size Subtract(Size left, Size right);
    public static Size Ceiling(SizeF size);
    public static Size Round(SizeF size);
    public static SizeF Transform(Size size, Matrix3x2 matrix);
    public static Size Truncate(SizeF size);
    public void Deconstruct(Int32& width, Int32& height);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Size other);
    private static Size Multiply(Size size, int multiplier);
    private static SizeF Multiply(Size size, float multiplier);
}
public class SixLabors.ImageSharp.SizeF : ValueType {
    public static SizeF Empty;
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Height>k__BackingField;
    public float Width { get; public set; }
    public float Height { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsEmpty { get; }
    public SizeF(float width, float height);
    public SizeF(SizeF size);
    public SizeF(PointF point);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    public bool get_IsEmpty();
    public static Vector2 op_Implicit(SizeF point);
    public static Size op_Explicit(SizeF size);
    public static PointF op_Explicit(SizeF size);
    public static SizeF op_Addition(SizeF left, SizeF right);
    public static SizeF op_Subtraction(SizeF left, SizeF right);
    public static SizeF op_Multiply(float left, SizeF right);
    public static SizeF op_Multiply(SizeF left, float right);
    public static SizeF op_Division(SizeF left, float right);
    public static bool op_Equality(SizeF left, SizeF right);
    public static bool op_Inequality(SizeF left, SizeF right);
    public static SizeF Add(SizeF left, SizeF right);
    public static SizeF Subtract(SizeF left, SizeF right);
    public static SizeF Transform(SizeF size, Matrix3x2 matrix);
    public void Deconstruct(Single& width, Single& height);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SizeF other);
    private static SizeF Multiply(SizeF size, float multiplier);
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.StreamExtensions : object {
    [ExtensionAttribute]
public static void Write(Stream stream, Span`1<byte> buffer, int offset, int count);
    [ExtensionAttribute]
public static int Read(Stream stream, Span`1<byte> buffer, int offset, int count);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Skip(Stream stream, int count);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.TolerantMath : ValueType {
    private double epsilon;
    private double negEpsilon;
    public static TolerantMath Default;
    public TolerantMath(double epsilon);
    private static TolerantMath();
    public bool IsZero(double a);
    public bool IsPositive(double a);
    public bool IsNegative(double a);
    public bool AreEqual(double a, double b);
    public bool IsGreater(double a, double b);
    public bool IsLess(double a, double b);
    public bool IsGreaterOrEqual(double a, double b);
    public bool IsLessOrEqual(double a, double b);
    public double Ceiling(double a);
    public double Floor(double a);
}
internal class SixLabors.ImageSharp.Tuples.Octet`1 : ValueType {
    public T V0;
    public T V1;
    public T V2;
    public T V3;
    public T V4;
    public T V5;
    public T V6;
    public T V7;
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
}
[ExtensionAttribute]
internal static class SixLabors.ImageSharp.Tuples.OctetExtensions : object {
    [ExtensionAttribute]
public static void LoadFrom(Octet`1& destination, Octet`1& source);
    [ExtensionAttribute]
public static void LoadFrom(Octet`1& destination, Octet`1& source);
}
public class SixLabors.ImageSharp.UnknownImageFormatException : ImageFormatException {
    [NullableContextAttribute("1")]
public UnknownImageFormatException(string errorMessage);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.ValueSize : ValueType {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSizeType <Type>k__BackingField;
    public float Value { get; }
    public ValueSizeType Type { get; }
    public ValueSize(float value, ValueSizeType type);
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
public ValueSizeType get_Type();
    public static ValueSize op_Implicit(float f);
    public static ValueSize PercentageOfWidth(float percentage);
    public static ValueSize PercentageOfHeight(float percentage);
    public static ValueSize Absolute(float value);
    public float Calculate(Size size);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueSize other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.WXYZShuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.WZYXShuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.XWZYShuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.XYZWPad3Shuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.XYZWShuffle4Slice3 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.YZWXShuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[IsReadOnlyAttribute]
internal class SixLabors.ImageSharp.ZYXWShuffle4 : ValueType {
    public sealed virtual void ShuffleReduce(ReadOnlySpan`1& source, Span`1& dest);
    public sealed virtual void RunFallbackShuffle(ReadOnlySpan`1<byte> source, Span`1<byte> dest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class SixLabors.ThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowArgumentExceptionForNotNullOrWhitespace(string value, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeLessThan(T value, T max, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeLessThanOrEqualTo(T value, T maximum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeGreaterThan(T value, T minimum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeGreaterThanOrEqualTo(T value, T minimum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeBetweenOrEqualTo(T value, T minimum, T maximum, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeExceptionForMustBeSizedAtLeast(int minLength, string parameterName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message, string name);
    [DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string name, string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException(string name, string message);
}
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
