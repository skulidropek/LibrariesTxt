public enum SkiaSharp.GRBackend : Enum {
    public int value__;
    public static GRBackend OpenGL;
    public static GRBackend Vulkan;
}
public class SkiaSharp.GRBackendRenderTargetDesc : ValueType {
    private int width;
    private int height;
    private GRPixelConfig config;
    private GRSurfaceOrigin origin;
    private int sampleCount;
    private int stencilBits;
    private IntPtr renderTargetHandle;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int SampleCount { get; public set; }
    public int StencilBits { get; public set; }
    public IntPtr RenderTargetHandle { get; public set; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public GRPixelConfig get_Config();
    public void set_Config(GRPixelConfig value);
    public GRSurfaceOrigin get_Origin();
    public void set_Origin(GRSurfaceOrigin value);
    public int get_SampleCount();
    public void set_SampleCount(int value);
    public int get_StencilBits();
    public void set_StencilBits(int value);
    public IntPtr get_RenderTargetHandle();
    public void set_RenderTargetHandle(IntPtr value);
    public SKSizeI get_Size();
    public SKRectI get_Rect();
}
[FlagsAttribute]
public enum SkiaSharp.GRBackendState : Enum {
    public UInt32 value__;
    public static GRBackendState None;
    public static GRBackendState All;
}
public class SkiaSharp.GRBackendTextureDesc : ValueType {
    private GRBackendTextureDescFlags flags;
    private GRSurfaceOrigin origin;
    private int width;
    private int height;
    private GRPixelConfig config;
    private int sampleCount;
    private IntPtr textureHandle;
    public GRBackendTextureDescFlags Flags { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public int SampleCount { get; public set; }
    public IntPtr TextureHandle { get; public set; }
    public GRBackendTextureDescFlags get_Flags();
    public void set_Flags(GRBackendTextureDescFlags value);
    public GRSurfaceOrigin get_Origin();
    public void set_Origin(GRSurfaceOrigin value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public GRPixelConfig get_Config();
    public void set_Config(GRPixelConfig value);
    public int get_SampleCount();
    public void set_SampleCount(int value);
    public IntPtr get_TextureHandle();
    public void set_TextureHandle(IntPtr value);
}
[FlagsAttribute]
public enum SkiaSharp.GRBackendTextureDescFlags : Enum {
    public int value__;
    public static GRBackendTextureDescFlags None;
    public static GRBackendTextureDescFlags RenderTarget;
}
public class SkiaSharp.GRContext : SKObject {
    [PreserveAttribute]
internal GRContext(IntPtr h, bool owns);
    public static GRContext Create(GRBackend backend);
    public static GRContext Create(GRBackend backend, IntPtr backendContext);
    public static GRContext Create(GRBackend backend, GRGlInterface backendContext);
    public static GRContext Create(GRBackend backend, IntPtr backendContext, GRContextOptions options);
    public static GRContext Create(GRBackend backend, GRGlInterface backendContext, GRContextOptions options);
    public void AbandonContext(bool releaseResources);
    public void GetResourceCacheLimits(Int32& maxResources, Int64& maxResourceBytes);
    public void SetResourceCacheLimits(int maxResources, long maxResourceBytes);
    public void GetResourceCacheUsage(Int32& maxResources, Int64& maxResourceBytes);
    public void ResetContext(GRGlBackendState state);
    public void ResetContext(GRBackendState state);
    public void ResetContext(UInt32 state);
    public void Flush();
    public int GetRecommendedSampleCount(GRPixelConfig config, float dpi);
    protected virtual void Dispose(bool disposing);
}
public class SkiaSharp.GRContextOptions : ValueType {
    private byte fSuppressPrints;
    private int fMaxTextureSizeOverride;
    private int fMaxTileSizeOverride;
    private byte fSuppressDualSourceBlending;
    private int fBufferMapThreshold;
    private byte fUseDrawInsteadOfPartialRenderTargetWrite;
    private byte fImmediateMode;
    private byte fUseShaderSwizzling;
    private byte fDoManualMipmapping;
    private byte fEnableInstancedRendering;
    private byte fAllowPathMaskCaching;
    private byte fRequireDecodeDisableForSRGB;
    private byte fDisableGpuYUVConversion;
    private byte fSuppressPathRendering;
    private byte fWireframeMode;
    private GRContextOptionsGpuPathRenderers fGpuPathRenderers;
    private float fGlyphCacheTextureMaximumBytes;
    private byte fAvoidStencilBuffers;
    public bool SuppressPrints { get; public set; }
    public int MaxTextureSizeOverride { get; public set; }
    public int MaxTileSizeOverride { get; public set; }
    public bool SuppressDualSourceBlending { get; public set; }
    public int BufferMapThreshold { get; public set; }
    public bool UseDrawInsteadOfPartialRenderTargetWrite { get; public set; }
    public bool ImmediateMode { get; public set; }
    public bool UseShaderSwizzling { get; public set; }
    public bool DoManualMipmapping { get; public set; }
    public bool EnableInstancedRendering { get; public set; }
    public bool AllowPathMaskCaching { get; public set; }
    public bool RequireDecodeDisableForSrgb { get; public set; }
    public bool DisableGpuYuvConversion { get; public set; }
    public bool SuppressPathRendering { get; public set; }
    public bool WireframeMode { get; public set; }
    public GRContextOptionsGpuPathRenderers GpuPathRenderers { get; public set; }
    public float GlyphCacheTextureMaximumBytes { get; public set; }
    public bool AvoidStencilBuffers { get; public set; }
    public static GRContextOptions Default { get; }
    public bool get_SuppressPrints();
    public void set_SuppressPrints(bool value);
    public int get_MaxTextureSizeOverride();
    public void set_MaxTextureSizeOverride(int value);
    public int get_MaxTileSizeOverride();
    public void set_MaxTileSizeOverride(int value);
    public bool get_SuppressDualSourceBlending();
    public void set_SuppressDualSourceBlending(bool value);
    public int get_BufferMapThreshold();
    public void set_BufferMapThreshold(int value);
    public bool get_UseDrawInsteadOfPartialRenderTargetWrite();
    public void set_UseDrawInsteadOfPartialRenderTargetWrite(bool value);
    public bool get_ImmediateMode();
    public void set_ImmediateMode(bool value);
    public bool get_UseShaderSwizzling();
    public void set_UseShaderSwizzling(bool value);
    public bool get_DoManualMipmapping();
    public void set_DoManualMipmapping(bool value);
    public bool get_EnableInstancedRendering();
    public void set_EnableInstancedRendering(bool value);
    public bool get_AllowPathMaskCaching();
    public void set_AllowPathMaskCaching(bool value);
    public bool get_RequireDecodeDisableForSrgb();
    public void set_RequireDecodeDisableForSrgb(bool value);
    public bool get_DisableGpuYuvConversion();
    public void set_DisableGpuYuvConversion(bool value);
    public bool get_SuppressPathRendering();
    public void set_SuppressPathRendering(bool value);
    public bool get_WireframeMode();
    public void set_WireframeMode(bool value);
    public GRContextOptionsGpuPathRenderers get_GpuPathRenderers();
    public void set_GpuPathRenderers(GRContextOptionsGpuPathRenderers value);
    public float get_GlyphCacheTextureMaximumBytes();
    public void set_GlyphCacheTextureMaximumBytes(float value);
    public bool get_AvoidStencilBuffers();
    public void set_AvoidStencilBuffers(bool value);
    public static GRContextOptions get_Default();
}
public enum SkiaSharp.GRContextOptionsGpuPathRenderers : Enum {
    public int value__;
    public static GRContextOptionsGpuPathRenderers None;
    public static GRContextOptionsGpuPathRenderers DashLine;
    public static GRContextOptionsGpuPathRenderers StencilAndCover;
    public static GRContextOptionsGpuPathRenderers Msaa;
    public static GRContextOptionsGpuPathRenderers AaHairline;
    public static GRContextOptionsGpuPathRenderers AaConvex;
    public static GRContextOptionsGpuPathRenderers AaLinearizing;
    public static GRContextOptionsGpuPathRenderers Small;
    public static GRContextOptionsGpuPathRenderers Tessellating;
    public static GRContextOptionsGpuPathRenderers Default;
    public static GRContextOptionsGpuPathRenderers All;
}
[FlagsAttribute]
public enum SkiaSharp.GRGlBackendState : Enum {
    public UInt32 value__;
    public static GRGlBackendState None;
    public static GRGlBackendState RenderTarget;
    public static GRGlBackendState TextureBinding;
    public static GRGlBackendState View;
    public static GRGlBackendState Blend;
    public static GRGlBackendState MSAAEnable;
    public static GRGlBackendState Vertex;
    public static GRGlBackendState Stencil;
    public static GRGlBackendState PixelStore;
    public static GRGlBackendState Program;
    public static GRGlBackendState FixedFunction;
    public static GRGlBackendState Misc;
    public static GRGlBackendState PathRendering;
    public static GRGlBackendState All;
}
public class SkiaSharp.GRGlBackendTextureDesc : ValueType {
    [CompilerGeneratedAttribute]
private GRBackendTextureDescFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private GRSurfaceOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private GRPixelConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private GRGlTextureInfo <TextureHandle>k__BackingField;
    public GRBackendTextureDescFlags Flags { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public int SampleCount { get; public set; }
    public GRGlTextureInfo TextureHandle { get; public set; }
    [CompilerGeneratedAttribute]
public GRBackendTextureDescFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(GRBackendTextureDescFlags value);
    [CompilerGeneratedAttribute]
public GRSurfaceOrigin get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(GRSurfaceOrigin value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public GRPixelConfig get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(GRPixelConfig value);
    [CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public void set_SampleCount(int value);
    [CompilerGeneratedAttribute]
public GRGlTextureInfo get_TextureHandle();
    [CompilerGeneratedAttribute]
public void set_TextureHandle(GRGlTextureInfo value);
}
public class SkiaSharp.GRGlGetProcDelegate : MulticastDelegate {
    public GRGlGetProcDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(object context, string name);
    public virtual IAsyncResult BeginInvoke(object context, string name, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.GRGlGetProcDelegateInternal : MulticastDelegate {
    public GRGlGetProcDelegateInternal(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr context, string name);
    public virtual IAsyncResult BeginInvoke(IntPtr context, string name, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
public class SkiaSharp.GRGlInterface : SKObject {
    private static GRGlGetProcDelegateInternal getProcDelegateInternal;
    private static IntPtr getProcDelegate;
    private static GRGlInterface();
    [PreserveAttribute]
internal GRGlInterface(IntPtr h, bool owns);
    public static GRGlInterface CreateDefaultInterface();
    public static GRGlInterface CreateNativeGlInterface();
    public static GRGlInterface CreateNativeAngleInterface();
    public static GRGlInterface AssembleInterface(GRGlGetProcDelegate get);
    public static GRGlInterface AssembleInterface(object context, GRGlGetProcDelegate get);
    public static GRGlInterface AssembleAngleInterface(GRGlGetProcDelegate get);
    public static GRGlInterface AssembleAngleInterface(object context, GRGlGetProcDelegate get);
    public static GRGlInterface AssembleGlInterface(GRGlGetProcDelegate get);
    public static GRGlInterface AssembleGlInterface(object context, GRGlGetProcDelegate get);
    public static GRGlInterface AssembleGlesInterface(GRGlGetProcDelegate get);
    public static GRGlInterface AssembleGlesInterface(object context, GRGlGetProcDelegate get);
    public GRGlInterface Clone();
    public bool Validate();
    public bool HasExtension(string extension);
    protected virtual void Dispose(bool disposing);
    [MonoPInvokeCallbackAttribute("SkiaSharp.GRGlGetProcDelegateInternal")]
private static IntPtr GrGLGetProcInternal(IntPtr context, string name);
}
public class SkiaSharp.GRGlTextureInfo : ValueType {
    private UInt32 fTarget;
    private UInt32 fID;
    public UInt32 Target { get; public set; }
    public UInt32 Id { get; public set; }
    public UInt32 get_Target();
    public void set_Target(UInt32 value);
    public UInt32 get_Id();
    public void set_Id(UInt32 value);
}
public enum SkiaSharp.GRPixelConfig : Enum {
    public int value__;
    public static GRPixelConfig Unknown;
    public static GRPixelConfig Alpha8;
    public static GRPixelConfig Gray8;
    public static GRPixelConfig Rgb565;
    public static GRPixelConfig Rgba4444;
    public static GRPixelConfig Rgba8888;
    public static GRPixelConfig Bgra8888;
    public static GRPixelConfig Srgba8888;
    public static GRPixelConfig Sbgra8888;
    public static GRPixelConfig Rgba8888SInt;
    public static GRPixelConfig RgbaFloat;
    public static GRPixelConfig RgFloat;
    public static GRPixelConfig AlphaHalf;
    public static GRPixelConfig RgbaHalf;
}
public enum SkiaSharp.GRSurfaceOrigin : Enum {
    public int value__;
    public static GRSurfaceOrigin TopLeft;
    public static GRSurfaceOrigin BottomLeft;
}
[AttributeUsageAttribute("64")]
internal class SkiaSharp.MonoPInvokeCallbackAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public MonoPInvokeCallbackAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
internal class SkiaSharp.NativeDelegateContext : object {
    private static IDictionary`2<Guid, NativeDelegateContext> contexts;
    private Delegate managedDelegate;
    [CompilerGeneratedAttribute]
private object <ManagedContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <NativeContext>k__BackingField;
    public object ManagedContext { get; }
    public IntPtr NativeContext { get; }
    public NativeDelegateContext(object context, Delegate get);
    private static NativeDelegateContext();
    [CompilerGeneratedAttribute]
public object get_ManagedContext();
    [CompilerGeneratedAttribute]
public IntPtr get_NativeContext();
    public T GetDelegate();
    public IntPtr Wrap();
    public static NativeDelegateContext Unwrap(IntPtr ptr);
    public void Free();
    public static void Free(IntPtr ptr);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal static class SkiaSharp.PlatformConfiguration : object {
    [CompilerGeneratedAttribute]
private static bool <IsUnix>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsWindows>k__BackingField;
    public static bool IsUnix { get; }
    public static bool IsWindows { get; }
    private static PlatformConfiguration();
    [CompilerGeneratedAttribute]
public static bool get_IsUnix();
    [CompilerGeneratedAttribute]
public static bool get_IsWindows();
}
internal class SkiaSharp.PreserveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AllMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Conditional>k__BackingField;
    public bool AllMembers { get; public set; }
    public bool Conditional { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllMembers();
    [CompilerGeneratedAttribute]
public void set_AllMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_Conditional();
    [CompilerGeneratedAttribute]
public void set_Conditional(bool value);
}
public class SkiaSharp.SK3dView : SKObject {
    public SKMatrix Matrix { get; }
    [PreserveAttribute]
internal SK3dView(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public SKMatrix get_Matrix();
    public void GetMatrix(SKMatrix& matrix);
    public void Save();
    public void Restore();
    public void Translate(float x, float y, float z);
    public void TranslateX(float x);
    public void TranslateY(float y);
    public void TranslateZ(float z);
    public void RotateXDegrees(float degrees);
    public void RotateXRadians(float radians);
    public void RotateYDegrees(float degrees);
    public void RotateYRadians(float radians);
    public void RotateZDegrees(float degrees);
    public void RotateZRadians(float radians);
    public void ApplyToCanvas(SKCanvas canvas);
    public float DotWithNormal(float dx, float dy, float dz);
}
public abstract class SkiaSharp.SKAbstractManagedStream : SKStreamAsset {
    private static ConcurrentDictionary`2<IntPtr, SKAbstractManagedStream> managedStreams;
    private static read_delegate fRead;
    private static peek_delegate fPeek;
    private static isAtEnd_delegate fIsAtEnd;
    private static hasPosition_delegate fHasPosition;
    private static hasLength_delegate fHasLength;
    private static rewind_delegate fRewind;
    private static getPosition_delegate fGetPosition;
    private static seek_delegate fSeek;
    private static move_delegate fMove;
    private static getLength_delegate fGetLength;
    private static createNew_delegate fCreateNew;
    private static destroy_delegate fDestroy;
    private int fromNative;
    private static SKAbstractManagedStream();
    protected SKAbstractManagedStream(bool owns);
    private void DisposeFromNative();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected abstract virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected abstract virtual bool OnIsAtEnd();
    protected abstract virtual bool OnHasPosition();
    protected abstract virtual bool OnHasLength();
    protected abstract virtual bool OnRewind();
    protected abstract virtual IntPtr OnGetPosition();
    protected abstract virtual IntPtr OnGetLength();
    protected abstract virtual bool OnSeek(IntPtr position);
    protected abstract virtual bool OnMove(int offset);
    protected abstract virtual IntPtr OnCreateNew();
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/read_delegate")]
private static IntPtr ReadInternal(IntPtr managedStreamPtr, IntPtr buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/peek_delegate")]
private static IntPtr PeekInternal(IntPtr managedStreamPtr, IntPtr buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/isAtEnd_delegate")]
private static bool IsAtEndInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/hasPosition_delegate")]
private static bool HasPositionInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/hasLength_delegate")]
private static bool HasLengthInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/rewind_delegate")]
private static bool RewindInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/getPosition_delegate")]
private static IntPtr GetPositionInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/seek_delegate")]
private static bool SeekInternal(IntPtr managedStreamPtr, IntPtr position);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/move_delegate")]
private static bool MoveInternal(IntPtr managedStreamPtr, int offset);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/getLength_delegate")]
private static IntPtr GetLengthInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/createNew_delegate")]
private static IntPtr CreateNewInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedStream/destroy_delegate")]
private static void DestroyInternal(IntPtr managedStreamPtr);
    private static SKAbstractManagedStream AsManagedStream(IntPtr ptr);
    private static bool AsManagedStream(IntPtr ptr, SKAbstractManagedStream& target);
}
public abstract class SkiaSharp.SKAbstractManagedWStream : SKWStream {
    private static ConcurrentDictionary`2<IntPtr, SKAbstractManagedWStream> managedStreams;
    private static write_delegate fWrite;
    private static flush_delegate fFlush;
    private static bytesWritten_delegate fBytesWritten;
    private static destroy_delegate fDestroy;
    private int fromNative;
    private static SKAbstractManagedWStream();
    protected SKAbstractManagedWStream(bool owns);
    private void DisposeFromNative();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual bool OnWrite(IntPtr buffer, IntPtr size);
    protected abstract virtual void OnFlush();
    protected abstract virtual IntPtr OnBytesWritten();
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedWStream/write_delegate")]
private static bool WriteInternal(IntPtr managedStreamPtr, IntPtr buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedWStream/flush_delegate")]
private static void FlushInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedWStream/bytesWritten_delegate")]
private static IntPtr BytesWrittenInternal(IntPtr managedStreamPtr);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKAbstractManagedWStream/destroy_delegate")]
private static void DestroyInternal(IntPtr managedStreamPtr);
    private static SKAbstractManagedWStream AsManagedStream(IntPtr ptr);
    private static bool AsManagedStream(IntPtr ptr, SKAbstractManagedWStream& target);
}
public enum SkiaSharp.SKAlphaType : Enum {
    public int value__;
    public static SKAlphaType Unknown;
    public static SKAlphaType Opaque;
    public static SKAlphaType Premul;
    public static SKAlphaType Unpremul;
}
public class SkiaSharp.SKAutoCanvasRestore : object {
    private SKCanvas canvas;
    private int saveCount;
    public SKAutoCanvasRestore(SKCanvas canvas);
    public SKAutoCanvasRestore(SKCanvas canvas, bool doSave);
    public sealed virtual void Dispose();
    public void Restore();
}
public class SkiaSharp.SKAutoMaskFreeImage : object {
    private IntPtr image;
    public SKAutoMaskFreeImage(IntPtr maskImage);
    public sealed virtual void Dispose();
}
public class SkiaSharp.SKBitmap : SKObject {
    private static string UnsupportedColorTypeMessage;
    private static string UnableToAllocatePixelsMessage;
    private static SKBitmapReleaseDelegateInternal releaseDelegateInternal;
    private static IntPtr releaseDelegate;
    public bool ReadyToDraw { get; }
    public SKImageInfo Info { get; }
    public int Width { get; }
    public int Height { get; }
    public SKColorType ColorType { get; }
    public SKAlphaType AlphaType { get; }
    public SKColorSpace ColorSpace { get; }
    public int BytesPerPixel { get; }
    public int RowBytes { get; }
    public int ByteCount { get; }
    public Byte[] Bytes { get; }
    public SKColor[] Pixels { get; public set; }
    public bool IsEmpty { get; }
    public bool IsNull { get; }
    public bool DrawsNothing { get; }
    public bool IsImmutable { get; }
    public bool IsVolatile { get; public set; }
    public SKColorTable ColorTable { get; }
    private static SKBitmap();
    [PreserveAttribute]
internal SKBitmap(IntPtr handle, bool owns);
    public SKBitmap(int width, int height, bool isOpaque);
    public SKBitmap(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    public SKBitmap(SKImageInfo info);
    public SKBitmap(SKImageInfo info, int rowBytes);
    public SKBitmap(SKImageInfo info, SKColorTable ctable, SKBitmapAllocFlags flags);
    public SKBitmap(SKImageInfo info, SKColorTable ctable);
    private bool TryAllocPixels(SKImageInfo info, SKColorTable ctable, SKBitmapAllocFlags flags);
    protected virtual void Dispose(bool disposing);
    public void Reset();
    public void SetImmutable();
    public void Erase(SKColor color);
    public void Erase(SKColor color, SKRectI rect);
    public byte GetAddr8(int x, int y);
    public ushort GetAddr16(int x, int y);
    public UInt32 GetAddr32(int x, int y);
    public IntPtr GetAddr(int x, int y);
    public SKPMColor GetIndex8Color(int x, int y);
    public SKColor GetPixel(int x, int y);
    public void SetPixel(int x, int y, SKColor color);
    public bool CanCopyTo(SKColorType colorType);
    public SKBitmap Copy();
    public SKBitmap Copy(SKColorType colorType);
    public bool CopyTo(SKBitmap destination);
    public bool CopyTo(SKBitmap destination, SKColorType colorType);
    public bool ExtractSubset(SKBitmap destination, SKRectI subset);
    public bool ExtractAlpha(SKBitmap destination);
    public bool ExtractAlpha(SKBitmap destination, SKPointI& offset);
    public bool ExtractAlpha(SKBitmap destination, SKPaint paint);
    public bool ExtractAlpha(SKBitmap destination, SKPaint paint, SKPointI& offset);
    public bool get_ReadyToDraw();
    public SKImageInfo get_Info();
    public int get_Width();
    public int get_Height();
    public SKColorType get_ColorType();
    public SKAlphaType get_AlphaType();
    public SKColorSpace get_ColorSpace();
    public int get_BytesPerPixel();
    public int get_RowBytes();
    public int get_ByteCount();
    public IntPtr GetPixels();
    public IntPtr GetPixels(IntPtr& length);
    public void SetPixels(IntPtr pixels);
    public void SetPixels(IntPtr pixels, SKColorTable ct);
    public void SetColorTable(SKColorTable ct);
    public Byte[] get_Bytes();
    public SKColor[] get_Pixels();
    public void set_Pixels(SKColor[] value);
    public bool get_IsEmpty();
    public bool get_IsNull();
    public bool get_DrawsNothing();
    public bool get_IsImmutable();
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public SKColorTable get_ColorTable();
    public static SKImageInfo DecodeBounds(Stream stream);
    public static SKImageInfo DecodeBounds(SKStream stream);
    public static SKImageInfo DecodeBounds(SKData data);
    public static SKImageInfo DecodeBounds(string filename);
    public static SKImageInfo DecodeBounds(Byte[] buffer);
    public static SKBitmap Decode(SKCodec codec, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(SKCodec codec);
    public static SKBitmap Decode(Stream stream);
    public static SKBitmap Decode(Stream stream, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(SKStream stream);
    public static SKBitmap Decode(SKStream stream, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(SKData data);
    public static SKBitmap Decode(SKData data, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(string filename);
    public static SKBitmap Decode(string filename, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(Byte[] buffer);
    public static SKBitmap Decode(Byte[] buffer, SKImageInfo bitmapInfo);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable, SKBitmapReleaseDelegate releaseProc, object context);
    public bool InstallPixels(SKPixmap pixmap);
    public bool InstallMaskPixels(SKMask mask);
    public void NotifyPixelsChanged();
    public SKPixmap PeekPixels();
    public bool PeekPixels(SKPixmap pixmap);
    public SKBitmap Resize(SKImageInfo info, SKBitmapResizeMethod method);
    public bool Resize(SKBitmap dst, SKBitmapResizeMethod method);
    public static bool Resize(SKBitmap dst, SKBitmap src, SKBitmapResizeMethod method);
    public static SKBitmap FromImage(SKImage image);
    public bool Encode(SKWStream dst, SKEncodedImageFormat format, int quality);
    private static SKStream WrapManagedStream(Stream stream);
    private static SKStream OpenStream(string path);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKBitmapReleaseDelegateInternal")]
private static void SKBitmapReleaseInternal(IntPtr address, IntPtr context);
}
[FlagsAttribute]
public enum SkiaSharp.SKBitmapAllocFlags : Enum {
    public UInt32 value__;
    public static SKBitmapAllocFlags None;
    public static SKBitmapAllocFlags ZeroPixels;
}
public class SkiaSharp.SKBitmapReleaseDelegate : MulticastDelegate {
    public SKBitmapReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKBitmapReleaseDelegateInternal : MulticastDelegate {
    public SKBitmapReleaseDelegateInternal(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, IntPtr context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, IntPtr context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum SkiaSharp.SKBitmapResizeMethod : Enum {
    public int value__;
    public static SKBitmapResizeMethod Box;
    public static SKBitmapResizeMethod Triangle;
    public static SKBitmapResizeMethod Lanczos3;
    public static SKBitmapResizeMethod Hamming;
    public static SKBitmapResizeMethod Mitchell;
}
public enum SkiaSharp.SKBlendMode : Enum {
    public int value__;
    public static SKBlendMode Clear;
    public static SKBlendMode Src;
    public static SKBlendMode Dst;
    public static SKBlendMode SrcOver;
    public static SKBlendMode DstOver;
    public static SKBlendMode SrcIn;
    public static SKBlendMode DstIn;
    public static SKBlendMode SrcOut;
    public static SKBlendMode DstOut;
    public static SKBlendMode SrcATop;
    public static SKBlendMode DstATop;
    public static SKBlendMode Xor;
    public static SKBlendMode Plus;
    public static SKBlendMode Modulate;
    public static SKBlendMode Screen;
    public static SKBlendMode Overlay;
    public static SKBlendMode Darken;
    public static SKBlendMode Lighten;
    public static SKBlendMode ColorDodge;
    public static SKBlendMode ColorBurn;
    public static SKBlendMode HardLight;
    public static SKBlendMode SoftLight;
    public static SKBlendMode Difference;
    public static SKBlendMode Exclusion;
    public static SKBlendMode Multiply;
    public static SKBlendMode Hue;
    public static SKBlendMode Saturation;
    public static SKBlendMode Color;
    public static SKBlendMode Luminosity;
}
[FlagsAttribute]
public enum SkiaSharp.SKBlurMaskFilterFlags : Enum {
    public int value__;
    public static SKBlurMaskFilterFlags None;
    public static SKBlurMaskFilterFlags IgnoreTransform;
    public static SKBlurMaskFilterFlags HighQuality;
    public static SKBlurMaskFilterFlags All;
}
public enum SkiaSharp.SKBlurStyle : Enum {
    public int value__;
    public static SKBlurStyle Normal;
    public static SKBlurStyle Solid;
    public static SKBlurStyle Outer;
    public static SKBlurStyle Inner;
}
public class SkiaSharp.SKCanvas : SKObject {
    public SKRect LocalClipBounds { get; }
    public SKRectI DeviceClipBounds { get; }
    public SKMatrix TotalMatrix { get; }
    public int SaveCount { get; }
    [PreserveAttribute]
internal SKCanvas(IntPtr handle, bool owns);
    public SKCanvas(SKBitmap bitmap);
    protected virtual void Dispose(bool disposing);
    public bool QuickReject(SKRect rect);
    public bool QuickReject(SKPath path);
    public int Save();
    public int SaveLayer(SKRect limit, SKPaint paint);
    public int SaveLayer(SKPaint paint);
    public void DrawColor(SKColor color, SKBlendMode mode);
    public void DrawLine(SKPoint p0, SKPoint p1, SKPaint paint);
    public void DrawLine(float x0, float y0, float x1, float y1, SKPaint paint);
    public void Clear();
    public void Clear(SKColor color);
    public void Restore();
    public void RestoreToCount(int count);
    public void Translate(float dx, float dy);
    public void Translate(SKPoint point);
    public void Scale(float s);
    public void Scale(float sx, float sy);
    public void Scale(SKPoint size);
    public void Scale(float sx, float sy, float px, float py);
    public void RotateDegrees(float degrees);
    public void RotateRadians(float radians);
    public void RotateDegrees(float degrees, float px, float py);
    public void RotateRadians(float radians, float px, float py);
    public void Skew(float sx, float sy);
    public void Skew(SKPoint skew);
    public void Concat(SKMatrix& m);
    public void ClipRect(SKRect rect, SKClipOperation operation, bool antialias);
    public void ClipPath(SKPath path, SKClipOperation operation, bool antialias);
    public void ClipRegion(SKRegion region, SKClipOperation operation);
    public SKRect get_LocalClipBounds();
    public SKRectI get_DeviceClipBounds();
    public bool GetLocalClipBounds(SKRect& bounds);
    public bool GetDeviceClipBounds(SKRectI& bounds);
    public void DrawPaint(SKPaint paint);
    public void DrawRegion(SKRegion region, SKPaint paint);
    public void DrawRect(float x, float y, float w, float h, SKPaint paint);
    public void DrawRect(SKRect rect, SKPaint paint);
    public void DrawRoundRect(float x, float y, float w, float h, float rx, float ry, SKPaint paint);
    public void DrawRoundRect(SKRect rect, float rx, float ry, SKPaint paint);
    public void DrawRoundRect(SKRect rect, SKSize r, SKPaint paint);
    public void DrawOval(float cx, float cy, float rx, float ry, SKPaint paint);
    public void DrawOval(SKPoint c, SKSize r, SKPaint paint);
    public void DrawOval(SKRect rect, SKPaint paint);
    public void DrawCircle(float cx, float cy, float radius, SKPaint paint);
    public void DrawCircle(SKPoint c, float radius, SKPaint paint);
    public void DrawPath(SKPath path, SKPaint paint);
    public void DrawPoints(SKPointMode mode, SKPoint[] points, SKPaint paint);
    public void DrawPoint(SKPoint p, SKPaint paint);
    public void DrawPoint(float x, float y, SKPaint paint);
    public void DrawPoint(SKPoint p, SKColor color);
    public void DrawPoint(float x, float y, SKColor color);
    public void DrawImage(SKImage image, SKPoint p, SKPaint paint);
    public void DrawImage(SKImage image, float x, float y, SKPaint paint);
    public void DrawImage(SKImage image, SKRect dest, SKPaint paint);
    public void DrawImage(SKImage image, SKRect source, SKRect dest, SKPaint paint);
    public void DrawPicture(SKPicture picture, float x, float y, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKPoint p, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKMatrix& matrix, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, SKPoint p, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, float x, float y, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, SKRect dest, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, SKRect source, SKRect dest, SKPaint paint);
    public void DrawSurface(SKSurface surface, SKPoint p, SKPaint paint);
    public void DrawSurface(SKSurface surface, float x, float y, SKPaint paint);
    public void DrawText(string text, SKPoint p, SKPaint paint);
    public void DrawText(string text, float x, float y, SKPaint paint);
    public void DrawText(Byte[] text, SKPoint p, SKPaint paint);
    public void DrawText(Byte[] text, float x, float y, SKPaint paint);
    public void DrawPositionedText(string text, SKPoint[] points, SKPaint paint);
    public void DrawPositionedText(Byte[] text, SKPoint[] points, SKPaint paint);
    public void DrawTextOnPath(IntPtr buffer, int length, SKPath path, SKPoint offset, SKPaint paint);
    public void DrawTextOnPath(IntPtr buffer, int length, SKPath path, float hOffset, float vOffset, SKPaint paint);
    public void DrawText(IntPtr buffer, int length, SKPoint p, SKPaint paint);
    public void DrawText(IntPtr buffer, int length, float x, float y, SKPaint paint);
    public void DrawPositionedText(IntPtr buffer, int length, SKPoint[] points, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, SKPoint offset, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, float hOffset, float vOffset, SKPaint paint);
    public void DrawTextOnPath(Byte[] text, SKPath path, SKPoint offset, SKPaint paint);
    public void DrawTextOnPath(Byte[] text, SKPath path, float hOffset, float vOffset, SKPaint paint);
    public void Flush();
    public void DrawAnnotation(SKRect rect, string key, SKData value);
    public void DrawUrlAnnotation(SKRect rect, SKData value);
    public SKData DrawUrlAnnotation(SKRect rect, string value);
    public void DrawNamedDestinationAnnotation(SKPoint point, SKData value);
    public SKData DrawNamedDestinationAnnotation(SKPoint point, string value);
    public void DrawLinkDestinationAnnotation(SKRect rect, SKData value);
    public SKData DrawLinkDestinationAnnotation(SKRect rect, string value);
    public void DrawBitmapNinePatch(SKBitmap bitmap, SKRectI center, SKRect dst, SKPaint paint);
    public void DrawImageNinePatch(SKImage image, SKRectI center, SKRect dst, SKPaint paint);
    public void DrawBitmapLattice(SKBitmap bitmap, Int32[] xDivs, Int32[] yDivs, SKRect dst, SKPaint paint);
    public void DrawImageLattice(SKImage image, Int32[] xDivs, Int32[] yDivs, SKRect dst, SKPaint paint);
    public void DrawBitmapLattice(SKBitmap bitmap, SKLattice lattice, SKRect dst, SKPaint paint);
    public void DrawImageLattice(SKImage image, SKLattice lattice, SKRect dst, SKPaint paint);
    public void ResetMatrix();
    public void SetMatrix(SKMatrix matrix);
    public SKMatrix get_TotalMatrix();
    public int get_SaveCount();
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKColor[] colors, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, UInt16[] indices, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKBlendMode mode, UInt16[] indices, SKPaint paint);
    public void DrawVertices(SKVertices vertices, SKBlendMode mode, SKPaint paint);
}
public enum SkiaSharp.SKClipOperation : Enum {
    public int value__;
    public static SKClipOperation Difference;
    public static SKClipOperation Intersect;
}
public class SkiaSharp.SKCodec : SKObject {
    public static int MinBufferedBytesNeeded { get; }
    public SKImageInfo Info { get; }
    public SKEncodedInfo EncodedInfo { get; }
    public SKCodecOrigin Origin { get; }
    public SKEncodedImageFormat EncodedFormat { get; }
    public Byte[] Pixels { get; }
    public int RepetitionCount { get; }
    public int FrameCount { get; }
    public SKCodecFrameInfo[] FrameInfo { get; }
    public SKCodecScanlineOrder ScanlineOrder { get; }
    public int NextScanline { get; }
    [PreserveAttribute]
internal SKCodec(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static int get_MinBufferedBytesNeeded();
    public SKImageInfo get_Info();
    public SKEncodedInfo get_EncodedInfo();
    public SKCodecOrigin get_Origin();
    public SKEncodedImageFormat get_EncodedFormat();
    public SKSizeI GetScaledDimensions(float desiredScale);
    public bool GetValidSubset(SKRectI& desiredSubset);
    public Byte[] get_Pixels();
    public int get_RepetitionCount();
    public int get_FrameCount();
    public SKCodecFrameInfo[] get_FrameInfo();
    public SKCodecResult GetPixels(Byte[]& pixels);
    public SKCodecResult GetPixels(SKImageInfo info, Byte[]& pixels);
    public SKCodecResult GetPixels(SKImageInfo info, Byte[] pixels);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, IntPtr colorTable, Int32& colorTableCount);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult IncrementalDecode(Int32& rowsDecoded);
    public SKCodecResult IncrementalDecode();
    public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options);
    public SKCodecResult StartScanlineDecode(SKImageInfo info);
    public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public int GetScanlines(IntPtr dst, int countLines, int rowBytes);
    public bool SkipScanlines(int countLines);
    public SKCodecScanlineOrder get_ScanlineOrder();
    public int get_NextScanline();
    public int GetOutputScanline(int inputScanline);
    public static SKCodec Create(SKStream stream);
    public static SKCodec Create(SKData data);
}
public class SkiaSharp.SKCodecFrameInfo : ValueType {
    private int requiredFrame;
    private int duration;
    private byte fullyRecieved;
    private SKAlphaType alphaType;
    public int RequiredFrame { get; public set; }
    public int Duration { get; public set; }
    public bool FullyRecieved { get; public set; }
    public SKAlphaType AlphaType { get; public set; }
    public int get_RequiredFrame();
    public void set_RequiredFrame(int value);
    public int get_Duration();
    public void set_Duration(int value);
    public bool get_FullyRecieved();
    public void set_FullyRecieved(bool value);
    public SKAlphaType get_AlphaType();
    public void set_AlphaType(SKAlphaType value);
}
public class SkiaSharp.SKCodecOptions : ValueType {
    public static SKCodecOptions Default;
    [CompilerGeneratedAttribute]
private SKZeroInitialized <ZeroInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SKRectI> <Subset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrameIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPriorFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private SKTransferFunctionBehavior <PremulBehavior>k__BackingField;
    public SKZeroInitialized ZeroInitialized { get; public set; }
    public Nullable`1<SKRectI> Subset { get; public set; }
    public bool HasSubset { get; }
    public int FrameIndex { get; public set; }
    public bool HasPriorFrame { get; public set; }
    public SKTransferFunctionBehavior PremulBehavior { get; public set; }
    private static SKCodecOptions();
    public SKCodecOptions(SKZeroInitialized zeroInitialized);
    public SKCodecOptions(SKZeroInitialized zeroInitialized, SKRectI subset);
    public SKCodecOptions(SKRectI subset);
    public SKCodecOptions(int frameIndex, bool hasPriorFrame);
    [CompilerGeneratedAttribute]
public SKZeroInitialized get_ZeroInitialized();
    [CompilerGeneratedAttribute]
public void set_ZeroInitialized(SKZeroInitialized value);
    [CompilerGeneratedAttribute]
public Nullable`1<SKRectI> get_Subset();
    [CompilerGeneratedAttribute]
public void set_Subset(Nullable`1<SKRectI> value);
    public bool get_HasSubset();
    [CompilerGeneratedAttribute]
public int get_FrameIndex();
    [CompilerGeneratedAttribute]
public void set_FrameIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_HasPriorFrame();
    [CompilerGeneratedAttribute]
public void set_HasPriorFrame(bool value);
    [CompilerGeneratedAttribute]
public SKTransferFunctionBehavior get_PremulBehavior();
    [CompilerGeneratedAttribute]
public void set_PremulBehavior(SKTransferFunctionBehavior value);
}
internal class SkiaSharp.SKCodecOptionsInternal : ValueType {
    public SKZeroInitialized fZeroInitialized;
    public SKRectI* fSubset;
    public int fFrameIndex;
    public byte fHasPriorFrame;
    public SKTransferFunctionBehavior fPremulBehavior;
    public static SKCodecOptionsInternal FromManaged(SKCodecOptions& managed);
}
public enum SkiaSharp.SKCodecOrigin : Enum {
    public int value__;
    public static SKCodecOrigin TopLeft;
    public static SKCodecOrigin TopRight;
    public static SKCodecOrigin BottomRight;
    public static SKCodecOrigin BottomLeft;
    public static SKCodecOrigin LeftTop;
    public static SKCodecOrigin RightTop;
    public static SKCodecOrigin RightBottom;
    public static SKCodecOrigin LeftBottom;
}
public enum SkiaSharp.SKCodecResult : Enum {
    public int value__;
    public static SKCodecResult Success;
    public static SKCodecResult IncompleteInput;
    public static SKCodecResult InvalidConversion;
    public static SKCodecResult InvalidScale;
    public static SKCodecResult InvalidParameters;
    public static SKCodecResult InvalidInput;
    public static SKCodecResult CouldNotRewind;
    public static SKCodecResult Unimplemented;
}
public enum SkiaSharp.SKCodecScanlineOrder : Enum {
    public int value__;
    public static SKCodecScanlineOrder TopDown;
    public static SKCodecScanlineOrder BottomUp;
}
public class SkiaSharp.SKColor : ValueType {
    private static float EPSILON;
    public static SKColor Empty;
    private UInt32 color;
    public byte Alpha { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public float Hue { get; }
    public SKColor(UInt32 value);
    public SKColor(byte red, byte green, byte blue, byte alpha);
    public SKColor(byte red, byte green, byte blue);
    public SKColor WithRed(byte red);
    public SKColor WithGreen(byte green);
    public SKColor WithBlue(byte blue);
    public SKColor WithAlpha(byte alpha);
    public byte get_Alpha();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public float get_Hue();
    public static SKColor FromHsl(float h, float s, float l, byte a);
    private static float HueToRgb(float v1, float v2, float vH);
    public static SKColor FromHsv(float h, float s, float v, byte a);
    public void ToHsl(Single& h, Single& s, Single& l);
    public void ToHsv(Single& h, Single& s, Single& v);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static SKColor op_Implicit(UInt32 color);
    public static UInt32 op_Explicit(SKColor color);
    public static bool op_Equality(SKColor left, SKColor right);
    public static bool op_Inequality(SKColor left, SKColor right);
    public static SKColor Parse(string hexString);
    public static bool TryParse(string hexString, SKColor& color);
}
public class SkiaSharp.SKColorFilter : SKObject {
    public static int ColorMatrixSize;
    [PreserveAttribute]
internal SKColorFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKColorFilter CreateBlendMode(SKColor c, SKBlendMode mode);
    public static SKColorFilter CreateLighting(SKColor mul, SKColor add);
    public static SKColorFilter CreateCompose(SKColorFilter outer, SKColorFilter inner);
    public static SKColorFilter CreateColorMatrix(Single[] matrix);
    public static SKColorFilter CreateLumaColor();
    public static SKColorFilter CreateTable(Byte[] table);
    public static SKColorFilter CreateTable(Byte[] tableA, Byte[] tableR, Byte[] tableG, Byte[] tableB);
    public static SKColorFilter CreateHighContrast(SKHighContrastConfig config);
    public static SKColorFilter CreateHighContrast(bool grayscale, SKHighContrastConfigInvertStyle invertStyle, float contrast);
}
public class SkiaSharp.SKColors : ValueType {
    public static SKColor AliceBlue;
    public static SKColor AntiqueWhite;
    public static SKColor Aqua;
    public static SKColor Aquamarine;
    public static SKColor Azure;
    public static SKColor Beige;
    public static SKColor Bisque;
    public static SKColor Black;
    public static SKColor BlanchedAlmond;
    public static SKColor Blue;
    public static SKColor BlueViolet;
    public static SKColor Brown;
    public static SKColor BurlyWood;
    public static SKColor CadetBlue;
    public static SKColor Chartreuse;
    public static SKColor Chocolate;
    public static SKColor Coral;
    public static SKColor CornflowerBlue;
    public static SKColor Cornsilk;
    public static SKColor Crimson;
    public static SKColor Cyan;
    public static SKColor DarkBlue;
    public static SKColor DarkCyan;
    public static SKColor DarkGoldenrod;
    public static SKColor DarkGray;
    public static SKColor DarkGreen;
    public static SKColor DarkKhaki;
    public static SKColor DarkMagenta;
    public static SKColor DarkOliveGreen;
    public static SKColor DarkOrange;
    public static SKColor DarkOrchid;
    public static SKColor DarkRed;
    public static SKColor DarkSalmon;
    public static SKColor DarkSeaGreen;
    public static SKColor DarkSlateBlue;
    public static SKColor DarkSlateGray;
    public static SKColor DarkTurquoise;
    public static SKColor DarkViolet;
    public static SKColor DeepPink;
    public static SKColor DeepSkyBlue;
    public static SKColor DimGray;
    public static SKColor DodgerBlue;
    public static SKColor Firebrick;
    public static SKColor FloralWhite;
    public static SKColor ForestGreen;
    public static SKColor Fuchsia;
    public static SKColor Gainsboro;
    public static SKColor GhostWhite;
    public static SKColor Gold;
    public static SKColor Goldenrod;
    public static SKColor Gray;
    public static SKColor Green;
    public static SKColor GreenYellow;
    public static SKColor Honeydew;
    public static SKColor HotPink;
    public static SKColor IndianRed;
    public static SKColor Indigo;
    public static SKColor Ivory;
    public static SKColor Khaki;
    public static SKColor Lavender;
    public static SKColor LavenderBlush;
    public static SKColor LawnGreen;
    public static SKColor LemonChiffon;
    public static SKColor LightBlue;
    public static SKColor LightCoral;
    public static SKColor LightCyan;
    public static SKColor LightGoldenrodYellow;
    public static SKColor LightGray;
    public static SKColor LightGreen;
    public static SKColor LightPink;
    public static SKColor LightSalmon;
    public static SKColor LightSeaGreen;
    public static SKColor LightSkyBlue;
    public static SKColor LightSlateGray;
    public static SKColor LightSteelBlue;
    public static SKColor LightYellow;
    public static SKColor Lime;
    public static SKColor LimeGreen;
    public static SKColor Linen;
    public static SKColor Magenta;
    public static SKColor Maroon;
    public static SKColor MediumAquamarine;
    public static SKColor MediumBlue;
    public static SKColor MediumOrchid;
    public static SKColor MediumPurple;
    public static SKColor MediumSeaGreen;
    public static SKColor MediumSlateBlue;
    public static SKColor MediumSpringGreen;
    public static SKColor MediumTurquoise;
    public static SKColor MediumVioletRed;
    public static SKColor MidnightBlue;
    public static SKColor MintCream;
    public static SKColor MistyRose;
    public static SKColor Moccasin;
    public static SKColor NavajoWhite;
    public static SKColor Navy;
    public static SKColor OldLace;
    public static SKColor Olive;
    public static SKColor OliveDrab;
    public static SKColor Orange;
    public static SKColor OrangeRed;
    public static SKColor Orchid;
    public static SKColor PaleGoldenrod;
    public static SKColor PaleGreen;
    public static SKColor PaleTurquoise;
    public static SKColor PaleVioletRed;
    public static SKColor PapayaWhip;
    public static SKColor PeachPuff;
    public static SKColor Peru;
    public static SKColor Pink;
    public static SKColor Plum;
    public static SKColor PowderBlue;
    public static SKColor Purple;
    public static SKColor Red;
    public static SKColor RosyBrown;
    public static SKColor RoyalBlue;
    public static SKColor SaddleBrown;
    public static SKColor Salmon;
    public static SKColor SandyBrown;
    public static SKColor SeaGreen;
    public static SKColor SeaShell;
    public static SKColor Sienna;
    public static SKColor Silver;
    public static SKColor SkyBlue;
    public static SKColor SlateBlue;
    public static SKColor SlateGray;
    public static SKColor Snow;
    public static SKColor SpringGreen;
    public static SKColor SteelBlue;
    public static SKColor Tan;
    public static SKColor Teal;
    public static SKColor Thistle;
    public static SKColor Tomato;
    public static SKColor Turquoise;
    public static SKColor Violet;
    public static SKColor Wheat;
    public static SKColor White;
    public static SKColor WhiteSmoke;
    public static SKColor Yellow;
    public static SKColor YellowGreen;
    public static SKColor Transparent;
    public static SKColor Empty { get; }
    private static SKColors();
    public static SKColor get_Empty();
}
public class SkiaSharp.SKColorSpace : SKObject {
    public bool GammaIsCloseToSrgb { get; }
    public bool GammaIsLinear { get; }
    public bool IsSrgb { get; }
    [PreserveAttribute]
internal SKColorSpace(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public bool get_GammaIsCloseToSrgb();
    public bool get_GammaIsLinear();
    public bool get_IsSrgb();
    public static bool Equal(SKColorSpace left, SKColorSpace right);
    public static SKColorSpace CreateSrgb();
    public static SKColorSpace CreateSrgbLinear();
    public static SKColorSpace CreateIcc(IntPtr input, long length);
    public static SKColorSpace CreateIcc(Byte[] input, long length);
    public static SKColorSpace CreateIcc(Byte[] input);
    public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKMatrix44 toXyzD50, SKColorSpaceFlags flags);
    public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKMatrix44 toXyzD50, SKColorSpaceFlags flags);
    public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    public bool ToXyzD50(SKMatrix44 toXyzD50);
    public SKMatrix44 ToXyzD50();
}
[FlagsAttribute]
public enum SkiaSharp.SKColorSpaceFlags : Enum {
    public int value__;
    public static SKColorSpaceFlags None;
    public static SKColorSpaceFlags NonLinearBlending;
}
public enum SkiaSharp.SKColorSpaceGamut : Enum {
    public int value__;
    public static SKColorSpaceGamut Srgb;
    public static SKColorSpaceGamut AdobeRgb;
    public static SKColorSpaceGamut Dcip3D65;
    public static SKColorSpaceGamut Rec2020;
}
public class SkiaSharp.SKColorSpacePrimaries : ValueType {
    private float fRX;
    private float fRY;
    private float fGX;
    private float fGY;
    private float fBX;
    private float fBY;
    private float fWX;
    private float fWY;
    public float RX { get; public set; }
    public float RY { get; public set; }
    public float GX { get; public set; }
    public float GY { get; public set; }
    public float BX { get; public set; }
    public float BY { get; public set; }
    public float WX { get; public set; }
    public float WY { get; public set; }
    public SKColorSpacePrimaries(float rx, float ry, float gx, float gy, float bx, float by, float wx, float wy);
    public float get_RX();
    public void set_RX(float value);
    public float get_RY();
    public void set_RY(float value);
    public float get_GX();
    public void set_GX(float value);
    public float get_GY();
    public void set_GY(float value);
    public float get_BX();
    public void set_BX(float value);
    public float get_BY();
    public void set_BY(float value);
    public float get_WX();
    public void set_WX(float value);
    public float get_WY();
    public void set_WY(float value);
    public bool ToXyzD50(SKMatrix44 toXyzD50);
    public SKMatrix44 ToXyzD50();
}
public enum SkiaSharp.SKColorSpaceRenderTargetGamma : Enum {
    public int value__;
    public static SKColorSpaceRenderTargetGamma Linear;
    public static SKColorSpaceRenderTargetGamma Srgb;
}
public class SkiaSharp.SKColorSpaceTransferFn : ValueType {
    private float fG;
    private float fA;
    private float fB;
    private float fC;
    private float fD;
    private float fE;
    private float fF;
    public float G { get; public set; }
    public float A { get; public set; }
    public float B { get; public set; }
    public float C { get; public set; }
    public float D { get; public set; }
    public float E { get; public set; }
    public float F { get; public set; }
    public SKColorSpaceTransferFn(float g, float a, float b, float c, float d, float e, float f);
    public float get_G();
    public void set_G(float value);
    public float get_A();
    public void set_A(float value);
    public float get_B();
    public void set_B(float value);
    public float get_C();
    public void set_C(float value);
    public float get_D();
    public void set_D(float value);
    public float get_E();
    public void set_E(float value);
    public float get_F();
    public void set_F(float value);
    public SKColorSpaceTransferFn Invert();
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKColorTable : SKObject {
    public static int MaxLength;
    public int Count { get; }
    public SKPMColor[] Colors { get; }
    public SKColor[] UnPreMultipledColors { get; }
    public SKPMColor Item { get; }
    [PreserveAttribute]
internal SKColorTable(IntPtr x, bool owns);
    public SKColorTable(int count);
    public SKColorTable(SKColor[] colors);
    public SKColorTable(SKColor[] colors, int count);
    public SKColorTable(SKPMColor[] colors);
    public SKColorTable(SKPMColor[] colors, int count);
    protected virtual void Dispose(bool disposing);
    public int get_Count();
    public SKPMColor[] get_Colors();
    public SKColor[] get_UnPreMultipledColors();
    public SKPMColor get_Item(int index);
    public SKColor GetUnPreMultipliedColor(int index);
    public IntPtr ReadColors();
}
public enum SkiaSharp.SKColorType : Enum {
    public int value__;
    public static SKColorType Unknown;
    public static SKColorType Alpha8;
    public static SKColorType Rgb565;
    public static SKColorType Argb4444;
    public static SKColorType Rgba8888;
    public static SKColorType Bgra8888;
    public static SKColorType Index8;
    public static SKColorType Gray8;
    public static SKColorType RgbaF16;
}
[FlagsAttribute]
public enum SkiaSharp.SKCropRectFlags : Enum {
    public int value__;
    public static SKCropRectFlags HasNone;
    public static SKCropRectFlags HasLeft;
    public static SKCropRectFlags HasTop;
    public static SKCropRectFlags HasWidth;
    public static SKCropRectFlags HasHeight;
    public static SKCropRectFlags HasAll;
}
public class SkiaSharp.SKData : SKObject {
    private static int CopyBufferSize;
    private static Lazy`1<SKData> empty;
    private static SKDataReleaseDelegateInternal releaseDelegateInternal;
    private static IntPtr releaseDelegate;
    public static SKData Empty { get; }
    public bool IsEmpty { get; }
    public long Size { get; }
    public IntPtr Data { get; }
    private static SKData();
    [PreserveAttribute]
internal SKData(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKData get_Empty();
    public static SKData CreateCopy(IntPtr bytes, ulong length);
    public static SKData CreateCopy(Byte[] bytes);
    public static SKData CreateCopy(Byte[] bytes, ulong length);
    public static SKData Create(int size);
    public static SKData Create(ulong size);
    public static SKData Create(string filename);
    public static SKData Create(Stream stream);
    public static SKData Create(Stream stream, int length);
    public static SKData Create(Stream stream, ulong length);
    public static SKData Create(Stream stream, long length);
    public static SKData Create(SKStream stream);
    public static SKData Create(SKStream stream, int length);
    public static SKData Create(SKStream stream, ulong length);
    public static SKData Create(SKStream stream, long length);
    public static SKData Create(IntPtr address, int length);
    public static SKData Create(IntPtr address, int length, SKDataReleaseDelegate releaseProc);
    public static SKData Create(IntPtr address, int length, SKDataReleaseDelegate releaseProc, object context);
    internal static SKData FromCString(string str);
    public SKData Subset(ulong offset, ulong length);
    public Byte[] ToArray();
    public bool get_IsEmpty();
    public long get_Size();
    public IntPtr get_Data();
    public Stream AsStream();
    public Stream AsStream(bool streamDisposesData);
    public void SaveTo(Stream target);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKDataReleaseDelegateInternal")]
private static void ReleaseInternal(IntPtr address, IntPtr context);
}
public class SkiaSharp.SKDataReleaseDelegate : MulticastDelegate {
    public SKDataReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKDataReleaseDelegateInternal : MulticastDelegate {
    public SKDataReleaseDelegateInternal(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, IntPtr context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, IntPtr context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum SkiaSharp.SKDisplacementMapEffectChannelSelectorType : Enum {
    public int value__;
    public static SKDisplacementMapEffectChannelSelectorType Unknown;
    public static SKDisplacementMapEffectChannelSelectorType R;
    public static SKDisplacementMapEffectChannelSelectorType G;
    public static SKDisplacementMapEffectChannelSelectorType B;
    public static SKDisplacementMapEffectChannelSelectorType A;
}
public class SkiaSharp.SKDocument : SKObject {
    public static float DefaultRasterDpi;
    [PreserveAttribute]
internal SKDocument(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public void Abort();
    public SKCanvas BeginPage(float width, float height);
    public SKCanvas BeginPage(float width, float height, SKRect content);
    public void EndPage();
    public void Close();
    [ObsoleteAttribute("Use CreateXps(SKWStream, float) instead.")]
public static SKDocument CreateXps(string path, float dpi);
    public static SKDocument CreateXps(SKWStream stream, float dpi);
    [ObsoleteAttribute("Use CreatePdf(SKWStream, float) instead.")]
public static SKDocument CreatePdf(string path, float dpi);
    public static SKDocument CreatePdf(SKWStream stream, float dpi);
    public static SKDocument CreatePdf(SKWStream stream, SKDocumentPdfMetadata metadata, float dpi);
}
public class SkiaSharp.SKDocumentPdfMetadata : ValueType {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Producer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Creation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Modified>k__BackingField;
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; public set; }
    public Nullable`1<DateTime> Creation { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(string value);
    [CompilerGeneratedAttribute]
public string get_Creator();
    [CompilerGeneratedAttribute]
public void set_Creator(string value);
    [CompilerGeneratedAttribute]
public string get_Producer();
    [CompilerGeneratedAttribute]
public void set_Producer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Creation();
    [CompilerGeneratedAttribute]
public void set_Creation(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Modified();
    [CompilerGeneratedAttribute]
public void set_Modified(Nullable`1<DateTime> value);
}
internal class SkiaSharp.SKDocumentPdfMetadataInternal : ValueType {
    public IntPtr Title;
    public IntPtr Author;
    public IntPtr Subject;
    public IntPtr Keywords;
    public IntPtr Creator;
    public IntPtr Producer;
    public SKTimeDateTimeInternal* Creation;
    public SKTimeDateTimeInternal* Modified;
}
public enum SkiaSharp.SKDropShadowImageFilterShadowMode : Enum {
    public int value__;
    public static SKDropShadowImageFilterShadowMode DrawShadowAndForeground;
    public static SKDropShadowImageFilterShadowMode DrawShadowOnly;
}
public class SkiaSharp.SKDynamicMemoryWStream : SKWStream {
    [PreserveAttribute]
internal SKDynamicMemoryWStream(IntPtr handle, bool owns);
    public SKData CopyToData();
    public SKStreamAsset DetachAsStream();
    public SKData DetachAsData();
    public void CopyTo(IntPtr data);
    public bool CopyTo(SKWStream dst);
    protected virtual void Dispose(bool disposing);
}
public enum SkiaSharp.SKEncodedImageFormat : Enum {
    public int value__;
    public static SKEncodedImageFormat Bmp;
    public static SKEncodedImageFormat Gif;
    public static SKEncodedImageFormat Ico;
    public static SKEncodedImageFormat Jpeg;
    public static SKEncodedImageFormat Png;
    public static SKEncodedImageFormat Wbmp;
    public static SKEncodedImageFormat Webp;
    public static SKEncodedImageFormat Pkm;
    public static SKEncodedImageFormat Ktx;
    public static SKEncodedImageFormat Astc;
    public static SKEncodedImageFormat Dng;
}
public class SkiaSharp.SKEncodedInfo : ValueType {
    private SKEncodedInfoColor color;
    private SKEncodedInfoAlpha alpha;
    private byte bitsPerComponent;
    public SKEncodedInfoColor Color { get; }
    public SKEncodedInfoAlpha Alpha { get; }
    public byte BitsPerComponent { get; }
    public byte BitsPerPixel { get; }
    public SKEncodedInfo(SKEncodedInfoColor color);
    public SKEncodedInfo(SKEncodedInfoColor color, SKEncodedInfoAlpha alpha, byte bitsPerComponent);
    public SKEncodedInfoColor get_Color();
    public SKEncodedInfoAlpha get_Alpha();
    public byte get_BitsPerComponent();
    public byte get_BitsPerPixel();
}
public enum SkiaSharp.SKEncodedInfoAlpha : Enum {
    public int value__;
    public static SKEncodedInfoAlpha Opaque;
    public static SKEncodedInfoAlpha Unpremul;
    public static SKEncodedInfoAlpha Binary;
}
public enum SkiaSharp.SKEncodedInfoColor : Enum {
    public int value__;
    public static SKEncodedInfoColor Gray;
    public static SKEncodedInfoColor GrayAlpha;
    public static SKEncodedInfoColor Palette;
    public static SKEncodedInfoColor Rgb;
    public static SKEncodedInfoColor Rgba;
    public static SKEncodedInfoColor Bgr;
    public static SKEncodedInfoColor Bgrx;
    public static SKEncodedInfoColor Bgra;
    public static SKEncodedInfoColor Yuv;
    public static SKEncodedInfoColor Yuva;
    public static SKEncodedInfoColor InvertedCmyk;
    public static SKEncodedInfoColor Ycck;
}
public enum SkiaSharp.SKEncoding : Enum {
    public int value__;
    public static SKEncoding Utf8;
    public static SKEncoding Utf16;
    public static SKEncoding Utf32;
}
public class SkiaSharp.SKFileStream : SKStreamAsset {
    [PreserveAttribute]
internal SKFileStream(IntPtr handle, bool owns);
    public SKFileStream(string path);
    protected virtual void Dispose(bool disposing);
    public static bool IsPathSupported(string path);
    public static SKStreamAsset OpenStream(string path);
}
public class SkiaSharp.SKFileWStream : SKWStream {
    [PreserveAttribute]
internal SKFileWStream(IntPtr handle, bool owns);
    public SKFileWStream(string path);
    protected virtual void Dispose(bool disposing);
    public static bool IsPathSupported(string path);
    public static SKWStream OpenStream(string path);
}
public enum SkiaSharp.SKFilterQuality : Enum {
    public int value__;
    public static SKFilterQuality None;
    public static SKFilterQuality Low;
    public static SKFilterQuality Medium;
    public static SKFilterQuality High;
}
public class SkiaSharp.SKFontManager : SKObject {
    public static SKFontManager Default { get; }
    public int FontFamilyCount { get; }
    [PreserveAttribute]
internal SKFontManager(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKFontManager get_Default();
    public int get_FontFamilyCount();
    public string GetFamilyName(int index);
    public String[] GetFontFamilies();
    public SKTypeface MatchCharacter(char character);
    public SKTypeface MatchCharacter(int character);
    public SKTypeface MatchCharacter(string familyName, char character);
    public SKTypeface MatchCharacter(string familyName, int character);
    public SKTypeface MatchCharacter(string familyName, String[] bcp47, char character);
    public SKTypeface MatchCharacter(string familyName, String[] bcp47, int character);
    public SKTypeface MatchCharacter(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant, String[] bcp47, char character);
    public SKTypeface MatchCharacter(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant, String[] bcp47, int character);
    public SKTypeface MatchCharacter(string familyName, int weight, int width, SKFontStyleSlant slant, String[] bcp47, int character);
}
public class SkiaSharp.SKFontMetrics : ValueType {
    private UInt32 flags;
    private float top;
    private float ascent;
    private float descent;
    private float bottom;
    private float leading;
    private float avgCharWidth;
    private float maxCharWidth;
    private float xMin;
    private float xMax;
    private float xHeight;
    private float capHeight;
    private float underlineThickness;
    private float underlinePosition;
    private static UInt32 flagsUnderlineThicknessIsValid;
    private static UInt32 flagsUnderlinePositionIsValid;
    public float Top { get; }
    public float Ascent { get; }
    public float Descent { get; }
    public float Bottom { get; }
    public float Leading { get; }
    public float AverageCharacterWidth { get; }
    public float MaxCharacterWidth { get; }
    public float XMin { get; }
    public float XMax { get; }
    public float XHeight { get; }
    public float CapHeight { get; }
    public Nullable`1<float> UnderlineThickness { get; }
    public Nullable`1<float> UnderlinePosition { get; }
    public float get_Top();
    public float get_Ascent();
    public float get_Descent();
    public float get_Bottom();
    public float get_Leading();
    public float get_AverageCharacterWidth();
    public float get_MaxCharacterWidth();
    public float get_XMin();
    public float get_XMax();
    public float get_XHeight();
    public float get_CapHeight();
    public Nullable`1<float> get_UnderlineThickness();
    public Nullable`1<float> get_UnderlinePosition();
}
public enum SkiaSharp.SKFontStyleSlant : Enum {
    public int value__;
    public static SKFontStyleSlant Upright;
    public static SKFontStyleSlant Italic;
    public static SKFontStyleSlant Oblique;
}
public enum SkiaSharp.SKFontStyleWeight : Enum {
    public int value__;
    public static SKFontStyleWeight Invisible;
    public static SKFontStyleWeight Thin;
    public static SKFontStyleWeight ExtraLight;
    public static SKFontStyleWeight Light;
    public static SKFontStyleWeight Normal;
    public static SKFontStyleWeight Medium;
    public static SKFontStyleWeight SemiBold;
    public static SKFontStyleWeight Bold;
    public static SKFontStyleWeight ExtraBold;
    public static SKFontStyleWeight Black;
    public static SKFontStyleWeight ExtraBlack;
}
public enum SkiaSharp.SKFontStyleWidth : Enum {
    public int value__;
    public static SKFontStyleWidth UltraCondensed;
    public static SKFontStyleWidth ExtraCondensed;
    public static SKFontStyleWidth Condensed;
    public static SKFontStyleWidth SemiCondensed;
    public static SKFontStyleWidth Normal;
    public static SKFontStyleWidth SemiExpanded;
    public static SKFontStyleWidth Expanded;
    public static SKFontStyleWidth ExtraExpanded;
    public static SKFontStyleWidth UltraExpanded;
}
public class SkiaSharp.SKFrontBufferedManagedStream : SKAbstractManagedStream {
    private SKStream stream;
    private bool disposeStream;
    private bool hasLength;
    private int streamLength;
    private int bufferLength;
    private Byte[] frontBuffer;
    private int bufferedSoFar;
    private int offset;
    public SKFrontBufferedManagedStream(Stream managedStream, int bufferSize);
    public SKFrontBufferedManagedStream(Stream managedStream, int bufferSize, bool disposeUnderlyingStream);
    public SKFrontBufferedManagedStream(SKStream nativeStream, int bufferSize);
    public SKFrontBufferedManagedStream(SKStream nativeStream, int bufferSize, bool disposeUnderlyingStream);
    protected virtual void Dispose(bool disposing);
    protected virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected virtual bool OnIsAtEnd();
    protected virtual bool OnRewind();
    protected virtual bool OnHasLength();
    protected virtual IntPtr OnGetLength();
    protected virtual bool OnHasPosition();
    protected virtual IntPtr OnGetPosition();
    protected virtual bool OnSeek(IntPtr position);
    protected virtual bool OnMove(int offset);
    protected virtual IntPtr OnCreateNew();
}
public class SkiaSharp.SKFrontBufferedStream : Stream {
    public static int DefaultBufferSize;
    private long totalBufferSize;
    private long totalLength;
    private bool disposeStream;
    private Stream underlyingStream;
    private long currentOffset;
    private long bufferedSoFar;
    private Byte[] internalBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SKFrontBufferedStream(Stream stream);
    public SKFrontBufferedStream(Stream stream, long bufferSize);
    public SKFrontBufferedStream(Stream stream, bool disposeUnderlyingStream);
    public SKFrontBufferedStream(Stream stream, long bufferSize, bool disposeUnderlyingStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int ReadFromBuffer(Byte[] dst, int offset, int size);
    private int BufferAndWriteTo(Byte[] dst, int offset, int size);
    private int ReadDirectlyFromStream(Byte[] dst, int offset, int size);
    protected virtual void Dispose(bool disposing);
}
public class SkiaSharp.SKHighContrastConfig : ValueType {
    private byte fGrayscale;
    private SKHighContrastConfigInvertStyle fInvertStyle;
    private float fContrast;
    public static SKHighContrastConfig Default;
    public bool Grayscale { get; public set; }
    public SKHighContrastConfigInvertStyle InvertStyle { get; public set; }
    public float Contrast { get; public set; }
    public bool IsValid { get; }
    private static SKHighContrastConfig();
    public SKHighContrastConfig(bool grayscale, SKHighContrastConfigInvertStyle invertStyle, float contrast);
    public bool get_Grayscale();
    public void set_Grayscale(bool value);
    public SKHighContrastConfigInvertStyle get_InvertStyle();
    public void set_InvertStyle(SKHighContrastConfigInvertStyle value);
    public float get_Contrast();
    public void set_Contrast(float value);
    public bool get_IsValid();
}
public enum SkiaSharp.SKHighContrastConfigInvertStyle : Enum {
    public int value__;
    public static SKHighContrastConfigInvertStyle NoInvert;
    public static SKHighContrastConfigInvertStyle InvertBrightness;
    public static SKHighContrastConfigInvertStyle InvertLightness;
}
internal static class SkiaSharp.SkiaApi : object {
    private static string SKIA;
    public static void sk_colorspace_unref(IntPtr cColorSpace);
    public static bool sk_colorspace_gamma_close_to_srgb(IntPtr cColorSpace);
    public static bool sk_colorspace_gamma_is_linear(IntPtr cColorSpace);
    public static bool sk_colorspace_is_srgb(IntPtr cColorSpace);
    public static bool sk_colorspace_equals(IntPtr src, IntPtr dst);
    public static IntPtr sk_colorspace_new_srgb();
    public static IntPtr sk_colorspace_new_srgb_linear();
    public static IntPtr sk_colorspace_new_icc(IntPtr input, IntPtr len);
    public static IntPtr sk_colorspace_new_icc(Byte[] input, IntPtr len);
    public static IntPtr sk_colorspace_new_rgb_with_gamma(SKColorSpaceRenderTargetGamma gamma, IntPtr toXYZD50, SKColorSpaceFlags flags);
    public static IntPtr sk_colorspace_new_rgb_with_gamma_and_gamut(SKColorSpaceRenderTargetGamma gamma, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    public static IntPtr sk_colorspace_new_rgb_with_coeffs(SKColorSpaceTransferFn& coeffs, IntPtr toXYZD50, SKColorSpaceFlags flags);
    public static IntPtr sk_colorspace_new_rgb_with_coeffs_and_gamut(SKColorSpaceTransferFn& coeffs, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    public static bool sk_colorspace_to_xyzd50(IntPtr cColorSpace, IntPtr toXYZD50);
    public static bool sk_colorspaceprimaries_to_xyzd50(SKColorSpacePrimaries& primaries, IntPtr toXYZD50);
    public static void sk_colorspace_transfer_fn_invert(SKColorSpaceTransferFn& transfer, SKColorSpaceTransferFn& inverted);
    public static SKColorType sk_colortype_get_default_8888();
    public static void sk_pixelserializer_unref(IntPtr cserializer);
    public static bool sk_pixelserializer_use_encoded_data(IntPtr cserializer, IntPtr data, IntPtr len);
    public static IntPtr sk_pixelserializer_encode(IntPtr cserializer, IntPtr cpixmap);
    public static IntPtr sk_managedpixelserializer_new();
    public static void sk_managedpixelserializer_set_delegates(IntPtr pUse, IntPtr pEncode);
    public static void sk_surface_unref(IntPtr t);
    public static IntPtr sk_surface_new_raster(SKImageInfoNative& info, SKSurfaceProps& pros);
    public static IntPtr sk_surface_new_raster(SKImageInfoNative& info, IntPtr propsZero);
    public static IntPtr sk_surface_new_raster_direct(SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, SKSurfaceProps& props);
    public static IntPtr sk_surface_new_raster_direct(SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, IntPtr propsZero);
    public static IntPtr sk_surface_get_canvas(IntPtr t);
    public static IntPtr sk_surface_new_image_snapshot(IntPtr t);
    public static IntPtr sk_surface_new_backend_render_target(IntPtr context, GRBackendRenderTargetDesc& desc, SKSurfaceProps& props);
    public static IntPtr sk_surface_new_backend_render_target(IntPtr context, GRBackendRenderTargetDesc& desc, IntPtr propsZero);
    public static IntPtr sk_surface_new_backend_texture(IntPtr context, GRBackendTextureDesc& desc, SKSurfaceProps& props);
    public static IntPtr sk_surface_new_backend_texture(IntPtr context, GRBackendTextureDesc& desc, IntPtr propsZero);
    public static IntPtr sk_surface_new_backend_texture_as_render_target(IntPtr context, GRBackendTextureDesc& desc, SKSurfaceProps& props);
    public static IntPtr sk_surface_new_backend_texture_as_render_target(IntPtr context, GRBackendTextureDesc& desc, IntPtr propsZero);
    public static IntPtr sk_surface_new_render_target(IntPtr context, bool budgeted, SKImageInfoNative& info, int sampleCount, SKSurfaceProps& props);
    public static IntPtr sk_surface_new_render_target(IntPtr context, bool budgeted, SKImageInfoNative& info, int sampleCount, IntPtr propsZero);
    public static void sk_surface_draw(IntPtr surface, IntPtr canvas, float x, float y, IntPtr paint);
    public static bool sk_surface_peek_pixels(IntPtr surface, IntPtr pixmap);
    public static bool sk_surface_read_pixels(IntPtr surface, SKImageInfoNative& dstInfo, IntPtr dstPixels, IntPtr dstRowBytes, int srcX, int srcY);
    public static void sk_surface_get_props(IntPtr surface, SKSurfaceProps& props);
    public static int sk_canvas_save(IntPtr t);
    public static int sk_canvas_save_layer(IntPtr t, SKRect& rect, IntPtr paint);
    public static int sk_canvas_save_layer(IntPtr t, IntPtr rectZero, IntPtr paint);
    public static void sk_canvas_restore(IntPtr t);
    public static int sk_canvas_get_save_count(IntPtr t);
    public static void sk_canvas_restore_to_count(IntPtr t, int saveCount);
    public static void sk_canvas_translate(IntPtr t, float dx, float dy);
    public static void sk_canvas_scale(IntPtr t, float sx, float sy);
    public static void sk_canvas_rotate_degrees(IntPtr t, float degrees);
    public static void sk_canvas_rotate_radians(IntPtr t, float radians);
    public static void sk_canvas_skew(IntPtr t, float sx, float sy);
    public static void sk_canvas_concat(IntPtr t, SKMatrix& m);
    public static bool sk_canvas_quick_reject(IntPtr t, SKRect& rect);
    public static void sk_canvas_clip_rect(IntPtr t, SKRect& rect);
    public static void sk_canvas_clip_path(IntPtr t, IntPtr p);
    public static void sk_canvas_draw_paint(IntPtr t, IntPtr p);
    public static void sk_canvas_draw_region(IntPtr t, IntPtr region, IntPtr paint);
    public static void sk_canvas_draw_rect(IntPtr t, SKRect& rect, IntPtr paint);
    public static void sk_canvas_draw_round_rect(IntPtr t, SKRect& rect, float rx, float ry, IntPtr paint);
    public static void sk_canvas_draw_oval(IntPtr t, SKRect& rect, IntPtr paint);
    public static void sk_canvas_draw_circle(IntPtr t, float cx, float cy, float radius, IntPtr paint);
    public static void sk_canvas_draw_path(IntPtr t, IntPtr path, IntPtr paint);
    public static void sk_canvas_draw_image(IntPtr t, IntPtr image, float x, float y, IntPtr paint);
    public static void sk_canvas_draw_image_rect(IntPtr t, IntPtr image, SKRect& src, SKRect& dest, IntPtr paint);
    public static void sk_canvas_draw_image_rect(IntPtr t, IntPtr image, IntPtr srcZero, SKRect& dest, IntPtr paint);
    public static void sk_canvas_draw_picture(IntPtr t, IntPtr pict, SKMatrix& mat, IntPtr paint);
    public static void sk_canvas_draw_picture(IntPtr t, IntPtr pict, IntPtr matZero, IntPtr paint);
    public static void sk_canvas_draw_color(IntPtr t, SKColor color, SKBlendMode mode);
    public static void sk_canvas_draw_points(IntPtr t, SKPointMode mode, IntPtr count, SKPoint[] points, IntPtr paint);
    public static void sk_canvas_draw_point(IntPtr t, float x, float y, IntPtr paint);
    public static void sk_canvas_draw_line(IntPtr t, float x0, float y0, float x1, float y1, IntPtr paint);
    public static void sk_canvas_draw_text(IntPtr t, Byte[] text, int len, float x, float y, IntPtr paint);
    public static void sk_canvas_draw_pos_text(IntPtr t, Byte[] text, int len, SKPoint[] points, IntPtr paint);
    public static void sk_canvas_draw_text_on_path(IntPtr t, Byte[] text, int len, IntPtr path, float hOffset, float vOffset, IntPtr paint);
    public static void sk_canvas_draw_text(IntPtr t, IntPtr text, int len, float x, float y, IntPtr paint);
    public static void sk_canvas_draw_pos_text(IntPtr t, IntPtr text, int len, SKPoint[] points, IntPtr paint);
    public static void sk_canvas_draw_text_on_path(IntPtr t, IntPtr text, int len, IntPtr path, float hOffset, float vOffset, IntPtr paint);
    public static void sk_canvas_draw_bitmap(IntPtr t, IntPtr bitmap, float x, float y, IntPtr paint);
    public static void sk_canvas_draw_bitmap_rect(IntPtr t, IntPtr bitmap, SKRect& src, SKRect& dest, IntPtr paint);
    public static void sk_canvas_draw_bitmap_rect(IntPtr t, IntPtr bitmap, IntPtr srcZero, SKRect& dest, IntPtr paint);
    public static void sk_canvas_reset_matrix(IntPtr canvas);
    public static void sk_canvas_set_matrix(IntPtr canvas, SKMatrix& matrix);
    public static void sk_canvas_get_total_matrix(IntPtr canvas, SKMatrix& matrix);
    public static void sk_canvas_draw_annotation(IntPtr t, SKRect& rect, Byte[] key, IntPtr value);
    public static void sk_canvas_draw_url_annotation(IntPtr t, SKRect& rect, IntPtr value);
    public static void sk_canvas_draw_named_destination_annotation(IntPtr t, SKPoint& point, IntPtr value);
    public static void sk_canvas_draw_link_destination_annotation(IntPtr t, SKRect& rect, IntPtr value);
    public static void sk_canvas_clip_rect_with_operation(IntPtr t, SKRect& crect, SKClipOperation op, bool doAA);
    public static void sk_canvas_clip_path_with_operation(IntPtr t, IntPtr cpath, SKClipOperation op, bool doAA);
    public static void sk_canvas_clip_region(IntPtr t, IntPtr region, SKClipOperation op);
    public static bool sk_canvas_get_device_clip_bounds(IntPtr t, SKRectI& cbounds);
    public static bool sk_canvas_get_local_clip_bounds(IntPtr t, SKRect& cbounds);
    public static IntPtr sk_canvas_new_from_bitmap(IntPtr bitmap);
    public static void sk_canvas_flush(IntPtr canvas);
    public static void sk_canvas_draw_bitmap_lattice(IntPtr t, IntPtr bitmap, SKLatticeInternal& lattice, SKRect& dst, IntPtr paint);
    public static void sk_canvas_draw_image_lattice(IntPtr t, IntPtr image, SKLatticeInternal& lattice, SKRect& dst, IntPtr paint);
    public static void sk_canvas_draw_bitmap_nine(IntPtr t, IntPtr bitmap, SKRectI& center, SKRect& dst, IntPtr paint);
    public static void sk_canvas_draw_image_nine(IntPtr t, IntPtr image, SKRectI& center, SKRect& dst, IntPtr paint);
    public static void sk_canvas_destroy(IntPtr canvas);
    public static void sk_canvas_draw_vertices(IntPtr canvas, IntPtr vertices, SKBlendMode mode, IntPtr paint);
    public static IntPtr sk_paint_new();
    public static void sk_paint_delete(IntPtr t);
    public static bool sk_paint_is_antialias(IntPtr t);
    public static void sk_paint_set_antialias(IntPtr t, bool v);
    public static bool sk_paint_is_dither(IntPtr t);
    public static void sk_paint_set_dither(IntPtr t, bool v);
    public static bool sk_paint_is_verticaltext(IntPtr t);
    public static void sk_paint_set_verticaltext(IntPtr t, bool v);
    public static UInt32 sk_paint_get_color(IntPtr t);
    public static void sk_paint_set_color(IntPtr t, SKColor color);
    public static SKPaintStyle sk_paint_get_style(IntPtr t);
    public static void sk_paint_set_style(IntPtr t, SKPaintStyle style);
    public static float sk_paint_get_stroke_width(IntPtr paint);
    public static void sk_paint_set_stroke_width(IntPtr t, float width);
    public static float sk_paint_get_stroke_miter(IntPtr t);
    public static void sk_paint_set_stroke_miter(IntPtr t, float miter);
    public static SKStrokeCap sk_paint_get_stroke_cap(IntPtr t);
    public static void sk_paint_set_stroke_cap(IntPtr t, SKStrokeCap cap);
    public static SKStrokeJoin sk_paint_get_stroke_join(IntPtr t);
    public static void sk_paint_set_stroke_join(IntPtr t, SKStrokeJoin join);
    public static void sk_paint_set_shader(IntPtr t, IntPtr shader);
    public static IntPtr sk_paint_get_shader(IntPtr t);
    public static void sk_paint_set_maskfilter(IntPtr t, IntPtr filter);
    public static IntPtr sk_paint_get_maskfilter(IntPtr t);
    public static void sk_paint_set_colorfilter(IntPtr t, IntPtr filter);
    public static IntPtr sk_paint_get_colorfilter(IntPtr t);
    public static void sk_paint_set_imagefilter(IntPtr t, IntPtr filter);
    public static IntPtr sk_paint_get_imagefilter(IntPtr t);
    public static void sk_paint_set_blendmode(IntPtr t, SKBlendMode mode);
    public static SKBlendMode sk_paint_get_blendmode(IntPtr t);
    public static void sk_paint_set_filter_quality(IntPtr t, SKFilterQuality filterQuality);
    public static SKFilterQuality sk_paint_get_filter_quality(IntPtr t);
    public static IntPtr sk_paint_get_typeface(IntPtr t);
    public static void sk_paint_set_typeface(IntPtr t, IntPtr typeface);
    public static float sk_paint_get_textsize(IntPtr t);
    public static void sk_paint_set_textsize(IntPtr t, float size);
    public static SKTextAlign sk_paint_get_text_align(IntPtr t);
    public static void sk_paint_set_text_align(IntPtr t, SKTextAlign align);
    public static SKTextEncoding sk_paint_get_text_encoding(IntPtr t);
    public static void sk_paint_set_text_encoding(IntPtr t, SKTextEncoding encoding);
    public static float sk_paint_get_text_scale_x(IntPtr t);
    public static void sk_paint_set_text_scale_x(IntPtr t, float scale);
    public static float sk_paint_get_text_skew_x(IntPtr t);
    public static void sk_paint_set_text_skew_x(IntPtr t, float skew);
    public static float sk_paint_measure_text(IntPtr t, Byte[] text, IntPtr length, SKRect& bounds);
    public static float sk_paint_measure_text(IntPtr t, Byte[] text, IntPtr length, IntPtr boundsZero);
    public static float sk_paint_measure_text(IntPtr t, IntPtr text, IntPtr length, SKRect& bounds);
    public static float sk_paint_measure_text(IntPtr t, IntPtr text, IntPtr length, IntPtr boundsZero);
    public static IntPtr sk_paint_break_text(IntPtr t, IntPtr text, IntPtr length, float maxWidth, Single& measuredWidth);
    public static IntPtr sk_paint_break_text(IntPtr t, Byte[] text, IntPtr length, float maxWidth, Single& measuredWidth);
    public static IntPtr sk_paint_get_text_path(IntPtr t, IntPtr text, IntPtr length, float x, float y);
    public static IntPtr sk_paint_get_text_path(IntPtr t, Byte[] text, IntPtr length, float x, float y);
    public static IntPtr sk_paint_get_pos_text_path(IntPtr t, IntPtr text, IntPtr length, SKPoint[] points);
    public static IntPtr sk_paint_get_pos_text_path(IntPtr t, Byte[] text, IntPtr length, SKPoint[] points);
    public static float sk_paint_get_fontmetrics(IntPtr t, SKFontMetrics& fontMetrics, float scale);
    public static float sk_paint_get_fontmetrics(IntPtr t, IntPtr fontMetricsZero, float scale);
    public static IntPtr sk_paint_get_path_effect(IntPtr cpaint);
    public static void sk_paint_set_path_effect(IntPtr cpaint, IntPtr effect);
    public static bool sk_paint_is_linear_text(IntPtr cpaint);
    public static void sk_paint_set_linear_text(IntPtr cpaint, bool linearText);
    public static bool sk_paint_is_subpixel_text(IntPtr cpaint);
    public static void sk_paint_set_subpixel_text(IntPtr cpaint, bool subpixelText);
    public static bool sk_paint_is_lcd_render_text(IntPtr cpaint);
    public static void sk_paint_set_lcd_render_text(IntPtr cpaint, bool lcdText);
    public static bool sk_paint_is_embedded_bitmap_text(IntPtr cpaint);
    public static void sk_paint_set_embedded_bitmap_text(IntPtr cpaint, bool useEmbeddedBitmapText);
    public static bool sk_paint_is_autohinted(IntPtr cpaint);
    public static void sk_paint_set_autohinted(IntPtr cpaint, bool useAutohinter);
    public static SKPaintHinting sk_paint_get_hinting(IntPtr cpaint);
    public static void sk_paint_set_hinting(IntPtr cpaint, SKPaintHinting hintingLevel);
    public static bool sk_paint_is_fake_bold_text(IntPtr cpaint);
    public static void sk_paint_set_fake_bold_text(IntPtr cpaint, bool fakeBoldText);
    public static bool sk_paint_is_dev_kern_text(IntPtr cpaint);
    public static void sk_paint_set_dev_kern_text(IntPtr cpaint, bool devKernText);
    public static bool sk_paint_get_fill_path(IntPtr paint, IntPtr src, IntPtr dst, SKRect& cullRect, float resScale);
    public static bool sk_paint_get_fill_path(IntPtr paint, IntPtr src, IntPtr dst, IntPtr cullRectZero, float resScale);
    public static IntPtr sk_paint_clone(IntPtr cpaint);
    public static void sk_image_ref(IntPtr image);
    public static void sk_image_unref(IntPtr image);
    public static IntPtr sk_image_new_raster_copy(SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes);
    public static IntPtr sk_image_new_raster_copy_with_pixmap(IntPtr pixmap);
    public static IntPtr sk_image_new_raster_copy_with_colortable(SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, IntPtr ctable);
    public static IntPtr sk_image_new_raster_data(SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes);
    public static IntPtr sk_image_new_raster(IntPtr pixmap, IntPtr releaseProc, IntPtr context);
    public static IntPtr sk_image_new_from_bitmap(IntPtr cbitmap);
    public static IntPtr sk_image_new_from_encoded(IntPtr encoded, SKRectI& subset);
    public static IntPtr sk_image_new_from_encoded(IntPtr encoded, IntPtr subsetZero);
    public static IntPtr sk_image_new_from_texture(IntPtr context, GRBackendTextureDesc& desc, SKAlphaType alpha, IntPtr colorSpace, IntPtr releaseProc, IntPtr releaseContext);
    public static IntPtr sk_image_new_from_adopted_texture(IntPtr context, GRBackendTextureDesc& desc, SKAlphaType alpha, IntPtr colorSpace);
    public static IntPtr sk_image_new_from_picture(IntPtr picture, SKSizeI& dimensions, SKMatrix& matrix, IntPtr paint);
    public static IntPtr sk_image_new_from_picture(IntPtr picture, SKSizeI& dimensions, IntPtr matrixZero, IntPtr paint);
    public static int sk_image_get_width(IntPtr image);
    public static int sk_image_get_height(IntPtr image);
    public static UInt32 sk_image_get_unique_id(IntPtr image);
    public static SKAlphaType sk_image_get_alpha_type(IntPtr image);
    public static bool sk_image_is_alpha_only(IntPtr image);
    public static IntPtr sk_image_make_shader(IntPtr image, SKShaderTileMode tileX, SKShaderTileMode tileY, SKMatrix& localMatrix);
    public static IntPtr sk_image_make_shader(IntPtr image, SKShaderTileMode tileX, SKShaderTileMode tileY, IntPtr localMatrixZero);
    public static bool sk_image_peek_pixels(IntPtr image, IntPtr pixmap);
    public static bool sk_image_is_texture_backed(IntPtr image);
    public static bool sk_image_is_lazy_generated(IntPtr image);
    public static bool sk_image_read_pixels(IntPtr image, SKImageInfoNative& dstInfo, IntPtr dstPixels, IntPtr dstRowBytes, int srcX, int srcY, SKImageCachingHint cachingHint);
    public static bool sk_image_read_pixels_into_pixmap(IntPtr image, IntPtr dst, int srcX, int srcY, SKImageCachingHint cachingHint);
    public static bool sk_image_scale_pixels(IntPtr image, IntPtr dst, SKFilterQuality quality, SKImageCachingHint cachingHint);
    public static IntPtr sk_image_encode(IntPtr image);
    public static IntPtr sk_image_encode_with_serializer(IntPtr image, IntPtr serializer);
    public static IntPtr sk_image_encode_specific(IntPtr image, SKEncodedImageFormat encoder, int quality);
    public static IntPtr sk_image_make_subset(IntPtr image, SKRectI& subset);
    public static IntPtr sk_image_make_non_texture_image(IntPtr image);
    public static IntPtr sk_image_make_with_filter(IntPtr image, IntPtr filter, SKRectI& subset, SKRectI& clipbounds, SKRectI& outSubset, SKPoint& outOffset);
    public static bool sk_path_contains(IntPtr cpath, float x, float y);
    public static bool sk_path_get_last_point(IntPtr cpath, SKPoint& point);
    public static IntPtr sk_path_new();
    public static void sk_path_delete(IntPtr t);
    public static void sk_path_move_to(IntPtr t, float x, float y);
    public static void sk_path_rmove_to(IntPtr t, float dx, float dy);
    public static void sk_path_line_to(IntPtr t, float x, float y);
    public static void sk_path_rline_to(IntPtr t, float dx, float dy);
    public static void sk_path_quad_to(IntPtr t, float x0, float y0, float x1, float y1);
    public static void sk_path_rquad_to(IntPtr t, float dx0, float dy0, float dx1, float dy1);
    public static void sk_path_conic_to(IntPtr t, float x0, float y0, float x1, float y1, float w);
    public static void sk_path_rconic_to(IntPtr t, float dx0, float dy0, float dx1, float dy1, float w);
    public static void sk_path_cubic_to(IntPtr t, float x0, float y0, float x1, float y1, float x2, float y2);
    public static void sk_path_rcubic_to(IntPtr t, float dx0, float dy0, float dx1, float dy1, float dx2, float dy2);
    public static void sk_path_close(IntPtr t);
    public static void sk_path_rewind(IntPtr t);
    public static void sk_path_reset(IntPtr t);
    public static void sk_path_add_rect(IntPtr t, SKRect& rect, SKPathDirection direction);
    public static void sk_path_add_rect_start(IntPtr t, SKRect& rect, SKPathDirection direction, UInt32 startIndex);
    public static void sk_path_add_oval(IntPtr t, SKRect& rect, SKPathDirection direction);
    public static void sk_path_add_arc(IntPtr t, SKRect& rect, float startAngle, float sweepAngle);
    public static void sk_path_add_path_offset(IntPtr t, IntPtr other, float dx, float dy, SKPathAddMode mode);
    public static void sk_path_add_path_matrix(IntPtr t, IntPtr other, SKMatrix& matrix, SKPathAddMode mode);
    public static void sk_path_add_path(IntPtr t, IntPtr other, SKPathAddMode mode);
    public static void sk_path_add_path_reverse(IntPtr t, IntPtr other);
    public static bool sk_path_get_bounds(IntPtr t, SKRect& rect);
    public static void sk_path_compute_tight_bounds(IntPtr t, SKRect& rect);
    public static SKPathFillType sk_path_get_filltype(IntPtr t);
    public static void sk_path_set_filltype(IntPtr t, SKPathFillType filltype);
    public static IntPtr sk_path_clone(IntPtr t);
    public static IntPtr sk_path_transform(IntPtr t, SKMatrix& matrix);
    public static void sk_path_arc_to(IntPtr t, float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public static void sk_path_rarc_to(IntPtr t, float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public static void sk_path_arc_to_with_oval(IntPtr t, SKRect& oval, float startAngle, float sweepAngle, bool forceMoveTo);
    public static void sk_path_arc_to_with_points(IntPtr t, float x1, float y1, float x2, float y2, float radius);
    public static void sk_path_add_rounded_rect(IntPtr t, SKRect& rect, float rx, float ry, SKPathDirection dir);
    public static void sk_path_add_circle(IntPtr t, float x, float y, float radius, SKPathDirection dir);
    public static int sk_path_count_verbs(IntPtr path);
    public static int sk_path_count_points(IntPtr path);
    public static void sk_path_get_point(IntPtr path, int index, SKPoint& point);
    public static int sk_path_get_points(IntPtr path, SKPoint[] points, int max);
    public static SKPathConvexity sk_path_get_convexity(IntPtr cpath);
    public static void sk_path_set_convexity(IntPtr cpath, SKPathConvexity convexity);
    public static bool sk_path_parse_svg_string(IntPtr cpath, string str);
    public static void sk_path_to_svg_string(IntPtr cpath, IntPtr str);
    public static int sk_path_convert_conic_to_quads(SKPoint& p0, SKPoint& p1, SKPoint& p2, float w, SKPoint[] pts, int pow2);
    public static void sk_path_add_poly(IntPtr cpath, SKPoint[] points, int count, bool close);
    public static SKPathSegmentMask sk_path_get_segment_masks(IntPtr t);
    public static IntPtr sk_pathmeasure_new();
    public static IntPtr sk_pathmeasure_new_with_path(IntPtr path, bool forceClosed, float resScale);
    public static void sk_pathmeasure_destroy(IntPtr pathMeasure);
    public static void sk_pathmeasure_set_path(IntPtr pathMeasure, IntPtr path, bool forceClosed);
    public static float sk_pathmeasure_get_length(IntPtr pathMeasure);
    public static bool sk_pathmeasure_get_pos_tan(IntPtr pathMeasure, float distance, SKPoint& position, SKPoint& tangent);
    public static bool sk_pathmeasure_get_pos_tan(IntPtr pathMeasure, float distance, IntPtr positionZero, SKPoint& tangent);
    public static bool sk_pathmeasure_get_pos_tan(IntPtr pathMeasure, float distance, SKPoint& position, IntPtr tangentZero);
    public static bool sk_pathmeasure_get_matrix(IntPtr pathMeasure, float distance, SKMatrix& matrix, SKPathMeasureMatrixFlags flags);
    public static bool sk_pathmeasure_get_segment(IntPtr pathMeasure, float start, float stop, IntPtr dst, bool startWithMoveTo);
    public static bool sk_pathmeasure_is_closed(IntPtr pathMeasure);
    public static bool sk_pathmeasure_next_contour(IntPtr pathMeasure);
    public static bool sk_pathop_op(IntPtr one, IntPtr two, SKPathOp op, IntPtr result);
    public static bool sk_pathop_simplify(IntPtr path, IntPtr result);
    public static bool sk_pathop_tight_bounds(IntPtr path, SKRect& result);
    public static IntPtr sk_opbuilder_new();
    public static void sk_opbuilder_destroy(IntPtr builder);
    public static void sk_opbuilder_add(IntPtr builder, IntPtr path, SKPathOp op);
    public static bool sk_opbuilder_resolve(IntPtr builder, IntPtr result);
    public static IntPtr sk_path_create_iter(IntPtr path, int forceClose);
    public static SKPathVerb sk_path_iter_next(IntPtr iterator, SKPoint[] points, int doConsumeDegenerates, int exact);
    public static float sk_path_iter_conic_weight(IntPtr iterator);
    public static int sk_path_iter_is_close_line(IntPtr iterator);
    public static int sk_path_iter_is_closed_contour(IntPtr iterator);
    public static void sk_path_iter_destroy(IntPtr path);
    public static IntPtr sk_path_create_rawiter(IntPtr path);
    public static SKPathVerb sk_path_rawiter_next(IntPtr iterator, SKPoint[] points);
    public static SKPathVerb sk_path_rawiter_peek(IntPtr iterator);
    public static float sk_path_rawiter_conic_weight(IntPtr iterator);
    public static void sk_path_rawiter_destroy(IntPtr path);
    public static void sk_maskfilter_unref(IntPtr t);
    public static IntPtr sk_maskfilter_new_blur(SKBlurStyle style, float sigma);
    public static IntPtr sk_maskfilter_new_blur_with_flags(SKBlurStyle style, float sigma, SKRect& occluder, SKBlurMaskFilterFlags flags);
    public static IntPtr sk_maskfilter_new_table(Byte[] table);
    public static IntPtr sk_maskfilter_new_gamma(float gamma);
    public static IntPtr sk_maskfilter_new_clip(byte min, byte max);
    public static IntPtr sk_imagefilter_croprect_new();
    public static IntPtr sk_imagefilter_croprect_new_with_rect(SKRect& rect, SKCropRectFlags flags);
    public static void sk_imagefilter_croprect_destructor(IntPtr cropRect);
    public static void sk_imagefilter_croprect_get_rect(IntPtr cropRect, SKRect& rect);
    public static SKCropRectFlags sk_imagefilter_croprect_get_flags(IntPtr cropRect);
    public static void sk_imagefilter_unref(IntPtr filter);
    public static IntPtr sk_imagefilter_new_matrix(SKMatrix& matrix, SKFilterQuality quality, IntPtr input);
    public static IntPtr sk_imagefilter_new_alpha_threshold(SKRectI& region, float innerThreshold, float outerThreshold, IntPtr input);
    public static IntPtr sk_imagefilter_new_blur(float sigmaX, float sigmaY, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_color_filter(IntPtr cf, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_compose(IntPtr outer, IntPtr inner);
    public static IntPtr sk_imagefilter_new_displacement_map_effect(SKDisplacementMapEffectChannelSelectorType xChannelSelector, SKDisplacementMapEffectChannelSelectorType yChannelSelector, float scale, IntPtr displacement, IntPtr color, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_drop_shadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKDropShadowImageFilterShadowMode shadowMode, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_distant_lit_diffuse(SKPoint3& direction, SKColor lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_point_lit_diffuse(SKPoint3& location, SKColor lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_spot_lit_diffuse(SKPoint3& location, SKPoint3& target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_distant_lit_specular(SKPoint3& direction, SKColor lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_point_lit_specular(SKPoint3& location, SKColor lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_spot_lit_specular(SKPoint3& location, SKPoint3& target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_magnifier(SKRect& src, float inset, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_matrix_convolution(SKSizeI& kernelSize, Single[] kernel, float gain, float bias, SKPointI& kernelOffset, SKMatrixConvolutionTileMode tileMode, bool convolveAlpha, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_merge(IntPtr[] filters, int count, SKBlendMode[] modes, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_dilate(int radiusX, int radiusY, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_erode(int radiusX, int radiusY, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_offset(float dx, float dy, IntPtr input, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_picture(IntPtr picture);
    public static IntPtr sk_imagefilter_new_picture_with_croprect(IntPtr picture, SKRect& cropRect);
    public static IntPtr sk_imagefilter_new_picture_for_localspace(IntPtr picture, SKRect& cropRect, SKFilterQuality filterQuality);
    public static IntPtr sk_imagefilter_new_tile(SKRect& src, SKRect& dst, IntPtr input);
    public static IntPtr sk_imagefilter_new_xfermode(SKBlendMode mode, IntPtr background, IntPtr foreground, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_arithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, IntPtr background, IntPtr foreground, IntPtr cropRect);
    public static IntPtr sk_imagefilter_new_image_source(IntPtr image, SKRect& srcRect, SKRect& dstRect, SKFilterQuality filterQuality);
    public static IntPtr sk_imagefilter_new_image_source_default(IntPtr image);
    public static IntPtr sk_imagefilter_new_paint(IntPtr paint, IntPtr cropRect);
    public static void sk_colorfilter_unref(IntPtr filter);
    public static IntPtr sk_colorfilter_new_mode(SKColor c, SKBlendMode mode);
    public static IntPtr sk_colorfilter_new_lighting(SKColor mul, SKColor add);
    public static IntPtr sk_colorfilter_new_compose(IntPtr outer, IntPtr inner);
    public static IntPtr sk_colorfilter_new_color_matrix(Single[] array);
    public static IntPtr sk_colorfilter_new_luma_color();
    public static IntPtr sk_colorfilter_new_table(Byte[] table);
    public static IntPtr sk_colorfilter_new_table_argb(Byte[] tableA, Byte[] tableR, Byte[] tableG, Byte[] tableB);
    public static IntPtr sk_colorfilter_new_high_contrast(SKHighContrastConfig& config);
    public static IntPtr sk_data_new_empty();
    public static IntPtr sk_data_new_with_copy(IntPtr src, IntPtr length);
    public static IntPtr sk_data_new_with_copy(Byte[] src, IntPtr length);
    public static IntPtr sk_data_new_from_malloc(IntPtr malloc, IntPtr length);
    public static IntPtr sk_data_new_from_malloc(Byte[] malloc, IntPtr length);
    public static IntPtr sk_data_new_subset(IntPtr src, IntPtr offset, IntPtr length);
    public static IntPtr sk_data_new_from_file(string path);
    public static IntPtr sk_data_new_from_stream(IntPtr stream, IntPtr length);
    public static IntPtr sk_data_new_with_proc(IntPtr ptr, IntPtr length, IntPtr proc, IntPtr ctx);
    public static void sk_data_unref(IntPtr d);
    public static IntPtr sk_data_get_size(IntPtr d);
    public static IntPtr sk_data_get_data(IntPtr d);
    public static IntPtr sk_data_new_uninitialized(IntPtr size);
    public static IntPtr sk_string_new_empty();
    public static IntPtr sk_string_new_with_copy(Byte[] src, IntPtr length);
    public static void sk_string_destructor(IntPtr skstring);
    public static IntPtr sk_string_get_size(IntPtr skstring);
    public static IntPtr sk_string_get_c_str(IntPtr skstring);
    public static void sk_picture_recorder_delete(IntPtr r);
    public static IntPtr sk_picture_recorder_new();
    public static IntPtr sk_picture_recorder_begin_recording(IntPtr r, SKRect& rect);
    public static IntPtr sk_picture_recorder_end_recording(IntPtr r);
    public static IntPtr sk_picture_get_recording_canvas(IntPtr r);
    public static void sk_picture_unref(IntPtr t);
    public static UInt32 sk_picture_get_unique_id(IntPtr p);
    public static void sk_picture_get_cull_rect(IntPtr p, SKRect& rect);
    public static void sk_shader_unref(IntPtr t);
    public static IntPtr sk_shader_new_empty();
    public static IntPtr sk_shader_new_color(SKColor color);
    public static IntPtr sk_shader_new_local_matrix(IntPtr proxy, SKMatrix& matrix);
    public static IntPtr sk_shader_new_color_filter(IntPtr proxy, IntPtr filter);
    public static IntPtr sk_shader_new_bitmap(IntPtr src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix& matrix);
    public static IntPtr sk_shader_new_bitmap(IntPtr src, SKShaderTileMode tmx, SKShaderTileMode tmy, IntPtr matrixZero);
    public static IntPtr sk_shader_new_linear_gradient(SKPoint[] points, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_linear_gradient(SKPoint[] points, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_radial_gradient(SKPoint& center, float radius, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_radial_gradient(SKPoint& center, float radius, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_sweep_gradient(SKPoint& center, SKColor[] colors, Single[] colorPos, int count, IntPtr matrixZero);
    public static IntPtr sk_shader_new_sweep_gradient(SKPoint& center, SKColor[] colors, Single[] colorPos, int count, SKMatrix& matrixZero);
    public static IntPtr sk_shader_new_two_point_conical_gradient(SKPoint& start, float startRadius, SKPoint& end, float endRadius, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_two_point_conical_gradient(SKPoint& start, float startRadius, SKPoint& end, float endRadius, SKColor[] colors, Single[] colorPos, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_linear_gradient(SKPoint[] points, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_linear_gradient(SKPoint[] points, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_radial_gradient(SKPoint& center, float radius, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_radial_gradient(SKPoint& center, float radius, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_sweep_gradient(SKPoint& center, SKColor[] colors, IntPtr colorPosZero, int count, IntPtr matrixZero);
    public static IntPtr sk_shader_new_sweep_gradient(SKPoint& center, SKColor[] colors, IntPtr colorPosZero, int count, SKMatrix& matrixZero);
    public static IntPtr sk_shader_new_two_point_conical_gradient(SKPoint& start, float startRadius, SKPoint& end, float endRadius, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, SKMatrix& matrix);
    public static IntPtr sk_shader_new_two_point_conical_gradient(SKPoint& start, float startRadius, SKPoint& end, float endRadius, SKColor[] colors, IntPtr colorPosZero, int count, SKShaderTileMode mode, IntPtr matrixZero);
    public static IntPtr sk_shader_new_perlin_noise_fractal_noise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, IntPtr tileSizeZero);
    public static IntPtr sk_shader_new_perlin_noise_fractal_noise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI& tileSize);
    public static IntPtr sk_shader_new_perlin_noise_turbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, IntPtr tileSizeZero);
    public static IntPtr sk_shader_new_perlin_noise_turbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI& tileSize);
    public static IntPtr sk_shader_new_compose(IntPtr shaderA, IntPtr shaderB);
    public static IntPtr sk_shader_new_compose_with_mode(IntPtr shaderA, IntPtr shaderB, SKBlendMode mode);
    public static IntPtr sk_typeface_create_from_name(string str, SKTypefaceStyle style);
    public static IntPtr sk_typeface_create_from_name_with_font_style(string familyName, int weight, int width, SKFontStyleSlant slant);
    public static IntPtr sk_typeface_create_from_typeface(IntPtr typeface, SKTypefaceStyle style);
    public static IntPtr sk_typeface_create_from_file(string path, int index);
    public static IntPtr sk_typeface_create_from_stream(IntPtr stream, int index);
    public static void sk_typeface_unref(IntPtr t);
    public static int sk_typeface_chars_to_glyphs(IntPtr t, IntPtr chars, SKEncoding encoding, IntPtr glyphPtr, int glyphCount);
    public static IntPtr sk_typeface_get_family_name(IntPtr typeface);
    public static int sk_typeface_count_tables(IntPtr typeface);
    public static int sk_typeface_get_table_tags(IntPtr typeface, UInt32[] tags);
    public static IntPtr sk_typeface_get_table_size(IntPtr typeface, UInt32 tag);
    public static IntPtr sk_typeface_get_table_data(IntPtr typeface, UInt32 tag, IntPtr offset, IntPtr length, Byte[] data);
    public static int sk_typeface_get_font_weight(IntPtr typeface);
    public static int sk_typeface_get_font_width(IntPtr typeface);
    public static SKFontStyleSlant sk_typeface_get_font_slant(IntPtr typeface);
    public static SKTypefaceStyle sk_typeface_get_style(IntPtr typeface);
    public static IntPtr sk_typeface_open_stream(IntPtr typeface, Int32& ttcIndex);
    public static int sk_typeface_get_units_per_em(IntPtr typeface);
    public static IntPtr sk_fontmgr_ref_default();
    public static void sk_fontmgr_unref(IntPtr fontmgr);
    public static int sk_fontmgr_count_families(IntPtr fontmgr);
    public static void sk_fontmgr_get_family_name(IntPtr fontmgr, int index, IntPtr familyName);
    public static IntPtr sk_fontmgr_match_family_style_character(IntPtr fontmgr, string familyName, int weight, int width, SKFontStyleSlant slant, String[] bcp47, int bcp47Count, int character);
    public static void sk_memorystream_destroy(IntPtr stream);
    public static void sk_filestream_destroy(IntPtr stream);
    public static void sk_stream_asset_destroy(IntPtr stream);
    public static IntPtr sk_stream_read(IntPtr stream, IntPtr buffer, IntPtr size);
    public static IntPtr sk_stream_peek(IntPtr stream, IntPtr buffer, IntPtr size);
    public static IntPtr sk_stream_skip(IntPtr stream, IntPtr size);
    public static bool sk_stream_is_at_end(IntPtr stream);
    public static sbyte sk_stream_read_s8(IntPtr stream);
    public static short sk_stream_read_s16(IntPtr stream);
    public static int sk_stream_read_s32(IntPtr stream);
    public static byte sk_stream_read_u8(IntPtr stream);
    public static ushort sk_stream_read_u16(IntPtr stream);
    public static UInt32 sk_stream_read_u32(IntPtr stream);
    public static bool sk_stream_read_bool(IntPtr stream);
    public static bool sk_stream_rewind(IntPtr stream);
    public static bool sk_stream_has_position(IntPtr stream);
    public static IntPtr sk_stream_get_position(IntPtr stream);
    public static bool sk_stream_seek(IntPtr stream, IntPtr position);
    public static bool sk_stream_move(IntPtr stream, long offset);
    public static bool sk_stream_has_length(IntPtr stream);
    public static IntPtr sk_stream_get_length(IntPtr stream);
    public static IntPtr sk_stream_get_memory_base(IntPtr cstream);
    public static IntPtr sk_filestream_new(string path);
    public static IntPtr sk_memorystream_new();
    public static IntPtr sk_memorystream_new_with_length(IntPtr length);
    public static IntPtr sk_memorystream_new_with_data(IntPtr data, IntPtr length, bool copyData);
    public static IntPtr sk_memorystream_new_with_data(Byte[] data, IntPtr length, bool copyData);
    public static IntPtr sk_memorystream_new_with_skdata(IntPtr data);
    public static void sk_memorystream_set_memory(IntPtr s, IntPtr data, IntPtr length, bool copyData);
    public static void sk_memorystream_set_memory(IntPtr s, Byte[] data, IntPtr length, bool copyData);
    public static IntPtr sk_managedstream_new();
    public static void sk_managedstream_set_delegates(IntPtr pRead, IntPtr pPeek, IntPtr pIsAtEnd, IntPtr pHasPosition, IntPtr pHasLength, IntPtr pRewind, IntPtr pGetPosition, IntPtr pSeek, IntPtr pMove, IntPtr pGetLength, IntPtr pCreateNew, IntPtr pDestroy);
    public static void sk_managedstream_destroy(IntPtr stream);
    public static IntPtr sk_managedwstream_new();
    public static void sk_managedwstream_destroy(IntPtr stream);
    public static void sk_managedwstream_set_delegates(IntPtr pWrite, IntPtr pFlush, IntPtr pBytesWritten, IntPtr pDestroy);
    public static void sk_filewstream_destroy(IntPtr cstream);
    public static void sk_dynamicmemorywstream_destroy(IntPtr cstream);
    public static IntPtr sk_filewstream_new(string path);
    public static IntPtr sk_dynamicmemorywstream_new();
    public static IntPtr sk_dynamicmemorywstream_detach_as_stream(IntPtr cstream);
    public static IntPtr sk_dynamicmemorywstream_detach_as_data(IntPtr cstream);
    public static void sk_dynamicmemorywstream_copy_to(IntPtr cstream, IntPtr data);
    public static bool sk_dynamicmemorywstream_write_to_stream(IntPtr cstream, IntPtr dst);
    public static bool sk_wstream_write(IntPtr cstream, IntPtr buffer, IntPtr size);
    public static bool sk_wstream_write(IntPtr cstream, Byte[] buffer, IntPtr size);
    public static bool sk_wstream_newline(IntPtr cstream);
    public static void sk_wstream_flush(IntPtr cstream);
    public static IntPtr sk_wstream_bytes_written(IntPtr cstream);
    public static bool sk_wstream_write_8(IntPtr cstream, byte value);
    public static bool sk_wstream_write_16(IntPtr cstream, ushort value);
    public static bool sk_wstream_write_32(IntPtr cstream, UInt32 value);
    public static bool sk_wstream_write_text(IntPtr cstream, string value);
    public static bool sk_wstream_write_dec_as_text(IntPtr cstream, int value);
    public static bool sk_wstream_write_bigdec_as_text(IntPtr cstream, long value, int minDigits);
    public static bool sk_wstream_write_hex_as_text(IntPtr cstream, UInt32 value, int minDigits);
    public static bool sk_wstream_write_scalar_as_text(IntPtr cstream, float value);
    public static bool sk_wstream_write_bool(IntPtr cstream, bool value);
    public static bool sk_wstream_write_scalar(IntPtr cstream, float value);
    public static bool sk_wstream_write_packed_uint(IntPtr cstream, IntPtr value);
    public static bool sk_wstream_write_stream(IntPtr cstream, IntPtr input, IntPtr length);
    public static int sk_wstream_get_size_of_packed_uint(IntPtr value);
    public static void sk_document_unref(IntPtr document);
    public static IntPtr sk_document_create_pdf_from_stream(IntPtr stream, float dpi);
    public static IntPtr sk_document_create_pdf_from_stream_with_metadata(IntPtr stream, float dpi, SKDocumentPdfMetadataInternal& metadata);
    public static IntPtr sk_document_create_pdf_from_filename(string path, float dpi);
    public static IntPtr sk_document_create_xps_from_stream(IntPtr stream, float dpi);
    public static IntPtr sk_document_begin_page(IntPtr document, float width, float height, SKRect& content);
    public static IntPtr sk_document_begin_page(IntPtr document, float width, float height, IntPtr content);
    public static void sk_document_end_page(IntPtr document);
    public static void sk_document_close(IntPtr document);
    public static void sk_document_abort(IntPtr document);
    public static IntPtr sk_codec_min_buffered_bytes_needed();
    public static IntPtr sk_codec_new_from_stream(IntPtr stream);
    public static IntPtr sk_codec_new_from_data(IntPtr data);
    public static void sk_codec_destroy(IntPtr codec);
    public static void sk_codec_get_info(IntPtr codec, SKImageInfoNative& info);
    public static void sk_codec_get_encodedinfo(IntPtr codec, SKEncodedInfo& info);
    public static SKCodecOrigin sk_codec_get_origin(IntPtr codec);
    public static void sk_codec_get_scaled_dimensions(IntPtr codec, float desiredScale, SKSizeI& dimensions);
    public static bool sk_codec_get_valid_subset(IntPtr codec, SKRectI& desiredSubset);
    public static SKEncodedImageFormat sk_codec_get_encoded_format(IntPtr codec);
    public static SKCodecResult sk_codec_get_pixels(IntPtr codec, SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, SKCodecOptionsInternal& options, IntPtr ctable, Int32& ctableCount);
    public static SKCodecResult sk_codec_get_pixels_using_defaults(IntPtr codec, SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes);
    public static SKCodecResult sk_codec_start_incremental_decode(IntPtr codec, SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, SKCodecOptionsInternal& options, IntPtr ctable, Int32& ctableCount);
    public static SKCodecResult sk_codec_start_incremental_decode(IntPtr codec, SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, SKCodecOptionsInternal& options, IntPtr ctableZero, IntPtr ctableCountZero);
    public static SKCodecResult sk_codec_start_incremental_decode(IntPtr codec, SKImageInfoNative& info, IntPtr pixels, IntPtr rowBytes, IntPtr optionsZero, IntPtr ctableZero, IntPtr ctableCountZero);
    public static SKCodecResult sk_codec_incremental_decode(IntPtr codec, Int32& rowsDecoded);
    public static int sk_codec_get_repetition_count(IntPtr codec);
    public static int sk_codec_get_frame_count(IntPtr codec);
    public static void sk_codec_get_frame_info(IntPtr codec, SKCodecFrameInfo[] frameInfo);
    public static SKCodecResult sk_codec_start_scanline_decode(IntPtr codec, SKImageInfoNative& info, SKCodecOptionsInternal& options, IntPtr ctable, Int32& ctableCount);
    public static SKCodecResult sk_codec_start_scanline_decode(IntPtr codec, SKImageInfoNative& info, SKCodecOptionsInternal& options, IntPtr ctableZero, IntPtr ctableCountZero);
    public static SKCodecResult sk_codec_start_scanline_decode(IntPtr codec, SKImageInfoNative& info, IntPtr optionsZero, IntPtr ctableZero, IntPtr ctableCountZero);
    public static int sk_codec_get_scanlines(IntPtr codec, IntPtr dst, int countLines, IntPtr rowBytes);
    public static bool sk_codec_skip_scanlines(IntPtr codec, int countLines);
    public static SKCodecScanlineOrder sk_codec_get_scanline_order(IntPtr codec);
    public static int sk_codec_next_scanline(IntPtr codec);
    public static int sk_codec_output_scanline(IntPtr codec, int inputScanline);
    public static IntPtr sk_bitmap_new();
    public static void sk_bitmap_destructor(IntPtr b);
    public static void sk_bitmap_get_info(IntPtr b, SKImageInfoNative& info);
    public static IntPtr sk_bitmap_get_pixels(IntPtr b, IntPtr& length);
    public static void sk_bitmap_get_pixel_colors(IntPtr b, SKColor[] colors);
    public static void sk_bitmap_set_pixel_colors(IntPtr b, SKColor[] colors);
    public static void sk_bitmap_reset(IntPtr b);
    public static IntPtr sk_bitmap_get_row_bytes(IntPtr b);
    public static IntPtr sk_bitmap_get_byte_count(IntPtr b);
    public static bool sk_bitmap_is_null(IntPtr b);
    public static bool sk_bitmap_is_immutable(IntPtr b);
    public static void sk_bitmap_set_immutable(IntPtr b);
    public static bool sk_bitmap_is_volatile(IntPtr b);
    public static void sk_bitmap_set_volatile(IntPtr b, bool value);
    public static void sk_bitmap_erase(IntPtr cbitmap, SKColor color);
    public static void sk_bitmap_erase_rect(IntPtr cbitmap, SKColor color, SKRectI& rect);
    public static byte sk_bitmap_get_addr_8(IntPtr cbitmap, int x, int y);
    public static ushort sk_bitmap_get_addr_16(IntPtr cbitmap, int x, int y);
    public static UInt32 sk_bitmap_get_addr_32(IntPtr cbitmap, int x, int y);
    public static IntPtr sk_bitmap_get_addr(IntPtr cbitmap, int x, int y);
    public static UInt32 sk_bitmap_get_pixel_color(IntPtr cbitmap, int x, int y);
    public static UInt32 sk_bitmap_get_index8_color(IntPtr cbitmap, int x, int y);
    public static void sk_bitmap_set_pixel_color(IntPtr cbitmap, int x, int y, SKColor color);
    public static bool sk_bitmap_ready_to_draw(IntPtr b);
    public static bool sk_bitmap_install_pixels(IntPtr cbitmap, SKImageInfoNative& cinfo, IntPtr pixels, IntPtr rowBytes, IntPtr ctable, IntPtr releaseProc, IntPtr context);
    public static bool sk_bitmap_install_pixels_with_pixmap(IntPtr cbitmap, IntPtr cpixmap);
    public static bool sk_bitmap_install_mask_pixels(IntPtr cbitmap, SKMask& cmask);
    public static bool sk_bitmap_try_alloc_pixels(IntPtr cbitmap, SKImageInfoNative& requestedInfo, IntPtr rowBytes);
    public static bool sk_bitmap_try_alloc_pixels_with_color_table(IntPtr cbitmap, SKImageInfoNative& requestedInfo, IntPtr ctable, SKBitmapAllocFlags flags);
    public static IntPtr sk_bitmap_get_colortable(IntPtr cbitmap);
    public static void sk_bitmap_set_pixels(IntPtr cbitmap, IntPtr pixels, IntPtr ctable);
    public static bool sk_bitmap_peek_pixels(IntPtr cbitmap, IntPtr cpixmap);
    public static bool sk_bitmapscaler_resize(IntPtr cdst, IntPtr csrc, SKBitmapResizeMethod method);
    public static bool sk_bitmap_extract_subset(IntPtr cbitmap, IntPtr cdst, SKRectI& subset);
    public static bool sk_bitmap_extract_alpha(IntPtr cbitmap, IntPtr dst, IntPtr paint, SKPointI& offset);
    public static void sk_bitmap_notify_pixels_changed(IntPtr cbitmap);
    public static UInt32 sk_color_unpremultiply(SKPMColor pmcolor);
    public static UInt32 sk_color_premultiply(SKColor color);
    public static void sk_color_unpremultiply_array(SKPMColor[] pmcolors, int size, SKColor[] colors);
    public static UInt32 sk_color_premultiply_array(SKColor[] colors, int size, SKPMColor[] pmcolors);
    public static void sk_color_get_bit_shift(Int32& a, Int32& r, Int32& g, Int32& b);
    public static void sk_pixmap_destructor(IntPtr cpixmap);
    public static IntPtr sk_pixmap_new();
    public static IntPtr sk_pixmap_new_with_params(SKImageInfoNative& cinfo, IntPtr addr, IntPtr rowBytes, IntPtr ctable);
    public static void sk_pixmap_reset(IntPtr cpixmap);
    public static void sk_pixmap_reset_with_params(IntPtr cpixmap, SKImageInfoNative& cinfo, IntPtr addr, IntPtr rowBytes, IntPtr ctable);
    public static void sk_pixmap_get_info(IntPtr cpixmap, SKImageInfoNative& cinfo);
    public static IntPtr sk_pixmap_get_row_bytes(IntPtr cpixmap);
    public static IntPtr sk_pixmap_get_pixels(IntPtr cpixmap);
    public static IntPtr sk_pixmap_get_colortable(IntPtr cpixmap);
    public static bool sk_pixmap_encode_image(IntPtr dst, IntPtr src, SKEncodedImageFormat encoder, int quality);
    public static bool sk_pixmap_read_pixels(IntPtr cpixmap, SKImageInfoNative& dstInfo, IntPtr dstPixels, IntPtr dstRowBytes, int srcX, int srcY);
    public static void sk_swizzle_swap_rb(IntPtr dest, IntPtr src, int count);
    public static IntPtr sk_mask_alloc_image(IntPtr bytes);
    public static void sk_mask_free_image(IntPtr image);
    public static bool sk_mask_is_empty(SKMask& cmask);
    public static IntPtr sk_mask_compute_image_size(SKMask& cmask);
    public static IntPtr sk_mask_compute_total_image_size(SKMask& cmask);
    public static byte sk_mask_get_addr_1(SKMask& cmask, int x, int y);
    public static byte sk_mask_get_addr_8(SKMask& cmask, int x, int y);
    public static ushort sk_mask_get_addr_lcd_16(SKMask& cmask, int x, int y);
    public static UInt32 sk_mask_get_addr_32(SKMask& cmask, int x, int y);
    public static IntPtr sk_mask_get_addr(SKMask& cmask, int x, int y);
    public static int sk_matrix_try_invert(SKMatrix& matrix, SKMatrix& result);
    public static void sk_matrix_concat(SKMatrix& target, SKMatrix& first, SKMatrix& second);
    public static void sk_matrix_pre_concat(SKMatrix& target, SKMatrix& matrix);
    public static void sk_matrix_post_concat(SKMatrix& target, SKMatrix& matrix);
    public static void sk_matrix_map_rect(SKMatrix& matrix, SKRect& dest, SKRect& source);
    public static void sk_matrix_map_points(SKMatrix& matrix, IntPtr dst, IntPtr src, int count);
    public static void sk_matrix_map_vectors(SKMatrix& matrix, IntPtr dst, IntPtr src, int count);
    public static void sk_matrix_map_xy(SKMatrix& matrix, float x, float y, SKPoint& result);
    public static void sk_matrix_map_vector(SKMatrix& matrix, float x, float y, SKPoint& result);
    public static float sk_matrix_map_radius(SKMatrix& matrix, float radius);
    public static IntPtr sk_3dview_new();
    public static void sk_3dview_destroy(IntPtr cview);
    public static void sk_3dview_save(IntPtr cview);
    public static void sk_3dview_restore(IntPtr cview);
    public static void sk_3dview_translate(IntPtr cview, float x, float y, float z);
    public static void sk_3dview_rotate_x_degrees(IntPtr cview, float degrees);
    public static void sk_3dview_rotate_y_degrees(IntPtr cview, float degrees);
    public static void sk_3dview_rotate_z_degrees(IntPtr cview, float degrees);
    public static void sk_3dview_rotate_x_radians(IntPtr cview, float radians);
    public static void sk_3dview_rotate_y_radians(IntPtr cview, float radians);
    public static void sk_3dview_rotate_z_radians(IntPtr cview, float radians);
    public static void sk_3dview_get_matrix(IntPtr cview, SKMatrix& cmatrix);
    public static void sk_3dview_apply_to_canvas(IntPtr cview, IntPtr ccanvas);
    public static float sk_3dview_dot_with_normal(IntPtr cview, float dx, float dy, float dz);
    public static void sk_matrix44_destroy(IntPtr matrix);
    public static IntPtr sk_matrix44_new();
    public static IntPtr sk_matrix44_new_identity();
    public static IntPtr sk_matrix44_new_copy(IntPtr src);
    public static IntPtr sk_matrix44_new_concat(IntPtr a, IntPtr b);
    public static IntPtr sk_matrix44_new_matrix(SKMatrix& src);
    public static bool sk_matrix44_equals(IntPtr matrix, IntPtr other);
    public static void sk_matrix44_to_matrix(IntPtr matrix, SKMatrix& dst);
    public static SKMatrix44TypeMask sk_matrix44_get_type(IntPtr matrix);
    public static void sk_matrix44_set_identity(IntPtr matrix);
    public static float sk_matrix44_get(IntPtr matrix, int row, int col);
    public static void sk_matrix44_set(IntPtr matrix, int row, int col, float value);
    public static void sk_matrix44_as_col_major(IntPtr matrix, Single[] dst);
    public static void sk_matrix44_as_row_major(IntPtr matrix, Single[] dst);
    public static void sk_matrix44_set_col_major(IntPtr matrix, Single[] src);
    public static void sk_matrix44_set_row_major(IntPtr matrix, Single[] src);
    public static void sk_matrix44_set_translate(IntPtr matrix, float dx, float dy, float dz);
    public static void sk_matrix44_pre_translate(IntPtr matrix, float dx, float dy, float dz);
    public static void sk_matrix44_post_translate(IntPtr matrix, float dx, float dy, float dz);
    public static void sk_matrix44_set_scale(IntPtr matrix, float sx, float sy, float sz);
    public static void sk_matrix44_pre_scale(IntPtr matrix, float sx, float sy, float sz);
    public static void sk_matrix44_post_scale(IntPtr matrix, float sx, float sy, float sz);
    public static void sk_matrix44_set_rotate_about_degrees(IntPtr matrix, float x, float y, float z, float degrees);
    public static void sk_matrix44_set_rotate_about_radians(IntPtr matrix, float x, float y, float z, float radians);
    public static void sk_matrix44_set_rotate_about_radians_unit(IntPtr matrix, float x, float y, float z, float radians);
    public static void sk_matrix44_set_concat(IntPtr matrix, IntPtr a, IntPtr b);
    public static void sk_matrix44_pre_concat(IntPtr matrix, IntPtr m);
    public static void sk_matrix44_post_concat(IntPtr matrix, IntPtr m);
    public static bool sk_matrix44_invert(IntPtr matrix, IntPtr inverse);
    public static void sk_matrix44_transpose(IntPtr matrix);
    public static void sk_matrix44_map_scalars(IntPtr matrix, Single[] src, Single[] dst);
    public static void sk_matrix44_map2(IntPtr matrix, Single[] src2, int count, Single[] dst);
    public static bool sk_matrix44_preserves_2d_axis_alignment(IntPtr matrix, float epsilon);
    public static double sk_matrix44_determinant(IntPtr matrix);
    public static void sk_path_effect_unref(IntPtr effect);
    public static IntPtr sk_path_effect_create_compose(IntPtr outer, IntPtr inner);
    public static IntPtr sk_path_effect_create_sum(IntPtr first, IntPtr second);
    public static IntPtr sk_path_effect_create_discrete(float segLength, float deviation, UInt32 seedAssist);
    public static IntPtr sk_path_effect_create_corner(float radius);
    public static IntPtr sk_path_effect_create_arc_to(float radius);
    public static IntPtr sk_path_effect_create_1d_path(IntPtr path, float advance, float phase, SKPath1DPathEffectStyle style);
    public static IntPtr sk_path_effect_create_2d_line(float width, SKMatrix& matrix);
    public static IntPtr sk_path_effect_create_2d_path(SKMatrix& matrix, IntPtr path);
    public static IntPtr sk_path_effect_create_dash(Single[] intervals, int count, float phase);
    public static void sk_colortable_unref(IntPtr ctable);
    public static IntPtr sk_colortable_new(SKPMColor[] colors, int count);
    public static int sk_colortable_count(IntPtr ctable);
    public static void sk_colortable_read_colors(IntPtr ctable, SKPMColor[] colors);
    public static void sk_colortable_read_colors(IntPtr ctable, IntPtr& colors);
    public static IntPtr gr_context_create(GRBackend backend, IntPtr backendContext, GRContextOptions& options);
    public static IntPtr gr_context_create_with_defaults(GRBackend backend, IntPtr backendContext);
    public static void gr_context_unref(IntPtr context);
    public static void gr_context_abandon_context(IntPtr context);
    public static void gr_context_release_resources_and_abandon_context(IntPtr context);
    public static void gr_context_get_resource_cache_limits(IntPtr context, Int32& maxResources, IntPtr& maxResourceBytes);
    public static void gr_context_set_resource_cache_limits(IntPtr context, int maxResources, IntPtr maxResourceBytes);
    public static void gr_context_get_resource_cache_usage(IntPtr context, Int32& maxResources, IntPtr& maxResourceBytes);
    public static int gr_context_get_recommended_sample_count(IntPtr context, GRPixelConfig config, float dpi);
    public static void gr_context_flush(IntPtr context);
    public static void gr_context_reset_context(IntPtr context, UInt32 state);
    public static IntPtr gr_glinterface_assemble_interface(IntPtr ctx, IntPtr get);
    public static IntPtr gr_glinterface_assemble_gl_interface(IntPtr ctx, IntPtr get);
    public static IntPtr gr_glinterface_assemble_gles_interface(IntPtr ctx, IntPtr get);
    public static IntPtr gr_glinterface_default_interface();
    public static IntPtr gr_glinterface_create_native_interface();
    public static void gr_glinterface_unref(IntPtr glInterface);
    public static IntPtr gr_glinterface_clone(IntPtr glInterface);
    public static bool gr_glinterface_validate(IntPtr glInterface);
    public static bool gr_glinterface_has_extension(IntPtr glInterface, string extension);
    public static IntPtr sk_xmlstreamwriter_new(IntPtr stream);
    public static void sk_xmlstreamwriter_delete(IntPtr writer);
    public static IntPtr sk_svgcanvas_create(SKRect& bounds, IntPtr writer);
    public static IntPtr sk_region_new();
    public static IntPtr sk_region_new2(IntPtr r);
    public static bool sk_region_contains(IntPtr r, IntPtr region);
    public static bool sk_region_contains2(IntPtr r, int x, int y);
    public static bool sk_region_intersects(IntPtr r, IntPtr src);
    public static bool sk_region_intersects(IntPtr r, SKRectI rect);
    public static bool sk_region_set_region(IntPtr r, IntPtr src);
    public static bool sk_region_set_rect(IntPtr r, SKRectI& rect);
    public static bool sk_region_set_path(IntPtr r, IntPtr t, IntPtr clip);
    public static bool sk_region_op(IntPtr r, int left, int top, int right, int bottom, SKRegionOperation op);
    public static bool sk_region_op2(IntPtr r, IntPtr src, SKRegionOperation op);
    public static void sk_region_get_bounds(IntPtr r, SKRectI& rect);
    public static void sk_vertices_unref(IntPtr cvertices);
    public static IntPtr sk_vertices_make_copy(SKVertexMode vmode, int vertexCount, SKPoint[] positions, SKPoint[] texs, SKColor[] colors, int indexCount, UInt16[] indices);
}
[ExtensionAttribute]
public static class SkiaSharp.SkiaExtensions : object {
    [ExtensionAttribute]
public static bool IsBgr(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsRgb(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsVertical(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsHorizontal(SKPixelGeometry pg);
}
public class SkiaSharp.SKImage : SKObject {
    private static SKImageRasterReleaseDelegateInternal rasterReleaseDelegateInternal;
    private static SKImageTextureReleaseDelegateInternal textureReleaseDelegateInternal;
    private static SKImageRasterReleaseDelegateInternal coTaskMemReleaseDelegateInternal;
    private static IntPtr rasterReleaseDelegate;
    private static IntPtr textureReleaseDelegate;
    private static IntPtr coTaskMemReleaseDelegate;
    public int Width { get; }
    public int Height { get; }
    public UInt32 UniqueId { get; }
    public SKAlphaType AlphaType { get; }
    public bool IsAlphaOnly { get; }
    public bool IsTextureBacked { get; }
    public bool IsLazyGenerated { get; }
    private static SKImage();
    [PreserveAttribute]
internal SKImage(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKImage Create(SKImageInfo info);
    public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels, int rowBytes);
    public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable);
    public static SKImage FromPixelCopy(SKPixmap pixmap);
    public static SKImage FromPixelData(SKImageInfo info, SKData data, int rowBytes);
    public static SKImage FromPixels(SKImageInfo info, IntPtr pixels);
    public static SKImage FromPixels(SKImageInfo info, IntPtr pixels, int rowBytes);
    public static SKImage FromPixels(SKPixmap pixmap);
    public static SKImage FromPixels(SKPixmap pixmap, SKImageRasterReleaseDelegate releaseProc);
    public static SKImage FromPixels(SKPixmap pixmap, SKImageRasterReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromEncodedData(SKData data, SKRectI subset);
    public static SKImage FromEncodedData(SKData data);
    public static SKImage FromBitmap(SKBitmap bitmap);
    public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc);
    public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha);
    public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc);
    public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc);
    public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha);
    public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc);
    public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromAdoptedTexture(GRContext context, GRGlBackendTextureDesc desc);
    public static SKImage FromAdoptedTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTextureDesc desc);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKMatrix matrix);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKPaint paint);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKMatrix matrix, SKPaint paint);
    public SKData Encode();
    public SKData Encode(SKPixelSerializer serializer);
    public SKData Encode(SKEncodedImageFormat format, int quality);
    public int get_Width();
    public int get_Height();
    public UInt32 get_UniqueId();
    public SKAlphaType get_AlphaType();
    public bool get_IsAlphaOnly();
    public SKShader ToShader(SKShaderTileMode tileX, SKShaderTileMode tileY);
    public SKShader ToShader(SKShaderTileMode tileX, SKShaderTileMode tileY, SKMatrix localMatrix);
    public bool PeekPixels(SKPixmap pixmap);
    public SKPixmap PeekPixels();
    public bool get_IsTextureBacked();
    public bool get_IsLazyGenerated();
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY, SKImageCachingHint cachingHint);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY, SKImageCachingHint cachingHint);
    public bool ScalePixels(SKPixmap dst, SKFilterQuality quality);
    public bool ScalePixels(SKPixmap dst, SKFilterQuality quality, SKImageCachingHint cachingHint);
    public SKImage Subset(SKRectI subset);
    public SKImage ToRasterImage();
    public SKImage ApplyImageFilter(SKImageFilter filter, SKRectI subset, SKRectI clipBounds, SKRectI& outSubset, SKPoint& outOffset);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageRasterReleaseDelegateInternal")]
private static void RasterReleaseInternal(IntPtr pixels, IntPtr context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageRasterReleaseDelegateInternal")]
private static void CoTaskMemReleaseInternal(IntPtr pixels, IntPtr context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageTextureReleaseDelegateInternal")]
private static void TextureReleaseInternal(IntPtr context);
}
public enum SkiaSharp.SKImageCachingHint : Enum {
    public int value__;
    public static SKImageCachingHint Allow;
    public static SKImageCachingHint Disallow;
}
public class SkiaSharp.SKImageFilter : SKObject {
    [PreserveAttribute]
internal SKImageFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKImageFilter CreateMatrix(SKMatrix matrix, SKFilterQuality quality, SKImageFilter input);
    public static SKImageFilter CreateAlphaThreshold(SKRectI region, float innerThreshold, float outerThreshold, SKImageFilter input);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateColorFilter(SKColorFilter cf, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateCompose(SKImageFilter outer, SKImageFilter inner);
    public static SKImageFilter CreateDisplacementMapEffect(SKDisplacementMapEffectChannelSelectorType xChannelSelector, SKDisplacementMapEffectChannelSelectorType yChannelSelector, float scale, SKImageFilter displacement, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKDropShadowImageFilterShadowMode shadowMode, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDistantLitDiffuse(SKPoint3 direction, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePointLitDiffuse(SKPoint3 location, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateSpotLitDiffuse(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDistantLitSpecular(SKPoint3 direction, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePointLitSpecular(SKPoint3 location, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateSpotLitSpecular(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMagnifier(SKRect src, float inset, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, Single[] kernel, float gain, float bias, SKPointI kernelOffset, SKMatrixConvolutionTileMode tileMode, bool convolveAlpha, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMerge(SKImageFilter first, SKImageFilter second, SKBlendMode mode, CropRect cropRect);
    public static SKImageFilter CreateMerge(SKImageFilter[] filters, SKBlendMode[] modes, CropRect cropRect);
    public static SKImageFilter CreateDilate(int radiusX, int radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateErode(int radiusX, int radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateOffset(float dx, float dy, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePicture(SKPicture picture);
    public static SKImageFilter CreatePicture(SKPicture picture, SKRect cropRect);
    public static SKImageFilter CreatePictureForLocalspace(SKPicture picture, SKRect cropRect, SKFilterQuality filterQuality);
    public static SKImageFilter CreateTile(SKRect src, SKRect dst, SKImageFilter input);
    public static SKImageFilter CreateBlendMode(SKBlendMode mode, SKImageFilter background, SKImageFilter foreground, CropRect cropRect);
    public static SKImageFilter CreateArithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, SKImageFilter background, SKImageFilter foreground, CropRect cropRect);
    public static SKImageFilter CreateImage(SKImage image);
    public static SKImageFilter CreateImage(SKImage image, SKRect src, SKRect dst, SKFilterQuality filterQuality);
    public static SKImageFilter CreatePaint(SKPaint paint, CropRect cropRect);
}
public class SkiaSharp.SKImageInfo : ValueType {
    public static SKImageInfo Empty;
    public static SKColorType PlatformColorType;
    public static int PlatformColorAlphaShift;
    public static int PlatformColorRedShift;
    public static int PlatformColorGreenShift;
    public static int PlatformColorBlueShift;
    private int width;
    private int height;
    private SKColorType colorType;
    private SKAlphaType alphaType;
    private SKColorSpace colorSpace;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public SKColorType ColorType { get; public set; }
    public SKAlphaType AlphaType { get; public set; }
    public SKColorSpace ColorSpace { get; public set; }
    public int BytesPerPixel { get; }
    public int BitsPerPixel { get; }
    public int BytesSize { get; }
    public long BytesSize64 { get; }
    public int RowBytes { get; }
    public long RowBytes64 { get; }
    public bool IsEmpty { get; }
    public bool IsOpaque { get; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    private static SKImageInfo();
    public SKImageInfo(int width, int height);
    public SKImageInfo(int width, int height, SKColorType colorType);
    public SKImageInfo(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    public SKImageInfo(int width, int height, SKColorType colorType, SKAlphaType alphaType, SKColorSpace colorspace);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public SKColorType get_ColorType();
    public void set_ColorType(SKColorType value);
    public SKAlphaType get_AlphaType();
    public void set_AlphaType(SKAlphaType value);
    public SKColorSpace get_ColorSpace();
    public void set_ColorSpace(SKColorSpace value);
    public int get_BytesPerPixel();
    public int get_BitsPerPixel();
    public int get_BytesSize();
    public long get_BytesSize64();
    public int get_RowBytes();
    public long get_RowBytes64();
    public bool get_IsEmpty();
    public bool get_IsOpaque();
    public SKSizeI get_Size();
    public SKRectI get_Rect();
    public SKImageInfo WithColorType(SKColorType newColorType);
    public SKImageInfo WithColorSpace(SKColorSpace newColorSpace);
    public SKImageInfo WithAlphaType(SKAlphaType newAlphaType);
}
internal class SkiaSharp.SKImageInfoNative : ValueType {
    public IntPtr fColorSpace;
    public int fWidth;
    public int fHeight;
    public SKColorType fColorType;
    public SKAlphaType fAlphaType;
    public static void UpdateNative(SKImageInfo& managed, SKImageInfoNative& native);
    public static SKImageInfoNative FromManaged(SKImageInfo& managed);
    public static SKImageInfo ToManaged(SKImageInfoNative& native);
}
public class SkiaSharp.SKImageRasterReleaseDelegate : MulticastDelegate {
    public SKImageRasterReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pixels, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr pixels, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKImageRasterReleaseDelegateInternal : MulticastDelegate {
    public SKImageRasterReleaseDelegateInternal(object object, IntPtr method);
    public virtual void Invoke(IntPtr pixels, IntPtr context);
    public virtual IAsyncResult BeginInvoke(IntPtr pixels, IntPtr context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKImageTextureReleaseDelegate : MulticastDelegate {
    public SKImageTextureReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(object context);
    public virtual IAsyncResult BeginInvoke(object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKImageTextureReleaseDelegateInternal : MulticastDelegate {
    public SKImageTextureReleaseDelegateInternal(object object, IntPtr method);
    public virtual void Invoke(IntPtr context);
    public virtual IAsyncResult BeginInvoke(IntPtr context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKLattice : ValueType {
    [CompilerGeneratedAttribute]
private Int32[] <XDivs>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <YDivs>k__BackingField;
    [CompilerGeneratedAttribute]
private SKLatticeFlags[] <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SKRectI> <Bounds>k__BackingField;
    public Int32[] XDivs { get; public set; }
    public Int32[] YDivs { get; public set; }
    public SKLatticeFlags[] Flags { get; public set; }
    public Nullable`1<SKRectI> Bounds { get; public set; }
    [CompilerGeneratedAttribute]
public Int32[] get_XDivs();
    [CompilerGeneratedAttribute]
public void set_XDivs(Int32[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_YDivs();
    [CompilerGeneratedAttribute]
public void set_YDivs(Int32[] value);
    [CompilerGeneratedAttribute]
public SKLatticeFlags[] get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SKLatticeFlags[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<SKRectI> get_Bounds();
    [CompilerGeneratedAttribute]
public void set_Bounds(Nullable`1<SKRectI> value);
}
public enum SkiaSharp.SKLatticeFlags : Enum {
    public int value__;
    public static SKLatticeFlags Default;
    public static SKLatticeFlags Transparent;
}
internal class SkiaSharp.SKLatticeInternal : ValueType {
    public Int32* fXDivs;
    public Int32* fYDivs;
    public SKLatticeFlags* fFlags;
    public int fXCount;
    public int fYCount;
    public SKRectI* fBounds;
}
public abstract class SkiaSharp.SKManagedPixelSerializer : SKPixelSerializer {
    private static use_delegate fUse;
    private static encode_delegate fEncode;
    private static SKManagedPixelSerializer();
    [PreserveAttribute]
internal SKManagedPixelSerializer(IntPtr x, bool owns);
    protected abstract virtual bool OnUseEncodedData(IntPtr data, IntPtr length);
    protected abstract virtual SKData OnEncode(SKPixmap pixmap);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedPixelSerializer/use_delegate")]
private static bool UseInternal(IntPtr cserializer, IntPtr buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKBitmapReleaseDelegateInternal")]
private static IntPtr EncodeInternal(IntPtr cserializer, IntPtr pixmap);
}
public class SkiaSharp.SKManagedStream : SKAbstractManagedStream {
    private Stream stream;
    private bool isAsEnd;
    private bool disposeStream;
    public SKManagedStream(Stream managedStream);
    public SKManagedStream(Stream managedStream, bool disposeManagedStream);
    private SKManagedStream(Stream managedStream, bool disposeManagedStream, bool owns);
    protected virtual void Dispose(bool disposing);
    private IntPtr OnReadManagedStream(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected virtual bool OnIsAtEnd();
    protected virtual bool OnHasPosition();
    protected virtual bool OnHasLength();
    protected virtual bool OnRewind();
    protected virtual IntPtr OnGetPosition();
    protected virtual IntPtr OnGetLength();
    protected virtual bool OnSeek(IntPtr position);
    protected virtual bool OnMove(int offset);
    protected virtual IntPtr OnCreateNew();
}
public class SkiaSharp.SKManagedWStream : SKAbstractManagedWStream {
    private Stream stream;
    private bool disposeStream;
    public SKManagedWStream(Stream managedStream);
    public SKManagedWStream(Stream managedStream, bool disposeManagedStream);
    private SKManagedWStream(Stream managedStream, bool disposeManagedStream, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual bool OnWrite(IntPtr buffer, IntPtr size);
    protected virtual void OnFlush();
    protected virtual IntPtr OnBytesWritten();
}
public class SkiaSharp.SKMask : ValueType {
    private IntPtr image;
    private SKRectI bounds;
    private UInt32 rowBytes;
    private SKMaskFormat format;
    public IntPtr Image { get; }
    public SKRectI Bounds { get; }
    public UInt32 RowBytes { get; }
    public SKMaskFormat Format { get; }
    public bool IsEmpty { get; }
    public SKMask(IntPtr image, SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
    public SKMask(SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
    public IntPtr get_Image();
    public SKRectI get_Bounds();
    public UInt32 get_RowBytes();
    public SKMaskFormat get_Format();
    public bool get_IsEmpty();
    public long AllocateImage();
    public void FreeImage();
    public long ComputeImageSize();
    public long ComputeTotalImageSize();
    public byte GetAddr1(int x, int y);
    public byte GetAddr8(int x, int y);
    public ushort GetAddr16(int x, int y);
    public UInt32 GetAddr32(int x, int y);
    public IntPtr GetAddr(int x, int y);
    public static IntPtr AllocateImage(long size);
    public static void FreeImage(IntPtr image);
    public static SKMask Create(Byte[] image, SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
}
public class SkiaSharp.SKMaskFilter : SKObject {
    private static float BlurSigmaScale;
    [PreserveAttribute]
internal SKMaskFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static float ConvertRadiusToSigma(float radius);
    public static float ConvertSigmaToRadius(float sigma);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKBlurMaskFilterFlags flags);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKRect occluder);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKRect occluder, SKBlurMaskFilterFlags flags);
    public static SKMaskFilter CreateTable(Byte[] table);
    public static SKMaskFilter CreateGamma(float gamma);
    public static SKMaskFilter CreateClip(byte min, byte max);
}
public enum SkiaSharp.SKMaskFormat : Enum {
    public int value__;
    public static SKMaskFormat BW;
    public static SKMaskFormat A8;
    public static SKMaskFormat ThreeD;
    public static SKMaskFormat Argb32;
    public static SKMaskFormat Lcd16;
}
public class SkiaSharp.SKMatrix : ValueType {
    private float scaleX;
    private float skewX;
    private float transX;
    private float skewY;
    private float scaleY;
    private float transY;
    private float persp0;
    private float persp1;
    private float persp2;
    private static float degToRad;
    public float ScaleX { get; public set; }
    public float SkewX { get; public set; }
    public float TransX { get; public set; }
    public float SkewY { get; public set; }
    public float ScaleY { get; public set; }
    public float TransY { get; public set; }
    public float Persp0 { get; public set; }
    public float Persp1 { get; public set; }
    public float Persp2 { get; public set; }
    public Single[] Values { get; public set; }
    public float get_ScaleX();
    public void set_ScaleX(float value);
    public float get_SkewX();
    public void set_SkewX(float value);
    public float get_TransX();
    public void set_TransX(float value);
    public float get_SkewY();
    public void set_SkewY(float value);
    public float get_ScaleY();
    public void set_ScaleY(float value);
    public float get_TransY();
    public void set_TransY(float value);
    public float get_Persp0();
    public void set_Persp0(float value);
    public float get_Persp1();
    public void set_Persp1(float value);
    public float get_Persp2();
    public void set_Persp2(float value);
    public Single[] get_Values();
    public void set_Values(Single[] value);
    public void GetValues(Single[] values);
    private static float sdot(float a, float b, float c, float d);
    private static float scross(float a, float b, float c, float d);
    public static SKMatrix MakeIdentity();
    public void SetScaleTranslate(float sx, float sy, float tx, float ty);
    public static SKMatrix MakeScale(float sx, float sy);
    public static SKMatrix MakeScale(float sx, float sy, float pivotX, float pivotY);
    public static SKMatrix MakeTranslation(float dx, float dy);
    public static SKMatrix MakeRotation(float radians);
    public static SKMatrix MakeRotation(float radians, float pivotx, float pivoty);
    public static SKMatrix MakeRotationDegrees(float degrees);
    public static SKMatrix MakeRotationDegrees(float degrees, float pivotx, float pivoty);
    private static void SetSinCos(SKMatrix& matrix, float sin, float cos);
    private static void SetSinCos(SKMatrix& matrix, float sin, float cos, float pivotx, float pivoty);
    public static void Rotate(SKMatrix& matrix, float radians, float pivotx, float pivoty);
    public static void RotateDegrees(SKMatrix& matrix, float degrees, float pivotx, float pivoty);
    public static void Rotate(SKMatrix& matrix, float radians);
    public static void RotateDegrees(SKMatrix& matrix, float degrees);
    public static SKMatrix MakeSkew(float sx, float sy);
    public bool TryInvert(SKMatrix& inverse);
    public static void Concat(SKMatrix& target, SKMatrix first, SKMatrix second);
    public static void Concat(SKMatrix& target, SKMatrix& first, SKMatrix& second);
    public static void PreConcat(SKMatrix& target, SKMatrix matrix);
    public static void PreConcat(SKMatrix& target, SKMatrix& matrix);
    public static void PostConcat(SKMatrix& target, SKMatrix matrix);
    public static void PostConcat(SKMatrix& target, SKMatrix& matrix);
    public static void MapRect(SKMatrix& matrix, SKRect& dest, SKRect& source);
    public SKRect MapRect(SKRect source);
    public void MapPoints(SKPoint[] result, SKPoint[] points);
    public SKPoint[] MapPoints(SKPoint[] points);
    public void MapVectors(SKPoint[] result, SKPoint[] vectors);
    public SKPoint[] MapVectors(SKPoint[] vectors);
    public SKPoint MapPoint(SKPoint point);
    public SKPoint MapPoint(float x, float y);
    public SKPoint MapVector(float x, float y);
    public float MapRadius(float radius);
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKMatrix44 : SKObject {
    public SKMatrix Matrix { get; }
    public SKMatrix44TypeMask Type { get; }
    public float Item { get; public set; }
    [PreserveAttribute]
internal SKMatrix44(IntPtr x, bool owns);
    public SKMatrix44(SKMatrix44 src);
    public SKMatrix44(SKMatrix44 a, SKMatrix44 b);
    public SKMatrix44(SKMatrix src);
    protected virtual void Dispose(bool disposing);
    public static SKMatrix44 CreateIdentity();
    public static SKMatrix44 CreateTranslate(float x, float y, float z);
    public static SKMatrix44 CreateScale(float x, float y, float z);
    public static SKMatrix44 CreateRotation(float x, float y, float z, float radians);
    public static SKMatrix44 CreateRotationDegrees(float x, float y, float z, float degrees);
    public static SKMatrix44 FromRowMajor(Single[] src);
    public static SKMatrix44 FromColumnMajor(Single[] src);
    public static bool Equal(SKMatrix44 left, SKMatrix44 right);
    public SKMatrix get_Matrix();
    public SKMatrix44TypeMask get_Type();
    public void SetIdentity();
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public Single[] ToColumnMajor();
    public void ToColumnMajor(Single[] dst);
    public Single[] ToRowMajor();
    public void ToRowMajor(Single[] dst);
    public void SetColumnMajor(Single[] src);
    public void SetRowMajor(Single[] src);
    public void SetTranslate(float dx, float dy, float dz);
    public void PreTranslate(float dx, float dy, float dz);
    public void PostTranslate(float dx, float dy, float dz);
    public void SetScale(float sx, float sy, float sz);
    public void PreScale(float sx, float sy, float sz);
    public void PostScale(float sx, float sy, float sz);
    public void SetRotationAboutDegrees(float x, float y, float z, float degrees);
    public void SetRotationAbout(float x, float y, float z, float radians);
    public void SetRotationAboutUnit(float x, float y, float z, float radians);
    public void SetConcat(SKMatrix44 a, SKMatrix44 b);
    public void PreConcat(SKMatrix44 m);
    public void PostConcat(SKMatrix44 m);
    public SKMatrix44 Invert();
    public bool Invert(SKMatrix44 inverse);
    public void Transpose();
    public Single[] MapScalars(float x, float y, float z, float w);
    public Single[] MapScalars(Single[] srcVector4);
    public void MapScalars(Single[] srcVector4, Single[] dstVector4);
    public SKPoint MapPoint(SKPoint src);
    public SKPoint[] MapPoints(SKPoint[] src);
    public Single[] MapVector2(Single[] src2);
    public void MapVector2(Single[] src2, Single[] dst4);
    public bool Preserves2DAxisAlignment(float epsilon);
    public double Determinant();
}
[FlagsAttribute]
public enum SkiaSharp.SKMatrix44TypeMask : Enum {
    public int value__;
    public static SKMatrix44TypeMask Identity;
    public static SKMatrix44TypeMask Translate;
    public static SKMatrix44TypeMask Scale;
    public static SKMatrix44TypeMask Affine;
    public static SKMatrix44TypeMask Perspective;
}
public enum SkiaSharp.SKMatrixConvolutionTileMode : Enum {
    public int value__;
    public static SKMatrixConvolutionTileMode Clamp;
    public static SKMatrixConvolutionTileMode Repeat;
    public static SKMatrixConvolutionTileMode ClampToBlack;
}
public class SkiaSharp.SKMemoryStream : SKStreamMemory {
    [PreserveAttribute]
internal SKMemoryStream(IntPtr handle, bool owns);
    public SKMemoryStream(ulong length);
    internal SKMemoryStream(IntPtr data, IntPtr length, bool copyData);
    public SKMemoryStream(SKData data);
    public SKMemoryStream(Byte[] data);
    protected virtual void Dispose(bool disposing);
    internal void SetMemory(IntPtr data, IntPtr length, bool copyData);
    internal void SetMemory(Byte[] data, IntPtr length, bool copyData);
    public void SetMemory(Byte[] data);
}
public class SkiaSharp.SKNativeObject : object {
    private bool zero;
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    public IntPtr Handle { get; protected set; }
    internal SKNativeObject(IntPtr handle);
    internal SKNativeObject(IntPtr handle, bool zero);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public virtual IntPtr get_Handle();
    [CompilerGeneratedAttribute]
protected virtual void set_Handle(IntPtr value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public abstract class SkiaSharp.SKObject : SKNativeObject {
    private static Dictionary`2<IntPtr, WeakReference> instances;
    private List`1<SKObject> ownedObjects;
    private int referenceCount;
    private bool ownsHandle;
    protected bool OwnsHandle { get; private set; }
    public IntPtr Handle { get; protected set; }
    [PreserveAttribute]
internal SKObject(IntPtr handle, bool owns);
    private static SKObject();
    protected bool get_OwnsHandle();
    private void set_OwnsHandle(bool value);
    public virtual IntPtr get_Handle();
    protected virtual void set_Handle(IntPtr value);
    protected virtual void Dispose(bool disposing);
    internal static TSkiaObject GetObject(IntPtr handle, bool owns);
    internal static void RegisterHandle(IntPtr handle, SKObject instance);
    internal static bool DeregisterHandle(IntPtr handle, SKObject instance);
    internal void SetDisposeChild(SKObject child);
    private void TakeOwnership(SKObject obj);
    internal void RevokeOwnership(SKObject owner);
    internal static int SizeOf();
    internal T PtrToStructure(IntPtr intPtr);
    internal T[] PtrToStructureArray(IntPtr intPtr, int count);
    internal T PtrToStructure(IntPtr intPtr, int index);
}
public class SkiaSharp.SKPaint : SKObject {
    public bool IsAntialias { get; public set; }
    public bool IsDither { get; public set; }
    public bool IsVerticalText { get; public set; }
    public bool IsLinearText { get; public set; }
    public bool SubpixelText { get; public set; }
    public bool LcdRenderText { get; public set; }
    public bool IsEmbeddedBitmapText { get; public set; }
    public bool IsAutohinted { get; public set; }
    public SKPaintHinting HintingLevel { get; public set; }
    public bool FakeBoldText { get; public set; }
    public bool DeviceKerningEnabled { get; public set; }
    public bool IsStroke { get; public set; }
    public SKPaintStyle Style { get; public set; }
    public SKColor Color { get; public set; }
    public float StrokeWidth { get; public set; }
    public float StrokeMiter { get; public set; }
    public SKStrokeCap StrokeCap { get; public set; }
    public SKStrokeJoin StrokeJoin { get; public set; }
    public SKShader Shader { get; public set; }
    public SKMaskFilter MaskFilter { get; public set; }
    public SKColorFilter ColorFilter { get; public set; }
    public SKImageFilter ImageFilter { get; public set; }
    public SKBlendMode BlendMode { get; public set; }
    public SKFilterQuality FilterQuality { get; public set; }
    public SKTypeface Typeface { get; public set; }
    public float TextSize { get; public set; }
    public SKTextAlign TextAlign { get; public set; }
    public SKTextEncoding TextEncoding { get; public set; }
    public float TextScaleX { get; public set; }
    public float TextSkewX { get; public set; }
    public SKPathEffect PathEffect { get; public set; }
    public SKFontMetrics FontMetrics { get; }
    public float FontSpacing { get; }
    [PreserveAttribute]
internal SKPaint(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public bool get_IsAntialias();
    public void set_IsAntialias(bool value);
    public bool get_IsDither();
    public void set_IsDither(bool value);
    public bool get_IsVerticalText();
    public void set_IsVerticalText(bool value);
    public bool get_IsLinearText();
    public void set_IsLinearText(bool value);
    public bool get_SubpixelText();
    public void set_SubpixelText(bool value);
    public bool get_LcdRenderText();
    public void set_LcdRenderText(bool value);
    public bool get_IsEmbeddedBitmapText();
    public void set_IsEmbeddedBitmapText(bool value);
    public bool get_IsAutohinted();
    public void set_IsAutohinted(bool value);
    public SKPaintHinting get_HintingLevel();
    public void set_HintingLevel(SKPaintHinting value);
    public bool get_FakeBoldText();
    public void set_FakeBoldText(bool value);
    public bool get_DeviceKerningEnabled();
    public void set_DeviceKerningEnabled(bool value);
    public bool get_IsStroke();
    public void set_IsStroke(bool value);
    public SKPaintStyle get_Style();
    public void set_Style(SKPaintStyle value);
    public SKColor get_Color();
    public void set_Color(SKColor value);
    public float get_StrokeWidth();
    public void set_StrokeWidth(float value);
    public float get_StrokeMiter();
    public void set_StrokeMiter(float value);
    public SKStrokeCap get_StrokeCap();
    public void set_StrokeCap(SKStrokeCap value);
    public SKStrokeJoin get_StrokeJoin();
    public void set_StrokeJoin(SKStrokeJoin value);
    public SKShader get_Shader();
    public void set_Shader(SKShader value);
    public SKMaskFilter get_MaskFilter();
    public void set_MaskFilter(SKMaskFilter value);
    public SKColorFilter get_ColorFilter();
    public void set_ColorFilter(SKColorFilter value);
    public SKImageFilter get_ImageFilter();
    public void set_ImageFilter(SKImageFilter value);
    public SKBlendMode get_BlendMode();
    public void set_BlendMode(SKBlendMode value);
    public SKFilterQuality get_FilterQuality();
    public void set_FilterQuality(SKFilterQuality value);
    public SKTypeface get_Typeface();
    public void set_Typeface(SKTypeface value);
    public float get_TextSize();
    public void set_TextSize(float value);
    public SKTextAlign get_TextAlign();
    public void set_TextAlign(SKTextAlign value);
    public SKTextEncoding get_TextEncoding();
    public void set_TextEncoding(SKTextEncoding value);
    public float get_TextScaleX();
    public void set_TextScaleX(float value);
    public float get_TextSkewX();
    public void set_TextSkewX(float value);
    public SKPathEffect get_PathEffect();
    public void set_PathEffect(SKPathEffect value);
    public float MeasureText(string text);
    public float MeasureText(Byte[] text);
    public float MeasureText(IntPtr buffer, IntPtr length);
    public float MeasureText(string text, SKRect& bounds);
    public float MeasureText(Byte[] text, SKRect& bounds);
    public float MeasureText(IntPtr buffer, IntPtr length, SKRect& bounds);
    public long BreakText(string text, float maxWidth);
    public long BreakText(string text, float maxWidth, Single& measuredWidth);
    public long BreakText(string text, float maxWidth, Single& measuredWidth, String& measuredText);
    public long BreakText(Byte[] text, float maxWidth);
    public long BreakText(Byte[] text, float maxWidth, Single& measuredWidth);
    public long BreakText(IntPtr buffer, IntPtr length, float maxWidth);
    public long BreakText(IntPtr buffer, IntPtr length, float maxWidth, Single& measuredWidth);
    public SKPath GetTextPath(string text, float x, float y);
    public SKPath GetTextPath(Byte[] text, float x, float y);
    public SKPath GetTextPath(IntPtr buffer, IntPtr length, float x, float y);
    public SKPath GetTextPath(string text, SKPoint[] points);
    public SKPath GetTextPath(Byte[] text, SKPoint[] points);
    public SKPath GetTextPath(IntPtr buffer, IntPtr length, SKPoint[] points);
    public bool GetFillPath(SKPath src, SKPath dst, SKRect cullRect, float resScale);
    public bool GetFillPath(SKPath src, SKPath dst, float resScale);
    public SKFontMetrics get_FontMetrics();
    public float get_FontSpacing();
    public float GetFontMetrics(SKFontMetrics& metrics, float scale);
    public SKPaint Clone();
}
public enum SkiaSharp.SKPaintHinting : Enum {
    public int value__;
    public static SKPaintHinting NoHinting;
    public static SKPaintHinting Slight;
    public static SKPaintHinting Normal;
    public static SKPaintHinting Full;
}
public enum SkiaSharp.SKPaintStyle : Enum {
    public int value__;
    public static SKPaintStyle Fill;
    public static SKPaintStyle Stroke;
    public static SKPaintStyle StrokeAndFill;
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKPath : SKObject {
    public SKPathFillType FillType { get; public set; }
    public SKPathConvexity Convexity { get; public set; }
    public bool IsConvex { get; }
    public bool IsConcave { get; }
    public bool IsEmpty { get; }
    public SKPathSegmentMask SegmentMasks { get; }
    public int VerbCount { get; }
    public int PointCount { get; }
    public SKPoint Item { get; }
    public SKPoint[] Points { get; }
    public SKPoint LastPoint { get; }
    public SKRect Bounds { get; }
    public SKRect TightBounds { get; }
    [PreserveAttribute]
internal SKPath(IntPtr handle, bool owns);
    public SKPath(SKPath path);
    protected virtual void Dispose(bool disposing);
    public SKPathFillType get_FillType();
    public void set_FillType(SKPathFillType value);
    public SKPathConvexity get_Convexity();
    public void set_Convexity(SKPathConvexity value);
    public bool get_IsConvex();
    public bool get_IsConcave();
    public bool get_IsEmpty();
    public SKPathSegmentMask get_SegmentMasks();
    public int get_VerbCount();
    public int get_PointCount();
    public SKPoint get_Item(int index);
    public SKPoint[] get_Points();
    public SKPoint get_LastPoint();
    public SKRect get_Bounds();
    public SKRect get_TightBounds();
    public SKPoint GetPoint(int index);
    public SKPoint[] GetPoints(int max);
    public int GetPoints(SKPoint[] points, int max);
    public bool Contains(float x, float y);
    public void Offset(SKPoint offset);
    public void Offset(float dx, float dy);
    public void MoveTo(SKPoint point);
    public void MoveTo(float x, float y);
    public void RMoveTo(SKPoint point);
    public void RMoveTo(float dx, float dy);
    public void LineTo(SKPoint point);
    public void LineTo(float x, float y);
    public void RLineTo(SKPoint point);
    public void RLineTo(float dx, float dy);
    public void QuadTo(SKPoint point0, SKPoint point1);
    public void QuadTo(float x0, float y0, float x1, float y1);
    public void RQuadTo(SKPoint point0, SKPoint point1);
    public void RQuadTo(float dx0, float dy0, float dx1, float dy1);
    public void ConicTo(SKPoint point0, SKPoint point1, float w);
    public void ConicTo(float x0, float y0, float x1, float y1, float w);
    public void RConicTo(SKPoint point0, SKPoint point1, float w);
    public void RConicTo(float dx0, float dy0, float dx1, float dy1, float w);
    public void CubicTo(SKPoint point0, SKPoint point1, SKPoint point2);
    public void CubicTo(float x0, float y0, float x1, float y1, float x2, float y2);
    public void RCubicTo(SKPoint point0, SKPoint point1, SKPoint point2);
    public void RCubicTo(float dx0, float dy0, float dx1, float dy1, float dx2, float dy2);
    public void ArcTo(SKPoint r, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, SKPoint xy);
    public void ArcTo(float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public void ArcTo(SKRect oval, float startAngle, float sweepAngle, bool forceMoveTo);
    public void ArcTo(SKPoint point1, SKPoint point2, float radius);
    public void ArcTo(float x1, float y1, float x2, float y2, float radius);
    public void RArcTo(SKPoint r, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, SKPoint xy);
    public void RArcTo(float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public void Close();
    public void Rewind();
    public void Reset();
    public void AddRect(SKRect rect, SKPathDirection direction);
    public void AddRect(SKRect rect, SKPathDirection direction, UInt32 startIndex);
    public void AddOval(SKRect rect, SKPathDirection direction);
    public void AddArc(SKRect oval, float startAngle, float sweepAngle);
    public bool GetBounds(SKRect& rect);
    public SKRect ComputeTightBounds();
    public void Transform(SKMatrix matrix);
    public void AddPath(SKPath other, float dx, float dy, SKPathAddMode mode);
    public void AddPath(SKPath other, SKMatrix& matrix, SKPathAddMode mode);
    public void AddPath(SKPath other, SKPathAddMode mode);
    public void AddPathReverse(SKPath other);
    public void AddRoundedRect(SKRect rect, float rx, float ry, SKPathDirection dir);
    public void AddCircle(float x, float y, float radius, SKPathDirection dir);
    public void AddPoly(SKPoint[] points, bool close);
    public Iterator CreateIterator(bool forceClose);
    public RawIterator CreateRawIterator();
    public bool Op(SKPath other, SKPathOp op, SKPath result);
    public SKPath Op(SKPath other, SKPathOp op);
    public bool Simplify(SKPath result);
    public SKPath Simplify();
    public bool GetTightBounds(SKRect& result);
    public string ToSvgPathData();
    public static SKPath ParseSvgPathData(string svgPath);
    public static SKPoint[] ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, int pow2);
    public static int ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, SKPoint[]& pts, int pow2);
    public static int ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, SKPoint[] pts, int pow2);
}
public enum SkiaSharp.SKPath1DPathEffectStyle : Enum {
    public int value__;
    public static SKPath1DPathEffectStyle Translate;
    public static SKPath1DPathEffectStyle Rotate;
    public static SKPath1DPathEffectStyle Morph;
}
public enum SkiaSharp.SKPathAddMode : Enum {
    public int value__;
    public static SKPathAddMode Append;
    public static SKPathAddMode Extend;
}
public enum SkiaSharp.SKPathArcSize : Enum {
    public int value__;
    public static SKPathArcSize Small;
    public static SKPathArcSize Large;
}
public enum SkiaSharp.SKPathConvexity : Enum {
    public int value__;
    public static SKPathConvexity Unknown;
    public static SKPathConvexity Convex;
    public static SKPathConvexity Concave;
}
public enum SkiaSharp.SKPathDirection : Enum {
    public int value__;
    public static SKPathDirection Clockwise;
    public static SKPathDirection CounterClockwise;
}
public class SkiaSharp.SKPathEffect : SKObject {
    [PreserveAttribute]
internal SKPathEffect(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKPathEffect CreateCompose(SKPathEffect outer, SKPathEffect inner);
    public static SKPathEffect CreateSum(SKPathEffect first, SKPathEffect second);
    public static SKPathEffect CreateDiscrete(float segLength, float deviation, UInt32 seedAssist);
    public static SKPathEffect CreateCorner(float radius);
    public static SKPathEffect CreateArcTo(float radius);
    public static SKPathEffect Create1DPath(SKPath path, float advance, float phase, SKPath1DPathEffectStyle style);
    public static SKPathEffect Create2DLine(float width, SKMatrix matrix);
    public static SKPathEffect Create2DPath(SKMatrix matrix, SKPath path);
    public static SKPathEffect CreateDash(Single[] intervals, float phase);
}
public enum SkiaSharp.SKPathFillType : Enum {
    public int value__;
    public static SKPathFillType Winding;
    public static SKPathFillType EvenOdd;
    public static SKPathFillType InverseWinding;
    public static SKPathFillType InverseEvenOdd;
}
public class SkiaSharp.SKPathMeasure : SKObject {
    public float Length { get; }
    public bool IsClosed { get; }
    [PreserveAttribute]
internal SKPathMeasure(IntPtr handle, bool owns);
    public SKPathMeasure(SKPath path, bool forceClosed, float resScale);
    protected virtual void Dispose(bool disposing);
    public float get_Length();
    public bool get_IsClosed();
    public void SetPath(SKPath path, bool forceClosed);
    public bool GetPositionAndTangent(float distance, SKPoint& position, SKPoint& tangent);
    public bool GetPosition(float distance, SKPoint& position);
    public bool GetTangent(float distance, SKPoint& tangent);
    public bool GetMatrix(float distance, SKMatrix& matrix, SKPathMeasureMatrixFlags flags);
    public bool GetSegment(float start, float stop, SKPath dst, bool startWithMoveTo);
    public bool NextContour();
}
[FlagsAttribute]
public enum SkiaSharp.SKPathMeasureMatrixFlags : Enum {
    public int value__;
    public static SKPathMeasureMatrixFlags GetPosition;
    public static SKPathMeasureMatrixFlags GetTangent;
    public static SKPathMeasureMatrixFlags GetPositionAndTangent;
}
public enum SkiaSharp.SKPathOp : Enum {
    public int value__;
    public static SKPathOp Difference;
    public static SKPathOp Intersect;
    public static SKPathOp Union;
    public static SKPathOp Xor;
    public static SKPathOp ReverseDifference;
}
[FlagsAttribute]
public enum SkiaSharp.SKPathSegmentMask : Enum {
    public int value__;
    public static SKPathSegmentMask Line;
    public static SKPathSegmentMask Quad;
    public static SKPathSegmentMask Conic;
    public static SKPathSegmentMask Cubic;
}
public enum SkiaSharp.SKPathVerb : Enum {
    public int value__;
    public static SKPathVerb Move;
    public static SKPathVerb Line;
    public static SKPathVerb Quad;
    public static SKPathVerb Conic;
    public static SKPathVerb Cubic;
    public static SKPathVerb Close;
    public static SKPathVerb Done;
}
public class SkiaSharp.SKPicture : SKObject {
    public UInt32 UniqueId { get; }
    public SKRect CullRect { get; }
    [PreserveAttribute]
internal SKPicture(IntPtr h, bool owns);
    protected virtual void Dispose(bool disposing);
    public UInt32 get_UniqueId();
    public SKRect get_CullRect();
}
public class SkiaSharp.SKPictureRecorder : SKObject {
    public SKCanvas RecordingCanvas { get; }
    [PreserveAttribute]
internal SKPictureRecorder(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public SKCanvas BeginRecording(SKRect cullRect);
    public SKPicture EndRecording();
    public SKCanvas get_RecordingCanvas();
}
public enum SkiaSharp.SKPixelGeometry : Enum {
    public int value__;
    public static SKPixelGeometry Unknown;
    public static SKPixelGeometry RgbHorizontal;
    public static SKPixelGeometry BgrHorizontal;
    public static SKPixelGeometry RgbVertical;
    public static SKPixelGeometry BgrVertical;
}
public class SkiaSharp.SKPixelSerializer : SKObject {
    [PreserveAttribute]
internal SKPixelSerializer(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public bool UseEncodedData(IntPtr data, ulong length);
    public SKData Encode(SKPixmap pixmap);
    public static SKPixelSerializer Create(Func`2<SKPixmap, SKData> onEncode);
    public static SKPixelSerializer Create(Func`3<IntPtr, IntPtr, bool> onUseEncodedData, Func`2<SKPixmap, SKData> onEncode);
}
public class SkiaSharp.SKPixmap : SKObject {
    private static string UnableToCreateInstanceMessage;
    public SKImageInfo Info { get; }
    public int Width { get; }
    public int Height { get; }
    public SKColorType ColorType { get; }
    public SKAlphaType AlphaType { get; }
    public SKColorSpace ColorSpace { get; }
    public int BytesPerPixel { get; }
    public int RowBytes { get; }
    public SKColorTable ColorTable { get; }
    [PreserveAttribute]
internal SKPixmap(IntPtr handle, bool owns);
    public SKPixmap(SKImageInfo info, IntPtr addr);
    public SKPixmap(SKImageInfo info, IntPtr addr, int rowBytes, SKColorTable ctable);
    protected virtual void Dispose(bool disposing);
    public void Reset();
    public void Reset(SKImageInfo info, IntPtr addr, int rowBytes, SKColorTable ctable);
    public SKImageInfo get_Info();
    public int get_Width();
    public int get_Height();
    public SKColorType get_ColorType();
    public SKAlphaType get_AlphaType();
    public SKColorSpace get_ColorSpace();
    public int get_BytesPerPixel();
    public int get_RowBytes();
    public IntPtr GetPixels();
    public SKColorTable get_ColorTable();
    public static bool Resize(SKPixmap dst, SKPixmap src, SKBitmapResizeMethod method);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY);
    public bool ReadPixels(SKPixmap pixmap);
    public SKData Encode(SKEncodedImageFormat encoder, int quality);
    public bool Encode(SKWStream dst, SKEncodedImageFormat encoder, int quality);
    public static bool Encode(SKWStream dst, SKPixmap src, SKEncodedImageFormat encoder, int quality);
    public SKPixmap WithColorType(SKColorType newColorType);
    public SKPixmap WithColorSpace(SKColorSpace newColorSpace);
    public SKPixmap WithAlphaType(SKAlphaType newAlphaType);
}
public class SkiaSharp.SKPMColor : ValueType {
    private UInt32 color;
    public byte Alpha { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public SKPMColor(UInt32 value);
    public byte get_Alpha();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public static SKPMColor PreMultiply(SKColor color);
    public static SKColor UnPreMultiply(SKPMColor pmcolor);
    public static SKPMColor[] PreMultiply(SKColor[] colors);
    public static SKColor[] UnPreMultiply(SKPMColor[] pmcolors);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(SKPMColor left, SKPMColor right);
    public static bool op_Inequality(SKPMColor left, SKPMColor right);
    public static SKPMColor op_Explicit(SKColor color);
    public static SKColor op_Explicit(SKPMColor color);
    public static SKPMColor op_Implicit(UInt32 color);
    public static UInt32 op_Explicit(SKPMColor color);
    public virtual string ToString();
}
public class SkiaSharp.SKPoint : ValueType {
    private float x;
    private float y;
    public static SKPoint Empty;
    public bool IsEmpty { get; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public SKPoint(float x, float y);
    public static SKPoint op_Addition(SKPoint pt, SKSizeI sz);
    public static SKPoint op_Addition(SKPoint pt, SKSize sz);
    public static SKPoint op_Addition(SKPoint pt, SKPointI sz);
    public static SKPoint op_Addition(SKPoint pt, SKPoint sz);
    public static bool op_Equality(SKPoint left, SKPoint right);
    public static bool op_Inequality(SKPoint left, SKPoint right);
    public static SKPoint op_Subtraction(SKPoint pt, SKSizeI sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKSize sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKPointI sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKPoint sz);
    public bool get_IsEmpty();
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void Offset(SKPoint p);
    public void Offset(float dx, float dy);
    public static SKPoint Add(SKPoint pt, SKSizeI sz);
    public static SKPoint Add(SKPoint pt, SKSize sz);
    public static SKPoint Add(SKPoint pt, SKPointI sz);
    public static SKPoint Add(SKPoint pt, SKPoint sz);
    public static SKPoint Subtract(SKPoint pt, SKSizeI sz);
    public static SKPoint Subtract(SKPoint pt, SKSize sz);
    public static SKPoint Subtract(SKPoint pt, SKPointI sz);
    public static SKPoint Subtract(SKPoint pt, SKPoint sz);
}
public class SkiaSharp.SKPoint3 : ValueType {
    public static SKPoint3 Empty;
    private float x;
    private float y;
    private float z;
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Z { get; public set; }
    public bool IsEmpty { get; }
    public SKPoint3(float x, float y, float z);
    public float get_X();
    public void set_X(float value);
    public float get_Y();
    public void set_Y(float value);
    public float get_Z();
    public void set_Z(float value);
    public static SKPoint3 op_Addition(SKPoint3 pt, SKPoint3 sz);
    public static SKPoint3 op_Subtraction(SKPoint3 pt, SKPoint3 sz);
    public static bool op_Equality(SKPoint3 left, SKPoint3 right);
    public static bool op_Inequality(SKPoint3 left, SKPoint3 right);
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SKPoint3 Add(SKPoint3 pt, SKPoint3 sz);
    public static SKPoint3 Subtract(SKPoint3 pt, SKPoint3 sz);
}
public class SkiaSharp.SKPointI : ValueType {
    private int x;
    private int y;
    public static SKPointI Empty;
    public bool IsEmpty { get; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public SKPointI(SKSizeI sz);
    public SKPointI(int x, int y);
    public static SKPointI Ceiling(SKPoint value);
    public static SKPointI Round(SKPoint value);
    public static SKPointI Truncate(SKPoint value);
    public static SKPointI op_Addition(SKPointI pt, SKSizeI sz);
    public static SKPointI op_Addition(SKPointI pt, SKPointI sz);
    public static bool op_Equality(SKPointI left, SKPointI right);
    public static bool op_Inequality(SKPointI left, SKPointI right);
    public static SKPointI op_Subtraction(SKPointI pt, SKSizeI sz);
    public static SKPointI op_Subtraction(SKPointI pt, SKPointI sz);
    public static SKSizeI op_Explicit(SKPointI p);
    public static SKPoint op_Implicit(SKPointI p);
    public bool get_IsEmpty();
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Offset(int dx, int dy);
    public virtual string ToString();
    public void Offset(SKPointI p);
    public static SKPointI Add(SKPointI pt, SKSizeI sz);
    public static SKPointI Add(SKPointI pt, SKPointI sz);
    public static SKPointI Subtract(SKPointI pt, SKSizeI sz);
    public static SKPointI Subtract(SKPointI pt, SKPointI sz);
}
public enum SkiaSharp.SKPointMode : Enum {
    public int value__;
    public static SKPointMode Points;
    public static SKPointMode Lines;
    public static SKPointMode Polygon;
}
public class SkiaSharp.SKRect : ValueType {
    public static SKRect Empty;
    private float left;
    private float top;
    private float right;
    private float bottom;
    public float Left { get; public set; }
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public float MidX { get; }
    public float MidY { get; }
    public float Width { get; }
    public float Height { get; }
    public bool IsEmpty { get; }
    public SKSize Size { get; public set; }
    public SKPoint Location { get; public set; }
    public SKRect Standardized { get; }
    public SKRect(float left, float top, float right, float bottom);
    public float get_Left();
    public void set_Left(float value);
    public float get_Top();
    public void set_Top(float value);
    public float get_Right();
    public void set_Right(float value);
    public float get_Bottom();
    public void set_Bottom(float value);
    public float get_MidX();
    public float get_MidY();
    public float get_Width();
    public float get_Height();
    public bool get_IsEmpty();
    public SKSize get_Size();
    public void set_Size(SKSize value);
    public SKPoint get_Location();
    public void set_Location(SKPoint value);
    public SKRect get_Standardized();
    public SKRect AspectFit(SKSize size);
    public SKRect AspectFill(SKSize size);
    private SKRect AspectResize(SKSize size, bool fit);
    public static SKRect Inflate(SKRect rect, float x, float y);
    public void Inflate(SKSize size);
    public void Inflate(float x, float y);
    public static SKRect Intersect(SKRect a, SKRect b);
    public void Intersect(SKRect rect);
    public static SKRect Union(SKRect a, SKRect b);
    public void Union(SKRect rect);
    public static bool op_Equality(SKRect left, SKRect right);
    public static bool op_Inequality(SKRect left, SKRect right);
    public static SKRect op_Implicit(SKRectI r);
    public bool Contains(float x, float y);
    public bool Contains(SKPoint pt);
    public bool Contains(SKRect rect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IntersectsWith(SKRect rect);
    public bool IntersectsWithInclusive(SKRect rect);
    public void Offset(float x, float y);
    public void Offset(SKPoint pos);
    public virtual string ToString();
    public static SKRect Create(SKPoint location, SKSize size);
    public static SKRect Create(SKSize size);
    public static SKRect Create(float width, float height);
    public static SKRect Create(float x, float y, float width, float height);
}
public class SkiaSharp.SKRectI : ValueType {
    public static SKRectI Empty;
    private int left;
    private int top;
    private int right;
    private int bottom;
    public int Left { get; public set; }
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Bottom { get; public set; }
    public int MidX { get; }
    public int MidY { get; }
    public int Width { get; }
    public int Height { get; }
    public bool IsEmpty { get; }
    public SKSizeI Size { get; public set; }
    public SKPointI Location { get; public set; }
    public SKRectI Standardized { get; }
    public SKRectI(int left, int top, int right, int bottom);
    public int get_Left();
    public void set_Left(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public int get_MidX();
    public int get_MidY();
    public int get_Width();
    public int get_Height();
    public bool get_IsEmpty();
    public SKSizeI get_Size();
    public void set_Size(SKSizeI value);
    public SKPointI get_Location();
    public void set_Location(SKPointI value);
    public SKRectI get_Standardized();
    public SKRectI AspectFit(SKSizeI size);
    public SKRectI AspectFill(SKSizeI size);
    public static SKRectI Ceiling(SKRect value);
    public static SKRectI Ceiling(SKRect value, bool outwards);
    public static SKRectI Inflate(SKRectI rect, int x, int y);
    public void Inflate(SKSizeI size);
    public void Inflate(int width, int height);
    public static SKRectI Intersect(SKRectI a, SKRectI b);
    public void Intersect(SKRectI rect);
    public static SKRectI Round(SKRect value);
    public static SKRectI Floor(SKRect value);
    public static SKRectI Floor(SKRect value, bool inwards);
    public static SKRectI Truncate(SKRect value);
    public static SKRectI Union(SKRectI a, SKRectI b);
    public void Union(SKRectI rect);
    public bool Contains(int x, int y);
    public bool Contains(SKPointI pt);
    public bool Contains(SKRectI rect);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IntersectsWith(SKRectI rect);
    private bool IntersectsWithInclusive(SKRectI r);
    public void Offset(int x, int y);
    public void Offset(SKPointI pos);
    public virtual string ToString();
    public static bool op_Equality(SKRectI left, SKRectI right);
    public static bool op_Inequality(SKRectI left, SKRectI right);
    public static SKRectI Create(SKSizeI size);
    public static SKRectI Create(SKPointI location, SKSizeI size);
    public static SKRectI Create(int width, int height);
    public static SKRectI Create(int x, int y, int width, int height);
}
public class SkiaSharp.SKRegion : SKObject {
    public SKRectI Bounds { get; }
    [PreserveAttribute]
internal SKRegion(IntPtr handle, bool owns);
    public SKRegion(SKRegion region);
    public SKRectI get_Bounds();
    public bool Contains(SKRegion src);
    public bool Contains(SKPointI xy);
    public bool Contains(int x, int y);
    public bool Intersects(SKRegion region);
    public bool Intersects(SKRectI rect);
    public bool SetRegion(SKRegion region);
    public bool SetRect(SKRectI rect);
    public bool SetPath(SKPath path, SKRegion clip);
    public bool SetPath(SKPath path);
    public bool Op(SKRectI rect, SKRegionOperation op);
    public bool Op(int left, int top, int right, int bottom, SKRegionOperation op);
    public bool Op(SKRegion region, SKRegionOperation op);
}
public enum SkiaSharp.SKRegionOperation : Enum {
    public int value__;
    public static SKRegionOperation Difference;
    public static SKRegionOperation Intersect;
    public static SKRegionOperation Union;
    public static SKRegionOperation XOR;
    public static SKRegionOperation ReverseDifference;
    public static SKRegionOperation Replace;
}
public class SkiaSharp.SKShader : SKObject {
    [PreserveAttribute]
internal SKShader(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKShader CreateEmpty();
    public static SKShader CreateColor(SKColor color);
    public static SKShader CreateBitmap(SKBitmap src, SKShaderTileMode tmx, SKShaderTileMode tmy);
    public static SKShader CreateBitmap(SKBitmap src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix);
    public static SKShader CreateColorFilter(SKShader shader, SKColorFilter filter);
    public static SKShader CreateLocalMatrix(SKShader shader, SKMatrix localMatrix);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos, SKMatrix localMatrix);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreatePerlinNoiseFractalNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed);
    public static SKShader CreatePerlinNoiseFractalNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI tileSize);
    public static SKShader CreatePerlinNoiseTurbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed);
    public static SKShader CreatePerlinNoiseTurbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI tileSize);
    public static SKShader CreateCompose(SKShader shaderA, SKShader shaderB);
    public static SKShader CreateCompose(SKShader shaderA, SKShader shaderB, SKBlendMode mode);
}
public enum SkiaSharp.SKShaderTileMode : Enum {
    public int value__;
    public static SKShaderTileMode Clamp;
    public static SKShaderTileMode Repeat;
    public static SKShaderTileMode Mirror;
}
internal class SkiaSharp.SKSimplePixelSerializer : SKManagedPixelSerializer {
    private Func`3<IntPtr, IntPtr, bool> onUseEncodedData;
    private Func`2<SKPixmap, SKData> onEncode;
    public SKSimplePixelSerializer(Func`3<IntPtr, IntPtr, bool> onUseEncodedData, Func`2<SKPixmap, SKData> onEncode);
    protected virtual SKData OnEncode(SKPixmap pixmap);
    protected virtual bool OnUseEncodedData(IntPtr data, IntPtr length);
}
public class SkiaSharp.SKSize : ValueType {
    private float width;
    private float height;
    public static SKSize Empty;
    public bool IsEmpty { get; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public SKSize(float width, float height);
    public SKSize(SKPoint pt);
    public bool get_IsEmpty();
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public SKPoint ToPoint();
    public SKSizeI ToSizeI();
    public static SKSize op_Addition(SKSize sz1, SKSize sz2);
    public static SKSize op_Subtraction(SKSize sz1, SKSize sz2);
    public static bool op_Equality(SKSize sz1, SKSize sz2);
    public static bool op_Inequality(SKSize sz1, SKSize sz2);
    public static SKPoint op_Explicit(SKSize size);
    public static SKSize op_Implicit(SKSizeI size);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SKSize Add(SKSize sz1, SKSize sz2);
    public static SKSize Subtract(SKSize sz1, SKSize sz2);
}
public class SkiaSharp.SKSizeI : ValueType {
    private int width;
    private int height;
    public static SKSizeI Empty;
    public bool IsEmpty { get; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public SKSizeI(int width, int height);
    public SKSizeI(SKPointI pt);
    public bool get_IsEmpty();
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public SKPointI ToPointI();
    public static SKSizeI op_Addition(SKSizeI sz1, SKSizeI sz2);
    public static SKSizeI op_Subtraction(SKSizeI sz1, SKSizeI sz2);
    public static bool op_Equality(SKSizeI sz1, SKSizeI sz2);
    public static bool op_Inequality(SKSizeI sz1, SKSizeI sz2);
    public static SKPointI op_Explicit(SKSizeI size);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SKSizeI Add(SKSizeI sz1, SKSizeI sz2);
    public static SKSizeI Subtract(SKSizeI sz1, SKSizeI sz2);
}
public abstract class SkiaSharp.SKStream : SKObject {
    public bool IsAtEnd { get; }
    public bool HasPosition { get; }
    public int Position { get; public set; }
    public bool HasLength { get; }
    public int Length { get; }
    internal SKStream(IntPtr handle, bool owns);
    public bool get_IsAtEnd();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public int Read(Byte[] buffer, int size);
    public int Read(IntPtr buffer, int size);
    public int Peek(IntPtr buffer, int size);
    public int Skip(int size);
    public bool Rewind();
    public bool Seek(int position);
    public bool Move(long offset);
    public IntPtr GetMemoryBase();
    public bool get_HasPosition();
    public int get_Position();
    public void set_Position(int value);
    public bool get_HasLength();
    public int get_Length();
}
public abstract class SkiaSharp.SKStreamAsset : SKStreamSeekable {
    internal SKStreamAsset(IntPtr handle, bool owns);
}
internal class SkiaSharp.SKStreamAssetImplementation : SKStreamAsset {
    [PreserveAttribute]
internal SKStreamAssetImplementation(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
}
public abstract class SkiaSharp.SKStreamMemory : SKStreamAsset {
    internal SKStreamMemory(IntPtr handle, bool owns);
}
public abstract class SkiaSharp.SKStreamRewindable : SKStream {
    internal SKStreamRewindable(IntPtr handle, bool owns);
}
public abstract class SkiaSharp.SKStreamSeekable : SKStreamRewindable {
    internal SKStreamSeekable(IntPtr handle, bool owns);
}
internal class SkiaSharp.SKString : SKObject {
    [PreserveAttribute]
internal SKString(IntPtr handle, bool owns);
    public SKString(Byte[] src, long length);
    public SKString(Byte[] src);
    public SKString(string str);
    public virtual string ToString();
    public static string op_Explicit(SKString skString);
    internal static SKString Create(string str);
    protected virtual void Dispose(bool disposing);
}
public enum SkiaSharp.SKStrokeCap : Enum {
    public int value__;
    public static SKStrokeCap Butt;
    public static SKStrokeCap Round;
    public static SKStrokeCap Square;
}
public enum SkiaSharp.SKStrokeJoin : Enum {
    public int value__;
    public static SKStrokeJoin Miter;
    public static SKStrokeJoin Round;
    public static SKStrokeJoin Bevel;
}
public class SkiaSharp.SKSurface : SKObject {
    public SKCanvas Canvas { get; }
    public SKSurfaceProps SurfaceProps { get; }
    [PreserveAttribute]
internal SKSurface(IntPtr h, bool owns);
    public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, SKSurfaceProps props);
    public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, IntPtr pixels, int rowBytes);
    public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, IntPtr pixels, int rowBytes, SKSurfaceProps props);
    public static SKSurface Create(SKImageInfo info);
    public static SKSurface Create(SKImageInfo info, SKSurfaceProps props);
    public static SKSurface Create(SKPixmap pixmap);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes);
    public static SKSurface Create(SKPixmap pixmap, SKSurfaceProps props);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRBackendRenderTargetDesc desc, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRBackendRenderTargetDesc desc);
    public static SKSurface Create(GRContext context, GRGlBackendTextureDesc desc, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRGlBackendTextureDesc desc);
    public static SKSurface CreateAsRenderTarget(GRContext context, GRGlBackendTextureDesc desc, SKSurfaceProps props);
    public static SKSurface CreateAsRenderTarget(GRContext context, GRGlBackendTextureDesc desc);
    public static SKSurface Create(GRContext context, GRBackendTextureDesc desc, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRBackendTextureDesc desc);
    public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTextureDesc desc, SKSurfaceProps props);
    public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTextureDesc desc);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info);
    protected virtual void Dispose(bool disposing);
    public SKCanvas get_Canvas();
    public SKSurfaceProps get_SurfaceProps();
    public SKImage Snapshot();
    public void Draw(SKCanvas canvas, float x, float y, SKPaint paint);
    public SKPixmap PeekPixels();
    public bool PeekPixels(SKPixmap pixmap);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
}
public class SkiaSharp.SKSurfaceProps : ValueType {
    private SKPixelGeometry pixelGeometry;
    private SKSurfacePropsFlags flags;
    public SKPixelGeometry PixelGeometry { get; public set; }
    public SKSurfacePropsFlags Flags { get; public set; }
    public SKPixelGeometry get_PixelGeometry();
    public void set_PixelGeometry(SKPixelGeometry value);
    public SKSurfacePropsFlags get_Flags();
    public void set_Flags(SKSurfacePropsFlags value);
}
[FlagsAttribute]
public enum SkiaSharp.SKSurfacePropsFlags : Enum {
    public int value__;
    public static SKSurfacePropsFlags None;
    public static SKSurfacePropsFlags UseDeviceIndependentFonts;
}
public class SkiaSharp.SKSvgCanvas : object {
    public static SKCanvas Create(SKRect bounds, SKXmlWriter writer);
}
public static class SkiaSharp.SKSwizzle : object {
    public static void SwapRedBlue(IntPtr pixels, int count);
    public static void SwapRedBlue(IntPtr dest, IntPtr src, int count);
}
public enum SkiaSharp.SKTextAlign : Enum {
    public int value__;
    public static SKTextAlign Left;
    public static SKTextAlign Center;
    public static SKTextAlign Right;
}
public enum SkiaSharp.SKTextEncoding : Enum {
    public int value__;
    public static SKTextEncoding Utf8;
    public static SKTextEncoding Utf16;
    public static SKTextEncoding Utf32;
    public static SKTextEncoding GlyphId;
}
internal class SkiaSharp.SKTimeDateTimeInternal : ValueType {
    public short TimeZoneMinutes;
    public ushort Year;
    public byte Month;
    public byte DayOfWeek;
    public byte Day;
    public byte Hour;
    public byte Minute;
    public byte Second;
    public static SKTimeDateTimeInternal Create(DateTime datetime);
}
public enum SkiaSharp.SKTransferFunctionBehavior : Enum {
    public int value__;
    public static SKTransferFunctionBehavior Respect;
    public static SKTransferFunctionBehavior Ignore;
}
public class SkiaSharp.SKTypeface : SKObject {
    public string FamilyName { get; }
    public int FontWeight { get; }
    public int FontWidth { get; }
    public SKFontStyleSlant FontSlant { get; }
    public SKTypefaceStyle Style { get; }
    public int UnitsPerEm { get; }
    [PreserveAttribute]
internal SKTypeface(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKTypeface FromFamilyName(string familyName, SKTypefaceStyle style);
    public static SKTypeface FromFamilyName(string familyName, int weight, int width, SKFontStyleSlant slant);
    public static SKTypeface FromFamilyName(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant);
    public static SKTypeface FromTypeface(SKTypeface typeface, SKTypefaceStyle style);
    public static SKTypeface FromFile(string path, int index);
    public static SKTypeface FromStream(Stream stream, int index);
    public static SKTypeface FromStream(SKStreamAsset stream, int index);
    public static SKTypeface FromData(SKData data, int index);
    public int CountGlyphs(string str);
    public int CountGlyphs(IntPtr str, int strLen, SKEncoding encoding);
    public int CharsToGlyphs(string chars, UInt16[]& glyphs);
    public int CharsToGlyphs(IntPtr str, int strlen, SKEncoding encoding, UInt16[]& glyphs);
    public string get_FamilyName();
    public int get_FontWeight();
    public int get_FontWidth();
    public SKFontStyleSlant get_FontSlant();
    public SKTypefaceStyle get_Style();
    public int get_UnitsPerEm();
    public UInt32[] GetTableTags();
    public Byte[] GetTableData(UInt32 tag);
    public bool TryGetTableData(UInt32 tag, Byte[]& tableData);
    public SKStreamAsset OpenStream();
    public SKStreamAsset OpenStream(Int32& ttcIndex);
}
[FlagsAttribute]
public enum SkiaSharp.SKTypefaceStyle : Enum {
    public int value__;
    public static SKTypefaceStyle Normal;
    public static SKTypefaceStyle Bold;
    public static SKTypefaceStyle Italic;
    public static SKTypefaceStyle BoldItalic;
}
public enum SkiaSharp.SKVertexMode : Enum {
    public int value__;
    public static SKVertexMode Triangles;
    public static SKVertexMode TriangleStrip;
    public static SKVertexMode TriangleFan;
}
public class SkiaSharp.SKVertices : SKObject {
    [PreserveAttribute]
internal SKVertices(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKColor[] colors);
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKPoint[] texs, SKColor[] colors);
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKPoint[] texs, SKColor[] colors, UInt16[] indices);
}
public abstract class SkiaSharp.SKWStream : SKObject {
    public int BytesWritten { get; }
    internal SKWStream(IntPtr handle, bool owns);
    public virtual int get_BytesWritten();
    public virtual bool Write(Byte[] buffer, int size);
    public bool NewLine();
    public virtual void Flush();
    public bool Write8(byte value);
    public bool Write16(ushort value);
    public bool Write32(UInt32 value);
    public bool WriteText(string value);
    public bool WriteDecimalAsTest(int value);
    public bool WriteBigDecimalAsText(long value, int digits);
    public bool WriteHexAsText(UInt32 value, int digits);
    public bool WriteScalarAsText(float value);
    public bool WriteBool(bool value);
    public bool WriteScalar(float value);
    public bool WritePackedUInt32(UInt32 value);
    public bool WriteStream(SKStream input, int length);
    public static int GetSizeOfPackedUInt32(UInt32 value);
}
public class SkiaSharp.SKXmlStreamWriter : SKXmlWriter {
    [PreserveAttribute]
internal SKXmlStreamWriter(IntPtr h, bool owns);
    public SKXmlStreamWriter(SKWStream stream);
    protected virtual void Dispose(bool disposing);
}
public abstract class SkiaSharp.SKXmlWriter : SKObject {
    internal SKXmlWriter(IntPtr h, bool owns);
}
public enum SkiaSharp.SKZeroInitialized : Enum {
    public int value__;
    public static SKZeroInitialized Yes;
    public static SKZeroInitialized No;
}
public static class SkiaSharp.StringUtilities : object {
    private static int GetUnicodeStringLength(SKTextEncoding encoding);
    public static int GetUnicodeCharacterCode(string character, SKTextEncoding encoding);
    public static Byte[] GetEncodedText(string text, SKTextEncoding encoding);
    public static string GetString(IntPtr data, int dataLength, SKTextEncoding encoding);
    public static string GetString(Byte[] data, SKTextEncoding encoding);
    public static string GetString(Byte[] data, int index, int count, SKTextEncoding encoding);
}
