[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class SkiaSharp.DelegateProxies : object {
    public static SKBitmapReleaseProxyDelegate SKBitmapReleaseDelegateProxy;
    public static SKDataReleaseProxyDelegate SKDataReleaseDelegateProxy;
    public static SKImageRasterReleaseProxyDelegate SKImageRasterReleaseDelegateProxy;
    public static SKImageRasterReleaseProxyDelegate SKImageRasterReleaseDelegateProxyForCoTaskMem;
    public static SKImageTextureReleaseProxyDelegate SKImageTextureReleaseDelegateProxy;
    public static SKSurfaceRasterReleaseProxyDelegate SKSurfaceReleaseDelegateProxy;
    public static GRGlGetProcProxyDelegate GRGlGetProcDelegateProxy;
    public static GRVkGetProcProxyDelegate GRVkGetProcDelegateProxy;
    public static SKGlyphPathProxyDelegate SKGlyphPathDelegateProxy;
    private static DelegateProxies();
    public static T Create(object managedDel, T nativeDel, GCHandle& gch, IntPtr& contextPtr);
    public static void Create(object managedDel, GCHandle& gch, IntPtr& contextPtr);
    public static T Get(IntPtr contextPtr, GCHandle& gch);
    public static IntPtr CreateUserData(object userData, bool makeWeak);
    public static T GetUserData(IntPtr contextPtr, GCHandle& gch);
    public static IntPtr CreateMulti(T1 wrappedDelegate1, T2 wrappedDelegate2);
    public static IntPtr CreateMulti(T1 wrappedDelegate1, T2 wrappedDelegate2, T3 wrappedDelegate3);
    public static T GetMulti(IntPtr contextPtr, GCHandle& gch);
    public static void GetMulti(IntPtr contextPtr, T1& wrappedDelegate1, T2& wrappedDelegate2, GCHandle& gch);
    public static void GetMulti(IntPtr contextPtr, T1& wrappedDelegate1, T2& wrappedDelegate2, T3& wrappedDelegate3, GCHandle& gch);
    public static IntPtr CreateMultiUserData(T wrappedDelegate, object userData, bool makeWeak);
    public static IntPtr CreateMultiUserData(T1 wrappedDelegate1, T2 wrappedDelegate2, object userData, bool makeWeak);
    public static IntPtr CreateMultiUserData(T1 wrappedDelegate1, T2 wrappedDelegate2, T3 wrappedDelegate3, object userData, bool makeWeak);
    public static TUserData GetMultiUserData(IntPtr contextPtr, GCHandle& gch);
    public static void GetMultiUserData(IntPtr contextPtr, T& wrappedDelegate, TUserData& userData, GCHandle& gch);
    public static void GetMultiUserData(IntPtr contextPtr, T1& wrappedDelegate1, T2& wrappedDelegate2, TUserData& userData, GCHandle& gch);
    public static void GetMultiUserData(IntPtr contextPtr, T1& wrappedDelegate1, T2& wrappedDelegate2, T3& wrappedDelegate3, TUserData& userData, GCHandle& gch);
    private static TUserData GetUserData(GetMultiDelegateDelegate multi);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKBitmapReleaseProxyDelegate")]
private static void SKBitmapReleaseDelegateProxyImplementation(Void* address, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKDataReleaseProxyDelegate")]
private static void SKDataReleaseDelegateProxyImplementation(Void* address, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageRasterReleaseProxyDelegate")]
private static void SKImageRasterReleaseDelegateProxyImplementationForCoTaskMem(Void* pixels, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageRasterReleaseProxyDelegate")]
private static void SKImageRasterReleaseDelegateProxyImplementation(Void* pixels, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKImageTextureReleaseProxyDelegate")]
private static void SKImageTextureReleaseDelegateProxyImplementation(Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKSurfaceRasterReleaseProxyDelegate")]
private static void SKSurfaceReleaseDelegateProxyImplementation(Void* address, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.GRGlGetProcProxyDelegate")]
private static IntPtr GRGlGetProcDelegateProxyImplementation(Void* context, Void* name);
    [MonoPInvokeCallbackAttribute("SkiaSharp.GRVkGetProcProxyDelegate")]
private static IntPtr GRVkGetProcDelegateProxyImplementation(Void* context, Void* name, IntPtr instance, IntPtr device);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKGlyphPathProxyDelegate")]
private static void SKGlyphPathDelegateProxyImplementation(IntPtr pathOrNull, SKMatrix* matrix, Void* context);
}
internal class SkiaSharp.GetMultiDelegateDelegate : MulticastDelegate {
    public GetMultiDelegateDelegate(object object, IntPtr method);
    public virtual Delegate Invoke(Type index);
    public virtual IAsyncResult BeginInvoke(Type index, AsyncCallback callback, object object);
    public virtual Delegate EndInvoke(IAsyncResult result);
}
public enum SkiaSharp.GRBackend : Enum {
    public int value__;
    public static GRBackend Metal;
    public static GRBackend OpenGL;
    public static GRBackend Vulkan;
    public static GRBackend Dawn;
    public static GRBackend Direct3D;
}
internal enum SkiaSharp.GRBackendNative : Enum {
    public int value__;
    public static GRBackendNative OpenGL;
    public static GRBackendNative Vulkan;
    public static GRBackendNative Metal;
    public static GRBackendNative Direct3D;
    public static GRBackendNative Dawn;
}
public class SkiaSharp.GRBackendRenderTarget : SKObject {
    public bool IsValid { get; }
    public int Width { get; }
    public int Height { get; }
    public int SampleCount { get; }
    public int StencilBits { get; }
    public GRBackend Backend { get; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    internal GRBackendRenderTarget(IntPtr handle, bool owns);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendRenderTarget(int, int, int, int, GRGlFramebufferInfo) instead.")]
public GRBackendRenderTarget(GRBackend backend, GRBackendRenderTargetDesc desc);
    public GRBackendRenderTarget(int width, int height, int sampleCount, int stencilBits, GRGlFramebufferInfo glInfo);
    public GRBackendRenderTarget(int width, int height, int sampleCount, GRVkImageInfo vkImageInfo);
    public GRBackendRenderTarget(int width, int height, int sampleCount, GRMtlTextureInfo mtlInfo);
    private void CreateGl(int width, int height, int sampleCount, int stencilBits, GRGlFramebufferInfo glInfo);
    private void CreateVulkan(int width, int height, int sampleCount, GRVkImageInfo vkImageInfo);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool get_IsValid();
    public int get_Width();
    public int get_Height();
    public int get_SampleCount();
    public int get_StencilBits();
    public GRBackend get_Backend();
    public SKSizeI get_Size();
    public SKRectI get_Rect();
    public GRGlFramebufferInfo GetGlFramebufferInfo();
    public bool GetGlFramebufferInfo(GRGlFramebufferInfo& glInfo);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendRenderTarget instead.")]
public class SkiaSharp.GRBackendRenderTargetDesc : ValueType {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private GRPixelConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private GRSurfaceOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StencilBits>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <RenderTargetHandle>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int SampleCount { get; public set; }
    public int StencilBits { get; public set; }
    public IntPtr RenderTargetHandle { get; public set; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRPixelConfig get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(GRPixelConfig value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRSurfaceOrigin get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(GRSurfaceOrigin value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public void set_SampleCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_StencilBits();
    [CompilerGeneratedAttribute]
public void set_StencilBits(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IntPtr get_RenderTargetHandle();
    [CompilerGeneratedAttribute]
public void set_RenderTargetHandle(IntPtr value);
    [IsReadOnlyAttribute]
public SKSizeI get_Size();
    [IsReadOnlyAttribute]
public SKRectI get_Rect();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRBackendRenderTargetDesc obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRBackendRenderTargetDesc left, GRBackendRenderTargetDesc right);
    public static bool op_Inequality(GRBackendRenderTargetDesc left, GRBackendRenderTargetDesc right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[FlagsAttribute]
public enum SkiaSharp.GRBackendState : Enum {
    public UInt32 value__;
    public static GRBackendState None;
    public static GRBackendState All;
}
public class SkiaSharp.GRBackendTexture : SKObject {
    public bool IsValid { get; }
    public int Width { get; }
    public int Height { get; }
    public bool HasMipMaps { get; }
    public GRBackend Backend { get; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    internal GRBackendTexture(IntPtr handle, bool owns);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendTexture(int, int, bool, GRGlTextureInfo) instead.")]
public GRBackendTexture(GRGlBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendTexture(int, int, bool, GRGlTextureInfo) instead.")]
public GRBackendTexture(GRBackendTextureDesc desc);
    public GRBackendTexture(int width, int height, bool mipmapped, GRGlTextureInfo glInfo);
    public GRBackendTexture(int width, int height, GRVkImageInfo vkInfo);
    public GRBackendTexture(int width, int height, bool mipmapped, GRMtlTextureInfo mtlInfo);
    private void CreateGl(int width, int height, bool mipmapped, GRGlTextureInfo glInfo);
    private void CreateVulkan(int width, int height, GRVkImageInfo vkInfo);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool get_IsValid();
    public int get_Width();
    public int get_Height();
    public bool get_HasMipMaps();
    public GRBackend get_Backend();
    public SKSizeI get_Size();
    public SKRectI get_Rect();
    public GRGlTextureInfo GetGlTextureInfo();
    public bool GetGlTextureInfo(GRGlTextureInfo& glInfo);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendTexture instead.")]
public class SkiaSharp.GRBackendTextureDesc : ValueType {
    [CompilerGeneratedAttribute]
private GRBackendTextureDescFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private GRSurfaceOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private GRPixelConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <TextureHandle>k__BackingField;
    public GRBackendTextureDescFlags Flags { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public int SampleCount { get; public set; }
    public IntPtr TextureHandle { get; public set; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRBackendTextureDescFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(GRBackendTextureDescFlags value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRSurfaceOrigin get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(GRSurfaceOrigin value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRPixelConfig get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(GRPixelConfig value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public void set_SampleCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IntPtr get_TextureHandle();
    [CompilerGeneratedAttribute]
public void set_TextureHandle(IntPtr value);
    [IsReadOnlyAttribute]
public SKSizeI get_Size();
    [IsReadOnlyAttribute]
public SKRectI get_Rect();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRBackendTextureDesc obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRBackendTextureDesc left, GRBackendTextureDesc right);
    public static bool op_Inequality(GRBackendTextureDesc left, GRBackendTextureDesc right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
[ObsoleteAttribute]
public enum SkiaSharp.GRBackendTextureDescFlags : Enum {
    public int value__;
    public static GRBackendTextureDescFlags None;
    public static GRBackendTextureDescFlags RenderTarget;
}
public class SkiaSharp.GRContext : GRRecordingContext {
    public GRBackend Backend { get; }
    public bool IsAbandoned { get; }
    internal GRContext(IntPtr h, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateGl() instead.")]
public static GRContext Create(GRBackend backend);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateGl(GRGlInterface) instead.")]
public static GRContext Create(GRBackend backend, GRGlInterface backendContext);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateGl(GRGlInterface) instead.")]
public static GRContext Create(GRBackend backend, IntPtr backendContext);
    public static GRContext CreateGl();
    public static GRContext CreateGl(GRGlInterface backendContext);
    public static GRContext CreateGl(GRContextOptions options);
    public static GRContext CreateGl(GRGlInterface backendContext, GRContextOptions options);
    public static GRContext CreateVulkan(GRVkBackendContext backendContext);
    public static GRContext CreateVulkan(GRVkBackendContext backendContext, GRContextOptions options);
    public static GRContext CreateMetal(GRMtlBackendContext backendContext);
    public static GRContext CreateMetal(GRMtlBackendContext backendContext, GRContextOptions options);
    public GRBackend get_Backend();
    public bool get_IsAbandoned();
    public void AbandonContext(bool releaseResources);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetResourceCacheLimit() instead.")]
public void GetResourceCacheLimits(Int32& maxResources, Int64& maxResourceBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SetResourceCacheLimit(long) instead.")]
public void SetResourceCacheLimits(int maxResources, long maxResourceBytes);
    public long GetResourceCacheLimit();
    public void SetResourceCacheLimit(long maxResourceBytes);
    public void GetResourceCacheUsage(Int32& maxResources, Int64& maxResourceBytes);
    public void ResetContext(GRGlBackendState state);
    public void ResetContext(GRBackendState state);
    public void ResetContext(UInt32 state);
    public void Flush();
    public void Flush(bool submit, bool synchronous);
    public void Submit(bool synchronous);
    public int GetMaxSurfaceSampleCount(SKColorType colorType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public int GetRecommendedSampleCount(GRPixelConfig config, float dpi);
    public void DumpMemoryStatistics(SKTraceMemoryDump dump);
    public void PurgeResources();
    public void PurgeUnusedResources(long milliseconds);
    public void PurgeUnlockedResources(bool scratchResourcesOnly);
    public void PurgeUnlockedResources(long bytesToPurge, bool preferScratchResources);
    internal static GRContext GetObject(IntPtr handle, bool owns);
}
public class SkiaSharp.GRContextOptions : object {
    [CompilerGeneratedAttribute]
private bool <AvoidStencilBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RuntimeProgramCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GlyphCacheTextureMaximumBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowPathMaskCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoManualMipmapping>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferMapThreshold>k__BackingField;
    public bool AvoidStencilBuffers { get; public set; }
    public int RuntimeProgramCacheSize { get; public set; }
    public int GlyphCacheTextureMaximumBytes { get; public set; }
    public bool AllowPathMaskCaching { get; public set; }
    public bool DoManualMipmapping { get; public set; }
    public int BufferMapThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AvoidStencilBuffers();
    [CompilerGeneratedAttribute]
public void set_AvoidStencilBuffers(bool value);
    [CompilerGeneratedAttribute]
public int get_RuntimeProgramCacheSize();
    [CompilerGeneratedAttribute]
public void set_RuntimeProgramCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_GlyphCacheTextureMaximumBytes();
    [CompilerGeneratedAttribute]
public void set_GlyphCacheTextureMaximumBytes(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowPathMaskCaching();
    [CompilerGeneratedAttribute]
public void set_AllowPathMaskCaching(bool value);
    [CompilerGeneratedAttribute]
public bool get_DoManualMipmapping();
    [CompilerGeneratedAttribute]
public void set_DoManualMipmapping(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferMapThreshold();
    [CompilerGeneratedAttribute]
public void set_BufferMapThreshold(int value);
    internal GRContextOptionsNative ToNative();
}
internal class SkiaSharp.GRContextOptionsNative : ValueType {
    public byte fAvoidStencilBuffers;
    public int fRuntimeProgramCacheSize;
    public IntPtr fGlyphCacheTextureMaximumBytes;
    public byte fAllowPathMaskCaching;
    public byte fDoManualMipmapping;
    public int fBufferMapThreshold;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRContextOptionsNative obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRContextOptionsNative left, GRContextOptionsNative right);
    public static bool op_Inequality(GRContextOptionsNative left, GRContextOptionsNative right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[FlagsAttribute]
public enum SkiaSharp.GRGlBackendState : Enum {
    public UInt32 value__;
    public static GRGlBackendState None;
    public static GRGlBackendState RenderTarget;
    public static GRGlBackendState TextureBinding;
    public static GRGlBackendState View;
    public static GRGlBackendState Blend;
    public static GRGlBackendState MSAAEnable;
    public static GRGlBackendState Vertex;
    public static GRGlBackendState Stencil;
    public static GRGlBackendState PixelStore;
    public static GRGlBackendState Program;
    public static GRGlBackendState FixedFunction;
    public static GRGlBackendState Misc;
    public static GRGlBackendState PathRendering;
    public static GRGlBackendState All;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRBackendTexture instead.")]
public class SkiaSharp.GRGlBackendTextureDesc : ValueType {
    [CompilerGeneratedAttribute]
private GRBackendTextureDescFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private GRSurfaceOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private GRPixelConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SampleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private GRGlTextureInfo <TextureHandle>k__BackingField;
    public GRBackendTextureDescFlags Flags { get; public set; }
    public GRSurfaceOrigin Origin { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public GRPixelConfig Config { get; public set; }
    public int SampleCount { get; public set; }
    public GRGlTextureInfo TextureHandle { get; public set; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRBackendTextureDescFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(GRBackendTextureDescFlags value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRSurfaceOrigin get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(GRSurfaceOrigin value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRPixelConfig get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(GRPixelConfig value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SampleCount();
    [CompilerGeneratedAttribute]
public void set_SampleCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GRGlTextureInfo get_TextureHandle();
    [CompilerGeneratedAttribute]
public void set_TextureHandle(GRGlTextureInfo value);
    [IsReadOnlyAttribute]
public SKSizeI get_Size();
    [IsReadOnlyAttribute]
public SKRectI get_Rect();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRGlBackendTextureDesc obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRGlBackendTextureDesc left, GRGlBackendTextureDesc right);
    public static bool op_Inequality(GRGlBackendTextureDesc left, GRGlBackendTextureDesc right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.GRGlFramebufferInfo : ValueType {
    private UInt32 fFBOID;
    private UInt32 fFormat;
    public UInt32 FramebufferObjectId { get; public set; }
    public UInt32 Format { get; public set; }
    public GRGlFramebufferInfo(UInt32 fboId);
    public GRGlFramebufferInfo(UInt32 fboId, UInt32 format);
    [IsReadOnlyAttribute]
public UInt32 get_FramebufferObjectId();
    public void set_FramebufferObjectId(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Format();
    public void set_Format(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRGlFramebufferInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRGlFramebufferInfo left, GRGlFramebufferInfo right);
    public static bool op_Inequality(GRGlFramebufferInfo left, GRGlFramebufferInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.GRGlFuncPtr : MulticastDelegate {
    public GRGlFuncPtr(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GRGlGetProcedureAddressDelegate instead.")]
public class SkiaSharp.GRGlGetProcDelegate : MulticastDelegate {
    public GRGlGetProcDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(object context, string name);
    public virtual IAsyncResult BeginInvoke(object context, string name, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
public class SkiaSharp.GRGlGetProcedureAddressDelegate : MulticastDelegate {
    public GRGlGetProcedureAddressDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(string name);
    public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.GRGlGetProcProxyDelegate : MulticastDelegate {
    public GRGlGetProcProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(Void* ctx, Void* name);
    public virtual IAsyncResult BeginInvoke(Void* ctx, Void* name, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
public class SkiaSharp.GRGlInterface : SKObject {
    internal GRGlInterface(IntPtr h, bool owns);
    protected virtual void Dispose(bool disposing);
    public static GRGlInterface Create();
    private static GRGlInterface CreateGl();
    public static GRGlInterface CreateAngle();
    public static GRGlInterface Create(GRGlGetProcedureAddressDelegate get);
    public static GRGlInterface CreateAngle(GRGlGetProcedureAddressDelegate get);
    public static GRGlInterface CreateOpenGl(GRGlGetProcedureAddressDelegate get);
    public static GRGlInterface CreateGles(GRGlGetProcedureAddressDelegate get);
    public static GRGlInterface CreateWebGl(GRGlGetProcedureAddressDelegate get);
    public static GRGlInterface CreateEvas(IntPtr evas);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create() instead.")]
public static GRGlInterface CreateDefaultInterface();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create() instead.")]
public static GRGlInterface CreateNativeGlInterface();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create() instead.")]
public static GRGlInterface CreateNativeAngleInterface();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateEvas(IntPtr) instead.")]
public static GRGlInterface CreateNativeEvasInterface(IntPtr evas);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleInterface(GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleInterface(object context, GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateAngle(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleAngleInterface(GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateAngle(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleAngleInterface(object context, GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateOpenGl(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleGlInterface(GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateOpenGl(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleGlInterface(object context, GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateGles(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleGlesInterface(GRGlGetProcDelegate get);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateGles(GRGlGetProcedureAddressDelegate) instead.")]
public static GRGlInterface AssembleGlesInterface(object context, GRGlGetProcDelegate get);
    public bool Validate();
    public bool HasExtension(string extension);
    internal static GRGlInterface GetObject(IntPtr handle);
}
internal static class SkiaSharp.GRGlSizedFormat : object {
    internal static UInt32 STENCIL_INDEX;
    internal static UInt32 DEPTH_COMPONENT;
    internal static UInt32 DEPTH_STENCIL;
    internal static UInt32 RED;
    internal static UInt32 RED_INTEGER;
    internal static UInt32 GREEN;
    internal static UInt32 BLUE;
    internal static UInt32 ALPHA;
    internal static UInt32 LUMINANCE;
    internal static UInt32 LUMINANCE_ALPHA;
    internal static UInt32 RG_INTEGER;
    internal static UInt32 RGB;
    internal static UInt32 RGB_INTEGER;
    internal static UInt32 SRGB;
    internal static UInt32 RGBA;
    internal static UInt32 RG;
    internal static UInt32 SRGB_ALPHA;
    internal static UInt32 RGBA_INTEGER;
    internal static UInt32 BGRA;
    internal static UInt32 STENCIL_INDEX4;
    internal static UInt32 STENCIL_INDEX8;
    internal static UInt32 STENCIL_INDEX16;
    internal static UInt32 DEPTH_COMPONENT16;
    internal static UInt32 DEPTH24_STENCIL8;
    internal static UInt32 R8;
    internal static UInt32 R16;
    internal static UInt32 R16F;
    internal static UInt32 R32F;
    internal static UInt32 R8I;
    internal static UInt32 R8UI;
    internal static UInt32 R16I;
    internal static UInt32 R16UI;
    internal static UInt32 R32I;
    internal static UInt32 R32UI;
    internal static UInt32 LUMINANCE8;
    internal static UInt32 LUMINANCE16F;
    internal static UInt32 ALPHA8;
    internal static UInt32 ALPHA16;
    internal static UInt32 ALPHA16F;
    internal static UInt32 ALPHA32F;
    internal static UInt32 ALPHA8I;
    internal static UInt32 ALPHA8UI;
    internal static UInt32 ALPHA16I;
    internal static UInt32 ALPHA16UI;
    internal static UInt32 ALPHA32I;
    internal static UInt32 ALPHA32UI;
    internal static UInt32 RG8;
    internal static UInt32 RG16;
    internal static UInt32 RG16F;
    internal static UInt32 RG8I;
    internal static UInt32 RG8UI;
    internal static UInt32 RG16I;
    internal static UInt32 RG16UI;
    internal static UInt32 RG32I;
    internal static UInt32 RG32UI;
    internal static UInt32 RGB5;
    internal static UInt32 RGB565;
    internal static UInt32 RGB8;
    internal static UInt32 SRGB8;
    internal static UInt32 RGB8I;
    internal static UInt32 RGB8UI;
    internal static UInt32 RGB16I;
    internal static UInt32 RGB16UI;
    internal static UInt32 RGB32I;
    internal static UInt32 RGB32UI;
    internal static UInt32 RGBA4;
    internal static UInt32 RGB5_A1;
    internal static UInt32 RGBA8;
    internal static UInt32 RGB10_A2;
    internal static UInt32 SRGB8_ALPHA8;
    internal static UInt32 RGBA16F;
    internal static UInt32 RGBA32F;
    internal static UInt32 RG32F;
    internal static UInt32 RGBA16;
    internal static UInt32 RGBA8I;
    internal static UInt32 RGBA8UI;
    internal static UInt32 RGBA16I;
    internal static UInt32 RGBA16UI;
    internal static UInt32 RGBA32I;
    internal static UInt32 RGBA32UI;
    internal static UInt32 BGRA8;
    internal static UInt32 COMPRESSED_ETC1_RGB8;
}
public class SkiaSharp.GRGlTextureInfo : ValueType {
    private UInt32 fTarget;
    private UInt32 fID;
    private UInt32 fFormat;
    public UInt32 Target { get; public set; }
    public UInt32 Id { get; public set; }
    public UInt32 Format { get; public set; }
    public GRGlTextureInfo(UInt32 target, UInt32 id);
    public GRGlTextureInfo(UInt32 target, UInt32 id, UInt32 format);
    [IsReadOnlyAttribute]
public UInt32 get_Target();
    public void set_Target(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Id();
    public void set_Id(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Format();
    public void set_Format(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRGlTextureInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRGlTextureInfo left, GRGlTextureInfo right);
    public static bool op_Inequality(GRGlTextureInfo left, GRGlTextureInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.GRMtlBackendContext : object {
    [CompilerGeneratedAttribute]
private IMTLDevice <Device>k__BackingField;
    [CompilerGeneratedAttribute]
private IMTLCommandQueue <Queue>k__BackingField;
    public IMTLDevice Device { get; public set; }
    public IMTLCommandQueue Queue { get; public set; }
    [CompilerGeneratedAttribute]
public IMTLDevice get_Device();
    [CompilerGeneratedAttribute]
public void set_Device(IMTLDevice value);
    [CompilerGeneratedAttribute]
public IMTLCommandQueue get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(IMTLCommandQueue value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class SkiaSharp.GRMtlTextureInfo : ValueType {
    [CompilerGeneratedAttribute]
private IMTLTexture <Texture>k__BackingField;
    public IMTLTexture Texture { get; public set; }
    public GRMtlTextureInfo(IMTLTexture texture);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IMTLTexture get_Texture();
    [CompilerGeneratedAttribute]
public void set_Texture(IMTLTexture value);
    internal GRMtlTextureInfoNative ToNative();
    [IsReadOnlyAttribute]
public bool Equals(GRMtlTextureInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRMtlTextureInfo left, GRMtlTextureInfo right);
    public static bool op_Inequality(GRMtlTextureInfo left, GRMtlTextureInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal class SkiaSharp.GRMtlTextureInfoNative : ValueType {
    public Void* fTexture;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRMtlTextureInfoNative obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRMtlTextureInfoNative left, GRMtlTextureInfoNative right);
    public static bool op_Inequality(GRMtlTextureInfoNative left, GRMtlTextureInfoNative right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorType instead.")]
public enum SkiaSharp.GRPixelConfig : Enum {
    public int value__;
    public static GRPixelConfig Unknown;
    public static GRPixelConfig Alpha8;
    public static GRPixelConfig Gray8;
    public static GRPixelConfig Rgb565;
    public static GRPixelConfig Rgba4444;
    public static GRPixelConfig Rgba8888;
    public static GRPixelConfig Rgb888;
    public static GRPixelConfig Bgra8888;
    public static GRPixelConfig Srgba8888;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The pixel configuration 'sBGRA 8888' is no longer supported in the native library.", "True")]
public static GRPixelConfig Sbgra8888;
    public static GRPixelConfig Rgba1010102;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The pixel configuration 'floating-point RGBA' is no longer supported in the native library.", "True")]
public static GRPixelConfig RgbaFloat;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The pixel configuration 'floating-point RG' is no longer supported in the native library.", "True")]
public static GRPixelConfig RgFloat;
    public static GRPixelConfig AlphaHalf;
    public static GRPixelConfig RgbaHalf;
    public static GRPixelConfig Alpha8AsAlpha;
    public static GRPixelConfig Alpha8AsRed;
    public static GRPixelConfig AlphaHalfAsLum;
    public static GRPixelConfig AlphaHalfAsRed;
    public static GRPixelConfig Gray8AsLum;
    public static GRPixelConfig Gray8AsRed;
    public static GRPixelConfig RgbaHalfClamped;
    public static GRPixelConfig Alpha16;
    public static GRPixelConfig Rg1616;
    public static GRPixelConfig Rgba16161616;
    public static GRPixelConfig RgHalf;
    public static GRPixelConfig Rg88;
    public static GRPixelConfig Rgb888x;
    public static GRPixelConfig RgbEtc1;
}
public class SkiaSharp.GRRecordingContext : SKObject {
    public GRBackend Backend { get; }
    internal GRRecordingContext(IntPtr h, bool owns);
    public GRBackend get_Backend();
    public int GetMaxSurfaceSampleCount(SKColorType colorType);
    internal static GRRecordingContext GetObject(IntPtr handle, bool owns, bool unrefExisting);
}
public enum SkiaSharp.GRSurfaceOrigin : Enum {
    public int value__;
    public static GRSurfaceOrigin TopLeft;
    public static GRSurfaceOrigin BottomLeft;
}
public class SkiaSharp.GRVkAlloc : ValueType {
    private ulong fMemory;
    private ulong fOffset;
    private ulong fSize;
    private UInt32 fFlags;
    private IntPtr fBackendMemory;
    private byte fUsesSystemHeap;
    public ulong Memory { get; public set; }
    public ulong Offset { get; public set; }
    public ulong Size { get; public set; }
    public UInt32 Flags { get; public set; }
    public IntPtr BackendMemory { get; public set; }
    [IsReadOnlyAttribute]
public ulong get_Memory();
    public void set_Memory(ulong value);
    [IsReadOnlyAttribute]
public ulong get_Offset();
    public void set_Offset(ulong value);
    [IsReadOnlyAttribute]
public ulong get_Size();
    public void set_Size(ulong value);
    [IsReadOnlyAttribute]
public UInt32 get_Flags();
    public void set_Flags(UInt32 value);
    [IsReadOnlyAttribute]
public IntPtr get_BackendMemory();
    public void set_BackendMemory(IntPtr value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRVkAlloc obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRVkAlloc left, GRVkAlloc right);
    public static bool op_Inequality(GRVkAlloc left, GRVkAlloc right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.GRVkBackendContext : object {
    private GRVkGetProcedureAddressDelegate getProc;
    private GRVkGetProcProxyDelegate getProcProxy;
    private GCHandle getProcHandle;
    private Void* getProcContext;
    [CompilerGeneratedAttribute]
private IntPtr <VkInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VkPhysicalDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VkDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VkQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <GraphicsQueueIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxAPIVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private GRVkExtensions <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VkPhysicalDeviceFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VkPhysicalDeviceFeatures2>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProtectedContext>k__BackingField;
    public IntPtr VkInstance { get; public set; }
    public IntPtr VkPhysicalDevice { get; public set; }
    public IntPtr VkDevice { get; public set; }
    public IntPtr VkQueue { get; public set; }
    public UInt32 GraphicsQueueIndex { get; public set; }
    public UInt32 MaxAPIVersion { get; public set; }
    public GRVkExtensions Extensions { get; public set; }
    public IntPtr VkPhysicalDeviceFeatures { get; public set; }
    public IntPtr VkPhysicalDeviceFeatures2 { get; public set; }
    public GRVkGetProcedureAddressDelegate GetProcedureAddress { get; public set; }
    public bool ProtectedContext { get; public set; }
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public IntPtr get_VkInstance();
    [CompilerGeneratedAttribute]
public void set_VkInstance(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_VkPhysicalDevice();
    [CompilerGeneratedAttribute]
public void set_VkPhysicalDevice(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_VkDevice();
    [CompilerGeneratedAttribute]
public void set_VkDevice(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_VkQueue();
    [CompilerGeneratedAttribute]
public void set_VkQueue(IntPtr value);
    [CompilerGeneratedAttribute]
public UInt32 get_GraphicsQueueIndex();
    [CompilerGeneratedAttribute]
public void set_GraphicsQueueIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxAPIVersion();
    [CompilerGeneratedAttribute]
public void set_MaxAPIVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public GRVkExtensions get_Extensions();
    [CompilerGeneratedAttribute]
public void set_Extensions(GRVkExtensions value);
    [CompilerGeneratedAttribute]
public IntPtr get_VkPhysicalDeviceFeatures();
    [CompilerGeneratedAttribute]
public void set_VkPhysicalDeviceFeatures(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_VkPhysicalDeviceFeatures2();
    [CompilerGeneratedAttribute]
public void set_VkPhysicalDeviceFeatures2(IntPtr value);
    public GRVkGetProcedureAddressDelegate get_GetProcedureAddress();
    public void set_GetProcedureAddress(GRVkGetProcedureAddressDelegate value);
    [CompilerGeneratedAttribute]
public bool get_ProtectedContext();
    [CompilerGeneratedAttribute]
public void set_ProtectedContext(bool value);
    internal GRVkBackendContextNative ToNative();
}
internal class SkiaSharp.GRVkBackendContextNative : ValueType {
    public IntPtr fInstance;
    public IntPtr fPhysicalDevice;
    public IntPtr fDevice;
    public IntPtr fQueue;
    public UInt32 fGraphicsQueueIndex;
    public UInt32 fMinAPIVersion;
    public UInt32 fInstanceVersion;
    public UInt32 fMaxAPIVersion;
    public UInt32 fExtensions;
    public IntPtr fVkExtensions;
    public UInt32 fFeatures;
    public IntPtr fDeviceFeatures;
    public IntPtr fDeviceFeatures2;
    public IntPtr fMemoryAllocator;
    public GRVkGetProcProxyDelegate fGetProc;
    public Void* fGetProcUserData;
    public byte fOwnsInstanceAndDevice;
    public byte fProtectedContext;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRVkBackendContextNative obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRVkBackendContextNative left, GRVkBackendContextNative right);
    public static bool op_Inequality(GRVkBackendContextNative left, GRVkBackendContextNative right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.GRVkExtensions : SKObject {
    internal GRVkExtensions(IntPtr h, bool owns);
    protected virtual void DisposeNative();
    public void HasExtension(string extension, int minVersion);
    public void Initialize(GRVkGetProcedureAddressDelegate getProc, IntPtr vkInstance, IntPtr vkPhysicalDevice);
    public void Initialize(GRVkGetProcedureAddressDelegate getProc, IntPtr vkInstance, IntPtr vkPhysicalDevice, String[] instanceExtensions, String[] deviceExtensions);
    public static GRVkExtensions Create(GRVkGetProcedureAddressDelegate getProc, IntPtr vkInstance, IntPtr vkPhysicalDevice, String[] instanceExtensions, String[] deviceExtensions);
    internal static GRVkExtensions GetObject(IntPtr handle);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.GRVkFuncPtr : MulticastDelegate {
    public GRVkFuncPtr(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.GRVkGetProcedureAddressDelegate : MulticastDelegate {
    public GRVkGetProcedureAddressDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(string name, IntPtr instance, IntPtr device);
    public virtual IAsyncResult BeginInvoke(string name, IntPtr instance, IntPtr device, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.GRVkGetProcProxyDelegate : MulticastDelegate {
    public GRVkGetProcProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(Void* ctx, Void* name, IntPtr instance, IntPtr device);
    public virtual IAsyncResult BeginInvoke(Void* ctx, Void* name, IntPtr instance, IntPtr device, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
public class SkiaSharp.GRVkImageInfo : ValueType {
    private ulong fImage;
    private GRVkAlloc fAlloc;
    private UInt32 fImageTiling;
    private UInt32 fImageLayout;
    private UInt32 fFormat;
    private UInt32 fImageUsageFlags;
    private UInt32 fSampleCount;
    private UInt32 fLevelCount;
    private UInt32 fCurrentQueueFamily;
    private byte fProtected;
    private GrVkYcbcrConversionInfo fYcbcrConversionInfo;
    private UInt32 fSharingMode;
    public ulong Image { get; public set; }
    public GRVkAlloc Alloc { get; public set; }
    public UInt32 ImageTiling { get; public set; }
    public UInt32 ImageLayout { get; public set; }
    public UInt32 Format { get; public set; }
    public UInt32 ImageUsageFlags { get; public set; }
    public UInt32 SampleCount { get; public set; }
    public UInt32 LevelCount { get; public set; }
    public UInt32 CurrentQueueFamily { get; public set; }
    public bool Protected { get; public set; }
    public GrVkYcbcrConversionInfo YcbcrConversionInfo { get; public set; }
    public UInt32 SharingMode { get; public set; }
    [IsReadOnlyAttribute]
public ulong get_Image();
    public void set_Image(ulong value);
    [IsReadOnlyAttribute]
public GRVkAlloc get_Alloc();
    public void set_Alloc(GRVkAlloc value);
    [IsReadOnlyAttribute]
public UInt32 get_ImageTiling();
    public void set_ImageTiling(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_ImageLayout();
    public void set_ImageLayout(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Format();
    public void set_Format(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_ImageUsageFlags();
    public void set_ImageUsageFlags(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_SampleCount();
    public void set_SampleCount(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_LevelCount();
    public void set_LevelCount(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_CurrentQueueFamily();
    public void set_CurrentQueueFamily(UInt32 value);
    [IsReadOnlyAttribute]
public bool get_Protected();
    public void set_Protected(bool value);
    [IsReadOnlyAttribute]
public GrVkYcbcrConversionInfo get_YcbcrConversionInfo();
    public void set_YcbcrConversionInfo(GrVkYcbcrConversionInfo value);
    [IsReadOnlyAttribute]
public UInt32 get_SharingMode();
    public void set_SharingMode(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GRVkImageInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GRVkImageInfo left, GRVkImageInfo right);
    public static bool op_Inequality(GRVkImageInfo left, GRVkImageInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.GrVkYcbcrConversionInfo : ValueType {
    private UInt32 fFormat;
    private ulong fExternalFormat;
    private UInt32 fYcbcrModel;
    private UInt32 fYcbcrRange;
    private UInt32 fXChromaOffset;
    private UInt32 fYChromaOffset;
    private UInt32 fChromaFilter;
    private UInt32 fForceExplicitReconstruction;
    private UInt32 fFormatFeatures;
    public UInt32 Format { get; public set; }
    public ulong ExternalFormat { get; public set; }
    public UInt32 YcbcrModel { get; public set; }
    public UInt32 YcbcrRange { get; public set; }
    public UInt32 XChromaOffset { get; public set; }
    public UInt32 YChromaOffset { get; public set; }
    public UInt32 ChromaFilter { get; public set; }
    public UInt32 ForceExplicitReconstruction { get; public set; }
    public UInt32 FormatFeatures { get; public set; }
    [IsReadOnlyAttribute]
public UInt32 get_Format();
    public void set_Format(UInt32 value);
    [IsReadOnlyAttribute]
public ulong get_ExternalFormat();
    public void set_ExternalFormat(ulong value);
    [IsReadOnlyAttribute]
public UInt32 get_YcbcrModel();
    public void set_YcbcrModel(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_YcbcrRange();
    public void set_YcbcrRange(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_XChromaOffset();
    public void set_XChromaOffset(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_YChromaOffset();
    public void set_YChromaOffset(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_ChromaFilter();
    public void set_ChromaFilter(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_ForceExplicitReconstruction();
    public void set_ForceExplicitReconstruction(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_FormatFeatures();
    public void set_FormatFeatures(UInt32 value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(GrVkYcbcrConversionInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(GrVkYcbcrConversionInfo left, GrVkYcbcrConversionInfo right);
    public static bool op_Inequality(GrVkYcbcrConversionInfo left, GrVkYcbcrConversionInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal static class SkiaSharp.HandleDictionary : object {
    private static Type SkipObjectRegistrationType;
    internal static Dictionary`2<IntPtr, WeakReference> instances;
    internal static IPlatformLock instancesLock;
    private static HandleDictionary();
    internal static bool GetInstance(IntPtr handle, TSkiaObject& instance);
    internal static TSkiaObject GetOrAddObject(IntPtr handle, bool owns, bool unrefExisting, Func`3<IntPtr, bool, TSkiaObject> objectFactory);
    private static bool GetInstanceNoLocks(IntPtr handle, TSkiaObject& instance);
    internal static void RegisterHandle(IntPtr handle, SKObject instance);
    internal static void DeregisterHandle(IntPtr handle, SKObject instance);
}
internal class SkiaSharp.HashCode : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 RotateLeft(UInt32 value, int offset);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(Void* value);
    public void Add(T value);
    private void Add(int value);
    public int ToHashCode();
}
public interface SkiaSharp.Internals.IPlatformLock {
    public abstract virtual void EnterReadLock();
    public abstract virtual void ExitReadLock();
    public abstract virtual void EnterWriteLock();
    public abstract virtual void ExitWriteLock();
    public abstract virtual void EnterUpgradeableReadLock();
    public abstract virtual void ExitUpgradeableReadLock();
}
public static class SkiaSharp.Internals.PlatformConfiguration : object {
    private static string LibCLibrary;
    private static string linuxFlavor;
    private static Lazy`1<bool> isGlibcLazy;
    public static bool IsUnix { get; }
    public static bool IsWindows { get; }
    public static bool IsMac { get; }
    public static bool IsLinux { get; }
    public static bool IsArm { get; }
    public static bool Is64Bit { get; }
    public static string LinuxFlavor { get; public set; }
    public static bool IsGlibc { get; }
    private static PlatformConfiguration();
    public static bool get_IsUnix();
    public static bool get_IsWindows();
    public static bool get_IsMac();
    public static bool get_IsLinux();
    public static bool get_IsArm();
    public static bool get_Is64Bit();
    public static string get_LinuxFlavor();
    public static void set_LinuxFlavor(string value);
    public static bool get_IsGlibc();
    private static bool IsGlibcImplementation();
    private static IntPtr gnu_get_libc_version();
}
public static class SkiaSharp.Internals.PlatformLock : object {
    [CompilerGeneratedAttribute]
private static Func`1<IPlatformLock> <Factory>k__BackingField;
    public static Func`1<IPlatformLock> Factory { get; public set; }
    private static PlatformLock();
    public static IPlatformLock Create();
    [CompilerGeneratedAttribute]
public static Func`1<IPlatformLock> get_Factory();
    [CompilerGeneratedAttribute]
public static void set_Factory(Func`1<IPlatformLock> value);
    public static IPlatformLock DefaultFactory();
}
internal interface SkiaSharp.ISKNonVirtualReferenceCounted {
    public abstract virtual void ReferenceNative();
    public abstract virtual void UnreferenceNative();
}
internal interface SkiaSharp.ISKReferenceCounted {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
internal interface SkiaSharp.ISKSkipObjectRegistration {
}
[AttributeUsageAttribute("64")]
internal class SkiaSharp.MonoPInvokeCallbackAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public MonoPInvokeCallbackAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
}
public class SkiaSharp.SK3dView : SKObject {
    public SKMatrix Matrix { get; }
    internal SK3dView(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKMatrix get_Matrix();
    public void GetMatrix(SKMatrix& matrix);
    public void Save();
    public void Restore();
    public void Translate(float x, float y, float z);
    public void TranslateX(float x);
    public void TranslateY(float y);
    public void TranslateZ(float z);
    public void RotateXDegrees(float degrees);
    public void RotateYDegrees(float degrees);
    public void RotateZDegrees(float degrees);
    public void RotateXRadians(float radians);
    public void RotateYRadians(float radians);
    public void RotateZRadians(float radians);
    public float DotWithNormal(float dx, float dy, float dz);
    public void ApplyToCanvas(SKCanvas canvas);
}
public abstract class SkiaSharp.SKAbstractManagedStream : SKStreamAsset {
    private static SKManagedStreamDelegates delegates;
    private int fromNative;
    private static SKAbstractManagedStream();
    protected SKAbstractManagedStream(bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    protected abstract virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected abstract virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected abstract virtual bool OnIsAtEnd();
    protected abstract virtual bool OnHasPosition();
    protected abstract virtual bool OnHasLength();
    protected abstract virtual bool OnRewind();
    protected abstract virtual IntPtr OnGetPosition();
    protected abstract virtual IntPtr OnGetLength();
    protected abstract virtual bool OnSeek(IntPtr position);
    protected abstract virtual bool OnMove(int offset);
    protected abstract virtual IntPtr OnCreateNew();
    protected virtual IntPtr OnFork();
    protected virtual IntPtr OnDuplicate();
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamReadProxyDelegate")]
private static IntPtr ReadInternal(IntPtr s, Void* context, Void* buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamPeekProxyDelegate")]
private static IntPtr PeekInternal(IntPtr s, Void* context, Void* buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamIsAtEndProxyDelegate")]
private static bool IsAtEndInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamHasPositionProxyDelegate")]
private static bool HasPositionInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamHasLengthProxyDelegate")]
private static bool HasLengthInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamRewindProxyDelegate")]
private static bool RewindInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamGetPositionProxyDelegate")]
private static IntPtr GetPositionInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamSeekProxyDelegate")]
private static bool SeekInternal(IntPtr s, Void* context, IntPtr position);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamMoveProxyDelegate")]
private static bool MoveInternal(IntPtr s, Void* context, int offset);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamGetLengthProxyDelegate")]
private static IntPtr GetLengthInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamDuplicateProxyDelegate")]
private static IntPtr DuplicateInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamForkProxyDelegate")]
private static IntPtr ForkInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedStreamDestroyProxyDelegate")]
private static void DestroyInternal(IntPtr s, Void* context);
}
public abstract class SkiaSharp.SKAbstractManagedWStream : SKWStream {
    private static SKManagedWStreamDelegates delegates;
    private int fromNative;
    private static SKAbstractManagedWStream();
    protected SKAbstractManagedWStream(bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    protected abstract virtual bool OnWrite(IntPtr buffer, IntPtr size);
    protected abstract virtual void OnFlush();
    protected abstract virtual IntPtr OnBytesWritten();
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedWStreamWriteProxyDelegate")]
private static bool WriteInternal(IntPtr s, Void* context, Void* buffer, IntPtr size);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedWStreamFlushProxyDelegate")]
private static void FlushInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedWStreamBytesWrittenProxyDelegate")]
private static IntPtr BytesWrittenInternal(IntPtr s, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedWStreamDestroyProxyDelegate")]
private static void DestroyInternal(IntPtr s, Void* context);
}
public enum SkiaSharp.SKAlphaType : Enum {
    public int value__;
    public static SKAlphaType Unknown;
    public static SKAlphaType Opaque;
    public static SKAlphaType Premul;
    public static SKAlphaType Unpremul;
}
public class SkiaSharp.SKAutoCanvasRestore : object {
    private SKCanvas canvas;
    private int saveCount;
    public SKAutoCanvasRestore(SKCanvas canvas);
    public SKAutoCanvasRestore(SKCanvas canvas, bool doSave);
    public sealed virtual void Dispose();
    public void Restore();
}
public class SkiaSharp.SKAutoCoInitialize : object {
    private long hResult;
    private static long S_OK;
    private static long RPC_E_CHANGED_MODE;
    private static UInt32 COINIT_MULTITHREADED;
    private static UInt32 COINIT_APARTMENTTHREADED;
    private static UInt32 COINIT_DISABLE_OLE1DDE;
    private static UInt32 COINIT_SPEED_OVER_MEMORY;
    public bool Initialized { get; }
    public bool get_Initialized();
    public void Uninitialize();
    public sealed virtual void Dispose();
    private static long CoInitializeEx(IntPtr pvReserved, UInt32 dwCoInit);
    private static void CoUninitialize();
}
public class SkiaSharp.SKAutoMaskFreeImage : object {
    private IntPtr image;
    public SKAutoMaskFreeImage(IntPtr maskImage);
    public sealed virtual void Dispose();
}
public class SkiaSharp.SKBitmap : SKObject {
    private static string UnsupportedColorTypeMessage;
    private static string UnableToAllocatePixelsMessage;
    public bool ReadyToDraw { get; }
    public SKImageInfo Info { get; }
    public int Width { get; }
    public int Height { get; }
    public SKColorType ColorType { get; }
    public SKAlphaType AlphaType { get; }
    public SKColorSpace ColorSpace { get; }
    public int BytesPerPixel { get; }
    public int RowBytes { get; }
    public int ByteCount { get; }
    public Byte[] Bytes { get; }
    public SKColor[] Pixels { get; public set; }
    public bool IsEmpty { get; }
    public bool IsNull { get; }
    public bool DrawsNothing { get; }
    public bool IsImmutable { get; }
    [ObsoleteAttribute]
public bool IsVolatile { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported.")]
public SKColorTable ColorTable { get; }
    internal SKBitmap(IntPtr handle, bool owns);
    public SKBitmap(int width, int height, bool isOpaque);
    public SKBitmap(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    public SKBitmap(int width, int height, SKColorType colorType, SKAlphaType alphaType, SKColorSpace colorspace);
    public SKBitmap(SKImageInfo info);
    public SKBitmap(SKImageInfo info, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use SKBitmap(SKImageInfo, SKBitmapAllocFlags) instead.")]
public SKBitmap(SKImageInfo info, SKColorTable ctable, SKBitmapAllocFlags flags);
    public SKBitmap(SKImageInfo info, SKBitmapAllocFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use SKBitmap(SKImageInfo) instead.")]
public SKBitmap(SKImageInfo info, SKColorTable ctable);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool TryAllocPixels(SKImageInfo info);
    public bool TryAllocPixels(SKImageInfo info, int rowBytes);
    public bool TryAllocPixels(SKImageInfo info, SKBitmapAllocFlags flags);
    public void Reset();
    public void SetImmutable();
    public void Erase(SKColor color);
    public void Erase(SKColor color, SKRectI rect);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public byte GetAddr8(int x, int y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public ushort GetAddr16(int x, int y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public UInt32 GetAddr32(int x, int y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAddress instead.")]
public IntPtr GetAddr(int x, int y);
    public IntPtr GetAddress(int x, int y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixel(int, int) instead.")]
public SKPMColor GetIndex8Color(int x, int y);
    public SKColor GetPixel(int x, int y);
    public void SetPixel(int x, int y, SKColor color);
    public bool CanCopyTo(SKColorType colorType);
    public SKBitmap Copy();
    public SKBitmap Copy(SKColorType colorType);
    public bool CopyTo(SKBitmap destination);
    public bool CopyTo(SKBitmap destination, SKColorType colorType);
    public bool ExtractSubset(SKBitmap destination, SKRectI subset);
    public bool ExtractAlpha(SKBitmap destination);
    public bool ExtractAlpha(SKBitmap destination, SKPointI& offset);
    public bool ExtractAlpha(SKBitmap destination, SKPaint paint);
    public bool ExtractAlpha(SKBitmap destination, SKPaint paint, SKPointI& offset);
    public bool get_ReadyToDraw();
    public SKImageInfo get_Info();
    public int get_Width();
    public int get_Height();
    public SKColorType get_ColorType();
    public SKAlphaType get_AlphaType();
    public SKColorSpace get_ColorSpace();
    public int get_BytesPerPixel();
    public int get_RowBytes();
    public int get_ByteCount();
    public IntPtr GetPixels();
    public ReadOnlySpan`1<byte> GetPixelSpan();
    public IntPtr GetPixels(IntPtr& length);
    public void SetPixels(IntPtr pixels);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use SetPixels(IntPtr) instead.")]
public void SetPixels(IntPtr pixels, SKColorTable ct);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported.")]
public void SetColorTable(SKColorTable ct);
    public Byte[] get_Bytes();
    public SKColor[] get_Pixels();
    public void set_Pixels(SKColor[] value);
    public bool get_IsEmpty();
    public bool get_IsNull();
    public bool get_DrawsNothing();
    public bool get_IsImmutable();
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public SKColorTable get_ColorTable();
    public static SKImageInfo DecodeBounds(Stream stream);
    public static SKImageInfo DecodeBounds(SKStream stream);
    public static SKImageInfo DecodeBounds(SKData data);
    public static SKImageInfo DecodeBounds(string filename);
    public static SKImageInfo DecodeBounds(Byte[] buffer);
    public static SKImageInfo DecodeBounds(ReadOnlySpan`1<byte> buffer);
    public static SKBitmap Decode(SKCodec codec);
    public static SKBitmap Decode(SKCodec codec, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(Stream stream);
    public static SKBitmap Decode(Stream stream, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(SKStream stream);
    public static SKBitmap Decode(SKStream stream, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(SKData data);
    public static SKBitmap Decode(SKData data, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(string filename);
    public static SKBitmap Decode(string filename, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(Byte[] buffer);
    public static SKBitmap Decode(Byte[] buffer, SKImageInfo bitmapInfo);
    public static SKBitmap Decode(ReadOnlySpan`1<byte> buffer);
    public static SKBitmap Decode(ReadOnlySpan`1<byte> buffer, SKImageInfo bitmapInfo);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use InstallPixels(SKImageInfo, IntPtr, int) instead.")]
public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use InstallPixels(SKImageInfo, IntPtr, int, SKBitmapReleaseDelegate, object) instead.")]
public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable, SKBitmapReleaseDelegate releaseProc, object context);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKBitmapReleaseDelegate releaseProc);
    public bool InstallPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKBitmapReleaseDelegate releaseProc, object context);
    public bool InstallPixels(SKPixmap pixmap);
    public bool InstallMaskPixels(SKMask mask);
    public void NotifyPixelsChanged();
    public SKPixmap PeekPixels();
    public bool PeekPixels(SKPixmap pixmap);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Resize(SKImageInfo, SKFilterQuality) instead.")]
public SKBitmap Resize(SKImageInfo info, SKBitmapResizeMethod method);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ScalePixels(SKBitmap, SKFilterQuality) instead.")]
public bool Resize(SKBitmap dst, SKBitmapResizeMethod method);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ScalePixels(SKBitmap, SKFilterQuality) instead.")]
public static bool Resize(SKBitmap dst, SKBitmap src, SKBitmapResizeMethod method);
    public SKBitmap Resize(SKImageInfo info, SKFilterQuality quality);
    public SKBitmap Resize(SKSizeI size, SKFilterQuality quality);
    public bool ScalePixels(SKBitmap destination, SKFilterQuality quality);
    public bool ScalePixels(SKPixmap destination, SKFilterQuality quality);
    public static SKBitmap FromImage(SKImage image);
    public SKData Encode(SKEncodedImageFormat format, int quality);
    public bool Encode(Stream dst, SKEncodedImageFormat format, int quality);
    public bool Encode(SKWStream dst, SKEncodedImageFormat format, int quality);
    private void Swap(SKBitmap other);
    public SKShader ToShader();
    public SKShader ToShader(SKShaderTileMode tmx, SKShaderTileMode tmy);
    public SKShader ToShader(SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix);
}
[FlagsAttribute]
public enum SkiaSharp.SKBitmapAllocFlags : Enum {
    public int value__;
    public static SKBitmapAllocFlags None;
    public static SKBitmapAllocFlags ZeroPixels;
}
public class SkiaSharp.SKBitmapReleaseDelegate : MulticastDelegate {
    public SKBitmapReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKBitmapReleaseProxyDelegate : MulticastDelegate {
    public SKBitmapReleaseProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(Void* addr, Void* context);
    public virtual IAsyncResult BeginInvoke(Void* addr, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public enum SkiaSharp.SKBitmapResizeMethod : Enum {
    public int value__;
    public static SKBitmapResizeMethod Box;
    public static SKBitmapResizeMethod Triangle;
    public static SKBitmapResizeMethod Lanczos3;
    public static SKBitmapResizeMethod Hamming;
    public static SKBitmapResizeMethod Mitchell;
}
public enum SkiaSharp.SKBlendMode : Enum {
    public int value__;
    public static SKBlendMode Clear;
    public static SKBlendMode Src;
    public static SKBlendMode Dst;
    public static SKBlendMode SrcOver;
    public static SKBlendMode DstOver;
    public static SKBlendMode SrcIn;
    public static SKBlendMode DstIn;
    public static SKBlendMode SrcOut;
    public static SKBlendMode DstOut;
    public static SKBlendMode SrcATop;
    public static SKBlendMode DstATop;
    public static SKBlendMode Xor;
    public static SKBlendMode Plus;
    public static SKBlendMode Modulate;
    public static SKBlendMode Screen;
    public static SKBlendMode Overlay;
    public static SKBlendMode Darken;
    public static SKBlendMode Lighten;
    public static SKBlendMode ColorDodge;
    public static SKBlendMode ColorBurn;
    public static SKBlendMode HardLight;
    public static SKBlendMode SoftLight;
    public static SKBlendMode Difference;
    public static SKBlendMode Exclusion;
    public static SKBlendMode Multiply;
    public static SKBlendMode Hue;
    public static SKBlendMode Saturation;
    public static SKBlendMode Color;
    public static SKBlendMode Luminosity;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
[ObsoleteAttribute]
public enum SkiaSharp.SKBlurMaskFilterFlags : Enum {
    public int value__;
    public static SKBlurMaskFilterFlags None;
    public static SKBlurMaskFilterFlags IgnoreTransform;
    public static SKBlurMaskFilterFlags HighQuality;
    public static SKBlurMaskFilterFlags All;
}
public enum SkiaSharp.SKBlurStyle : Enum {
    public int value__;
    public static SKBlurStyle Normal;
    public static SKBlurStyle Solid;
    public static SKBlurStyle Outer;
    public static SKBlurStyle Inner;
}
public class SkiaSharp.SKCanvas : SKObject {
    private static int PatchCornerCount;
    private static int PatchCubicsCount;
    private static double RadiansCircle;
    private static double DegreesCircle;
    public SKRect LocalClipBounds { get; }
    public SKRectI DeviceClipBounds { get; }
    public bool IsClipEmpty { get; }
    public bool IsClipRect { get; }
    public SKMatrix TotalMatrix { get; }
    public int SaveCount { get; }
    internal SKCanvas(IntPtr handle, bool owns);
    public SKCanvas(SKBitmap bitmap);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public void Discard();
    public bool QuickReject(SKRect rect);
    public bool QuickReject(SKPath path);
    public int Save();
    public int SaveLayer(SKRect limit, SKPaint paint);
    public int SaveLayer(SKPaint paint);
    public int SaveLayer();
    public void DrawColor(SKColor color, SKBlendMode mode);
    public void DrawColor(SKColorF color, SKBlendMode mode);
    public void DrawLine(SKPoint p0, SKPoint p1, SKPaint paint);
    public void DrawLine(float x0, float y0, float x1, float y1, SKPaint paint);
    public void Clear();
    public void Clear(SKColor color);
    public void Clear(SKColorF color);
    public void Restore();
    public void RestoreToCount(int count);
    public void Translate(float dx, float dy);
    public void Translate(SKPoint point);
    public void Scale(float s);
    public void Scale(float sx, float sy);
    public void Scale(SKPoint size);
    public void Scale(float sx, float sy, float px, float py);
    public void RotateDegrees(float degrees);
    public void RotateRadians(float radians);
    public void RotateDegrees(float degrees, float px, float py);
    public void RotateRadians(float radians, float px, float py);
    public void Skew(float sx, float sy);
    public void Skew(SKPoint skew);
    public void Concat(SKMatrix& m);
    public void ClipRect(SKRect rect, SKClipOperation operation, bool antialias);
    public void ClipRoundRect(SKRoundRect rect, SKClipOperation operation, bool antialias);
    public void ClipPath(SKPath path, SKClipOperation operation, bool antialias);
    public void ClipRegion(SKRegion region, SKClipOperation operation);
    public SKRect get_LocalClipBounds();
    public SKRectI get_DeviceClipBounds();
    public bool get_IsClipEmpty();
    public bool get_IsClipRect();
    public bool GetLocalClipBounds(SKRect& bounds);
    public bool GetDeviceClipBounds(SKRectI& bounds);
    public void DrawPaint(SKPaint paint);
    public void DrawRegion(SKRegion region, SKPaint paint);
    public void DrawRect(float x, float y, float w, float h, SKPaint paint);
    public void DrawRect(SKRect rect, SKPaint paint);
    public void DrawRoundRect(SKRoundRect rect, SKPaint paint);
    public void DrawRoundRect(float x, float y, float w, float h, float rx, float ry, SKPaint paint);
    public void DrawRoundRect(SKRect rect, float rx, float ry, SKPaint paint);
    public void DrawRoundRect(SKRect rect, SKSize r, SKPaint paint);
    public void DrawOval(float cx, float cy, float rx, float ry, SKPaint paint);
    public void DrawOval(SKPoint c, SKSize r, SKPaint paint);
    public void DrawOval(SKRect rect, SKPaint paint);
    public void DrawCircle(float cx, float cy, float radius, SKPaint paint);
    public void DrawCircle(SKPoint c, float radius, SKPaint paint);
    public void DrawPath(SKPath path, SKPaint paint);
    public void DrawPoints(SKPointMode mode, SKPoint[] points, SKPaint paint);
    public void DrawPoint(SKPoint p, SKPaint paint);
    public void DrawPoint(float x, float y, SKPaint paint);
    public void DrawPoint(SKPoint p, SKColor color);
    public void DrawPoint(float x, float y, SKColor color);
    public void DrawImage(SKImage image, SKPoint p, SKPaint paint);
    public void DrawImage(SKImage image, float x, float y, SKPaint paint);
    public void DrawImage(SKImage image, SKRect dest, SKPaint paint);
    public void DrawImage(SKImage image, SKRect source, SKRect dest, SKPaint paint);
    public void DrawPicture(SKPicture picture, float x, float y, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKPoint p, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKMatrix& matrix, SKPaint paint);
    public void DrawPicture(SKPicture picture, SKPaint paint);
    public void DrawDrawable(SKDrawable drawable, SKMatrix& matrix);
    public void DrawDrawable(SKDrawable drawable, float x, float y);
    public void DrawDrawable(SKDrawable drawable, SKPoint p);
    public void DrawBitmap(SKBitmap bitmap, SKPoint p, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, float x, float y, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, SKRect dest, SKPaint paint);
    public void DrawBitmap(SKBitmap bitmap, SKRect source, SKRect dest, SKPaint paint);
    public void DrawSurface(SKSurface surface, SKPoint p, SKPaint paint);
    public void DrawSurface(SKSurface surface, float x, float y, SKPaint paint);
    public void DrawText(SKTextBlob text, float x, float y, SKPaint paint);
    public void DrawText(string text, SKPoint p, SKPaint paint);
    public void DrawText(string text, float x, float y, SKPaint paint);
    public void DrawText(string text, float x, float y, SKFont font, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawText(Byte[] text, SKPoint p, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawText(Byte[] text, float x, float y, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawText(IntPtr buffer, int length, SKPoint p, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawText(IntPtr buffer, int length, float x, float y, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawPositionedText(string text, SKPoint[] points, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawPositionedText(Byte[] text, SKPoint[] points, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawText(SKTextBlob, float, float, SKPaint) instead.")]
public void DrawPositionedText(IntPtr buffer, int length, SKPoint[] points, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, SKPoint offset, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, float hOffset, float vOffset, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, SKPoint offset, bool warpGlyphs, SKPaint paint);
    public void DrawTextOnPath(string text, SKPath path, SKPoint offset, bool warpGlyphs, SKFont font, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawTextOnPath(string, SKPath, SKPoint, SKPaint) instead.")]
public void DrawTextOnPath(Byte[] text, SKPath path, SKPoint offset, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawTextOnPath(string, SKPath, float, float, SKPaint) instead.")]
public void DrawTextOnPath(Byte[] text, SKPath path, float hOffset, float vOffset, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawTextOnPath(string, SKPath, SKPoint, SKPaint) instead.")]
public void DrawTextOnPath(IntPtr buffer, int length, SKPath path, SKPoint offset, SKPaint paint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use DrawTextOnPath(string, SKPath, float, float, SKPaint) instead.")]
public void DrawTextOnPath(IntPtr buffer, int length, SKPath path, float hOffset, float vOffset, SKPaint paint);
    public void Flush();
    public void DrawAnnotation(SKRect rect, string key, SKData value);
    public void DrawUrlAnnotation(SKRect rect, SKData value);
    public SKData DrawUrlAnnotation(SKRect rect, string value);
    public void DrawNamedDestinationAnnotation(SKPoint point, SKData value);
    public SKData DrawNamedDestinationAnnotation(SKPoint point, string value);
    public void DrawLinkDestinationAnnotation(SKRect rect, SKData value);
    public SKData DrawLinkDestinationAnnotation(SKRect rect, string value);
    public void DrawBitmapNinePatch(SKBitmap bitmap, SKRectI center, SKRect dst, SKPaint paint);
    public void DrawImageNinePatch(SKImage image, SKRectI center, SKRect dst, SKPaint paint);
    public void DrawBitmapLattice(SKBitmap bitmap, Int32[] xDivs, Int32[] yDivs, SKRect dst, SKPaint paint);
    public void DrawImageLattice(SKImage image, Int32[] xDivs, Int32[] yDivs, SKRect dst, SKPaint paint);
    public void DrawBitmapLattice(SKBitmap bitmap, SKLattice lattice, SKRect dst, SKPaint paint);
    public void DrawImageLattice(SKImage image, SKLattice lattice, SKRect dst, SKPaint paint);
    public void ResetMatrix();
    public void SetMatrix(SKMatrix matrix);
    public SKMatrix get_TotalMatrix();
    public int get_SaveCount();
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKColor[] colors, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, UInt16[] indices, SKPaint paint);
    public void DrawVertices(SKVertexMode vmode, SKPoint[] vertices, SKPoint[] texs, SKColor[] colors, SKBlendMode mode, UInt16[] indices, SKPaint paint);
    public void DrawVertices(SKVertices vertices, SKBlendMode mode, SKPaint paint);
    public void DrawArc(SKRect oval, float startAngle, float sweepAngle, bool useCenter, SKPaint paint);
    public void DrawRoundRectDifference(SKRoundRect outer, SKRoundRect inner, SKPaint paint);
    public void DrawAtlas(SKImage atlas, SKRect[] sprites, SKRotationScaleMatrix[] transforms, SKPaint paint);
    public void DrawAtlas(SKImage atlas, SKRect[] sprites, SKRotationScaleMatrix[] transforms, SKColor[] colors, SKBlendMode mode, SKPaint paint);
    public void DrawAtlas(SKImage atlas, SKRect[] sprites, SKRotationScaleMatrix[] transforms, SKColor[] colors, SKBlendMode mode, SKRect cullRect, SKPaint paint);
    private void DrawAtlas(SKImage atlas, SKRect[] sprites, SKRotationScaleMatrix[] transforms, SKColor[] colors, SKBlendMode mode, SKRect* cullRect, SKPaint paint);
    public void DrawPatch(SKPoint[] cubics, SKColor[] colors, SKPoint[] texCoords, SKPaint paint);
    public void DrawPatch(SKPoint[] cubics, SKColor[] colors, SKPoint[] texCoords, SKBlendMode mode, SKPaint paint);
    internal static SKCanvas GetObject(IntPtr handle, bool owns, bool unrefExisting);
}
public enum SkiaSharp.SKClipOperation : Enum {
    public int value__;
    public static SKClipOperation Difference;
    public static SKClipOperation Intersect;
}
public class SkiaSharp.SKCodec : SKObject {
    public static int MinBufferedBytesNeeded { get; }
    public SKImageInfo Info { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use EncodedOrigin instead.")]
public SKCodecOrigin Origin { get; }
    public SKEncodedOrigin EncodedOrigin { get; }
    public SKEncodedImageFormat EncodedFormat { get; }
    public Byte[] Pixels { get; }
    public int RepetitionCount { get; }
    public int FrameCount { get; }
    public SKCodecFrameInfo[] FrameInfo { get; }
    public SKCodecScanlineOrder ScanlineOrder { get; }
    public int NextScanline { get; }
    internal SKCodec(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public static int get_MinBufferedBytesNeeded();
    public SKImageInfo get_Info();
    public SKCodecOrigin get_Origin();
    public SKEncodedOrigin get_EncodedOrigin();
    public SKEncodedImageFormat get_EncodedFormat();
    public SKSizeI GetScaledDimensions(float desiredScale);
    public bool GetValidSubset(SKRectI& desiredSubset);
    public Byte[] get_Pixels();
    public int get_RepetitionCount();
    public int get_FrameCount();
    public SKCodecFrameInfo[] get_FrameInfo();
    public bool GetFrameInfo(int index, SKCodecFrameInfo& frameInfo);
    public SKCodecResult GetPixels(Byte[]& pixels);
    public SKCodecResult GetPixels(SKImageInfo info, Byte[]& pixels);
    public SKCodecResult GetPixels(SKImageInfo info, Byte[] pixels);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options);
    public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr, int, SKCodecOptions) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr, SKCodecOptions) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, IntPtr colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr, int, SKCodecOptions) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr, SKCodecOptions) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use GetPixels(SKImageInfo, IntPtr) instead.")]
public SKCodecResult GetPixels(SKImageInfo info, IntPtr pixels, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options);
    public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use StartIncrementalDecode(SKImageInfo, IntPtr, int, SKCodecOptions) instead.")]
public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use StartIncrementalDecode(SKImageInfo, IntPtr, int, SKCodecOptions) instead.")]
public SKCodecResult StartIncrementalDecode(SKImageInfo info, IntPtr pixels, int rowBytes, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public SKCodecResult IncrementalDecode(Int32& rowsDecoded);
    public SKCodecResult IncrementalDecode();
    public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options);
    public SKCodecResult StartScanlineDecode(SKImageInfo info);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use StartScanlineDecode(SKImageInfo, SKCodecOptions) instead.")]
public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options, IntPtr colorTable, Int32& colorTableCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use StartScanlineDecode(SKImageInfo, SKCodecOptions) instead.")]
public SKCodecResult StartScanlineDecode(SKImageInfo info, SKCodecOptions options, SKColorTable colorTable, Int32& colorTableCount);
    public int GetScanlines(IntPtr dst, int countLines, int rowBytes);
    public bool SkipScanlines(int countLines);
    public SKCodecScanlineOrder get_ScanlineOrder();
    public int get_NextScanline();
    public int GetOutputScanline(int inputScanline);
    public static SKCodec Create(string filename);
    public static SKCodec Create(string filename, SKCodecResult& result);
    public static SKCodec Create(Stream stream);
    public static SKCodec Create(Stream stream, SKCodecResult& result);
    public static SKCodec Create(SKStream stream);
    public static SKCodec Create(SKStream stream, SKCodecResult& result);
    public static SKCodec Create(SKData data);
    internal static SKStream WrapManagedStream(Stream stream);
    internal static SKCodec GetObject(IntPtr handle);
}
public enum SkiaSharp.SKCodecAnimationDisposalMethod : Enum {
    public int value__;
    public static SKCodecAnimationDisposalMethod Keep;
    public static SKCodecAnimationDisposalMethod RestoreBackgroundColor;
    public static SKCodecAnimationDisposalMethod RestorePrevious;
}
public class SkiaSharp.SKCodecFrameInfo : ValueType {
    private int fRequiredFrame;
    private int fDuration;
    private byte fFullyReceived;
    private SKAlphaType fAlphaType;
    private SKCodecAnimationDisposalMethod fDisposalMethod;
    public int RequiredFrame { get; public set; }
    public int Duration { get; public set; }
    public bool FullyRecieved { get; public set; }
    public SKAlphaType AlphaType { get; public set; }
    public SKCodecAnimationDisposalMethod DisposalMethod { get; public set; }
    [IsReadOnlyAttribute]
public int get_RequiredFrame();
    public void set_RequiredFrame(int value);
    [IsReadOnlyAttribute]
public int get_Duration();
    public void set_Duration(int value);
    [IsReadOnlyAttribute]
public bool get_FullyRecieved();
    public void set_FullyRecieved(bool value);
    [IsReadOnlyAttribute]
public SKAlphaType get_AlphaType();
    public void set_AlphaType(SKAlphaType value);
    [IsReadOnlyAttribute]
public SKCodecAnimationDisposalMethod get_DisposalMethod();
    public void set_DisposalMethod(SKCodecAnimationDisposalMethod value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKCodecFrameInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKCodecFrameInfo left, SKCodecFrameInfo right);
    public static bool op_Inequality(SKCodecFrameInfo left, SKCodecFrameInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKCodecOptions : ValueType {
    public static SKCodecOptions Default;
    [CompilerGeneratedAttribute]
private SKZeroInitialized <ZeroInitialized>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SKRectI> <Subset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrameIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorFrame>k__BackingField;
    public SKZeroInitialized ZeroInitialized { get; public set; }
    public Nullable`1<SKRectI> Subset { get; public set; }
    public bool HasSubset { get; }
    public int FrameIndex { get; public set; }
    public int PriorFrame { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKTransferFunctionBehavior PremulBehavior { get; public set; }
    private static SKCodecOptions();
    public SKCodecOptions(SKZeroInitialized zeroInitialized);
    public SKCodecOptions(SKZeroInitialized zeroInitialized, SKRectI subset);
    public SKCodecOptions(SKRectI subset);
    public SKCodecOptions(int frameIndex);
    public SKCodecOptions(int frameIndex, int priorFrame);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKZeroInitialized get_ZeroInitialized();
    [CompilerGeneratedAttribute]
public void set_ZeroInitialized(SKZeroInitialized value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<SKRectI> get_Subset();
    [CompilerGeneratedAttribute]
public void set_Subset(Nullable`1<SKRectI> value);
    [IsReadOnlyAttribute]
public bool get_HasSubset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_FrameIndex();
    [CompilerGeneratedAttribute]
public void set_FrameIndex(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_PriorFrame();
    [CompilerGeneratedAttribute]
public void set_PriorFrame(int value);
    [IsReadOnlyAttribute]
public SKTransferFunctionBehavior get_PremulBehavior();
    public void set_PremulBehavior(SKTransferFunctionBehavior value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKCodecOptions obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKCodecOptions left, SKCodecOptions right);
    public static bool op_Inequality(SKCodecOptions left, SKCodecOptions right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal class SkiaSharp.SKCodecOptionsInternal : ValueType {
    public SKZeroInitialized fZeroInitialized;
    public SKRectI* fSubset;
    public int fFrameIndex;
    public int fPriorFrame;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKCodecOptionsInternal obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKCodecOptionsInternal left, SKCodecOptionsInternal right);
    public static bool op_Inequality(SKCodecOptionsInternal left, SKCodecOptionsInternal right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKEncodedOrigin instead.")]
public enum SkiaSharp.SKCodecOrigin : Enum {
    public int value__;
    public static SKCodecOrigin TopLeft;
    public static SKCodecOrigin TopRight;
    public static SKCodecOrigin BottomRight;
    public static SKCodecOrigin BottomLeft;
    public static SKCodecOrigin LeftTop;
    public static SKCodecOrigin RightTop;
    public static SKCodecOrigin RightBottom;
    public static SKCodecOrigin LeftBottom;
}
public enum SkiaSharp.SKCodecResult : Enum {
    public int value__;
    public static SKCodecResult Success;
    public static SKCodecResult IncompleteInput;
    public static SKCodecResult ErrorInInput;
    public static SKCodecResult InvalidConversion;
    public static SKCodecResult InvalidScale;
    public static SKCodecResult InvalidParameters;
    public static SKCodecResult InvalidInput;
    public static SKCodecResult CouldNotRewind;
    public static SKCodecResult InternalError;
    public static SKCodecResult Unimplemented;
}
public enum SkiaSharp.SKCodecScanlineOrder : Enum {
    public int value__;
    public static SKCodecScanlineOrder TopDown;
    public static SKCodecScanlineOrder BottomUp;
}
[IsReadOnlyAttribute]
public class SkiaSharp.SKColor : ValueType {
    public static SKColor Empty;
    private UInt32 color;
    public byte Alpha { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public float Hue { get; }
    public SKColor(UInt32 value);
    public SKColor(byte red, byte green, byte blue, byte alpha);
    public SKColor(byte red, byte green, byte blue);
    public SKColor WithRed(byte red);
    public SKColor WithGreen(byte green);
    public SKColor WithBlue(byte blue);
    public SKColor WithAlpha(byte alpha);
    public byte get_Alpha();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public float get_Hue();
    public static SKColor FromHsl(float h, float s, float l, byte a);
    public static SKColor FromHsv(float h, float s, float v, byte a);
    public void ToHsl(Single& h, Single& s, Single& l);
    public void ToHsv(Single& h, Single& s, Single& v);
    public virtual string ToString();
    public sealed virtual bool Equals(SKColor obj);
    public virtual bool Equals(object other);
    public static bool op_Equality(SKColor left, SKColor right);
    public static bool op_Inequality(SKColor left, SKColor right);
    public virtual int GetHashCode();
    public static SKColor op_Implicit(UInt32 color);
    public static UInt32 op_Explicit(SKColor color);
    public static SKColor Parse(string hexString);
    public static bool TryParse(string hexString, SKColor& color);
}
public enum SkiaSharp.SKColorChannel : Enum {
    public int value__;
    public static SKColorChannel R;
    public static SKColorChannel G;
    public static SKColorChannel B;
    public static SKColorChannel A;
}
[IsReadOnlyAttribute]
public class SkiaSharp.SKColorF : ValueType {
    private static float EPSILON;
    public static SKColorF Empty;
    private float fR;
    private float fG;
    private float fB;
    private float fA;
    public float Hue { get; }
    public float Red { get; }
    public float Green { get; }
    public float Blue { get; }
    public float Alpha { get; }
    public SKColorF(float red, float green, float blue);
    public SKColorF(float red, float green, float blue, float alpha);
    public SKColorF WithRed(float red);
    public SKColorF WithGreen(float green);
    public SKColorF WithBlue(float blue);
    public SKColorF WithAlpha(float alpha);
    public float get_Hue();
    public SKColorF Clamp();
    public static SKColorF FromHsl(float h, float s, float l, float a);
    private static float HueToRgb(float v1, float v2, float vH);
    public static SKColorF FromHsv(float h, float s, float v, float a);
    public void ToHsl(Single& h, Single& s, Single& l);
    public void ToHsv(Single& h, Single& s, Single& v);
    public virtual string ToString();
    public static SKColorF op_Implicit(SKColor color);
    public static SKColor op_Explicit(SKColorF color);
    public float get_Red();
    public float get_Green();
    public float get_Blue();
    public float get_Alpha();
    public sealed virtual bool Equals(SKColorF obj);
    public virtual bool Equals(object obj);
    public static bool op_Equality(SKColorF left, SKColorF right);
    public static bool op_Inequality(SKColorF left, SKColorF right);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static float <Clamp>g__Clamp|10_0(float v);
}
public class SkiaSharp.SKColorFilter : SKObject {
    public static int ColorMatrixSize;
    public static int TableMaxLength;
    internal SKColorFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKColorFilter CreateBlendMode(SKColor c, SKBlendMode mode);
    public static SKColorFilter CreateLighting(SKColor mul, SKColor add);
    public static SKColorFilter CreateCompose(SKColorFilter outer, SKColorFilter inner);
    public static SKColorFilter CreateColorMatrix(Single[] matrix);
    public static SKColorFilter CreateLumaColor();
    public static SKColorFilter CreateTable(Byte[] table);
    public static SKColorFilter CreateTable(Byte[] tableA, Byte[] tableR, Byte[] tableG, Byte[] tableB);
    public static SKColorFilter CreateHighContrast(SKHighContrastConfig config);
    public static SKColorFilter CreateHighContrast(bool grayscale, SKHighContrastConfigInvertStyle invertStyle, float contrast);
    internal static SKColorFilter GetObject(IntPtr handle);
}
public class SkiaSharp.SKColors : ValueType {
    public static SKColor AliceBlue;
    public static SKColor AntiqueWhite;
    public static SKColor Aqua;
    public static SKColor Aquamarine;
    public static SKColor Azure;
    public static SKColor Beige;
    public static SKColor Bisque;
    public static SKColor Black;
    public static SKColor BlanchedAlmond;
    public static SKColor Blue;
    public static SKColor BlueViolet;
    public static SKColor Brown;
    public static SKColor BurlyWood;
    public static SKColor CadetBlue;
    public static SKColor Chartreuse;
    public static SKColor Chocolate;
    public static SKColor Coral;
    public static SKColor CornflowerBlue;
    public static SKColor Cornsilk;
    public static SKColor Crimson;
    public static SKColor Cyan;
    public static SKColor DarkBlue;
    public static SKColor DarkCyan;
    public static SKColor DarkGoldenrod;
    public static SKColor DarkGray;
    public static SKColor DarkGreen;
    public static SKColor DarkKhaki;
    public static SKColor DarkMagenta;
    public static SKColor DarkOliveGreen;
    public static SKColor DarkOrange;
    public static SKColor DarkOrchid;
    public static SKColor DarkRed;
    public static SKColor DarkSalmon;
    public static SKColor DarkSeaGreen;
    public static SKColor DarkSlateBlue;
    public static SKColor DarkSlateGray;
    public static SKColor DarkTurquoise;
    public static SKColor DarkViolet;
    public static SKColor DeepPink;
    public static SKColor DeepSkyBlue;
    public static SKColor DimGray;
    public static SKColor DodgerBlue;
    public static SKColor Firebrick;
    public static SKColor FloralWhite;
    public static SKColor ForestGreen;
    public static SKColor Fuchsia;
    public static SKColor Gainsboro;
    public static SKColor GhostWhite;
    public static SKColor Gold;
    public static SKColor Goldenrod;
    public static SKColor Gray;
    public static SKColor Green;
    public static SKColor GreenYellow;
    public static SKColor Honeydew;
    public static SKColor HotPink;
    public static SKColor IndianRed;
    public static SKColor Indigo;
    public static SKColor Ivory;
    public static SKColor Khaki;
    public static SKColor Lavender;
    public static SKColor LavenderBlush;
    public static SKColor LawnGreen;
    public static SKColor LemonChiffon;
    public static SKColor LightBlue;
    public static SKColor LightCoral;
    public static SKColor LightCyan;
    public static SKColor LightGoldenrodYellow;
    public static SKColor LightGray;
    public static SKColor LightGreen;
    public static SKColor LightPink;
    public static SKColor LightSalmon;
    public static SKColor LightSeaGreen;
    public static SKColor LightSkyBlue;
    public static SKColor LightSlateGray;
    public static SKColor LightSteelBlue;
    public static SKColor LightYellow;
    public static SKColor Lime;
    public static SKColor LimeGreen;
    public static SKColor Linen;
    public static SKColor Magenta;
    public static SKColor Maroon;
    public static SKColor MediumAquamarine;
    public static SKColor MediumBlue;
    public static SKColor MediumOrchid;
    public static SKColor MediumPurple;
    public static SKColor MediumSeaGreen;
    public static SKColor MediumSlateBlue;
    public static SKColor MediumSpringGreen;
    public static SKColor MediumTurquoise;
    public static SKColor MediumVioletRed;
    public static SKColor MidnightBlue;
    public static SKColor MintCream;
    public static SKColor MistyRose;
    public static SKColor Moccasin;
    public static SKColor NavajoWhite;
    public static SKColor Navy;
    public static SKColor OldLace;
    public static SKColor Olive;
    public static SKColor OliveDrab;
    public static SKColor Orange;
    public static SKColor OrangeRed;
    public static SKColor Orchid;
    public static SKColor PaleGoldenrod;
    public static SKColor PaleGreen;
    public static SKColor PaleTurquoise;
    public static SKColor PaleVioletRed;
    public static SKColor PapayaWhip;
    public static SKColor PeachPuff;
    public static SKColor Peru;
    public static SKColor Pink;
    public static SKColor Plum;
    public static SKColor PowderBlue;
    public static SKColor Purple;
    public static SKColor Red;
    public static SKColor RosyBrown;
    public static SKColor RoyalBlue;
    public static SKColor SaddleBrown;
    public static SKColor Salmon;
    public static SKColor SandyBrown;
    public static SKColor SeaGreen;
    public static SKColor SeaShell;
    public static SKColor Sienna;
    public static SKColor Silver;
    public static SKColor SkyBlue;
    public static SKColor SlateBlue;
    public static SKColor SlateGray;
    public static SKColor Snow;
    public static SKColor SpringGreen;
    public static SKColor SteelBlue;
    public static SKColor Tan;
    public static SKColor Teal;
    public static SKColor Thistle;
    public static SKColor Tomato;
    public static SKColor Turquoise;
    public static SKColor Violet;
    public static SKColor Wheat;
    public static SKColor White;
    public static SKColor WhiteSmoke;
    public static SKColor Yellow;
    public static SKColor YellowGreen;
    public static SKColor Transparent;
    public static SKColor Empty { get; }
    private static SKColors();
    public static SKColor get_Empty();
}
public class SkiaSharp.SKColorSpace : SKObject {
    private static SKColorSpace srgb;
    private static SKColorSpace srgbLinear;
    public bool GammaIsCloseToSrgb { get; }
    public bool GammaIsLinear { get; }
    public bool IsSrgb { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKColorSpaceType Type { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetNumericalTransferFunction() instead.")]
public SKNamedGamma NamedGamma { get; }
    public bool IsNumericalTransferFunction { get; }
    private static SKColorSpace();
    internal SKColorSpace(IntPtr handle, bool owns);
    internal static void EnsureStaticInstanceAreInitialized();
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.ReferenceNative();
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.UnreferenceNative();
    protected virtual void Dispose(bool disposing);
    public bool get_GammaIsCloseToSrgb();
    public bool get_GammaIsLinear();
    public bool get_IsSrgb();
    public SKColorSpaceType get_Type();
    public SKNamedGamma get_NamedGamma();
    public bool get_IsNumericalTransferFunction();
    public static bool Equal(SKColorSpace left, SKColorSpace right);
    public static SKColorSpace CreateSrgb();
    public static SKColorSpace CreateSrgbLinear();
    public static SKColorSpace CreateIcc(IntPtr input, long length);
    public static SKColorSpace CreateIcc(Byte[] input, long length);
    public static SKColorSpace CreateIcc(Byte[] input);
    public static SKColorSpace CreateIcc(ReadOnlySpan`1<byte> input);
    public static SKColorSpace CreateIcc(SKData input);
    public static SKColorSpace CreateIcc(SKColorSpaceIccProfile profile);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKMatrix44 toXyzD50, SKColorSpaceFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKMatrix44 toXyzD50, SKColorSpaceFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKColorSpaceGamut gamut, SKColorSpaceFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKMatrix44 toXyzD50);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceRenderTargetGamma gamma, SKColorSpaceGamut gamut);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKMatrix44 toXyzD50);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKColorSpaceTransferFn coeffs, SKColorSpaceGamut gamut);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKNamedGamma gamma, SKMatrix44 toXyzD50);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRgb(SKColorSpaceTransferFn, SKColorSpaceXyz) instead.")]
public static SKColorSpace CreateRgb(SKNamedGamma gamma, SKColorSpaceGamut gamut);
    public static SKColorSpace CreateRgb(SKColorSpaceTransferFn transferFn, SKColorSpaceXyz toXyzD50);
    public SKColorSpaceTransferFn GetNumericalTransferFunction();
    public bool GetNumericalTransferFunction(SKColorSpaceTransferFn& fn);
    public SKColorSpaceIccProfile ToProfile();
    public bool ToColorSpaceXyz(SKColorSpaceXyz& toXyzD50);
    public SKColorSpaceXyz ToColorSpaceXyz();
    public SKColorSpace ToLinearGamma();
    public SKColorSpace ToSrgbGamma();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ToColorSpaceXyz() instead.")]
public SKMatrix44 ToXyzD50();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ToColorSpaceXyz(out SKColorSpaceXyz) instead.")]
public bool ToXyzD50(SKMatrix44 toXyzD50);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKMatrix44 FromXyzD50();
    internal static SKColorSpace GetObject(IntPtr handle, bool owns, bool unrefExisting);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
[FlagsAttribute]
public enum SkiaSharp.SKColorSpaceFlags : Enum {
    public int value__;
    public static SKColorSpaceFlags None;
    public static SKColorSpaceFlags NonLinearBlending;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorSpaceXyz instead.")]
public enum SkiaSharp.SKColorSpaceGamut : Enum {
    public int value__;
    public static SKColorSpaceGamut AdobeRgb;
    public static SKColorSpaceGamut Dcip3D65;
    public static SKColorSpaceGamut Rec2020;
    public static SKColorSpaceGamut Srgb;
}
public class SkiaSharp.SKColorSpaceIccProfile : SKObject {
    public long Size { get; }
    public IntPtr Buffer { get; }
    internal SKColorSpaceIccProfile(IntPtr handle, bool owns);
    protected virtual void DisposeNative();
    public long get_Size();
    public IntPtr get_Buffer();
    public bool ToColorSpaceXyz(SKColorSpaceXyz& toXyzD50);
    public SKColorSpaceXyz ToColorSpaceXyz();
    public static SKColorSpaceIccProfile Create(Byte[] data);
    public static SKColorSpaceIccProfile Create(ReadOnlySpan`1<byte> data);
    public static SKColorSpaceIccProfile Create(SKData data);
    public static SKColorSpaceIccProfile Create(IntPtr data, long length);
}
public class SkiaSharp.SKColorSpacePrimaries : ValueType {
    public static SKColorSpacePrimaries Empty;
    private float fRX;
    private float fRY;
    private float fGX;
    private float fGY;
    private float fBX;
    private float fBY;
    private float fWX;
    private float fWY;
    public Single[] Values { get; }
    public float RX { get; public set; }
    public float RY { get; public set; }
    public float GX { get; public set; }
    public float GY { get; public set; }
    public float BX { get; public set; }
    public float BY { get; public set; }
    public float WX { get; public set; }
    public float WY { get; public set; }
    public SKColorSpacePrimaries(Single[] values);
    public SKColorSpacePrimaries(float rx, float ry, float gx, float gy, float bx, float by, float wx, float wy);
    [IsReadOnlyAttribute]
public Single[] get_Values();
    [IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ToColorSpaceXyz() instead.")]
public SKMatrix44 ToXyzD50();
    [IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ToColorSpaceXyz(out SKColorSpaceXyz) instead.")]
public bool ToXyzD50(SKMatrix44 toXyzD50);
    [IsReadOnlyAttribute]
internal SKMatrix44 ToMatrix44();
    [IsReadOnlyAttribute]
internal bool ToMatrix44(SKMatrix44& toXyzD50);
    [IsReadOnlyAttribute]
public bool ToColorSpaceXyz(SKColorSpaceXyz& toXyzD50);
    [IsReadOnlyAttribute]
public SKColorSpaceXyz ToColorSpaceXyz();
    [IsReadOnlyAttribute]
public float get_RX();
    public void set_RX(float value);
    [IsReadOnlyAttribute]
public float get_RY();
    public void set_RY(float value);
    [IsReadOnlyAttribute]
public float get_GX();
    public void set_GX(float value);
    [IsReadOnlyAttribute]
public float get_GY();
    public void set_GY(float value);
    [IsReadOnlyAttribute]
public float get_BX();
    public void set_BX(float value);
    [IsReadOnlyAttribute]
public float get_BY();
    public void set_BY(float value);
    [IsReadOnlyAttribute]
public float get_WX();
    public void set_WX(float value);
    [IsReadOnlyAttribute]
public float get_WY();
    public void set_WY(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKColorSpacePrimaries obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKColorSpacePrimaries left, SKColorSpacePrimaries right);
    public static bool op_Inequality(SKColorSpacePrimaries left, SKColorSpacePrimaries right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorSpaceTransferFn instead.")]
public enum SkiaSharp.SKColorSpaceRenderTargetGamma : Enum {
    public int value__;
    public static SKColorSpaceRenderTargetGamma Linear;
    public static SKColorSpaceRenderTargetGamma Srgb;
}
public class SkiaSharp.SKColorSpaceTransferFn : ValueType {
    public static SKColorSpaceTransferFn Empty;
    private float fG;
    private float fA;
    private float fB;
    private float fC;
    private float fD;
    private float fE;
    private float fF;
    public static SKColorSpaceTransferFn Srgb { get; }
    public static SKColorSpaceTransferFn TwoDotTwo { get; }
    public static SKColorSpaceTransferFn Linear { get; }
    public static SKColorSpaceTransferFn Rec2020 { get; }
    public static SKColorSpaceTransferFn Pq { get; }
    public static SKColorSpaceTransferFn Hlg { get; }
    public Single[] Values { get; }
    public float G { get; public set; }
    public float A { get; public set; }
    public float B { get; public set; }
    public float C { get; public set; }
    public float D { get; public set; }
    public float E { get; public set; }
    public float F { get; public set; }
    public SKColorSpaceTransferFn(Single[] values);
    public SKColorSpaceTransferFn(float g, float a, float b, float c, float d, float e, float f);
    public static SKColorSpaceTransferFn get_Srgb();
    public static SKColorSpaceTransferFn get_TwoDotTwo();
    public static SKColorSpaceTransferFn get_Linear();
    public static SKColorSpaceTransferFn get_Rec2020();
    public static SKColorSpaceTransferFn get_Pq();
    public static SKColorSpaceTransferFn get_Hlg();
    [IsReadOnlyAttribute]
public Single[] get_Values();
    [IsReadOnlyAttribute]
public SKColorSpaceTransferFn Invert();
    [IsReadOnlyAttribute]
public float Transform(float x);
    [IsReadOnlyAttribute]
public float get_G();
    public void set_G(float value);
    [IsReadOnlyAttribute]
public float get_A();
    public void set_A(float value);
    [IsReadOnlyAttribute]
public float get_B();
    public void set_B(float value);
    [IsReadOnlyAttribute]
public float get_C();
    public void set_C(float value);
    [IsReadOnlyAttribute]
public float get_D();
    public void set_D(float value);
    [IsReadOnlyAttribute]
public float get_E();
    public void set_E(float value);
    [IsReadOnlyAttribute]
public float get_F();
    public void set_F(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKColorSpaceTransferFn obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKColorSpaceTransferFn left, SKColorSpaceTransferFn right);
    public static bool op_Inequality(SKColorSpaceTransferFn left, SKColorSpaceTransferFn right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public enum SkiaSharp.SKColorSpaceType : Enum {
    public int value__;
    public static SKColorSpaceType Cmyk;
    public static SKColorSpaceType Gray;
    public static SKColorSpaceType Rgb;
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKColorSpaceXyz : ValueType {
    public static SKColorSpaceXyz Empty;
    private float fM00;
    private float fM01;
    private float fM02;
    private float fM10;
    private float fM11;
    private float fM12;
    private float fM20;
    private float fM21;
    private float fM22;
    public static SKColorSpaceXyz Srgb { get; }
    public static SKColorSpaceXyz AdobeRgb { get; }
    [ObsoleteAttribute("Use DisplayP3 instead.")]
public static SKColorSpaceXyz Dcip3 { get; }
    public static SKColorSpaceXyz DisplayP3 { get; }
    public static SKColorSpaceXyz Rec2020 { get; }
    public static SKColorSpaceXyz Xyz { get; }
    public Single[] Values { get; public set; }
    public float Item { get; }
    public SKColorSpaceXyz(float value);
    public SKColorSpaceXyz(Single[] values);
    public SKColorSpaceXyz(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22);
    public static SKColorSpaceXyz get_Srgb();
    public static SKColorSpaceXyz get_AdobeRgb();
    public static SKColorSpaceXyz get_Dcip3();
    public static SKColorSpaceXyz get_DisplayP3();
    public static SKColorSpaceXyz get_Rec2020();
    public static SKColorSpaceXyz get_Xyz();
    [IsReadOnlyAttribute]
public Single[] get_Values();
    public void set_Values(Single[] value);
    [IsReadOnlyAttribute]
public float get_Item(int x, int y);
    [IsReadOnlyAttribute]
public SKColorSpaceXyz Invert();
    public static SKColorSpaceXyz Concat(SKColorSpaceXyz a, SKColorSpaceXyz b);
    [IsReadOnlyAttribute]
internal SKMatrix44 ToMatrix44();
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKColorSpaceXyz obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKColorSpaceXyz left, SKColorSpaceXyz right);
    public static bool op_Inequality(SKColorSpaceXyz left, SKColorSpaceXyz right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported.")]
public class SkiaSharp.SKColorTable : SKObject {
    public static int MaxLength;
    public int Count { get; }
    public SKPMColor[] Colors { get; }
    public SKColor[] UnPreMultipledColors { get; }
    public SKPMColor Item { get; }
    internal SKColorTable(IntPtr x, bool owns);
    public SKColorTable(int count);
    public SKColorTable(SKColor[] colors);
    public SKColorTable(SKColor[] colors, int count);
    public SKColorTable(SKPMColor[] colors);
    public SKColorTable(SKPMColor[] colors, int count);
    private static IntPtr CreateNew(SKPMColor[] colors, int count);
    protected virtual void Dispose(bool disposing);
    public int get_Count();
    public SKPMColor[] get_Colors();
    public SKColor[] get_UnPreMultipledColors();
    public SKPMColor get_Item(int index);
    public SKColor GetUnPreMultipliedColor(int index);
    public IntPtr ReadColors();
}
public enum SkiaSharp.SKColorType : Enum {
    public int value__;
    public static SKColorType Unknown;
    public static SKColorType Alpha8;
    public static SKColorType Rgb565;
    public static SKColorType Argb4444;
    public static SKColorType Rgba8888;
    public static SKColorType Rgb888x;
    public static SKColorType Bgra8888;
    public static SKColorType Rgba1010102;
    public static SKColorType Rgb101010x;
    public static SKColorType Gray8;
    public static SKColorType RgbaF16;
    public static SKColorType RgbaF16Clamped;
    public static SKColorType RgbaF32;
    public static SKColorType Rg88;
    public static SKColorType AlphaF16;
    public static SKColorType RgF16;
    public static SKColorType Alpha16;
    public static SKColorType Rg1616;
    public static SKColorType Rgba16161616;
    public static SKColorType Bgra1010102;
    public static SKColorType Bgr101010x;
}
internal enum SkiaSharp.SKColorTypeNative : Enum {
    public int value__;
    public static SKColorTypeNative Unknown;
    public static SKColorTypeNative Alpha8;
    public static SKColorTypeNative Rgb565;
    public static SKColorTypeNative Argb4444;
    public static SKColorTypeNative Rgba8888;
    public static SKColorTypeNative Rgb888x;
    public static SKColorTypeNative Bgra8888;
    public static SKColorTypeNative Rgba1010102;
    public static SKColorTypeNative Bgra1010102;
    public static SKColorTypeNative Rgb101010x;
    public static SKColorTypeNative Bgr101010x;
    public static SKColorTypeNative Gray8;
    public static SKColorTypeNative RgbaF16Norm;
    public static SKColorTypeNative RgbaF16;
    public static SKColorTypeNative RgbaF32;
    public static SKColorTypeNative R8g8Unorm;
    public static SKColorTypeNative A16Float;
    public static SKColorTypeNative R16g16Float;
    public static SKColorTypeNative A16Unorm;
    public static SKColorTypeNative R16g16Unorm;
    public static SKColorTypeNative R16g16b16a16Unorm;
}
[FlagsAttribute]
public enum SkiaSharp.SKCropRectFlags : Enum {
    public int value__;
    public static SKCropRectFlags HasNone;
    public static SKCropRectFlags HasLeft;
    public static SKCropRectFlags HasTop;
    public static SKCropRectFlags HasWidth;
    public static SKCropRectFlags HasHeight;
    public static SKCropRectFlags HasAll;
}
public class SkiaSharp.SKData : SKObject {
    internal static int CopyBufferSize;
    private static SKData empty;
    public static SKData Empty { get; }
    public bool IsEmpty { get; }
    public long Size { get; }
    public IntPtr Data { get; }
    public Span`1<byte> Span { get; }
    private static SKData();
    internal SKData(IntPtr x, bool owns);
    internal static void EnsureStaticInstanceAreInitialized();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.ReferenceNative();
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.UnreferenceNative();
    public static SKData get_Empty();
    public static SKData CreateCopy(IntPtr bytes, int length);
    public static SKData CreateCopy(IntPtr bytes, long length);
    public static SKData CreateCopy(IntPtr bytes, ulong length);
    public static SKData CreateCopy(Byte[] bytes);
    public static SKData CreateCopy(Byte[] bytes, ulong length);
    public static SKData CreateCopy(ReadOnlySpan`1<byte> bytes);
    public static SKData Create(int size);
    public static SKData Create(long size);
    public static SKData Create(ulong size);
    public static SKData Create(string filename);
    public static SKData Create(Stream stream);
    public static SKData Create(Stream stream, int length);
    public static SKData Create(Stream stream, ulong length);
    public static SKData Create(Stream stream, long length);
    public static SKData Create(SKStream stream);
    public static SKData Create(SKStream stream, int length);
    public static SKData Create(SKStream stream, ulong length);
    public static SKData Create(SKStream stream, long length);
    public static SKData Create(IntPtr address, int length);
    public static SKData Create(IntPtr address, int length, SKDataReleaseDelegate releaseProc);
    public static SKData Create(IntPtr address, int length, SKDataReleaseDelegate releaseProc, object context);
    internal static SKData FromCString(string str);
    public SKData Subset(ulong offset, ulong length);
    public Byte[] ToArray();
    public bool get_IsEmpty();
    public long get_Size();
    public IntPtr get_Data();
    public Span`1<byte> get_Span();
    public Stream AsStream();
    public Stream AsStream(bool streamDisposesData);
    public ReadOnlySpan`1<byte> AsSpan();
    public void SaveTo(Stream target);
    internal static SKData GetObject(IntPtr handle);
}
public class SkiaSharp.SKDataReleaseDelegate : MulticastDelegate {
    public SKDataReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKDataReleaseProxyDelegate : MulticastDelegate {
    public SKDataReleaseProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(Void* ptr, Void* context);
    public virtual IAsyncResult BeginInvoke(Void* ptr, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorChannel instead.")]
public enum SkiaSharp.SKDisplacementMapEffectChannelSelectorType : Enum {
    public int value__;
    public static SKDisplacementMapEffectChannelSelectorType Unknown;
    public static SKDisplacementMapEffectChannelSelectorType R;
    public static SKDisplacementMapEffectChannelSelectorType G;
    public static SKDisplacementMapEffectChannelSelectorType B;
    public static SKDisplacementMapEffectChannelSelectorType A;
}
public class SkiaSharp.SKDocument : SKObject {
    public static float DefaultRasterDpi;
    internal SKDocument(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public void Abort();
    public SKCanvas BeginPage(float width, float height);
    public SKCanvas BeginPage(float width, float height, SKRect content);
    public void EndPage();
    public void Close();
    public static SKDocument CreateXps(string path);
    public static SKDocument CreateXps(Stream stream);
    public static SKDocument CreateXps(SKWStream stream);
    public static SKDocument CreateXps(string path, float dpi);
    public static SKDocument CreateXps(Stream stream, float dpi);
    public static SKDocument CreateXps(SKWStream stream, float dpi);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreatePdf(SKWStream, SKDocumentPdfMetadata) instead.")]
public static SKDocument CreatePdf(SKWStream stream, SKDocumentPdfMetadata metadata, float dpi);
    public static SKDocument CreatePdf(string path);
    public static SKDocument CreatePdf(Stream stream);
    public static SKDocument CreatePdf(SKWStream stream);
    public static SKDocument CreatePdf(string path, float dpi);
    public static SKDocument CreatePdf(Stream stream, float dpi);
    public static SKDocument CreatePdf(SKWStream stream, float dpi);
    public static SKDocument CreatePdf(string path, SKDocumentPdfMetadata metadata);
    public static SKDocument CreatePdf(Stream stream, SKDocumentPdfMetadata metadata);
    public static SKDocument CreatePdf(SKWStream stream, SKDocumentPdfMetadata metadata);
    internal static SKDocument GetObject(IntPtr handle);
}
public class SkiaSharp.SKDocumentPdfMetadata : ValueType {
    public static float DefaultRasterDpi;
    public static int DefaultEncodingQuality;
    public static SKDocumentPdfMetadata Default;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Producer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Creation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Modified>k__BackingField;
    [CompilerGeneratedAttribute]
private float <RasterDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PdfA>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncodingQuality>k__BackingField;
    public string Title { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Keywords { get; public set; }
    public string Creator { get; public set; }
    public string Producer { get; public set; }
    public Nullable`1<DateTime> Creation { get; public set; }
    public Nullable`1<DateTime> Modified { get; public set; }
    public float RasterDpi { get; public set; }
    public bool PdfA { get; public set; }
    public int EncodingQuality { get; public set; }
    private static SKDocumentPdfMetadata();
    public SKDocumentPdfMetadata(float rasterDpi);
    public SKDocumentPdfMetadata(int encodingQuality);
    public SKDocumentPdfMetadata(float rasterDpi, int encodingQuality);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Creator();
    [CompilerGeneratedAttribute]
public void set_Creator(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Producer();
    [CompilerGeneratedAttribute]
public void set_Producer(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Creation();
    [CompilerGeneratedAttribute]
public void set_Creation(Nullable`1<DateTime> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Modified();
    [CompilerGeneratedAttribute]
public void set_Modified(Nullable`1<DateTime> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public float get_RasterDpi();
    [CompilerGeneratedAttribute]
public void set_RasterDpi(float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PdfA();
    [CompilerGeneratedAttribute]
public void set_PdfA(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_EncodingQuality();
    [CompilerGeneratedAttribute]
public void set_EncodingQuality(int value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKDocumentPdfMetadata obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKDocumentPdfMetadata left, SKDocumentPdfMetadata right);
    public static bool op_Inequality(SKDocumentPdfMetadata left, SKDocumentPdfMetadata right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal class SkiaSharp.SKDocumentPdfMetadataInternal : ValueType {
    public IntPtr fTitle;
    public IntPtr fAuthor;
    public IntPtr fSubject;
    public IntPtr fKeywords;
    public IntPtr fCreator;
    public IntPtr fProducer;
    public SKTimeDateTimeInternal* fCreation;
    public SKTimeDateTimeInternal* fModified;
    public float fRasterDPI;
    public byte fPDFA;
    public int fEncodingQuality;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKDocumentPdfMetadataInternal obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKDocumentPdfMetadataInternal left, SKDocumentPdfMetadataInternal right);
    public static bool op_Inequality(SKDocumentPdfMetadataInternal left, SKDocumentPdfMetadataInternal right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKDrawable : SKObject {
    private static SKManagedDrawableDelegates delegates;
    private int fromNative;
    public UInt32 GenerationId { get; }
    public SKRect Bounds { get; }
    private static SKDrawable();
    protected SKDrawable(bool owns);
    internal SKDrawable(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public UInt32 get_GenerationId();
    public SKRect get_Bounds();
    public void Draw(SKCanvas canvas, SKMatrix& matrix);
    public void Draw(SKCanvas canvas, float x, float y);
    public SKPicture Snapshot();
    public void NotifyDrawingChanged();
    protected virtual void OnDraw(SKCanvas canvas);
    protected virtual SKRect OnGetBounds();
    protected virtual SKPicture OnSnapshot();
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedDrawableDrawProxyDelegate")]
private static void DrawInternal(IntPtr d, Void* context, IntPtr canvas);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedDrawableGetBoundsProxyDelegate")]
private static void GetBoundsInternal(IntPtr d, Void* context, SKRect* rect);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedDrawableNewPictureSnapshotProxyDelegate")]
private static IntPtr NewPictureSnapshotInternal(IntPtr d, Void* context);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedDrawableDestroyProxyDelegate")]
private static void DestroyInternal(IntPtr d, Void* context);
    internal static SKDrawable GetObject(IntPtr handle);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateDropShadow or CreateDropShadowOnly instead.")]
public enum SkiaSharp.SKDropShadowImageFilterShadowMode : Enum {
    public int value__;
    public static SKDropShadowImageFilterShadowMode DrawShadowAndForeground;
    public static SKDropShadowImageFilterShadowMode DrawShadowOnly;
}
public class SkiaSharp.SKDynamicMemoryWStream : SKWStream {
    internal SKDynamicMemoryWStream(IntPtr handle, bool owns);
    public SKData CopyToData();
    public SKStreamAsset DetachAsStream();
    public SKData DetachAsData();
    public void CopyTo(IntPtr data);
    public void CopyTo(Span`1<byte> data);
    public bool CopyTo(SKWStream dst);
    public bool CopyTo(Stream dst);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
}
public enum SkiaSharp.SKEncodedImageFormat : Enum {
    public int value__;
    public static SKEncodedImageFormat Bmp;
    public static SKEncodedImageFormat Gif;
    public static SKEncodedImageFormat Ico;
    public static SKEncodedImageFormat Jpeg;
    public static SKEncodedImageFormat Png;
    public static SKEncodedImageFormat Wbmp;
    public static SKEncodedImageFormat Webp;
    public static SKEncodedImageFormat Pkm;
    public static SKEncodedImageFormat Ktx;
    public static SKEncodedImageFormat Astc;
    public static SKEncodedImageFormat Dng;
    public static SKEncodedImageFormat Heif;
    public static SKEncodedImageFormat Avif;
}
public enum SkiaSharp.SKEncodedOrigin : Enum {
    public int value__;
    public static SKEncodedOrigin TopLeft;
    public static SKEncodedOrigin TopRight;
    public static SKEncodedOrigin BottomRight;
    public static SKEncodedOrigin BottomLeft;
    public static SKEncodedOrigin LeftTop;
    public static SKEncodedOrigin RightTop;
    public static SKEncodedOrigin RightBottom;
    public static SKEncodedOrigin LeftBottom;
    public static SKEncodedOrigin Default;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKTextEncoding instead.")]
public enum SkiaSharp.SKEncoding : Enum {
    public int value__;
    public static SKEncoding Utf8;
    public static SKEncoding Utf16;
    public static SKEncoding Utf32;
}
public class SkiaSharp.SKFileStream : SKStreamAsset {
    public bool IsValid { get; }
    internal SKFileStream(IntPtr handle, bool owns);
    public SKFileStream(string path);
    private static IntPtr CreateNew(string path);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool get_IsValid();
    public static bool IsPathSupported(string path);
    public static SKStreamAsset OpenStream(string path);
}
public class SkiaSharp.SKFileWStream : SKWStream {
    public bool IsValid { get; }
    internal SKFileWStream(IntPtr handle, bool owns);
    public SKFileWStream(string path);
    private static IntPtr CreateNew(string path);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool get_IsValid();
    public static bool IsPathSupported(string path);
    public static SKWStream OpenStream(string path);
}
public enum SkiaSharp.SKFilterQuality : Enum {
    public int value__;
    public static SKFilterQuality None;
    public static SKFilterQuality Low;
    public static SKFilterQuality Medium;
    public static SKFilterQuality High;
}
public class SkiaSharp.SKFont : SKObject {
    internal static float DefaultSize;
    internal static float DefaultScaleX;
    internal static float DefaultSkewX;
    public bool ForceAutoHinting { get; public set; }
    public bool EmbeddedBitmaps { get; public set; }
    public bool Subpixel { get; public set; }
    public bool LinearMetrics { get; public set; }
    public bool Embolden { get; public set; }
    public bool BaselineSnap { get; public set; }
    public SKFontEdging Edging { get; public set; }
    public SKFontHinting Hinting { get; public set; }
    public SKTypeface Typeface { get; public set; }
    public float Size { get; public set; }
    public float ScaleX { get; public set; }
    public float SkewX { get; public set; }
    public float Spacing { get; }
    public SKFontMetrics Metrics { get; }
    internal SKFont(IntPtr handle, bool owns);
    public SKFont(SKTypeface typeface, float size, float scaleX, float skewX);
    protected virtual void DisposeNative();
    public bool get_ForceAutoHinting();
    public void set_ForceAutoHinting(bool value);
    public bool get_EmbeddedBitmaps();
    public void set_EmbeddedBitmaps(bool value);
    public bool get_Subpixel();
    public void set_Subpixel(bool value);
    public bool get_LinearMetrics();
    public void set_LinearMetrics(bool value);
    public bool get_Embolden();
    public void set_Embolden(bool value);
    public bool get_BaselineSnap();
    public void set_BaselineSnap(bool value);
    public SKFontEdging get_Edging();
    public void set_Edging(SKFontEdging value);
    public SKFontHinting get_Hinting();
    public void set_Hinting(SKFontHinting value);
    public SKTypeface get_Typeface();
    public void set_Typeface(SKTypeface value);
    public float get_Size();
    public void set_Size(float value);
    public float get_ScaleX();
    public void set_ScaleX(float value);
    public float get_SkewX();
    public void set_SkewX(float value);
    public float get_Spacing();
    public SKFontMetrics get_Metrics();
    public float GetFontMetrics(SKFontMetrics& metrics);
    public ushort GetGlyph(int codepoint);
    internal UInt16[] GetGlyphs(ReadOnlySpan`1<int> codepoints);
    public void GetGlyphs(ReadOnlySpan`1<int> codepoints, Span`1<ushort> glyphs);
    internal UInt16[] GetGlyphs(string text);
    internal UInt16[] GetGlyphs(ReadOnlySpan`1<char> text);
    internal UInt16[] GetGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding);
    internal UInt16[] GetGlyphs(IntPtr text, int length, SKTextEncoding encoding);
    public void GetGlyphs(string text, Span`1<ushort> glyphs);
    public void GetGlyphs(ReadOnlySpan`1<char> text, Span`1<ushort> glyphs);
    public void GetGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, Span`1<ushort> glyphs);
    public void GetGlyphs(IntPtr text, int length, SKTextEncoding encoding, Span`1<ushort> glyphs);
    internal UInt16[] GetGlyphs(Void* text, int length, SKTextEncoding encoding);
    internal void GetGlyphs(Void* text, int length, SKTextEncoding encoding, Span`1<ushort> glyphs);
    public bool ContainsGlyph(int codepoint);
    public bool ContainsGlyphs(ReadOnlySpan`1<int> codepoints);
    public bool ContainsGlyphs(string text);
    public bool ContainsGlyphs(ReadOnlySpan`1<char> text);
    public bool ContainsGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding);
    public bool ContainsGlyphs(IntPtr text, int length, SKTextEncoding encoding);
    private bool ContainsGlyphs(UInt16[] glyphs);
    public int CountGlyphs(string text);
    public int CountGlyphs(ReadOnlySpan`1<char> text);
    public int CountGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding);
    public int CountGlyphs(IntPtr text, int length, SKTextEncoding encoding);
    internal int CountGlyphs(Void* text, int length, SKTextEncoding encoding);
    internal float MeasureText(string text, SKPaint paint);
    internal float MeasureText(ReadOnlySpan`1<char> text, SKPaint paint);
    internal float MeasureText(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKPaint paint);
    internal float MeasureText(IntPtr text, int length, SKTextEncoding encoding, SKPaint paint);
    internal float MeasureText(string text, SKRect& bounds, SKPaint paint);
    internal float MeasureText(ReadOnlySpan`1<char> text, SKRect& bounds, SKPaint paint);
    internal float MeasureText(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKRect& bounds, SKPaint paint);
    internal float MeasureText(IntPtr text, int length, SKTextEncoding encoding, SKRect& bounds, SKPaint paint);
    internal float MeasureText(Void* text, int length, SKTextEncoding encoding, SKRect* bounds, SKPaint paint);
    public float MeasureText(ReadOnlySpan`1<ushort> glyphs, SKPaint paint);
    public float MeasureText(ReadOnlySpan`1<ushort> glyphs, SKRect& bounds, SKPaint paint);
    internal int BreakText(string text, float maxWidth, Single& measuredWidth, SKPaint paint);
    internal int BreakText(ReadOnlySpan`1<char> text, float maxWidth, Single& measuredWidth, SKPaint paint);
    internal int BreakText(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, float maxWidth, Single& measuredWidth, SKPaint paint);
    internal int BreakText(IntPtr text, int length, SKTextEncoding encoding, float maxWidth, Single& measuredWidth, SKPaint paint);
    internal int BreakText(Void* text, int length, SKTextEncoding encoding, float maxWidth, Single* measuredWidth, SKPaint paint);
    internal SKPoint[] GetGlyphPositions(string text, SKPoint origin);
    internal SKPoint[] GetGlyphPositions(ReadOnlySpan`1<char> text, SKPoint origin);
    internal SKPoint[] GetGlyphPositions(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKPoint origin);
    internal SKPoint[] GetGlyphPositions(IntPtr text, int length, SKTextEncoding encoding, SKPoint origin);
    internal void GetGlyphPositions(string text, Span`1<SKPoint> offsets, SKPoint origin);
    internal void GetGlyphPositions(ReadOnlySpan`1<char> text, Span`1<SKPoint> offsets, SKPoint origin);
    internal void GetGlyphPositions(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, Span`1<SKPoint> offsets, SKPoint origin);
    internal void GetGlyphPositions(IntPtr text, int length, SKTextEncoding encoding, Span`1<SKPoint> offsets, SKPoint origin);
    internal SKPoint[] GetGlyphPositions(Void* text, int length, SKTextEncoding encoding, SKPoint origin);
    internal void GetGlyphPositions(Void* text, int length, SKTextEncoding encoding, Span`1<SKPoint> offsets, SKPoint origin);
    internal SKPoint[] GetGlyphPositions(ReadOnlySpan`1<ushort> glyphs, SKPoint origin);
    public void GetGlyphPositions(ReadOnlySpan`1<ushort> glyphs, Span`1<SKPoint> positions, SKPoint origin);
    internal Single[] GetGlyphOffsets(string text, float origin);
    internal Single[] GetGlyphOffsets(ReadOnlySpan`1<char> text, float origin);
    internal Single[] GetGlyphOffsets(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, float origin);
    internal Single[] GetGlyphOffsets(IntPtr text, int length, SKTextEncoding encoding, float origin);
    internal void GetGlyphOffsets(string text, Span`1<float> offsets, float origin);
    internal void GetGlyphOffsets(ReadOnlySpan`1<char> text, Span`1<float> offsets, float origin);
    internal void GetGlyphOffsets(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, Span`1<float> offsets, float origin);
    internal void GetGlyphOffsets(IntPtr text, int length, SKTextEncoding encoding, Span`1<float> offsets, float origin);
    internal Single[] GetGlyphOffsets(Void* text, int length, SKTextEncoding encoding, float origin);
    internal void GetGlyphOffsets(Void* text, int length, SKTextEncoding encoding, Span`1<float> offsets, float origin);
    internal Single[] GetGlyphOffsets(ReadOnlySpan`1<ushort> glyphs, float origin);
    public void GetGlyphOffsets(ReadOnlySpan`1<ushort> glyphs, Span`1<float> offsets, float origin);
    internal Single[] GetGlyphWidths(string text, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<char> text, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKPaint paint);
    internal Single[] GetGlyphWidths(IntPtr text, int length, SKTextEncoding encoding, SKPaint paint);
    internal Single[] GetGlyphWidths(string text, SKRect[]& bounds, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<char> text, SKRect[]& bounds, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKRect[]& bounds, SKPaint paint);
    internal Single[] GetGlyphWidths(IntPtr text, int length, SKTextEncoding encoding, SKRect[]& bounds, SKPaint paint);
    internal void GetGlyphWidths(string text, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    internal void GetGlyphWidths(ReadOnlySpan`1<char> text, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    internal void GetGlyphWidths(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    internal void GetGlyphWidths(IntPtr text, int length, SKTextEncoding encoding, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    internal Single[] GetGlyphWidths(Void* text, int length, SKTextEncoding encoding, SKPaint paint);
    internal Single[] GetGlyphWidths(Void* text, int length, SKTextEncoding encoding, SKRect[]& bounds, SKPaint paint);
    internal void GetGlyphWidths(Void* text, int length, SKTextEncoding encoding, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<ushort> glyphs, SKPaint paint);
    internal Single[] GetGlyphWidths(ReadOnlySpan`1<ushort> glyphs, SKRect[]& bounds, SKPaint paint);
    public void GetGlyphWidths(ReadOnlySpan`1<ushort> glyphs, Span`1<float> widths, Span`1<SKRect> bounds, SKPaint paint);
    public SKPath GetGlyphPath(ushort glyph);
    internal SKPath GetTextPath(string text, SKPoint origin);
    internal SKPath GetTextPath(ReadOnlySpan`1<char> text, SKPoint origin);
    internal SKPath GetTextPath(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKPoint origin);
    internal SKPath GetTextPath(IntPtr text, int length, SKTextEncoding encoding, SKPoint origin);
    internal SKPath GetTextPath(Void* text, int length, SKTextEncoding encoding, SKPoint origin);
    internal SKPath GetTextPath(string text, ReadOnlySpan`1<SKPoint> positions);
    internal SKPath GetTextPath(ReadOnlySpan`1<char> text, ReadOnlySpan`1<SKPoint> positions);
    internal SKPath GetTextPath(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, ReadOnlySpan`1<SKPoint> positions);
    internal SKPath GetTextPath(IntPtr text, int length, SKTextEncoding encoding, ReadOnlySpan`1<SKPoint> positions);
    internal SKPath GetTextPath(Void* text, int length, SKTextEncoding encoding, ReadOnlySpan`1<SKPoint> positions);
    public void GetGlyphPaths(ReadOnlySpan`1<ushort> glyphs, SKGlyphPathDelegate glyphPathDelegate);
    internal SKPath GetTextPathOnPath(string text, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(ReadOnlySpan`1<char> text, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(IntPtr text, int length, SKTextEncoding encoding, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(Void* text, int length, SKTextEncoding encoding, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(ReadOnlySpan`1<ushort> glyphs, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal SKPath GetTextPathOnPath(ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<float> glyphWidths, ReadOnlySpan`1<SKPoint> glyphPositions, SKPath path, SKTextAlign textAlign);
    private bool ValidateTextArgs(Void* text, int length, SKTextEncoding encoding);
    internal static SKFont GetObject(IntPtr handle, bool owns);
    [CompilerGeneratedAttribute]
internal static void <GetTextPathOnPath>g__MorphPath|149_0(SKPath dst, SKPath src, SKPathMeasure meas, SKMatrix& matrix);
    [CompilerGeneratedAttribute]
internal static void <GetTextPathOnPath>g__MorphPoints|149_1(Span`1<SKPoint> dst, Span`1<SKPoint> src, int count, SKPathMeasure meas, SKMatrix& matrix);
}
public enum SkiaSharp.SKFontEdging : Enum {
    public int value__;
    public static SKFontEdging Alias;
    public static SKFontEdging Antialias;
    public static SKFontEdging SubpixelAntialias;
}
public enum SkiaSharp.SKFontHinting : Enum {
    public int value__;
    public static SKFontHinting None;
    public static SKFontHinting Slight;
    public static SKFontHinting Normal;
    public static SKFontHinting Full;
}
public class SkiaSharp.SKFontManager : SKObject {
    private static SKFontManager defaultManager;
    public static SKFontManager Default { get; }
    public int FontFamilyCount { get; }
    public IEnumerable`1<string> FontFamilies { get; }
    private static SKFontManager();
    internal SKFontManager(IntPtr handle, bool owns);
    internal static void EnsureStaticInstanceAreInitialized();
    protected virtual void Dispose(bool disposing);
    public static SKFontManager get_Default();
    public int get_FontFamilyCount();
    [IteratorStateMachineAttribute("SkiaSharp.SKFontManager/<get_FontFamilies>d__10")]
public IEnumerable`1<string> get_FontFamilies();
    public string GetFamilyName(int index);
    public String[] GetFontFamilies();
    public SKFontStyleSet GetFontStyles(int index);
    public SKFontStyleSet GetFontStyles(string familyName);
    public SKTypeface MatchFamily(string familyName);
    public SKTypeface MatchFamily(string familyName, SKFontStyle style);
    public SKTypeface MatchTypeface(SKTypeface face, SKFontStyle style);
    public SKTypeface CreateTypeface(string path, int index);
    public SKTypeface CreateTypeface(Stream stream, int index);
    public SKTypeface CreateTypeface(SKStreamAsset stream, int index);
    public SKTypeface CreateTypeface(SKData data, int index);
    public SKTypeface MatchCharacter(char character);
    public SKTypeface MatchCharacter(int character);
    public SKTypeface MatchCharacter(string familyName, char character);
    public SKTypeface MatchCharacter(string familyName, int character);
    public SKTypeface MatchCharacter(string familyName, String[] bcp47, char character);
    public SKTypeface MatchCharacter(string familyName, String[] bcp47, int character);
    public SKTypeface MatchCharacter(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant, String[] bcp47, char character);
    public SKTypeface MatchCharacter(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant, String[] bcp47, int character);
    public SKTypeface MatchCharacter(string familyName, int weight, int width, SKFontStyleSlant slant, String[] bcp47, int character);
    public SKTypeface MatchCharacter(string familyName, SKFontStyle style, String[] bcp47, int character);
    public static SKFontManager CreateDefault();
    internal static SKFontManager GetObject(IntPtr handle);
}
public class SkiaSharp.SKFontMetrics : ValueType {
    private static UInt32 flagsUnderlineThicknessIsValid;
    private static UInt32 flagsUnderlinePositionIsValid;
    private static UInt32 flagsStrikeoutThicknessIsValid;
    private static UInt32 flagsStrikeoutPositionIsValid;
    private UInt32 fFlags;
    private float fTop;
    private float fAscent;
    private float fDescent;
    private float fBottom;
    private float fLeading;
    private float fAvgCharWidth;
    private float fMaxCharWidth;
    private float fXMin;
    private float fXMax;
    private float fXHeight;
    private float fCapHeight;
    private float fUnderlineThickness;
    private float fUnderlinePosition;
    private float fStrikeoutThickness;
    private float fStrikeoutPosition;
    public float Top { get; }
    public float Ascent { get; }
    public float Descent { get; }
    public float Bottom { get; }
    public float Leading { get; }
    public float AverageCharacterWidth { get; }
    public float MaxCharacterWidth { get; }
    public float XMin { get; }
    public float XMax { get; }
    public float XHeight { get; }
    public float CapHeight { get; }
    public Nullable`1<float> UnderlineThickness { get; }
    public Nullable`1<float> UnderlinePosition { get; }
    public Nullable`1<float> StrikeoutThickness { get; }
    public Nullable`1<float> StrikeoutPosition { get; }
    [IsReadOnlyAttribute]
public float get_Top();
    [IsReadOnlyAttribute]
public float get_Ascent();
    [IsReadOnlyAttribute]
public float get_Descent();
    [IsReadOnlyAttribute]
public float get_Bottom();
    [IsReadOnlyAttribute]
public float get_Leading();
    [IsReadOnlyAttribute]
public float get_AverageCharacterWidth();
    [IsReadOnlyAttribute]
public float get_MaxCharacterWidth();
    [IsReadOnlyAttribute]
public float get_XMin();
    [IsReadOnlyAttribute]
public float get_XMax();
    [IsReadOnlyAttribute]
public float get_XHeight();
    [IsReadOnlyAttribute]
public float get_CapHeight();
    [IsReadOnlyAttribute]
public Nullable`1<float> get_UnderlineThickness();
    [IsReadOnlyAttribute]
public Nullable`1<float> get_UnderlinePosition();
    [IsReadOnlyAttribute]
public Nullable`1<float> get_StrikeoutThickness();
    [IsReadOnlyAttribute]
public Nullable`1<float> get_StrikeoutPosition();
    [IsReadOnlyAttribute]
private Nullable`1<float> GetIfValid(float value, UInt32 flag);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKFontMetrics obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKFontMetrics left, SKFontMetrics right);
    public static bool op_Inequality(SKFontMetrics left, SKFontMetrics right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKFontStyle : SKObject {
    private static SKFontStyle normal;
    private static SKFontStyle bold;
    private static SKFontStyle italic;
    private static SKFontStyle boldItalic;
    public int Weight { get; }
    public int Width { get; }
    public SKFontStyleSlant Slant { get; }
    public static SKFontStyle Normal { get; }
    public static SKFontStyle Bold { get; }
    public static SKFontStyle Italic { get; }
    public static SKFontStyle BoldItalic { get; }
    private static SKFontStyle();
    internal SKFontStyle(IntPtr handle, bool owns);
    public SKFontStyle(SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant);
    public SKFontStyle(int weight, int width, SKFontStyleSlant slant);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public int get_Weight();
    public int get_Width();
    public SKFontStyleSlant get_Slant();
    public static SKFontStyle get_Normal();
    public static SKFontStyle get_Bold();
    public static SKFontStyle get_Italic();
    public static SKFontStyle get_BoldItalic();
    internal static SKFontStyle GetObject(IntPtr handle);
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKFontStyleSet : SKObject {
    public int Count { get; }
    public SKFontStyle Item { get; }
    internal SKFontStyleSet(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int get_Count();
    public sealed virtual SKFontStyle get_Item(int index);
    public string GetStyleName(int index);
    public SKTypeface CreateTypeface(int index);
    public SKTypeface CreateTypeface(SKFontStyle style);
    public sealed virtual IEnumerator`1<SKFontStyle> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("SkiaSharp.SKFontStyleSet/<GetStyles>d__12")]
private IEnumerable`1<SKFontStyle> GetStyles();
    private SKFontStyle GetStyle(int index);
    internal static SKFontStyleSet GetObject(IntPtr handle);
}
public enum SkiaSharp.SKFontStyleSlant : Enum {
    public int value__;
    public static SKFontStyleSlant Upright;
    public static SKFontStyleSlant Italic;
    public static SKFontStyleSlant Oblique;
}
public enum SkiaSharp.SKFontStyleWeight : Enum {
    public int value__;
    public static SKFontStyleWeight Invisible;
    public static SKFontStyleWeight Thin;
    public static SKFontStyleWeight ExtraLight;
    public static SKFontStyleWeight Light;
    public static SKFontStyleWeight Normal;
    public static SKFontStyleWeight Medium;
    public static SKFontStyleWeight SemiBold;
    public static SKFontStyleWeight Bold;
    public static SKFontStyleWeight ExtraBold;
    public static SKFontStyleWeight Black;
    public static SKFontStyleWeight ExtraBlack;
}
public enum SkiaSharp.SKFontStyleWidth : Enum {
    public int value__;
    public static SKFontStyleWidth UltraCondensed;
    public static SKFontStyleWidth ExtraCondensed;
    public static SKFontStyleWidth Condensed;
    public static SKFontStyleWidth SemiCondensed;
    public static SKFontStyleWidth Normal;
    public static SKFontStyleWidth SemiExpanded;
    public static SKFontStyleWidth Expanded;
    public static SKFontStyleWidth ExtraExpanded;
    public static SKFontStyleWidth UltraExpanded;
}
public class SkiaSharp.SKFrontBufferedManagedStream : SKAbstractManagedStream {
    private SKStream stream;
    private bool disposeStream;
    private bool hasLength;
    private int streamLength;
    private int bufferLength;
    private Byte[] frontBuffer;
    private int bufferedSoFar;
    private int offset;
    public SKFrontBufferedManagedStream(Stream managedStream, int bufferSize);
    public SKFrontBufferedManagedStream(Stream managedStream, int bufferSize, bool disposeUnderlyingStream);
    public SKFrontBufferedManagedStream(SKStream nativeStream, int bufferSize);
    public SKFrontBufferedManagedStream(SKStream nativeStream, int bufferSize, bool disposeUnderlyingStream);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeManaged();
    protected virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected virtual bool OnIsAtEnd();
    protected virtual bool OnRewind();
    protected virtual bool OnHasLength();
    protected virtual IntPtr OnGetLength();
    protected virtual bool OnHasPosition();
    protected virtual IntPtr OnGetPosition();
    protected virtual bool OnSeek(IntPtr position);
    protected virtual bool OnMove(int offset);
    protected virtual IntPtr OnCreateNew();
}
public class SkiaSharp.SKFrontBufferedStream : Stream {
    public static int DefaultBufferSize;
    private long totalBufferSize;
    private long totalLength;
    private bool disposeStream;
    private Stream underlyingStream;
    private long currentOffset;
    private long bufferedSoFar;
    private Byte[] internalBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SKFrontBufferedStream(Stream stream);
    public SKFrontBufferedStream(Stream stream, long bufferSize);
    public SKFrontBufferedStream(Stream stream, bool disposeUnderlyingStream);
    public SKFrontBufferedStream(Stream stream, long bufferSize, bool disposeUnderlyingStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int ReadFromBuffer(Byte[] dst, int offset, int size);
    private int BufferAndWriteTo(Byte[] dst, int offset, int size);
    private int ReadDirectlyFromStream(Byte[] dst, int offset, int size);
    protected virtual void Dispose(bool disposing);
}
public class SkiaSharp.SKGlyphPathDelegate : MulticastDelegate {
    public SKGlyphPathDelegate(object object, IntPtr method);
    public virtual void Invoke(SKPath path, SKMatrix matrix);
    public virtual IAsyncResult BeginInvoke(SKPath path, SKMatrix matrix, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKGlyphPathProxyDelegate : MulticastDelegate {
    public SKGlyphPathProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pathOrNull, SKMatrix* matrix, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr pathOrNull, SKMatrix* matrix, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class SkiaSharp.SKGraphics : object {
    public static void Init();
    public static void PurgeFontCache();
    public static void PurgeResourceCache();
    public static void PurgeAllCaches();
    public static long GetFontCacheUsed();
    public static long GetFontCacheLimit();
    public static long SetFontCacheLimit(long bytes);
    public static int GetFontCacheCountUsed();
    public static int GetFontCacheCountLimit();
    public static int SetFontCacheCountLimit(int count);
    public static int GetFontCachePointSizeLimit();
    public static int SetFontCachePointSizeLimit(int count);
    public static long GetResourceCacheTotalBytesUsed();
    public static long GetResourceCacheTotalByteLimit();
    public static long SetResourceCacheTotalByteLimit(long bytes);
    public static long GetResourceCacheSingleAllocationByteLimit();
    public static long SetResourceCacheSingleAllocationByteLimit(long bytes);
    public static void DumpMemoryStatistics(SKTraceMemoryDump dump);
}
public class SkiaSharp.SKHighContrastConfig : ValueType {
    public static SKHighContrastConfig Default;
    private byte fGrayscale;
    private SKHighContrastConfigInvertStyle fInvertStyle;
    private float fContrast;
    public bool IsValid { get; }
    public bool Grayscale { get; public set; }
    public SKHighContrastConfigInvertStyle InvertStyle { get; public set; }
    public float Contrast { get; public set; }
    private static SKHighContrastConfig();
    public SKHighContrastConfig(bool grayscale, SKHighContrastConfigInvertStyle invertStyle, float contrast);
    [IsReadOnlyAttribute]
public bool get_IsValid();
    [IsReadOnlyAttribute]
public bool get_Grayscale();
    public void set_Grayscale(bool value);
    [IsReadOnlyAttribute]
public SKHighContrastConfigInvertStyle get_InvertStyle();
    public void set_InvertStyle(SKHighContrastConfigInvertStyle value);
    [IsReadOnlyAttribute]
public float get_Contrast();
    public void set_Contrast(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKHighContrastConfig obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKHighContrastConfig left, SKHighContrastConfig right);
    public static bool op_Inequality(SKHighContrastConfig left, SKHighContrastConfig right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public enum SkiaSharp.SKHighContrastConfigInvertStyle : Enum {
    public int value__;
    public static SKHighContrastConfigInvertStyle NoInvert;
    public static SKHighContrastConfigInvertStyle InvertBrightness;
    public static SKHighContrastConfigInvertStyle InvertLightness;
}
public class SkiaSharp.SKHorizontalRunBuffer : SKRunBuffer {
    internal SKHorizontalRunBuffer(SKRunBufferInternal buffer, int count);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal SKHorizontalRunBuffer(SKRunBufferInternal buffer, int count, int textSize);
    public Span`1<float> GetPositionSpan();
    public void SetPositions(ReadOnlySpan`1<float> positions);
}
internal class SkiaSharp.SkiaApi : object {
    private static string SKIA;
    internal static void gr_backendrendertarget_delete(IntPtr rendertarget);
    internal static GRBackendNative gr_backendrendertarget_get_backend(IntPtr rendertarget);
    internal static bool gr_backendrendertarget_get_gl_framebufferinfo(IntPtr rendertarget, GRGlFramebufferInfo* glInfo);
    internal static int gr_backendrendertarget_get_height(IntPtr rendertarget);
    internal static int gr_backendrendertarget_get_samples(IntPtr rendertarget);
    internal static int gr_backendrendertarget_get_stencils(IntPtr rendertarget);
    internal static int gr_backendrendertarget_get_width(IntPtr rendertarget);
    internal static bool gr_backendrendertarget_is_valid(IntPtr rendertarget);
    internal static IntPtr gr_backendrendertarget_new_gl(int width, int height, int samples, int stencils, GRGlFramebufferInfo* glInfo);
    internal static IntPtr gr_backendrendertarget_new_metal(int width, int height, int samples, GRMtlTextureInfoNative* mtlInfo);
    internal static IntPtr gr_backendrendertarget_new_vulkan(int width, int height, int samples, GRVkImageInfo* vkImageInfo);
    internal static void gr_backendtexture_delete(IntPtr texture);
    internal static GRBackendNative gr_backendtexture_get_backend(IntPtr texture);
    internal static bool gr_backendtexture_get_gl_textureinfo(IntPtr texture, GRGlTextureInfo* glInfo);
    internal static int gr_backendtexture_get_height(IntPtr texture);
    internal static int gr_backendtexture_get_width(IntPtr texture);
    internal static bool gr_backendtexture_has_mipmaps(IntPtr texture);
    internal static bool gr_backendtexture_is_valid(IntPtr texture);
    internal static IntPtr gr_backendtexture_new_gl(int width, int height, bool mipmapped, GRGlTextureInfo* glInfo);
    internal static IntPtr gr_backendtexture_new_metal(int width, int height, bool mipmapped, GRMtlTextureInfoNative* mtlInfo);
    internal static IntPtr gr_backendtexture_new_vulkan(int width, int height, GRVkImageInfo* vkInfo);
    internal static void gr_direct_context_abandon_context(IntPtr context);
    internal static void gr_direct_context_dump_memory_statistics(IntPtr context, IntPtr dump);
    internal static void gr_direct_context_flush(IntPtr context);
    internal static void gr_direct_context_flush_and_submit(IntPtr context, bool syncCpu);
    internal static void gr_direct_context_free_gpu_resources(IntPtr context);
    internal static IntPtr gr_direct_context_get_resource_cache_limit(IntPtr context);
    internal static void gr_direct_context_get_resource_cache_usage(IntPtr context, Int32* maxResources, IntPtr* maxResourceBytes);
    internal static bool gr_direct_context_is_abandoned(IntPtr context);
    internal static IntPtr gr_direct_context_make_gl(IntPtr glInterface);
    internal static IntPtr gr_direct_context_make_gl_with_options(IntPtr glInterface, GRContextOptionsNative* options);
    internal static IntPtr gr_direct_context_make_metal(Void* device, Void* queue);
    internal static IntPtr gr_direct_context_make_metal_with_options(Void* device, Void* queue, GRContextOptionsNative* options);
    internal static IntPtr gr_direct_context_make_vulkan(GRVkBackendContextNative vkBackendContext);
    internal static IntPtr gr_direct_context_make_vulkan_with_options(GRVkBackendContextNative vkBackendContext, GRContextOptionsNative* options);
    internal static void gr_direct_context_perform_deferred_cleanup(IntPtr context, long ms);
    internal static void gr_direct_context_purge_unlocked_resources(IntPtr context, bool scratchResourcesOnly);
    internal static void gr_direct_context_purge_unlocked_resources_bytes(IntPtr context, IntPtr bytesToPurge, bool preferScratchResources);
    internal static void gr_direct_context_release_resources_and_abandon_context(IntPtr context);
    internal static void gr_direct_context_reset_context(IntPtr context, UInt32 state);
    internal static void gr_direct_context_set_resource_cache_limit(IntPtr context, IntPtr maxResourceBytes);
    internal static bool gr_direct_context_submit(IntPtr context, bool syncCpu);
    internal static IntPtr gr_glinterface_assemble_gl_interface(Void* ctx, GRGlGetProcProxyDelegate get);
    internal static IntPtr gr_glinterface_assemble_gles_interface(Void* ctx, GRGlGetProcProxyDelegate get);
    internal static IntPtr gr_glinterface_assemble_interface(Void* ctx, GRGlGetProcProxyDelegate get);
    internal static IntPtr gr_glinterface_assemble_webgl_interface(Void* ctx, GRGlGetProcProxyDelegate get);
    internal static IntPtr gr_glinterface_create_native_interface();
    internal static bool gr_glinterface_has_extension(IntPtr glInterface, string extension);
    internal static void gr_glinterface_unref(IntPtr glInterface);
    internal static bool gr_glinterface_validate(IntPtr glInterface);
    internal static GRBackendNative gr_recording_context_get_backend(IntPtr context);
    internal static int gr_recording_context_get_max_surface_sample_count_for_color_type(IntPtr context, SKColorTypeNative colorType);
    internal static void gr_recording_context_unref(IntPtr context);
    internal static void gr_vk_extensions_delete(IntPtr extensions);
    internal static bool gr_vk_extensions_has_extension(IntPtr extensions, string ext, UInt32 minVersion);
    internal static void gr_vk_extensions_init(IntPtr extensions, GRVkGetProcProxyDelegate getProc, Void* userData, IntPtr instance, IntPtr physDev, UInt32 instanceExtensionCount, String[] instanceExtensions, UInt32 deviceExtensionCount, String[] deviceExtensions);
    internal static IntPtr gr_vk_extensions_new();
    internal static void sk_bitmap_destructor(IntPtr cbitmap);
    internal static void sk_bitmap_erase(IntPtr cbitmap, UInt32 color);
    internal static void sk_bitmap_erase_rect(IntPtr cbitmap, UInt32 color, SKRectI* rect);
    internal static bool sk_bitmap_extract_alpha(IntPtr cbitmap, IntPtr dst, IntPtr paint, SKPointI* offset);
    internal static bool sk_bitmap_extract_subset(IntPtr cbitmap, IntPtr dst, SKRectI* subset);
    internal static Void* sk_bitmap_get_addr(IntPtr cbitmap, int x, int y);
    internal static UInt16* sk_bitmap_get_addr_16(IntPtr cbitmap, int x, int y);
    internal static UInt32* sk_bitmap_get_addr_32(IntPtr cbitmap, int x, int y);
    internal static Byte* sk_bitmap_get_addr_8(IntPtr cbitmap, int x, int y);
    internal static IntPtr sk_bitmap_get_byte_count(IntPtr cbitmap);
    internal static void sk_bitmap_get_info(IntPtr cbitmap, SKImageInfoNative* info);
    internal static UInt32 sk_bitmap_get_pixel_color(IntPtr cbitmap, int x, int y);
    internal static void sk_bitmap_get_pixel_colors(IntPtr cbitmap, UInt32* colors);
    internal static Void* sk_bitmap_get_pixels(IntPtr cbitmap, IntPtr* length);
    internal static IntPtr sk_bitmap_get_row_bytes(IntPtr cbitmap);
    internal static bool sk_bitmap_install_mask_pixels(IntPtr cbitmap, SKMask* cmask);
    internal static bool sk_bitmap_install_pixels(IntPtr cbitmap, SKImageInfoNative* cinfo, Void* pixels, IntPtr rowBytes, SKBitmapReleaseProxyDelegate releaseProc, Void* context);
    internal static bool sk_bitmap_install_pixels_with_pixmap(IntPtr cbitmap, IntPtr cpixmap);
    internal static bool sk_bitmap_is_immutable(IntPtr cbitmap);
    internal static bool sk_bitmap_is_null(IntPtr cbitmap);
    internal static IntPtr sk_bitmap_make_shader(IntPtr cbitmap, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix* cmatrix);
    internal static IntPtr sk_bitmap_new();
    internal static void sk_bitmap_notify_pixels_changed(IntPtr cbitmap);
    internal static bool sk_bitmap_peek_pixels(IntPtr cbitmap, IntPtr cpixmap);
    internal static bool sk_bitmap_ready_to_draw(IntPtr cbitmap);
    internal static void sk_bitmap_reset(IntPtr cbitmap);
    internal static void sk_bitmap_set_immutable(IntPtr cbitmap);
    internal static void sk_bitmap_set_pixels(IntPtr cbitmap, Void* pixels);
    internal static void sk_bitmap_swap(IntPtr cbitmap, IntPtr cother);
    internal static bool sk_bitmap_try_alloc_pixels(IntPtr cbitmap, SKImageInfoNative* requestedInfo, IntPtr rowBytes);
    internal static bool sk_bitmap_try_alloc_pixels_with_flags(IntPtr cbitmap, SKImageInfoNative* requestedInfo, UInt32 flags);
    internal static void sk_canvas_clear(IntPtr param0, UInt32 param1);
    internal static void sk_canvas_clear_color4f(IntPtr param0, SKColorF param1);
    internal static void sk_canvas_clip_path_with_operation(IntPtr t, IntPtr crect, SKClipOperation op, bool doAA);
    internal static void sk_canvas_clip_rect_with_operation(IntPtr t, SKRect* crect, SKClipOperation op, bool doAA);
    internal static void sk_canvas_clip_region(IntPtr canvas, IntPtr region, SKClipOperation op);
    internal static void sk_canvas_clip_rrect_with_operation(IntPtr t, IntPtr crect, SKClipOperation op, bool doAA);
    internal static void sk_canvas_concat(IntPtr param0, SKMatrix* param1);
    internal static void sk_canvas_destroy(IntPtr param0);
    internal static void sk_canvas_discard(IntPtr param0);
    internal static void sk_canvas_draw_annotation(IntPtr t, SKRect* rect, Void* key, IntPtr value);
    internal static void sk_canvas_draw_arc(IntPtr ccanvas, SKRect* oval, float startAngle, float sweepAngle, bool useCenter, IntPtr paint);
    internal static void sk_canvas_draw_atlas(IntPtr ccanvas, IntPtr atlas, SKRotationScaleMatrix* xform, SKRect* tex, UInt32* colors, int count, SKBlendMode mode, SKRect* cullRect, IntPtr paint);
    internal static void sk_canvas_draw_circle(IntPtr param0, float cx, float cy, float rad, IntPtr param4);
    internal static void sk_canvas_draw_color(IntPtr ccanvas, UInt32 color, SKBlendMode mode);
    internal static void sk_canvas_draw_color4f(IntPtr ccanvas, SKColorF color, SKBlendMode mode);
    internal static void sk_canvas_draw_drawable(IntPtr param0, IntPtr param1, SKMatrix* param2);
    internal static void sk_canvas_draw_drrect(IntPtr ccanvas, IntPtr outer, IntPtr inner, IntPtr paint);
    internal static void sk_canvas_draw_image(IntPtr param0, IntPtr param1, float x, float y, IntPtr param4);
    internal static void sk_canvas_draw_image_lattice(IntPtr t, IntPtr image, SKLatticeInternal* lattice, SKRect* dst, IntPtr paint);
    internal static void sk_canvas_draw_image_nine(IntPtr t, IntPtr image, SKRectI* center, SKRect* dst, IntPtr paint);
    internal static void sk_canvas_draw_image_rect(IntPtr param0, IntPtr param1, SKRect* src, SKRect* dst, IntPtr param4);
    internal static void sk_canvas_draw_line(IntPtr ccanvas, float x0, float y0, float x1, float y1, IntPtr cpaint);
    internal static void sk_canvas_draw_link_destination_annotation(IntPtr t, SKRect* rect, IntPtr value);
    internal static void sk_canvas_draw_named_destination_annotation(IntPtr t, SKPoint* point, IntPtr value);
    internal static void sk_canvas_draw_oval(IntPtr param0, SKRect* param1, IntPtr param2);
    internal static void sk_canvas_draw_paint(IntPtr param0, IntPtr param1);
    internal static void sk_canvas_draw_patch(IntPtr ccanvas, SKPoint* cubics, UInt32* colors, SKPoint* texCoords, SKBlendMode mode, IntPtr paint);
    internal static void sk_canvas_draw_path(IntPtr param0, IntPtr param1, IntPtr param2);
    internal static void sk_canvas_draw_picture(IntPtr param0, IntPtr param1, SKMatrix* param2, IntPtr param3);
    internal static void sk_canvas_draw_point(IntPtr param0, float param1, float param2, IntPtr param3);
    internal static void sk_canvas_draw_points(IntPtr param0, SKPointMode param1, IntPtr param2, SKPoint* param3, IntPtr param4);
    internal static void sk_canvas_draw_rect(IntPtr param0, SKRect* param1, IntPtr param2);
    internal static void sk_canvas_draw_region(IntPtr param0, IntPtr param1, IntPtr param2);
    internal static void sk_canvas_draw_round_rect(IntPtr param0, SKRect* param1, float rx, float ry, IntPtr param4);
    internal static void sk_canvas_draw_rrect(IntPtr param0, IntPtr param1, IntPtr param2);
    internal static void sk_canvas_draw_simple_text(IntPtr ccanvas, Void* text, IntPtr byte_length, SKTextEncoding encoding, float x, float y, IntPtr cfont, IntPtr cpaint);
    internal static void sk_canvas_draw_text_blob(IntPtr param0, IntPtr text, float x, float y, IntPtr paint);
    internal static void sk_canvas_draw_url_annotation(IntPtr t, SKRect* rect, IntPtr value);
    internal static void sk_canvas_draw_vertices(IntPtr ccanvas, IntPtr vertices, SKBlendMode mode, IntPtr paint);
    internal static void sk_canvas_flush(IntPtr ccanvas);
    internal static bool sk_canvas_get_device_clip_bounds(IntPtr t, SKRectI* cbounds);
    internal static bool sk_canvas_get_local_clip_bounds(IntPtr t, SKRect* cbounds);
    internal static int sk_canvas_get_save_count(IntPtr param0);
    internal static void sk_canvas_get_total_matrix(IntPtr ccanvas, SKMatrix* matrix);
    internal static bool sk_canvas_is_clip_empty(IntPtr ccanvas);
    internal static bool sk_canvas_is_clip_rect(IntPtr ccanvas);
    internal static IntPtr sk_canvas_new_from_bitmap(IntPtr bitmap);
    internal static bool sk_canvas_quick_reject(IntPtr param0, SKRect* param1);
    internal static void sk_canvas_reset_matrix(IntPtr ccanvas);
    internal static void sk_canvas_restore(IntPtr param0);
    internal static void sk_canvas_restore_to_count(IntPtr param0, int saveCount);
    internal static void sk_canvas_rotate_degrees(IntPtr param0, float degrees);
    internal static void sk_canvas_rotate_radians(IntPtr param0, float radians);
    internal static int sk_canvas_save(IntPtr param0);
    internal static int sk_canvas_save_layer(IntPtr param0, SKRect* param1, IntPtr param2);
    internal static void sk_canvas_scale(IntPtr param0, float sx, float sy);
    internal static void sk_canvas_set_matrix(IntPtr ccanvas, SKMatrix* matrix);
    internal static void sk_canvas_skew(IntPtr param0, float sx, float sy);
    internal static void sk_canvas_translate(IntPtr param0, float dx, float dy);
    internal static void sk_nodraw_canvas_destroy(IntPtr param0);
    internal static IntPtr sk_nodraw_canvas_new(int width, int height);
    internal static void sk_nway_canvas_add_canvas(IntPtr param0, IntPtr canvas);
    internal static void sk_nway_canvas_destroy(IntPtr param0);
    internal static IntPtr sk_nway_canvas_new(int width, int height);
    internal static void sk_nway_canvas_remove_all(IntPtr param0);
    internal static void sk_nway_canvas_remove_canvas(IntPtr param0, IntPtr canvas);
    internal static void sk_overdraw_canvas_destroy(IntPtr canvas);
    internal static IntPtr sk_overdraw_canvas_new(IntPtr canvas);
    internal static void sk_codec_destroy(IntPtr codec);
    internal static SKEncodedImageFormat sk_codec_get_encoded_format(IntPtr codec);
    internal static int sk_codec_get_frame_count(IntPtr codec);
    internal static void sk_codec_get_frame_info(IntPtr codec, SKCodecFrameInfo* frameInfo);
    internal static bool sk_codec_get_frame_info_for_index(IntPtr codec, int index, SKCodecFrameInfo* frameInfo);
    internal static void sk_codec_get_info(IntPtr codec, SKImageInfoNative* info);
    internal static SKEncodedOrigin sk_codec_get_origin(IntPtr codec);
    internal static SKCodecResult sk_codec_get_pixels(IntPtr codec, SKImageInfoNative* info, Void* pixels, IntPtr rowBytes, SKCodecOptionsInternal* options);
    internal static int sk_codec_get_repetition_count(IntPtr codec);
    internal static void sk_codec_get_scaled_dimensions(IntPtr codec, float desiredScale, SKSizeI* dimensions);
    internal static SKCodecScanlineOrder sk_codec_get_scanline_order(IntPtr codec);
    internal static int sk_codec_get_scanlines(IntPtr codec, Void* dst, int countLines, IntPtr rowBytes);
    internal static bool sk_codec_get_valid_subset(IntPtr codec, SKRectI* desiredSubset);
    internal static SKCodecResult sk_codec_incremental_decode(IntPtr codec, Int32* rowsDecoded);
    internal static IntPtr sk_codec_min_buffered_bytes_needed();
    internal static IntPtr sk_codec_new_from_data(IntPtr data);
    internal static IntPtr sk_codec_new_from_stream(IntPtr stream, SKCodecResult* result);
    internal static int sk_codec_next_scanline(IntPtr codec);
    internal static int sk_codec_output_scanline(IntPtr codec, int inputScanline);
    internal static bool sk_codec_skip_scanlines(IntPtr codec, int countLines);
    internal static SKCodecResult sk_codec_start_incremental_decode(IntPtr codec, SKImageInfoNative* info, Void* pixels, IntPtr rowBytes, SKCodecOptionsInternal* options);
    internal static SKCodecResult sk_codec_start_scanline_decode(IntPtr codec, SKImageInfoNative* info, SKCodecOptionsInternal* options);
    internal static IntPtr sk_colorfilter_new_color_matrix(Single* array);
    internal static IntPtr sk_colorfilter_new_compose(IntPtr outer, IntPtr inner);
    internal static IntPtr sk_colorfilter_new_high_contrast(SKHighContrastConfig* config);
    internal static IntPtr sk_colorfilter_new_lighting(UInt32 mul, UInt32 add);
    internal static IntPtr sk_colorfilter_new_luma_color();
    internal static IntPtr sk_colorfilter_new_mode(UInt32 c, SKBlendMode mode);
    internal static IntPtr sk_colorfilter_new_table(Byte* table);
    internal static IntPtr sk_colorfilter_new_table_argb(Byte* tableA, Byte* tableR, Byte* tableG, Byte* tableB);
    internal static void sk_colorfilter_unref(IntPtr filter);
    internal static void sk_color4f_from_color(UInt32 color, SKColorF* color4f);
    internal static UInt32 sk_color4f_to_color(SKColorF* color4f);
    internal static bool sk_colorspace_equals(IntPtr src, IntPtr dst);
    internal static bool sk_colorspace_gamma_close_to_srgb(IntPtr colorspace);
    internal static bool sk_colorspace_gamma_is_linear(IntPtr colorspace);
    internal static void sk_colorspace_icc_profile_delete(IntPtr profile);
    internal static Byte* sk_colorspace_icc_profile_get_buffer(IntPtr profile, UInt32* size);
    internal static bool sk_colorspace_icc_profile_get_to_xyzd50(IntPtr profile, SKColorSpaceXyz* toXYZD50);
    internal static IntPtr sk_colorspace_icc_profile_new();
    internal static bool sk_colorspace_icc_profile_parse(Void* buffer, IntPtr length, IntPtr profile);
    internal static bool sk_colorspace_is_numerical_transfer_fn(IntPtr colorspace, SKColorSpaceTransferFn* transferFn);
    internal static bool sk_colorspace_is_srgb(IntPtr colorspace);
    internal static IntPtr sk_colorspace_make_linear_gamma(IntPtr colorspace);
    internal static IntPtr sk_colorspace_make_srgb_gamma(IntPtr colorspace);
    internal static IntPtr sk_colorspace_new_icc(IntPtr profile);
    internal static IntPtr sk_colorspace_new_rgb(SKColorSpaceTransferFn* transferFn, SKColorSpaceXyz* toXYZD50);
    internal static IntPtr sk_colorspace_new_srgb();
    internal static IntPtr sk_colorspace_new_srgb_linear();
    internal static bool sk_colorspace_primaries_to_xyzd50(SKColorSpacePrimaries* primaries, SKColorSpaceXyz* toXYZD50);
    internal static void sk_colorspace_ref(IntPtr colorspace);
    internal static void sk_colorspace_to_profile(IntPtr colorspace, IntPtr profile);
    internal static bool sk_colorspace_to_xyzd50(IntPtr colorspace, SKColorSpaceXyz* toXYZD50);
    internal static float sk_colorspace_transfer_fn_eval(SKColorSpaceTransferFn* transferFn, float x);
    internal static bool sk_colorspace_transfer_fn_invert(SKColorSpaceTransferFn* src, SKColorSpaceTransferFn* dst);
    internal static void sk_colorspace_transfer_fn_named_2dot2(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_transfer_fn_named_hlg(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_transfer_fn_named_linear(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_transfer_fn_named_pq(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_transfer_fn_named_rec2020(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_transfer_fn_named_srgb(SKColorSpaceTransferFn* transferFn);
    internal static void sk_colorspace_unref(IntPtr colorspace);
    internal static void sk_colorspace_xyz_concat(SKColorSpaceXyz* a, SKColorSpaceXyz* b, SKColorSpaceXyz* result);
    internal static bool sk_colorspace_xyz_invert(SKColorSpaceXyz* src, SKColorSpaceXyz* dst);
    internal static void sk_colorspace_xyz_named_adobe_rgb(SKColorSpaceXyz* xyz);
    internal static void sk_colorspace_xyz_named_display_p3(SKColorSpaceXyz* xyz);
    internal static void sk_colorspace_xyz_named_rec2020(SKColorSpaceXyz* xyz);
    internal static void sk_colorspace_xyz_named_srgb(SKColorSpaceXyz* xyz);
    internal static void sk_colorspace_xyz_named_xyz(SKColorSpaceXyz* xyz);
    internal static int sk_colortable_count(IntPtr ctable);
    internal static IntPtr sk_colortable_new(UInt32* colors, int count);
    internal static void sk_colortable_read_colors(IntPtr ctable, UInt32** colors);
    internal static void sk_colortable_unref(IntPtr ctable);
    internal static Byte* sk_data_get_bytes(IntPtr param0);
    internal static Void* sk_data_get_data(IntPtr param0);
    internal static IntPtr sk_data_get_size(IntPtr param0);
    internal static IntPtr sk_data_new_empty();
    internal static IntPtr sk_data_new_from_file(Void* path);
    internal static IntPtr sk_data_new_from_stream(IntPtr stream, IntPtr length);
    internal static IntPtr sk_data_new_subset(IntPtr src, IntPtr offset, IntPtr length);
    internal static IntPtr sk_data_new_uninitialized(IntPtr size);
    internal static IntPtr sk_data_new_with_copy(Void* src, IntPtr length);
    internal static IntPtr sk_data_new_with_proc(Void* ptr, IntPtr length, SKDataReleaseProxyDelegate proc, Void* ctx);
    internal static void sk_data_ref(IntPtr param0);
    internal static void sk_data_unref(IntPtr param0);
    internal static void sk_document_abort(IntPtr document);
    internal static IntPtr sk_document_begin_page(IntPtr document, float width, float height, SKRect* content);
    internal static void sk_document_close(IntPtr document);
    internal static IntPtr sk_document_create_pdf_from_stream(IntPtr stream);
    internal static IntPtr sk_document_create_pdf_from_stream_with_metadata(IntPtr stream, SKDocumentPdfMetadataInternal* metadata);
    internal static IntPtr sk_document_create_xps_from_stream(IntPtr stream, float dpi);
    internal static void sk_document_end_page(IntPtr document);
    internal static void sk_document_unref(IntPtr document);
    internal static void sk_drawable_draw(IntPtr param0, IntPtr param1, SKMatrix* param2);
    internal static void sk_drawable_get_bounds(IntPtr param0, SKRect* param1);
    internal static UInt32 sk_drawable_get_generation_id(IntPtr param0);
    internal static IntPtr sk_drawable_new_picture_snapshot(IntPtr param0);
    internal static void sk_drawable_notify_drawing_changed(IntPtr param0);
    internal static void sk_drawable_unref(IntPtr param0);
    internal static IntPtr sk_font_break_text(IntPtr font, Void* text, IntPtr byteLength, SKTextEncoding encoding, float maxWidth, Single* measuredWidth, IntPtr paint);
    internal static void sk_font_delete(IntPtr font);
    internal static SKFontEdging sk_font_get_edging(IntPtr font);
    internal static SKFontHinting sk_font_get_hinting(IntPtr font);
    internal static float sk_font_get_metrics(IntPtr font, SKFontMetrics* metrics);
    internal static bool sk_font_get_path(IntPtr font, ushort glyph, IntPtr path);
    internal static void sk_font_get_paths(IntPtr font, UInt16* glyphs, int count, SKGlyphPathProxyDelegate glyphPathProc, Void* context);
    internal static void sk_font_get_pos(IntPtr font, UInt16* glyphs, int count, SKPoint* pos, SKPoint* origin);
    internal static float sk_font_get_scale_x(IntPtr font);
    internal static float sk_font_get_size(IntPtr font);
    internal static float sk_font_get_skew_x(IntPtr font);
    internal static IntPtr sk_font_get_typeface(IntPtr font);
    internal static void sk_font_get_widths_bounds(IntPtr font, UInt16* glyphs, int count, Single* widths, SKRect* bounds, IntPtr paint);
    internal static void sk_font_get_xpos(IntPtr font, UInt16* glyphs, int count, Single* xpos, float origin);
    internal static bool sk_font_is_baseline_snap(IntPtr font);
    internal static bool sk_font_is_embedded_bitmaps(IntPtr font);
    internal static bool sk_font_is_embolden(IntPtr font);
    internal static bool sk_font_is_force_auto_hinting(IntPtr font);
    internal static bool sk_font_is_linear_metrics(IntPtr font);
    internal static bool sk_font_is_subpixel(IntPtr font);
    internal static float sk_font_measure_text(IntPtr font, Void* text, IntPtr byteLength, SKTextEncoding encoding, SKRect* bounds, IntPtr paint);
    internal static void sk_font_measure_text_no_return(IntPtr font, Void* text, IntPtr byteLength, SKTextEncoding encoding, SKRect* bounds, IntPtr paint, Single* measuredWidth);
    internal static IntPtr sk_font_new();
    internal static IntPtr sk_font_new_with_values(IntPtr typeface, float size, float scaleX, float skewX);
    internal static void sk_font_set_baseline_snap(IntPtr font, bool value);
    internal static void sk_font_set_edging(IntPtr font, SKFontEdging value);
    internal static void sk_font_set_embedded_bitmaps(IntPtr font, bool value);
    internal static void sk_font_set_embolden(IntPtr font, bool value);
    internal static void sk_font_set_force_auto_hinting(IntPtr font, bool value);
    internal static void sk_font_set_hinting(IntPtr font, SKFontHinting value);
    internal static void sk_font_set_linear_metrics(IntPtr font, bool value);
    internal static void sk_font_set_scale_x(IntPtr font, float value);
    internal static void sk_font_set_size(IntPtr font, float value);
    internal static void sk_font_set_skew_x(IntPtr font, float value);
    internal static void sk_font_set_subpixel(IntPtr font, bool value);
    internal static void sk_font_set_typeface(IntPtr font, IntPtr value);
    internal static int sk_font_text_to_glyphs(IntPtr font, Void* text, IntPtr byteLength, SKTextEncoding encoding, UInt16* glyphs, int maxGlyphCount);
    internal static ushort sk_font_unichar_to_glyph(IntPtr font, int uni);
    internal static void sk_font_unichars_to_glyphs(IntPtr font, Int32* uni, int count, UInt16* glyphs);
    internal static void sk_text_utils_get_path(Void* text, IntPtr length, SKTextEncoding encoding, float x, float y, IntPtr font, IntPtr path);
    internal static void sk_text_utils_get_pos_path(Void* text, IntPtr length, SKTextEncoding encoding, SKPoint* pos, IntPtr font, IntPtr path);
    internal static SKColorTypeNative sk_colortype_get_default_8888();
    internal static int sk_nvrefcnt_get_ref_count(IntPtr refcnt);
    internal static void sk_nvrefcnt_safe_ref(IntPtr refcnt);
    internal static void sk_nvrefcnt_safe_unref(IntPtr refcnt);
    internal static bool sk_nvrefcnt_unique(IntPtr refcnt);
    internal static int sk_refcnt_get_ref_count(IntPtr refcnt);
    internal static void sk_refcnt_safe_ref(IntPtr refcnt);
    internal static void sk_refcnt_safe_unref(IntPtr refcnt);
    internal static bool sk_refcnt_unique(IntPtr refcnt);
    internal static int sk_version_get_increment();
    internal static int sk_version_get_milestone();
    internal static Void* sk_version_get_string();
    internal static void sk_graphics_dump_memory_statistics(IntPtr dump);
    internal static int sk_graphics_get_font_cache_count_limit();
    internal static int sk_graphics_get_font_cache_count_used();
    internal static IntPtr sk_graphics_get_font_cache_limit();
    internal static int sk_graphics_get_font_cache_point_size_limit();
    internal static IntPtr sk_graphics_get_font_cache_used();
    internal static IntPtr sk_graphics_get_resource_cache_single_allocation_byte_limit();
    internal static IntPtr sk_graphics_get_resource_cache_total_byte_limit();
    internal static IntPtr sk_graphics_get_resource_cache_total_bytes_used();
    internal static void sk_graphics_init();
    internal static void sk_graphics_purge_all_caches();
    internal static void sk_graphics_purge_font_cache();
    internal static void sk_graphics_purge_resource_cache();
    internal static int sk_graphics_set_font_cache_count_limit(int count);
    internal static IntPtr sk_graphics_set_font_cache_limit(IntPtr bytes);
    internal static int sk_graphics_set_font_cache_point_size_limit(int maxPointSize);
    internal static IntPtr sk_graphics_set_resource_cache_single_allocation_byte_limit(IntPtr newLimit);
    internal static IntPtr sk_graphics_set_resource_cache_total_byte_limit(IntPtr newLimit);
    internal static IntPtr sk_image_encode(IntPtr param0);
    internal static IntPtr sk_image_encode_specific(IntPtr cimage, SKEncodedImageFormat encoder, int quality);
    internal static SKAlphaType sk_image_get_alpha_type(IntPtr param0);
    internal static SKColorTypeNative sk_image_get_color_type(IntPtr param0);
    internal static IntPtr sk_image_get_colorspace(IntPtr param0);
    internal static int sk_image_get_height(IntPtr param0);
    internal static UInt32 sk_image_get_unique_id(IntPtr param0);
    internal static int sk_image_get_width(IntPtr param0);
    internal static bool sk_image_is_alpha_only(IntPtr param0);
    internal static bool sk_image_is_lazy_generated(IntPtr image);
    internal static bool sk_image_is_texture_backed(IntPtr image);
    internal static bool sk_image_is_valid(IntPtr image, IntPtr context);
    internal static IntPtr sk_image_make_non_texture_image(IntPtr cimage);
    internal static IntPtr sk_image_make_raster_image(IntPtr cimage);
    internal static IntPtr sk_image_make_shader(IntPtr param0, SKShaderTileMode tileX, SKShaderTileMode tileY, SKMatrix* localMatrix);
    internal static IntPtr sk_image_make_subset(IntPtr cimage, SKRectI* subset);
    internal static IntPtr sk_image_make_texture_image(IntPtr cimage, IntPtr context, bool mipmapped);
    internal static IntPtr sk_image_make_with_filter(IntPtr cimage, IntPtr context, IntPtr filter, SKRectI* subset, SKRectI* clipBounds, SKRectI* outSubset, SKPointI* outOffset);
    internal static IntPtr sk_image_make_with_filter_legacy(IntPtr cimage, IntPtr filter, SKRectI* subset, SKRectI* clipBounds, SKRectI* outSubset, SKPointI* outOffset);
    internal static IntPtr sk_image_new_from_adopted_texture(IntPtr context, IntPtr texture, GRSurfaceOrigin origin, SKColorTypeNative colorType, SKAlphaType alpha, IntPtr colorSpace);
    internal static IntPtr sk_image_new_from_bitmap(IntPtr cbitmap);
    internal static IntPtr sk_image_new_from_encoded(IntPtr encoded);
    internal static IntPtr sk_image_new_from_picture(IntPtr picture, SKSizeI* dimensions, SKMatrix* matrix, IntPtr paint);
    internal static IntPtr sk_image_new_from_texture(IntPtr context, IntPtr texture, GRSurfaceOrigin origin, SKColorTypeNative colorType, SKAlphaType alpha, IntPtr colorSpace, SKImageTextureReleaseProxyDelegate releaseProc, Void* releaseContext);
    internal static IntPtr sk_image_new_raster(IntPtr pixmap, SKImageRasterReleaseProxyDelegate releaseProc, Void* context);
    internal static IntPtr sk_image_new_raster_copy(SKImageInfoNative* param0, Void* pixels, IntPtr rowBytes);
    internal static IntPtr sk_image_new_raster_copy_with_pixmap(IntPtr pixmap);
    internal static IntPtr sk_image_new_raster_data(SKImageInfoNative* cinfo, IntPtr pixels, IntPtr rowBytes);
    internal static bool sk_image_peek_pixels(IntPtr image, IntPtr pixmap);
    internal static bool sk_image_read_pixels(IntPtr image, SKImageInfoNative* dstInfo, Void* dstPixels, IntPtr dstRowBytes, int srcX, int srcY, SKImageCachingHint cachingHint);
    internal static bool sk_image_read_pixels_into_pixmap(IntPtr image, IntPtr dst, int srcX, int srcY, SKImageCachingHint cachingHint);
    internal static void sk_image_ref(IntPtr param0);
    internal static IntPtr sk_image_ref_encoded(IntPtr param0);
    internal static bool sk_image_scale_pixels(IntPtr image, IntPtr dst, SKFilterQuality quality, SKImageCachingHint cachingHint);
    internal static void sk_image_unref(IntPtr param0);
    internal static void sk_imagefilter_croprect_destructor(IntPtr cropRect);
    internal static UInt32 sk_imagefilter_croprect_get_flags(IntPtr cropRect);
    internal static void sk_imagefilter_croprect_get_rect(IntPtr cropRect, SKRect* rect);
    internal static IntPtr sk_imagefilter_croprect_new();
    internal static IntPtr sk_imagefilter_croprect_new_with_rect(SKRect* rect, UInt32 flags);
    internal static IntPtr sk_imagefilter_new_alpha_threshold(IntPtr region, float innerThreshold, float outerThreshold, IntPtr input);
    internal static IntPtr sk_imagefilter_new_arithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, IntPtr background, IntPtr foreground, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_blur(float sigmaX, float sigmaY, SKShaderTileMode tileMode, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_color_filter(IntPtr cf, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_compose(IntPtr outer, IntPtr inner);
    internal static IntPtr sk_imagefilter_new_dilate(float radiusX, float radiusY, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_displacement_map_effect(SKColorChannel xChannelSelector, SKColorChannel yChannelSelector, float scale, IntPtr displacement, IntPtr color, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_distant_lit_diffuse(SKPoint3* direction, UInt32 lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_distant_lit_specular(SKPoint3* direction, UInt32 lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_drop_shadow(float dx, float dy, float sigmaX, float sigmaY, UInt32 color, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_drop_shadow_only(float dx, float dy, float sigmaX, float sigmaY, UInt32 color, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_erode(float radiusX, float radiusY, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_image_source(IntPtr image, SKRect* srcRect, SKRect* dstRect, SKFilterQuality filterQuality);
    internal static IntPtr sk_imagefilter_new_image_source_default(IntPtr image);
    internal static IntPtr sk_imagefilter_new_magnifier(SKRect* src, float inset, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_matrix(SKMatrix* matrix, SKFilterQuality quality, IntPtr input);
    internal static IntPtr sk_imagefilter_new_matrix_convolution(SKSizeI* kernelSize, Single* kernel, float gain, float bias, SKPointI* kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_merge(IntPtr* filters, int count, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_offset(float dx, float dy, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_paint(IntPtr paint, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_picture(IntPtr picture);
    internal static IntPtr sk_imagefilter_new_picture_with_croprect(IntPtr picture, SKRect* cropRect);
    internal static IntPtr sk_imagefilter_new_point_lit_diffuse(SKPoint3* location, UInt32 lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_point_lit_specular(SKPoint3* location, UInt32 lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_spot_lit_diffuse(SKPoint3* location, SKPoint3* target, float specularExponent, float cutoffAngle, UInt32 lightColor, float surfaceScale, float kd, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_spot_lit_specular(SKPoint3* location, SKPoint3* target, float specularExponent, float cutoffAngle, UInt32 lightColor, float surfaceScale, float ks, float shininess, IntPtr input, IntPtr cropRect);
    internal static IntPtr sk_imagefilter_new_tile(SKRect* src, SKRect* dst, IntPtr input);
    internal static IntPtr sk_imagefilter_new_xfermode(SKBlendMode mode, IntPtr background, IntPtr foreground, IntPtr cropRect);
    internal static void sk_imagefilter_unref(IntPtr param0);
    internal static Byte* sk_mask_alloc_image(IntPtr bytes);
    internal static IntPtr sk_mask_compute_image_size(SKMask* cmask);
    internal static IntPtr sk_mask_compute_total_image_size(SKMask* cmask);
    internal static void sk_mask_free_image(Void* image);
    internal static Void* sk_mask_get_addr(SKMask* cmask, int x, int y);
    internal static Byte* sk_mask_get_addr_1(SKMask* cmask, int x, int y);
    internal static UInt32* sk_mask_get_addr_32(SKMask* cmask, int x, int y);
    internal static Byte* sk_mask_get_addr_8(SKMask* cmask, int x, int y);
    internal static UInt16* sk_mask_get_addr_lcd_16(SKMask* cmask, int x, int y);
    internal static bool sk_mask_is_empty(SKMask* cmask);
    internal static IntPtr sk_maskfilter_new_blur(SKBlurStyle param0, float sigma);
    internal static IntPtr sk_maskfilter_new_blur_with_flags(SKBlurStyle param0, float sigma, bool respectCTM);
    internal static IntPtr sk_maskfilter_new_clip(byte min, byte max);
    internal static IntPtr sk_maskfilter_new_gamma(float gamma);
    internal static IntPtr sk_maskfilter_new_shader(IntPtr cshader);
    internal static IntPtr sk_maskfilter_new_table(Byte* table);
    internal static void sk_maskfilter_ref(IntPtr param0);
    internal static void sk_maskfilter_unref(IntPtr param0);
    internal static void sk_3dview_apply_to_canvas(IntPtr cview, IntPtr ccanvas);
    internal static void sk_3dview_destroy(IntPtr cview);
    internal static float sk_3dview_dot_with_normal(IntPtr cview, float dx, float dy, float dz);
    internal static void sk_3dview_get_matrix(IntPtr cview, SKMatrix* cmatrix);
    internal static IntPtr sk_3dview_new();
    internal static void sk_3dview_restore(IntPtr cview);
    internal static void sk_3dview_rotate_x_degrees(IntPtr cview, float degrees);
    internal static void sk_3dview_rotate_x_radians(IntPtr cview, float radians);
    internal static void sk_3dview_rotate_y_degrees(IntPtr cview, float degrees);
    internal static void sk_3dview_rotate_y_radians(IntPtr cview, float radians);
    internal static void sk_3dview_rotate_z_degrees(IntPtr cview, float degrees);
    internal static void sk_3dview_rotate_z_radians(IntPtr cview, float radians);
    internal static void sk_3dview_save(IntPtr cview);
    internal static void sk_3dview_translate(IntPtr cview, float x, float y, float z);
    internal static void sk_matrix_concat(SKMatrix* result, SKMatrix* first, SKMatrix* second);
    internal static void sk_matrix_map_points(SKMatrix* matrix, SKPoint* dst, SKPoint* src, int count);
    internal static float sk_matrix_map_radius(SKMatrix* matrix, float radius);
    internal static void sk_matrix_map_rect(SKMatrix* matrix, SKRect* dest, SKRect* source);
    internal static void sk_matrix_map_vector(SKMatrix* matrix, float x, float y, SKPoint* result);
    internal static void sk_matrix_map_vectors(SKMatrix* matrix, SKPoint* dst, SKPoint* src, int count);
    internal static void sk_matrix_map_xy(SKMatrix* matrix, float x, float y, SKPoint* result);
    internal static void sk_matrix_post_concat(SKMatrix* result, SKMatrix* matrix);
    internal static void sk_matrix_pre_concat(SKMatrix* result, SKMatrix* matrix);
    internal static bool sk_matrix_try_invert(SKMatrix* matrix, SKMatrix* result);
    internal static void sk_matrix44_as_col_major(IntPtr matrix, Single* dst);
    internal static void sk_matrix44_as_row_major(IntPtr matrix, Single* dst);
    internal static void sk_matrix44_destroy(IntPtr matrix);
    internal static double sk_matrix44_determinant(IntPtr matrix);
    internal static bool sk_matrix44_equals(IntPtr matrix, IntPtr other);
    internal static float sk_matrix44_get(IntPtr matrix, int row, int col);
    internal static SKMatrix44TypeMask sk_matrix44_get_type(IntPtr matrix);
    internal static bool sk_matrix44_invert(IntPtr matrix, IntPtr inverse);
    internal static void sk_matrix44_map_scalars(IntPtr matrix, Single* src, Single* dst);
    internal static void sk_matrix44_map2(IntPtr matrix, Single* src2, int count, Single* dst4);
    internal static IntPtr sk_matrix44_new();
    internal static IntPtr sk_matrix44_new_concat(IntPtr a, IntPtr b);
    internal static IntPtr sk_matrix44_new_copy(IntPtr src);
    internal static IntPtr sk_matrix44_new_identity();
    internal static IntPtr sk_matrix44_new_matrix(SKMatrix* src);
    internal static void sk_matrix44_post_concat(IntPtr matrix, IntPtr m);
    internal static void sk_matrix44_post_scale(IntPtr matrix, float sx, float sy, float sz);
    internal static void sk_matrix44_post_translate(IntPtr matrix, float dx, float dy, float dz);
    internal static void sk_matrix44_pre_concat(IntPtr matrix, IntPtr m);
    internal static void sk_matrix44_pre_scale(IntPtr matrix, float sx, float sy, float sz);
    internal static void sk_matrix44_pre_translate(IntPtr matrix, float dx, float dy, float dz);
    internal static bool sk_matrix44_preserves_2d_axis_alignment(IntPtr matrix, float epsilon);
    internal static void sk_matrix44_set(IntPtr matrix, int row, int col, float value);
    internal static void sk_matrix44_set_3x3_row_major(IntPtr matrix, Single* dst);
    internal static void sk_matrix44_set_col_major(IntPtr matrix, Single* dst);
    internal static void sk_matrix44_set_concat(IntPtr matrix, IntPtr a, IntPtr b);
    internal static void sk_matrix44_set_identity(IntPtr matrix);
    internal static void sk_matrix44_set_rotate_about_degrees(IntPtr matrix, float x, float y, float z, float degrees);
    internal static void sk_matrix44_set_rotate_about_radians(IntPtr matrix, float x, float y, float z, float radians);
    internal static void sk_matrix44_set_rotate_about_radians_unit(IntPtr matrix, float x, float y, float z, float radians);
    internal static void sk_matrix44_set_row_major(IntPtr matrix, Single* dst);
    internal static void sk_matrix44_set_scale(IntPtr matrix, float sx, float sy, float sz);
    internal static void sk_matrix44_set_translate(IntPtr matrix, float dx, float dy, float dz);
    internal static void sk_matrix44_to_matrix(IntPtr matrix, SKMatrix* dst);
    internal static void sk_matrix44_transpose(IntPtr matrix);
    internal static IntPtr sk_paint_clone(IntPtr param0);
    internal static void sk_paint_delete(IntPtr param0);
    internal static SKBlendMode sk_paint_get_blendmode(IntPtr param0);
    internal static UInt32 sk_paint_get_color(IntPtr param0);
    internal static void sk_paint_get_color4f(IntPtr paint, SKColorF* color);
    internal static IntPtr sk_paint_get_colorfilter(IntPtr param0);
    internal static bool sk_paint_get_fill_path(IntPtr param0, IntPtr src, IntPtr dst, SKRect* cullRect, float resScale);
    internal static SKFilterQuality sk_paint_get_filter_quality(IntPtr param0);
    internal static IntPtr sk_paint_get_imagefilter(IntPtr param0);
    internal static IntPtr sk_paint_get_maskfilter(IntPtr param0);
    internal static IntPtr sk_paint_get_path_effect(IntPtr cpaint);
    internal static IntPtr sk_paint_get_shader(IntPtr param0);
    internal static SKStrokeCap sk_paint_get_stroke_cap(IntPtr param0);
    internal static SKStrokeJoin sk_paint_get_stroke_join(IntPtr param0);
    internal static float sk_paint_get_stroke_miter(IntPtr param0);
    internal static float sk_paint_get_stroke_width(IntPtr param0);
    internal static SKPaintStyle sk_paint_get_style(IntPtr param0);
    internal static bool sk_paint_is_antialias(IntPtr param0);
    internal static bool sk_paint_is_dither(IntPtr param0);
    internal static IntPtr sk_paint_new();
    internal static void sk_paint_reset(IntPtr param0);
    internal static void sk_paint_set_antialias(IntPtr param0, bool param1);
    internal static void sk_paint_set_blendmode(IntPtr param0, SKBlendMode param1);
    internal static void sk_paint_set_color(IntPtr param0, UInt32 param1);
    internal static void sk_paint_set_color4f(IntPtr paint, SKColorF* color, IntPtr colorspace);
    internal static void sk_paint_set_colorfilter(IntPtr param0, IntPtr param1);
    internal static void sk_paint_set_dither(IntPtr param0, bool param1);
    internal static void sk_paint_set_filter_quality(IntPtr param0, SKFilterQuality param1);
    internal static void sk_paint_set_imagefilter(IntPtr param0, IntPtr param1);
    internal static void sk_paint_set_maskfilter(IntPtr param0, IntPtr param1);
    internal static void sk_paint_set_path_effect(IntPtr cpaint, IntPtr effect);
    internal static void sk_paint_set_shader(IntPtr param0, IntPtr param1);
    internal static void sk_paint_set_stroke_cap(IntPtr param0, SKStrokeCap param1);
    internal static void sk_paint_set_stroke_join(IntPtr param0, SKStrokeJoin param1);
    internal static void sk_paint_set_stroke_miter(IntPtr param0, float miter);
    internal static void sk_paint_set_stroke_width(IntPtr param0, float width);
    internal static void sk_paint_set_style(IntPtr param0, SKPaintStyle param1);
    internal static void sk_opbuilder_add(IntPtr builder, IntPtr path, SKPathOp op);
    internal static void sk_opbuilder_destroy(IntPtr builder);
    internal static IntPtr sk_opbuilder_new();
    internal static bool sk_opbuilder_resolve(IntPtr builder, IntPtr result);
    internal static void sk_path_add_arc(IntPtr cpath, SKRect* crect, float startAngle, float sweepAngle);
    internal static void sk_path_add_circle(IntPtr param0, float x, float y, float radius, SKPathDirection dir);
    internal static void sk_path_add_oval(IntPtr param0, SKRect* param1, SKPathDirection param2);
    internal static void sk_path_add_path(IntPtr cpath, IntPtr other, SKPathAddMode add_mode);
    internal static void sk_path_add_path_matrix(IntPtr cpath, IntPtr other, SKMatrix* matrix, SKPathAddMode add_mode);
    internal static void sk_path_add_path_offset(IntPtr cpath, IntPtr other, float dx, float dy, SKPathAddMode add_mode);
    internal static void sk_path_add_path_reverse(IntPtr cpath, IntPtr other);
    internal static void sk_path_add_poly(IntPtr cpath, SKPoint* points, int count, bool close);
    internal static void sk_path_add_rect(IntPtr param0, SKRect* param1, SKPathDirection param2);
    internal static void sk_path_add_rect_start(IntPtr cpath, SKRect* crect, SKPathDirection cdir, UInt32 startIndex);
    internal static void sk_path_add_rounded_rect(IntPtr param0, SKRect* param1, float param2, float param3, SKPathDirection param4);
    internal static void sk_path_add_rrect(IntPtr param0, IntPtr param1, SKPathDirection param2);
    internal static void sk_path_add_rrect_start(IntPtr param0, IntPtr param1, SKPathDirection param2, UInt32 param3);
    internal static void sk_path_arc_to(IntPtr param0, float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    internal static void sk_path_arc_to_with_oval(IntPtr param0, SKRect* oval, float startAngle, float sweepAngle, bool forceMoveTo);
    internal static void sk_path_arc_to_with_points(IntPtr param0, float x1, float y1, float x2, float y2, float radius);
    internal static IntPtr sk_path_clone(IntPtr cpath);
    internal static void sk_path_close(IntPtr param0);
    internal static void sk_path_compute_tight_bounds(IntPtr param0, SKRect* param1);
    internal static void sk_path_conic_to(IntPtr param0, float x0, float y0, float x1, float y1, float w);
    internal static bool sk_path_contains(IntPtr cpath, float x, float y);
    internal static int sk_path_convert_conic_to_quads(SKPoint* p0, SKPoint* p1, SKPoint* p2, float w, SKPoint* pts, int pow2);
    internal static int sk_path_count_points(IntPtr cpath);
    internal static int sk_path_count_verbs(IntPtr cpath);
    internal static IntPtr sk_path_create_iter(IntPtr cpath, int forceClose);
    internal static IntPtr sk_path_create_rawiter(IntPtr cpath);
    internal static void sk_path_cubic_to(IntPtr param0, float x0, float y0, float x1, float y1, float x2, float y2);
    internal static void sk_path_delete(IntPtr param0);
    internal static void sk_path_get_bounds(IntPtr param0, SKRect* param1);
    internal static SKPathFillType sk_path_get_filltype(IntPtr param0);
    internal static bool sk_path_get_last_point(IntPtr cpath, SKPoint* point);
    internal static void sk_path_get_point(IntPtr cpath, int index, SKPoint* point);
    internal static int sk_path_get_points(IntPtr cpath, SKPoint* points, int max);
    internal static UInt32 sk_path_get_segment_masks(IntPtr cpath);
    internal static bool sk_path_is_convex(IntPtr cpath);
    internal static bool sk_path_is_line(IntPtr cpath, SKPoint* line);
    internal static bool sk_path_is_oval(IntPtr cpath, SKRect* bounds);
    internal static bool sk_path_is_rect(IntPtr cpath, SKRect* rect, Byte* isClosed, SKPathDirection* direction);
    internal static bool sk_path_is_rrect(IntPtr cpath, IntPtr bounds);
    internal static float sk_path_iter_conic_weight(IntPtr iterator);
    internal static void sk_path_iter_destroy(IntPtr iterator);
    internal static int sk_path_iter_is_close_line(IntPtr iterator);
    internal static int sk_path_iter_is_closed_contour(IntPtr iterator);
    internal static SKPathVerb sk_path_iter_next(IntPtr iterator, SKPoint* points);
    internal static void sk_path_line_to(IntPtr param0, float x, float y);
    internal static void sk_path_move_to(IntPtr param0, float x, float y);
    internal static IntPtr sk_path_new();
    internal static bool sk_path_parse_svg_string(IntPtr cpath, string str);
    internal static void sk_path_quad_to(IntPtr param0, float x0, float y0, float x1, float y1);
    internal static void sk_path_rarc_to(IntPtr param0, float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    internal static float sk_path_rawiter_conic_weight(IntPtr iterator);
    internal static void sk_path_rawiter_destroy(IntPtr iterator);
    internal static SKPathVerb sk_path_rawiter_next(IntPtr iterator, SKPoint* points);
    internal static SKPathVerb sk_path_rawiter_peek(IntPtr iterator);
    internal static void sk_path_rconic_to(IntPtr param0, float dx0, float dy0, float dx1, float dy1, float w);
    internal static void sk_path_rcubic_to(IntPtr param0, float dx0, float dy0, float dx1, float dy1, float dx2, float dy2);
    internal static void sk_path_reset(IntPtr cpath);
    internal static void sk_path_rewind(IntPtr cpath);
    internal static void sk_path_rline_to(IntPtr param0, float dx, float yd);
    internal static void sk_path_rmove_to(IntPtr param0, float dx, float dy);
    internal static void sk_path_rquad_to(IntPtr param0, float dx0, float dy0, float dx1, float dy1);
    internal static void sk_path_set_filltype(IntPtr param0, SKPathFillType param1);
    internal static void sk_path_to_svg_string(IntPtr cpath, IntPtr str);
    internal static void sk_path_transform(IntPtr cpath, SKMatrix* cmatrix);
    internal static void sk_path_transform_to_dest(IntPtr cpath, SKMatrix* cmatrix, IntPtr destination);
    internal static void sk_pathmeasure_destroy(IntPtr pathMeasure);
    internal static float sk_pathmeasure_get_length(IntPtr pathMeasure);
    internal static bool sk_pathmeasure_get_matrix(IntPtr pathMeasure, float distance, SKMatrix* matrix, SKPathMeasureMatrixFlags flags);
    internal static bool sk_pathmeasure_get_pos_tan(IntPtr pathMeasure, float distance, SKPoint* position, SKPoint* tangent);
    internal static bool sk_pathmeasure_get_segment(IntPtr pathMeasure, float start, float stop, IntPtr dst, bool startWithMoveTo);
    internal static bool sk_pathmeasure_is_closed(IntPtr pathMeasure);
    internal static IntPtr sk_pathmeasure_new();
    internal static IntPtr sk_pathmeasure_new_with_path(IntPtr path, bool forceClosed, float resScale);
    internal static bool sk_pathmeasure_next_contour(IntPtr pathMeasure);
    internal static void sk_pathmeasure_set_path(IntPtr pathMeasure, IntPtr path, bool forceClosed);
    internal static bool sk_pathop_as_winding(IntPtr path, IntPtr result);
    internal static bool sk_pathop_op(IntPtr one, IntPtr two, SKPathOp op, IntPtr result);
    internal static bool sk_pathop_simplify(IntPtr path, IntPtr result);
    internal static bool sk_pathop_tight_bounds(IntPtr path, SKRect* result);
    internal static IntPtr sk_path_effect_create_1d_path(IntPtr path, float advance, float phase, SKPath1DPathEffectStyle style);
    internal static IntPtr sk_path_effect_create_2d_line(float width, SKMatrix* matrix);
    internal static IntPtr sk_path_effect_create_2d_path(SKMatrix* matrix, IntPtr path);
    internal static IntPtr sk_path_effect_create_compose(IntPtr outer, IntPtr inner);
    internal static IntPtr sk_path_effect_create_corner(float radius);
    internal static IntPtr sk_path_effect_create_dash(Single* intervals, int count, float phase);
    internal static IntPtr sk_path_effect_create_discrete(float segLength, float deviation, UInt32 seedAssist);
    internal static IntPtr sk_path_effect_create_sum(IntPtr first, IntPtr second);
    internal static IntPtr sk_path_effect_create_trim(float start, float stop, SKTrimPathEffectMode mode);
    internal static void sk_path_effect_unref(IntPtr t);
    internal static IntPtr sk_picture_deserialize_from_data(IntPtr data);
    internal static IntPtr sk_picture_deserialize_from_memory(Void* buffer, IntPtr length);
    internal static IntPtr sk_picture_deserialize_from_stream(IntPtr stream);
    internal static void sk_picture_get_cull_rect(IntPtr param0, SKRect* param1);
    internal static IntPtr sk_picture_get_recording_canvas(IntPtr crec);
    internal static UInt32 sk_picture_get_unique_id(IntPtr param0);
    internal static IntPtr sk_picture_make_shader(IntPtr src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix* localMatrix, SKRect* tile);
    internal static IntPtr sk_picture_recorder_begin_recording(IntPtr param0, SKRect* param1);
    internal static void sk_picture_recorder_delete(IntPtr param0);
    internal static IntPtr sk_picture_recorder_end_recording(IntPtr param0);
    internal static IntPtr sk_picture_recorder_end_recording_as_drawable(IntPtr param0);
    internal static IntPtr sk_picture_recorder_new();
    internal static void sk_picture_ref(IntPtr param0);
    internal static IntPtr sk_picture_serialize_to_data(IntPtr picture);
    internal static void sk_picture_serialize_to_stream(IntPtr picture, IntPtr stream);
    internal static void sk_picture_unref(IntPtr param0);
    internal static void sk_color_get_bit_shift(Int32* a, Int32* r, Int32* g, Int32* b);
    internal static UInt32 sk_color_premultiply(UInt32 color);
    internal static void sk_color_premultiply_array(UInt32* colors, int size, UInt32* pmcolors);
    internal static UInt32 sk_color_unpremultiply(UInt32 pmcolor);
    internal static void sk_color_unpremultiply_array(UInt32* pmcolors, int size, UInt32* colors);
    internal static bool sk_jpegencoder_encode(IntPtr dst, IntPtr src, SKJpegEncoderOptions* options);
    internal static void sk_pixmap_destructor(IntPtr cpixmap);
    internal static bool sk_pixmap_encode_image(IntPtr dst, IntPtr src, SKEncodedImageFormat encoder, int quality);
    internal static bool sk_pixmap_erase_color(IntPtr cpixmap, UInt32 color, SKRectI* subset);
    internal static bool sk_pixmap_erase_color4f(IntPtr cpixmap, SKColorF* color, IntPtr colorspace, SKRectI* subset);
    internal static bool sk_pixmap_extract_subset(IntPtr cpixmap, IntPtr result, SKRectI* subset);
    internal static void sk_pixmap_get_info(IntPtr cpixmap, SKImageInfoNative* cinfo);
    internal static UInt32 sk_pixmap_get_pixel_color(IntPtr cpixmap, int x, int y);
    internal static Void* sk_pixmap_get_pixels(IntPtr cpixmap);
    internal static Void* sk_pixmap_get_pixels_with_xy(IntPtr cpixmap, int x, int y);
    internal static IntPtr sk_pixmap_get_row_bytes(IntPtr cpixmap);
    internal static Void* sk_pixmap_get_writable_addr(IntPtr cpixmap);
    internal static IntPtr sk_pixmap_new();
    internal static IntPtr sk_pixmap_new_with_params(SKImageInfoNative* cinfo, Void* addr, IntPtr rowBytes);
    internal static bool sk_pixmap_read_pixels(IntPtr cpixmap, SKImageInfoNative* dstInfo, Void* dstPixels, IntPtr dstRowBytes, int srcX, int srcY);
    internal static void sk_pixmap_reset(IntPtr cpixmap);
    internal static void sk_pixmap_reset_with_params(IntPtr cpixmap, SKImageInfoNative* cinfo, Void* addr, IntPtr rowBytes);
    internal static bool sk_pixmap_scale_pixels(IntPtr cpixmap, IntPtr dst, SKFilterQuality quality);
    internal static bool sk_pngencoder_encode(IntPtr dst, IntPtr src, SKPngEncoderOptions* options);
    internal static void sk_swizzle_swap_rb(UInt32* dest, UInt32* src, int count);
    internal static bool sk_webpencoder_encode(IntPtr dst, IntPtr src, SKWebpEncoderOptions* options);
    internal static void sk_region_cliperator_delete(IntPtr iter);
    internal static bool sk_region_cliperator_done(IntPtr iter);
    internal static IntPtr sk_region_cliperator_new(IntPtr region, SKRectI* clip);
    internal static void sk_region_cliperator_next(IntPtr iter);
    internal static void sk_region_cliperator_rect(IntPtr iter, SKRectI* rect);
    internal static bool sk_region_contains(IntPtr r, IntPtr region);
    internal static bool sk_region_contains_point(IntPtr r, int x, int y);
    internal static bool sk_region_contains_rect(IntPtr r, SKRectI* rect);
    internal static void sk_region_delete(IntPtr r);
    internal static bool sk_region_get_boundary_path(IntPtr r, IntPtr path);
    internal static void sk_region_get_bounds(IntPtr r, SKRectI* rect);
    internal static bool sk_region_intersects(IntPtr r, IntPtr src);
    internal static bool sk_region_intersects_rect(IntPtr r, SKRectI* rect);
    internal static bool sk_region_is_complex(IntPtr r);
    internal static bool sk_region_is_empty(IntPtr r);
    internal static bool sk_region_is_rect(IntPtr r);
    internal static void sk_region_iterator_delete(IntPtr iter);
    internal static bool sk_region_iterator_done(IntPtr iter);
    internal static IntPtr sk_region_iterator_new(IntPtr region);
    internal static void sk_region_iterator_next(IntPtr iter);
    internal static void sk_region_iterator_rect(IntPtr iter, SKRectI* rect);
    internal static bool sk_region_iterator_rewind(IntPtr iter);
    internal static IntPtr sk_region_new();
    internal static bool sk_region_op(IntPtr r, IntPtr region, SKRegionOperation op);
    internal static bool sk_region_op_rect(IntPtr r, SKRectI* rect, SKRegionOperation op);
    internal static bool sk_region_quick_contains(IntPtr r, SKRectI* rect);
    internal static bool sk_region_quick_reject(IntPtr r, IntPtr region);
    internal static bool sk_region_quick_reject_rect(IntPtr r, SKRectI* rect);
    internal static bool sk_region_set_empty(IntPtr r);
    internal static bool sk_region_set_path(IntPtr r, IntPtr t, IntPtr clip);
    internal static bool sk_region_set_rect(IntPtr r, SKRectI* rect);
    internal static bool sk_region_set_rects(IntPtr r, SKRectI* rects, int count);
    internal static bool sk_region_set_region(IntPtr r, IntPtr region);
    internal static void sk_region_spanerator_delete(IntPtr iter);
    internal static IntPtr sk_region_spanerator_new(IntPtr region, int y, int left, int right);
    internal static bool sk_region_spanerator_next(IntPtr iter, Int32* left, Int32* right);
    internal static void sk_region_translate(IntPtr r, int x, int y);
    internal static bool sk_rrect_contains(IntPtr rrect, SKRect* rect);
    internal static void sk_rrect_delete(IntPtr rrect);
    internal static float sk_rrect_get_height(IntPtr rrect);
    internal static void sk_rrect_get_radii(IntPtr rrect, SKRoundRectCorner corner, SKPoint* radii);
    internal static void sk_rrect_get_rect(IntPtr rrect, SKRect* rect);
    internal static SKRoundRectType sk_rrect_get_type(IntPtr rrect);
    internal static float sk_rrect_get_width(IntPtr rrect);
    internal static void sk_rrect_inset(IntPtr rrect, float dx, float dy);
    internal static bool sk_rrect_is_valid(IntPtr rrect);
    internal static IntPtr sk_rrect_new();
    internal static IntPtr sk_rrect_new_copy(IntPtr rrect);
    internal static void sk_rrect_offset(IntPtr rrect, float dx, float dy);
    internal static void sk_rrect_outset(IntPtr rrect, float dx, float dy);
    internal static void sk_rrect_set_empty(IntPtr rrect);
    internal static void sk_rrect_set_nine_patch(IntPtr rrect, SKRect* rect, float leftRad, float topRad, float rightRad, float bottomRad);
    internal static void sk_rrect_set_oval(IntPtr rrect, SKRect* rect);
    internal static void sk_rrect_set_rect(IntPtr rrect, SKRect* rect);
    internal static void sk_rrect_set_rect_radii(IntPtr rrect, SKRect* rect, SKPoint* radii);
    internal static void sk_rrect_set_rect_xy(IntPtr rrect, SKRect* rect, float xRad, float yRad);
    internal static bool sk_rrect_transform(IntPtr rrect, SKMatrix* matrix, IntPtr dest);
    internal static void sk_runtimeeffect_get_child_name(IntPtr effect, int index, IntPtr name);
    internal static IntPtr sk_runtimeeffect_get_children_count(IntPtr effect);
    internal static IntPtr sk_runtimeeffect_get_uniform_from_index(IntPtr effect, int index);
    internal static IntPtr sk_runtimeeffect_get_uniform_from_name(IntPtr effect, Void* name, IntPtr len);
    internal static void sk_runtimeeffect_get_uniform_name(IntPtr effect, int index, IntPtr name);
    internal static IntPtr sk_runtimeeffect_get_uniform_size(IntPtr effect);
    internal static IntPtr sk_runtimeeffect_get_uniforms_count(IntPtr effect);
    internal static IntPtr sk_runtimeeffect_make(IntPtr sksl, IntPtr error);
    internal static IntPtr sk_runtimeeffect_make_color_filter(IntPtr effect, IntPtr uniforms, IntPtr* children, IntPtr childCount);
    internal static IntPtr sk_runtimeeffect_make_shader(IntPtr effect, IntPtr uniforms, IntPtr* children, IntPtr childCount, SKMatrix* localMatrix, bool isOpaque);
    internal static IntPtr sk_runtimeeffect_uniform_get_offset(IntPtr variable);
    internal static IntPtr sk_runtimeeffect_uniform_get_size_in_bytes(IntPtr variable);
    internal static void sk_runtimeeffect_unref(IntPtr effect);
    internal static IntPtr sk_shader_new_blend(SKBlendMode mode, IntPtr dst, IntPtr src);
    internal static IntPtr sk_shader_new_color(UInt32 color);
    internal static IntPtr sk_shader_new_color4f(SKColorF* color, IntPtr colorspace);
    internal static IntPtr sk_shader_new_empty();
    internal static IntPtr sk_shader_new_lerp(float t, IntPtr dst, IntPtr src);
    internal static IntPtr sk_shader_new_linear_gradient(SKPoint* points, UInt32* colors, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_linear_gradient_color4f(SKPoint* points, SKColorF* colors, IntPtr colorspace, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_perlin_noise_fractal_noise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKSizeI* tileSize);
    internal static IntPtr sk_shader_new_perlin_noise_improved_noise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float z);
    internal static IntPtr sk_shader_new_perlin_noise_turbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKSizeI* tileSize);
    internal static IntPtr sk_shader_new_radial_gradient(SKPoint* center, float radius, UInt32* colors, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_radial_gradient_color4f(SKPoint* center, float radius, SKColorF* colors, IntPtr colorspace, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_sweep_gradient(SKPoint* center, UInt32* colors, Single* colorPos, int colorCount, SKShaderTileMode tileMode, float startAngle, float endAngle, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_sweep_gradient_color4f(SKPoint* center, SKColorF* colors, IntPtr colorspace, Single* colorPos, int colorCount, SKShaderTileMode tileMode, float startAngle, float endAngle, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_two_point_conical_gradient(SKPoint* start, float startRadius, SKPoint* end, float endRadius, UInt32* colors, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static IntPtr sk_shader_new_two_point_conical_gradient_color4f(SKPoint* start, float startRadius, SKPoint* end, float endRadius, SKColorF* colors, IntPtr colorspace, Single* colorPos, int colorCount, SKShaderTileMode tileMode, SKMatrix* localMatrix);
    internal static void sk_shader_ref(IntPtr shader);
    internal static void sk_shader_unref(IntPtr shader);
    internal static IntPtr sk_shader_with_color_filter(IntPtr shader, IntPtr filter);
    internal static IntPtr sk_shader_with_local_matrix(IntPtr shader, SKMatrix* localMatrix);
    internal static void sk_dynamicmemorywstream_copy_to(IntPtr cstream, Void* data);
    internal static void sk_dynamicmemorywstream_destroy(IntPtr cstream);
    internal static IntPtr sk_dynamicmemorywstream_detach_as_data(IntPtr cstream);
    internal static IntPtr sk_dynamicmemorywstream_detach_as_stream(IntPtr cstream);
    internal static IntPtr sk_dynamicmemorywstream_new();
    internal static bool sk_dynamicmemorywstream_write_to_stream(IntPtr cstream, IntPtr dst);
    internal static void sk_filestream_destroy(IntPtr cstream);
    internal static bool sk_filestream_is_valid(IntPtr cstream);
    internal static IntPtr sk_filestream_new(Void* path);
    internal static void sk_filewstream_destroy(IntPtr cstream);
    internal static bool sk_filewstream_is_valid(IntPtr cstream);
    internal static IntPtr sk_filewstream_new(Void* path);
    internal static void sk_memorystream_destroy(IntPtr cstream);
    internal static IntPtr sk_memorystream_new();
    internal static IntPtr sk_memorystream_new_with_data(Void* data, IntPtr length, bool copyData);
    internal static IntPtr sk_memorystream_new_with_length(IntPtr length);
    internal static IntPtr sk_memorystream_new_with_skdata(IntPtr data);
    internal static void sk_memorystream_set_memory(IntPtr cmemorystream, Void* data, IntPtr length, bool copyData);
    internal static void sk_stream_asset_destroy(IntPtr cstream);
    internal static void sk_stream_destroy(IntPtr cstream);
    internal static IntPtr sk_stream_duplicate(IntPtr cstream);
    internal static IntPtr sk_stream_fork(IntPtr cstream);
    internal static IntPtr sk_stream_get_length(IntPtr cstream);
    internal static Void* sk_stream_get_memory_base(IntPtr cstream);
    internal static IntPtr sk_stream_get_position(IntPtr cstream);
    internal static bool sk_stream_has_length(IntPtr cstream);
    internal static bool sk_stream_has_position(IntPtr cstream);
    internal static bool sk_stream_is_at_end(IntPtr cstream);
    internal static bool sk_stream_move(IntPtr cstream, int offset);
    internal static IntPtr sk_stream_peek(IntPtr cstream, Void* buffer, IntPtr size);
    internal static IntPtr sk_stream_read(IntPtr cstream, Void* buffer, IntPtr size);
    internal static bool sk_stream_read_bool(IntPtr cstream, Byte* buffer);
    internal static bool sk_stream_read_s16(IntPtr cstream, Int16* buffer);
    internal static bool sk_stream_read_s32(IntPtr cstream, Int32* buffer);
    internal static bool sk_stream_read_s8(IntPtr cstream, SByte* buffer);
    internal static bool sk_stream_read_u16(IntPtr cstream, UInt16* buffer);
    internal static bool sk_stream_read_u32(IntPtr cstream, UInt32* buffer);
    internal static bool sk_stream_read_u8(IntPtr cstream, Byte* buffer);
    internal static bool sk_stream_rewind(IntPtr cstream);
    internal static bool sk_stream_seek(IntPtr cstream, IntPtr position);
    internal static IntPtr sk_stream_skip(IntPtr cstream, IntPtr size);
    internal static IntPtr sk_wstream_bytes_written(IntPtr cstream);
    internal static void sk_wstream_flush(IntPtr cstream);
    internal static int sk_wstream_get_size_of_packed_uint(IntPtr value);
    internal static bool sk_wstream_newline(IntPtr cstream);
    internal static bool sk_wstream_write(IntPtr cstream, Void* buffer, IntPtr size);
    internal static bool sk_wstream_write_16(IntPtr cstream, ushort value);
    internal static bool sk_wstream_write_32(IntPtr cstream, UInt32 value);
    internal static bool sk_wstream_write_8(IntPtr cstream, byte value);
    internal static bool sk_wstream_write_bigdec_as_text(IntPtr cstream, long value, int minDigits);
    internal static bool sk_wstream_write_bool(IntPtr cstream, bool value);
    internal static bool sk_wstream_write_dec_as_text(IntPtr cstream, int value);
    internal static bool sk_wstream_write_hex_as_text(IntPtr cstream, UInt32 value, int minDigits);
    internal static bool sk_wstream_write_packed_uint(IntPtr cstream, IntPtr value);
    internal static bool sk_wstream_write_scalar(IntPtr cstream, float value);
    internal static bool sk_wstream_write_scalar_as_text(IntPtr cstream, float value);
    internal static bool sk_wstream_write_stream(IntPtr cstream, IntPtr input, IntPtr length);
    internal static bool sk_wstream_write_text(IntPtr cstream, string value);
    internal static void sk_string_destructor(IntPtr param0);
    internal static Void* sk_string_get_c_str(IntPtr param0);
    internal static IntPtr sk_string_get_size(IntPtr param0);
    internal static IntPtr sk_string_new_empty();
    internal static IntPtr sk_string_new_with_copy(Void* src, IntPtr length);
    internal static void sk_surface_draw(IntPtr surface, IntPtr canvas, float x, float y, IntPtr paint);
    internal static void sk_surface_flush(IntPtr surface);
    internal static void sk_surface_flush_and_submit(IntPtr surface, bool syncCpu);
    internal static IntPtr sk_surface_get_canvas(IntPtr param0);
    internal static IntPtr sk_surface_get_props(IntPtr surface);
    internal static IntPtr sk_surface_get_recording_context(IntPtr surface);
    internal static IntPtr sk_surface_new_backend_render_target(IntPtr context, IntPtr target, GRSurfaceOrigin origin, SKColorTypeNative colorType, IntPtr colorspace, IntPtr props);
    internal static IntPtr sk_surface_new_backend_texture(IntPtr context, IntPtr texture, GRSurfaceOrigin origin, int samples, SKColorTypeNative colorType, IntPtr colorspace, IntPtr props);
    internal static IntPtr sk_surface_new_image_snapshot(IntPtr param0);
    internal static IntPtr sk_surface_new_image_snapshot_with_crop(IntPtr surface, SKRectI* bounds);
    internal static IntPtr sk_surface_new_metal_layer(IntPtr context, Void* layer, GRSurfaceOrigin origin, int sampleCount, SKColorTypeNative colorType, IntPtr colorspace, IntPtr props, Void** drawable);
    internal static IntPtr sk_surface_new_metal_view(IntPtr context, Void* mtkView, GRSurfaceOrigin origin, int sampleCount, SKColorTypeNative colorType, IntPtr colorspace, IntPtr props);
    internal static IntPtr sk_surface_new_null(int width, int height);
    internal static IntPtr sk_surface_new_raster(SKImageInfoNative* param0, IntPtr rowBytes, IntPtr param2);
    internal static IntPtr sk_surface_new_raster_direct(SKImageInfoNative* param0, Void* pixels, IntPtr rowBytes, SKSurfaceRasterReleaseProxyDelegate releaseProc, Void* context, IntPtr props);
    internal static IntPtr sk_surface_new_render_target(IntPtr context, bool budgeted, SKImageInfoNative* cinfo, int sampleCount, GRSurfaceOrigin origin, IntPtr props, bool shouldCreateWithMips);
    internal static bool sk_surface_peek_pixels(IntPtr surface, IntPtr pixmap);
    internal static bool sk_surface_read_pixels(IntPtr surface, SKImageInfoNative* dstInfo, Void* dstPixels, IntPtr dstRowBytes, int srcX, int srcY);
    internal static void sk_surface_unref(IntPtr param0);
    internal static void sk_surfaceprops_delete(IntPtr props);
    internal static UInt32 sk_surfaceprops_get_flags(IntPtr props);
    internal static SKPixelGeometry sk_surfaceprops_get_pixel_geometry(IntPtr props);
    internal static IntPtr sk_surfaceprops_new(UInt32 flags, SKPixelGeometry geometry);
    internal static IntPtr sk_svgcanvas_create_with_stream(SKRect* bounds, IntPtr stream);
    internal static IntPtr sk_svgcanvas_create_with_writer(SKRect* bounds, IntPtr writer);
    internal static void sk_textblob_builder_alloc_run(IntPtr builder, IntPtr font, int count, float x, float y, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_pos(IntPtr builder, IntPtr font, int count, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_pos_h(IntPtr builder, IntPtr font, int count, float y, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_rsxform(IntPtr builder, IntPtr font, int count, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_text(IntPtr builder, IntPtr font, int count, float x, float y, int textByteCount, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_text_pos(IntPtr builder, IntPtr font, int count, int textByteCount, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_alloc_run_text_pos_h(IntPtr builder, IntPtr font, int count, float y, int textByteCount, SKRect* bounds, SKRunBufferInternal* runbuffer);
    internal static void sk_textblob_builder_delete(IntPtr builder);
    internal static IntPtr sk_textblob_builder_make(IntPtr builder);
    internal static IntPtr sk_textblob_builder_new();
    internal static void sk_textblob_get_bounds(IntPtr blob, SKRect* bounds);
    internal static int sk_textblob_get_intercepts(IntPtr blob, Single* bounds, Single* intervals, IntPtr paint);
    internal static UInt32 sk_textblob_get_unique_id(IntPtr blob);
    internal static void sk_textblob_ref(IntPtr blob);
    internal static void sk_textblob_unref(IntPtr blob);
    internal static int sk_fontmgr_count_families(IntPtr param0);
    internal static IntPtr sk_fontmgr_create_default();
    internal static IntPtr sk_fontmgr_create_from_data(IntPtr param0, IntPtr data, int index);
    internal static IntPtr sk_fontmgr_create_from_file(IntPtr param0, Void* path, int index);
    internal static IntPtr sk_fontmgr_create_from_stream(IntPtr param0, IntPtr stream, int index);
    internal static IntPtr sk_fontmgr_create_styleset(IntPtr param0, int index);
    internal static void sk_fontmgr_get_family_name(IntPtr param0, int index, IntPtr familyName);
    internal static IntPtr sk_fontmgr_match_face_style(IntPtr param0, IntPtr face, IntPtr style);
    internal static IntPtr sk_fontmgr_match_family(IntPtr param0, IntPtr familyName);
    internal static IntPtr sk_fontmgr_match_family_style(IntPtr param0, IntPtr familyName, IntPtr style);
    internal static IntPtr sk_fontmgr_match_family_style_character(IntPtr param0, IntPtr familyName, IntPtr style, String[] bcp47, int bcp47Count, int character);
    internal static IntPtr sk_fontmgr_ref_default();
    internal static void sk_fontmgr_unref(IntPtr param0);
    internal static void sk_fontstyle_delete(IntPtr fs);
    internal static SKFontStyleSlant sk_fontstyle_get_slant(IntPtr fs);
    internal static int sk_fontstyle_get_weight(IntPtr fs);
    internal static int sk_fontstyle_get_width(IntPtr fs);
    internal static IntPtr sk_fontstyle_new(int weight, int width, SKFontStyleSlant slant);
    internal static IntPtr sk_fontstyleset_create_empty();
    internal static IntPtr sk_fontstyleset_create_typeface(IntPtr fss, int index);
    internal static int sk_fontstyleset_get_count(IntPtr fss);
    internal static void sk_fontstyleset_get_style(IntPtr fss, int index, IntPtr fs, IntPtr style);
    internal static IntPtr sk_fontstyleset_match_style(IntPtr fss, IntPtr style);
    internal static void sk_fontstyleset_unref(IntPtr fss);
    internal static IntPtr sk_typeface_copy_table_data(IntPtr typeface, UInt32 tag);
    internal static int sk_typeface_count_glyphs(IntPtr typeface);
    internal static int sk_typeface_count_tables(IntPtr typeface);
    internal static IntPtr sk_typeface_create_default();
    internal static IntPtr sk_typeface_create_from_data(IntPtr data, int index);
    internal static IntPtr sk_typeface_create_from_file(Void* path, int index);
    internal static IntPtr sk_typeface_create_from_name(IntPtr familyName, IntPtr style);
    internal static IntPtr sk_typeface_create_from_stream(IntPtr stream, int index);
    internal static IntPtr sk_typeface_get_family_name(IntPtr typeface);
    internal static SKFontStyleSlant sk_typeface_get_font_slant(IntPtr typeface);
    internal static int sk_typeface_get_font_weight(IntPtr typeface);
    internal static int sk_typeface_get_font_width(IntPtr typeface);
    internal static IntPtr sk_typeface_get_fontstyle(IntPtr typeface);
    internal static bool sk_typeface_get_kerning_pair_adjustments(IntPtr typeface, UInt16* glyphs, int count, Int32* adjustments);
    internal static IntPtr sk_typeface_get_table_data(IntPtr typeface, UInt32 tag, IntPtr offset, IntPtr length, Void* data);
    internal static IntPtr sk_typeface_get_table_size(IntPtr typeface, UInt32 tag);
    internal static int sk_typeface_get_table_tags(IntPtr typeface, UInt32* tags);
    internal static int sk_typeface_get_units_per_em(IntPtr typeface);
    internal static bool sk_typeface_is_fixed_pitch(IntPtr typeface);
    internal static IntPtr sk_typeface_open_stream(IntPtr typeface, Int32* ttcIndex);
    internal static IntPtr sk_typeface_ref_default();
    internal static ushort sk_typeface_unichar_to_glyph(IntPtr typeface, int unichar);
    internal static void sk_typeface_unichars_to_glyphs(IntPtr typeface, Int32* unichars, int count, UInt16* glyphs);
    internal static void sk_typeface_unref(IntPtr typeface);
    internal static IntPtr sk_vertices_make_copy(SKVertexMode vmode, int vertexCount, SKPoint* positions, SKPoint* texs, UInt32* colors, int indexCount, UInt16* indices);
    internal static void sk_vertices_ref(IntPtr cvertices);
    internal static void sk_vertices_unref(IntPtr cvertices);
    internal static void sk_xmlstreamwriter_delete(IntPtr writer);
    internal static IntPtr sk_xmlstreamwriter_new(IntPtr stream);
    internal static IntPtr sk_compatpaint_clone(IntPtr paint);
    internal static void sk_compatpaint_delete(IntPtr paint);
    internal static IntPtr sk_compatpaint_get_font(IntPtr paint);
    internal static SKTextAlign sk_compatpaint_get_text_align(IntPtr paint);
    internal static SKTextEncoding sk_compatpaint_get_text_encoding(IntPtr paint);
    internal static IntPtr sk_compatpaint_make_font(IntPtr paint);
    internal static IntPtr sk_compatpaint_new();
    internal static IntPtr sk_compatpaint_new_with_font(IntPtr font);
    internal static void sk_compatpaint_reset(IntPtr paint);
    internal static void sk_compatpaint_set_text_align(IntPtr paint, SKTextAlign align);
    internal static void sk_compatpaint_set_text_encoding(IntPtr paint, SKTextEncoding encoding);
    internal static IntPtr sk_manageddrawable_new(Void* context);
    internal static void sk_manageddrawable_set_procs(SKManagedDrawableDelegates procs);
    internal static void sk_manageddrawable_unref(IntPtr param0);
    internal static void sk_managedstream_destroy(IntPtr s);
    internal static IntPtr sk_managedstream_new(Void* context);
    internal static void sk_managedstream_set_procs(SKManagedStreamDelegates procs);
    internal static void sk_managedwstream_destroy(IntPtr s);
    internal static IntPtr sk_managedwstream_new(Void* context);
    internal static void sk_managedwstream_set_procs(SKManagedWStreamDelegates procs);
    internal static void sk_managedtracememorydump_delete(IntPtr param0);
    internal static IntPtr sk_managedtracememorydump_new(bool detailed, bool dumpWrapped, Void* context);
    internal static void sk_managedtracememorydump_set_procs(SKManagedTraceMemoryDumpDelegates procs);
}
[ExtensionAttribute]
public static class SkiaSharp.SkiaExtensions : object {
    [ExtensionAttribute]
public static bool IsBgr(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsRgb(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsVertical(SKPixelGeometry pg);
    [ExtensionAttribute]
public static bool IsHorizontal(SKPixelGeometry pg);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKTextEncoding ToTextEncoding(SKEncoding encoding);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal static SKEncoding ToEncoding(SKTextEncoding encoding);
    [ExtensionAttribute]
public static int GetBytesPerPixel(SKColorType colorType);
    [ExtensionAttribute]
public static SKAlphaType GetAlphaType(SKColorType colorType, SKAlphaType alphaType);
    [ExtensionAttribute]
internal static GRBackendNative ToNative(GRBackend backend);
    [ExtensionAttribute]
internal static GRBackend FromNative(GRBackendNative backend);
    [ExtensionAttribute]
internal static SKColorTypeNative ToNative(SKColorType colorType);
    [ExtensionAttribute]
internal static SKColorType FromNative(SKColorTypeNative colorType);
    [ExtensionAttribute]
public static UInt32 ToGlSizedFormat(SKColorType colorType);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorType instead.")]
public static UInt32 ToGlSizedFormat(GRPixelConfig config);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorType instead.")]
public static GRPixelConfig ToPixelConfig(SKColorType colorType);
    [ExtensionAttribute]
[ObsoleteAttribute("Use SKColorType instead.")]
public static SKColorType ToColorType(GRPixelConfig config);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKFilterQuality ToFilterQuality(SKBitmapResizeMethod method);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKColorSpaceTransferFn ToColorSpaceTransferFn(SKColorSpaceRenderTargetGamma gamma);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKColorSpaceTransferFn ToColorSpaceTransferFn(SKNamedGamma gamma);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKColorSpaceXyz ToColorSpaceXyz(SKColorSpaceGamut gamut);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKColorSpaceXyz ToColorSpaceXyz(SKMatrix44 matrix);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorChannel instead.")]
public static SKColorChannel ToColorChannel(SKDisplacementMapEffectChannelSelectorType channelSelectorType);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKShaderTileMode instead.")]
public static SKShaderTileMode ToShaderTileMode(SKMatrixConvolutionTileMode tileMode);
}
public static class SkiaSharp.SkiaSharpVersion : object {
    private static Version Zero;
    private static Version nativeMinimum;
    private static Version nativeVersion;
    public static Version NativeMinimum { get; }
    public static Version Native { get; }
    internal static string NativeString { get; }
    private static SkiaSharpVersion();
    public static Version get_NativeMinimum();
    public static Version get_Native();
    internal static string get_NativeString();
    public static bool CheckNativeLibraryCompatible(bool throwIfIncompatible);
    internal static bool CheckNativeLibraryCompatible(Version minSupported, Version current, bool throwIfIncompatible);
}
public class SkiaSharp.SKImage : SKObject {
    public int Width { get; }
    public int Height { get; }
    public UInt32 UniqueId { get; }
    public SKAlphaType AlphaType { get; }
    public SKColorType ColorType { get; }
    public SKColorSpace ColorSpace { get; }
    public bool IsAlphaOnly { get; }
    public SKData EncodedData { get; }
    public SKImageInfo Info { get; }
    public bool IsTextureBacked { get; }
    public bool IsLazyGenerated { get; }
    internal SKImage(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKImage Create(SKImageInfo info);
    public static SKImage FromPixelCopy(SKImageInfo info, SKStream pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, SKStream pixels, int rowBytes);
    public static SKImage FromPixelCopy(SKImageInfo info, Stream pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, Stream pixels, int rowBytes);
    public static SKImage FromPixelCopy(SKImageInfo info, Byte[] pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, Byte[] pixels, int rowBytes);
    public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use FromPixelCopy(SKImageInfo, IntPtr, int) instead.")]
public static SKImage FromPixelCopy(SKImageInfo info, IntPtr pixels, int rowBytes, SKColorTable ctable);
    public static SKImage FromPixelCopy(SKPixmap pixmap);
    public static SKImage FromPixelCopy(SKImageInfo info, ReadOnlySpan`1<byte> pixels);
    public static SKImage FromPixelCopy(SKImageInfo info, ReadOnlySpan`1<byte> pixels, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromPixels (SKImageInfo, SKData, int) instead.")]
public static SKImage FromPixelData(SKImageInfo info, SKData data, int rowBytes);
    public static SKImage FromPixels(SKImageInfo info, SKData data);
    public static SKImage FromPixels(SKImageInfo info, SKData data, int rowBytes);
    public static SKImage FromPixels(SKImageInfo info, IntPtr pixels);
    public static SKImage FromPixels(SKImageInfo info, IntPtr pixels, int rowBytes);
    public static SKImage FromPixels(SKPixmap pixmap);
    public static SKImage FromPixels(SKPixmap pixmap, SKImageRasterReleaseDelegate releaseProc);
    public static SKImage FromPixels(SKPixmap pixmap, SKImageRasterReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromEncodedData(SKData data, SKRectI subset);
    public static SKImage FromEncodedData(SKData data);
    public static SKImage FromEncodedData(ReadOnlySpan`1<byte> data);
    public static SKImage FromEncodedData(Byte[] data);
    public static SKImage FromEncodedData(SKStream data);
    public static SKImage FromEncodedData(Stream data);
    public static SKImage FromEncodedData(string filename);
    public static SKImage FromBitmap(SKBitmap bitmap);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType) instead.")]
public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType) instead.")]
public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType, SKColorSpace, SKImageTextureReleaseDelegate) instead.")]
public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType, SKColorSpace, SKImageTextureReleaseDelegate, object) instead.")]
public static SKImage FromTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType) instead.")]
public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType) instead.")]
public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType, SKColorSpace, SKImageTextureReleaseDelegate) instead.")]
public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType, SKColorSpace, SKImageTextureReleaseDelegate, object) instead.")]
public static SKImage FromTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace, SKImageTextureReleaseDelegate releaseProc);
    public static SKImage FromTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace, SKImageTextureReleaseDelegate releaseProc);
    public static SKImage FromTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace, SKImageTextureReleaseDelegate releaseProc, object releaseContext);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromAdoptedTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType) instead.")]
public static SKImage FromAdoptedTexture(GRContext context, GRBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromAdoptedTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType) instead.")]
public static SKImage FromAdoptedTexture(GRContext context, GRBackendTextureDesc desc, SKAlphaType alpha);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromAdoptedTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType) instead.")]
public static SKImage FromAdoptedTexture(GRContext context, GRGlBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromAdoptedTexture(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKAlphaType) instead.")]
public static SKImage FromAdoptedTexture(GRContext context, GRGlBackendTextureDesc desc, SKAlphaType alpha);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha);
    public static SKImage FromAdoptedTexture(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace);
    public static SKImage FromAdoptedTexture(GRRecordingContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKImage FromAdoptedTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKImage FromAdoptedTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha);
    public static SKImage FromAdoptedTexture(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKAlphaType alpha, SKColorSpace colorspace);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKMatrix matrix);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKPaint paint);
    public static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKMatrix matrix, SKPaint paint);
    private static SKImage FromPicture(SKPicture picture, SKSizeI dimensions, SKMatrix* matrix, SKPaint paint);
    public SKData Encode();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKData Encode(SKPixelSerializer serializer);
    public SKData Encode(SKEncodedImageFormat format, int quality);
    public int get_Width();
    public int get_Height();
    public UInt32 get_UniqueId();
    public SKAlphaType get_AlphaType();
    public SKColorType get_ColorType();
    public SKColorSpace get_ColorSpace();
    public bool get_IsAlphaOnly();
    public SKData get_EncodedData();
    public SKImageInfo get_Info();
    public SKShader ToShader();
    public SKShader ToShader(SKShaderTileMode tileX, SKShaderTileMode tileY);
    public SKShader ToShader(SKShaderTileMode tileX, SKShaderTileMode tileY, SKMatrix localMatrix);
    public bool PeekPixels(SKPixmap pixmap);
    public SKPixmap PeekPixels();
    public bool get_IsTextureBacked();
    public bool get_IsLazyGenerated();
    public bool IsValid(GRContext context);
    public bool IsValid(GRRecordingContext context);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY, SKImageCachingHint cachingHint);
    public bool ReadPixels(SKPixmap pixmap);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY, SKImageCachingHint cachingHint);
    public bool ScalePixels(SKPixmap dst, SKFilterQuality quality);
    public bool ScalePixels(SKPixmap dst, SKFilterQuality quality, SKImageCachingHint cachingHint);
    public SKImage Subset(SKRectI subset);
    public SKImage ToRasterImage();
    public SKImage ToRasterImage(bool ensurePixelData);
    public SKImage ToTextureImage(GRContext context);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ToTextureImage(GRContext) instead.")]
public SKImage ToTextureImage(GRContext context, SKColorSpace colorspace);
    public SKImage ToTextureImage(GRContext context, bool mipmapped);
    public SKImage ApplyImageFilter(SKImageFilter filter, SKRectI subset, SKRectI clipBounds, SKRectI& outSubset, SKPoint& outOffset);
    public SKImage ApplyImageFilter(SKImageFilter filter, SKRectI subset, SKRectI clipBounds, SKRectI& outSubset, SKPointI& outOffset);
    public SKImage ApplyImageFilter(GRContext context, SKImageFilter filter, SKRectI subset, SKRectI clipBounds, SKRectI& outSubset, SKPointI& outOffset);
    public SKImage ApplyImageFilter(GRRecordingContext context, SKImageFilter filter, SKRectI subset, SKRectI clipBounds, SKRectI& outSubset, SKPointI& outOffset);
    internal static SKImage GetObject(IntPtr handle);
}
public enum SkiaSharp.SKImageCachingHint : Enum {
    public int value__;
    public static SKImageCachingHint Allow;
    public static SKImageCachingHint Disallow;
}
public class SkiaSharp.SKImageFilter : SKObject {
    internal SKImageFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKImageFilter CreateMatrix(SKMatrix matrix);
    public static SKImageFilter CreateMatrix(SKMatrix matrix, SKFilterQuality quality, SKImageFilter input);
    public static SKImageFilter CreateAlphaThreshold(SKRectI region, float innerThreshold, float outerThreshold, SKImageFilter input);
    public static SKImageFilter CreateAlphaThreshold(SKRegion region, float innerThreshold, float outerThreshold);
    public static SKImageFilter CreateAlphaThreshold(SKRegion region, float innerThreshold, float outerThreshold, SKImageFilter input);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKImageFilter input);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKShaderTileMode tileMode);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKShaderTileMode tileMode, SKImageFilter input);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKShaderTileMode tileMode, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateBlur(float sigmaX, float sigmaY, SKShaderTileMode tileMode, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateColorFilter(SKColorFilter cf);
    public static SKImageFilter CreateColorFilter(SKColorFilter cf, SKImageFilter input);
    public static SKImageFilter CreateColorFilter(SKColorFilter cf, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateColorFilter(SKColorFilter cf, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateCompose(SKImageFilter outer, SKImageFilter inner);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateDisplacementMapEffect(SKColorChannel, SKColorChannel, float, SKImageFilter, SKImageFilter, SKImageFilter.CropRect) instead.")]
public static SKImageFilter CreateDisplacementMapEffect(SKDisplacementMapEffectChannelSelectorType xChannelSelector, SKDisplacementMapEffectChannelSelectorType yChannelSelector, float scale, SKImageFilter displacement, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDisplacementMapEffect(SKColorChannel xChannelSelector, SKColorChannel yChannelSelector, float scale, SKImageFilter displacement);
    public static SKImageFilter CreateDisplacementMapEffect(SKColorChannel xChannelSelector, SKColorChannel yChannelSelector, float scale, SKImageFilter displacement, SKImageFilter input);
    public static SKImageFilter CreateDisplacementMapEffect(SKColorChannel xChannelSelector, SKColorChannel yChannelSelector, float scale, SKImageFilter displacement, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDisplacementMapEffect(SKColorChannel xChannelSelector, SKColorChannel yChannelSelector, float scale, SKImageFilter displacement, SKImageFilter input, CropRect cropRect);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateDropShadow or CreateDropShadowOnly instead.")]
public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKDropShadowImageFilterShadowMode shadowMode, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color);
    public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input);
    public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDropShadow(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDropShadowOnly(float dx, float dy, float sigmaX, float sigmaY, SKColor color);
    public static SKImageFilter CreateDropShadowOnly(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input);
    public static SKImageFilter CreateDropShadowOnly(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDropShadowOnly(float dx, float dy, float sigmaX, float sigmaY, SKColor color, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDistantLitDiffuse(SKPoint3 direction, SKColor lightColor, float surfaceScale, float kd);
    public static SKImageFilter CreateDistantLitDiffuse(SKPoint3 direction, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input);
    public static SKImageFilter CreateDistantLitDiffuse(SKPoint3 direction, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDistantLitDiffuse(SKPoint3 direction, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePointLitDiffuse(SKPoint3 location, SKColor lightColor, float surfaceScale, float kd);
    public static SKImageFilter CreatePointLitDiffuse(SKPoint3 location, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input);
    public static SKImageFilter CreatePointLitDiffuse(SKPoint3 location, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreatePointLitDiffuse(SKPoint3 location, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateSpotLitDiffuse(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd);
    public static SKImageFilter CreateSpotLitDiffuse(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input);
    public static SKImageFilter CreateSpotLitDiffuse(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateSpotLitDiffuse(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float kd, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDistantLitSpecular(SKPoint3 direction, SKColor lightColor, float surfaceScale, float ks, float shininess);
    public static SKImageFilter CreateDistantLitSpecular(SKPoint3 direction, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input);
    public static SKImageFilter CreateDistantLitSpecular(SKPoint3 direction, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDistantLitSpecular(SKPoint3 direction, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePointLitSpecular(SKPoint3 location, SKColor lightColor, float surfaceScale, float ks, float shininess);
    public static SKImageFilter CreatePointLitSpecular(SKPoint3 location, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input);
    public static SKImageFilter CreatePointLitSpecular(SKPoint3 location, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreatePointLitSpecular(SKPoint3 location, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateSpotLitSpecular(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess);
    public static SKImageFilter CreateSpotLitSpecular(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input);
    public static SKImageFilter CreateSpotLitSpecular(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateSpotLitSpecular(SKPoint3 location, SKPoint3 target, float specularExponent, float cutoffAngle, SKColor lightColor, float surfaceScale, float ks, float shininess, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMagnifier(SKRect src, float inset);
    public static SKImageFilter CreateMagnifier(SKRect src, float inset, SKImageFilter input);
    public static SKImageFilter CreateMagnifier(SKRect src, float inset, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateMagnifier(SKRect src, float inset, SKImageFilter input, CropRect cropRect);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateMatrixConvolution(SKSizeI, ReadOnlySpan<float>, float, float, SKPointI, SKShaderTileMode, bool, SKImageFilter, SKImageFilter.CropRect) instead.")]
public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, Single[] kernel, float gain, float bias, SKPointI kernelOffset, SKMatrixConvolutionTileMode tileMode, bool convolveAlpha, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, ReadOnlySpan`1<float> kernel, float gain, float bias, SKPointI kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, ReadOnlySpan`1<float> kernel, float gain, float bias, SKPointI kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha, SKImageFilter input);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, ReadOnlySpan`1<float> kernel, float gain, float bias, SKPointI kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, Single[] kernel, float gain, float bias, SKPointI kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateMatrixConvolution(SKSizeI kernelSize, ReadOnlySpan`1<float> kernel, float gain, float bias, SKPointI kernelOffset, SKShaderTileMode tileMode, bool convolveAlpha, SKImageFilter input, CropRect cropRect);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateMerge(SKImageFilter, SKImageFilter, SKImageFilter.CropRect) instead.")]
public static SKImageFilter CreateMerge(SKImageFilter first, SKImageFilter second, SKBlendMode mode, CropRect cropRect);
    public static SKImageFilter CreateMerge(SKImageFilter first, SKImageFilter second);
    public static SKImageFilter CreateMerge(SKImageFilter first, SKImageFilter second, SKRect cropRect);
    public static SKImageFilter CreateMerge(SKImageFilter first, SKImageFilter second, CropRect cropRect);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateMerge(ReadOnlySpan<SKImageFilter>, SKImageFilter.CropRect) instead.")]
public static SKImageFilter CreateMerge(SKImageFilter[] filters, SKBlendMode[] modes, CropRect cropRect);
    public static SKImageFilter CreateMerge(ReadOnlySpan`1<SKImageFilter> filters);
    public static SKImageFilter CreateMerge(ReadOnlySpan`1<SKImageFilter> filters, SKRect cropRect);
    public static SKImageFilter CreateMerge(SKImageFilter[] filters, CropRect cropRect);
    public static SKImageFilter CreateMerge(ReadOnlySpan`1<SKImageFilter> filters, CropRect cropRect);
    public static SKImageFilter CreateDilate(int radiusX, int radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateDilate(float radiusX, float radiusY);
    public static SKImageFilter CreateDilate(float radiusX, float radiusY, SKImageFilter input);
    public static SKImageFilter CreateDilate(float radiusX, float radiusY, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateDilate(float radiusX, float radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateErode(int radiusX, int radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateErode(float radiusX, float radiusY);
    public static SKImageFilter CreateErode(float radiusX, float radiusY, SKImageFilter input);
    public static SKImageFilter CreateErode(float radiusX, float radiusY, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateErode(float radiusX, float radiusY, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreateOffset(float radiusX, float radiusY);
    public static SKImageFilter CreateOffset(float radiusX, float radiusY, SKImageFilter input);
    public static SKImageFilter CreateOffset(float radiusX, float radiusY, SKImageFilter input, SKRect cropRect);
    public static SKImageFilter CreateOffset(float dx, float dy, SKImageFilter input, CropRect cropRect);
    public static SKImageFilter CreatePicture(SKPicture picture);
    public static SKImageFilter CreatePicture(SKPicture picture, SKRect cropRect);
    public static SKImageFilter CreateTile(SKRect src, SKRect dst);
    public static SKImageFilter CreateTile(SKRect src, SKRect dst, SKImageFilter input);
    public static SKImageFilter CreateBlendMode(SKBlendMode mode, SKImageFilter background);
    public static SKImageFilter CreateBlendMode(SKBlendMode mode, SKImageFilter background, SKImageFilter foreground);
    public static SKImageFilter CreateBlendMode(SKBlendMode mode, SKImageFilter background, SKImageFilter foreground, SKRect cropRect);
    public static SKImageFilter CreateBlendMode(SKBlendMode mode, SKImageFilter background, SKImageFilter foreground, CropRect cropRect);
    public static SKImageFilter CreateArithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, SKImageFilter background, SKImageFilter foreground);
    public static SKImageFilter CreateArithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, SKImageFilter background, SKImageFilter foreground, SKRect cropRect);
    public static SKImageFilter CreateArithmetic(float k1, float k2, float k3, float k4, bool enforcePMColor, SKImageFilter background, SKImageFilter foreground, CropRect cropRect);
    public static SKImageFilter CreateImage(SKImage image);
    public static SKImageFilter CreateImage(SKImage image, SKRect src, SKRect dst, SKFilterQuality filterQuality);
    public static SKImageFilter CreatePaint(SKPaint paint);
    public static SKImageFilter CreatePaint(SKPaint paint, SKRect cropRect);
    public static SKImageFilter CreatePaint(SKPaint paint, CropRect cropRect);
    internal static SKImageFilter GetObject(IntPtr handle);
    public static SKImageFilter CreateShader(SKShader shader);
    public static SKImageFilter CreateShader(SKShader shader, bool dither);
    public static SKImageFilter CreateShader(SKShader shader, bool dither, SKRect cropRect);
    public static SKImageFilter CreateShader(SKShader shader, bool dither, CropRect cropRect);
}
public class SkiaSharp.SKImageInfo : ValueType {
    public static SKImageInfo Empty;
    public static SKColorType PlatformColorType;
    public static int PlatformColorAlphaShift;
    public static int PlatformColorRedShift;
    public static int PlatformColorGreenShift;
    public static int PlatformColorBlueShift;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private SKColorType <ColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private SKAlphaType <AlphaType>k__BackingField;
    [CompilerGeneratedAttribute]
private SKColorSpace <ColorSpace>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public SKColorType ColorType { get; public set; }
    public SKAlphaType AlphaType { get; public set; }
    public SKColorSpace ColorSpace { get; public set; }
    public int BytesPerPixel { get; }
    public int BitsPerPixel { get; }
    public int BytesSize { get; }
    public long BytesSize64 { get; }
    public int RowBytes { get; }
    public long RowBytes64 { get; }
    public bool IsEmpty { get; }
    public bool IsOpaque { get; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    private static SKImageInfo();
    public SKImageInfo(int width, int height);
    public SKImageInfo(int width, int height, SKColorType colorType);
    public SKImageInfo(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    public SKImageInfo(int width, int height, SKColorType colorType, SKAlphaType alphaType, SKColorSpace colorspace);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKColorType get_ColorType();
    [CompilerGeneratedAttribute]
public void set_ColorType(SKColorType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKAlphaType get_AlphaType();
    [CompilerGeneratedAttribute]
public void set_AlphaType(SKAlphaType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKColorSpace get_ColorSpace();
    [CompilerGeneratedAttribute]
public void set_ColorSpace(SKColorSpace value);
    [IsReadOnlyAttribute]
public int get_BytesPerPixel();
    [IsReadOnlyAttribute]
public int get_BitsPerPixel();
    [IsReadOnlyAttribute]
public int get_BytesSize();
    [IsReadOnlyAttribute]
public long get_BytesSize64();
    [IsReadOnlyAttribute]
public int get_RowBytes();
    [IsReadOnlyAttribute]
public long get_RowBytes64();
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public bool get_IsOpaque();
    [IsReadOnlyAttribute]
public SKSizeI get_Size();
    [IsReadOnlyAttribute]
public SKRectI get_Rect();
    [IsReadOnlyAttribute]
public SKImageInfo WithSize(SKSizeI size);
    [IsReadOnlyAttribute]
public SKImageInfo WithSize(int width, int height);
    [IsReadOnlyAttribute]
public SKImageInfo WithColorType(SKColorType newColorType);
    [IsReadOnlyAttribute]
public SKImageInfo WithColorSpace(SKColorSpace newColorSpace);
    [IsReadOnlyAttribute]
public SKImageInfo WithAlphaType(SKAlphaType newAlphaType);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKImageInfo obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKImageInfo left, SKImageInfo right);
    public static bool op_Inequality(SKImageInfo left, SKImageInfo right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal class SkiaSharp.SKImageInfoNative : ValueType {
    public IntPtr colorspace;
    public int width;
    public int height;
    public SKColorTypeNative colorType;
    public SKAlphaType alphaType;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKImageInfoNative obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKImageInfoNative left, SKImageInfoNative right);
    public static bool op_Inequality(SKImageInfoNative left, SKImageInfoNative right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static void UpdateNative(SKImageInfo& managed, SKImageInfoNative& native);
    public static SKImageInfoNative FromManaged(SKImageInfo& managed);
    public static SKImageInfo ToManaged(SKImageInfoNative& native);
}
public class SkiaSharp.SKImageRasterReleaseDelegate : MulticastDelegate {
    public SKImageRasterReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pixels, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr pixels, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKImageRasterReleaseProxyDelegate : MulticastDelegate {
    public SKImageRasterReleaseProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(Void* addr, Void* context);
    public virtual IAsyncResult BeginInvoke(Void* addr, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKImageTextureReleaseDelegate : MulticastDelegate {
    public SKImageTextureReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(object context);
    public virtual IAsyncResult BeginInvoke(object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKImageTextureReleaseProxyDelegate : MulticastDelegate {
    public SKImageTextureReleaseProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(Void* context);
    public virtual IAsyncResult BeginInvoke(Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum SkiaSharp.SKJpegEncoderAlphaOption : Enum {
    public int value__;
    public static SKJpegEncoderAlphaOption Ignore;
    public static SKJpegEncoderAlphaOption BlendOnBlack;
}
public enum SkiaSharp.SKJpegEncoderDownsample : Enum {
    public int value__;
    public static SKJpegEncoderDownsample Downsample420;
    public static SKJpegEncoderDownsample Downsample422;
    public static SKJpegEncoderDownsample Downsample444;
}
public class SkiaSharp.SKJpegEncoderOptions : ValueType {
    public static SKJpegEncoderOptions Default;
    private int fQuality;
    private SKJpegEncoderDownsample fDownsample;
    private SKJpegEncoderAlphaOption fAlphaOption;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKTransferFunctionBehavior BlendBehavior { get; public set; }
    public int Quality { get; public set; }
    public SKJpegEncoderDownsample Downsample { get; public set; }
    public SKJpegEncoderAlphaOption AlphaOption { get; public set; }
    private static SKJpegEncoderOptions();
    public SKJpegEncoderOptions(int quality, SKJpegEncoderDownsample downsample, SKJpegEncoderAlphaOption alphaOption);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKJpegEncoderOptions(int, SKJpegEncoderDownsample, SKJpegEncoderAlphaOption) instead.")]
public SKJpegEncoderOptions(int quality, SKJpegEncoderDownsample downsample, SKJpegEncoderAlphaOption alphaOption, SKTransferFunctionBehavior blendBehavior);
    [IsReadOnlyAttribute]
public SKTransferFunctionBehavior get_BlendBehavior();
    public void set_BlendBehavior(SKTransferFunctionBehavior value);
    [IsReadOnlyAttribute]
public int get_Quality();
    public void set_Quality(int value);
    [IsReadOnlyAttribute]
public SKJpegEncoderDownsample get_Downsample();
    public void set_Downsample(SKJpegEncoderDownsample value);
    [IsReadOnlyAttribute]
public SKJpegEncoderAlphaOption get_AlphaOption();
    public void set_AlphaOption(SKJpegEncoderAlphaOption value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKJpegEncoderOptions obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKJpegEncoderOptions left, SKJpegEncoderOptions right);
    public static bool op_Inequality(SKJpegEncoderOptions left, SKJpegEncoderOptions right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKLattice : ValueType {
    [CompilerGeneratedAttribute]
private Int32[] <XDivs>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <YDivs>k__BackingField;
    [CompilerGeneratedAttribute]
private SKLatticeRectType[] <RectTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SKRectI> <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private SKColor[] <Colors>k__BackingField;
    public Int32[] XDivs { get; public set; }
    public Int32[] YDivs { get; public set; }
    public SKLatticeRectType[] RectTypes { get; public set; }
    public Nullable`1<SKRectI> Bounds { get; public set; }
    public SKColor[] Colors { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Int32[] get_XDivs();
    [CompilerGeneratedAttribute]
public void set_XDivs(Int32[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Int32[] get_YDivs();
    [CompilerGeneratedAttribute]
public void set_YDivs(Int32[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKLatticeRectType[] get_RectTypes();
    [CompilerGeneratedAttribute]
public void set_RectTypes(SKLatticeRectType[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<SKRectI> get_Bounds();
    [CompilerGeneratedAttribute]
public void set_Bounds(Nullable`1<SKRectI> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKColor[] get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(SKColor[] value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKLattice obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKLattice left, SKLattice right);
    public static bool op_Inequality(SKLattice left, SKLattice right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
internal class SkiaSharp.SKLatticeInternal : ValueType {
    public Int32* fXDivs;
    public Int32* fYDivs;
    public SKLatticeRectType* fRectTypes;
    public int fXCount;
    public int fYCount;
    public SKRectI* fBounds;
    public UInt32* fColors;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKLatticeInternal obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKLatticeInternal left, SKLatticeInternal right);
    public static bool op_Inequality(SKLatticeInternal left, SKLatticeInternal right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public enum SkiaSharp.SKLatticeRectType : Enum {
    public int value__;
    public static SKLatticeRectType Default;
    public static SKLatticeRectType Transparent;
    public static SKLatticeRectType FixedColor;
}
internal class SkiaSharp.SKManagedDrawableDelegates : ValueType {
    public SKManagedDrawableDrawProxyDelegate fDraw;
    public SKManagedDrawableGetBoundsProxyDelegate fGetBounds;
    public SKManagedDrawableNewPictureSnapshotProxyDelegate fNewPictureSnapshot;
    public SKManagedDrawableDestroyProxyDelegate fDestroy;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKManagedDrawableDelegates obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKManagedDrawableDelegates left, SKManagedDrawableDelegates right);
    public static bool op_Inequality(SKManagedDrawableDelegates left, SKManagedDrawableDelegates right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedDrawableDestroyProxyDelegate : MulticastDelegate {
    public SKManagedDrawableDestroyProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr d, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedDrawableDrawProxyDelegate : MulticastDelegate {
    public SKManagedDrawableDrawProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr d, Void* context, IntPtr ccanvas);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, IntPtr ccanvas, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedDrawableGetBoundsProxyDelegate : MulticastDelegate {
    public SKManagedDrawableGetBoundsProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr d, Void* context, SKRect* rect);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, SKRect* rect, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedDrawableNewPictureSnapshotProxyDelegate : MulticastDelegate {
    public SKManagedDrawableNewPictureSnapshotProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr d, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public abstract class SkiaSharp.SKManagedPixelSerializer : SKPixelSerializer {
}
public class SkiaSharp.SKManagedStream : SKAbstractManagedStream {
    private Stream stream;
    private bool isAsEnd;
    private bool disposeStream;
    private bool wasCopied;
    private WeakReference parent;
    private WeakReference child;
    public SKManagedStream(Stream managedStream);
    public SKManagedStream(Stream managedStream, bool disposeManagedStream);
    public int CopyTo(SKWStream destination);
    public SKStreamAsset ToMemoryStream();
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeManaged();
    private IntPtr OnReadManagedStream(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnRead(IntPtr buffer, IntPtr size);
    protected virtual IntPtr OnPeek(IntPtr buffer, IntPtr size);
    protected virtual bool OnIsAtEnd();
    protected virtual bool OnHasPosition();
    protected virtual bool OnHasLength();
    protected virtual bool OnRewind();
    protected virtual IntPtr OnGetPosition();
    protected virtual IntPtr OnGetLength();
    protected virtual bool OnSeek(IntPtr position);
    protected virtual bool OnMove(int offset);
    protected virtual IntPtr OnCreateNew();
    protected virtual IntPtr OnDuplicate();
    protected virtual IntPtr OnFork();
    private void VerifyOriginal();
}
internal class SkiaSharp.SKManagedStreamDelegates : ValueType {
    public SKManagedStreamReadProxyDelegate fRead;
    public SKManagedStreamPeekProxyDelegate fPeek;
    public SKManagedStreamIsAtEndProxyDelegate fIsAtEnd;
    public SKManagedStreamHasPositionProxyDelegate fHasPosition;
    public SKManagedStreamHasLengthProxyDelegate fHasLength;
    public SKManagedStreamRewindProxyDelegate fRewind;
    public SKManagedStreamGetPositionProxyDelegate fGetPosition;
    public SKManagedStreamSeekProxyDelegate fSeek;
    public SKManagedStreamMoveProxyDelegate fMove;
    public SKManagedStreamGetLengthProxyDelegate fGetLength;
    public SKManagedStreamDuplicateProxyDelegate fDuplicate;
    public SKManagedStreamForkProxyDelegate fFork;
    public SKManagedStreamDestroyProxyDelegate fDestroy;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKManagedStreamDelegates obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKManagedStreamDelegates left, SKManagedStreamDelegates right);
    public static bool op_Inequality(SKManagedStreamDelegates left, SKManagedStreamDelegates right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamDestroyProxyDelegate : MulticastDelegate {
    public SKManagedStreamDestroyProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamDuplicateProxyDelegate : MulticastDelegate {
    public SKManagedStreamDuplicateProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamForkProxyDelegate : MulticastDelegate {
    public SKManagedStreamForkProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamGetLengthProxyDelegate : MulticastDelegate {
    public SKManagedStreamGetLengthProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamGetPositionProxyDelegate : MulticastDelegate {
    public SKManagedStreamGetPositionProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamHasLengthProxyDelegate : MulticastDelegate {
    public SKManagedStreamHasLengthProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamHasPositionProxyDelegate : MulticastDelegate {
    public SKManagedStreamHasPositionProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamIsAtEndProxyDelegate : MulticastDelegate {
    public SKManagedStreamIsAtEndProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamMoveProxyDelegate : MulticastDelegate {
    public SKManagedStreamMoveProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context, int offset);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, int offset, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamPeekProxyDelegate : MulticastDelegate {
    public SKManagedStreamPeekProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context, Void* buffer, IntPtr size);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, Void* buffer, IntPtr size, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamReadProxyDelegate : MulticastDelegate {
    public SKManagedStreamReadProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context, Void* buffer, IntPtr size);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, Void* buffer, IntPtr size, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamRewindProxyDelegate : MulticastDelegate {
    public SKManagedStreamRewindProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedStreamSeekProxyDelegate : MulticastDelegate {
    public SKManagedStreamSeekProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context, IntPtr position);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, IntPtr position, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class SkiaSharp.SKManagedTraceMemoryDumpDelegates : ValueType {
    public SKManagedTraceMemoryDumpDumpNumericValueProxyDelegate fDumpNumericValue;
    public SKManagedTraceMemoryDumpDumpStringValueProxyDelegate fDumpStringValue;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKManagedTraceMemoryDumpDelegates obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKManagedTraceMemoryDumpDelegates left, SKManagedTraceMemoryDumpDelegates right);
    public static bool op_Inequality(SKManagedTraceMemoryDumpDelegates left, SKManagedTraceMemoryDumpDelegates right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedTraceMemoryDumpDumpNumericValueProxyDelegate : MulticastDelegate {
    public SKManagedTraceMemoryDumpDumpNumericValueProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* units, ulong value);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* units, ulong value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedTraceMemoryDumpDumpStringValueProxyDelegate : MulticastDelegate {
    public SKManagedTraceMemoryDumpDumpStringValueProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* value);
    public virtual IAsyncResult BeginInvoke(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKManagedWStream : SKAbstractManagedWStream {
    private Stream stream;
    private bool disposeStream;
    public SKManagedWStream(Stream managedStream);
    public SKManagedWStream(Stream managedStream, bool disposeManagedStream);
    private SKManagedWStream(Stream managedStream, bool disposeManagedStream, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeManaged();
    protected virtual bool OnWrite(IntPtr buffer, IntPtr size);
    protected virtual void OnFlush();
    protected virtual IntPtr OnBytesWritten();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedWStreamBytesWrittenProxyDelegate : MulticastDelegate {
    public SKManagedWStreamBytesWrittenProxyDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
internal class SkiaSharp.SKManagedWStreamDelegates : ValueType {
    public SKManagedWStreamWriteProxyDelegate fWrite;
    public SKManagedWStreamFlushProxyDelegate fFlush;
    public SKManagedWStreamBytesWrittenProxyDelegate fBytesWritten;
    public SKManagedWStreamDestroyProxyDelegate fDestroy;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKManagedWStreamDelegates obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKManagedWStreamDelegates left, SKManagedWStreamDelegates right);
    public static bool op_Inequality(SKManagedWStreamDelegates left, SKManagedWStreamDelegates right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedWStreamDestroyProxyDelegate : MulticastDelegate {
    public SKManagedWStreamDestroyProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedWStreamFlushProxyDelegate : MulticastDelegate {
    public SKManagedWStreamFlushProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr s, Void* context);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKManagedWStreamWriteProxyDelegate : MulticastDelegate {
    public SKManagedWStreamWriteProxyDelegate(object object, IntPtr method);
    public virtual bool Invoke(IntPtr s, Void* context, Void* buffer, IntPtr size);
    public virtual IAsyncResult BeginInvoke(IntPtr s, Void* context, Void* buffer, IntPtr size, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKMask : ValueType {
    private Byte* fImage;
    private SKRectI fBounds;
    private UInt32 fRowBytes;
    private SKMaskFormat fFormat;
    public IntPtr Image { get; public set; }
    public SKRectI Bounds { get; public set; }
    public UInt32 RowBytes { get; public set; }
    public SKMaskFormat Format { get; public set; }
    public bool IsEmpty { get; }
    public SKMask(IntPtr image, SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
    public SKMask(SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKMask obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKMask left, SKMask right);
    public static bool op_Inequality(SKMask left, SKMask right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public IntPtr get_Image();
    public void set_Image(IntPtr value);
    public Span`1<byte> GetImageSpan();
    [IsReadOnlyAttribute]
public SKRectI get_Bounds();
    public void set_Bounds(SKRectI value);
    [IsReadOnlyAttribute]
public UInt32 get_RowBytes();
    public void set_RowBytes(UInt32 value);
    [IsReadOnlyAttribute]
public SKMaskFormat get_Format();
    public void set_Format(SKMaskFormat value);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    public long AllocateImage();
    public void FreeImage();
    [IsReadOnlyAttribute]
public long ComputeImageSize();
    [IsReadOnlyAttribute]
public long ComputeTotalImageSize();
    [IsReadOnlyAttribute]
public byte GetAddr1(int x, int y);
    [IsReadOnlyAttribute]
public byte GetAddr8(int x, int y);
    [IsReadOnlyAttribute]
public ushort GetAddr16(int x, int y);
    [IsReadOnlyAttribute]
public UInt32 GetAddr32(int x, int y);
    [IsReadOnlyAttribute]
public IntPtr GetAddr(int x, int y);
    public static IntPtr AllocateImage(long size);
    public static void FreeImage(IntPtr image);
    public static SKMask Create(Byte[] image, SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
    public static SKMask Create(ReadOnlySpan`1<byte> image, SKRectI bounds, UInt32 rowBytes, SKMaskFormat format);
}
public class SkiaSharp.SKMaskFilter : SKObject {
    private static float BlurSigmaScale;
    public static int TableMaxLength;
    internal SKMaskFilter(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static float ConvertRadiusToSigma(float radius);
    public static float ConvertSigmaToRadius(float sigma);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma);
    public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, bool respectCTM);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateBlur(SKBlurStyle, float) instead.")]
public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKBlurMaskFilterFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateBlur(SKBlurStyle, float) instead.")]
public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKRect occluder);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateBlur(SKBlurStyle, float) instead.")]
public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKRect occluder, SKBlurMaskFilterFlags flags);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateBlur(SKBlurStyle, float, bool) instead.")]
public static SKMaskFilter CreateBlur(SKBlurStyle blurStyle, float sigma, SKRect occluder, bool respectCTM);
    public static SKMaskFilter CreateTable(Byte[] table);
    public static SKMaskFilter CreateGamma(float gamma);
    public static SKMaskFilter CreateClip(byte min, byte max);
    internal static SKMaskFilter GetObject(IntPtr handle);
}
public enum SkiaSharp.SKMaskFormat : Enum {
    public int value__;
    public static SKMaskFormat BW;
    public static SKMaskFormat A8;
    public static SKMaskFormat ThreeD;
    public static SKMaskFormat Argb32;
    public static SKMaskFormat Lcd16;
    public static SKMaskFormat Sdf;
}
public class SkiaSharp.SKMatrix : ValueType {
    private float scaleX;
    private float skewX;
    private float transX;
    private float skewY;
    private float scaleY;
    private float transY;
    private float persp0;
    private float persp1;
    private float persp2;
    internal static float DegreesToRadians;
    public static SKMatrix Empty;
    public static SKMatrix Identity;
    public float ScaleX { get; public set; }
    public float SkewX { get; public set; }
    public float TransX { get; public set; }
    public float SkewY { get; public set; }
    public float ScaleY { get; public set; }
    public float TransY { get; public set; }
    public float Persp0 { get; public set; }
    public float Persp1 { get; public set; }
    public float Persp2 { get; public set; }
    public bool IsIdentity { get; }
    public Single[] Values { get; public set; }
    public bool IsInvertible { get; }
    public SKMatrix(Single[] values);
    public SKMatrix(float scaleX, float skewX, float transX, float skewY, float scaleY, float transY, float persp0, float persp1, float persp2);
    private static SKMatrix();
    [IsReadOnlyAttribute]
public float get_ScaleX();
    public void set_ScaleX(float value);
    [IsReadOnlyAttribute]
public float get_SkewX();
    public void set_SkewX(float value);
    [IsReadOnlyAttribute]
public float get_TransX();
    public void set_TransX(float value);
    [IsReadOnlyAttribute]
public float get_SkewY();
    public void set_SkewY(float value);
    [IsReadOnlyAttribute]
public float get_ScaleY();
    public void set_ScaleY(float value);
    [IsReadOnlyAttribute]
public float get_TransY();
    public void set_TransY(float value);
    [IsReadOnlyAttribute]
public float get_Persp0();
    public void set_Persp0(float value);
    [IsReadOnlyAttribute]
public float get_Persp1();
    public void set_Persp1(float value);
    [IsReadOnlyAttribute]
public float get_Persp2();
    public void set_Persp2(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKMatrix obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKMatrix left, SKMatrix right);
    public static bool op_Inequality(SKMatrix left, SKMatrix right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IsReadOnlyAttribute]
public Single[] get_Values();
    public void set_Values(Single[] value);
    [IsReadOnlyAttribute]
public void GetValues(Single[] values);
    public static SKMatrix CreateIdentity();
    public static SKMatrix CreateTranslation(float x, float y);
    public static SKMatrix CreateScale(float x, float y);
    public static SKMatrix CreateScale(float x, float y, float pivotX, float pivotY);
    public static SKMatrix CreateRotation(float radians);
    public static SKMatrix CreateRotation(float radians, float pivotX, float pivotY);
    public static SKMatrix CreateRotationDegrees(float degrees);
    public static SKMatrix CreateRotationDegrees(float degrees, float pivotX, float pivotY);
    public static SKMatrix CreateSkew(float x, float y);
    public static SKMatrix CreateScaleTranslation(float sx, float sy, float tx, float ty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateIdentity() instead.")]
public static SKMatrix MakeIdentity();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateScale(float, float) instead.")]
public static SKMatrix MakeScale(float sx, float sy);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateScale(float, float, float, float) instead.")]
public static SKMatrix MakeScale(float sx, float sy, float pivotX, float pivotY);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateTranslation(float, float) instead.")]
public static SKMatrix MakeTranslation(float dx, float dy);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotation(float) instead.")]
public static SKMatrix MakeRotation(float radians);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotation(float, float, float) instead.")]
public static SKMatrix MakeRotation(float radians, float pivotx, float pivoty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotationDegrees(float) instead.")]
public static SKMatrix MakeRotationDegrees(float degrees);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotationDegrees(float, float, float) instead.")]
public static SKMatrix MakeRotationDegrees(float degrees, float pivotx, float pivoty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateSkew(float, float) instead.")]
public static SKMatrix MakeSkew(float sx, float sy);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateScaleTranslation(float, float, float, float) instead.")]
public void SetScaleTranslate(float sx, float sy, float tx, float ty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotation(float, float, float) instead.")]
public static void Rotate(SKMatrix& matrix, float radians, float pivotx, float pivoty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotationDegrees(float, float, float) instead.")]
public static void RotateDegrees(SKMatrix& matrix, float degrees, float pivotx, float pivoty);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotation(float) instead.")]
public static void Rotate(SKMatrix& matrix, float radians);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CreateRotationDegrees(float) instead.")]
public static void RotateDegrees(SKMatrix& matrix, float degrees);
    [IsReadOnlyAttribute]
public bool get_IsInvertible();
    [IsReadOnlyAttribute]
public bool TryInvert(SKMatrix& inverse);
    [IsReadOnlyAttribute]
public SKMatrix Invert();
    public static SKMatrix Concat(SKMatrix first, SKMatrix second);
    [IsReadOnlyAttribute]
public SKMatrix PreConcat(SKMatrix matrix);
    [IsReadOnlyAttribute]
public SKMatrix PostConcat(SKMatrix matrix);
    public static void Concat(SKMatrix& target, SKMatrix first, SKMatrix second);
    public static void Concat(SKMatrix& target, SKMatrix& first, SKMatrix& second);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PreConcat(SKMatrix) instead.")]
public static void PreConcat(SKMatrix& target, SKMatrix matrix);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PreConcat(SKMatrix) instead.")]
public static void PreConcat(SKMatrix& target, SKMatrix& matrix);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PostConcat(SKMatrix) instead.")]
public static void PostConcat(SKMatrix& target, SKMatrix matrix);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PostConcat(SKMatrix) instead.")]
public static void PostConcat(SKMatrix& target, SKMatrix& matrix);
    [IsReadOnlyAttribute]
public SKRect MapRect(SKRect source);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use MapRect(SKRect) instead.")]
public static void MapRect(SKMatrix& matrix, SKRect& dest, SKRect& source);
    [IsReadOnlyAttribute]
public SKPoint MapPoint(SKPoint point);
    [IsReadOnlyAttribute]
public SKPoint MapPoint(float x, float y);
    [IsReadOnlyAttribute]
public void MapPoints(SKPoint[] result, SKPoint[] points);
    [IsReadOnlyAttribute]
public SKPoint[] MapPoints(SKPoint[] points);
    [IsReadOnlyAttribute]
public SKPoint MapVector(SKPoint vector);
    [IsReadOnlyAttribute]
public SKPoint MapVector(float x, float y);
    [IsReadOnlyAttribute]
public void MapVectors(SKPoint[] result, SKPoint[] vectors);
    [IsReadOnlyAttribute]
public SKPoint[] MapVectors(SKPoint[] vectors);
    [IsReadOnlyAttribute]
public float MapRadius(float radius);
    private static void SetSinCos(SKMatrix& matrix, float sin, float cos);
    private static void SetSinCos(SKMatrix& matrix, float sin, float cos, float pivotx, float pivoty);
    private static float Dot(float a, float b, float c, float d);
    private static float Cross(float a, float b, float c, float d);
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKMatrix44 : SKObject {
    public SKMatrix Matrix { get; }
    public SKMatrix44TypeMask Type { get; }
    public float Item { get; public set; }
    public bool IsInvertible { get; }
    internal SKMatrix44(IntPtr x, bool owns);
    public SKMatrix44(SKMatrix44 src);
    public SKMatrix44(SKMatrix44 a, SKMatrix44 b);
    public SKMatrix44(SKMatrix src);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKMatrix get_Matrix();
    public SKMatrix44TypeMask get_Type();
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public static SKMatrix44 CreateIdentity();
    [EditorBrowsableAttribute("1")]
public static SKMatrix44 CreateTranslate(float x, float y, float z);
    public static SKMatrix44 CreateTranslation(float x, float y, float z);
    public static SKMatrix44 CreateScale(float x, float y, float z);
    public static SKMatrix44 CreateRotation(float x, float y, float z, float radians);
    public static SKMatrix44 CreateRotationDegrees(float x, float y, float z, float degrees);
    public static SKMatrix44 FromRowMajor(Single[] src);
    public static SKMatrix44 FromColumnMajor(Single[] src);
    public Single[] ToColumnMajor();
    public void ToColumnMajor(Single[] dst);
    public Single[] ToRowMajor();
    public void ToRowMajor(Single[] dst);
    public static bool Equal(SKMatrix44 left, SKMatrix44 right);
    public void SetIdentity();
    public void SetColumnMajor(Single[] src);
    public void SetRowMajor(Single[] src);
    public void Set3x3ColumnMajor(Single[] src);
    public void Set3x3RowMajor(Single[] src);
    public void SetTranslate(float dx, float dy, float dz);
    public void SetScale(float sx, float sy, float sz);
    public void SetRotationAboutDegrees(float x, float y, float z, float degrees);
    public void SetRotationAbout(float x, float y, float z, float radians);
    public void SetRotationAboutUnit(float x, float y, float z, float radians);
    public void SetConcat(SKMatrix44 a, SKMatrix44 b);
    public void PreTranslate(float dx, float dy, float dz);
    public void PostTranslate(float dx, float dy, float dz);
    public void PreScale(float sx, float sy, float sz);
    public void PostScale(float sx, float sy, float sz);
    public void PreConcat(SKMatrix44 m);
    public void PostConcat(SKMatrix44 m);
    public bool get_IsInvertible();
    public SKMatrix44 Invert();
    public bool Invert(SKMatrix44 inverse);
    public void Transpose();
    public Single[] MapScalars(float x, float y, float z, float w);
    public Single[] MapScalars(Single[] srcVector4);
    public void MapScalars(Single[] srcVector4, Single[] dstVector4);
    public SKPoint MapPoint(SKPoint src);
    public SKPoint[] MapPoints(SKPoint[] src);
    public Single[] MapVector2(Single[] src2);
    public void MapVector2(Single[] src2, Single[] dst4);
    public bool Preserves2DAxisAlignment(float epsilon);
    public double Determinant();
    public static SKMatrix44 op_Implicit(SKMatrix matrix);
    internal static SKMatrix44 GetObject(IntPtr handle, bool owns);
}
[FlagsAttribute]
public enum SkiaSharp.SKMatrix44TypeMask : Enum {
    public int value__;
    public static SKMatrix44TypeMask Identity;
    public static SKMatrix44TypeMask Translate;
    public static SKMatrix44TypeMask Scale;
    public static SKMatrix44TypeMask Affine;
    public static SKMatrix44TypeMask Perspective;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKShaderTileMode instead.")]
public enum SkiaSharp.SKMatrixConvolutionTileMode : Enum {
    public int value__;
    public static SKMatrixConvolutionTileMode Clamp;
    public static SKMatrixConvolutionTileMode Repeat;
    public static SKMatrixConvolutionTileMode ClampToBlack;
}
public class SkiaSharp.SKMemoryStream : SKStreamMemory {
    internal SKMemoryStream(IntPtr handle, bool owns);
    public SKMemoryStream(ulong length);
    internal SKMemoryStream(IntPtr data, IntPtr length, bool copyData);
    public SKMemoryStream(SKData data);
    public SKMemoryStream(Byte[] data);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    internal void SetMemory(IntPtr data, IntPtr length, bool copyData);
    internal void SetMemory(Byte[] data, IntPtr length, bool copyData);
    public void SetMemory(Byte[] data);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKColorSpaceTransferFn instead.")]
public enum SkiaSharp.SKNamedGamma : Enum {
    public int value__;
    public static SKNamedGamma Linear;
    public static SKNamedGamma Srgb;
    public static SKNamedGamma TwoDotTwoCurve;
    public static SKNamedGamma NonStandard;
}
public abstract class SkiaSharp.SKNativeObject : object {
    internal bool fromFinalizer;
    private int isDisposed;
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnorePublicDispose>k__BackingField;
    public IntPtr Handle { get; protected set; }
    protected internal bool OwnsHandle { get; protected set; }
    protected internal bool IgnorePublicDispose { get; protected internal set; }
    protected internal bool IsDisposed { get; }
    internal SKNativeObject(IntPtr handle);
    internal SKNativeObject(IntPtr handle, bool ownsHandle);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public virtual IntPtr get_Handle();
    [CompilerGeneratedAttribute]
protected virtual void set_Handle(IntPtr value);
    [CompilerGeneratedAttribute]
protected internal virtual bool get_OwnsHandle();
    [CompilerGeneratedAttribute]
protected virtual void set_OwnsHandle(bool value);
    [CompilerGeneratedAttribute]
protected internal bool get_IgnorePublicDispose();
    [CompilerGeneratedAttribute]
protected internal void set_IgnorePublicDispose(bool value);
    protected internal bool get_IsDisposed();
    protected virtual void DisposeUnownedManaged();
    protected virtual void DisposeManaged();
    protected virtual void DisposeNative();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected internal void DisposeInternal();
}
public class SkiaSharp.SKNoDrawCanvas : SKCanvas {
    internal SKNoDrawCanvas(IntPtr handle, bool owns);
    public SKNoDrawCanvas(int width, int height);
}
public class SkiaSharp.SKNWayCanvas : SKNoDrawCanvas {
    internal SKNWayCanvas(IntPtr handle, bool owns);
    public SKNWayCanvas(int width, int height);
    public void AddCanvas(SKCanvas canvas);
    public void RemoveCanvas(SKCanvas canvas);
    public void RemoveAll();
}
public abstract class SkiaSharp.SKObject : SKNativeObject {
    private object locker;
    private ConcurrentDictionary`2<IntPtr, SKObject> ownedObjects;
    private ConcurrentDictionary`2<IntPtr, SKObject> keepAliveObjects;
    internal ConcurrentDictionary`2<IntPtr, SKObject> OwnedObjects { get; }
    internal ConcurrentDictionary`2<IntPtr, SKObject> KeepAliveObjects { get; }
    public IntPtr Handle { get; protected set; }
    private static SKObject();
    internal SKObject(IntPtr handle, bool owns);
    internal ConcurrentDictionary`2<IntPtr, SKObject> get_OwnedObjects();
    internal ConcurrentDictionary`2<IntPtr, SKObject> get_KeepAliveObjects();
    protected virtual void Dispose(bool disposing);
    public virtual IntPtr get_Handle();
    protected virtual void set_Handle(IntPtr value);
    protected virtual void DisposeUnownedManaged();
    protected virtual void DisposeManaged();
    protected virtual void DisposeNative();
    internal static TSkiaObject GetOrAddObject(IntPtr handle, Func`3<IntPtr, bool, TSkiaObject> objectFactory);
    internal static TSkiaObject GetOrAddObject(IntPtr handle, bool owns, Func`3<IntPtr, bool, TSkiaObject> objectFactory);
    internal static TSkiaObject GetOrAddObject(IntPtr handle, bool owns, bool unrefExisting, Func`3<IntPtr, bool, TSkiaObject> objectFactory);
    internal static void RegisterHandle(IntPtr handle, SKObject instance);
    internal static void DeregisterHandle(IntPtr handle, SKObject instance);
    internal static bool GetInstance(IntPtr handle, TSkiaObject& instance);
    internal void PreventPublicDisposal();
    internal void RevokeOwnership(SKObject newOwner);
    internal static T OwnedBy(T child, SKObject owner);
    internal static T Owned(T owner, SKObject child);
    internal static T Referenced(T owner, SKObject child);
    internal static T[] PtrToStructureArray(IntPtr intPtr, int count);
    internal static T PtrToStructure(IntPtr intPtr, int index);
}
[ExtensionAttribute]
internal static class SkiaSharp.SKObjectExtensions : object {
    [ExtensionAttribute]
public static bool IsUnique(IntPtr handle, bool isVirtual);
    [ExtensionAttribute]
public static int GetReferenceCount(IntPtr handle, bool isVirtual);
    [ExtensionAttribute]
public static void SafeRef(ISKReferenceCounted obj);
    [ExtensionAttribute]
public static void SafeUnRef(ISKReferenceCounted obj);
    [ExtensionAttribute]
public static int GetReferenceCount(ISKReferenceCounted obj);
}
public class SkiaSharp.SKOverdrawCanvas : SKNWayCanvas {
    internal SKOverdrawCanvas(IntPtr handle, bool owns);
    public SKOverdrawCanvas(SKCanvas canvas);
}
public class SkiaSharp.SKPaint : SKObject {
    private SKFont font;
    private bool lcdRenderText;
    public bool IsAntialias { get; public set; }
    public bool IsDither { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public bool IsVerticalText { get; public set; }
    public bool IsLinearText { get; public set; }
    public bool SubpixelText { get; public set; }
    public bool LcdRenderText { get; public set; }
    public bool IsEmbeddedBitmapText { get; public set; }
    public bool IsAutohinted { get; public set; }
    public SKPaintHinting HintingLevel { get; public set; }
    public bool FakeBoldText { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public bool DeviceKerningEnabled { get; public set; }
    public bool IsStroke { get; public set; }
    public SKPaintStyle Style { get; public set; }
    public SKColor Color { get; public set; }
    public SKColorF ColorF { get; public set; }
    public float StrokeWidth { get; public set; }
    public float StrokeMiter { get; public set; }
    public SKStrokeCap StrokeCap { get; public set; }
    public SKStrokeJoin StrokeJoin { get; public set; }
    public SKShader Shader { get; public set; }
    public SKMaskFilter MaskFilter { get; public set; }
    public SKColorFilter ColorFilter { get; public set; }
    public SKImageFilter ImageFilter { get; public set; }
    public SKBlendMode BlendMode { get; public set; }
    public SKFilterQuality FilterQuality { get; public set; }
    public SKTypeface Typeface { get; public set; }
    public float TextSize { get; public set; }
    public SKTextAlign TextAlign { get; public set; }
    public SKTextEncoding TextEncoding { get; public set; }
    public float TextScaleX { get; public set; }
    public float TextSkewX { get; public set; }
    public SKPathEffect PathEffect { get; public set; }
    public float FontSpacing { get; }
    public SKFontMetrics FontMetrics { get; }
    internal SKPaint(IntPtr handle, bool owns);
    public SKPaint(SKFont font);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public void Reset();
    public bool get_IsAntialias();
    public void set_IsAntialias(bool value);
    public bool get_IsDither();
    public void set_IsDither(bool value);
    public bool get_IsVerticalText();
    public void set_IsVerticalText(bool value);
    public bool get_IsLinearText();
    public void set_IsLinearText(bool value);
    public bool get_SubpixelText();
    public void set_SubpixelText(bool value);
    public bool get_LcdRenderText();
    public void set_LcdRenderText(bool value);
    public bool get_IsEmbeddedBitmapText();
    public void set_IsEmbeddedBitmapText(bool value);
    public bool get_IsAutohinted();
    public void set_IsAutohinted(bool value);
    public SKPaintHinting get_HintingLevel();
    public void set_HintingLevel(SKPaintHinting value);
    public bool get_FakeBoldText();
    public void set_FakeBoldText(bool value);
    public bool get_DeviceKerningEnabled();
    public void set_DeviceKerningEnabled(bool value);
    public bool get_IsStroke();
    public void set_IsStroke(bool value);
    public SKPaintStyle get_Style();
    public void set_Style(SKPaintStyle value);
    public SKColor get_Color();
    public void set_Color(SKColor value);
    public SKColorF get_ColorF();
    public void set_ColorF(SKColorF value);
    public void SetColor(SKColorF color, SKColorSpace colorspace);
    public float get_StrokeWidth();
    public void set_StrokeWidth(float value);
    public float get_StrokeMiter();
    public void set_StrokeMiter(float value);
    public SKStrokeCap get_StrokeCap();
    public void set_StrokeCap(SKStrokeCap value);
    public SKStrokeJoin get_StrokeJoin();
    public void set_StrokeJoin(SKStrokeJoin value);
    public SKShader get_Shader();
    public void set_Shader(SKShader value);
    public SKMaskFilter get_MaskFilter();
    public void set_MaskFilter(SKMaskFilter value);
    public SKColorFilter get_ColorFilter();
    public void set_ColorFilter(SKColorFilter value);
    public SKImageFilter get_ImageFilter();
    public void set_ImageFilter(SKImageFilter value);
    public SKBlendMode get_BlendMode();
    public void set_BlendMode(SKBlendMode value);
    public SKFilterQuality get_FilterQuality();
    public void set_FilterQuality(SKFilterQuality value);
    public SKTypeface get_Typeface();
    public void set_Typeface(SKTypeface value);
    public float get_TextSize();
    public void set_TextSize(float value);
    public SKTextAlign get_TextAlign();
    public void set_TextAlign(SKTextAlign value);
    public SKTextEncoding get_TextEncoding();
    public void set_TextEncoding(SKTextEncoding value);
    public float get_TextScaleX();
    public void set_TextScaleX(float value);
    public float get_TextSkewX();
    public void set_TextSkewX(float value);
    public SKPathEffect get_PathEffect();
    public void set_PathEffect(SKPathEffect value);
    public float get_FontSpacing();
    public SKFontMetrics get_FontMetrics();
    public float GetFontMetrics(SKFontMetrics& metrics);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetFontMetrics (out SKFontMetrics) instead.")]
public float GetFontMetrics(SKFontMetrics& metrics, float scale);
    public SKPaint Clone();
    public float MeasureText(string text);
    public float MeasureText(ReadOnlySpan`1<char> text);
    public float MeasureText(Byte[] text);
    public float MeasureText(ReadOnlySpan`1<byte> text);
    public float MeasureText(IntPtr buffer, int length);
    public float MeasureText(IntPtr buffer, IntPtr length);
    public float MeasureText(string text, SKRect& bounds);
    public float MeasureText(ReadOnlySpan`1<char> text, SKRect& bounds);
    public float MeasureText(Byte[] text, SKRect& bounds);
    public float MeasureText(ReadOnlySpan`1<byte> text, SKRect& bounds);
    public float MeasureText(IntPtr buffer, int length, SKRect& bounds);
    public float MeasureText(IntPtr buffer, IntPtr length, SKRect& bounds);
    public long BreakText(string text, float maxWidth);
    public long BreakText(string text, float maxWidth, Single& measuredWidth);
    public long BreakText(string text, float maxWidth, Single& measuredWidth, String& measuredText);
    public long BreakText(ReadOnlySpan`1<char> text, float maxWidth);
    public long BreakText(ReadOnlySpan`1<char> text, float maxWidth, Single& measuredWidth);
    public long BreakText(Byte[] text, float maxWidth);
    public long BreakText(Byte[] text, float maxWidth, Single& measuredWidth);
    public long BreakText(ReadOnlySpan`1<byte> text, float maxWidth);
    public long BreakText(ReadOnlySpan`1<byte> text, float maxWidth, Single& measuredWidth);
    public long BreakText(IntPtr buffer, int length, float maxWidth);
    public long BreakText(IntPtr buffer, int length, float maxWidth, Single& measuredWidth);
    public long BreakText(IntPtr buffer, IntPtr length, float maxWidth);
    public long BreakText(IntPtr buffer, IntPtr length, float maxWidth, Single& measuredWidth);
    public SKPath GetTextPath(string text, float x, float y);
    public SKPath GetTextPath(ReadOnlySpan`1<char> text, float x, float y);
    public SKPath GetTextPath(Byte[] text, float x, float y);
    public SKPath GetTextPath(ReadOnlySpan`1<byte> text, float x, float y);
    public SKPath GetTextPath(IntPtr buffer, int length, float x, float y);
    public SKPath GetTextPath(IntPtr buffer, IntPtr length, float x, float y);
    public SKPath GetTextPath(string text, SKPoint[] points);
    public SKPath GetTextPath(ReadOnlySpan`1<char> text, ReadOnlySpan`1<SKPoint> points);
    public SKPath GetTextPath(Byte[] text, SKPoint[] points);
    public SKPath GetTextPath(ReadOnlySpan`1<byte> text, ReadOnlySpan`1<SKPoint> points);
    public SKPath GetTextPath(IntPtr buffer, int length, SKPoint[] points);
    public SKPath GetTextPath(IntPtr buffer, int length, ReadOnlySpan`1<SKPoint> points);
    public SKPath GetTextPath(IntPtr buffer, IntPtr length, SKPoint[] points);
    public SKPath GetFillPath(SKPath src);
    public SKPath GetFillPath(SKPath src, float resScale);
    public SKPath GetFillPath(SKPath src, SKRect cullRect);
    public SKPath GetFillPath(SKPath src, SKRect cullRect, float resScale);
    public bool GetFillPath(SKPath src, SKPath dst);
    public bool GetFillPath(SKPath src, SKPath dst, float resScale);
    public bool GetFillPath(SKPath src, SKPath dst, SKRect cullRect);
    public bool GetFillPath(SKPath src, SKPath dst, SKRect cullRect, float resScale);
    public int CountGlyphs(string text);
    public int CountGlyphs(ReadOnlySpan`1<char> text);
    public int CountGlyphs(Byte[] text);
    public int CountGlyphs(ReadOnlySpan`1<byte> text);
    public int CountGlyphs(IntPtr text, int length);
    public int CountGlyphs(IntPtr text, IntPtr length);
    public UInt16[] GetGlyphs(string text);
    public UInt16[] GetGlyphs(ReadOnlySpan`1<char> text);
    public UInt16[] GetGlyphs(Byte[] text);
    public UInt16[] GetGlyphs(ReadOnlySpan`1<byte> text);
    public UInt16[] GetGlyphs(IntPtr text, int length);
    public UInt16[] GetGlyphs(IntPtr text, IntPtr length);
    public bool ContainsGlyphs(string text);
    public bool ContainsGlyphs(ReadOnlySpan`1<char> text);
    public bool ContainsGlyphs(Byte[] text);
    public bool ContainsGlyphs(ReadOnlySpan`1<byte> text);
    public bool ContainsGlyphs(IntPtr text, int length);
    public bool ContainsGlyphs(IntPtr text, IntPtr length);
    public SKPoint[] GetGlyphPositions(string text, SKPoint origin);
    public SKPoint[] GetGlyphPositions(ReadOnlySpan`1<char> text, SKPoint origin);
    public SKPoint[] GetGlyphPositions(ReadOnlySpan`1<byte> text, SKPoint origin);
    public SKPoint[] GetGlyphPositions(IntPtr text, int length, SKPoint origin);
    public Single[] GetGlyphOffsets(string text, float origin);
    public Single[] GetGlyphOffsets(ReadOnlySpan`1<char> text, float origin);
    public Single[] GetGlyphOffsets(ReadOnlySpan`1<byte> text, float origin);
    public Single[] GetGlyphOffsets(IntPtr text, int length, float origin);
    public Single[] GetGlyphWidths(string text);
    public Single[] GetGlyphWidths(ReadOnlySpan`1<char> text);
    public Single[] GetGlyphWidths(Byte[] text);
    public Single[] GetGlyphWidths(ReadOnlySpan`1<byte> text);
    public Single[] GetGlyphWidths(IntPtr text, int length);
    public Single[] GetGlyphWidths(IntPtr text, IntPtr length);
    public Single[] GetGlyphWidths(string text, SKRect[]& bounds);
    public Single[] GetGlyphWidths(ReadOnlySpan`1<char> text, SKRect[]& bounds);
    public Single[] GetGlyphWidths(Byte[] text, SKRect[]& bounds);
    public Single[] GetGlyphWidths(ReadOnlySpan`1<byte> text, SKRect[]& bounds);
    public Single[] GetGlyphWidths(IntPtr text, int length, SKRect[]& bounds);
    public Single[] GetGlyphWidths(IntPtr text, IntPtr length, SKRect[]& bounds);
    public Single[] GetTextIntercepts(string text, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(ReadOnlySpan`1<char> text, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(Byte[] text, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(ReadOnlySpan`1<byte> text, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(IntPtr text, IntPtr length, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(IntPtr text, int length, float x, float y, float upperBounds, float lowerBounds);
    public Single[] GetTextIntercepts(SKTextBlob text, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(string text, SKPoint[] positions, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(ReadOnlySpan`1<char> text, ReadOnlySpan`1<SKPoint> positions, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(Byte[] text, SKPoint[] positions, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(ReadOnlySpan`1<byte> text, ReadOnlySpan`1<SKPoint> positions, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(IntPtr text, int length, SKPoint[] positions, float upperBounds, float lowerBounds);
    public Single[] GetPositionedTextIntercepts(IntPtr text, IntPtr length, SKPoint[] positions, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(string text, Single[] xpositions, float y, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(ReadOnlySpan`1<char> text, ReadOnlySpan`1<float> xpositions, float y, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(Byte[] text, Single[] xpositions, float y, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(ReadOnlySpan`1<byte> text, ReadOnlySpan`1<float> xpositions, float y, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(IntPtr text, int length, Single[] xpositions, float y, float upperBounds, float lowerBounds);
    public Single[] GetHorizontalTextIntercepts(IntPtr text, IntPtr length, Single[] xpositions, float y, float upperBounds, float lowerBounds);
    public SKFont ToFont();
    internal SKFont GetFont();
    private void UpdateFontEdging(bool antialias);
    internal static SKPaint GetObject(IntPtr handle);
}
public enum SkiaSharp.SKPaintHinting : Enum {
    public int value__;
    public static SKPaintHinting NoHinting;
    public static SKPaintHinting Slight;
    public static SKPaintHinting Normal;
    public static SKPaintHinting Full;
}
public enum SkiaSharp.SKPaintStyle : Enum {
    public int value__;
    public static SKPaintStyle Fill;
    public static SKPaintStyle Stroke;
    public static SKPaintStyle StrokeAndFill;
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKPath : SKObject {
    public SKPathFillType FillType { get; public set; }
    public SKPathConvexity Convexity { get; public set; }
    public bool IsConvex { get; }
    public bool IsConcave { get; }
    public bool IsEmpty { get; }
    public bool IsOval { get; }
    public bool IsRoundRect { get; }
    public bool IsLine { get; }
    public bool IsRect { get; }
    public SKPathSegmentMask SegmentMasks { get; }
    public int VerbCount { get; }
    public int PointCount { get; }
    public SKPoint Item { get; }
    public SKPoint[] Points { get; }
    public SKPoint LastPoint { get; }
    public SKRect Bounds { get; }
    public SKRect TightBounds { get; }
    internal SKPath(IntPtr handle, bool owns);
    public SKPath(SKPath path);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKPathFillType get_FillType();
    public void set_FillType(SKPathFillType value);
    public SKPathConvexity get_Convexity();
    [ObsoleteAttribute]
public void set_Convexity(SKPathConvexity value);
    public bool get_IsConvex();
    public bool get_IsConcave();
    public bool get_IsEmpty();
    public bool get_IsOval();
    public bool get_IsRoundRect();
    public bool get_IsLine();
    public bool get_IsRect();
    public SKPathSegmentMask get_SegmentMasks();
    public int get_VerbCount();
    public int get_PointCount();
    public SKPoint get_Item(int index);
    public SKPoint[] get_Points();
    public SKPoint get_LastPoint();
    public SKRect get_Bounds();
    public SKRect get_TightBounds();
    public SKRect GetOvalBounds();
    public SKRoundRect GetRoundRect();
    public SKPoint[] GetLine();
    public SKRect GetRect();
    public SKRect GetRect(Boolean& isClosed, SKPathDirection& direction);
    public SKPoint GetPoint(int index);
    public SKPoint[] GetPoints(int max);
    public int GetPoints(SKPoint[] points, int max);
    public bool Contains(float x, float y);
    public void Offset(SKPoint offset);
    public void Offset(float dx, float dy);
    public void MoveTo(SKPoint point);
    public void MoveTo(float x, float y);
    public void RMoveTo(SKPoint point);
    public void RMoveTo(float dx, float dy);
    public void LineTo(SKPoint point);
    public void LineTo(float x, float y);
    public void RLineTo(SKPoint point);
    public void RLineTo(float dx, float dy);
    public void QuadTo(SKPoint point0, SKPoint point1);
    public void QuadTo(float x0, float y0, float x1, float y1);
    public void RQuadTo(SKPoint point0, SKPoint point1);
    public void RQuadTo(float dx0, float dy0, float dx1, float dy1);
    public void ConicTo(SKPoint point0, SKPoint point1, float w);
    public void ConicTo(float x0, float y0, float x1, float y1, float w);
    public void RConicTo(SKPoint point0, SKPoint point1, float w);
    public void RConicTo(float dx0, float dy0, float dx1, float dy1, float w);
    public void CubicTo(SKPoint point0, SKPoint point1, SKPoint point2);
    public void CubicTo(float x0, float y0, float x1, float y1, float x2, float y2);
    public void RCubicTo(SKPoint point0, SKPoint point1, SKPoint point2);
    public void RCubicTo(float dx0, float dy0, float dx1, float dy1, float dx2, float dy2);
    public void ArcTo(SKPoint r, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, SKPoint xy);
    public void ArcTo(float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public void ArcTo(SKRect oval, float startAngle, float sweepAngle, bool forceMoveTo);
    public void ArcTo(SKPoint point1, SKPoint point2, float radius);
    public void ArcTo(float x1, float y1, float x2, float y2, float radius);
    public void RArcTo(SKPoint r, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, SKPoint xy);
    public void RArcTo(float rx, float ry, float xAxisRotate, SKPathArcSize largeArc, SKPathDirection sweep, float x, float y);
    public void Close();
    public void Rewind();
    public void Reset();
    public void AddRect(SKRect rect, SKPathDirection direction);
    public void AddRect(SKRect rect, SKPathDirection direction, UInt32 startIndex);
    public void AddRoundRect(SKRoundRect rect, SKPathDirection direction);
    public void AddRoundRect(SKRoundRect rect, SKPathDirection direction, UInt32 startIndex);
    public void AddOval(SKRect rect, SKPathDirection direction);
    public void AddArc(SKRect oval, float startAngle, float sweepAngle);
    public bool GetBounds(SKRect& rect);
    public SKRect ComputeTightBounds();
    public void Transform(SKMatrix matrix);
    public void Transform(SKMatrix matrix, SKPath destination);
    public void AddPath(SKPath other, float dx, float dy, SKPathAddMode mode);
    public void AddPath(SKPath other, SKMatrix& matrix, SKPathAddMode mode);
    public void AddPath(SKPath other, SKPathAddMode mode);
    public void AddPathReverse(SKPath other);
    public void AddRoundRect(SKRect rect, float rx, float ry, SKPathDirection dir);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRoundRect instead.")]
public void AddRoundedRect(SKRect rect, float rx, float ry, SKPathDirection dir);
    public void AddCircle(float x, float y, float radius, SKPathDirection dir);
    public void AddPoly(SKPoint[] points, bool close);
    public Iterator CreateIterator(bool forceClose);
    public RawIterator CreateRawIterator();
    public bool Op(SKPath other, SKPathOp op, SKPath result);
    public SKPath Op(SKPath other, SKPathOp op);
    public bool Simplify(SKPath result);
    public SKPath Simplify();
    public bool GetTightBounds(SKRect& result);
    public bool ToWinding(SKPath result);
    public SKPath ToWinding();
    public string ToSvgPathData();
    public static SKPath ParseSvgPathData(string svgPath);
    public static SKPoint[] ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, int pow2);
    public static int ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, SKPoint[]& pts, int pow2);
    public static int ConvertConicToQuads(SKPoint p0, SKPoint p1, SKPoint p2, float w, SKPoint[] pts, int pow2);
    internal static SKPath GetObject(IntPtr handle, bool owns);
}
public enum SkiaSharp.SKPath1DPathEffectStyle : Enum {
    public int value__;
    public static SKPath1DPathEffectStyle Translate;
    public static SKPath1DPathEffectStyle Rotate;
    public static SKPath1DPathEffectStyle Morph;
}
public enum SkiaSharp.SKPathAddMode : Enum {
    public int value__;
    public static SKPathAddMode Append;
    public static SKPathAddMode Extend;
}
public enum SkiaSharp.SKPathArcSize : Enum {
    public int value__;
    public static SKPathArcSize Small;
    public static SKPathArcSize Large;
}
public enum SkiaSharp.SKPathConvexity : Enum {
    public int value__;
    public static SKPathConvexity Unknown;
    public static SKPathConvexity Convex;
    public static SKPathConvexity Concave;
}
public enum SkiaSharp.SKPathDirection : Enum {
    public int value__;
    public static SKPathDirection Clockwise;
    public static SKPathDirection CounterClockwise;
}
public class SkiaSharp.SKPathEffect : SKObject {
    internal SKPathEffect(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public static SKPathEffect CreateCompose(SKPathEffect outer, SKPathEffect inner);
    public static SKPathEffect CreateSum(SKPathEffect first, SKPathEffect second);
    public static SKPathEffect CreateDiscrete(float segLength, float deviation, UInt32 seedAssist);
    public static SKPathEffect CreateCorner(float radius);
    public static SKPathEffect Create1DPath(SKPath path, float advance, float phase, SKPath1DPathEffectStyle style);
    public static SKPathEffect Create2DLine(float width, SKMatrix matrix);
    public static SKPathEffect Create2DPath(SKMatrix matrix, SKPath path);
    public static SKPathEffect CreateDash(Single[] intervals, float phase);
    public static SKPathEffect CreateTrim(float start, float stop);
    public static SKPathEffect CreateTrim(float start, float stop, SKTrimPathEffectMode mode);
    internal static SKPathEffect GetObject(IntPtr handle);
}
public enum SkiaSharp.SKPathFillType : Enum {
    public int value__;
    public static SKPathFillType Winding;
    public static SKPathFillType EvenOdd;
    public static SKPathFillType InverseWinding;
    public static SKPathFillType InverseEvenOdd;
}
public class SkiaSharp.SKPathMeasure : SKObject {
    public float Length { get; }
    public bool IsClosed { get; }
    internal SKPathMeasure(IntPtr handle, bool owns);
    public SKPathMeasure(SKPath path, bool forceClosed, float resScale);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public float get_Length();
    public bool get_IsClosed();
    public void SetPath(SKPath path);
    public void SetPath(SKPath path, bool forceClosed);
    public bool GetPositionAndTangent(float distance, SKPoint& position, SKPoint& tangent);
    public SKPoint GetPosition(float distance);
    public bool GetPosition(float distance, SKPoint& position);
    public SKPoint GetTangent(float distance);
    public bool GetTangent(float distance, SKPoint& tangent);
    public SKMatrix GetMatrix(float distance, SKPathMeasureMatrixFlags flags);
    public bool GetMatrix(float distance, SKMatrix& matrix, SKPathMeasureMatrixFlags flags);
    public bool GetSegment(float start, float stop, SKPath dst, bool startWithMoveTo);
    public SKPath GetSegment(float start, float stop, bool startWithMoveTo);
    public bool NextContour();
}
[FlagsAttribute]
public enum SkiaSharp.SKPathMeasureMatrixFlags : Enum {
    public int value__;
    public static SKPathMeasureMatrixFlags GetPosition;
    public static SKPathMeasureMatrixFlags GetTangent;
    public static SKPathMeasureMatrixFlags GetPositionAndTangent;
}
public enum SkiaSharp.SKPathOp : Enum {
    public int value__;
    public static SKPathOp Difference;
    public static SKPathOp Intersect;
    public static SKPathOp Union;
    public static SKPathOp Xor;
    public static SKPathOp ReverseDifference;
}
[FlagsAttribute]
public enum SkiaSharp.SKPathSegmentMask : Enum {
    public int value__;
    public static SKPathSegmentMask Line;
    public static SKPathSegmentMask Quad;
    public static SKPathSegmentMask Conic;
    public static SKPathSegmentMask Cubic;
}
public enum SkiaSharp.SKPathVerb : Enum {
    public int value__;
    public static SKPathVerb Move;
    public static SKPathVerb Line;
    public static SKPathVerb Quad;
    public static SKPathVerb Conic;
    public static SKPathVerb Cubic;
    public static SKPathVerb Close;
    public static SKPathVerb Done;
}
public class SkiaSharp.SKPicture : SKObject {
    public UInt32 UniqueId { get; }
    public SKRect CullRect { get; }
    internal SKPicture(IntPtr h, bool owns);
    protected virtual void Dispose(bool disposing);
    public UInt32 get_UniqueId();
    public SKRect get_CullRect();
    public SKData Serialize();
    public void Serialize(Stream stream);
    public void Serialize(SKWStream stream);
    public SKShader ToShader();
    public SKShader ToShader(SKShaderTileMode tmx, SKShaderTileMode tmy);
    public SKShader ToShader(SKShaderTileMode tmx, SKShaderTileMode tmy, SKRect tile);
    public SKShader ToShader(SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix, SKRect tile);
    public static SKPicture Deserialize(IntPtr data, int length);
    public static SKPicture Deserialize(ReadOnlySpan`1<byte> data);
    public static SKPicture Deserialize(SKData data);
    public static SKPicture Deserialize(Stream stream);
    public static SKPicture Deserialize(SKStream stream);
    internal static SKPicture GetObject(IntPtr handle, bool owns, bool unrefExisting);
}
public class SkiaSharp.SKPictureRecorder : SKObject {
    public SKCanvas RecordingCanvas { get; }
    internal SKPictureRecorder(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKCanvas BeginRecording(SKRect cullRect);
    public SKPicture EndRecording();
    public SKDrawable EndRecordingAsDrawable();
    public SKCanvas get_RecordingCanvas();
}
public enum SkiaSharp.SKPixelGeometry : Enum {
    public int value__;
    public static SKPixelGeometry Unknown;
    public static SKPixelGeometry RgbHorizontal;
    public static SKPixelGeometry BgrHorizontal;
    public static SKPixelGeometry RgbVertical;
    public static SKPixelGeometry BgrVertical;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public abstract class SkiaSharp.SKPixelSerializer : SKObject {
    public bool UseEncodedData(IntPtr data, ulong length);
    public SKData Encode(SKPixmap pixmap);
    protected abstract virtual bool OnUseEncodedData(IntPtr data, IntPtr length);
    protected abstract virtual SKData OnEncode(SKPixmap pixmap);
    public static SKPixelSerializer Create(Func`2<SKPixmap, SKData> onEncode);
    public static SKPixelSerializer Create(Func`3<IntPtr, IntPtr, bool> onUseEncodedData, Func`2<SKPixmap, SKData> onEncode);
}
public class SkiaSharp.SKPixmap : SKObject {
    private static string UnableToCreateInstanceMessage;
    internal SKObject pixelSource;
    public SKImageInfo Info { get; }
    public int Width { get; }
    public int Height { get; }
    public SKSizeI Size { get; }
    public SKRectI Rect { get; }
    public SKColorType ColorType { get; }
    public SKAlphaType AlphaType { get; }
    public SKColorSpace ColorSpace { get; }
    public int BytesPerPixel { get; }
    public int RowBytes { get; }
    public int BytesSize { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported.")]
public SKColorTable ColorTable { get; }
    internal SKPixmap(IntPtr handle, bool owns);
    public SKPixmap(SKImageInfo info, IntPtr addr);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use SKPixmap(SKImageInfo, IntPtr, int) instead.")]
public SKPixmap(SKImageInfo info, IntPtr addr, int rowBytes, SKColorTable ctable);
    public SKPixmap(SKImageInfo info, IntPtr addr, int rowBytes);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    protected virtual void DisposeManaged();
    public void Reset();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The Index8 color type and color table is no longer supported. Use Reset(SKImageInfo, IntPtr, int) instead.")]
public void Reset(SKImageInfo info, IntPtr addr, int rowBytes, SKColorTable ctable);
    public void Reset(SKImageInfo info, IntPtr addr, int rowBytes);
    public SKImageInfo get_Info();
    public int get_Width();
    public int get_Height();
    public SKSizeI get_Size();
    public SKRectI get_Rect();
    public SKColorType get_ColorType();
    public SKAlphaType get_AlphaType();
    public SKColorSpace get_ColorSpace();
    public int get_BytesPerPixel();
    public int get_RowBytes();
    public int get_BytesSize();
    public IntPtr GetPixels();
    public IntPtr GetPixels(int x, int y);
    public ReadOnlySpan`1<byte> GetPixelSpan();
    public Span`1<T> GetPixelSpan();
    public SKColor GetPixelColor(int x, int y);
    public SKColorTable get_ColorTable();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ScalePixels(SKPixmap, SKFilterQuality) instead.")]
public static bool Resize(SKPixmap dst, SKPixmap src, SKBitmapResizeMethod method);
    public bool ScalePixels(SKPixmap destination, SKFilterQuality quality);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ReadPixels(SKImageInfo, IntPtr, int, int, int) instead.")]
public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY, SKTransferFunctionBehavior behavior);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes);
    public bool ReadPixels(SKPixmap pixmap, int srcX, int srcY);
    public bool ReadPixels(SKPixmap pixmap);
    public SKData Encode(SKEncodedImageFormat encoder, int quality);
    public bool Encode(Stream dst, SKEncodedImageFormat encoder, int quality);
    public bool Encode(SKWStream dst, SKEncodedImageFormat encoder, int quality);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Encode(SKWStream, SKEncodedImageFormat, int) instead.")]
public static bool Encode(SKWStream dst, SKBitmap src, SKEncodedImageFormat format, int quality);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Encode(SKWStream, SKEncodedImageFormat, int) instead.")]
public static bool Encode(SKWStream dst, SKPixmap src, SKEncodedImageFormat encoder, int quality);
    public SKData Encode(SKWebpEncoderOptions options);
    public bool Encode(Stream dst, SKWebpEncoderOptions options);
    public bool Encode(SKWStream dst, SKWebpEncoderOptions options);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Encode(SKWStream, SKWebpEncoderOptions) instead.")]
public static bool Encode(SKWStream dst, SKPixmap src, SKWebpEncoderOptions options);
    public SKData Encode(SKJpegEncoderOptions options);
    public bool Encode(Stream dst, SKJpegEncoderOptions options);
    public bool Encode(SKWStream dst, SKJpegEncoderOptions options);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Encode(SKWStream, SKJpegEncoderOptions) instead.")]
public static bool Encode(SKWStream dst, SKPixmap src, SKJpegEncoderOptions options);
    public SKData Encode(SKPngEncoderOptions options);
    public bool Encode(Stream dst, SKPngEncoderOptions options);
    public bool Encode(SKWStream dst, SKPngEncoderOptions options);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Encode(SKWStream, SKPngEncoderOptions) instead.")]
public static bool Encode(SKWStream dst, SKPixmap src, SKPngEncoderOptions options);
    public SKPixmap ExtractSubset(SKRectI subset);
    public bool ExtractSubset(SKPixmap result, SKRectI subset);
    public bool Erase(SKColor color);
    public bool Erase(SKColor color, SKRectI subset);
    public bool Erase(SKColorF color);
    public bool Erase(SKColorF color, SKRectI subset);
    public bool Erase(SKColorF color, SKColorSpace colorspace, SKRectI subset);
    public SKPixmap WithColorType(SKColorType newColorType);
    public SKPixmap WithColorSpace(SKColorSpace newColorSpace);
    public SKPixmap WithAlphaType(SKAlphaType newAlphaType);
}
[IsReadOnlyAttribute]
public class SkiaSharp.SKPMColor : ValueType {
    private UInt32 color;
    public byte Alpha { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public SKPMColor(UInt32 value);
    public byte get_Alpha();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public static SKPMColor PreMultiply(SKColor color);
    public static SKPMColor[] PreMultiply(SKColor[] colors);
    public static SKColor UnPreMultiply(SKPMColor pmcolor);
    public static SKColor[] UnPreMultiply(SKPMColor[] pmcolors);
    public static SKPMColor op_Explicit(SKColor color);
    public static SKColor op_Explicit(SKPMColor color);
    public virtual string ToString();
    public sealed virtual bool Equals(SKPMColor obj);
    public virtual bool Equals(object other);
    public static bool op_Equality(SKPMColor left, SKPMColor right);
    public static bool op_Inequality(SKPMColor left, SKPMColor right);
    public virtual int GetHashCode();
    public static SKPMColor op_Implicit(UInt32 color);
    public static UInt32 op_Explicit(SKPMColor color);
}
[FlagsAttribute]
public enum SkiaSharp.SKPngEncoderFilterFlags : Enum {
    public int value__;
    public static SKPngEncoderFilterFlags NoFilters;
    public static SKPngEncoderFilterFlags None;
    public static SKPngEncoderFilterFlags Sub;
    public static SKPngEncoderFilterFlags Up;
    public static SKPngEncoderFilterFlags Avg;
    public static SKPngEncoderFilterFlags Paeth;
    public static SKPngEncoderFilterFlags AllFilters;
}
public class SkiaSharp.SKPngEncoderOptions : ValueType {
    public static SKPngEncoderOptions Default;
    private SKPngEncoderFilterFlags fFilterFlags;
    private int fZLibLevel;
    private Void* fComments;
    public SKPngEncoderFilterFlags FilterFlags { get; public set; }
    public int ZLibLevel { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKTransferFunctionBehavior UnpremulBehavior { get; public set; }
    private static SKPngEncoderOptions();
    public SKPngEncoderOptions(SKPngEncoderFilterFlags filterFlags, int zLibLevel);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Using SKPngEncoderOptions(SKPngEncoderFilterFlags, int) instead.")]
public SKPngEncoderOptions(SKPngEncoderFilterFlags filterFlags, int zLibLevel, SKTransferFunctionBehavior unpremulBehavior);
    [IsReadOnlyAttribute]
public SKPngEncoderFilterFlags get_FilterFlags();
    public void set_FilterFlags(SKPngEncoderFilterFlags value);
    [IsReadOnlyAttribute]
public int get_ZLibLevel();
    public void set_ZLibLevel(int value);
    [IsReadOnlyAttribute]
public SKTransferFunctionBehavior get_UnpremulBehavior();
    public void set_UnpremulBehavior(SKTransferFunctionBehavior value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKPngEncoderOptions obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKPngEncoderOptions left, SKPngEncoderOptions right);
    public static bool op_Inequality(SKPngEncoderOptions left, SKPngEncoderOptions right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKPoint : ValueType {
    public static SKPoint Empty;
    private float x;
    private float y;
    public bool IsEmpty { get; }
    public float Length { get; }
    public float LengthSquared { get; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public SKPoint(float x, float y);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public float get_Length();
    [IsReadOnlyAttribute]
public float get_LengthSquared();
    public void Offset(SKPoint p);
    public void Offset(float dx, float dy);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKPoint Normalize(SKPoint point);
    public static float Distance(SKPoint point, SKPoint other);
    public static float DistanceSquared(SKPoint point, SKPoint other);
    public static SKPoint Reflect(SKPoint point, SKPoint normal);
    public static SKPoint Add(SKPoint pt, SKSizeI sz);
    public static SKPoint Add(SKPoint pt, SKSize sz);
    public static SKPoint Add(SKPoint pt, SKPointI sz);
    public static SKPoint Add(SKPoint pt, SKPoint sz);
    public static SKPoint Subtract(SKPoint pt, SKSizeI sz);
    public static SKPoint Subtract(SKPoint pt, SKSize sz);
    public static SKPoint Subtract(SKPoint pt, SKPointI sz);
    public static SKPoint Subtract(SKPoint pt, SKPoint sz);
    public static SKPoint op_Addition(SKPoint pt, SKSizeI sz);
    public static SKPoint op_Addition(SKPoint pt, SKSize sz);
    public static SKPoint op_Addition(SKPoint pt, SKPointI sz);
    public static SKPoint op_Addition(SKPoint pt, SKPoint sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKSizeI sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKSize sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKPointI sz);
    public static SKPoint op_Subtraction(SKPoint pt, SKPoint sz);
    [IsReadOnlyAttribute]
public float get_X();
    public void set_X(float value);
    [IsReadOnlyAttribute]
public float get_Y();
    public void set_Y(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKPoint obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKPoint left, SKPoint right);
    public static bool op_Inequality(SKPoint left, SKPoint right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKPoint3 : ValueType {
    public static SKPoint3 Empty;
    private float x;
    private float y;
    private float z;
    public bool IsEmpty { get; }
    public float X { get; public set; }
    public float Y { get; public set; }
    public float Z { get; public set; }
    public SKPoint3(float x, float y, float z);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKPoint3 Add(SKPoint3 pt, SKPoint3 sz);
    public static SKPoint3 Subtract(SKPoint3 pt, SKPoint3 sz);
    public static SKPoint3 op_Addition(SKPoint3 pt, SKPoint3 sz);
    public static SKPoint3 op_Subtraction(SKPoint3 pt, SKPoint3 sz);
    [IsReadOnlyAttribute]
public float get_X();
    public void set_X(float value);
    [IsReadOnlyAttribute]
public float get_Y();
    public void set_Y(float value);
    [IsReadOnlyAttribute]
public float get_Z();
    public void set_Z(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKPoint3 obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKPoint3 left, SKPoint3 right);
    public static bool op_Inequality(SKPoint3 left, SKPoint3 right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKPointI : ValueType {
    public static SKPointI Empty;
    private int x;
    private int y;
    public bool IsEmpty { get; }
    public int Length { get; }
    public int LengthSquared { get; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public SKPointI(SKSizeI sz);
    public SKPointI(int x, int y);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public int get_Length();
    [IsReadOnlyAttribute]
public int get_LengthSquared();
    public void Offset(SKPointI p);
    public void Offset(int dx, int dy);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKPointI Normalize(SKPointI point);
    public static float Distance(SKPointI point, SKPointI other);
    public static float DistanceSquared(SKPointI point, SKPointI other);
    public static SKPointI Reflect(SKPointI point, SKPointI normal);
    public static SKPointI Ceiling(SKPoint value);
    public static SKPointI Round(SKPoint value);
    public static SKPointI Truncate(SKPoint value);
    public static SKPointI Add(SKPointI pt, SKSizeI sz);
    public static SKPointI Add(SKPointI pt, SKPointI sz);
    public static SKPointI Subtract(SKPointI pt, SKSizeI sz);
    public static SKPointI Subtract(SKPointI pt, SKPointI sz);
    public static SKPointI op_Addition(SKPointI pt, SKSizeI sz);
    public static SKPointI op_Addition(SKPointI pt, SKPointI sz);
    public static SKPointI op_Subtraction(SKPointI pt, SKSizeI sz);
    public static SKPointI op_Subtraction(SKPointI pt, SKPointI sz);
    public static SKSizeI op_Explicit(SKPointI p);
    public static SKPoint op_Implicit(SKPointI p);
    [IsReadOnlyAttribute]
public int get_X();
    public void set_X(int value);
    [IsReadOnlyAttribute]
public int get_Y();
    public void set_Y(int value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKPointI obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKPointI left, SKPointI right);
    public static bool op_Inequality(SKPointI left, SKPointI right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public enum SkiaSharp.SKPointMode : Enum {
    public int value__;
    public static SKPointMode Points;
    public static SKPointMode Lines;
    public static SKPointMode Polygon;
}
public class SkiaSharp.SKPositionedRunBuffer : SKRunBuffer {
    internal SKPositionedRunBuffer(SKRunBufferInternal buffer, int count);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal SKPositionedRunBuffer(SKRunBufferInternal buffer, int count, int textSize);
    public Span`1<SKPoint> GetPositionSpan();
    public void SetPositions(ReadOnlySpan`1<SKPoint> positions);
}
public class SkiaSharp.SKRect : ValueType {
    public static SKRect Empty;
    private float left;
    private float top;
    private float right;
    private float bottom;
    public float MidX { get; }
    public float MidY { get; }
    public float Width { get; }
    public float Height { get; }
    public bool IsEmpty { get; }
    public SKSize Size { get; public set; }
    public SKPoint Location { get; public set; }
    public SKRect Standardized { get; }
    public float Left { get; public set; }
    public float Top { get; public set; }
    public float Right { get; public set; }
    public float Bottom { get; public set; }
    public SKRect(float left, float top, float right, float bottom);
    [IsReadOnlyAttribute]
public float get_MidX();
    [IsReadOnlyAttribute]
public float get_MidY();
    [IsReadOnlyAttribute]
public float get_Width();
    [IsReadOnlyAttribute]
public float get_Height();
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public SKSize get_Size();
    public void set_Size(SKSize value);
    [IsReadOnlyAttribute]
public SKPoint get_Location();
    public void set_Location(SKPoint value);
    [IsReadOnlyAttribute]
public SKRect get_Standardized();
    [IsReadOnlyAttribute]
public SKRect AspectFit(SKSize size);
    [IsReadOnlyAttribute]
public SKRect AspectFill(SKSize size);
    [IsReadOnlyAttribute]
private SKRect AspectResize(SKSize size, bool fit);
    public static SKRect Inflate(SKRect rect, float x, float y);
    public void Inflate(SKSize size);
    public void Inflate(float x, float y);
    public static SKRect Intersect(SKRect a, SKRect b);
    public void Intersect(SKRect rect);
    public static SKRect Union(SKRect a, SKRect b);
    public void Union(SKRect rect);
    public static SKRect op_Implicit(SKRectI r);
    [IsReadOnlyAttribute]
public bool Contains(float x, float y);
    [IsReadOnlyAttribute]
public bool Contains(SKPoint pt);
    [IsReadOnlyAttribute]
public bool Contains(SKRect rect);
    [IsReadOnlyAttribute]
public bool IntersectsWith(SKRect rect);
    [IsReadOnlyAttribute]
public bool IntersectsWithInclusive(SKRect rect);
    public void Offset(float x, float y);
    public void Offset(SKPoint pos);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKRect Create(SKPoint location, SKSize size);
    public static SKRect Create(SKSize size);
    public static SKRect Create(float width, float height);
    public static SKRect Create(float x, float y, float width, float height);
    [IsReadOnlyAttribute]
public float get_Left();
    public void set_Left(float value);
    [IsReadOnlyAttribute]
public float get_Top();
    public void set_Top(float value);
    [IsReadOnlyAttribute]
public float get_Right();
    public void set_Right(float value);
    [IsReadOnlyAttribute]
public float get_Bottom();
    public void set_Bottom(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKRect obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKRect left, SKRect right);
    public static bool op_Inequality(SKRect left, SKRect right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKRectI : ValueType {
    public static SKRectI Empty;
    private int left;
    private int top;
    private int right;
    private int bottom;
    public int MidX { get; }
    public int MidY { get; }
    public int Width { get; }
    public int Height { get; }
    public bool IsEmpty { get; }
    public SKSizeI Size { get; public set; }
    public SKPointI Location { get; public set; }
    public SKRectI Standardized { get; }
    public int Left { get; public set; }
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Bottom { get; public set; }
    public SKRectI(int left, int top, int right, int bottom);
    [IsReadOnlyAttribute]
public int get_MidX();
    [IsReadOnlyAttribute]
public int get_MidY();
    [IsReadOnlyAttribute]
public int get_Width();
    [IsReadOnlyAttribute]
public int get_Height();
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public SKSizeI get_Size();
    public void set_Size(SKSizeI value);
    [IsReadOnlyAttribute]
public SKPointI get_Location();
    public void set_Location(SKPointI value);
    [IsReadOnlyAttribute]
public SKRectI get_Standardized();
    [IsReadOnlyAttribute]
public SKRectI AspectFit(SKSizeI size);
    [IsReadOnlyAttribute]
public SKRectI AspectFill(SKSizeI size);
    public static SKRectI Ceiling(SKRect value);
    public static SKRectI Ceiling(SKRect value, bool outwards);
    public static SKRectI Inflate(SKRectI rect, int x, int y);
    public void Inflate(SKSizeI size);
    public void Inflate(int width, int height);
    public static SKRectI Intersect(SKRectI a, SKRectI b);
    public void Intersect(SKRectI rect);
    public static SKRectI Round(SKRect value);
    public static SKRectI Floor(SKRect value);
    public static SKRectI Floor(SKRect value, bool inwards);
    public static SKRectI Truncate(SKRect value);
    public static SKRectI Union(SKRectI a, SKRectI b);
    public void Union(SKRectI rect);
    [IsReadOnlyAttribute]
public bool Contains(int x, int y);
    [IsReadOnlyAttribute]
public bool Contains(SKPointI pt);
    [IsReadOnlyAttribute]
public bool Contains(SKRectI rect);
    [IsReadOnlyAttribute]
public bool IntersectsWith(SKRectI rect);
    [IsReadOnlyAttribute]
public bool IntersectsWithInclusive(SKRectI rect);
    public void Offset(int x, int y);
    public void Offset(SKPointI pos);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKRectI Create(SKSizeI size);
    public static SKRectI Create(SKPointI location, SKSizeI size);
    public static SKRectI Create(int width, int height);
    public static SKRectI Create(int x, int y, int width, int height);
    [IsReadOnlyAttribute]
public int get_Left();
    public void set_Left(int value);
    [IsReadOnlyAttribute]
public int get_Top();
    public void set_Top(int value);
    [IsReadOnlyAttribute]
public int get_Right();
    public void set_Right(int value);
    [IsReadOnlyAttribute]
public int get_Bottom();
    public void set_Bottom(int value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKRectI obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKRectI left, SKRectI right);
    public static bool op_Inequality(SKRectI left, SKRectI right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKRegion : SKObject {
    public bool IsEmpty { get; }
    public bool IsRect { get; }
    public bool IsComplex { get; }
    public SKRectI Bounds { get; }
    internal SKRegion(IntPtr handle, bool owns);
    public SKRegion(SKRegion region);
    public SKRegion(SKRectI rect);
    public SKRegion(SKPath path);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public bool get_IsEmpty();
    public bool get_IsRect();
    public bool get_IsComplex();
    public SKRectI get_Bounds();
    public SKPath GetBoundaryPath();
    public bool Contains(SKPath path);
    public bool Contains(SKRegion src);
    public bool Contains(SKPointI xy);
    public bool Contains(int x, int y);
    public bool Contains(SKRectI rect);
    public bool QuickContains(SKRectI rect);
    public bool QuickReject(SKRectI rect);
    public bool QuickReject(SKRegion region);
    public bool QuickReject(SKPath path);
    public bool Intersects(SKPath path);
    public bool Intersects(SKRegion region);
    public bool Intersects(SKRectI rect);
    public void SetEmpty();
    public bool SetRegion(SKRegion region);
    public bool SetRect(SKRectI rect);
    public bool SetRects(SKRectI[] rects);
    public bool SetPath(SKPath path, SKRegion clip);
    public bool SetPath(SKPath path);
    public void Translate(int x, int y);
    public bool Op(SKRectI rect, SKRegionOperation op);
    public bool Op(int left, int top, int right, int bottom, SKRegionOperation op);
    public bool Op(SKRegion region, SKRegionOperation op);
    public bool Op(SKPath path, SKRegionOperation op);
    public RectIterator CreateRectIterator();
    public ClipIterator CreateClipIterator(SKRectI clip);
    public SpanIterator CreateSpanIterator(int y, int left, int right);
}
public enum SkiaSharp.SKRegionOperation : Enum {
    public int value__;
    public static SKRegionOperation Difference;
    public static SKRegionOperation Intersect;
    public static SKRegionOperation Union;
    public static SKRegionOperation XOR;
    public static SKRegionOperation ReverseDifference;
    public static SKRegionOperation Replace;
}
public class SkiaSharp.SKRotationScaleMatrix : ValueType {
    private float fSCos;
    private float fSSin;
    private float fTX;
    private float fTY;
    public static SKRotationScaleMatrix Empty;
    public static SKRotationScaleMatrix Identity;
    public float SCos { get; public set; }
    public float SSin { get; public set; }
    public float TX { get; public set; }
    public float TY { get; public set; }
    public SKRotationScaleMatrix(float scos, float ssin, float tx, float ty);
    private static SKRotationScaleMatrix();
    [IsReadOnlyAttribute]
public float get_SCos();
    public void set_SCos(float value);
    [IsReadOnlyAttribute]
public float get_SSin();
    public void set_SSin(float value);
    [IsReadOnlyAttribute]
public float get_TX();
    public void set_TX(float value);
    [IsReadOnlyAttribute]
public float get_TY();
    public void set_TY(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKRotationScaleMatrix obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKRotationScaleMatrix left, SKRotationScaleMatrix right);
    public static bool op_Inequality(SKRotationScaleMatrix left, SKRotationScaleMatrix right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public SKMatrix ToMatrix();
    public static SKRotationScaleMatrix CreateDegrees(float scale, float degrees, float tx, float ty, float anchorX, float anchorY);
    public static SKRotationScaleMatrix Create(float scale, float radians, float tx, float ty, float anchorX, float anchorY);
    public static SKRotationScaleMatrix CreateIdentity();
    public static SKRotationScaleMatrix CreateTranslation(float x, float y);
    public static SKRotationScaleMatrix CreateScale(float s);
    public static SKRotationScaleMatrix CreateRotation(float radians, float anchorX, float anchorY);
    public static SKRotationScaleMatrix CreateRotationDegrees(float degrees, float anchorX, float anchorY);
}
public class SkiaSharp.SKRotationScaleRunBuffer : SKRunBuffer {
    internal SKRotationScaleRunBuffer(SKRunBufferInternal buffer, int count);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal SKRotationScaleRunBuffer(SKRunBufferInternal buffer, int count, int textSize);
    public Span`1<SKRotationScaleMatrix> GetRotationScaleSpan();
    public void SetRotationScale(ReadOnlySpan`1<SKRotationScaleMatrix> positions);
}
public class SkiaSharp.SKRoundRect : SKObject {
    public SKRect Rect { get; }
    public SKPoint[] Radii { get; }
    public SKRoundRectType Type { get; }
    public float Width { get; }
    public float Height { get; }
    public bool IsValid { get; }
    public bool AllCornersCircular { get; }
    internal SKRoundRect(IntPtr handle, bool owns);
    public SKRoundRect(SKRect rect);
    public SKRoundRect(SKRect rect, float radius);
    public SKRoundRect(SKRect rect, float xRadius, float yRadius);
    public SKRoundRect(SKRoundRect rrect);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKRect get_Rect();
    public SKPoint[] get_Radii();
    public SKRoundRectType get_Type();
    public float get_Width();
    public float get_Height();
    public bool get_IsValid();
    public bool get_AllCornersCircular();
    public bool CheckAllCornersCircular(float tolerance);
    public void SetEmpty();
    public void SetRect(SKRect rect);
    public void SetRect(SKRect rect, float xRadius, float yRadius);
    public void SetOval(SKRect rect);
    public void SetNinePatch(SKRect rect, float leftRadius, float topRadius, float rightRadius, float bottomRadius);
    public void SetRectRadii(SKRect rect, SKPoint[] radii);
    public bool Contains(SKRect rect);
    public SKPoint GetRadii(SKRoundRectCorner corner);
    public void Deflate(SKSize size);
    public void Deflate(float dx, float dy);
    public void Inflate(SKSize size);
    public void Inflate(float dx, float dy);
    public void Offset(SKPoint pos);
    public void Offset(float dx, float dy);
    public bool TryTransform(SKMatrix matrix, SKRoundRect& transformed);
    public SKRoundRect Transform(SKMatrix matrix);
}
public enum SkiaSharp.SKRoundRectCorner : Enum {
    public int value__;
    public static SKRoundRectCorner UpperLeft;
    public static SKRoundRectCorner UpperRight;
    public static SKRoundRectCorner LowerRight;
    public static SKRoundRectCorner LowerLeft;
}
public enum SkiaSharp.SKRoundRectType : Enum {
    public int value__;
    public static SKRoundRectType Empty;
    public static SKRoundRectType Rect;
    public static SKRoundRectType Oval;
    public static SKRoundRectType Simple;
    public static SKRoundRectType NinePatch;
    public static SKRoundRectType Complex;
}
public class SkiaSharp.SKRunBuffer : object {
    internal SKRunBufferInternal internalBuffer;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TextSize>k__BackingField;
    public int Size { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public int TextSize { get; }
    internal SKRunBuffer(SKRunBufferInternal buffer, int size);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal SKRunBuffer(SKRunBufferInternal buffer, int size, int textSize);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public int get_TextSize();
    public Span`1<ushort> GetGlyphSpan();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public Span`1<byte> GetTextSpan();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public Span`1<UInt32> GetClusterSpan();
    public void SetGlyphs(ReadOnlySpan`1<ushort> glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public void SetText(ReadOnlySpan`1<byte> text);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public void SetClusters(ReadOnlySpan`1<UInt32> clusters);
}
internal class SkiaSharp.SKRunBufferInternal : ValueType {
    public Void* glyphs;
    public Void* pos;
    public Void* utf8text;
    public Void* clusters;
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKRunBufferInternal obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKRunBufferInternal left, SKRunBufferInternal right);
    public static bool op_Inequality(SKRunBufferInternal left, SKRunBufferInternal right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKRuntimeEffect : SKObject {
    private String[] children;
    private String[] uniforms;
    public int UniformSize { get; }
    public IReadOnlyList`1<string> Children { get; }
    public IReadOnlyList`1<string> Uniforms { get; }
    internal SKRuntimeEffect(IntPtr handle, bool owns);
    public static SKRuntimeEffect Create(string sksl, String& errors);
    public int get_UniformSize();
    public IReadOnlyList`1<string> get_Children();
    public IReadOnlyList`1<string> get_Uniforms();
    [IteratorStateMachineAttribute("SkiaSharp.SKRuntimeEffect/<GetChildrenNames>d__10")]
private IEnumerable`1<string> GetChildrenNames();
    [IteratorStateMachineAttribute("SkiaSharp.SKRuntimeEffect/<GetUniformNames>d__11")]
private IEnumerable`1<string> GetUniformNames();
    public SKShader ToShader(bool isOpaque);
    public SKShader ToShader(bool isOpaque, SKRuntimeEffectUniforms uniforms);
    public SKShader ToShader(bool isOpaque, SKRuntimeEffectUniforms uniforms, SKRuntimeEffectChildren children);
    public SKShader ToShader(bool isOpaque, SKRuntimeEffectUniforms uniforms, SKRuntimeEffectChildren children, SKMatrix localMatrix);
    private SKShader ToShader(bool isOpaque, SKData uniforms, SKShader[] children, SKMatrix* localMatrix);
    public SKColorFilter ToColorFilter();
    public SKColorFilter ToColorFilter(SKRuntimeEffectUniforms uniforms);
    private SKColorFilter ToColorFilter(SKData uniforms);
    public SKColorFilter ToColorFilter(SKRuntimeEffectUniforms uniforms, SKRuntimeEffectChildren children);
    private SKColorFilter ToColorFilter(SKData uniforms, SKShader[] children);
    internal static SKRuntimeEffect GetObject(IntPtr handle);
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKRuntimeEffectChildren : object {
    private String[] names;
    private SKShader[] children;
    public IReadOnlyList`1<string> Names { get; }
    public int Count { get; }
    unknown SKShader Item {public set; }
    public SKRuntimeEffectChildren(SKRuntimeEffect effect);
    public IReadOnlyList`1<string> get_Names();
    public int get_Count();
    public void Reset();
    public bool Contains(string name);
    public void set_Item(string name, SKShader value);
    public void Add(string name, SKShader value);
    public SKShader[] ToArray();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class SkiaSharp.SKRuntimeEffectUniform : ValueType {
    private DataType type;
    private int size;
    private float floatValue;
    private ReadOnlySpan`1<float> floatArray;
    public static SKRuntimeEffectUniform Empty { get; }
    public bool IsEmpty { get; }
    public int Size { get; }
    private SKRuntimeEffectUniform(DataType type, int size, float floatValue, ReadOnlySpan`1<float> floatArray);
    public static SKRuntimeEffectUniform get_Empty();
    public bool get_IsEmpty();
    public int get_Size();
    public static SKRuntimeEffectUniform op_Implicit(float value);
    public static SKRuntimeEffectUniform op_Implicit(Single[] value);
    public static SKRuntimeEffectUniform op_Implicit(Span`1<float> value);
    public static SKRuntimeEffectUniform op_Implicit(ReadOnlySpan`1<float> value);
    public static SKRuntimeEffectUniform op_Implicit(Single[][] value);
    public static SKRuntimeEffectUniform op_Implicit(SKMatrix value);
    public void WriteTo(Span`1<byte> data);
}
[DefaultMemberAttribute("Item")]
public class SkiaSharp.SKRuntimeEffectUniforms : object {
    private String[] names;
    private Dictionary`2<string, Variable> uniforms;
    private SKData data;
    public IReadOnlyList`1<string> Names { get; }
    internal IReadOnlyList`1<Variable> Variables { get; }
    public int Count { get; }
    unknown SKRuntimeEffectUniform Item {public set; }
    public SKRuntimeEffectUniforms(SKRuntimeEffect effect);
    public IReadOnlyList`1<string> get_Names();
    internal IReadOnlyList`1<Variable> get_Variables();
    public int get_Count();
    public void Reset();
    public bool Contains(string name);
    public void set_Item(string name, SKRuntimeEffectUniform value);
    public void Add(string name, SKRuntimeEffectUniform value);
    public SKData ToData();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
}
public class SkiaSharp.SKShader : SKObject {
    internal SKShader(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    public SKShader WithColorFilter(SKColorFilter filter);
    public SKShader WithLocalMatrix(SKMatrix localMatrix);
    public static SKShader CreateEmpty();
    public static SKShader CreateColor(SKColor color);
    public static SKShader CreateColor(SKColorF color, SKColorSpace colorspace);
    public static SKShader CreateBitmap(SKBitmap src);
    public static SKShader CreateBitmap(SKBitmap src, SKShaderTileMode tmx, SKShaderTileMode tmy);
    public static SKShader CreateBitmap(SKBitmap src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix);
    public static SKShader CreateImage(SKImage src);
    public static SKShader CreateImage(SKImage src, SKShaderTileMode tmx, SKShaderTileMode tmy);
    public static SKShader CreateImage(SKImage src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix);
    public static SKShader CreatePicture(SKPicture src);
    public static SKShader CreatePicture(SKPicture src, SKShaderTileMode tmx, SKShaderTileMode tmy);
    public static SKShader CreatePicture(SKPicture src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKRect tile);
    public static SKShader CreatePicture(SKPicture src, SKShaderTileMode tmx, SKShaderTileMode tmy, SKMatrix localMatrix, SKRect tile);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColor[] colors, SKShaderTileMode mode);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColorF[] colors, SKColorSpace colorspace, SKShaderTileMode mode);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateLinearGradient(SKPoint start, SKPoint end, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColor[] colors, SKShaderTileMode mode);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColorF[] colors, SKColorSpace colorspace, SKShaderTileMode mode);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateRadialGradient(SKPoint center, float radius, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos, SKMatrix localMatrix);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, SKShaderTileMode tileMode, float startAngle, float endAngle);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos, SKShaderTileMode tileMode, float startAngle, float endAngle);
    public static SKShader CreateSweepGradient(SKPoint center, SKColor[] colors, Single[] colorPos, SKShaderTileMode tileMode, float startAngle, float endAngle, SKMatrix localMatrix);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKMatrix localMatrix);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace, SKShaderTileMode tileMode, float startAngle, float endAngle);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode tileMode, float startAngle, float endAngle);
    public static SKShader CreateSweepGradient(SKPoint center, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode tileMode, float startAngle, float endAngle, SKMatrix localMatrix);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColor[] colors, SKShaderTileMode mode);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColor[] colors, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColorF[] colors, SKColorSpace colorspace, SKShaderTileMode mode);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode);
    public static SKShader CreateTwoPointConicalGradient(SKPoint start, float startRadius, SKPoint end, float endRadius, SKColorF[] colors, SKColorSpace colorspace, Single[] colorPos, SKShaderTileMode mode, SKMatrix localMatrix);
    public static SKShader CreatePerlinNoiseFractalNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed);
    public static SKShader CreatePerlinNoiseFractalNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI tileSize);
    public static SKShader CreatePerlinNoiseFractalNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKSizeI tileSize);
    public static SKShader CreatePerlinNoiseImprovedNoise(float baseFrequencyX, float baseFrequencyY, int numOctaves, float z);
    public static SKShader CreatePerlinNoiseTurbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed);
    public static SKShader CreatePerlinNoiseTurbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKPointI tileSize);
    public static SKShader CreatePerlinNoiseTurbulence(float baseFrequencyX, float baseFrequencyY, int numOctaves, float seed, SKSizeI tileSize);
    public static SKShader CreateCompose(SKShader shaderA, SKShader shaderB);
    public static SKShader CreateCompose(SKShader shaderA, SKShader shaderB, SKBlendMode mode);
    public static SKShader CreateLerp(float weight, SKShader dst, SKShader src);
    public static SKShader CreateColorFilter(SKShader shader, SKColorFilter filter);
    public static SKShader CreateLocalMatrix(SKShader shader, SKMatrix localMatrix);
    internal static SKShader GetObject(IntPtr handle);
}
public enum SkiaSharp.SKShaderTileMode : Enum {
    public int value__;
    public static SKShaderTileMode Clamp;
    public static SKShaderTileMode Repeat;
    public static SKShaderTileMode Mirror;
    public static SKShaderTileMode Decal;
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal class SkiaSharp.SKSimplePixelSerializer : SKPixelSerializer {
    private Func`3<IntPtr, IntPtr, bool> onUseEncodedData;
    private Func`2<SKPixmap, SKData> onEncode;
    public SKSimplePixelSerializer(Func`3<IntPtr, IntPtr, bool> onUseEncodedData, Func`2<SKPixmap, SKData> onEncode);
    protected virtual SKData OnEncode(SKPixmap pixmap);
    protected virtual bool OnUseEncodedData(IntPtr data, IntPtr length);
}
public class SkiaSharp.SKSize : ValueType {
    public static SKSize Empty;
    private float w;
    private float h;
    public bool IsEmpty { get; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public SKSize(float width, float height);
    public SKSize(SKPoint pt);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public SKPoint ToPoint();
    [IsReadOnlyAttribute]
public SKSizeI ToSizeI();
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKSize Add(SKSize sz1, SKSize sz2);
    public static SKSize Subtract(SKSize sz1, SKSize sz2);
    public static SKSize op_Addition(SKSize sz1, SKSize sz2);
    public static SKSize op_Subtraction(SKSize sz1, SKSize sz2);
    public static SKPoint op_Explicit(SKSize size);
    public static SKSize op_Implicit(SKSizeI size);
    [IsReadOnlyAttribute]
public float get_Width();
    public void set_Width(float value);
    [IsReadOnlyAttribute]
public float get_Height();
    public void set_Height(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKSize obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKSize left, SKSize right);
    public static bool op_Inequality(SKSize left, SKSize right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKSizeI : ValueType {
    public static SKSizeI Empty;
    private int w;
    private int h;
    public bool IsEmpty { get; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public SKSizeI(int width, int height);
    public SKSizeI(SKPointI pt);
    [IsReadOnlyAttribute]
public bool get_IsEmpty();
    [IsReadOnlyAttribute]
public SKPointI ToPointI();
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static SKSizeI Add(SKSizeI sz1, SKSizeI sz2);
    public static SKSizeI Subtract(SKSizeI sz1, SKSizeI sz2);
    public static SKSizeI op_Addition(SKSizeI sz1, SKSizeI sz2);
    public static SKSizeI op_Subtraction(SKSizeI sz1, SKSizeI sz2);
    public static SKPointI op_Explicit(SKSizeI size);
    [IsReadOnlyAttribute]
public int get_Width();
    public void set_Width(int value);
    [IsReadOnlyAttribute]
public int get_Height();
    public void set_Height(int value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKSizeI obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKSizeI left, SKSizeI right);
    public static bool op_Inequality(SKSizeI left, SKSizeI right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public abstract class SkiaSharp.SKStream : SKObject {
    public bool IsAtEnd { get; }
    public bool HasPosition { get; }
    public int Position { get; public set; }
    public bool HasLength { get; }
    public int Length { get; }
    internal SKStream(IntPtr handle, bool owns);
    public bool get_IsAtEnd();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public bool ReadBool();
    public bool ReadSByte(SByte& buffer);
    public bool ReadInt16(Int16& buffer);
    public bool ReadInt32(Int32& buffer);
    public bool ReadByte(Byte& buffer);
    public bool ReadUInt16(UInt16& buffer);
    public bool ReadUInt32(UInt32& buffer);
    public bool ReadBool(Boolean& buffer);
    public int Read(Byte[] buffer, int size);
    public int Read(IntPtr buffer, int size);
    public int Peek(IntPtr buffer, int size);
    public int Skip(int size);
    public bool Rewind();
    public bool Seek(int position);
    public bool Move(long offset);
    public bool Move(int offset);
    public IntPtr GetMemoryBase();
    internal SKStream Fork();
    internal SKStream Duplicate();
    public bool get_HasPosition();
    public int get_Position();
    public void set_Position(int value);
    public bool get_HasLength();
    public int get_Length();
    internal static SKStream GetObject(IntPtr handle);
}
public abstract class SkiaSharp.SKStreamAsset : SKStreamSeekable {
    internal SKStreamAsset(IntPtr handle, bool owns);
    internal static SKStreamAsset GetObject(IntPtr handle);
}
internal class SkiaSharp.SKStreamAssetImplementation : SKStreamAsset {
    internal SKStreamAssetImplementation(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
}
internal class SkiaSharp.SKStreamImplementation : SKStream {
    internal SKStreamImplementation(IntPtr handle, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
}
public abstract class SkiaSharp.SKStreamMemory : SKStreamAsset {
    internal SKStreamMemory(IntPtr handle, bool owns);
}
public abstract class SkiaSharp.SKStreamRewindable : SKStream {
    internal SKStreamRewindable(IntPtr handle, bool owns);
}
public abstract class SkiaSharp.SKStreamSeekable : SKStreamRewindable {
    internal SKStreamSeekable(IntPtr handle, bool owns);
}
internal class SkiaSharp.SKString : SKObject {
    internal SKString(IntPtr handle, bool owns);
    public SKString(Byte[] src, long length);
    public SKString(Byte[] src);
    public SKString(string str);
    private static IntPtr CreateCopy(Byte[] src, long length);
    public virtual string ToString();
    public static string op_Explicit(SKString skString);
    internal static SKString Create(string str);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    internal static SKString GetObject(IntPtr handle);
}
public enum SkiaSharp.SKStrokeCap : Enum {
    public int value__;
    public static SKStrokeCap Butt;
    public static SKStrokeCap Round;
    public static SKStrokeCap Square;
}
public enum SkiaSharp.SKStrokeJoin : Enum {
    public int value__;
    public static SKStrokeJoin Miter;
    public static SKStrokeJoin Round;
    public static SKStrokeJoin Bevel;
}
public class SkiaSharp.SKSurface : SKObject {
    public SKCanvas Canvas { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SurfaceProperties instead.")]
public SKSurfaceProps SurfaceProps { get; }
    public SKSurfaceProperties SurfaceProperties { get; }
    public GRRecordingContext Context { get; }
    internal SKSurface(IntPtr h, bool owns);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo) instead.")]
public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo, SKSurfaceProperties) instead.")]
public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, SKSurfaceProps props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo, IntPtr, int) instead.")]
public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, IntPtr pixels, int rowBytes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo, IntPtr, int, SKSurfaceProperties) instead.")]
public static SKSurface Create(int width, int height, SKColorType colorType, SKAlphaType alphaType, IntPtr pixels, int rowBytes, SKSurfaceProps props);
    protected virtual void Dispose(bool disposing);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo, SKSurfaceProperties) instead.")]
public static SKSurface Create(SKImageInfo info, SKSurfaceProps props);
    public static SKSurface Create(SKImageInfo info);
    public static SKSurface Create(SKImageInfo info, int rowBytes);
    public static SKSurface Create(SKImageInfo info, SKSurfaceProperties props);
    public static SKSurface Create(SKImageInfo info, int rowBytes, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKPixmap, SKSurfaceProperties) instead.")]
public static SKSurface Create(SKPixmap pixmap, SKSurfaceProps props);
    public static SKSurface Create(SKPixmap pixmap);
    public static SKSurface Create(SKPixmap pixmap, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKImageInfo, IntPtr, rowBytes, SKSurfaceProperties) instead.")]
public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes, SKSurfaceProps props);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes, SKSurfaceReleaseDelegate releaseProc, object context);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, SKSurfaceProperties props);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes, SKSurfaceProperties props);
    public static SKSurface Create(SKImageInfo info, IntPtr pixels, int rowBytes, SKSurfaceReleaseDelegate releaseProc, object context, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendRenderTarget, GRSurfaceOrigin, SKColorType) instead.")]
public static SKSurface Create(GRContext context, GRBackendRenderTargetDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendRenderTarget, GRSurfaceOrigin, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface Create(GRContext context, GRBackendRenderTargetDesc desc, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, SKColorType colorType);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKColorSpace colorspace);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKColorSpace colorspace);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendRenderTarget renderTarget, GRSurfaceOrigin origin, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType) instead.")]
public static SKSurface Create(GRContext context, GRGlBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType) instead.")]
public static SKSurface Create(GRContext context, GRBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface Create(GRContext context, GRGlBackendTextureDesc desc, SKSurfaceProps props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface Create(GRContext context, GRBackendTextureDesc desc, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRGlBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTextureDesc desc);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRGlBackendTextureDesc desc, SKSurfaceProps props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTextureDesc desc, SKSurfaceProps props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, SKColorType) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, SKColorType colorType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKColorSpace) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, SKColorType colorType, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, SKColorType colorType, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, GRBackendTexture, GRSurfaceOrigin, int, SKColorType, SKColorSpace, SKSurfaceProperties) instead.")]
public static SKSurface CreateAsRenderTarget(GRContext context, GRBackendTexture texture, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(GRContext, bool, SKImageInfo, int, SKSurfaceProperties) instead.")]
public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount, SKSurfaceProps props);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount, GRSurfaceOrigin origin);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount, SKSurfaceProperties props);
    public static SKSurface Create(GRContext context, bool budgeted, SKImageInfo info, int sampleCount, GRSurfaceOrigin origin, SKSurfaceProperties props, bool shouldCreateWithMips);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info, int sampleCount);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info, int sampleCount, GRSurfaceOrigin origin);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info, int sampleCount, SKSurfaceProperties props);
    public static SKSurface Create(GRRecordingContext context, bool budgeted, SKImageInfo info, int sampleCount, GRSurfaceOrigin origin, SKSurfaceProperties props, bool shouldCreateWithMips);
    public static SKSurface Create(GRContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRRecordingContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRRecordingContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRRecordingContext context, CAMetalLayer layer, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props, ICAMetalDrawable& drawable);
    public static SKSurface Create(GRRecordingContext context, MTKView view, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType);
    public static SKSurface Create(GRRecordingContext context, MTKView view, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace);
    public static SKSurface Create(GRRecordingContext context, MTKView view, GRSurfaceOrigin origin, int sampleCount, SKColorType colorType, SKColorSpace colorspace, SKSurfaceProperties props);
    public static SKSurface CreateNull(int width, int height);
    public SKCanvas get_Canvas();
    public SKSurfaceProps get_SurfaceProps();
    public SKSurfaceProperties get_SurfaceProperties();
    public GRRecordingContext get_Context();
    public SKImage Snapshot();
    public SKImage Snapshot(SKRectI bounds);
    public void Draw(SKCanvas canvas, float x, float y, SKPaint paint);
    public SKPixmap PeekPixels();
    public bool PeekPixels(SKPixmap pixmap);
    public bool ReadPixels(SKImageInfo dstInfo, IntPtr dstPixels, int dstRowBytes, int srcX, int srcY);
    public void Flush();
    public void Flush(bool submit, bool synchronous);
    internal static SKSurface GetObject(IntPtr handle);
}
public class SkiaSharp.SKSurfaceProperties : SKObject {
    public SKSurfacePropsFlags Flags { get; }
    public SKPixelGeometry PixelGeometry { get; }
    public bool IsUseDeviceIndependentFonts { get; }
    internal SKSurfaceProperties(IntPtr h, bool owns);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKSurfaceProperties(SKSurfaceProps props);
    public SKSurfaceProperties(SKPixelGeometry pixelGeometry);
    public SKSurfaceProperties(UInt32 flags, SKPixelGeometry pixelGeometry);
    public SKSurfaceProperties(SKSurfacePropsFlags flags, SKPixelGeometry pixelGeometry);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKSurfacePropsFlags get_Flags();
    public SKPixelGeometry get_PixelGeometry();
    public bool get_IsUseDeviceIndependentFonts();
    internal static SKSurfaceProperties GetObject(IntPtr handle, bool owns);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKSurfaceProperties instead.")]
public class SkiaSharp.SKSurfaceProps : ValueType {
    [CompilerGeneratedAttribute]
private SKPixelGeometry <PixelGeometry>k__BackingField;
    [CompilerGeneratedAttribute]
private SKSurfacePropsFlags <Flags>k__BackingField;
    public SKPixelGeometry PixelGeometry { get; public set; }
    public SKSurfacePropsFlags Flags { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKPixelGeometry get_PixelGeometry();
    [CompilerGeneratedAttribute]
public void set_PixelGeometry(SKPixelGeometry value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SKSurfacePropsFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SKSurfacePropsFlags value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKSurfaceProps obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKSurfaceProps left, SKSurfaceProps right);
    public static bool op_Inequality(SKSurfaceProps left, SKSurfaceProps right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
[FlagsAttribute]
public enum SkiaSharp.SKSurfacePropsFlags : Enum {
    public int value__;
    public static SKSurfacePropsFlags None;
    public static SKSurfacePropsFlags UseDeviceIndependentFonts;
}
[UnmanagedFunctionPointerAttribute("2")]
internal class SkiaSharp.SKSurfaceRasterReleaseProxyDelegate : MulticastDelegate {
    public SKSurfaceRasterReleaseProxyDelegate(object object, IntPtr method);
    public virtual void Invoke(Void* addr, Void* context);
    public virtual IAsyncResult BeginInvoke(Void* addr, Void* context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKSurfaceReleaseDelegate : MulticastDelegate {
    public SKSurfaceReleaseDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr address, object context);
    public virtual IAsyncResult BeginInvoke(IntPtr address, object context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class SkiaSharp.SKSvgCanvas : object {
    public static SKCanvas Create(SKRect bounds, Stream stream);
    public static SKCanvas Create(SKRect bounds, SKWStream stream);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use Create(SKRect, Stream) instead.")]
public static SKCanvas Create(SKRect bounds, SKXmlWriter writer);
}
public static class SkiaSharp.SKSwizzle : object {
    public static void SwapRedBlue(IntPtr pixels, int count);
    public static void SwapRedBlue(IntPtr dest, IntPtr src, int count);
    public static void SwapRedBlue(Span`1<byte> pixels);
    public static void SwapRedBlue(ReadOnlySpan`1<byte> pixels, int count);
    public static void SwapRedBlue(ReadOnlySpan`1<byte> dest, ReadOnlySpan`1<byte> src, int count);
}
public enum SkiaSharp.SKTextAlign : Enum {
    public int value__;
    public static SKTextAlign Left;
    public static SKTextAlign Center;
    public static SKTextAlign Right;
}
public class SkiaSharp.SKTextBlob : SKObject {
    public SKRect Bounds { get; }
    public UInt32 UniqueId { get; }
    internal SKTextBlob(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.ReferenceNative();
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.UnreferenceNative();
    public SKRect get_Bounds();
    public UInt32 get_UniqueId();
    public static SKTextBlob Create(string text, SKFont font, SKPoint origin);
    public static SKTextBlob Create(ReadOnlySpan`1<char> text, SKFont font, SKPoint origin);
    public static SKTextBlob Create(IntPtr text, int length, SKTextEncoding encoding, SKFont font, SKPoint origin);
    public static SKTextBlob Create(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKFont font, SKPoint origin);
    internal static SKTextBlob Create(Void* text, int length, SKTextEncoding encoding, SKFont font, SKPoint origin);
    public static SKTextBlob CreateHorizontal(string text, SKFont font, ReadOnlySpan`1<float> positions, float y);
    public static SKTextBlob CreateHorizontal(ReadOnlySpan`1<char> text, SKFont font, ReadOnlySpan`1<float> positions, float y);
    public static SKTextBlob CreateHorizontal(IntPtr text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<float> positions, float y);
    public static SKTextBlob CreateHorizontal(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<float> positions, float y);
    internal static SKTextBlob CreateHorizontal(Void* text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<float> positions, float y);
    public static SKTextBlob CreatePositioned(string text, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    public static SKTextBlob CreatePositioned(ReadOnlySpan`1<char> text, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    public static SKTextBlob CreatePositioned(IntPtr text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    public static SKTextBlob CreatePositioned(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    internal static SKTextBlob CreatePositioned(Void* text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    public static SKTextBlob CreateRotationScale(string text, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    public static SKTextBlob CreateRotationScale(ReadOnlySpan`1<char> text, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    public static SKTextBlob CreateRotationScale(IntPtr text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    public static SKTextBlob CreateRotationScale(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    internal static SKTextBlob CreateRotationScale(Void* text, int length, SKTextEncoding encoding, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    public static SKTextBlob CreatePathPositioned(string text, SKFont font, SKPath path, SKTextAlign textAlign, SKPoint origin);
    public static SKTextBlob CreatePathPositioned(ReadOnlySpan`1<char> text, SKFont font, SKPath path, SKTextAlign textAlign, SKPoint origin);
    public static SKTextBlob CreatePathPositioned(IntPtr text, int length, SKTextEncoding encoding, SKFont font, SKPath path, SKTextAlign textAlign, SKPoint origin);
    public static SKTextBlob CreatePathPositioned(ReadOnlySpan`1<byte> text, SKTextEncoding encoding, SKFont font, SKPath path, SKTextAlign textAlign, SKPoint origin);
    internal static SKTextBlob CreatePathPositioned(Void* text, int length, SKTextEncoding encoding, SKFont font, SKPath path, SKTextAlign textAlign, SKPoint origin);
    public Single[] GetIntercepts(float upperBounds, float lowerBounds, SKPaint paint);
    public void GetIntercepts(float upperBounds, float lowerBounds, Span`1<float> intervals, SKPaint paint);
    public int CountIntercepts(float upperBounds, float lowerBounds, SKPaint paint);
    internal static SKTextBlob GetObject(IntPtr handle);
}
public class SkiaSharp.SKTextBlobBuilder : SKObject {
    internal SKTextBlobBuilder(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
    public SKTextBlob Build();
    public void AddRun(ReadOnlySpan`1<ushort> glyphs, SKFont font, SKPoint origin);
    public void AddHorizontalRun(ReadOnlySpan`1<ushort> glyphs, SKFont font, ReadOnlySpan`1<float> positions, float y);
    public void AddPositionedRun(ReadOnlySpan`1<ushort> glyphs, SKFont font, ReadOnlySpan`1<SKPoint> positions);
    public void AddRotationScaleRun(ReadOnlySpan`1<ushort> glyphs, SKFont font, ReadOnlySpan`1<SKRotationScaleMatrix> positions);
    public void AddPathPositionedRun(ReadOnlySpan`1<ushort> glyphs, SKFont font, ReadOnlySpan`1<float> glyphWidths, ReadOnlySpan`1<SKPoint> glyphOffsets, SKPath path, SKTextAlign textAlign);
    public SKRunBuffer AllocateRun(SKFont font, int count, float x, float y, Nullable`1<SKRect> bounds);
    public SKHorizontalRunBuffer AllocateHorizontalRun(SKFont font, int count, float y, Nullable`1<SKRect> bounds);
    public SKPositionedRunBuffer AllocatePositionedRun(SKFont font, int count, Nullable`1<SKRect> bounds);
    public SKRotationScaleRunBuffer AllocateRotationScaleRun(SKFont font, int count);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs, string text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs, string text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs, Byte[] text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, UInt16[] glyphs, Byte[] text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, ReadOnlySpan`1<ushort> glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, ReadOnlySpan`1<ushort> glyphs, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddRun (ReadOnlySpan<ushort>, SKFont, float, float) instead.")]
public void AddRun(SKPaint font, float x, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions, string text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions, string text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions, Byte[] text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, UInt16[] glyphs, Single[] positions, Byte[] text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<float> positions);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<float> positions, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<float> positions, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddHorizontalRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<float>, float) instead.")]
public void AddHorizontalRun(SKPaint font, float y, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<float> positions, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions, string text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions, string text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions, Byte[] text, UInt32[] clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, UInt16[] glyphs, SKPoint[] positions, Byte[] text, UInt32[] clusters, SKRect bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<SKPoint> positions);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<SKPoint> positions, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<SKPoint> positions, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AddPositionedRun (ReadOnlySpan<ushort>, SKFont, ReadOnlySpan<SKPoint>) instead.")]
public void AddPositionedRun(SKPaint font, ReadOnlySpan`1<ushort> glyphs, ReadOnlySpan`1<SKPoint> positions, ReadOnlySpan`1<byte> text, ReadOnlySpan`1<UInt32> clusters, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateRun (SKFont, int, float, float, SKRect?) instead.")]
public SKRunBuffer AllocateRun(SKPaint font, int count, float x, float y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateRun (SKFont, int, float, float, SKRect?) instead.")]
public SKRunBuffer AllocateRun(SKPaint font, int count, float x, float y, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateRun (SKFont, int, float, float, SKRect?) instead.")]
public SKRunBuffer AllocateRun(SKPaint font, int count, float x, float y, int textByteCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateRun (SKFont, int, float, float, SKRect?) instead.")]
public SKRunBuffer AllocateRun(SKPaint font, int count, float x, float y, int textByteCount, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateHorizontalRun (SKFont, int, float, SKRect?) instead.")]
public SKHorizontalRunBuffer AllocateHorizontalRun(SKPaint font, int count, float y);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateHorizontalRun (SKFont, int, float, SKRect?) instead.")]
public SKHorizontalRunBuffer AllocateHorizontalRun(SKPaint font, int count, float y, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateHorizontalRun (SKFont, int, float, SKRect?) instead.")]
public SKHorizontalRunBuffer AllocateHorizontalRun(SKPaint font, int count, float y, int textByteCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocateHorizontalRun (SKFont, int, float, SKRect?) instead.")]
public SKHorizontalRunBuffer AllocateHorizontalRun(SKPaint font, int count, float y, int textByteCount, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocatePositionedRun (SKFont, int, SKRect?) instead.")]
public SKPositionedRunBuffer AllocatePositionedRun(SKPaint font, int count);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocatePositionedRun (SKFont, int, SKRect?) instead.")]
public SKPositionedRunBuffer AllocatePositionedRun(SKPaint font, int count, Nullable`1<SKRect> bounds);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocatePositionedRun (SKFont, int, SKRect?) instead.")]
public SKPositionedRunBuffer AllocatePositionedRun(SKPaint font, int count, int textByteCount);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AllocatePositionedRun (SKFont, int, SKRect?) instead.")]
public SKPositionedRunBuffer AllocatePositionedRun(SKPaint font, int count, int textByteCount, Nullable`1<SKRect> bounds);
}
public enum SkiaSharp.SKTextEncoding : Enum {
    public int value__;
    public static SKTextEncoding Utf8;
    public static SKTextEncoding Utf16;
    public static SKTextEncoding Utf32;
    public static SKTextEncoding GlyphId;
}
internal class SkiaSharp.SKTimeDateTimeInternal : ValueType {
    public short fTimeZoneMinutes;
    public ushort fYear;
    public byte fMonth;
    public byte fDayOfWeek;
    public byte fDay;
    public byte fHour;
    public byte fMinute;
    public byte fSecond;
    public static SKTimeDateTimeInternal Create(DateTime datetime);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKTimeDateTimeInternal obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKTimeDateTimeInternal left, SKTimeDateTimeInternal right);
    public static bool op_Inequality(SKTimeDateTimeInternal left, SKTimeDateTimeInternal right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public class SkiaSharp.SKTraceMemoryDump : SKObject {
    private static SKManagedTraceMemoryDumpDelegates delegates;
    private IntPtr userData;
    private static SKTraceMemoryDump();
    protected SKTraceMemoryDump(bool detailedDump, bool dumpWrappedObjects);
    protected virtual void DisposeNative();
    protected virtual void OnDumpNumericValue(string dumpName, string valueName, string units, ulong value);
    protected virtual void OnDumpStringValue(string dumpName, string valueName, string value);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedTraceMemoryDumpDumpNumericValueProxyDelegate")]
private static void DumpNumericValueInternal(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* units, ulong value);
    [MonoPInvokeCallbackAttribute("SkiaSharp.SKManagedTraceMemoryDumpDumpStringValueProxyDelegate")]
private static void DumpStringValueInternal(IntPtr d, Void* context, Void* dumpName, Void* valueName, Void* value);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public enum SkiaSharp.SKTransferFunctionBehavior : Enum {
    public int value__;
    public static SKTransferFunctionBehavior Ignore;
    public static SKTransferFunctionBehavior Respect;
}
public enum SkiaSharp.SKTrimPathEffectMode : Enum {
    public int value__;
    public static SKTrimPathEffectMode Normal;
    public static SKTrimPathEffectMode Inverted;
}
public class SkiaSharp.SKTypeface : SKObject {
    private static SKTypeface defaultTypeface;
    private SKFont font;
    public static SKTypeface Default { get; }
    public string FamilyName { get; }
    public SKFontStyle FontStyle { get; }
    public int FontWeight { get; }
    public int FontWidth { get; }
    public SKFontStyleSlant FontSlant { get; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public bool IsFixedPitch { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FontWeight and FontSlant instead.")]
public SKTypefaceStyle Style { get; }
    public int UnitsPerEm { get; }
    public int GlyphCount { get; }
    public int TableCount { get; }
    private static SKTypeface();
    internal SKTypeface(IntPtr handle, bool owns);
    internal static void EnsureStaticInstanceAreInitialized();
    protected virtual void Dispose(bool disposing);
    public static SKTypeface get_Default();
    public static SKTypeface CreateDefault();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use FromFamilyName(string, SKFontStyleWeight, SKFontStyleWidth, SKFontStyleSlant) instead.")]
public static SKTypeface FromFamilyName(string familyName, SKTypefaceStyle style);
    public static SKTypeface FromFamilyName(string familyName, int weight, int width, SKFontStyleSlant slant);
    public static SKTypeface FromFamilyName(string familyName);
    public static SKTypeface FromFamilyName(string familyName, SKFontStyle style);
    public static SKTypeface FromFamilyName(string familyName, SKFontStyleWeight weight, SKFontStyleWidth width, SKFontStyleSlant slant);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public static SKTypeface FromTypeface(SKTypeface typeface, SKTypefaceStyle style);
    public static SKTypeface FromFile(string path, int index);
    public static SKTypeface FromStream(Stream stream, int index);
    public static SKTypeface FromStream(SKStreamAsset stream, int index);
    public static SKTypeface FromData(SKData data, int index);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(string, out ushort[]) instead.")]
public int CharsToGlyphs(string chars, UInt16[]& glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(IntPtr, int, SKTextEncoding, out ushort[]) instead.")]
public int CharsToGlyphs(IntPtr str, int strlen, SKEncoding encoding, UInt16[]& glyphs);
    public string get_FamilyName();
    public SKFontStyle get_FontStyle();
    public int get_FontWeight();
    public int get_FontWidth();
    public SKFontStyleSlant get_FontSlant();
    public bool get_IsBold();
    public bool get_IsItalic();
    public bool get_IsFixedPitch();
    public SKTypefaceStyle get_Style();
    public int get_UnitsPerEm();
    public int get_GlyphCount();
    public int get_TableCount();
    public UInt32[] GetTableTags();
    public bool TryGetTableTags(UInt32[]& tags);
    public int GetTableSize(UInt32 tag);
    public Byte[] GetTableData(UInt32 tag);
    public bool TryGetTableData(UInt32 tag, Byte[]& tableData);
    public bool TryGetTableData(UInt32 tag, int offset, int length, IntPtr tableData);
    public int CountGlyphs(string str);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CountGlyphs(string) instead.")]
public int CountGlyphs(string str, SKEncoding encoding);
    public int CountGlyphs(ReadOnlySpan`1<char> str);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CountGlyphs(byte[], SKTextEncoding) instead.")]
public int CountGlyphs(Byte[] str, SKEncoding encoding);
    public int CountGlyphs(Byte[] str, SKTextEncoding encoding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CountGlyphs(ReadOnlySpan<byte>, SKTextEncoding) instead.")]
public int CountGlyphs(ReadOnlySpan`1<byte> str, SKEncoding encoding);
    public int CountGlyphs(ReadOnlySpan`1<byte> str, SKTextEncoding encoding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use CountGlyphs(IntPtr, int, SKTextEncoding) instead.")]
public int CountGlyphs(IntPtr str, int strLen, SKEncoding encoding);
    public int CountGlyphs(IntPtr str, int strLen, SKTextEncoding encoding);
    public ushort GetGlyph(int codepoint);
    public UInt16[] GetGlyphs(ReadOnlySpan`1<int> codepoints);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(string) instead.")]
public int GetGlyphs(string text, UInt16[]& glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(string) instead.")]
public int GetGlyphs(string text, SKEncoding encoding, UInt16[]& glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(byte[], SKTextEncoding) instead.")]
public int GetGlyphs(Byte[] text, SKEncoding encoding, UInt16[]& glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(ReadOnlySpan<byte>, SKTextEncoding) instead.")]
public int GetGlyphs(ReadOnlySpan`1<byte> text, SKEncoding encoding, UInt16[]& glyphs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(IntPtr, int, SKTextEncoding) instead.")]
public int GetGlyphs(IntPtr text, int length, SKEncoding encoding, UInt16[]& glyphs);
    public UInt16[] GetGlyphs(string text);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(string) instead.")]
public UInt16[] GetGlyphs(string text, SKEncoding encoding);
    public UInt16[] GetGlyphs(ReadOnlySpan`1<char> text);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(ReadOnlySpan<byte>, SKTextEncoding) instead.")]
public UInt16[] GetGlyphs(Byte[] text, SKEncoding encoding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(ReadOnlySpan<byte>, SKTextEncoding) instead.")]
public UInt16[] GetGlyphs(ReadOnlySpan`1<byte> text, SKEncoding encoding);
    public UInt16[] GetGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetGlyphs(IntPtr, int, SKTextEncoding) instead.")]
public UInt16[] GetGlyphs(IntPtr text, int length, SKEncoding encoding);
    public UInt16[] GetGlyphs(IntPtr text, int length, SKTextEncoding encoding);
    public bool ContainsGlyph(int codepoint);
    public bool ContainsGlyphs(ReadOnlySpan`1<int> codepoints);
    public bool ContainsGlyphs(string text);
    public bool ContainsGlyphs(ReadOnlySpan`1<char> text);
    public bool ContainsGlyphs(ReadOnlySpan`1<byte> text, SKTextEncoding encoding);
    public bool ContainsGlyphs(IntPtr text, int length, SKTextEncoding encoding);
    internal SKFont GetFont();
    public SKFont ToFont();
    public SKFont ToFont(float size, float scaleX, float skewX);
    public SKStreamAsset OpenStream();
    public SKStreamAsset OpenStream(Int32& ttcIndex);
    public Int32[] GetKerningPairAdjustments(ReadOnlySpan`1<ushort> glyphs);
    internal static SKTypeface GetObject(IntPtr handle);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
[ObsoleteAttribute("Use SKFontStyleWeight and SKFontStyleSlant instead.")]
public enum SkiaSharp.SKTypefaceStyle : Enum {
    public int value__;
    public static SKTypefaceStyle Normal;
    public static SKTypefaceStyle Bold;
    public static SKTypefaceStyle Italic;
    public static SKTypefaceStyle BoldItalic;
}
public enum SkiaSharp.SKVertexMode : Enum {
    public int value__;
    public static SKVertexMode Triangles;
    public static SKVertexMode TriangleStrip;
    public static SKVertexMode TriangleFan;
}
public class SkiaSharp.SKVertices : SKObject {
    internal SKVertices(IntPtr x, bool owns);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.ReferenceNative();
    private sealed virtual override void SkiaSharp.ISKNonVirtualReferenceCounted.UnreferenceNative();
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKColor[] colors);
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKPoint[] texs, SKColor[] colors);
    public static SKVertices CreateCopy(SKVertexMode vmode, SKPoint[] positions, SKPoint[] texs, SKColor[] colors, UInt16[] indices);
    internal static SKVertices GetObject(IntPtr handle);
}
public enum SkiaSharp.SKWebpEncoderCompression : Enum {
    public int value__;
    public static SKWebpEncoderCompression Lossy;
    public static SKWebpEncoderCompression Lossless;
}
public class SkiaSharp.SKWebpEncoderOptions : ValueType {
    public static SKWebpEncoderOptions Default;
    private SKWebpEncoderCompression fCompression;
    private float fQuality;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
public SKTransferFunctionBehavior UnpremulBehavior { get; public set; }
    public SKWebpEncoderCompression Compression { get; public set; }
    public float Quality { get; public set; }
    private static SKWebpEncoderOptions();
    public SKWebpEncoderOptions(SKWebpEncoderCompression compression, float quality);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use SKWebpEncoderOptions(SKWebpEncoderCompression, float) instead.")]
public SKWebpEncoderOptions(SKWebpEncoderCompression compression, float quality, SKTransferFunctionBehavior unpremulBehavior);
    [IsReadOnlyAttribute]
public SKTransferFunctionBehavior get_UnpremulBehavior();
    public void set_UnpremulBehavior(SKTransferFunctionBehavior value);
    [IsReadOnlyAttribute]
public SKWebpEncoderCompression get_Compression();
    public void set_Compression(SKWebpEncoderCompression value);
    [IsReadOnlyAttribute]
public float get_Quality();
    public void set_Quality(float value);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SKWebpEncoderOptions obj);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    public static bool op_Equality(SKWebpEncoderOptions left, SKWebpEncoderOptions right);
    public static bool op_Inequality(SKWebpEncoderOptions left, SKWebpEncoderOptions right);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
}
public abstract class SkiaSharp.SKWStream : SKObject {
    public int BytesWritten { get; }
    internal SKWStream(IntPtr handle, bool owns);
    public virtual int get_BytesWritten();
    public virtual bool Write(Byte[] buffer, int size);
    public bool NewLine();
    public virtual void Flush();
    public bool Write8(byte value);
    public bool Write16(ushort value);
    public bool Write32(UInt32 value);
    public bool WriteText(string value);
    public bool WriteDecimalAsTest(int value);
    public bool WriteBigDecimalAsText(long value, int digits);
    public bool WriteHexAsText(UInt32 value, int digits);
    public bool WriteScalarAsText(float value);
    public bool WriteBool(bool value);
    public bool WriteScalar(float value);
    public bool WritePackedUInt32(UInt32 value);
    public bool WriteStream(SKStream input, int length);
    public static int GetSizeOfPackedUInt32(UInt32 value);
}
public class SkiaSharp.SKXmlStreamWriter : SKXmlWriter {
    internal SKXmlStreamWriter(IntPtr h, bool owns);
    public SKXmlStreamWriter(SKWStream stream);
    protected virtual void Dispose(bool disposing);
    protected virtual void DisposeNative();
}
public abstract class SkiaSharp.SKXmlWriter : SKObject {
    internal SKXmlWriter(IntPtr h, bool owns);
}
public enum SkiaSharp.SKZeroInitialized : Enum {
    public int value__;
    public static SKZeroInitialized Yes;
    public static SKZeroInitialized No;
}
[ExtensionAttribute]
public static class SkiaSharp.StringUtilities : object {
    internal static string NullTerminator;
    private static int GetUnicodeStringLength(SKTextEncoding encoding);
    [ExtensionAttribute]
internal static int GetCharacterByteSize(SKTextEncoding encoding);
    public static int GetUnicodeCharacterCode(string character, SKTextEncoding encoding);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetEncodedText(string, SKTextEncoding) instead.")]
public static Byte[] GetEncodedText(string text, SKEncoding encoding);
    public static Byte[] GetEncodedText(string text, SKTextEncoding encoding);
    internal static Byte[] GetEncodedText(string text, SKTextEncoding encoding, bool addNull);
    public static Byte[] GetEncodedText(ReadOnlySpan`1<char> text, SKTextEncoding encoding);
    public static string GetString(IntPtr data, int dataLength, SKTextEncoding encoding);
    public static string GetString(Byte[] data, SKTextEncoding encoding);
    public static string GetString(Byte[] data, int index, int count, SKTextEncoding encoding);
    public static string GetString(ReadOnlySpan`1<byte> data, SKTextEncoding encoding);
    public static string GetString(ReadOnlySpan`1<byte> data, int index, int count, SKTextEncoding encoding);
}
internal class SkiaSharp.UserDataDelegate : MulticastDelegate {
    public UserDataDelegate(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class SkiaSharp.Utils : object {
    internal static float NearlyZero;
    internal static int GetPreambleSize(SKData data);
    [ExtensionAttribute]
internal static Span`1<byte> AsSpan(IntPtr ptr, int size);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<byte> AsReadOnlySpan(IntPtr ptr, int size);
    internal static bool NearlyEqual(float a, float b, float tolerance);
    [ExtensionAttribute]
internal static Byte[] GetBytes(Encoding encoding, ReadOnlySpan`1<char> text);
    public static RentedArray`1<T> RentArray(int length, bool nullIfEmpty);
    public static RentedArray`1<IntPtr> RentHandlesArray(SKObject[] objects, bool nullIfEmpty);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
internal class VersionConstants : object {
    public static string AssemblyVersion;
    public static string AssemblyFileVersion;
    public static string AssemblyInformationalVersion;
    public static string GitSha;
    public static int Milestone;
    public static int Increment;
}
