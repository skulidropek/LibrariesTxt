[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
public static class SonarAnalyzer.CFG.CfgSerializer : object {
    public static string Serialize(IControlFlowGraph cfg, string title);
    public static string Serialize(ControlFlowGraph cfg, string title);
    public static string Serialize(RoslynLiveVariableAnalysis lva, string title);
}
public class SonarAnalyzer.CFG.DotWriter : object {
    private StringBuilder builder;
    private StringBuilder edges;
    private bool started;
    public void WriteGraphStart(string graphName);
    public void WriteGraphEnd();
    public void WriteSubGraphStart(int id, string title);
    public void WriteSubGraphEnd();
    public void WriteNode(string id, string header, String[] items);
    public void WriteEdge(string startId, string endId, string label);
    public virtual string ToString();
    private static string Encode(string s);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.CFG.Helpers.CSharpSyntaxHelper : object {
    private static string NameOfKeywordText;
    private static ISet`1<SyntaxKind> ParenthesizedExpressionKinds;
    private static CSharpSyntaxHelper();
    [ExtensionAttribute]
public static SyntaxNode RemoveParentheses(SyntaxNode expression);
    [ExtensionAttribute]
public static ExpressionSyntax RemoveParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNameof(InvocationExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsCatchingAllExceptions(CatchClauseSyntax catchClause);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.CFG.Helpers.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.CFG.Helpers.EnumerableExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> equalityComparer);
}
public abstract class SonarAnalyzer.CFG.Helpers.OperationFinder`1 : object {
    protected abstract virtual bool TryFindOperation(IOperationWrapperSonar operation, TResult& result);
    public bool TryFind(BasicBlock block, TResult& result);
    protected bool TryFind(IEnumerable`1<IOperation> operations, TResult& result);
}
public static class SonarAnalyzer.CFG.Helpers.RoslynHelper : object {
    public static int VS2017MajorVersion;
    public static int MinimalSupportedMajorVersion;
    public static bool IsRoslynCfgSupported(int minimalVersion);
    public static Type FlowAnalysisType(string typeName);
    public static bool IsVersionLessThan(int minimalVersion);
}
[ExtensionAttribute]
public static class SonarAnalyzer.CFG.Helpers.SemanticModelHelper : object {
    [ExtensionAttribute]
public static ISymbol GetSymbolOrCandidateSymbol(SemanticModel model, SyntaxNode node);
}
internal class SonarAnalyzer.CFG.Helpers.UniqueQueue`1 : object {
    private Queue`1<T> queue;
    private ISet`1<T> unique;
    public void Enqueue(T item);
    public T Dequeue();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class SonarAnalyzer.CFG.LiveVariableAnalysis.LiveVariableAnalysisBase`2 : object {
    protected ISymbol originalDeclaration;
    protected CancellationToken Cancel;
    private Dictionary`2<TBlock, HashSet`1<ISymbol>> blockLiveOut;
    private Dictionary`2<TBlock, HashSet`1<ISymbol>> blockLiveIn;
    private HashSet`1<ISymbol> captured;
    [CompilerGeneratedAttribute]
private TCfg <Cfg>k__BackingField;
    protected TBlock ExitBlock { get; }
    public TCfg Cfg { get; }
    public IReadOnlyCollection`1<ISymbol> CapturedVariables { get; }
    protected LiveVariableAnalysisBase`2(TCfg cfg, ISymbol originalDeclaration, CancellationToken cancel);
    public abstract virtual bool IsLocal(ISymbol symbol);
    protected abstract virtual TBlock get_ExitBlock();
    protected abstract virtual State<TCfg, TBlock> ProcessBlock(TBlock block);
    protected abstract virtual IEnumerable`1<TBlock> ReversedBlocks();
    protected abstract virtual IEnumerable`1<TBlock> Successors(TBlock block);
    protected abstract virtual IEnumerable`1<TBlock> Predecessors(TBlock block);
    [CompilerGeneratedAttribute]
public TCfg get_Cfg();
    public IReadOnlyCollection`1<ISymbol> get_CapturedVariables();
    public IEnumerable`1<ISymbol> LiveIn(TBlock block);
    public IEnumerable`1<ISymbol> LiveOut(TBlock block);
    protected void Analyze();
    [CompilerGeneratedAttribute]
private HashSet`1<ISymbol> <Analyze>b__20_0(TBlock x);
}
public class SonarAnalyzer.CFG.LiveVariableAnalysis.RoslynLiveVariableAnalysis : LiveVariableAnalysisBase`2<ControlFlowGraph, BasicBlock> {
    private Dictionary`2<CaptureId, List`1<ISymbol>> flowCaptures;
    private Dictionary`2<int, List`1<BasicBlock>> blockPredecessors;
    private Dictionary`2<int, List`1<BasicBlock>> blockSuccessors;
    internal ImmutableDictionary`2<int, List`1<BasicBlock>> BlockPredecessors { get; }
    protected BasicBlock ExitBlock { get; }
    public RoslynLiveVariableAnalysis(ControlFlowGraph cfg, CancellationToken cancel);
    internal ImmutableDictionary`2<int, List`1<BasicBlock>> get_BlockPredecessors();
    protected virtual BasicBlock get_ExitBlock();
    public IEnumerable`1<ISymbol> ParameterOrLocalSymbols(IOperation operation);
    public virtual bool IsLocal(ISymbol symbol);
    protected virtual IEnumerable`1<BasicBlock> ReversedBlocks();
    protected virtual IEnumerable`1<BasicBlock> Predecessors(BasicBlock block);
    protected virtual IEnumerable`1<BasicBlock> Successors(BasicBlock block);
    protected virtual State<ControlFlowGraph, BasicBlock> ProcessBlock(BasicBlock block);
    private void ResolveCaptures();
    private void BuildBranches(BasicBlock block);
    private void BuildBranchesFinally(BasicBlock source, ControlFlowRegion finallyRegion);
    private void BuildBranchesRethrow(BasicBlock block);
    private void AddBranch(BasicBlock source, BasicBlock destination);
    private IEnumerable`1<ControlFlowBranch> TryRegionSuccessors(ControlFlowRegion finallyRegion);
    private static IEnumerable`1<ControlFlowRegion> CatchOrFilterRegions(ControlFlowBranch trySuccessor);
    [IteratorStateMachineAttribute("SonarAnalyzer.CFG.LiveVariableAnalysis.RoslynLiveVariableAnalysis/<CatchOrFilterRegions>d__21")]
private static IEnumerable`1<ControlFlowRegion> CatchOrFilterRegions(ControlFlowRegion tryAndCatchRegion);
    private static bool IsCatchAllType(ITypeSymbol exceptionType);
    private static ISymbol OriginalDeclaration(IOperation originalOperation);
    [CompilerGeneratedAttribute]
private bool <ParameterOrLocalSymbols>b__8_0(ISymbol x);
    [CompilerGeneratedAttribute]
private void <ResolveCaptures>g__AppendFlowCaptureReference|14_0(CaptureId id, IEnumerable`1<ISymbol> symbols);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.CFG.PropertyInfoExtensions : object {
    [ExtensionAttribute]
public static T ReadCached(PropertyInfo property, object instance, T& cache);
    [ExtensionAttribute]
public static T ReadCached(PropertyInfo property, object instance, Nullable`1& cache);
    [ExtensionAttribute]
public static T ReadCached(PropertyInfo property, object instance, Func`2<object, T> createInstance, T& cache);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ReadCached(PropertyInfo property, object instance, ImmutableArray`1& cache);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ReadCached(PropertyInfo property, object instance, Func`2<object, T> createInstance, ImmutableArray`1& cache);
}
public class SonarAnalyzer.CFG.Roslyn.BasicBlock : object {
    private static ConditionalWeakTable`2<object, BasicBlock> InstanceCache;
    private static PropertyInfo BranchValueProperty;
    private static PropertyInfo ConditionalSuccessorProperty;
    private static PropertyInfo ConditionKindProperty;
    private static PropertyInfo EnclosingRegionProperty;
    private static PropertyInfo FallThroughSuccessorProperty;
    private static PropertyInfo IsReachableProperty;
    private static PropertyInfo KindProperty;
    private static PropertyInfo OperationsProperty;
    private static PropertyInfo OrdinalProperty;
    private static PropertyInfo PredecessorsProperty;
    private object instance;
    private Lazy`1<ImmutableArray`1<ControlFlowBranch>> successors;
    private Lazy`1<ImmutableArray`1<BasicBlock>> successorBlocks;
    private Lazy`1<ImmutableArray`1<IOperation>> operationsAndBranchValue;
    private IOperation branchValue;
    private ControlFlowBranch conditionalSuccessor;
    private Nullable`1<ControlFlowConditionKind> conditionKind;
    private ControlFlowRegion enclosingRegion;
    private ControlFlowBranch fallThroughSuccessor;
    private Nullable`1<bool> isReachable;
    private Nullable`1<BasicBlockKind> kind;
    private ImmutableArray`1<IOperation> operations;
    private Nullable`1<int> ordinal;
    private ImmutableArray`1<ControlFlowBranch> predecessors;
    public IOperation BranchValue { get; }
    public ControlFlowBranch ConditionalSuccessor { get; }
    public ControlFlowConditionKind ConditionKind { get; }
    public ControlFlowRegion EnclosingRegion { get; }
    public ControlFlowBranch FallThroughSuccessor { get; }
    public bool IsReachable { get; }
    public BasicBlockKind Kind { get; }
    public ImmutableArray`1<IOperation> Operations { get; }
    public int Ordinal { get; }
    public ImmutableArray`1<ControlFlowBranch> Predecessors { get; }
    public ImmutableArray`1<ControlFlowBranch> Successors { get; }
    public ImmutableArray`1<BasicBlock> SuccessorBlocks { get; }
    public ImmutableArray`1<IOperation> OperationsAndBranchValue { get; }
    private static BasicBlock();
    private BasicBlock(object instance);
    public IOperation get_BranchValue();
    public ControlFlowBranch get_ConditionalSuccessor();
    public ControlFlowConditionKind get_ConditionKind();
    public ControlFlowRegion get_EnclosingRegion();
    public ControlFlowBranch get_FallThroughSuccessor();
    public bool get_IsReachable();
    public BasicBlockKind get_Kind();
    public ImmutableArray`1<IOperation> get_Operations();
    public int get_Ordinal();
    public ImmutableArray`1<ControlFlowBranch> get_Predecessors();
    public ImmutableArray`1<ControlFlowBranch> get_Successors();
    public ImmutableArray`1<BasicBlock> get_SuccessorBlocks();
    public ImmutableArray`1<IOperation> get_OperationsAndBranchValue();
    public static BasicBlock Wrap(object instance);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowBranch> <.ctor>b__52_0();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BasicBlock> <.ctor>b__52_1();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <.ctor>b__52_2();
}
public enum SonarAnalyzer.CFG.Roslyn.BasicBlockKind : Enum {
    public int value__;
    public static BasicBlockKind Entry;
    public static BasicBlockKind Exit;
    public static BasicBlockKind Block;
}
public abstract class SonarAnalyzer.CFG.Roslyn.CfgAllPathValidator : object {
    private ControlFlowGraph cfg;
    protected CfgAllPathValidator(ControlFlowGraph cfg);
    protected abstract virtual bool IsValid(BasicBlock block);
    protected abstract virtual bool IsInvalid(BasicBlock block);
    public bool CheckAllPaths();
}
public class SonarAnalyzer.CFG.Roslyn.ControlFlowBranch : object {
    private static ConditionalWeakTable`2<object, ControlFlowBranch> InstanceCache;
    private static PropertyInfo SourceProperty;
    private static PropertyInfo DestinationProperty;
    private static PropertyInfo SemanticsProperty;
    private static PropertyInfo IsConditionalSuccessorProperty;
    private static PropertyInfo EnteringRegionsProperty;
    private static PropertyInfo LeavingRegionsProperty;
    private static PropertyInfo FinallyRegionsProperty;
    private object instance;
    private BasicBlock source;
    private BasicBlock destination;
    private Nullable`1<ControlFlowBranchSemantics> semantics;
    private Nullable`1<bool> isConditionalSuccessor;
    private ImmutableArray`1<ControlFlowRegion> enteringRegions;
    private ImmutableArray`1<ControlFlowRegion> leavingRegions;
    private ImmutableArray`1<ControlFlowRegion> finallyRegions;
    public BasicBlock Source { get; }
    public BasicBlock Destination { get; }
    public ControlFlowBranchSemantics Semantics { get; }
    public bool IsConditionalSuccessor { get; }
    public ImmutableArray`1<ControlFlowRegion> EnteringRegions { get; }
    public ImmutableArray`1<ControlFlowRegion> LeavingRegions { get; }
    public ImmutableArray`1<ControlFlowRegion> FinallyRegions { get; }
    private static ControlFlowBranch();
    private ControlFlowBranch(object instance);
    public BasicBlock get_Source();
    public BasicBlock get_Destination();
    public ControlFlowBranchSemantics get_Semantics();
    public bool get_IsConditionalSuccessor();
    public ImmutableArray`1<ControlFlowRegion> get_EnteringRegions();
    public ImmutableArray`1<ControlFlowRegion> get_LeavingRegions();
    public ImmutableArray`1<ControlFlowRegion> get_FinallyRegions();
    public static ControlFlowBranch Wrap(object instance);
}
public enum SonarAnalyzer.CFG.Roslyn.ControlFlowBranchSemantics : Enum {
    public int value__;
    public static ControlFlowBranchSemantics None;
    public static ControlFlowBranchSemantics Regular;
    public static ControlFlowBranchSemantics Return;
    public static ControlFlowBranchSemantics StructuredExceptionHandling;
    public static ControlFlowBranchSemantics ProgramTermination;
    public static ControlFlowBranchSemantics Throw;
    public static ControlFlowBranchSemantics Rethrow;
    public static ControlFlowBranchSemantics Error;
}
public enum SonarAnalyzer.CFG.Roslyn.ControlFlowConditionKind : Enum {
    public int value__;
    public static ControlFlowConditionKind None;
    public static ControlFlowConditionKind WhenFalse;
    public static ControlFlowConditionKind WhenTrue;
}
public class SonarAnalyzer.CFG.Roslyn.ControlFlowGraph : object {
    private static ConditionalWeakTable`2<object, ControlFlowGraph> InstanceCache;
    private static PropertyInfo BlocksProperty;
    private static PropertyInfo LocalFunctionsProperty;
    private static PropertyInfo OriginalOperationProperty;
    private static PropertyInfo ParentProperty;
    private static PropertyInfo RootProperty;
    private static MethodInfo CreateMethod;
    private static MethodInfo GetAnonymousFunctionControlFlowGraphMethod;
    private static MethodInfo GetLocalFunctionControlFlowGraphMethod;
    private object instance;
    private ImmutableArray`1<BasicBlock> blocks;
    private ImmutableArray`1<IMethodSymbol> localFunctions;
    private ControlFlowGraph parent;
    private IOperation originalOperation;
    private ControlFlowRegion root;
    [CompilerGeneratedAttribute]
private static bool <IsAvailable>k__BackingField;
    public static bool IsAvailable { get; }
    public ImmutableArray`1<BasicBlock> Blocks { get; }
    public ImmutableArray`1<IMethodSymbol> LocalFunctions { get; }
    public IOperation OriginalOperation { get; }
    public ControlFlowGraph Parent { get; }
    public ControlFlowRegion Root { get; }
    public BasicBlock EntryBlock { get; }
    public BasicBlock ExitBlock { get; }
    private static ControlFlowGraph();
    private ControlFlowGraph(object instance);
    [CompilerGeneratedAttribute]
public static bool get_IsAvailable();
    public ImmutableArray`1<BasicBlock> get_Blocks();
    public ImmutableArray`1<IMethodSymbol> get_LocalFunctions();
    public IOperation get_OriginalOperation();
    public ControlFlowGraph get_Parent();
    public ControlFlowRegion get_Root();
    public BasicBlock get_EntryBlock();
    public BasicBlock get_ExitBlock();
    public static ControlFlowGraph Create(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancel);
    public ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperationWrapper anonymousFunction, CancellationToken cancel);
    public ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction, CancellationToken cancel);
    public static ControlFlowGraph Wrap(object instance);
}
public abstract class SonarAnalyzer.CFG.Roslyn.ControlFlowGraphCacheBase : object {
    private ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SyntaxNode, Wrapper>> compilationCache;
    protected abstract virtual bool HasNestedCfg(SyntaxNode node);
    protected abstract virtual bool IsLocalFunction(SyntaxNode node);
    public ControlFlowGraph FindOrCreate(SyntaxNode declaration, SemanticModel model, CancellationToken cancel);
}
public class SonarAnalyzer.CFG.Roslyn.ControlFlowRegion : object {
    private static ConditionalWeakTable`2<object, ControlFlowRegion> InstanceCache;
    private static PropertyInfo KindProperty;
    private static PropertyInfo EnclosingRegionProperty;
    private static PropertyInfo ExceptionTypeProperty;
    private static PropertyInfo FirstBlockOrdinalProperty;
    private static PropertyInfo LastBlockOrdinalProperty;
    private static PropertyInfo NestedRegionsProperty;
    private static PropertyInfo LocalsProperty;
    private static PropertyInfo LocalFunctionsProperty;
    private static PropertyInfo CaptureIdsProperty;
    private object instance;
    private Nullable`1<ControlFlowRegionKind> kind;
    private ControlFlowRegion enclosingRegion;
    private ITypeSymbol exceptionType;
    private Nullable`1<int> firstBlockOrdinal;
    private Nullable`1<int> lastBlockOrdinal;
    private ImmutableArray`1<ControlFlowRegion> nestedRegions;
    private ImmutableArray`1<ILocalSymbol> locals;
    private ImmutableArray`1<IMethodSymbol> localFunctions;
    private ImmutableArray`1<CaptureId> captureIds;
    public ControlFlowRegionKind Kind { get; }
    public ControlFlowRegion EnclosingRegion { get; }
    public ITypeSymbol ExceptionType { get; }
    public int FirstBlockOrdinal { get; }
    public int LastBlockOrdinal { get; }
    public ImmutableArray`1<ControlFlowRegion> NestedRegions { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ImmutableArray`1<IMethodSymbol> LocalFunctions { get; }
    public ImmutableArray`1<CaptureId> CaptureIds { get; }
    private static ControlFlowRegion();
    private ControlFlowRegion(object instance);
    public ControlFlowRegionKind get_Kind();
    public ControlFlowRegion get_EnclosingRegion();
    public ITypeSymbol get_ExceptionType();
    public int get_FirstBlockOrdinal();
    public int get_LastBlockOrdinal();
    public ImmutableArray`1<ControlFlowRegion> get_NestedRegions();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ImmutableArray`1<IMethodSymbol> get_LocalFunctions();
    public ImmutableArray`1<CaptureId> get_CaptureIds();
    public static ControlFlowRegion Wrap(object instance);
}
public enum SonarAnalyzer.CFG.Roslyn.ControlFlowRegionKind : Enum {
    public int value__;
    public static ControlFlowRegionKind Root;
    public static ControlFlowRegionKind LocalLifetime;
    public static ControlFlowRegionKind Try;
    public static ControlFlowRegionKind Filter;
    public static ControlFlowRegionKind Catch;
    public static ControlFlowRegionKind FilterAndHandler;
    public static ControlFlowRegionKind TryAndCatch;
    public static ControlFlowRegionKind Finally;
    public static ControlFlowRegionKind TryAndFinally;
    public static ControlFlowRegionKind StaticLocalInitializer;
    public static ControlFlowRegionKind ErroneousBody;
}
public abstract class SonarAnalyzer.CFG.Sonar.AbstractControlFlowGraphBuilder : object {
    protected SyntaxNode rootNode;
    protected SemanticModel semanticModel;
    protected List`1<Block> reversedBlocks;
    protected Stack`1<Block> exitTarget;
    protected AbstractControlFlowGraphBuilder(SyntaxNode node, SemanticModel semanticModel);
    protected abstract virtual void PostProcessGraph();
    public IControlFlowGraph Build();
    protected abstract virtual Block Build(SyntaxNode node, Block currentBlock);
    internal BinaryBranchBlock CreateBinaryBranchBlock(SyntaxNode branchingNode, Block trueSuccessor, Block falseSuccessor);
    internal SimpleBlock CreateBlock(Block successor);
    internal JumpBlock CreateJumpBlock(SyntaxNode jumpStatement, Block successor, Block wouldBeSuccessor);
    internal BranchBlock CreateBranchBlock(SyntaxNode branchingNode, IEnumerable`1<Block> successors);
    private ExitBlock CreateExitBlock();
    internal TemporaryBlock CreateTemporaryBlock();
    internal T AddBlock(T block);
}
public class SonarAnalyzer.CFG.Sonar.BinaryBranchBlock : BranchBlock {
    public Block TrueSuccessorBlock { get; }
    public Block FalseSuccessorBlock { get; }
    public SyntaxNode Parent { get; }
    internal BinaryBranchBlock(SyntaxNode branchingNode, Block trueSuccessor, Block falseSuccessor);
    public Block get_TrueSuccessorBlock();
    public Block get_FalseSuccessorBlock();
    public SyntaxNode get_Parent();
}
public class SonarAnalyzer.CFG.Sonar.BinaryBranchingSimpleBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private SyntaxNode <BranchingInstruction>k__BackingField;
    public SyntaxNode BranchingInstruction { get; }
    internal BinaryBranchingSimpleBlock(SyntaxNode branchingInstruction, Block trueAndFalseSuccessor);
    [CompilerGeneratedAttribute]
public SyntaxNode get_BranchingInstruction();
}
public class SonarAnalyzer.CFG.Sonar.Block : object {
    private Lazy`1<IReadOnlyList`1<SyntaxNode>> instructions;
    private Lazy`1<IReadOnlyCollection`1<Block>> predecessorBlocks;
    private Lazy`1<ISet`1<Block>> allSuccessors;
    private Lazy`1<ISet`1<Block>> allPredecessors;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Block> <SuccessorBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SyntaxNode> <ReversedInstructions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Block> <EditablePredecessorBlocks>k__BackingField;
    public IReadOnlyList`1<SyntaxNode> Instructions { get; }
    public IReadOnlyCollection`1<Block> PredecessorBlocks { get; }
    public IReadOnlyList`1<Block> SuccessorBlocks { get; }
    internal IList`1<SyntaxNode> ReversedInstructions { get; }
    internal ISet`1<Block> EditablePredecessorBlocks { get; }
    public ISet`1<Block> AllSuccessorBlocks { get; }
    public ISet`1<Block> AllPredecessorBlocks { get; }
    public virtual IReadOnlyList`1<SyntaxNode> get_Instructions();
    public virtual IReadOnlyCollection`1<Block> get_PredecessorBlocks();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<Block> get_SuccessorBlocks();
    [CompilerGeneratedAttribute]
internal IList`1<SyntaxNode> get_ReversedInstructions();
    [CompilerGeneratedAttribute]
internal ISet`1<Block> get_EditablePredecessorBlocks();
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
    internal virtual void ReplaceSuccessors(Dictionary`2<Block, Block> replacementMapping);
    public ISet`1<Block> get_AllSuccessorBlocks();
    public ISet`1<Block> get_AllPredecessorBlocks();
    private static ISet`1<Block> GetAll(Block initial, Func`2<Block, IEnumerable`1<Block>> getNexts);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SyntaxNode> <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<Block> <.ctor>b__4_1();
    [CompilerGeneratedAttribute]
private ISet`1<Block> <.ctor>b__4_2();
    [CompilerGeneratedAttribute]
private ISet`1<Block> <.ctor>b__4_3();
}
public class SonarAnalyzer.CFG.Sonar.BlockIdProvider : object {
    private Dictionary`2<Block, string> map;
    private int counter;
    public string Get(Block cfgBlock);
    [CompilerGeneratedAttribute]
private string <Get>b__2_0(Block b);
}
public class SonarAnalyzer.CFG.Sonar.BranchBlock : Block {
    [CompilerGeneratedAttribute]
private SyntaxNode <BranchingNode>k__BackingField;
    protected Block[] successors;
    public SyntaxNode BranchingNode { get; }
    public IReadOnlyList`1<Block> SuccessorBlocks { get; }
    internal BranchBlock(SyntaxNode branchingNode, Block[] successors);
    [CompilerGeneratedAttribute]
public SyntaxNode get_BranchingNode();
    public virtual IReadOnlyList`1<Block> get_SuccessorBlocks();
    internal virtual void ReplaceSuccessors(Dictionary`2<Block, Block> replacementMapping);
}
public class SonarAnalyzer.CFG.Sonar.CfgAllPathValidator : object {
    protected IControlFlowGraph cfg;
    private HashSet`1<Block> alreadyVisitedBlocks;
    protected CfgAllPathValidator(IControlFlowGraph cfg);
    public bool CheckAllPaths();
    private bool IsBlockValidWithSuccessors(Block block);
    private bool AreAllSuccessorsValid(Block block);
    protected virtual bool IsBlockValid(Block block);
    protected virtual bool IsBlockInvalid(Block block);
    [CompilerGeneratedAttribute]
private bool <AreAllSuccessorsValid>b__5_0(Block b);
}
public static class SonarAnalyzer.CFG.Sonar.CSharpControlFlowGraph : object {
    public static bool TryGet(SyntaxNode node, SemanticModel semanticModel, IControlFlowGraph& cfg);
    internal static IControlFlowGraph Create(SyntaxNode node, SemanticModel semanticModel);
}
public class SonarAnalyzer.CFG.Sonar.CSharpControlFlowGraphBuilder : AbstractControlFlowGraphBuilder {
    private static int SupportedExpressionNodeCountLimit;
    private Stack`1<Block> breakTarget;
    private Stack`1<Block> continueTargets;
    private Stack`1<Dictionary`2<object, List`1<JumpBlock>>> switchGotoJumpBlocks;
    private Dictionary`2<string, List`1<JumpBlock>> gotoJumpBlocks;
    private Dictionary`2<string, JumpBlock> labeledStatements;
    private static object GotoDefaultEntry;
    private static object GotoNullEntry;
    public CSharpControlFlowGraphBuilder(SyntaxNode node, SemanticModel semanticModel);
    private static CSharpControlFlowGraphBuilder();
    protected virtual void PostProcessGraph();
    private void FixJumps(Dictionary`2<TLabel, List`1<JumpBlock>> jumpsToFix, Dictionary`2<TLabel, Block> collectedJumpTargets);
    protected virtual Block Build(SyntaxNode node, Block currentBlock);
    private Block BuildConstructorInitializer(ConstructorInitializerSyntax initializer, Block currentBlock);
    private Block BuildStatement(StatementSyntax statement, Block currentBlock);
    private Block BuildExpression(ExpressionSyntax expression, Block currentBlock);
    private static bool IsTooComplex(SyntaxNode node);
    private Block BuildStatements(IEnumerable`1<StatementSyntax> statements, Block currentBlock);
    private Block BuildExpressions(IEnumerable`1<ExpressionSyntax> expressions, Block currentBlock);
    private Block BuildLabeledStatement(LabeledStatementSyntax labeledStatement, Block currentBlock);
    private Block BuildTryStatement(TryStatementSyntax tryStatement, Block currentBlock);
    private Block BuildGotoDefaultStatement(GotoStatementSyntax statement, Block currentBlock);
    private Block BuildGotoCaseStatement(GotoStatementSyntax statement, Block currentBlock);
    private Block BuildGotoStatement(GotoStatementSyntax statement, Block currentBlock);
    private Block BuildSwitchStatement(SwitchStatementSyntax switchStatement, Block currentBlock);
    private Block BuildSwitchExpression(SwitchExpressionSyntaxWrapper switchExpressionSyntax, Block currentBlock);
    private Block BuildArmBranch(SwitchExpressionArmSyntaxWrapper switchExpressionArmSyntax, Block trueSuccessor, Block falseSuccessor, bool isLast);
    private Block CreateCurrentBlock(SwitchExpressionArmSyntaxWrapper switchExpressionArmSyntax, Block trueSuccessor, Block falseSuccessor, bool isLast);
    private Block BuildCasePattern(CasePatternSwitchLabelSyntaxWrapper casePatternSwitchLabel, Block trueSuccessor, Block falseSuccessor);
    private Block CreateWhenCloseNewTrueSuccessor(WhenClauseSyntaxWrapper whenClauseSyntax, Block trueSuccessor, Block falseSuccessor);
    private object GetCaseIndexer(ExpressionSyntax expression);
    private Block BuildBreakStatement(BreakStatementSyntax breakStatement, Block currentBlock);
    private Block BuildContinueStatement(ContinueStatementSyntax continueStatement, Block currentBlock);
    private Block BuildReturnStatement(ReturnStatementSyntax returnStatement, Block currentBlock);
    private Block BuildThrowStatement(ThrowStatementSyntax throwStatement, Block currentBlock);
    private Block BuildYieldBreakStatement(YieldStatementSyntax yieldBreakStatement, Block currentBlock);
    private Block BuildYieldReturnStatement(YieldStatementSyntax yieldReturnStatement, Block currentBlock);
    private Block BuildJumpToExitStatement(StatementSyntax statement, Block currentBlock, ExpressionSyntax expression);
    private Block BuildJumpToExitStatement(ExpressionSyntax expression, Block currentBlock, ExpressionSyntax innerExpression);
    private Block BuildLockStatement(LockStatementSyntax lockStatement, Block currentBlock);
    private Block BuildUsingStatement(UsingStatementSyntax usingStatement, Block currentBlock);
    private Block BuildFixedStatement(FixedStatementSyntax fixedStatement, Block currentBlock);
    private Block BuildUnsafeStatement(UnsafeStatementSyntax statement, Block currentBlock);
    private Block BuildCheckedStatement(CheckedStatementSyntax statement, Block currentBlock);
    private Block BuildDoStatement(DoStatementSyntax doStatement, Block currentBlock);
    private Block BuildForStatement(ForStatementSyntax forStatement, Block currentBlock);
    private Block BuildForEachVariableStatement(ForEachVariableStatementSyntaxWrapper foreachStatement, Block currentBlock);
    private Block BuildForEachStatement(ForEachStatementSyntax foreachStatement, Block currentBlock);
    private Block BuildForEachStatement(StatementSyntax foreachStatement, StatementSyntax foreachBodyStatement, ExpressionSyntax foreachExpression, Block currentBlock);
    private Block BuildWhileStatement(WhileStatementSyntax whileStatement, Block currentBlock);
    private Block BuildIfStatement(IfStatementSyntax ifStatement, Block currentBlock);
    private Block BuildBlock(BlockSyntax block, Block currentBlock);
    private Block BuildConditionalAccessExpression(ConditionalAccessExpressionSyntax conditionalAccess, Block currentBlock);
    private Block BuildConditionalExpression(ConditionalExpressionSyntax conditional, Block currentBlock);
    private Block BuildCoalesceExpression(BinaryExpressionSyntax expression, Block currentBlock);
    private Block BuildLogicalAndExpression(BinaryExpressionSyntax expression, Block currentBlock);
    private Block BuildLogicalOrExpression(BinaryExpressionSyntax expression, Block currentBlock);
    private Block BuildArrayCreationExpression(ArrayCreationExpressionSyntax expression, Block currentBlock);
    private Block BuildElementAccessExpression(ElementAccessExpressionSyntax expression, Block currentBlock);
    private Block BuildImplicitElementAccessExpression(ImplicitElementAccessSyntax expression, Block currentBlock);
    private Block BuildInvocationLikeExpression(ExpressionSyntax parent, Block currentBlock, ExpressionSyntax child, IEnumerable`1<ArgumentSyntax> arguments);
    private Block BuildObjectCreationExpression(ObjectCreationExpressionSyntax expression, Block currentBlock);
    private Block BuildAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax expression, Block currentBlock);
    private Block BuildInvocationExpression(InvocationExpressionSyntax expression, Block currentBlock);
    private Block BuildInterpolatedStringExpression(InterpolatedStringExpressionSyntax expression, Block currentBlock);
    private Block BuildSimpleNestedExpression(ExpressionSyntax parent, Block currentBlock, ExpressionSyntax[] children);
    private Block BuildSimpleNestedExpression(ExpressionSyntax parent, Block currentBlock, IEnumerable`1<ExpressionSyntax> children);
    private Block BuildBinaryExpression(BinaryExpressionSyntax expression, Block currentBlock);
    private Block BuildAssignmentExpression(AssignmentExpressionSyntax expression, Block currentBlock);
    private Block BuildCoalesceAssignmentExpression(AssignmentExpressionSyntax expression, Block currentBlock);
    private Block BuildSimpleAssignmentExpression(AssignmentExpressionSyntax expression, Block currentBlock);
    public static bool IsAssignmentWithSimpleLeftSide(AssignmentExpressionSyntax assignment);
    private Block BuildArrayType(ArrayTypeSyntax arrayType, Block currentBlock);
    private Block BuildIsPatternExpression(IsPatternExpressionSyntaxWrapper isPatternExpression, Block currentBlock);
    private Block BuildPatternExpression(PatternSyntaxWrapper patternSyntaxWrapper, Block currentBlock);
    private Block BuildTupleExpression(TupleExpressionSyntaxWrapper tuple, Block currentBlock);
    private Block BuildVariableDeclaration(VariableDeclarationSyntax declaration, Block currentBlock);
    private Block BuildVariableDeclarator(VariableDeclaratorSyntax variableDeclarator, Block currentBlock);
    internal LockBlock CreateLockBlock(LockStatementSyntax lockStatement, Block successor);
    internal UsingEndBlock CreateUsingFinalizerBlock(UsingStatementSyntax usingStatement, Block successor);
    private Block BuildCondition(ExpressionSyntax expression, Block trueSuccessor, Block falseSuccessor);
    [CompilerGeneratedAttribute]
internal static bool <IsTooComplex>g__IsLambda|15_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <BuildSwitchStatement>g__ContainsDefaultLabel|23_0(SwitchSectionSyntax s);
}
public class SonarAnalyzer.CFG.Sonar.ExitBlock : Block {
}
public class SonarAnalyzer.CFG.Sonar.ForeachCollectionProducerBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private StatementSyntax <ForeachNode>k__BackingField;
    public StatementSyntax ForeachNode { get; }
    internal ForeachCollectionProducerBlock(StatementSyntax foreachNode, Block successor);
    [CompilerGeneratedAttribute]
public StatementSyntax get_ForeachNode();
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
}
public class SonarAnalyzer.CFG.Sonar.ForInitializerBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private ForStatementSyntax <ForNode>k__BackingField;
    public ForStatementSyntax ForNode { get; }
    internal ForInitializerBlock(ForStatementSyntax forNode, Block successor);
    [CompilerGeneratedAttribute]
public ForStatementSyntax get_ForNode();
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
}
public interface SonarAnalyzer.CFG.Sonar.IControlFlowGraph {
    public IEnumerable`1<Block> Blocks { get; }
    public Block EntryBlock { get; }
    public ExitBlock ExitBlock { get; }
    public abstract virtual IEnumerable`1<Block> get_Blocks();
    public abstract virtual Block get_EntryBlock();
    public abstract virtual ExitBlock get_ExitBlock();
}
public class SonarAnalyzer.CFG.Sonar.JumpBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private SyntaxNode <JumpNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <WouldBeSuccessor>k__BackingField;
    public SyntaxNode JumpNode { get; }
    public Block WouldBeSuccessor { get; private set; }
    internal JumpBlock(SyntaxNode jumpNode, Block successor, Block wouldBeSuccessor);
    [CompilerGeneratedAttribute]
public SyntaxNode get_JumpNode();
    [CompilerGeneratedAttribute]
public Block get_WouldBeSuccessor();
    [CompilerGeneratedAttribute]
private void set_WouldBeSuccessor(Block value);
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
    internal virtual void ReplaceSuccessors(Dictionary`2<Block, Block> replacementMapping);
}
public class SonarAnalyzer.CFG.Sonar.LockBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private LockStatementSyntax <LockNode>k__BackingField;
    public LockStatementSyntax LockNode { get; }
    public LockBlock(LockStatementSyntax lockNode, Block successor);
    [CompilerGeneratedAttribute]
public LockStatementSyntax get_LockNode();
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
}
public class SonarAnalyzer.CFG.Sonar.SimpleBlock : Block {
    [CompilerGeneratedAttribute]
private Block <SuccessorBlock>k__BackingField;
    public Block SuccessorBlock { get; internal set; }
    public IReadOnlyList`1<Block> SuccessorBlocks { get; }
    internal SimpleBlock(Block successor);
    [CompilerGeneratedAttribute]
public Block get_SuccessorBlock();
    [CompilerGeneratedAttribute]
internal void set_SuccessorBlock(Block value);
    public virtual IReadOnlyList`1<Block> get_SuccessorBlocks();
    internal virtual void ReplaceSuccessors(Dictionary`2<Block, Block> replacementMapping);
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
}
public class SonarAnalyzer.CFG.Sonar.TemporaryBlock : Block {
    [CompilerGeneratedAttribute]
private Block <SuccessorBlock>k__BackingField;
    public Block SuccessorBlock { get; public set; }
    public IReadOnlyList`1<Block> SuccessorBlocks { get; }
    [CompilerGeneratedAttribute]
public Block get_SuccessorBlock();
    [CompilerGeneratedAttribute]
public void set_SuccessorBlock(Block value);
    public virtual IReadOnlyList`1<Block> get_SuccessorBlocks();
    internal virtual Block GetPossibleNonEmptySuccessorBlock();
}
public class SonarAnalyzer.CFG.Sonar.UsingEndBlock : SimpleBlock {
    [CompilerGeneratedAttribute]
private UsingStatementSyntax <UsingStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxToken> <Identifiers>k__BackingField;
    public UsingStatementSyntax UsingStatement { get; }
    public IEnumerable`1<SyntaxToken> Identifiers { get; }
    public UsingEndBlock(UsingStatementSyntax usingStatement, Block successor);
    [CompilerGeneratedAttribute]
public UsingStatementSyntax get_UsingStatement();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxToken> get_Identifiers();
    private static IEnumerable`1<SyntaxToken> GetIdentifiers(VariableDeclarationSyntax declaration);
    private static IEnumerable`1<SyntaxToken> GetIdentifiers(ExpressionSyntax expression);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.BasicBlockExtensions : object {
    [ExtensionAttribute]
public static bool IsEnclosedIn(BasicBlock block, ControlFlowRegionKind kind);
    [ExtensionAttribute]
public static ControlFlowRegion EnclosingNonLocalLifetimeRegion(BasicBlock block);
    [ExtensionAttribute]
public static ControlFlowRegion EnclosingRegion(BasicBlock block, ControlFlowRegionKind kind);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IFlowAnonymousFunctionOperationWrapper> FlowAnonymousFunctionOperations(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static ControlFlowGraph FindLocalFunctionCfgInScope(ControlFlowGraph cfg, IMethodSymbol localFunction, CancellationToken cancel);
    [ExtensionAttribute]
public static ControlFlowGraph GetLocalFunctionControlFlowGraph(ControlFlowGraph cfg, SyntaxNode localFunction, CancellationToken cancel);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ControlFlowRegionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<BasicBlock> Blocks(ControlFlowRegion region, ControlFlowGraph cfg);
    [ExtensionAttribute]
public static ControlFlowRegion EnclosingNonLocalLifetimeRegion(ControlFlowRegion region);
    [ExtensionAttribute]
public static ControlFlowRegion EnclosingRegionOrSelf(ControlFlowRegion region, ControlFlowRegionKind kind);
    [ExtensionAttribute]
public static ControlFlowRegion EnclosingRegion(ControlFlowRegion region, ControlFlowRegionKind kind);
    [ExtensionAttribute]
public static ControlFlowRegion NestedRegion(ControlFlowRegion region, ControlFlowRegionKind kind);
    [ExtensionAttribute]
public static IEnumerable`1<ControlFlowRegion> ReachableHandlers(ControlFlowRegion tryRegion);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.IOperationExtensions : object {
    [ExtensionAttribute]
public static IOperationWrapperSonar ToSonar(IOperation operation);
    [ExtensionAttribute]
public static IOperationWrapperSonar ToSonar(IOperationWrapper operation);
    [ExtensionAttribute]
public static bool IsOutArgumentReference(IOperation operation);
    [ExtensionAttribute]
public static bool IsAssignmentTarget(IOperationWrapper operation);
    [ExtensionAttribute]
public static bool IsCompoundAssignmentTarget(IOperationWrapper operation);
    [ExtensionAttribute]
public static bool IsOutArgument(IOperationWrapper operation);
    [ExtensionAttribute]
public static bool IsAnyKind(IOperation operation, OperationKind[] kinds);
    [ExtensionAttribute]
public static IOperation RootOperation(IOperation operation);
    [ExtensionAttribute]
public static IOperation ArgumentValue(IInvocationOperationWrapper invocation, string parameterName);
    [ExtensionAttribute]
public static IOperation ArgumentValue(IObjectCreationOperationWrapper objectCreation, string parameterName);
    [ExtensionAttribute]
public static IOperation ArgumentValue(IPropertyReferenceOperationWrapper propertyReference, string parameterName);
    [ExtensionAttribute]
public static IOperation ArgumentValue(IRaiseEventOperationWrapper raiseEvent, string parameterName);
    [ExtensionAttribute]
public static OperationExecutionOrder ToExecutionOrder(IEnumerable`1<IOperation> operations);
    [ExtensionAttribute]
public static OperationExecutionOrder ToReversedExecutionOrder(IEnumerable`1<IOperation> operations);
    [ExtensionAttribute]
public static string Serialize(IOperation operation);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantsAndSelf(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IAnonymousFunctionOperationWrapper> AsAnonymousFunction(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IArgumentOperationWrapper> AsArgument(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IAssignmentOperationWrapper> AsAssignment(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IArrayCreationOperationWrapper> AsArrayCreation(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IConversionOperationWrapper> AsConversion(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IDeclarationExpressionOperationWrapper> AsDeclarationExpression(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IDeclarationPatternOperationWrapper> AsDeclarationPattern(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IFlowCaptureOperationWrapper> AsFlowCapture(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IFlowCaptureReferenceOperationWrapper> AsFlowCaptureReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IInvocationOperationWrapper> AsInvocation(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<ILocalFunctionOperationWrapper> AsLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<ILocalReferenceOperationWrapper> AsLocalReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IIsPatternOperationWrapper> AsIsPattern(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IParameterReferenceOperationWrapper> AsParameterReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IMethodReferenceOperationWrapper> AsMethodReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IObjectCreationOperationWrapper> AsObjectCreation(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IPropertyReferenceOperationWrapper> AsPropertyReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IRecursivePatternOperationWrapper> AsRecursivePattern(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<IArrayElementReferenceOperationWrapper> AsArrayElementReference(IOperation operation);
    [ExtensionAttribute]
public static Nullable`1<ITupleOperationWrapper> AsTuple(IOperation operation);
    [ExtensionAttribute]
public static IAwaitOperationWrapper ToAwait(IOperation operation);
    [ExtensionAttribute]
public static IArgumentOperationWrapper ToArgument(IOperation operation);
    [ExtensionAttribute]
public static IAssignmentOperationWrapper ToAssignment(IOperation operation);
    [ExtensionAttribute]
public static IArrayElementReferenceOperationWrapper ToArrayElementReference(IOperation operation);
    [ExtensionAttribute]
public static IBinaryOperationWrapper ToBinary(IOperation operation);
    [ExtensionAttribute]
public static IBinaryPatternOperationWrapper ToBinaryPattern(IOperation operation);
    [ExtensionAttribute]
public static ICompoundAssignmentOperationWrapper ToCompoundAssignment(IOperation operation);
    [ExtensionAttribute]
public static IConstantPatternOperationWrapper ToConstantPattern(IOperation operation);
    [ExtensionAttribute]
public static IConversionOperationWrapper ToConversion(IOperation operation);
    [ExtensionAttribute]
public static IDeclarationPatternOperationWrapper ToDeclarationPattern(IOperation operation);
    [ExtensionAttribute]
public static IEventReferenceOperationWrapper ToEventReference(IOperation operation);
    [ExtensionAttribute]
public static IFieldReferenceOperationWrapper ToFieldReference(IOperation operation);
    [ExtensionAttribute]
public static IFlowCaptureOperationWrapper ToFlowCapture(IOperation operation);
    [ExtensionAttribute]
public static IFlowCaptureReferenceOperationWrapper ToFlowCaptureReference(IOperation operation);
    [ExtensionAttribute]
public static IIncrementOrDecrementOperationWrapper ToIncrementOrDecrement(IOperation operation);
    [ExtensionAttribute]
public static IInvocationOperationWrapper ToInvocation(IOperation operation);
    [ExtensionAttribute]
public static ILocalReferenceOperationWrapper ToLocalReference(IOperation operation);
    [ExtensionAttribute]
public static IMemberReferenceOperationWrapper ToMemberReference(IOperation operation);
    [ExtensionAttribute]
public static IMethodReferenceOperationWrapper ToMethodReference(IOperation operation);
    [ExtensionAttribute]
public static INegatedPatternOperationWrapper ToNegatedPattern(IOperation operation);
    [ExtensionAttribute]
public static IObjectCreationOperationWrapper ToObjectCreation(IOperation operation);
    [ExtensionAttribute]
public static IParameterReferenceOperationWrapper ToParameterReference(IOperation operation);
    [ExtensionAttribute]
public static IPropertyReferenceOperationWrapper ToPropertyReference(IOperation operation);
    [ExtensionAttribute]
public static IRecursivePatternOperationWrapper ToRecursivePattern(IOperation operation);
    [ExtensionAttribute]
public static IRelationalPatternOperationWrapper ToRelationalPattern(IOperation operation);
    [ExtensionAttribute]
public static ITypePatternOperationWrapper ToTypePattern(IOperation operation);
    [ExtensionAttribute]
public static ITupleOperationWrapper ToTuple(IOperation operation);
    [ExtensionAttribute]
public static IUnaryOperationWrapper ToUnary(IOperation operation);
    [ExtensionAttribute]
public static IOperation UnwrapConversion(IOperation operation);
    [IteratorStateMachineAttribute("SonarAnalyzer.Extensions.IOperationExtensions/<Descendants>d__65")]
private static IEnumerable`1<IOperation> Descendants(IOperation operation, bool includeSelf);
    private static IOperation ArgumentValue(ImmutableArray`1<IOperation> arguments, string parameterName);
    private static string OperationPrefix(IOperation op);
    private static string OperationSuffix(IOperation op);
    [ExtensionAttribute]
private static Nullable`1<T> As(IOperation operation, OperationKind kind, Func`2<IOperation, T> fromOperation);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.IsPatternExpressionSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(IsPatternExpressionSyntaxWrapper isPatternWrapper);
    [ExtensionAttribute]
public static bool IsNot(IsPatternExpressionSyntaxWrapper isPatternWrapper);
    [ExtensionAttribute]
public static bool IsNotNull(IsPatternExpressionSyntaxWrapper isPatternWrapper);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.PatternSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(PatternSyntaxWrapper patternSyntaxWrapper);
    [ExtensionAttribute]
public static bool IsNot(PatternSyntaxWrapper patternSyntaxWrapper);
    [ExtensionAttribute]
public static SyntaxNode RemoveParentheses(PatternSyntaxWrapper patternSyntaxWrapper);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.UnaryPatternSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static bool IsNot(UnaryPatternSyntaxWrapper unaryPatternSyntaxWrapper);
    [ExtensionAttribute]
public static bool IsNotNull(UnaryPatternSyntaxWrapper unaryPatternSyntaxWrapper);
}
public class SonarAnalyzer.Helpers.OperationExecutionOrder : object {
    private IEnumerable`1<IOperation> operations;
    private bool reverseOrder;
    public OperationExecutionOrder(IEnumerable`1<IOperation> operations, bool reverseOrder);
    public sealed virtual IEnumerator`1<IOperationWrapperSonar> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.StringExtensions : object {
    [IteratorStateMachineAttribute("SonarAnalyzer.Helpers.StringExtensions/<SplitCamelCaseToWords>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<string> SplitCamelCaseToWords(string name);
    [CompilerGeneratedAttribute]
internal static bool <SplitCamelCaseToWords>g__IsFollowedByLower|0_0(int i, <>c__DisplayClass0_0& );
}
internal static class SonarAnalyzer.Signing : object {
    private static string PublicKey;
    internal static string InternalsVisibleToPublicKey;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
