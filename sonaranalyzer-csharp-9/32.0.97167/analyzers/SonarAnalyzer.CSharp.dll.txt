[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
public static class Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsWrittenTo(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ExpressionSyntax GetExpressionToAnalyzeForWrites(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrArrow(ExpressionSyntax name);
    [ExtensionAttribute]
public static bool IsAnyMemberAccessExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsMemberBindingExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOnlyWrittenTo(ExpressionSyntax expression);
    private static bool IsExpressionOfArgumentInDeconstruction(ExpressionSyntax expr);
    [ExtensionAttribute]
public static bool IsInOutContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsAttributeNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression, SyntaxNode& refParent);
    [ExtensionAttribute]
public static bool IsOperandOfIncrementOrDecrementExpression(ExpressionSyntax expression);
}
[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetParentConditionalAccessExpression(SyntaxNode node);
    [ExtensionAttribute]
public static ConditionalAccessExpressionSyntax GetRootConditionalAccessExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLeftSideOfAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind, T& result);
    [ExtensionAttribute]
public static bool IsLeftSideOfAnyAssignExpression(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnyAssignExpression(SyntaxNode node);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Roslyn.Utilities.SonarAnalyzer.Shared.LoggingFrameworkMethods : object {
    public static HashSet`1<string> MicrosoftExtensionsLogging;
    public static HashSet`1<string> CastleCoreOrCommonCore;
    public static HashSet`1<string> Log4NetILog;
    public static HashSet`1<string> Log4NetILogExtensions;
    public static HashSet`1<string> Serilog;
    public static HashSet`1<string> NLogLoggingMethods;
    public static HashSet`1<string> NLogILoggerBase;
    private static LoggingFrameworkMethods();
}
internal static class SonarAnalyzer.Common.DescriptorFactory : object {
    public static DiagnosticDescriptor Create(string id, string messageFormat, Nullable`1<bool> isEnabledByDefault, bool fadeOutCode);
}
internal static class SonarAnalyzer.Common.SyntaxConstants : object {
    public static string Discard;
    public static string Private;
    public static string Protected;
    public static string Internal;
}
public class SonarAnalyzer.Common.Walkers.CatchLoggingInvocationWalker : SafeCSharpSyntaxWalker {
    internal SemanticModel Model;
    private bool isFirstCatchClauseVisited;
    private bool hasWhenFilterWithDeclarations;
    internal ISymbol CaughtException;
    [CompilerGeneratedAttribute]
private bool <IsExceptionLogged>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <LoggingInvocationWithException>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<InvocationExpressionSyntax> <LoggingInvocationsWithoutException>k__BackingField;
    private static ImmutableArray`1<LoggingInvocationDescriptor> LoggingInvocationDescriptors;
    public bool IsExceptionLogged { get; private set; }
    public InvocationExpressionSyntax LoggingInvocationWithException { get; private set; }
    public IList`1<InvocationExpressionSyntax> LoggingInvocationsWithoutException { get; }
    public CatchLoggingInvocationWalker(SemanticModel model);
    private static CatchLoggingInvocationWalker();
    [CompilerGeneratedAttribute]
public bool get_IsExceptionLogged();
    [CompilerGeneratedAttribute]
private void set_IsExceptionLogged(bool value);
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_LoggingInvocationWithException();
    [CompilerGeneratedAttribute]
private void set_LoggingInvocationWithException(InvocationExpressionSyntax value);
    [CompilerGeneratedAttribute]
public IList`1<InvocationExpressionSyntax> get_LoggingInvocationsWithoutException();
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    private static ISymbol GetArgumentSymbolDerivedFromException(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsLoggingInvocation(InvocationExpressionSyntax invocation, SemanticModel model);
    private static bool IsLoggingInvocation(InvocationExpressionSyntax invocation, SemanticModel model, ICollection`1<string> methodNames, KnownType containingType, bool checkDerivedTypes);
}
internal class SonarAnalyzer.Common.Walkers.MutedSyntaxWalker : CSharpSyntaxWalker {
    private static SyntaxKind[] RootKinds;
    private SemanticModel model;
    private SyntaxNode root;
    private ISymbol[] symbols;
    private bool isMuted;
    public MutedSyntaxWalker(SemanticModel model, SyntaxNode node);
    public MutedSyntaxWalker(SemanticModel model, SyntaxNode node, ISymbol[] symbols);
    private static MutedSyntaxWalker();
    public bool IsMuted();
    public virtual void Visit(SyntaxNode node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
}
internal class SonarAnalyzer.Common.Walkers.ParameterValidationInMethodWalker : SafeCSharpSyntaxWalker {
    private static ISet`1<SyntaxKind> SubMethodEquivalents;
    private SemanticModel semanticModel;
    private List`1<SecondaryLocation> argumentExceptionLocations;
    protected bool keepWalking;
    public IEnumerable`1<SecondaryLocation> ArgumentExceptionLocations { get; }
    public ParameterValidationInMethodWalker(SemanticModel semanticModel);
    private static ParameterValidationInMethodWalker();
    public IEnumerable`1<SecondaryLocation> get_ArgumentExceptionLocations();
    public virtual void Visit(SyntaxNode node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
}
public class SonarAnalyzer.Common.Walkers.SafeCSharpSyntaxWalker : CSharpSyntaxWalker {
    protected SafeCSharpSyntaxWalker(SyntaxWalkerDepth depth);
    public sealed virtual bool SafeVisit(SyntaxNode syntaxNode);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax Get(ArgumentListSyntax argumentList, int index);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
internal static Nullable`1<int> GetArgumentIndex(ArgumentSyntax argument);
    [ExtensionAttribute]
internal static IEnumerable`1<ArgumentSyntax> GetArgumentsOfKnownType(SeparatedSyntaxList`1<ArgumentSyntax> syntaxList, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> GetSymbolsOfKnownType(SeparatedSyntaxList`1<ArgumentSyntax> syntaxList, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
internal static bool NameIs(ArgumentSyntax argument, string name);
    [ExtensionAttribute]
internal static bool IsInTupleAssignmentTarget(ArgumentSyntax argument);
    [ExtensionAttribute]
internal static Nullable`1<TupleExpressionSyntaxWrapper> OutermostTuple(ArgumentSyntax argument);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.AssignmentExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<AssignmentMapping> MapAssignmentArguments(AssignmentExpressionSyntax assignment);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> AssignmentTargets(AssignmentExpressionSyntax assignment);
    private static NestingMatch MapTupleElements(Builder<AssignmentMapping> arrayBuilder, TupleExpressionSyntaxWrapper left, TupleExpressionSyntaxWrapper right);
    private static NestingMatch MapDesignationElements(Builder<AssignmentMapping> arrayBuilder, ParenthesizedVariableDesignationSyntaxWrapper left, TupleExpressionSyntaxWrapper right);
    private static NestingMatch HandleTupleNesting(Builder<AssignmentMapping> arrayBuilder, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression);
    private static NestingMatch HandleDesignationNesting(Builder<AssignmentMapping> arrayBuilder, VariableDesignationSyntaxWrapper leftVar, ExpressionSyntax rightExpression);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.AttributeListSyntaxExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<AttributeSyntax> GetAttributes(SyntaxList`1<AttributeListSyntax> attributeLists, KnownType attributeKnownType, SemanticModel semanticModel);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeSyntax> GetAttributes(SyntaxList`1<AttributeListSyntax> attributeLists, ImmutableArray`1<KnownType> attributeKnownTypes, SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.AttributeSyntaxExtensions : object {
    private static int AttributeLength;
    [ExtensionAttribute]
public static bool IsKnownType(AttributeSyntax attribute, ImmutableArray`1<KnownType> attributeKnownTypes, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsKnownType(AttributeSyntax attribute, KnownType knownType, SemanticModel semanticModel);
    private static string GetShortNameWithoutAttributeSuffix(KnownType knownType);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.AwaitExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax AwaitedExpressionWithoutConfigureAwait(AwaitExpressionSyntax awaitExpression);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.BaseArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
internal static ArgumentSyntax GetArgumentByName(BaseArgumentListSyntax list, string name);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.BaseMethodDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetBodyDescendantNodes(BaseMethodDeclarationSyntax method);
    [ExtensionAttribute]
public static bool IsStatic(BaseMethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool IsExtern(BaseMethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool HasBodyOrExpressionBody(BaseMethodDeclarationSyntax node);
    [ExtensionAttribute]
public static SyntaxNode GetBodyOrExpressionBody(BaseMethodDeclarationSyntax node);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.BlockSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(BlockSyntax block, bool treatCommentsAsContent, bool treatConditionalCompilationAsContent);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.CompilationUnitSyntaxExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetTopLevelMainBody(CompilationUnitSyntax compilationUnit);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodDeclaration> GetMethodDeclarations(CompilationUnitSyntax compilationUnitSyntax);
    [ExtensionAttribute]
public static bool IsTopLevelMain(CompilationUnitSyntax compilationUnit);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.CSharpCompilationExtensions : object {
    [ExtensionAttribute]
internal static bool IsCoalesceAssignmentSupported(Compilation compilation);
    [ExtensionAttribute]
internal static bool IsTargetTypeConditionalSupported(Compilation compilation);
    [ExtensionAttribute]
internal static bool IsLambdaDiscardParameterSupported(Compilation compilation);
    [ExtensionAttribute]
internal static bool IsAtLeastLanguageVersion(Compilation compilation, LanguageVersion languageVersion);
    [ExtensionAttribute]
internal static LanguageVersion GetLanguageVersion(Compilation compilation);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ExpressionSyntaxExtensions : object {
    private static ISet`1<SyntaxKind> EqualsOrNotEquals;
    private static ExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static ExpressionSyntax RemoveParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool CanBeNull(ExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static ExpressionSyntax RemoveConditionalAccess(ExpressionSyntax node);
    [ExtensionAttribute]
public static bool TryGetExpressionComparedToNull(ExpressionSyntax expression, ExpressionSyntax& compared, Boolean& isAffirmative);
    [ExtensionAttribute]
public static ExpressionSyntax GetLeftOfDot(ExpressionSyntax expression);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.IAnalyzerConfigurationExtensions : object {
    [ExtensionAttribute]
public static bool UseSonarCfg(IAnalyzerConfiguration configuration);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.IFieldSymbolExtensions : object {
    [ExtensionAttribute]
internal static bool IsNonStaticNonPublicDisposableField(IFieldSymbol fieldSymbol, LanguageVersion languageVersion);
    [ExtensionAttribute]
private static bool IsDisposable(IFieldSymbol fieldSymbol, LanguageVersion languageVersion);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ILocalSymbolExtensions : object {
    private static Func`2<ILocalSymbol, RefKind> RefKindAccessor;
    private static ILocalSymbolExtensions();
    [ExtensionAttribute]
public static RefKind RefKind(ILocalSymbol symbol);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsModuleInitializer(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsGetTypeCall(IMethodSymbol invokedMethod);
    [ExtensionAttribute]
public static SyntaxNode ImplementationSyntax(IMethodSymbol method);
    private static bool IsObjectOrType(ITypeSymbol namedType);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.InterpolatedStringExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static string GetContentsText(InterpolatedStringExpressionSyntax interpolatedStringExpression);
    [ExtensionAttribute]
public static bool TryGetInterpolatedTextValue(InterpolatedStringExpressionSyntax interpolatedStringExpression, SemanticModel semanticModel, String& interpolatedValue);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.InvocationExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsMemberAccessOnKnownType(InvocationExpressionSyntax invocation, string identifierName, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> GetArgumentSymbolsOfKnownType(InvocationExpressionSyntax invocation, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
internal static bool HasExactlyNArguments(InvocationExpressionSyntax invocation, int count);
    [ExtensionAttribute]
internal static bool IsGetTypeCall(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    [ExtensionAttribute]
internal static bool IsOnBase(InvocationExpressionSyntax invocation);
    [ExtensionAttribute]
internal static bool IsEqualTo(InvocationExpressionSyntax first, InvocationExpressionSyntax second, SemanticModel model);
    [ExtensionAttribute]
internal static bool TryGetOperands(InvocationExpressionSyntax invocation, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
internal static Nullable`1<SyntaxToken> GetMethodCallIdentifier(InvocationExpressionSyntax invocation);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ISymbolExtensions : object {
    private static SyntaxKind[] DeclarationsTypesWithPrimaryConstructor;
    private static ISymbolExtensions();
    [ExtensionAttribute]
public static bool HasConstraint(ISymbol symbol, SymbolicConstraint constraint, ProgramState programState);
    [ExtensionAttribute]
public static ProgramState SetConstraint(ISymbol symbol, SymbolicConstraint constraint, ProgramState programState);
    [ExtensionAttribute]
public static ProgramState RemoveConstraint(ISymbol symbol, SymbolicConstraint constraint, ProgramState programState);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetLocationNodes(ISymbol symbol, SyntaxNode node);
    private static IEnumerable`1<SyntaxNode> GetDescendantNodes(Location location, SyntaxNode invocation);
    [ExtensionAttribute]
public static Nullable`1<SyntaxToken> FirstDeclaringReferenceIdentifier(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxToken> DeclaringReferenceIdentifiers(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPrimaryConstructor(ISymbol symbol);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ITupleOperationWrapperExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> AllElements(ITupleOperationWrapper tuple);
    [CompilerGeneratedAttribute]
internal static void <AllElements>g__CollectTupleElements|0_0(ITupleOperationWrapper tuple, <>c__DisplayClass0_0& );
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
internal static bool IsDisposableRefStruct(ITypeSymbol symbol, LanguageVersion languageVersion);
    [ExtensionAttribute]
internal static bool IsRefStruct(ITypeSymbol symbol);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.LanguageVersionExtensions : object {
    [ExtensionAttribute]
internal static bool IsAtLeast(LanguageVersion left, LanguageVersion right);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.LocalFunctionStatementSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static bool IsTopLevel(LocalFunctionStatementSyntaxWrapper localFunction);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.MemberAccessExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsMemberAccessOnKnownType(MemberAccessExpressionSyntax memberAccess, string name, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsPtrZero(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.MethodDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool ThrowsOrReturnsNull(MethodDeclarationSyntax syntaxNode);
    [ExtensionAttribute]
public static bool IsExtensionMethod(BaseMethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool HasReturnTypeVoid(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool IsDeconstructor(MethodDeclarationSyntax methodDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <IsDeconstructor>g__AllParametersHaveModifierOut|3_0(MethodDeclarationSyntax methodDeclaration);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ObjectCreationExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsKnownType(ObjectCreationExpressionSyntax objectCreation, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
public static Nullable`1<SyntaxToken> GetObjectCreationTypeIdentifier(ObjectCreationExpressionSyntax objectCreation);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ParameterSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsString(ParameterSyntax parameterSyntax);
    private static bool IsString(string parameterTypeName);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.PropertyDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool IsAutoProperty(PropertyDeclarationSyntax propertyDeclaration);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SonarAnalysisContextExtensions : object {
    [ExtensionAttribute]
public static void RegisterNodeAction(SonarAnalysisContext context, Action`1<SonarSyntaxNodeReportingContext> action, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static void RegisterNodeAction(SonarParametrizedAnalysisContext context, Action`1<SonarSyntaxNodeReportingContext> action, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static void RegisterNodeAction(SonarCompilationStartAnalysisContext context, Action`1<SonarSyntaxNodeReportingContext> action, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static void RegisterTreeAction(SonarAnalysisContext context, Action`1<SonarSyntaxTreeReportingContext> action);
    [ExtensionAttribute]
public static void RegisterTreeAction(SonarParametrizedAnalysisContext context, Action`1<SonarSyntaxTreeReportingContext> action);
    [ExtensionAttribute]
public static void RegisterSemanticModelAction(SonarParametrizedAnalysisContext context, Action`1<SonarSemanticModelReportingContext> action);
    [ExtensionAttribute]
public static void RegisterSemanticModelAction(SonarAnalysisContext context, Action`1<SonarSemanticModelReportingContext> action);
    [ExtensionAttribute]
public static void RegisterCodeBlockStartAction(SonarAnalysisContext context, Action`1<SonarCodeBlockStartAnalysisContext`1<SyntaxKind>> action);
    [ExtensionAttribute]
public static void ReportIssue(SonarCompilationReportingContextBase`1<TContext> context, DiagnosticDescriptor rule, SyntaxNode locationSyntax, String[] messageArgs);
    [ExtensionAttribute]
public static void ReportIssue(SonarCompilationReportingContextBase`1<TContext> context, DiagnosticDescriptor rule, SyntaxToken locationToken, String[] messageArgs);
    [ExtensionAttribute]
public static void ReportIssue(SonarCompilationReportingContextBase`1<TContext> context, DiagnosticDescriptor rule, Location location, String[] messageArgs);
    [ExtensionAttribute]
public static void ReportIssue(SonarCompilationReportingContextBase`1<TContext> context, DiagnosticDescriptor rule, Location primaryLocation, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SonarSyntaxNodeAnalysisContextExtensions : object {
    [ExtensionAttribute]
public static bool IsTopLevelMain(SonarSyntaxNodeReportingContext context);
    [ExtensionAttribute]
public static bool IsInExpressionTree(SonarSyntaxNodeReportingContext context);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.StatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<StatementSyntax> GetPreviousStatements(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetPrecedingStatement(StatementSyntax statement);
    [ExtensionAttribute]
private static StatementSyntax GetPrecedingStatement(StatementSyntax statement, IEnumerable`1<SyntaxNode> statementSiblingNodes);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.SwitchExpressionSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static bool HasDiscardPattern(SwitchExpressionSyntaxWrapper switchExpression);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SyntaxNodeExtensionsCSharp : object {
    private static ControlFlowGraphCache CfgCache;
    private static SyntaxKind[] ParenthesizedNodeKinds;
    private static SyntaxKind[] EnclosingScopeSyntaxKinds;
    private static SyntaxKind[] NegationOrConditionEnclosingSyntaxKinds;
    private static SyntaxNodeExtensionsCSharp();
    [ExtensionAttribute]
public static ControlFlowGraph CreateCfg(SyntaxNode node, SemanticModel model, CancellationToken cancel);
    [ExtensionAttribute]
public static bool ContainsConditionalConstructs(SyntaxNode node);
    [ExtensionAttribute]
public static object FindConstantValue(SyntaxNode node, SemanticModel semanticModel);
    [ExtensionAttribute]
public static string FindStringConstant(SyntaxNode node, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsPartOfBinaryNegationOrCondition(SyntaxNode node);
    [ExtensionAttribute]
public static string GetDeclarationTypeName(SyntaxNode node);
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ArrowExpressionBody(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode RemoveParentheses(SyntaxNode expression);
    [ExtensionAttribute]
public static SyntaxNode WalkUpParentheses(SyntaxNode node);
    [ExtensionAttribute]
public static Nullable`1<SyntaxToken> GetIdentifier(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindAssignmentComplement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel model);
    [ExtensionAttribute]
public static BaseArgumentListSyntax ArgumentList(SyntaxNode node);
    [ExtensionAttribute]
public static ParameterListSyntax ParameterList(SyntaxNode node);
    [ExtensionAttribute]
public static BlockSyntax GetBody(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetInitializer(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxTokenList GetModifiers(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTrue(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFalse(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode EnclosingScope(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <FindAssignmentComplement>g__OtherSideOfAssignment|14_2(SyntaxNode oneSide, AssignmentExpressionSyntax assignment);
    [CompilerGeneratedAttribute]
internal static Stack`1<PathPosition> <FindAssignmentComplement>g__GetNestingPathFromNodeToOutermost|14_3(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindAssignmentComplement>g__FindMatchingNestedNode|14_4(Stack`1<PathPosition> pathFromOutermostToGivenNode, SyntaxNode outermostParenthesesToMatch);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindAssignmentComplement>g__PushPathPositionForTuple|14_5(Stack`1<PathPosition> pathPositions, TupleExpressionSyntaxWrapper tuple, ArgumentSyntax argument);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindAssignmentComplement>g__PushPathPositionForParenthesizedDesignation|14_6(Stack`1<PathPosition> pathPositions, ParenthesizedVariableDesignationSyntaxWrapper parenthesizedDesignation, VariableDesignationSyntaxWrapper variable);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindAssignmentComplement>g__StepDownInParenthesizedVariableDesignation|14_7(ParenthesizedVariableDesignationSyntaxWrapper parenthesizedVariableDesignation, PathPosition expectedPathPosition);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindAssignmentComplement>g__StepDownInTuple|14_8(TupleExpressionSyntaxWrapper tupleExpression, PathPosition expectedPathPosition);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__TakesExpressionTree|15_4(SymbolInfo info);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SyntaxNodeExtensionsShared : object {
    [ExtensionAttribute]
public static bool ContainsGetOrSetOnDependencyProperty(SyntaxNode node, Compilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<StatementSyntax> GetPreviousStatementsCurrentBlock(SyntaxNode expression);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static SyntaxNode GetBindableParent(SyntaxToken token);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SyntaxTokenListExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SyntaxToken> Find(SyntaxTokenList tokenList, SyntaxKind kind);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.TupleExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ArgumentSyntax> AllArguments(TupleExpressionSyntaxWrapper tupleExpression);
    [CompilerGeneratedAttribute]
internal static void <AllArguments>g__CollectTupleElements|0_0(SeparatedSyntaxList`1<ArgumentSyntax> arguments, <>c__DisplayClass0_0& );
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.TypeDeclarationSyntaxExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodDeclaration> GetMethodDeclarations(TypeDeclarationSyntax typeDeclaration);
    private static IEnumerable`1<IMethodDeclaration> GetLocalFunctions(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static IMethodSymbol PrimaryConstructor(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel);
    [ExtensionAttribute]
public static ParameterListSyntax ParameterList(TypeDeclarationSyntax typeDeclaration);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.VariableDesignationSyntaxWrapperExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<SingleVariableDesignationSyntaxWrapper> AllVariables(VariableDesignationSyntaxWrapper variableDesignation);
    [CompilerGeneratedAttribute]
internal static void <AllVariables>g__CollectVariables|0_0(VariableDesignationSyntaxWrapper variableDesignation, <>c__DisplayClass0_0& );
}
internal class SonarAnalyzer.Helpers.AttributeSyntaxSymbolMapping : object {
    [CompilerGeneratedAttribute]
private AttributeSyntax <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <Symbol>k__BackingField;
    public AttributeSyntax SyntaxNode { get; }
    public IMethodSymbol Symbol { get; }
    private AttributeSyntaxSymbolMapping(AttributeSyntax syntaxNode, IMethodSymbol symbol);
    [CompilerGeneratedAttribute]
public AttributeSyntax get_SyntaxNode();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Symbol();
    public static IEnumerable`1<AttributeSyntaxSymbolMapping> GetAttributesForParameter(ParameterSyntax parameter, SemanticModel semanticModel);
}
public class SonarAnalyzer.Helpers.CSharpAssignmentFinder : AssignmentFinder {
    protected virtual SyntaxNode GetTopMostContainingMethod(SyntaxNode node);
    protected virtual bool IsAssignmentToIdentifier(SyntaxNode node, string identifierName, bool anyAssignmentKind, SyntaxNode& rightExpression);
    private static SyntaxNode IdentifierMutation(SyntaxNode mutation, string identifierName);
    protected virtual bool IsIdentifierDeclaration(SyntaxNode node, string identifierName, SyntaxNode& initializer);
    protected virtual bool IsLoop(SyntaxNode node);
}
internal class SonarAnalyzer.Helpers.CSharpAttributeParameterLookup : MethodParameterLookupBase`1<AttributeArgumentSyntax> {
    public CSharpAttributeParameterLookup(AttributeSyntax attribute, IMethodSymbol methodSymbol);
    protected virtual SyntaxNode Expression(AttributeArgumentSyntax argument);
    protected virtual Nullable`1<SyntaxToken> GetNameColonIdentifier(AttributeArgumentSyntax argument);
    protected virtual Nullable`1<SyntaxToken> GetNameEqualsIdentifier(AttributeArgumentSyntax argument);
}
public class SonarAnalyzer.Helpers.CSharpBuilderPatternCondition : BuilderPatternCondition`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    public CSharpBuilderPatternCondition(bool constructorIsSafe, BuilderPatternDescriptor`2[] descriptors);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode GetExpression(InvocationExpressionSyntax node);
    protected virtual string GetIdentifierName(InvocationExpressionSyntax node);
    protected virtual bool IsMemberAccess(SyntaxNode node, SyntaxNode& memberAccessExpression);
    protected virtual bool IsObjectCreation(SyntaxNode node);
    protected virtual bool IsIdentifier(SyntaxNode node, String& identifierName);
}
public class SonarAnalyzer.Helpers.CSharpConstantValueFinder : ConstantValueFinder`2<IdentifierNameSyntax, VariableDeclaratorSyntax> {
    public CSharpConstantValueFinder(SemanticModel semanticModel);
    protected virtual string IdentifierName(IdentifierNameSyntax node);
    protected virtual SyntaxNode InitializerValue(VariableDeclaratorSyntax node);
    protected virtual VariableDeclaratorSyntax VariableDeclarator(SyntaxNode node);
    protected virtual bool IsPtrZero(SyntaxNode node);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.CSharpDebugOnlyCodeHelper : object {
    public static bool IsDebugString(string text);
    [ExtensionAttribute]
public static bool IsInDebugBlock(SyntaxNode node);
    public static bool IsCallerInConditionalDebug(SyntaxNode node, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsConditionalDebugMethod(IMethodSymbol methodSymbol);
    private static IMethodSymbol FindContainingMethod(SyntaxNode node, SemanticModel semanticModel);
}
internal static class SonarAnalyzer.Helpers.CSharpEquivalenceChecker : object {
    public static bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public static bool AreEquivalent(SyntaxList`1<SyntaxNode> nodeList1, SyntaxList`1<SyntaxNode> nodeList2);
    private static bool NodeComparator(SyntaxNode node1, SyntaxNode node2);
    private static NullCheck NullCheckState(SyntaxNode node, bool isPositive);
    private static SyntaxNode NullCheckExpression(BinaryExpressionSyntax binary);
    private static NullCheck NullCheckPattern(SyntaxNode expression, SyntaxNode pattern, bool isPositive);
}
internal class SonarAnalyzer.Helpers.CSharpExpressionNumericConverter : ExpressionNumericConverterBase`2<LiteralExpressionSyntax, PrefixUnaryExpressionSyntax> {
    private static ISet`1<SyntaxKind> SupportedOperatorTokens;
    private static CSharpExpressionNumericConverter();
    protected virtual object TokenValue(LiteralExpressionSyntax literalExpression);
    protected virtual SyntaxNode Operand(PrefixUnaryExpressionSyntax unaryExpression);
    protected virtual bool IsSupportedOperator(PrefixUnaryExpressionSyntax unaryExpression);
    protected virtual bool IsMinusOperator(PrefixUnaryExpressionSyntax unaryExpression);
    protected virtual SyntaxNode RemoveParentheses(SyntaxNode expression);
}
internal class SonarAnalyzer.Helpers.CSharpFacade : object {
    private static Lazy`1<CSharpFacade> Singleton;
    private static Lazy`1<AssignmentFinder> AssignmentFinderLazy;
    private static Lazy`1<IExpressionNumericConverter> ExpressionNumericConverterLazy;
    private static Lazy`1<SyntaxFacade`1<SyntaxKind>> SyntaxLazy;
    private static Lazy`1<ISyntaxKindFacade`1<SyntaxKind>> SyntaxKindLazy;
    private static Lazy`1<ITrackerFacade`1<SyntaxKind>> TrackerLazy;
    public AssignmentFinder AssignmentFinder { get; }
    public StringComparison NameComparison { get; }
    public StringComparer NameComparer { get; }
    public GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    public IExpressionNumericConverter ExpressionNumericConverter { get; }
    public SyntaxFacade`1<SyntaxKind> Syntax { get; }
    public ISyntaxKindFacade`1<SyntaxKind> SyntaxKind { get; }
    public ITrackerFacade`1<SyntaxKind> Tracker { get; }
    public static CSharpFacade Instance { get; }
    private static CSharpFacade();
    public sealed virtual AssignmentFinder get_AssignmentFinder();
    public sealed virtual StringComparison get_NameComparison();
    public sealed virtual StringComparer get_NameComparer();
    public sealed virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    public sealed virtual IExpressionNumericConverter get_ExpressionNumericConverter();
    public sealed virtual SyntaxFacade`1<SyntaxKind> get_Syntax();
    public sealed virtual ISyntaxKindFacade`1<SyntaxKind> get_SyntaxKind();
    public sealed virtual ITrackerFacade`1<SyntaxKind> get_Tracker();
    public static CSharpFacade get_Instance();
    public sealed virtual DiagnosticDescriptor CreateDescriptor(string id, string messageFormat, Nullable`1<bool> isEnabledByDefault, bool fadeOutCode);
    public sealed virtual object FindConstantValue(SemanticModel model, SyntaxNode node);
    public sealed virtual IMethodParameterLookup MethodParameterLookup(SyntaxNode invocation, IMethodSymbol methodSymbol);
    public sealed virtual IMethodParameterLookup MethodParameterLookup(SyntaxNode invocation, SemanticModel semanticModel);
    public sealed virtual string GetName(SyntaxNode expression);
}
internal class SonarAnalyzer.Helpers.CSharpGeneratedCodeRecognizer : GeneratedCodeRecognizer {
    private static Lazy`1<CSharpGeneratedCodeRecognizer> Lazy;
    public static CSharpGeneratedCodeRecognizer Instance { get; }
    private static CSharpGeneratedCodeRecognizer();
    public static CSharpGeneratedCodeRecognizer get_Instance();
    protected virtual bool IsTriviaComment(SyntaxTrivia trivia);
    protected virtual string GetAttributeName(SyntaxNode node);
}
internal static class SonarAnalyzer.Helpers.CSharpIfDirectiveHelper : object {
    public static IEnumerable`1<string> GetActiveConditionalCompilationSections(SyntaxNode node);
    private static string FindDirectiveName(BranchingDirectiveTriviaSyntax directiveTriviaSyntax);
    private static void SafePop(Stack`1<BranchingDirectiveTriviaSyntax> stack);
    private static IList`1<DirectiveTriviaSyntax> CollectPrecedingDirectiveSyntax(SyntaxNode node);
}
internal class SonarAnalyzer.Helpers.CSharpMethodParameterLookup : MethodParameterLookupBase`1<ArgumentSyntax> {
    public CSharpMethodParameterLookup(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    public CSharpMethodParameterLookup(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol);
    public CSharpMethodParameterLookup(BaseArgumentListSyntax argumentList, SemanticModel semanticModel);
    public CSharpMethodParameterLookup(BaseArgumentListSyntax argumentList, IMethodSymbol methodSymbol);
    protected virtual SyntaxNode Expression(ArgumentSyntax argument);
    protected virtual Nullable`1<SyntaxToken> GetNameColonIdentifier(ArgumentSyntax argument);
    protected virtual Nullable`1<SyntaxToken> GetNameEqualsIdentifier(ArgumentSyntax argument);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.CSharpNavigationHelper : object {
    [ExtensionAttribute]
public static IList`1<IfStatementSyntax> GetPrecedingIfsInConditionChain(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IEnumerable`1<StatementSyntax> GetPrecedingStatementsInConditionChain(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IEnumerable`1<ExpressionSyntax> GetPrecedingConditionsInConditionChain(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IEnumerable`1<SwitchSectionSyntax> GetPrecedingSections(SwitchSectionSyntax caseStatement);
}
internal static class SonarAnalyzer.Helpers.CSharpOverloadHelper : object {
    public static bool HasOverloadWithType(InvocationExpressionSyntax invocation, SemanticModel semanticModel, ImmutableArray`1<KnownType> types);
    private static bool SameParametersExceptWantedType(IMethodSymbol possibleOverload, IMethodSymbol invocationMethodSymbol, ImmutableArray`1<KnownType> types);
    private static IMethodSymbol ConstructTypedPossibleOverload(IMethodSymbol possibleOverload, IMethodSymbol invocationMethodSymbol);
    public static bool IsCompatibleOverload(InvocationExpressionSyntax invocation, IMethodSymbol m);
    public static IMethodSymbol GetInvocationParameters(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool VerifyCompatibility(IList`1<IParameterSymbol> invocationParameters, IList`1<IParameterSymbol> overloadCandidateParameters, IParameterSymbol paramsParameter);
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <VerifyCompatibility>g__GetParamsElementType|5_0(ITypeSymbol typeSymbol);
}
internal class SonarAnalyzer.Helpers.CSharpRemovableDeclarationCollector : RemovableDeclarationCollectorBase`3<BaseTypeDeclarationSyntax, BaseTypeDeclarationSyntax, SyntaxKind> {
    public CSharpRemovableDeclarationCollector(INamedTypeSymbol namedType, Compilation compilation);
    protected virtual IEnumerable`1<SyntaxNode> SelectMatchingDeclarations(NodeAndModel`1<BaseTypeDeclarationSyntax> container, ISet`1<SyntaxKind> kinds);
    public virtual IEnumerable`1<NodeSymbolAndModel`2<SyntaxNode, ISymbol>> GetRemovableFieldLikeDeclarations(ISet`1<SyntaxKind> kinds, Accessibility maxAccessibility);
    internal virtual BaseTypeDeclarationSyntax GetOwnerOfSubnodes(BaseTypeDeclarationSyntax node);
    public static bool IsNodeContainerTypeDeclaration(SyntaxNode node);
    private static bool IsNodeStructOrClassOrRecordDeclaration(SyntaxNode node);
}
public class SonarAnalyzer.Helpers.CsharpStringInterpolationConstantValueResolver : StringInterpolationConstantValueResolver`5<SyntaxKind, InterpolatedStringExpressionSyntax, InterpolatedStringContentSyntax, InterpolationSyntax, InterpolatedStringTextSyntax> {
    private static Lazy`1<CsharpStringInterpolationConstantValueResolver> Singleton;
    public static CsharpStringInterpolationConstantValueResolver Instance { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static CsharpStringInterpolationConstantValueResolver();
    public static CsharpStringInterpolationConstantValueResolver get_Instance();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IEnumerable`1<InterpolatedStringContentSyntax> Contents(InterpolatedStringExpressionSyntax interpolatedStringExpression);
    protected virtual SyntaxToken TextToken(InterpolatedStringTextSyntax interpolatedStringText);
}
internal class SonarAnalyzer.Helpers.CSharpSymbolUsageCollector : SafeCSharpSyntaxWalker {
    private static ISet`1<SyntaxKind> IncrementKinds;
    private Compilation compilation;
    private HashSet`1<string> knownSymbolNames;
    private SemanticModel model;
    [CompilerGeneratedAttribute]
private ISet`1<ISymbol> <UsedSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ISymbol, SymbolUsage> <FieldSymbolUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DebuggerDisplayValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IPropertySymbol, AccessorAccess> <PropertyAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ISymbol> <PrivateAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ISymbol> <TypesUsedWithReflection>k__BackingField;
    public ISet`1<ISymbol> UsedSymbols { get; }
    public IDictionary`2<ISymbol, SymbolUsage> FieldSymbolUsages { get; }
    public HashSet`1<string> DebuggerDisplayValues { get; }
    public Dictionary`2<IPropertySymbol, AccessorAccess> PropertyAccess { get; }
    public HashSet`1<ISymbol> PrivateAttributes { get; }
    public HashSet`1<ISymbol> TypesUsedWithReflection { get; }
    public CSharpSymbolUsageCollector(Compilation compilation, IEnumerable`1<ISymbol> knownSymbols);
    private static CSharpSymbolUsageCollector();
    [CompilerGeneratedAttribute]
public ISet`1<ISymbol> get_UsedSymbols();
    [CompilerGeneratedAttribute]
public IDictionary`2<ISymbol, SymbolUsage> get_FieldSymbolUsages();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DebuggerDisplayValues();
    [CompilerGeneratedAttribute]
public Dictionary`2<IPropertySymbol, AccessorAccess> get_PropertyAccess();
    [CompilerGeneratedAttribute]
public HashSet`1<ISymbol> get_PrivateAttributes();
    [CompilerGeneratedAttribute]
public HashSet`1<ISymbol> get_TypesUsedWithReflection();
    public virtual void Visit(SyntaxNode node);
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    private SymbolAccess ParentAccessType(SyntaxNode node);
    private static SymbolAccess ArgumentAccessType(ArgumentSyntax argument);
    private ImmutableArray`1<ISymbol> GetSymbols(TSyntaxNode node);
    private void TryStorePropertyAccess(ExpressionSyntax node, IEnumerable`1<ISymbol> identifierSymbols);
    private void StorePropertyAccess(IPropertySymbol propertySymbol, AccessorAccess access);
    private AccessorAccess EvaluatePropertyAccesses(ExpressionSyntax node);
    private bool IsKnownIdentifier(SyntaxToken identifier);
    private void TryStoreFieldAccess(IdentifierNameSyntax node, IEnumerable`1<ISymbol> symbols);
    private List`1<SymbolUsage> GetFieldSymbolUsagesList(IEnumerable`1<ISymbol> symbols);
    private SymbolUsage GetFieldSymbolUsage(ISymbol symbol);
    private static SyntaxNode GetTopmostSyntaxWithTheSameSymbol(SyntaxNode identifier);
    private static IMethodSymbol GetImplicitlyCalledConstructor(IMethodSymbol constructor);
    private static IMethodSymbol GetDefaultConstructor(INamedTypeSymbol namedType);
    private static bool IsDefaultConstructor(IMethodSymbol constructor);
    private static string GetName(ISymbol symbol);
    [CompilerGeneratedAttribute]
private bool <Visit>b__24_0(AttributeData a);
    [CompilerGeneratedAttribute]
internal static int <VisitAssignmentExpression>g__GetTupleCount|25_0(ExpressionSyntax assignmentLeft);
    [CompilerGeneratedAttribute]
internal static ISymbol <VisitAssignmentExpression>g__FindDeconstructor|25_1(IEnumerable`1<ISymbol> deconstructors, int numberOfArguments);
    [CompilerGeneratedAttribute]
private Optional`1<object> <VisitAttribute>b__26_1(AttributeArgumentSyntax x);
    [CompilerGeneratedAttribute]
internal static bool <VisitAttribute>g__IsValueNameOrType|26_0(AttributeArgumentSyntax a);
    [CompilerGeneratedAttribute]
internal static ISymbol <GetSymbols>g__GetOriginalDefinition|37_0(ISymbol candidateSymbol);
    [CompilerGeneratedAttribute]
internal static bool <TryStoreFieldAccess>g__HasFlag|42_0(SymbolAccess symbolAccess, SymbolAccess flag);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.CSharpSyntaxHelper : object {
    public static ExpressionSyntax NullLiteralExpression;
    public static ExpressionSyntax FalseLiteralExpression;
    public static ExpressionSyntax TrueLiteralExpression;
    public static string NameOfKeywordText;
    private static SyntaxKind[] LiteralSyntaxKinds;
    private static CSharpSyntaxHelper();
    [ExtensionAttribute]
public static bool AnyOfKind(IEnumerable`1<SyntaxNode> nodes, SyntaxKind kind);
    [ExtensionAttribute]
public static bool AnyOfKind(IEnumerable`1<SyntaxToken> tokens, SyntaxKind kind);
    [ExtensionAttribute]
public static SyntaxNode GetTopMostContainingMethod(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetSelfOrTopParenthesizedExpression(SyntaxNode node);
    [ExtensionAttribute]
public static ExpressionSyntax GetSelfOrTopParenthesizedExpression(ExpressionSyntax node);
    [ExtensionAttribute]
public static SyntaxNode GetFirstNonParenthesizedParent(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxNode syntaxNode, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static bool IsOnThis(ExpressionSyntax expression);
    [ExtensionAttribute]
private static bool IsOn(ExpressionSyntax expression, SyntaxKind onKind);
    [ExtensionAttribute]
public static bool IsInNameOfArgument(ExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsNameof(InvocationExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsStringEmpty(ExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsNullLiteral(SyntaxNode syntaxNode);
    [ExtensionAttribute]
public static bool IsAnyKind(SyntaxNode syntaxNode, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static bool IsAnyKind(SyntaxNode syntaxNode, ISet`1<SyntaxKind> syntaxKinds);
    [ExtensionAttribute]
public static bool IsAnyKind(SyntaxToken syntaxToken, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static bool IsAnyKind(SyntaxToken syntaxToken, ISet`1<SyntaxKind> syntaxKinds);
    [ExtensionAttribute]
public static bool IsAnyKind(SyntaxTrivia syntaxTravia, SyntaxKind[] syntaxKinds);
    [ExtensionAttribute]
public static bool ContainsMethodInvocation(BaseMethodDeclarationSyntax methodDeclarationBase, SemanticModel semanticModel, Func`2<InvocationExpressionSyntax, bool> syntaxPredicate, Func`2<IMethodSymbol, bool> symbolPredicate);
    [ExtensionAttribute]
public static Nullable`1<SyntaxToken> GetIdentifierOrDefault(BaseMethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool IsMethodInvocation(InvocationExpressionSyntax invocation, KnownType type, string methodName, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsMethodInvocation(InvocationExpressionSyntax invocation, ImmutableArray`1<KnownType> types, string methodName, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsPropertyInvocation(MemberAccessExpressionSyntax expression, ImmutableArray`1<KnownType> types, string propertyName, SemanticModel semanticModel);
    [ExtensionAttribute]
public static Location FindIdentifierLocation(BaseMethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool HasDefaultLabel(SwitchStatementSyntax node);
    [ExtensionAttribute]
public static int GetDefaultLabelSectionIndex(SwitchStatementSyntax node);
    [ExtensionAttribute]
public static bool HasBodyOrExpressionBody(AccessorDeclarationSyntax node);
    [ExtensionAttribute]
public static string GetName(SyntaxNode node);
    [ExtensionAttribute]
public static bool NameIs(SyntaxNode node, string name);
    [ExtensionAttribute]
public static bool NameIs(SyntaxNode node, string name, String[] orNames);
    [ExtensionAttribute]
public static bool HasConstantValue(ExpressionSyntax expression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static string StringValue(SyntaxNode node, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsLeftSideOfAssignment(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsComment(SyntaxTrivia trivia);
    public static QualifiedNameSyntax BuildQualifiedNameSyntax(string a, string b);
    public static QualifiedNameSyntax BuildQualifiedNameSyntax(string a, string b, string c);
    public static ImmutableArray`1<SyntaxNode> ArgumentValuesForParameter(SemanticModel semanticModel, ArgumentListSyntax argumentList, string parameterName);
}
internal class SonarAnalyzer.Helpers.CSharpSyntaxNodeEqualityComparer`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual bool Equals(SyntaxList`1<T> x, SyntaxList`1<T> y);
    public sealed virtual int GetHashCode(T obj);
    public sealed virtual int GetHashCode(SyntaxList`1<T> obj);
}
internal class SonarAnalyzer.Helpers.Facade.CSharpSyntaxFacade : SyntaxFacade`1<SyntaxKind> {
    public virtual bool AreEquivalent(SyntaxNode firstNode, SyntaxNode secondNode);
    public virtual IEnumerable`1<SyntaxNode> ArgumentExpressions(SyntaxNode node);
    public virtual IReadOnlyList`1<SyntaxNode> ArgumentList(SyntaxNode node);
    public virtual Nullable`1<int> ArgumentIndex(SyntaxNode argument);
    public virtual Nullable`1<SyntaxToken> ArgumentNameColon(SyntaxNode argument);
    public virtual SyntaxNode AssignmentLeft(SyntaxNode assignment);
    public virtual SyntaxNode AssignmentRight(SyntaxNode assignment);
    public virtual ImmutableArray`1<SyntaxNode> AssignmentTargets(SyntaxNode assignment);
    public virtual SyntaxNode BinaryExpressionLeft(SyntaxNode binary);
    public virtual SyntaxNode BinaryExpressionRight(SyntaxNode binary);
    public virtual SyntaxNode CastType(SyntaxNode cast);
    public virtual SyntaxNode CastExpression(SyntaxNode cast);
    public virtual ComparisonKind ComparisonKind(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> EnumMembers(SyntaxNode enum);
    public virtual ImmutableArray`1<SyntaxToken> FieldDeclarationIdentifiers(SyntaxNode node);
    public virtual bool HasExactlyNArguments(SyntaxNode invocation, int count);
    public virtual Nullable`1<SyntaxToken> InvocationIdentifier(SyntaxNode invocation);
    public virtual bool IsAnyKind(SyntaxNode node, ISet`1<SyntaxKind> syntaxKinds);
    public virtual bool IsAnyKind(SyntaxNode node, SyntaxKind[] syntaxKinds);
    public virtual bool IsAnyKind(SyntaxTrivia trivia, SyntaxKind[] syntaxKinds);
    public virtual bool IsInExpressionTree(SemanticModel model, SyntaxNode node);
    public virtual bool IsKind(SyntaxNode node, SyntaxKind kind);
    public virtual bool IsKind(SyntaxToken token, SyntaxKind kind);
    public virtual bool IsKind(SyntaxTrivia trivia, SyntaxKind kind);
    public virtual bool IsKnownAttributeType(SemanticModel model, SyntaxNode attribute, KnownType knownType);
    public virtual bool IsMemberAccessOnKnownType(SyntaxNode memberAccess, string name, KnownType knownType, SemanticModel semanticModel);
    public virtual bool IsNullLiteral(SyntaxNode node);
    public virtual bool IsStatic(SyntaxNode node);
    public virtual bool IsWrittenTo(SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual SyntaxKind Kind(SyntaxNode node);
    public virtual string LiteralText(SyntaxNode literal);
    public virtual ImmutableArray`1<SyntaxToken> LocalDeclarationIdentifiers(SyntaxNode node);
    public virtual SyntaxKind[] ModifierKinds(SyntaxNode node);
    public virtual SyntaxNode NodeExpression(SyntaxNode node);
    public virtual Nullable`1<SyntaxToken> NodeIdentifier(SyntaxNode node);
    public virtual Nullable`1<SyntaxToken> ObjectCreationTypeIdentifier(SyntaxNode objectCreation);
    public virtual SyntaxNode RemoveConditionalAccess(SyntaxNode node);
    public virtual SyntaxNode RemoveParentheses(SyntaxNode node);
    public virtual string StringValue(SyntaxNode node, SemanticModel semanticModel);
    public virtual bool TryGetInterpolatedTextValue(SyntaxNode node, SemanticModel semanticModel, String& interpolatedValue);
    public virtual bool TryGetOperands(SyntaxNode invocation, SyntaxNode& left, SyntaxNode& right);
}
internal class SonarAnalyzer.Helpers.Facade.CSharpSyntaxKindFacade : object {
    public SyntaxKind Attribute { get; }
    public SyntaxKind[] CastExpressions { get; }
    public SyntaxKind ClassDeclaration { get; }
    public SyntaxKind[] ClassAndRecordDeclarations { get; }
    public SyntaxKind[] ClassAndModuleDeclarations { get; }
    public SyntaxKind[] CommentTrivia { get; }
    public SyntaxKind[] ComparisonKinds { get; }
    public SyntaxKind ConstructorDeclaration { get; }
    public SyntaxKind[] DefaultExpressions { get; }
    public SyntaxKind EnumDeclaration { get; }
    public SyntaxKind EndOfLineTrivia { get; }
    public SyntaxKind FieldDeclaration { get; }
    public SyntaxKind IdentifierName { get; }
    public SyntaxKind IdentifierToken { get; }
    public SyntaxKind InvocationExpression { get; }
    public SyntaxKind InterpolatedStringExpression { get; }
    public SyntaxKind LeftShiftAssignmentStatement { get; }
    public SyntaxKind LeftShiftExpression { get; }
    public SyntaxKind LocalDeclaration { get; }
    public SyntaxKind[] MethodDeclarations { get; }
    public SyntaxKind[] ObjectCreationExpressions { get; }
    public SyntaxKind Parameter { get; }
    public SyntaxKind ParameterList { get; }
    public SyntaxKind RefKeyword { get; }
    public SyntaxKind ReturnStatement { get; }
    public SyntaxKind RightShiftAssignmentStatement { get; }
    public SyntaxKind RightShiftExpression { get; }
    public SyntaxKind SimpleAssignment { get; }
    public SyntaxKind SimpleCommentTrivia { get; }
    public SyntaxKind SimpleMemberAccessExpression { get; }
    public SyntaxKind[] StringLiteralExpressions { get; }
    public SyntaxKind StructDeclaration { get; }
    public SyntaxKind SubtractExpression { get; }
    public SyntaxKind[] TypeDeclaration { get; }
    public SyntaxKind VariableDeclarator { get; }
    public SyntaxKind WhitespaceTrivia { get; }
    public sealed virtual SyntaxKind get_Attribute();
    public sealed virtual SyntaxKind[] get_CastExpressions();
    public sealed virtual SyntaxKind get_ClassDeclaration();
    public sealed virtual SyntaxKind[] get_ClassAndRecordDeclarations();
    public sealed virtual SyntaxKind[] get_ClassAndModuleDeclarations();
    public sealed virtual SyntaxKind[] get_CommentTrivia();
    public sealed virtual SyntaxKind[] get_ComparisonKinds();
    public sealed virtual SyntaxKind get_ConstructorDeclaration();
    public sealed virtual SyntaxKind[] get_DefaultExpressions();
    public sealed virtual SyntaxKind get_EnumDeclaration();
    public sealed virtual SyntaxKind get_EndOfLineTrivia();
    public sealed virtual SyntaxKind get_FieldDeclaration();
    public sealed virtual SyntaxKind get_IdentifierName();
    public sealed virtual SyntaxKind get_IdentifierToken();
    public sealed virtual SyntaxKind get_InvocationExpression();
    public sealed virtual SyntaxKind get_InterpolatedStringExpression();
    public sealed virtual SyntaxKind get_LeftShiftAssignmentStatement();
    public sealed virtual SyntaxKind get_LeftShiftExpression();
    public sealed virtual SyntaxKind get_LocalDeclaration();
    public sealed virtual SyntaxKind[] get_MethodDeclarations();
    public sealed virtual SyntaxKind[] get_ObjectCreationExpressions();
    public sealed virtual SyntaxKind get_Parameter();
    public sealed virtual SyntaxKind get_ParameterList();
    public sealed virtual SyntaxKind get_RefKeyword();
    public sealed virtual SyntaxKind get_ReturnStatement();
    public sealed virtual SyntaxKind get_RightShiftAssignmentStatement();
    public sealed virtual SyntaxKind get_RightShiftExpression();
    public sealed virtual SyntaxKind get_SimpleAssignment();
    public sealed virtual SyntaxKind get_SimpleCommentTrivia();
    public sealed virtual SyntaxKind get_SimpleMemberAccessExpression();
    public sealed virtual SyntaxKind[] get_StringLiteralExpressions();
    public sealed virtual SyntaxKind get_StructDeclaration();
    public sealed virtual SyntaxKind get_SubtractExpression();
    public sealed virtual SyntaxKind[] get_TypeDeclaration();
    public sealed virtual SyntaxKind get_VariableDeclarator();
    public sealed virtual SyntaxKind get_WhitespaceTrivia();
}
internal class SonarAnalyzer.Helpers.Facade.CSharpTrackerFacade : object {
    [CompilerGeneratedAttribute]
private ArgumentTracker`1<SyntaxKind> <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseTypeTracker`1<SyntaxKind> <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementAccessTracker`1<SyntaxKind> <ElementAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldAccessTracker`1<SyntaxKind> <FieldAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationTracker`1<SyntaxKind> <Invocation>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDeclarationTracker`1<SyntaxKind> <MethodDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectCreationTracker`1<SyntaxKind> <ObjectCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyAccessTracker`1<SyntaxKind> <PropertyAccess>k__BackingField;
    public ArgumentTracker`1<SyntaxKind> Argument { get; }
    public BaseTypeTracker`1<SyntaxKind> BaseType { get; }
    public ElementAccessTracker`1<SyntaxKind> ElementAccess { get; }
    public FieldAccessTracker`1<SyntaxKind> FieldAccess { get; }
    public InvocationTracker`1<SyntaxKind> Invocation { get; }
    public MethodDeclarationTracker`1<SyntaxKind> MethodDeclaration { get; }
    public ObjectCreationTracker`1<SyntaxKind> ObjectCreation { get; }
    public PropertyAccessTracker`1<SyntaxKind> PropertyAccess { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ArgumentTracker`1<SyntaxKind> get_Argument();
    [CompilerGeneratedAttribute]
public sealed virtual BaseTypeTracker`1<SyntaxKind> get_BaseType();
    [CompilerGeneratedAttribute]
public sealed virtual ElementAccessTracker`1<SyntaxKind> get_ElementAccess();
    [CompilerGeneratedAttribute]
public sealed virtual FieldAccessTracker`1<SyntaxKind> get_FieldAccess();
    [CompilerGeneratedAttribute]
public sealed virtual InvocationTracker`1<SyntaxKind> get_Invocation();
    [CompilerGeneratedAttribute]
public sealed virtual MethodDeclarationTracker`1<SyntaxKind> get_MethodDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual ObjectCreationTracker`1<SyntaxKind> get_ObjectCreation();
    [CompilerGeneratedAttribute]
public sealed virtual PropertyAccessTracker`1<SyntaxKind> get_PropertyAccess();
}
internal static class SonarAnalyzer.Helpers.PatternExpressionObjectToPatternMapping : object {
    public static void MapObjectToPattern(ExpressionSyntax expression, SyntaxNode pattern, IDictionary`2<ExpressionSyntax, SyntaxNode> objectToPatternMap);
}
internal class SonarAnalyzer.Helpers.Trackers.CSharpArgumentTracker : ArgumentTracker`1<SyntaxKind> {
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IReadOnlyCollection`1<SyntaxNode> ArgumentList(SyntaxNode argumentNode);
    protected virtual Nullable`1<int> Position(SyntaxNode argumentNode);
    protected virtual Nullable`1<RefKind> ArgumentRefKind(SyntaxNode argumentNode);
    protected virtual bool InvocationMatchesMemberKind(SyntaxNode invokedExpression, MemberKind memberKind);
    protected virtual bool InvokedMemberMatches(SemanticModel model, SyntaxNode invokedExpression, MemberKind memberKind, Func`2<string, bool> invokedMemberNameConstraint);
    private static string FindClassNameFromConstructorInitializerSyntax(ConstructorInitializerSyntax initializerSyntax);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpBaseTypeTracker : BaseTypeTracker`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TrackedSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    protected virtual IEnumerable`1<SyntaxNode> GetBaseTypeNodes(SyntaxNode contextNode);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpElementAccessTracker : ElementAccessTracker`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TrackedSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    public virtual Condition<SyntaxKind, ElementAccessContext> ArgumentAtIndexEquals(int index, string value);
    public virtual Condition<SyntaxKind, ElementAccessContext> MatchSetter();
    public virtual Condition<SyntaxKind, ElementAccessContext> MatchProperty(MemberDescriptor member);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpFieldAccessTracker : FieldAccessTracker`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TrackedSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    public virtual Condition<SyntaxKind, FieldAccessContext> WhenRead();
    public virtual Condition<SyntaxKind, FieldAccessContext> MatchSet();
    public virtual Condition<SyntaxKind, FieldAccessContext> AssignedValueIsConstant();
    protected virtual bool IsIdentifierWithinMemberAccess(SyntaxNode expression);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpInvocationTracker : InvocationTracker`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TrackedSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    public virtual Condition<SyntaxKind, InvocationContext> ArgumentAtIndexIsStringConstant(int index);
    public virtual Condition<SyntaxKind, InvocationContext> ArgumentAtIndexIsAny(int index, String[] values);
    public virtual Condition<SyntaxKind, InvocationContext> ArgumentAtIndexIs(int index, Func`3<SyntaxNode, SemanticModel, bool> predicate);
    private Condition<SyntaxKind, InvocationContext> ArgumentAtIndexConformsTo(int index, Func`3<ArgumentSyntax, SemanticModel, bool> predicate);
    public virtual Condition<SyntaxKind, InvocationContext> MatchProperty(MemberDescriptor member);
    internal virtual object ConstArgumentForParameter(InvocationContext context, string parameterName);
    protected virtual Nullable`1<SyntaxToken> ExpectedExpressionIdentifier(SyntaxNode expression);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpMethodDeclarationTracker : MethodDeclarationTracker`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    public virtual Condition<SyntaxKind, MethodDeclarationContext> ParameterAtIndexIsUsed(int index);
    private static MethodInfo GetMethodInfo(MethodDeclarationContext context);
    protected virtual Nullable`1<SyntaxToken> GetMethodIdentifier(SyntaxNode methodDeclaration);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpObjectCreationTracker : ObjectCreationTracker`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    internal virtual Condition<SyntaxKind, ObjectCreationContext> ArgumentAtIndexIsConst(int index);
    internal virtual object ConstArgumentForParameter(ObjectCreationContext context, string parameterName);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpObjectInitializationTracker : object {
    private static int DefaultTrackedConstructorArgumentIndex;
    private static Func`4<ISymbol, SyntaxNode, SemanticModel, bool> DefaultIsAllowedObject;
    private Predicate`1<object> isAllowedConstantValue;
    private Func`4<ISymbol, SyntaxNode, SemanticModel, bool> isAllowedObject;
    private Predicate`1<string> isTrackedPropertyName;
    private ImmutableArray`1<KnownType> trackedTypes;
    private int trackedConstructorArgumentIndex;
    internal CSharpObjectInitializationTracker(Predicate`1<object> isAllowedConstantValue, ImmutableArray`1<KnownType> trackedTypes, Predicate`1<string> isTrackedPropertyName, Func`4<ISymbol, SyntaxNode, SemanticModel, bool> isAllowedObject, int trackedConstructorArgumentIndex);
    private static CSharpObjectInitializationTracker();
    internal bool ShouldBeReported(IObjectCreation objectCreation, SemanticModel semanticModel, bool isDefaultConstructorSafe);
    internal bool ShouldBeReported(AssignmentExpressionSyntax assignment, SemanticModel semanticModel);
    private bool IsAllowedConstantValue(object constantValue);
    private bool IsTrackedType(ExpressionSyntax expression, SemanticModel semanticModel);
    private bool IsAllowedValue(SyntaxNode expression, SemanticModel semanticModel);
    private bool ObjectCreatedWithAllowedValue(IObjectCreation objectCreation, SemanticModel semanticModel, bool isDefaultConstructorSafe);
    private bool IsTrackedPropertyName(string propertyName);
    private bool IsTrackedPropertyName(SyntaxNode expression);
    private bool IsPropertyOnTrackedType(SyntaxNode expression, SemanticModel semanticModel);
    private bool IsLaterAssignedWithAllowedValue(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static IEnumerable`1<ExpressionSyntax> GetInitializerExpressions(InitializerExpressionSyntax initializer);
    private static ISymbol GetAssignedVariableSymbol(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static ISymbol GetAssignedVariableSymbol(SyntaxNode node, SemanticModel semanticModel);
    private static IEnumerable`1<StatementSyntax> GetNextStatements(StatementSyntax statement);
    private static IEnumerable`1<StatementSyntax> GetInnerStatements(StatementSyntax statement);
}
public class SonarAnalyzer.Helpers.Trackers.CSharpPropertyAccessTracker : PropertyAccessTracker`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TrackedSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TrackedSyntaxKinds();
    public virtual object AssignedValue(PropertyAccessContext context);
    public virtual Condition<SyntaxKind, PropertyAccessContext> MatchGetter();
    public virtual Condition<SyntaxKind, PropertyAccessContext> MatchSetter();
    public virtual Condition<SyntaxKind, PropertyAccessContext> AssignedValueIsConstant();
    protected virtual bool IsIdentifierWithinMemberAccess(SyntaxNode expression);
    [CompilerGeneratedAttribute]
private bool <AssignedValueIsConstant>b__8_0(PropertyAccessContext context);
}
public class SonarAnalyzer.LiveVariableAnalysis.CSharp.SonarCSharpLiveVariableAnalysis : LiveVariableAnalysisBase`2<IControlFlowGraph, Block> {
    private SemanticModel model;
    protected Block ExitBlock { get; }
    public SonarCSharpLiveVariableAnalysis(IControlFlowGraph controlFlowGraph, ISymbol originalDeclaration, SemanticModel model, CancellationToken cancel);
    protected virtual Block get_ExitBlock();
    public virtual bool IsLocal(ISymbol symbol);
    internal static bool IsOutArgument(IdentifierNameSyntax identifier);
    protected virtual IEnumerable`1<Block> ReversedBlocks();
    protected virtual IEnumerable`1<Block> Successors(Block block);
    protected virtual IEnumerable`1<Block> Predecessors(Block block);
    protected virtual State<IControlFlowGraph, Block> ProcessBlock(Block block);
    [CompilerGeneratedAttribute]
internal static bool <IsLocal>g__IsLocalOrParameterSymbol|4_0(<>c__DisplayClass4_0& );
}
public static class SonarAnalyzer.Metrics.CSharp.CSharpCognitiveComplexityMetric : object {
    public static CognitiveComplexity GetComplexity(SyntaxNode node);
    public static CognitiveComplexity GetComplexity(SyntaxNode node, bool onlyGlobalStatements);
}
public static class SonarAnalyzer.Metrics.CSharp.CSharpCyclomaticComplexityMetric : object {
    public static CyclomaticComplexity GetComplexity(SyntaxNode syntaxNode);
    public static CyclomaticComplexity GetComplexity(SyntaxNode syntaxNode, bool onlyGlobalStatements);
}
public static class SonarAnalyzer.Metrics.CSharp.CSharpExecutableLinesMetric : object {
    public static ImmutableArray`1<int> GetLineNumbers(SyntaxTree syntaxTree, SemanticModel semanticModel);
    private static ExecutableLinesWalker GetWalker(SyntaxTree syntaxTree, SemanticModel semanticModel);
}
public class SonarAnalyzer.Metrics.CSharp.CSharpMetrics : MetricsBase {
    private Lazy`1<ImmutableArray`1<int>> lazyExecutableLines;
    public ImmutableArray`1<int> ExecutableLines { get; }
    public CSharpMetrics(SyntaxTree tree, SemanticModel semanticModel);
    public virtual ImmutableArray`1<int> get_ExecutableLines();
    protected virtual int ComputeCognitiveComplexity(SyntaxNode node);
    public virtual int ComputeCyclomaticComplexity(SyntaxNode node);
    protected virtual bool IsClass(SyntaxNode node);
    protected virtual bool IsCommentTrivia(SyntaxTrivia trivia);
    protected virtual bool IsEndOfFile(SyntaxToken token);
    protected virtual bool IsFunction(SyntaxNode node);
    protected virtual bool IsNoneToken(SyntaxToken token);
    protected virtual bool IsStatement(SyntaxNode node);
}
internal static class SonarAnalyzer.RuleCatalog : object {
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, RuleDescriptor> <Rules>k__BackingField;
    public static Dictionary`2<string, RuleDescriptor> Rules { get; }
    private static RuleCatalog();
    [CompilerGeneratedAttribute]
public static Dictionary`2<string, RuleDescriptor> get_Rules();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AbstractClassToInterface : SonarDiagnosticAnalyzer`1<SyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual string get_MessageFormat();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsRecordWithParameters(ISymbol symbol);
    private static bool AllMethodsAreAbstract(INamedTypeSymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSymbolReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AbstractTypesShouldNotHaveConstructors : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractTypesShouldNotHaveConstructors();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsPublicOrInternal(SyntaxToken token);
    private static string SuggestModifier(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AllBranchesShouldNotHaveSameImplementation : AllBranchesShouldNotHaveSameImplementationBase {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AllBranchesShouldNotHaveSameImplementation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void Analyze(SonarSyntaxNodeReportingContext context, SwitchExpressionSyntaxWrapper switchExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AlwaysSetDateTimeKind : AlwaysSetDateTimeKindBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private String[] <ValidNames>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind ObjectCreationExpression { get; }
    protected String[] ValidNames { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_ObjectCreationExpression();
    [CompilerGeneratedAttribute]
protected virtual String[] get_ValidNames();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AnalysisWarningAnalyzer : AnalysisWarningAnalyzerBase {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AnnotateApiActionsWithHttpVerb : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> HttpMethodAttributes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AnnotateApiActionsWithHttpVerb();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IgnoresApiExplorer(IEnumerable`1<AttributeData> attributes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AnonymousDelegateEventUnsubscribe : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AnonymousDelegateEventUnsubscribe();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ApiControllersShouldNotDeriveDirectlyFromController : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static HashSet`1<string> ViewIdentifiers;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ApiControllersShouldNotDeriveDirectlyFromController();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckController(SonarSymbolStartAnalysisContext context);
    private static void ReportIssue(SonarSymbolReportingContext context, INamedTypeSymbol controllerSymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ApiControllersShouldNotDeriveDirectlyFromControllerCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ArgumentSpecifiedForCallerInfoParameter : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> CallerInfoAttributesToReportOn;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ArgumentSpecifiedForCallerInfoParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsArgumentPassthroughOfParameter(SemanticModel semanticModel, ArgumentSyntax argument, IParameterSymbol targetParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ArrayCovariance : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ArrayCovariance();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void RaiseOnArrayCovarianceInSimpleAssignmentExpression(SonarSyntaxNodeReportingContext context);
    private static void RaiseOnArrayCovarianceInVariableDeclaration(SonarSyntaxNodeReportingContext context);
    private static void RaiseOnArrayCovarianceInInvocationExpression(SonarSyntaxNodeReportingContext context);
    private static void RaiseOnArrayCovarianceInCastExpression(SonarSyntaxNodeReportingContext context);
    private static void VerifyExpression(SyntaxNode node, ITypeSymbol baseType, SonarSyntaxNodeReportingContext context);
    private static bool AreCovariantArrayTypes(ITypeSymbol typeDerivedArray, ITypeSymbol typeBaseArray);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ArrayCovariance/<GetPossibleTypes>d__13")]
private static IEnumerable`1<NodeTypePair> GetPossibleTypes(SyntaxNode syntax, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ArrayPassedAsParams : ArrayPassedAsParamsBase`2<SyntaxKind, ArgumentSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <ExpressionKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] ExpressionKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_ExpressionKinds();
    protected virtual ArgumentSyntax LastArgumentIfArrayCreation(SyntaxNode expression);
    protected virtual ITypeSymbol ArrayElementType(ArgumentSyntax argument, SemanticModel model);
    private static BaseArgumentListSyntax ArgumentList(SyntaxNode expression);
    private static bool IsArrayCreation(ExpressionSyntax expression);
    private static bool ContainsSpread(CollectionExpressionSyntaxWrapper expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AssertionArgsShouldBePassedInCorrectOrder : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AssertionArgsShouldBePassedInCorrectOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static KnownAssertParameters[] GetParameters(string name);
    private static Nullable`1<WrongArguments> FindWrongArguments(SemanticModel semanticModel, INamedTypeSymbol container, IMethodSymbol symbol, InvocationExpressionSyntax invocation, KnownAssertParameters knownParameters);
    private static Location CreateLocation(SyntaxNode argument1, SyntaxNode argument2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AssertionsShouldBeComplete : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AssertionsShouldBeComplete();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckInvocation(SonarSyntaxNodeReportingContext c, Func`2<InvocationExpressionSyntax, bool> isAssertionMethod);
    private static bool HasContinuation(InvocationExpressionSyntax invocation);
    private static bool IsVoid(TypeSyntax type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AssignmentInsideSubExpression : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> AllowedParentExpressionKinds;
    private static ISet`1<SyntaxKind> RelationalExpressionKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AssignmentInsideSubExpression();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsNonCompliantSubExpression(AssignmentExpressionSyntax assignment, ExpressionSyntax topParenthesizedExpression);
    private static bool IsInsideExpression(ExpressionSyntax expression);
    private static bool IsInInitializerExpression(ExpressionSyntax expression);
    private static bool IsCompliantAssignmentInsideExpression(AssignmentExpressionSyntax assignment, ExpressionSyntax topParenthesizedExpression);
    private static bool IsCompliantCoalesceExpression(ExpressionSyntax parentExpression, AssignmentExpressionSyntax assignment);
    private static bool TryGetCoalesceExpressionParent(ExpressionSyntax parent, BinaryExpressionSyntax& coalesceExpression);
    private static bool TryGetCoalesceExpression(ExpressionSyntax expression, BinaryExpressionSyntax& coalesceExpression);
    private static bool IsDirectlyInStatementCondition(ExpressionSyntax expression, ExpressionSyntax topParenthesizedExpression);
    private static bool IsDirectlyInStatementCondition(ExpressionSyntax expressionParent, ExpressionSyntax originalExpression, Func`2<T, ExpressionSyntax> conditionSelector);
    private static bool IsInStatementCondition(ExpressionSyntax expression);
    private static bool IsInStatementCondition(ExpressionSyntax expressionParent, ExpressionSyntax originalExpression, Func`2<T, ExpressionSyntax> conditionSelector);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AsyncAwaitIdentifier : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static ISet`1<string> AsyncOrAwait;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AsyncAwaitIdentifier();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<SyntaxToken> GetAsyncOrAwaitTokens(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AsyncVoidMethod : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MsTestV1AssemblyName;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> AllowedAsyncVoidMsTestAttributes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static SyntaxKind[] ParentTypeSyntaxKinds;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AsyncVoidMethod();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsViolatingRule(IMethodSymbol methodSymbol);
    private static bool IsExceptionToTheRule(MethodDeclarationSyntax methodDeclaration, IMethodSymbol methodSymbol);
    private static bool IsAcceptedUsage(MethodDeclarationSyntax methodDeclaration);
    private static IEnumerable`1<IdentifierNameSyntax> GetIdentifierArguments(ObjectCreationExpressionSyntax objectCreation);
    private static IEnumerable`1<IdentifierNameSyntax> GetIdentifierArguments(InvocationExpressionSyntax invocation);
    private static IEnumerable`1<IdentifierNameSyntax> GetIdentifierRightHandSide(AssignmentExpressionSyntax assignment);
    private static SyntaxNode GetParentDeclaration(SyntaxNode syntaxNode);
    private static bool IsNamedAsEventHandler(ISymbol symbol);
    private static bool HasAnyMsTestV1AllowedAttribute(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidDateTimeNowForBenchmarking : AvoidDateTimeNowForBenchmarkingBase`3<MemberAccessExpressionSyntax, InvocationExpressionSyntax, SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool ContainsDateTimeArgument(InvocationExpressionSyntax invocation, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidExcessiveClassCoupling : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int ThresholdDefaultValue;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> IgnoredTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("max", "3", "Maximum number of types a single type is allowed to depend upon", "30")]
public int Threshold { get; public set; }
    private static AvoidExcessiveClassCoupling();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(int value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private static bool IsTrackedType(INamedTypeSymbol namedType);
    private static IEnumerable`1<INamedTypeSymbol> ExpandGenericTypes(INamedTypeSymbol namedType);
    private static IEnumerable`1<INamedTypeSymbol> GetConstraintTypes(ITypeParameterSymbol typeParameter);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidExcessiveInheritance : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string FilteredClassesDefaultValue;
    private static int MaximumDepthDefaultValue;
    private static DiagnosticDescriptor Rule;
    private string filteredClasses;
    private ICollection`1<Regex> filters;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumDepth>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("max", "3", "Maximum depth of the inheritance tree. (Number)", "5")]
public int MaximumDepth { get; public set; }
    [RuleParameterAttribute("filteredClasses", "0", "Comma-separated list of classes or records to be filtered out of the count of inheritance. Depth counting will stop when a filtered class or record is reached. For example: System.Windows.Controls.UserControl, System.Windows.*. (String)", "")]
public string FilteredClasses { get; public set; }
    private static AvoidExcessiveInheritance();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_MaximumDepth();
    [CompilerGeneratedAttribute]
public void set_MaximumDepth(int value);
    public string get_FilteredClasses();
    public void set_FilteredClasses(string value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private static string GetRootNamespace(ISymbol symbol);
    private static Regex WildcardPatternToRegularExpression(string pattern);
    [CompilerGeneratedAttribute]
private void <Initialize>b__17_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__17_3(string className);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidLambdaExpressionInLoopsInBlazor : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<string> AddAttributeMethods;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidLambdaExpressionInLoopsInBlazor();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsWithinRenderTreeBuilderInvocation(SyntaxNode node, SemanticModel semanticModel);
    private static bool IsWithinLoopBody(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidUnderPosting : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> IgnoredTypes;
    private static ImmutableArray`1<KnownType> IgnoredAttributes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidUnderPosting();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ProcessControllerMethods(SonarSyntaxNodeReportingContext context, ConcurrentDictionary`2<ITypeSymbol, bool> examinedTypes);
    private static void CheckInvalidProperties(INamedTypeSymbol parameterType, SonarSyntaxNodeReportingContext context, ConcurrentDictionary`2<ITypeSymbol, bool> examinedTypes);
    private static bool IgnoreType(ITypeSymbol type);
    private static bool CanBeUsedInModelBinding(INamedTypeSymbol type);
    private static bool CanBeNull(ITypeSymbol type);
    private static void GetAllDeclaredProperties(ITypeSymbol type, ConcurrentDictionary`2<ITypeSymbol, bool> examinedTypes, List`1<IPropertySymbol> declaredProperties);
    private static IEnumerable`1<INamedTypeSymbol> RelatedTypesToExamine(ITypeSymbol type, ITypeSymbol controllerType);
    private static bool HasValidateNeverAttribute(ISymbol symbol);
    private static bool IsInitialized(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <CheckInvalidProperties>g__IsExcluded|9_3(IPropertySymbol property);
    [CompilerGeneratedAttribute]
internal static bool <CheckInvalidProperties>g__IsNewtonsoftJsonPropertyRequired|9_4(IPropertySymbol property);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AvoidUnsealedAttributes : AvoidUnsealedAttributesBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AzureFunctionsCatchExceptions : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AzureFunctionsCatchExceptions();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AzureFunctionsLogFailures : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static Int32[] InvalidLogLevel;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AzureFunctionsLogFailures();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasLoggerInScope(IMethodSymbol entryPoint);
    internal static bool HasLoggerMember(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AzureFunctionsReuseClients : ReuseClientBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ImmutableArray`1<KnownType> ReusableClients { get; }
    private static AzureFunctionsReuseClients();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ImmutableArray`1<KnownType> get_ReusableClients();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.AzureFunctionsStateless : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AzureFunctionsStateless();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckTarget(SonarSyntaxNodeReportingContext context, ExpressionSyntax target);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BackslashShouldBeAvoidedInAspNetRoutes : BackslashShouldBeAvoidedInAspNetRoutesBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual bool IsNamedAttributeArgument(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BeginInvokePairedWithEndInvoke : BeginInvokePairedWithEndInvokeBase`2<SyntaxKind, InvocationExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <ParentDeclarationKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind InvocationExpressionKind { get; }
    protected string CallbackParameterName { get; }
    protected ISet`1<SyntaxKind> ParentDeclarationKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_InvocationExpressionKind();
    protected virtual string get_CallbackParameterName();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_ParentDeclarationKinds();
    protected virtual void VisitInvocation(EndInvokeContext<SyntaxKind, InvocationExpressionSyntax> context);
    protected virtual bool IsInvalidCallback(SyntaxNode callbackArg, SemanticModel semanticModel);
    private static SyntaxNode FindCallback(SyntaxNode callbackArg, SemanticModel semanticModel);
    private static SyntaxNode LookupIdentifierInitializer(IdentifierNameSyntax identifier, SemanticModel semantic);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BinaryOperationWithIdenticalExpressions : BinaryOperationWithIdenticalExpressionsBase {
    internal static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static SyntaxKind[] SyntaxKindsToCheckBinary;
    private static SyntaxKind[] SyntaxKindsToCheckAssignment;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static BinaryOperationWithIdenticalExpressions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnObjectEqualsMatches(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation);
    private static Tuple`2<SyntaxNode, SyntaxNode> GetOperands(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol);
    private static SyntaxNode RemoveParentheses(SyntaxNode node);
    private static void ReportIfOperatorExpressionsMatch(SonarSyntaxNodeReportingContext context, ExpressionSyntax left, ExpressionSyntax right, SyntaxToken operatorToken);
}
[ObsoleteAttribute("This rule has been deprecated since 9.25")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BlazorQueryParameterRoutableComponent : SonarDiagnosticAnalyzer {
    private static string NoRouteQueryDiagnosticId;
    private static string NoRouteQueryMessageFormat;
    private static string QueryTypeDiagnosticId;
    private static string QueryTypeMessageFormat;
    private static DiagnosticDescriptor S6803Rule;
    private static DiagnosticDescriptor S6797Rule;
    private static ISet`1<KnownType> SupportedQueryTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static BlazorQueryParameterRoutableComponent();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckQueryProperties(SonarSymbolReportingContext c);
    private static bool IsSupportedType(ITypeSymbol type, KnownType supportType);
    private static string GetTypeName(TypeSyntax propertyType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BooleanCheckInverted : BooleanCheckInvertedBase`1<BinaryExpressionSyntax> {
    private static ISet`1<SyntaxKind> ignoredNullableOperators;
    private static Dictionary`2<SyntaxKind, string> oppositeTokens;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static BooleanCheckInverted();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool IsIgnoredNullableOperation(BinaryExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsConditionalAccessExpression(ExpressionSyntax expression);
    protected virtual bool IsLogicalNot(BinaryExpressionSyntax expression, SyntaxNode& logicalNot);
    protected virtual string GetSuggestedReplacement(BinaryExpressionSyntax expression);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BooleanCheckInvertedCodeFix : SonarCodeFix {
    internal static string Title;
    private static Dictionary`2<SyntaxKind, SyntaxKind> OppositeExpressionKinds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static BooleanCheckInvertedCodeFix();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static ExpressionSyntax ChangeOperator(BinaryExpressionSyntax binary);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BooleanLiteralUnnecessary : BooleanLiteralUnnecessaryBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual Nullable`1<SyntaxToken> GetOperatorToken(SyntaxNode node);
    protected virtual bool IsTrue(SyntaxNode syntaxNode);
    protected virtual bool IsFalse(SyntaxNode syntaxNode);
    protected virtual bool IsInsideTernaryWithThrowExpression(SyntaxNode syntaxNode);
    protected virtual SyntaxNode GetLeftNode(SyntaxNode node);
    protected virtual SyntaxNode GetRightNode(SyntaxNode node);
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckForLoopCondition(SonarSyntaxNodeReportingContext context);
    private void CheckLogicalNot(SonarSyntaxNodeReportingContext context);
    private void CheckConditional(SonarSyntaxNodeReportingContext context);
    private static bool IsThrowExpression(ExpressionSyntax expressionSyntax);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BooleanLiteralUnnecessaryCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void RegisterPatternExpressionReplacement(SonarCodeFixContext context, SyntaxNode root, IsPatternExpressionSyntaxWrapper patternExpression);
    private static void RegisterForStatementConditionRemoval(SonarCodeFixContext context, SyntaxNode root, ForStatementSyntax forStatement);
    private static void RegisterBinaryExpressionRemoval(SonarCodeFixContext context, SyntaxNode root, LiteralExpressionSyntax literal, BinaryExpressionSyntax binaryParent);
    private static void RegisterConditionalExpressionRewrite(SonarCodeFixContext context, SyntaxNode root, LiteralExpressionSyntax literal, ConditionalExpressionSyntax conditionalParent);
    private static void RegisterBooleanInversion(SonarCodeFixContext context, SyntaxNode root, LiteralExpressionSyntax literal);
    private static void RegisterConditionalExpressionRemoval(SonarCodeFixContext context, SyntaxNode root, ConditionalExpressionSyntax conditional);
    private static void RegisterBinaryExpressionReplacement(SonarCodeFixContext context, SyntaxNode root, SyntaxNode syntaxNode, BinaryExpressionSyntax binary);
    private static SyntaxNode FindNodeToKeep(BinaryExpressionSyntax binary);
    private static bool TwoSidesAreDifferentBooleans(BinaryExpressionSyntax binary);
    private static bool TwoSidesAreSameBooleans(BinaryExpressionSyntax binary);
    private static Document RemovePrefixUnary(Document document, SyntaxNode root, SyntaxNode literal);
    private static Document RemoveConditional(Document document, SyntaxNode root, ConditionalExpressionSyntax conditional);
    private static SyntaxNode ReplaceExpressionWithBinary(SyntaxNode nodeToReplace, SyntaxNode root, SyntaxKind binaryKind, ExpressionSyntax left, ExpressionSyntax right);
    private static Document RewriteConditional(Document document, SyntaxNode root, SyntaxNode syntaxNode, ConditionalExpressionSyntax conditional);
    private static ExpressionSyntax GetNegatedExpression(ExpressionSyntax expression);
    private static ExpressionSyntax AddParenthesis(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BreakOutsideSwitch : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IEnumerable`1<SyntaxKind> LoopOrSwitch { get; }
    private static BreakOutsideSwitch();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsInSwitch(BreakStatementSyntax node);
    private static IEnumerable`1<SyntaxKind> get_LoopOrSwitch();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.BypassingAccessibility : BypassingAccessibilityBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CallerInformationParametersShouldBeLast : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CallerInformationParametersShouldBeLast();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnViolation(SonarSyntaxNodeReportingContext context);
    private static bool HasIdentifier(ParameterSyntax parameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CallModelStateIsValid : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static SyntaxKind[] PropertyAccessSyntaxNodesToVisit;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CallModelStateIsValid();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ProcessCodeBlock(SonarCodeBlockStartAnalysisContext`1<SyntaxKind> codeBlockContext);
    private static bool HasApiControllerAttribute(ITypeSymbol type);
    private static bool HasActionFilterAttribute(ISymbol symbol);
    private static bool IsCheckingValidityProperty(SyntaxNode node, SemanticModel semanticModel);
    private static bool IsTryValidateInvocation(SyntaxNode node, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CallToAsyncMethodShouldNotBeBlocking : SonarDiagnosticAnalyzer {
    private static string MessageFormat;
    private static string ResultName;
    private static string ContinueWithName;
    private static string SleepName;
    private static string AzureFunctionSuffix;
    private static DiagnosticDescriptor RuleS4462;
    private static DiagnosticDescriptor RuleS6422;
    private static Dictionary`2<string, ImmutableArray`1<KnownType>> InvalidMemberAccess;
    private static Dictionary`2<string, String[]> MemberNameToMessageArguments;
    private static Dictionary`2<string, KnownType> TaskThreadPoolCalls;
    private static Dictionary`2<string, KnownType> WaitForMultipleTasksExecutionCalls;
    private static Dictionary`2<string, KnownType> WaitForSingleExecutionCalls;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CallToAsyncMethodShouldNotBeBlocking();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnViolation(SonarSyntaxNodeReportingContext context);
    private static bool IsAwaited(SonarSyntaxNodeReportingContext context, MemberAccessExpressionSyntax simpleMemberAccess);
    private static bool IsAwaitForMultipleTasksExecutionCall(SemanticModel model, InvocationExpressionSyntax invocation, ISymbol accessedSymbol);
    private static bool IsAwaitForSingleTaskExecutionCall(SemanticModel model, InvocationExpressionSyntax invocation, ISymbol accessedSymbol);
    private static bool IsResultInContinueWithCall(string memberAccessName, MemberAccessExpressionSyntax memberAccess);
    private static bool IsContinueWithCallWithArgumentName(InvocationExpressionSyntax invocation, string argumentName);
    private static bool IsLambdaExpressionWithArgumentName(ExpressionSyntax expression, string argumentName);
    private static bool IsChainedAfterThreadPoolCall(SemanticModel model, MemberAccessExpressionSyntax memberAccess);
    private static bool IsNamedSymbolOfExpectedType(SemanticModel model, MemberAccessExpressionSyntax memberAccess, Dictionary`2<string, KnownType> expectedTypes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CastConcreteTypeToInterface : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CastConcreteTypeToInterface();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForIssue(SonarSyntaxNodeReportingContext context, SyntaxNode fromExpression, SyntaxNode toExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CastShouldNotBeDuplicated : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string UsePatternMatchingCheckMessage;
    private static string RemoveRedundantCastAnotherVariableMessage;
    private static string RemoveRedundantCastMessage;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CastShouldNotBeDuplicated();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CasePatternSwitchLabel(SonarSyntaxNodeReportingContext analysisContext);
    private static void SwitchExpressionArm(SonarSyntaxNodeReportingContext analysisContext);
    private static void IsPatternExpression(SonarSyntaxNodeReportingContext analysisContext);
    private static void IsExpression(SonarSyntaxNodeReportingContext analysisContext);
    private static Location[] DuplicatedCastLocations(SonarSyntaxNodeReportingContext context, SyntaxNode parentStatement, TypeSyntax castType, SyntaxNode typedVariable);
    private static void ProcessPatternExpression(SonarSyntaxNodeReportingContext analysisContext, SyntaxNode isPattern, SyntaxNode mainVariableExpression, SyntaxNode parentStatement);
    private static IEnumerable`1<TypeSyntax> GetTypesFromPattern(SyntaxNode pattern);
    private static TypeSyntax GetType(SyntaxNode pattern);
    private static void ReportPatternAtMainVariable(SonarSyntaxNodeReportingContext context, SyntaxNode variableExpression, Location mainLocation, SyntaxNode parentStatement, TypeSyntax castType, string message);
    private static void ReportPatternAtCastLocation(SonarSyntaxNodeReportingContext context, SyntaxNode variableExpression, Location patternLocation, SyntaxNode parentStatement, TypeSyntax castType, string message);
    private static bool IsEquivalentVariable(ExpressionSyntax expression, SyntaxNode typedVariable);
    private static SyntaxNode CleanupExpression(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <GetTypesFromPattern>g__AddPatternType|16_0(SyntaxNode pattern, ISet`1<TypeSyntax> targetTypes);
    [CompilerGeneratedAttribute]
internal static string <IsEquivalentVariable>g__StandaloneIdentifier|20_0(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CatchEmpty : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CatchEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsGenericCatch(CatchClauseSyntax catchClause, SemanticModel semanticModel);
    private static bool HasComments(CatchClauseSyntax catchClause);
    private static bool IsCommentTrivia(SyntaxTrivia trivia);
    private static bool HasStatements(CatchClauseSyntax catchClause);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CatchRethrow : CatchRethrowBase`2<SyntaxKind, CatchClauseSyntax> {
    private static BlockSyntax ThrowBlock;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static CatchRethrow();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool ContainsOnlyThrow(CatchClauseSyntax currentCatch);
    protected virtual CatchClauseSyntax[] AllCatches(SyntaxNode node);
    protected virtual SyntaxNode DeclarationType(CatchClauseSyntax catchClause);
    protected virtual bool HasFilter(CatchClauseSyntax catchClause);
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CatchRethrowCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode CalculateNewRoot(SyntaxNode root, SyntaxNode currentNode, TryStatementSyntax tryStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CertificateValidationCheck : CertificateValidationCheckBase`10<SyntaxKind, ArgumentSyntax, ExpressionSyntax, IdentifierNameSyntax, AssignmentExpressionSyntax, InvocationExpressionSyntax, ParameterSyntax, VariableDeclaratorSyntax, ParenthesizedLambdaExpressionSyntax, MemberAccessExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <MethodDeclarationKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] MethodDeclarationKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_MethodDeclarationKinds();
    internal virtual MethodParameterLookupBase`1<ArgumentSyntax> CreateParameterLookup(SyntaxNode argumentListNode, IMethodSymbol method);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual SyntaxNode FindRootTypeDeclaration(SyntaxNode node);
    protected virtual Location ExpressionLocation(SyntaxNode expression);
    protected virtual void SplitAssignment(AssignmentExpressionSyntax assignment, IdentifierNameSyntax& leftIdentifier, ExpressionSyntax& right);
    protected virtual IEqualityComparer`1<ExpressionSyntax> CreateNodeEqualityComparer();
    protected virtual ExpressionSyntax[] FindReturnAndThrowExpressions(InspectionContext<SyntaxKind, ArgumentSyntax, ExpressionSyntax, IdentifierNameSyntax, AssignmentExpressionSyntax, InvocationExpressionSyntax, ParameterSyntax, VariableDeclaratorSyntax, ParenthesizedLambdaExpressionSyntax, MemberAccessExpressionSyntax> c, SyntaxNode block);
    protected virtual bool IsTrueLiteral(ExpressionSyntax expression);
    protected virtual ExpressionSyntax VariableInitializer(VariableDeclaratorSyntax variable);
    protected virtual ImmutableArray`1<Location> LambdaLocations(InspectionContext<SyntaxKind, ArgumentSyntax, ExpressionSyntax, IdentifierNameSyntax, AssignmentExpressionSyntax, InvocationExpressionSyntax, ParameterSyntax, VariableDeclaratorSyntax, ParenthesizedLambdaExpressionSyntax, MemberAccessExpressionSyntax> c, ParenthesizedLambdaExpressionSyntax lambda);
    protected virtual SyntaxNode LocalVariableScope(VariableDeclaratorSyntax variable);
    protected virtual SyntaxNode ExtractArgumentExpressionNode(SyntaxNode expression);
    protected virtual SyntaxNode SyntaxFromReference(SyntaxReference reference);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CheckArgumentException : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string ParameterLessConstructorMessage;
    private static string ConstructorParametersInverted;
    private static string InvalidParameterName;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> ArgumentExceptionTypesToCheck;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CheckArgumentException();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForIssue(SonarSyntaxNodeReportingContext analysisContext);
    private static Tuple`2<Optional`1<object>, Optional`1<object>> RetrieveParameterAndMessageArgumentValue(IMethodSymbol methodSymbol, IObjectCreation objectCreation, SemanticModel semanticModel);
    private static IEnumerable`1<string> GetMethodArgumentNames(SyntaxNode creationSyntax);
    private static string TakeOnlyBeforeDot(Optional`1<object> value);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetMethodArgumentNames>g__IdentifierNames|13_1(BaseParameterListSyntax parameterList);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetMethodArgumentNames>g__AccessorIdentifierNames|13_2(AccessorDeclarationSyntax accessor);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetMethodArgumentNames>g__ParentParameterList|13_3(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetMethodArgumentNames>g__GetIdentifierNames|13_4(ParameterListSyntax parameterList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CheckFileLicense : CheckFileLicenseBase {
    internal static string HeaderFormatDefaultValue;
    [CompilerGeneratedAttribute]
private string <HeaderFormat>k__BackingField;
    [RuleParameterAttribute("headerFormat", "1", "Expected copyright and license header.", "/*
 * <Your-Product-Name>
 * Copyright (c) <Year-From>-<Year-To> <Your-Company-Name>
 *
 * Please configure this header in your SonarCloud/SonarQube quality profile.
 * You can also set it in SonarLint.xml additional file for SonarLint or standalone NuGet analyzer.
 */
")]
public string HeaderFormat { get; public set; }
    protected ILanguageFacade Language { get; }
    [CompilerGeneratedAttribute]
public virtual string get_HeaderFormat();
    [CompilerGeneratedAttribute]
public virtual void set_HeaderFormat(string value);
    protected virtual ILanguageFacade get_Language();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CheckFileLicenseCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static IEnumerable`1<SyntaxTrivia> CreateFileHeaderTrivias(string comment);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassAndMethodName : SonarDiagnosticAnalyzer {
    private static string MethodNameDiagnosticId;
    private static string TypeNameDiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatNonUnderscore;
    private static string MessageFormatUnderscore;
    private static DiagnosticDescriptor MethodNameRule;
    private static DiagnosticDescriptor TypeNameRule;
    private static ImmutableArray`1<KnownType> ComRelatedTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ClassAndMethodName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ClassAndMethodName/<SplitToParts>d__11")]
internal static IEnumerable`1<string> SplitToParts(string name);
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckTypeName(SonarSyntaxNodeReportingContext context);
    private static void CheckMemberName(SonarSyntaxNodeReportingContext context, SyntaxToken identifier);
    private static bool IsMemberNameValid(string identifierName, String& suggestion);
    private static bool IsTypeNameValid(string identifierName, bool requireInitialI, bool allowInitialI, bool areUnderscoresAllowed, String& suggestion);
    private static string HandleFirstPartOfTypeName(string input, bool requireInitialI, bool allowInitialI, int maxUppercase);
    private static string SuggestCapitalLetterAfterNonLetter(StringBuilder suggestion);
    private static string SuggestFixedCaseName(string input, int maxUppercaseCount);
    private static string FirstCharToUpper(string input);
    private static bool IsCharUpper(string input, int idx);
    private static SyntaxToken GetDeclarationIdentifier(SyntaxNode declaration);
    private static bool IsTestClassName(string className);
    [CompilerGeneratedAttribute]
internal static bool <HandleFirstPartOfTypeName>g__ShouldExcludeFirstLetter|17_0(<>c__DisplayClass17_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassNamedException : ClassNamedExceptionBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassNotInstantiatable : ClassNotInstantiatableBase`2<BaseTypeDeclarationSyntax, SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IEnumerable`1<ConstructorContext<BaseTypeDeclarationSyntax, SyntaxKind>> CollectRemovableDeclarations(INamedTypeSymbol namedType, Compilation compilation, string messageArg);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassShouldNotBeEmpty : ClassShouldNotBeEmptyBase`2<SyntaxKind, BaseTypeDeclarationSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsEmptyAndNotPartial(SyntaxNode node);
    protected virtual BaseTypeDeclarationSyntax GetIfHasDeclaredBaseClassOrInterface(SyntaxNode node);
    protected virtual bool HasInterfaceOrGenericBaseClass(BaseTypeDeclarationSyntax declaration);
    protected virtual bool HasAnyAttribute(SyntaxNode node);
    protected virtual string DeclarationTypeKeyword(SyntaxNode node);
    protected virtual bool HasConditionalCompilationDirectives(SyntaxNode node);
    private static bool LacksParameterizedPrimaryConstructor(SyntaxNode node);
    private static bool IsParameterlessClass(SyntaxNode node);
    private static bool IsParameterlessRecord(SyntaxNode node);
    private static bool LacksParameters(ParameterListSyntax parameterList, BaseListSyntax baseList);
    private static Nullable`1<RecordDeclarationSyntaxWrapper> RecordDeclarationSyntax(SyntaxNode node);
    private static Nullable`1<PrimaryConstructorBaseTypeSyntaxWrapper> BaseTypeSyntax(BaseListSyntax list);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassWithEqualityShouldImplementIEquatable : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string EqualsMethodName;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ClassWithEqualityShouldImplementIEquatable();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool ImplementsIEquatableInterface(ITypeSymbol classSymbol);
    private static bool IsIEquatableEqualsMethodCandidate(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClassWithOnlyStaticMember : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatConstructor;
    private static string MessageFormatPrimaryConstructor;
    private static string MessageFormatStaticClass;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<Accessibility> ProblematicConstructorAccessibility;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ClassWithOnlyStaticMember();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckClasses(SonarSymbolReportingContext context, INamedTypeSymbol utilityClass);
    private static void CheckConstructors(SonarSymbolReportingContext context, INamedTypeSymbol utilityClass);
    private static bool ClassIsRelevant(INamedTypeSymbol class);
    private static bool ClassQualifiesForIssue(INamedTypeSymbol class);
    private static bool HasOnlyQualifyingMembers(INamedTypeSymbol class, IList`1<ISymbol> members);
    private static bool ClassUsedAsInstanceInMembers(INamedTypeSymbol class, IList`1<ISymbol> members);
    private static bool HasMembersAndAllAreStaticExceptConstructors(INamedTypeSymbol class);
    private static bool IsConstructor(ISymbol member);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ClearTextProtocolsAreSensitive : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string EnableSslMessage;
    private static string TelnetKey;
    private static string EnableSslName;
    private static DiagnosticDescriptor DefaultRule;
    private static DiagnosticDescriptor EnableSslRule;
    private static Dictionary`2<string, string> RecommendedProtocols;
    private static String[] CommonlyUsedXmlDomains;
    private static String[] CommonlyUsedExampleDomains;
    private static String[] LocalhostAddresses;
    private static KnownType[] AttributesWithNamespaceParameter;
    private static CSharpObjectInitializationTracker ObjectInitializationTracker;
    private static TimeSpan RegexTimeout;
    private static Regex HttpRegex;
    private static Regex FtpRegex;
    private static Regex TelnetRegex;
    private static Regex TelnetRegexForIdentifier;
    private static Regex ValidServerRegex;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public ClearTextProtocolsAreSensitive(IAnalyzerConfiguration analyzerConfiguration);
    private static ClearTextProtocolsAreSensitive();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VisitObjectCreation(SonarSyntaxNodeReportingContext context);
    private static void VisitInvocationExpression(SonarSyntaxNodeReportingContext context);
    private static void VisitAssignments(SonarSyntaxNodeReportingContext context);
    private static void VisitStringExpressions(SonarSyntaxNodeReportingContext c);
    private static bool IsServerSafe(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static string GetUnsafeProtocol(SyntaxNode node, SemanticModel semanticModel);
    private static string GetText(SyntaxNode node, SemanticModel semanticModel);
    private static bool IsNamespace(SemanticModel model, SyntaxNode node);
    private static bool IsAttributeWithNamespaceParameter(SemanticModel model, AttributeSyntax attribute);
    private static bool TokenContainsNamespace(SyntaxToken token);
    private static Regex CompileRegex(string pattern, bool ignoreCase);
    [CompilerGeneratedAttribute]
private void <Initialize>b__24_0(SonarCompilationStartAnalysisContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CognitiveComplexity : CognitiveComplexityBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_3(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_4(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_5(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_6(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_7(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_8(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CollectionEmptinessChecking : CollectionEmptinessCheckingBase`1<SyntaxKind> {
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual string get_MessageFormat();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CollectionEmptinessCheckingCodeFix : SonarCodeFix {
    private static string Title;
    private CSharpFacade language;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    public static void Simplify(SyntaxNode root, ExpressionSyntax expression, ExpressionSyntax countExpression, CountComparisonResult comparisonResult, SonarCodeFixContext context);
    private static Task`1<Document> Replacement(SyntaxNode root, ExpressionSyntax expression, InvocationExpressionSyntax count, CountComparisonResult comparison, SonarCodeFixContext context);
    private static InvocationExpressionSyntax AnyFromExtension(InvocationExpressionSyntax count);
    private static InvocationExpressionSyntax AnyFromStaticMethod(InvocationExpressionSyntax count);
    private static bool IsExtension(InvocationExpressionSyntax count);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CollectionPropertiesShouldBeReadOnly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> CollectionTypes;
    private static ImmutableArray`1<KnownType> IgnoredCollectionTypes;
    private static ISet`1<Accessibility> PrivateOrInternalAccessibility;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionPropertiesShouldBeReadOnly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsObservedCollectionType(IPropertySymbol propertySymbol);
    private static bool HasPublicSetter(IPropertySymbol propertySymbol);
    private static bool IsInterfaceImplementation(IPropertySymbol propertySymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CollectionQuerySimplification : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static string MessageUseInstead;
    internal static string MessageDropAndChange;
    internal static string MessageDropFromMiddle;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> MethodNamesWithPredicate;
    private static ISet`1<string> MethodNamesForTypeCheckingWithSelect;
    private static ISet`1<string> MethodNamesToCollection;
    private static ISet`1<string> IgnoredMethodNames;
    private static ISet`1<SyntaxKind> AsIsSyntaxKinds;
    private static string WhereMethodName;
    private static int WherePredicateTypeArgumentNumber;
    private static string SelectMethodName;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionQuerySimplification();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckCountCall(SonarSyntaxNodeReportingContext context);
    private static void CheckToCollectionCalls(SonarSyntaxNodeReportingContext context);
    private static bool MethodExistsOnIEnumerable(IMethodSymbol methodSymbol, SemanticModel semanticModel);
    private static bool ParametersMatch(IMethodSymbol originalDefinition, IMethodSymbol member);
    private static bool IsToCollectionCall(IMethodSymbol methodSymbol);
    private static string GetToCollectionCallsMessage(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol);
    private static bool IsLinqDatabaseQuery(InvocationExpressionSyntax node, SemanticModel model);
    private static ITypeSymbol GetNodeTypeSymbol(SyntaxNode node, SemanticModel model);
    private static void CheckExtensionMethodsOnIEnumerable(SonarSyntaxNodeReportingContext context);
    private static InvocationExpressionSyntax GetInnerInvocation(InvocationExpressionSyntax outerInvocation, IMethodSymbol outerMethodSymbol);
    private static List`1<ArgumentSyntax> GetReducedArguments(IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation);
    private static void CheckForCastSimplification(SonarSyntaxNodeReportingContext context, IMethodSymbol outerMethodSymbol, InvocationExpressionSyntax outerInvocation, IMethodSymbol innerMethodSymbol, InvocationExpressionSyntax innerInvocation);
    private static Location GetReportLocation(InvocationExpressionSyntax invocation);
    private static bool IsExpressionInLambdaIsCast(IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation, String& typeName);
    private static bool IsFirstExpressionInLambdaIsNullChecking(IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation);
    private static bool IsNullChecking(BinaryExpressionSyntax binaryExpression, string lambdaParameter);
    private static ExpressionSyntax GetExpressionFromLambda(ExpressionSyntax expression);
    private static string GetLambdaParameter(ExpressionSyntax expression);
    private static bool TryGetCastInLambda(SyntaxKind asOrIs, IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation, String& type);
    private static bool TryGetCastInLambda(IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation, String& type);
    private static bool CheckForSimplifiable(SonarSyntaxNodeReportingContext context, IMethodSymbol outerMethodSymbol, InvocationExpressionSyntax outerInvocation, IMethodSymbol innerMethodSymbol, InvocationExpressionSyntax innerInvocation);
    private static bool MethodIsNotUsingPredicate(IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation);
    [CompilerGeneratedAttribute]
internal static bool <CheckCountCall>g__HasCountProperty|18_0(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CollectionsShouldImplementGenericInterface : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static Dictionary`2<KnownType, string> NonGenericToGenericMapping;
    private static ImmutableArray`1<KnownType> GenericTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionsShouldImplementGenericInterface();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static string SuggestGenericCollectionType(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CommandPath : CommandPathBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal CommandPath(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string FirstArgument(InvocationContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CommentedOutCode : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string MessageFormat;
    private static int CommentMarkLength;
    private static String[] CodeEndings;
    private static String[] CodeParts;
    private static String[] CodePartsWithRelationalOperator;
    private static String[] RelationalOperators;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CommentedOutCode();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckTrivia(SonarSyntaxTreeReportingContext context, IEnumerable`1<SyntaxTrivia> trivia);
    private static void CheckMultilineComment(SonarSyntaxTreeReportingContext context, SyntaxTrivia trivia);
    internal static bool IsCode(string line);
    private static bool ContainsMultipleLogicalOperators(string checkedLine);
    private static bool ContainsCodeParts(string checkedLine);
    private static bool ContainsCodePartsWithRelationalOperator(string checkedLine);
    private static bool EndsWithCode(string checkedLine);
    [CompilerGeneratedAttribute]
internal static string <CheckMultilineComment>g__TriviaContent|13_0(<>c__DisplayClass13_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CommentedOutCodeCodeFix : SonarCodeFix {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static bool IsCode(SyntaxTrivia trivia);
    private static bool IsCode(string line);
    private static String[] Lines(SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CommentKeyword : CommentKeywordBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual bool IsComment(SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CommentsShouldNotBeEmpty : CommentsShouldNotBeEmptyBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string GetCommentText(SyntaxTrivia trivia);
    private static string GetSingleLineText(SyntaxTrivia trivia);
    private static string GetSingleLineDocumentationText(SyntaxTrivia trivia);
    private static string GetMultiLineText(SyntaxTrivia trivia);
    private static string GetMultiLineDocumentationText(SyntaxTrivia trivia);
    private static string ParseMultiLine(string commentText, int initialTrimSize);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ComparableInterfaceImplementation : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string ObjectEquals;
    private static ImmutableArray`1<KnownType> ComparableInterfaces;
    private static ComparisonKind[] ComparisonKinds;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ComparableInterfaceImplementation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<string> GetImplementedComparableInterfaces(INamedTypeSymbol classSymbol);
    private static string GetClassNameOnly(INamedTypeSymbol typeSymbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ComparableInterfaceImplementation/<GetMembersToOverride>d__12")]
private static IEnumerable`1<string> GetMembersToOverride(IEnumerable`1<IMethodSymbol> methods);
    private static string CSharp(ComparisonKind kind);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CompareNaN : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatEquality;
    private static string MessageFormatComparison;
    private static DiagnosticDescriptor Rule;
    private static Dictionary`2<KnownType, string> KnownTypeAliasMap;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CompareNaN();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool TryGetFloatingPointType(SyntaxNode expression, SemanticModel semanticModel, KnownType& floatingPointType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalSimplification : SonarDiagnosticAnalyzer {
    internal static string SimplifiedOperatorKey;
    internal static string IsCoalesceAssignmentSupportedKey;
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageMultipleNegation;
    private static string CoalesceAssignmentOp;
    private static string CoalesceOp;
    private static string TernaryOp;
    private static DiagnosticDescriptor Rule;
    private static DiagnosticDescriptor RuleMultipleNegation;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConditionalSimplification();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    internal static bool IsCoalesceAssignmentCandidate(SyntaxNode conditional, ExpressionSyntax comparedToNull);
    internal static StatementSyntax ExtractSingleStatement(StatementSyntax statement);
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckNotPattern(SonarSyntaxNodeReportingContext context);
    private static void CheckCoalesceExpression(SonarSyntaxNodeReportingContext context);
    private static void CheckIfStatement(SonarSyntaxNodeReportingContext context);
    private static void CheckConditionalExpression(SonarSyntaxNodeReportingContext context);
    private static bool AreTypesCompatible(ExpressionSyntax first, ExpressionSyntax second, SemanticModel semanticModel, ITypeSymbol targetType);
    private static bool IsNullAndValueType(ITypeSymbol typeNull, ITypeSymbol typeValue);
    private static bool CanBeSimplified(SonarSyntaxNodeReportingContext context, StatementSyntax statement1, StatementSyntax statement2, SyntaxNode comparedToNull, SemanticModel semanticModel, bool comparedIsNullInTrue, String& simplifiedOperator);
    private static bool AreCandidateAssignments(ExpressionSyntax expression1, ExpressionSyntax expression2, SyntaxNode compared, SemanticModel semanticModel, bool comparedIsNullInTrue, String& simplifiedOperator);
    private static bool AreCandidateInvocations(ExpressionSyntax firstExpression, ExpressionSyntax secondExpression, SyntaxNode comparedToNull, SemanticModel semanticModel, bool comparedIsNullInTrue);
    private static bool CanExpressionBeCoalescing(ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, SyntaxNode comparedToNull, SemanticModel semanticModel, bool comparedIsNullInTrue);
    private static ImmutableDictionary`2<string, string> BuildCodeFixProperties(SonarSyntaxNodeReportingContext c, string simplifiedOperator);
    private static bool IsConditionalStructure(SyntaxNode syntaxNode);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <CheckNotPattern>g__GetNegationRoot|16_0(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalSimplificationCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ConditionalSimplificationCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode Simplify(Diagnostic diagnostic, SemanticModel semanticModel, SyntaxNode oldNode);
    private static SyntaxNode ReduceDoubleNegation(SyntaxNode node);
    private static StatementSyntax SimplifyIfStatement(ComparedContext context, StatementSyntax statement1, StatementSyntax statement2, ExpressionSyntax condition);
    private static ExpressionSyntax SimplifyIfExpression(ComparedContext context, ExpressionStatementSyntax statement1, ExpressionStatementSyntax statement2, ExpressionSyntax condition);
    private static ExpressionSyntax SimplifyAssignmentExpression(ComparedContext context, ExpressionSyntax expression1, ExpressionSyntax expression2, ExpressionSyntax condition, bool isCoalescing);
    private static ExpressionSyntax SimplifyCoalesceExpression(ComparedContext context, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    private static ExpressionSyntax CoalesceAssignmentExpression(ComparedContext context, ExpressionSyntax assignmentExpression);
    private static ExpressionSyntax CoalesceAssignmentExpression(ComparedContext context, ExpressionSyntax left, ExpressionSyntax right);
    private static ExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right);
    private static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax truePart, ExpressionSyntax falsePart);
    private static ExpressionSyntax SimplifyInvocationExpression(ComparedContext context, ExpressionSyntax expression1, ExpressionSyntax expression2, ExpressionSyntax condition, bool isCoalescing);
    private static ArgumentListSyntax SimplifyInvocationArguments(ComparedContext context, InvocationExpressionSyntax methodCall1, InvocationExpressionSyntax methodCall2, ExpressionSyntax condition, bool isCoalescing);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalsShouldStartOnNewLine : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConditionalsShouldStartOnNewLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool TryGetPreviousTokenInSameLine(SyntaxToken token, SyntaxToken& previousToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalStructureSameCondition : ConditionalStructureSameConditionBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalStructureSameImplementation : ConditionalStructureSameImplementationBase {
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> IgnoredStatementsInSwitch;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConditionalStructureSameImplementation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasDefaultClause(SwitchStatementSyntax switchStatement);
    private static bool HasLeafElseClause(IfStatementSyntax ifStatement);
    private static void CheckStatement(SonarSyntaxNodeReportingContext context, SyntaxNode node, IReadOnlyList`1<SyntaxNode> precedingBranches, SemanticModel model, bool hasElse, string discriminator);
    private static bool AreEquivalentStatements(SyntaxNode node, SyntaxNode otherNode, SemanticModel model);
    private static int GetStatementsCount(SyntaxNode node);
    private static void ReportSyntaxNode(SonarSyntaxNodeReportingContext context, SyntaxNode node, SyntaxNode precedingNode, string errorMessageDiscriminator);
    private static bool IsApprovedStatement(SyntaxNode statement);
    private static bool HaveTheSameInvocations(SyntaxList`1<SyntaxNode> first, SyntaxList`1<SyntaxNode> second, SemanticModel model);
    private static bool HaveTheSameInvocations(SyntaxNode first, SyntaxNode second, SemanticModel model);
    private static bool HaveTheSameInvocations(InvocationExpressionSyntax[] referenceInvocations, InvocationExpressionSyntax[] candidateInvocations, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConditionalsWithSameCondition : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConditionalsWithSameCondition();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckMatchingExpressionsInSucceedingStatements(SonarSyntaxNodeReportingContext context, Func`2<T, ExpressionSyntax> expression);
    private static bool ContainsPossibleUpdate(StatementSyntax statement, ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConfiguringLoggers : ConfiguringLoggersBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal ConfiguringLoggers(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConstructorArgumentValueShouldExist : ConstructorArgumentValueShouldExistBase {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConstructorArgumentValueShouldExist();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual IEnumerable`1<string> GetAllParentClassConstructorArgumentNames(SyntaxNode propertyDeclaration);
    protected virtual void ReportIssue(SonarSyntaxNodeReportingContext c, AttributeData constructorArgumentAttribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConstructorOverridableCall : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConstructorOverridableCall();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckOverridableCallInConstructor(SonarSyntaxNodeReportingContext context);
    private static bool IsMethodOverridable(IMethodSymbol methodSymbol);
    private static bool IsMethodConstructor(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ConsumeValueTaskCorrectly : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string MessageFormat;
    private static string ConsumeOnlyOnceMessage;
    private static string ConsumeOnlyIfCompletedMessage;
    private static DiagnosticDescriptor rule;
    private static ImmutableArray`1<KnownType> ValueTaskTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConsumeValueTaskCorrectly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ControlCharacterInString : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static IDictionary`2<char, string> EscapedControlCharacters;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ControlCharacterInString();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckControlCharacter(SonarSyntaxNodeReportingContext c, string text, int displayPosIncrement);
    private static bool IsInescapableString(SyntaxNode syntaxNode);
    private static bool IsInescepableInterpolatedString(SyntaxNode syntaxNode);
    private static bool IsInescapableUtf8String(SyntaxNode syntaxNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ControllersHaveMixedResponsibilities : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string UnspeakableIndexerName;
    private static HashSet`1<string> ExcludedWellKnownServices;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ControllersHaveMixedResponsibilities();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static Action`1<SonarCodeBlockStartAnalysisContext`1<SyntaxKind>> PopulateDependencies(ImmutableDictionary`2<string, MemberType> relevantMembers, ConcurrentStack`1<Dependency> dependencies);
    private static Action`1<SonarSymbolReportingContext> CalculateAndReportOnResponsibilities(INamedTypeSymbol controllerSymbol, ImmutableDictionary`2<string, MemberType> relevantMembers, ConcurrentStack`1<Dependency> dependencies);
    private static List`1<List`1<string>> ResponsibilityGroups(ImmutableDictionary`2<string, MemberType> relevantMembers, ConcurrentStack`1<Dependency> dependencies);
    private static string BlockName(SyntaxNode block);
    private static ImmutableDictionary`2<string, MemberType> RelevantMembers(INamedTypeSymbol symbol);
    private static bool IsService(ISymbol symbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ControllersHaveMixedResponsibilities/<SecondaryLocations>d__15")]
private static IEnumerable`1<SecondaryLocation> SecondaryLocations(INamedTypeSymbol controllerSymbol, List`1<List`1<string>> sets);
    private static IEnumerable`1<Location> IdentifierLocations(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ControllersReuseClient : ReuseClientBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ImmutableArray`1<KnownType> ReusableClients { get; }
    private static ControllersReuseClient();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ImmutableArray`1<KnownType> get_ReusableClients();
    protected virtual void Initialize(SonarAnalysisContext context);
    public static bool IsInPublicMethod(SyntaxNode node);
    private static bool IsInsideConstructor(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(SonarSymbolStartAnalysisContext symbolStartContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_2(SonarSyntaxNodeReportingContext nodeContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CookieShouldBeHttpOnly : ObjectShouldBeInitializedCorrectlyBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> TrackedTypes;
    [CompilerGeneratedAttribute]
private CSharpObjectInitializationTracker <ObjectInitializationTracker>k__BackingField;
    protected CSharpObjectInitializationTracker ObjectInitializationTracker { get; }
    internal CookieShouldBeHttpOnly(IAnalyzerConfiguration analyzerConfiguration);
    private static CookieShouldBeHttpOnly();
    [CompilerGeneratedAttribute]
protected virtual CSharpObjectInitializationTracker get_ObjectInitializationTracker();
    protected virtual bool IsDefaultConstructorSafe(SonarCompilationStartAnalysisContext context);
    protected virtual void Initialize(TrackerInput input);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CookieShouldBeSecure : ObjectShouldBeInitializedCorrectlyBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> TrackedTypes;
    [CompilerGeneratedAttribute]
private CSharpObjectInitializationTracker <ObjectInitializationTracker>k__BackingField;
    protected CSharpObjectInitializationTracker ObjectInitializationTracker { get; }
    internal CookieShouldBeSecure(IAnalyzerConfiguration configuration);
    private static CookieShouldBeSecure();
    [CompilerGeneratedAttribute]
protected virtual CSharpObjectInitializationTracker get_ObjectInitializationTracker();
    protected virtual bool IsDefaultConstructorSafe(SonarCompilationStartAnalysisContext context);
    protected virtual void Initialize(TrackerInput input);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CopyPasteTokenAnalyzer : CopyPasteTokenAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsUsingDirective(SyntaxNode node);
    protected virtual string GetCpdValue(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CreatingHashAlgorithms : CreatingHashAlgorithmsBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal CreatingHashAlgorithms(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.CryptographicKeyShouldNotBeTooShort : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string UselessAssignmentInfo;
    private static int MinimalCommonKeyLength;
    private static int MinimalEllipticCurveKeyLength;
    private Regex namedEllipticCurve;
    private static ImmutableArray`1<KnownType> BouncyCastleCurveClasses;
    private static ImmutableArray`1<KnownType> SystemSecurityCryptographyDsaRsa;
    private static ImmutableArray`1<KnownType> SystemSecurityCryptographyCurveClasses;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CryptographicKeyShouldNotBeTooShort();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckAlgorithmCreation(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, InvocationExpressionSyntax invocation);
    private void CheckBouncyCastleEllipticCurve(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, InvocationExpressionSyntax invocation);
    private void CheckSystemSecurityEllipticCurve(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, SyntaxNode syntaxElement, ArgumentListSyntax argumentList);
    private void CheckCurveNameKeyLength(SonarSyntaxNodeReportingContext c, SyntaxNode syntaxElement, string curveName);
    private static void CheckSystemSecurityCryptographyAlgorithms(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, IObjectCreation objectCreation);
    private static bool HasDefaultSize(SonarSyntaxNodeReportingContext c, ArgumentListSyntax argumentList);
    private static void CheckGenericDsaRsaCryptographyAlgorithms(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, SyntaxNode syntaxElement, SyntaxNode keyLengthSyntax);
    private static void CheckBouncyCastleParametersGenerators(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, InvocationExpressionSyntax invocation);
    private static void CheckBouncyCastleKeyGenerationParameters(SonarSyntaxNodeReportingContext c, ITypeSymbol containingType, IObjectCreation objectCreation);
    private static bool IsInvalidCommonKeyLength(SonarSyntaxNodeReportingContext c, SyntaxNode keyLengthSyntax);
    private static string GetMethodName(InvocationExpressionSyntax invocationExpression);
    private static string GetPropertyName(ExpressionSyntax expression);
    private static string CipherName(ITypeSymbol containingType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DangerousGetHandleShouldNotBeCalled : DangerousGetHandleShouldNotBeCalledBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DatabasePasswordsShouldBeSecure : TrackerHotspotDiagnosticAnalyzer`1<SyntaxKind> {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static Regex Sanitizers;
    private static MemberDescriptor[] TrackedInvocations;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static DatabasePasswordsShouldBeSecure();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(TrackerInput input);
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckWebConfig(SonarCompilationReportingContext c);
    private void CheckAppSettings(SonarCompilationReportingContext c);
    private void CheckAppSettingJson(SonarCompilationReportingContext c, string fullPath);
    private void ReportEmptyPassword(SonarCompilationReportingContext c, XDocument doc, string webConfigPath);
    private void ReportEmptyPassword(SonarCompilationReportingContext c, JsonNode doc, string appSettingsPath);
    private static Condition<SyntaxKind, InvocationContext> HasEmptyPasswordArgument();
    private static ArgumentSyntax ConnectionStringArgument(SeparatedSyntaxList`1<ArgumentSyntax> argumentList);
    private static bool HasEmptyPasswordAndNoSanitizers(ExpressionSyntax expression);
    private static bool IsVulnerable(string connectionString);
    private static bool HasSanitizers(string connectionString);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DateAndTimeShouldNotBeUsedAsTypeForPrimaryKey : DateAndTimeShouldNotBeUsedasTypeForPrimaryKeyBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IEnumerable`1<SyntaxNode> TypeNodesOfTemporalKeyProperties(SonarSyntaxNodeReportingContext context);
    private static bool IsCandidateProperty(PropertyDeclarationSyntax property);
    private bool IsKeyProperty(PropertyDeclarationSyntax property, string className);
    private bool HasKeyAttribute(PropertyDeclarationSyntax property);
    [CompilerGeneratedAttribute]
private bool <HasKeyAttribute>b__5_1(AttributeSyntax x);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DateTimeFormatShouldNotBeHardcoded : DateTimeFormatShouldNotBeHardcodedBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual Location HardCodedArgumentLocation(InvocationExpressionSyntax invocation);
    protected virtual bool HasInvalidFirstArgument(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static ExpressionSyntax GetFormatArgumentExpression(ArgumentListSyntax argumentList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DeadStores : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static String[] AllowedNumericValues;
    private static String[] AllowedStringValues;
    private bool useSonarCfg;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal DeadStores(IAnalyzerConfiguration configuration);
    private static DeadStores();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckForDeadStores(SonarSyntaxNodeReportingContext context, ISymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DebugAssertHasNoSideEffects : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> sideEffectWords;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DebugAssertHasNoSideEffects();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static string GetIdentifierName(InvocationExpressionSyntax invocation);
    private static bool IsDebugAssert(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation);
    private static bool ContainsCallsWithSideEffects(InvocationExpressionSyntax invocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DebuggerDisplayUsesExistingMembers : DebuggerDisplayUsesExistingMembersBase`2<AttributeSyntax, SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode AttributeFormatString(AttributeSyntax attribute);
    protected virtual bool IsValidMemberName(string memberName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DeclareEventHandlersCorrectly : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static int SenderArgumentPosition;
    private static int EventArgsPosition;
    private static int DelegateEventHandlerArgCount;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DeclareEventHandlersCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeEventType(SonarSyntaxNodeReportingContext analysisContext, TypeSyntax typeSyntax, ISymbol eventSymbol);
    private static bool IsCorrectEventHandlerSignature(IMethodSymbol methodSymbol);
    private static bool IsDerivedFromEventArgs(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DeclareTypesInNamespaces : DeclareTypesInNamespacesBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual SyntaxToken GetTypeIdentifier(SyntaxNode declaration);
    protected virtual bool IsInnerTypeOrWithinNamespace(SyntaxNode declaration, SemanticModel semanticModel);
    protected virtual bool IsException(SyntaxNode node);
    private static bool IsTopLevelStatementPartialProgramClass(SyntaxNode declaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DefaultSectionShouldBeFirstOrLast : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DefaultSectionShouldBeFirstOrLast();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DelegateSubtraction : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DelegateSubtraction();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool BinaryIsValidSubstraction(BinaryExpressionSyntax subtraction);
    private static bool IsTopLevelSubtraction(BinaryExpressionSyntax subtraction);
    private static bool IsDelegateSubtraction(SyntaxNode node, SemanticModel semanticModel);
    private static bool ExpressionIsSimple(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DeliveringDebugFeaturesInProduction : DeliveringDebugFeaturesInProductionBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal DeliveringDebugFeaturesInProduction(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsDevelopmentCheckInvoked(SyntaxNode node, SemanticModel semanticModel);
    protected virtual bool IsInDevelopmentContext(SyntaxNode node);
    private bool IsDevelopmentCheck(SyntaxNode node, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisablingCsrfProtection : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static SyntaxKind ImplicitObjectCreationExpression;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public DisablingCsrfProtection(IAnalyzerConfiguration configuration);
    private static DisablingCsrfProtection();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckIgnoreAntiforgeryTokenAttribute(SonarSyntaxNodeReportingContext c);
    private static void ReportDiagnostic(SonarSyntaxNodeReportingContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarCompilationStartAnalysisContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisablingRequestValidation : DisablingRequestValidationBase {
    protected ILanguageFacade Language { get; }
    public DisablingRequestValidation(IAnalyzerConfiguration analyzerConfiguration);
    protected virtual ILanguageFacade get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposableMemberInNonDisposableClass : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableMemberInNonDisposableClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ShouldExclude(ITypeSymbol typeSymbol);
    private static string GetMessage(SonarSymbolReportingContext context, INamespaceOrTypeSymbol namedType);
    private static IEnumerable`1<IFieldSymbol> GetAssignmentsToFieldsIn(ISymbol m, Compilation compilation);
    private static bool IsOwnerSinceDeclaration(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposableNotDisposed : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> TrackedTypes;
    private static ImmutableArray`1<KnownType> DisposableTypes;
    private static ISet`1<string> DisposeMethods;
    private static ISet`1<string> FactoryMethods;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableNotDisposed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static NodeAndModel`1<SyntaxNode> CreateNodeAndModel(SonarSymbolReportingContext c, SyntaxReference syntaxReference);
    private static void TrackInitializedLocalsAndPrivateFields(INamedTypeSymbol namedType, SyntaxNode typeDeclaration, SemanticModel semanticModel, ISet`1<NodeAndSymbol> disposableObjects);
    private static void TrackAssignmentsToLocalsAndPrivateFields(INamedTypeSymbol namedType, SyntaxNode typeDeclaration, SemanticModel semanticModel, ISet`1<NodeAndSymbol> disposableObjects);
    private static bool IsNodeInsideUsingStatement(SyntaxNode node);
    private static IEnumerable`1<SyntaxNode> GetDescendantNodes(INamedTypeSymbol namedType, SyntaxNode typeDeclaration);
    private static bool IsLocalOrPrivateField(ISymbol symbol);
    private static void ExcludeDisposedAndClosedLocalsAndPrivateFields(SyntaxNode typeDeclaration, SemanticModel semanticModel, ISet`1<ISymbol> possiblyDisposed);
    private static void ExcludeReturnedPassedAndAliasedLocalsAndPrivateFields(SyntaxNode typeDeclaration, SemanticModel semanticModel, ISet`1<ISymbol> possiblyDisposed);
    private static bool IsStandaloneExpression(ExpressionSyntax expression);
    private static bool IsInstantiation(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsNewTrackedTypeObjectCreation(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsDisposableRefStructCreation(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsFactoryMethodInvocation(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposableReturnedFromUsing : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableReturnedFromUsing();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckReturns(SonarSyntaxNodeReportingContext c, SyntaxToken usingKeyword, SyntaxNode body, HashSet`1<ISymbol> declaredSymbols);
    private static ISet`1<ISymbol> GetReturnedSymbols(SyntaxNode body, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposableTypesNeedFinalizers : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> NativeHandles;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableTypesNeedFinalizers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasNativeHandleFields(TypeDeclarationSyntax classDeclaration, SemanticModel semanticModel);
    private static bool HasFinalizer(TypeDeclarationSyntax classDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposeFromDispose : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string DisposeMethodName;
    private static string DisposeMethodExplicitName;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposeFromDispose();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool FieldDisposedInDispose(SemanticModel model, IFieldSymbol invocationTarget);
    private static bool FieldIsDisposedIn(SemanticModel model, IFieldSymbol invocationTarget, IMethodSymbol dispose);
    private static bool FieldDeclaredInType(SemanticModel model, InvocationExpressionSyntax invocation, IFieldSymbol invocationTarget);
    private static bool InvocationTargetAndName(InvocationExpressionSyntax invocation, ExpressionSyntax& target, SimpleNameSyntax& name);
    private static bool IsDisposableClassOrStruct(INamedTypeSymbol type, LanguageVersion languageVersion);
    private static bool IsCalledInsideDispose(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsDisposeMethodCalled(InvocationExpressionSyntax invocation, SemanticModel semanticModel, LanguageVersion languageVersion);
    private static IMethodSymbol IDisposableDisposeMethodSymbol(Compilation compilation);
    private static bool IsMethodMatchingDisposeMethodName(IMethodSymbol enclosingMethodSymbol);
    private static bool ImplementsDisposable(INamedTypeSymbol containingType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DisposeNotImplementingDispose : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string DisposeMethodName;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposeNotImplementingDispose();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CollectInvocationsFromDisposeImplementation(IMethodSymbol disposeMethod, Compilation compilation, HashSet`1<IMethodSymbol> mightImplementDispose, HashSet`1<IMethodSymbol> disposeMethodsCalledFromDispose);
    private static void CollectDisposeMethodsCalledFromDispose(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, HashSet`1<IMethodSymbol> disposeMethodsCalledFromDispose);
    private static void ReportDisposeMethods(SonarSymbolReportingContext context, IEnumerable`1<IMethodSymbol> disposeMethods);
    private static void CollectMethodsNamedAndImplementingDispose(IMethodSymbol methodSymbol, IMethodSymbol disposeMethod, HashSet`1<IMethodSymbol> namedDispose, HashSet`1<IMethodSymbol> mightImplementDispose);
    private static bool MethodIsDisposeImplementation(IMethodSymbol methodSymbol, IMethodSymbol disposeMethod);
    private static bool MethodMightImplementDispose(IMethodSymbol declaredMethodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCallAssemblyGetExecutingAssemblyMethod : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCallAssemblyLoadInvalidMethods : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCallExitMethods : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual bool IsInValidContext(InvocationExpressionSyntax invocationSyntax, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCallGCCollectMethod : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCallGCSuppressFinalize : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual bool ShouldReportOnMethodCall(InvocationExpressionSyntax invocation, SemanticModel semanticModel, MemberDescriptor memberDescriptor);
}
public abstract class SonarAnalyzer.Rules.CSharp.DoNotCallMethodsCSharpBase : DoNotCallMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected DoNotCallMethodsCSharpBase(string diagnosticId);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCatchNullReferenceException : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCatchNullReferenceException();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsCatchingNullReferenceException(CatchDeclarationSyntax catchDeclaration, SemanticModel semanticModel);
    private static bool HasIsNullReferenceExceptionFilter(CatchFilterClauseSyntax catchFilterClause, SemanticModel semanticModel, Location& location);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCatchSystemException : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCatchSystemException();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsCatchClauseEmptyOrNotPattern(CatchClauseSyntax catchClause);
    private static bool IsSystemException(CatchDeclarationSyntax catchDeclaration, SemanticModel semanticModel);
    private static bool IsThrowTheLastStatementInTheBlock(BlockSyntax block);
    private static Location GetLocation(CatchClauseSyntax catchClause);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCheckZeroSizeCollection : DoNotCheckZeroSizeCollectionBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected string IEnumerableTString { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string get_IEnumerableTString();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void AnalyzePropertyPatternClause(SonarSyntaxNodeReportingContext c);
    private void AnalyzePatterns(SonarSyntaxNodeReportingContext c, ExpressionSyntax expression, SyntaxNode pattern);
    private void AnalyzeIsPatternExpression(SonarSyntaxNodeReportingContext c);
    private void AnalyzeSwitchExpression(SonarSyntaxNodeReportingContext c);
    private void AnalyzeSwitchStatement(SonarSyntaxNodeReportingContext c);
    private void CheckPatternCondition(SonarSyntaxNodeReportingContext context, SyntaxNode expression, SyntaxNode pattern);
    [CompilerGeneratedAttribute]
internal static ComparisonKind <CheckPatternCondition>g__ComparisonKind|10_1(SyntaxToken syntaxToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotCopyArraysInProperties : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor s2365;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCopyArraysInProperties();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SyntaxNode GetPropertyBody(PropertyDeclarationSyntax property);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotDecreaseMemberVisibility : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDecreaseMemberVisibility();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotExposeListT : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotExposeListT();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportIfListT(SonarSyntaxNodeReportingContext context, TypeSyntax typeSyntax, string memberType);
    private static bool IsOrdinaryMethodOrConstructor(IMethodSymbol method);
    private static bool HasXmlElementAttribute(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotHardcodeCredentials : DoNotHardcodeCredentialsBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal DoNotHardcodeCredentials(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void InitializeActions(SonarParametrizedAnalysisContext context);
    protected virtual bool IsSecureStringAppendCharFromConstant(SyntaxNode argumentNode, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <InitializeActions>b__4_0(SonarCompilationStartAnalysisContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotHideBaseClassMethods : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotHideBaseClassMethods();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotInstantiateSharedClasses : DoNotInstantiateSharedClassesBase {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotInstantiateSharedClasses();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotLockOnSharedResource : DoNotLockOnSharedResourceBase {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotLockOnSharedResource();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsLockOnThis(ExpressionSyntax expression);
    private static bool IsLockOnStringLiteral(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotLockWeakIdentityObjects : DoNotLockWeakIdentityObjectsBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private SyntaxKind <SyntaxKind>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind SyntaxKind { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind get_SyntaxKind();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotMarkEnumsWithFlags : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotMarkEnumsWithFlags();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static Nullable`1<BigInteger> GetEnumValueOrDefault(IFieldSymbol enumMember);
    private static bool IsValidFlagValue(Nullable`1<BigInteger> enumValue, IEnumerable`1<BigInteger> allValues);
    private static bool IsZeroOrPowerOfTwo(BigInteger value);
    private static bool IsCombinationOfOtherValues(BigInteger value, IEnumerable`1<BigInteger> otherValues);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotNestTernaryOperators : DoNotNestTernaryOperatorsBase {
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotNestTernaryOperators();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotNestTypesInArguments : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotNestTypesInArguments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool MaxDepthReached(SyntaxNode parameterSyntax, SemanticModel model);
    private static IEnumerable`1<ParameterSyntax> GetParametersSyntaxNodes(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotOverloadOperatorEqual : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> InterfacesRelyingOnOperatorEqualOverload;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotOverloadOperatorEqual();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForIssue(SonarSyntaxNodeReportingContext analysisContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotOverwriteCollectionElements : DoNotOverwriteCollectionElementsBase`2<SyntaxKind, ExpressionStatementSyntax> {
    private static HashSet`1<SyntaxKind> IdentifierOrLiteral;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static DoNotOverwriteCollectionElements();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual SyntaxNode GetCollectionIdentifier(ExpressionStatementSyntax statement);
    protected virtual SyntaxNode GetIndexOrKey(ExpressionStatementSyntax statement);
    protected virtual bool IsIdentifierOrLiteral(SyntaxNode syntaxNode);
    private static SyntaxNode GetAssignmentOrInvocation(StatementSyntax statement);
    private static ArgumentSyntax GetIndexOrKeyArgument(StatementSyntax statement);
    private static SyntaxNode GetInvokedMethodContainer(InvocationExpressionSyntax invocation);
    private static SyntaxNode GetIdentifier(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotShiftByZeroOrIntSize : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormatUseLargerTypeOrPromote;
    private static string MessageFormatShiftTooLarge;
    private static string MessageFormatRightShiftTooLarge;
    private static string MessageFormatUselessShift;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableDictionary`2<KnownType, int> MapKnownTypesToIntegerBitSize;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotShiftByZeroOrIntSize();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ContainsShiftExpressionWithinTwoLines(HashSet`1<int> linesWithShiftOperations, int lineNumber);
    private static Tuple`2<Shift, ExpressionSyntax> GetRhsArgumentOfShiftNode(SyntaxNode node);
    private static bool TryGetConstantValue(ExpressionSyntax expression, Int32& value);
    private static ShiftInstance FindShiftInstance(SyntaxNode node, SemanticModel semanticModel);
    private static int FindTypeSizeOrDefault(ITypeSymbol typeSymbol);
    private static string FindProblemDescription(int typeSizeInBits, int shiftBy, Shift shiftDirection, Boolean& isLiteralZero);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotTestThisWithIsOperator : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotTestThisWithIsOperator();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeIsExpression(SonarSyntaxNodeReportingContext context);
    private static void AnalyzeIsPatternExpression(SonarSyntaxNodeReportingContext context);
    private static void AnalyzeSwitchStatement(SonarSyntaxNodeReportingContext context);
    private static void AnalyzeSwitchExpression(SonarSyntaxNodeReportingContext context);
    private static IList`1<SecondaryLocation> CollectSecondaryLocations(SwitchStatementSyntax switchStatement);
    private static IList`1<SecondaryLocation> CollectSecondaryLocations(SwitchExpressionSyntaxWrapper switchExpression);
    private static bool ContainsTypeCheckInCaseSwitchLabel(SwitchLabelSyntax switchLabel);
    private static bool ContainsTypeCheckInPattern(SyntaxNode syntaxNode);
    private static bool IsTypeCheckOnThis(SyntaxNode pattern);
    private static bool IsNotInSubPattern(SyntaxNode node);
    private static void ReportDiagnostic(SonarSyntaxNodeReportingContext context, SyntaxNode node);
    private static void ReportDiagnostic(SonarSyntaxNodeReportingContext context, SyntaxNode node, IList`1<SecondaryLocation> secondaryLocations);
    private static Location TypeMatchLocation(SwitchLabelSyntax label);
    private static bool IsThisExpressionSyntax(SyntaxNode syntaxNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotThrowFromDestructors : DoNotThrowFromDestructorsBase {
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotThrowFromDestructors();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotUseCollectionInItsOwnMethodCalls : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string AlwaysEmptyCollectionMessage;
    private static string AlwaysSameCollectionMessage;
    private static string AlwaysTrueMessage;
    private static string AlwaysFalseMessage;
    private static string UnexpectedBehaviorMessage;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> trackedMethodNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseCollectionInItsOwnMethodCalls();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static OperandsToCheck GetOperandsToCheckIfTrackedMethod(InvocationExpressionSyntax invocation, SemanticModel model);
    private static string ProcessIssueMessageFromMethod(IMethodSymbol methodSymbol, Boolean& isEnumerableMethod);
    private static bool IsISetUnionWithImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetExceptWithImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetIntersectWithImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetIsProperSubsetOfImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetIsProperSupersetOfImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetIsSubsetOfImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetIsSupersetOfImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetOverlapsImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetSetEqualsImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetSymmetricExceptWithImplementation(IMethodSymbol methodSymbol);
    private static bool IsISetMethodImplementation(IMethodSymbol methodSymbol, string methodName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotUseDateTimeNow : DoNotUseDateTimeNowBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsInsideNameOf(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotUseLiteralBoolInAssertions : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static Dictionary`2<KnownType, HashSet`1<string>> TrackedTypeAndMethods;
    private static ISet`1<SyntaxKind> BoolLiterals;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseLiteralBoolInAssertions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsWorkingWithNullableType(IMethodSymbol methodSymbol, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SemanticModel semanticModel);
    private static bool IsFirstOrSecondArgumentABoolLiteral(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    private static bool IsBooleanLiteral(ArgumentSyntax argument);
    private static bool IsTrackedMethod(ISymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotUseOutRefParameters : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseOutRefParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsTryPattern(IMethodSymbol method, SyntaxToken modifier);
    private static bool IsRefOrOut(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotUseRandom : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public DoNotUseRandom(IAnalyzerConfiguration analyzerConfiguration);
    private static DoNotUseRandom();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarCompilationStartAnalysisContext ccc);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DoNotWriteToStandardOutput : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ISet`1<string> BannedConsoleMembers;
    protected static DiagnosticDescriptor Rule { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotWriteToStandardOutput();
    protected static DiagnosticDescriptor get_Rule();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DontMixIncrementOrDecrementWithOtherOperators : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<SyntaxKind> arithmeticOperator;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DontMixIncrementOrDecrementWithOtherOperators();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DontUseTraceSwitchLevels : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<string> TraceSwitchProperties;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DontUseTraceSwitchLevels();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SyntaxNode UsesTraceSwitchAsCondition(SemanticModel model, IMethodSymbol methodSymbol, InvocationExpressionSyntax invocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DontUseTraceWrite : DoNotCallMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual string get_MessageFormat();
    protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool ShouldReportOnMethodCall(InvocationExpressionSyntax invocation, SemanticModel semanticModel, MemberDescriptor memberDescriptor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.DurableEntityInterfaceRestrictions : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string SignalEntityName;
    private static string SignalEntityAsyncName;
    private static string CreateEntityProxyName;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DurableEntityInterfaceRestrictions();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsRestrictedMethod(IMethodSymbol method);
    private static string InterfaceErrorMessage(INamedTypeSymbol entityInterface);
    private static string MemberErrorMessage(ISymbol member);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyMethod : EmptyMethodBase`1<SyntaxKind> {
    internal static SyntaxKind[] SupportedSyntaxKinds;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    private static EmptyMethod();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual void CheckMethod(SonarSyntaxNodeReportingContext context);
    private static bool ShouldBeExcluded(SonarSyntaxNodeReportingContext context, SyntaxNode node, SyntaxTokenList modifiers);
    private static SyntaxToken ReportingToken(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyMethodCodeFix : SonarCodeFix {
    internal static string TitleThrow;
    internal static string TitleComment;
    private static string LiteralNotSupportedException;
    private static string LiteralSystem;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.EmptyMethodCodeFix/<RegisterCodeFixesAsync>d__6")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.EmptyMethodCodeFix/<RegisterCodeFixesForMethodsAsync>d__7")]
private static Task RegisterCodeFixesForMethodsAsync(SonarCodeFixContext context, SyntaxNode root, BlockSyntax methodBody);
    private static bool NamespaceNeedsToBeAdded(BlockSyntax methodBody, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyNamespace : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EmptyNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyNamespaceCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyNestedBlock : EmptyNestedBlockBase`1<SyntaxKind> {
    private static SyntaxKind[] AllowedContainerKinds;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    private static EmptyNestedBlock();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual IEnumerable`1<SyntaxNode> EmptyBlocks(SyntaxNode node);
    private static bool IsEmpty(SwitchStatementSyntax node);
    private static bool IsNestedAndEmpty(BlockSyntax node);
    private static bool IsNested(BlockSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyStatement : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EmptyStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EmptyStatementCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static bool IsInBlock(SyntaxNode node);
    internal static SyntaxNode RemoveUnusedCode(SyntaxNode root, SyntaxNode syntaxNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EncryptionAlgorithmsShouldBeSecure : EncryptionAlgorithmsShouldBeSecureBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual Condition<SyntaxKind, PropertyAccessContext> IsInsideObjectInitializer();
    protected virtual Condition<SyntaxKind, InvocationContext> HasPkcs1PaddingArgument();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EnumerableSumInUnchecked : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> DisallowedTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumerableSumInUnchecked();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsSumInsideUnchecked(InvocationExpressionSyntax invocation);
    private static bool IsUncheckedExpression(SyntaxNode node);
    private static bool IsUncheckedStatement(SyntaxNode node);
    private static bool IsSumOnInteger(IMethodSymbol methodSymbol);
    private static bool IsReturnTypeCandidate(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EnumNameHasEnumSuffix : EnumNameHasEnumSuffixBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EnumNameShouldFollowRegex : EnumNameShouldFollowRegexBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EnumsShouldNotBeNamedReserved : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumsShouldNotBeNamedReserved();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EnumStorageNeedsToBeInt32 : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumStorageNeedsToBeInt32();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsDefaultOrLarger(SyntaxNode syntaxNode, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EqualityOnFloatingPoint : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static Dictionary`2<string, string> SpecialMembers;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EqualityOnFloatingPoint();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckLogicalExpression(SonarSyntaxNodeReportingContext context);
    private static string MessageEqualityPart(bool isEquality);
    private static void CheckEquality(SonarSyntaxNodeReportingContext context);
    private static string ProposedMessageForMemberAccess(SonarSyntaxNodeReportingContext context, ExpressionSyntax expression);
    private static string ProposedMessageForIdentifier(SonarSyntaxNodeReportingContext context, ExpressionSyntax expression);
    private static bool IsFloatingPointType(ITypeSymbol type);
    private static BinaryExpressionSyntax TryGetBinaryExpression(ExpressionSyntax expression);
    private static bool IsIndirectInequality(SemanticModel semanticModel, BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax left, BinaryExpressionSyntax right);
    private static bool IsIndirectEquality(SemanticModel semanticModel, BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax left, BinaryExpressionSyntax right);
    private static bool HasFloatingType(SemanticModel semanticModel, BinaryExpressionSyntax binary);
    private static bool IsExpressionFloatingType(SemanticModel semanticModel, ExpressionSyntax expression);
    private static bool IsOperatorPair(BinaryExpressionSyntax left, BinaryExpressionSyntax right, SyntaxKind first, SyntaxKind second);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EqualityOnModulus : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string CountName;
    private static string LongCountName;
    private static string LengthName;
    private static string LongLengthName;
    private static string ListCapacityName;
    private static String[] CollectionSizePropertyOrMethodNames;
    private static CSharpExpressionNumericConverter ExpressionNumericConverter;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EqualityOnModulus();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VisitEquality(SonarSyntaxNodeReportingContext c);
    private static bool CheckExpression(SyntaxNode node, ExpressionSyntax expression, SemanticModel semanticModel, Int32& constantValue);
    private static bool ExpressionIsAlwaysPositive(BinaryExpressionSyntax binaryExpression, SemanticModel semantic);
    private static bool IsCollectionSize(ISymbol symbol);
    private static bool IsEnumerableCountMethod(ISymbol symbol);
    private static bool IsLengthProperty(IPropertySymbol propertySymbol);
    private static bool IsCollectionCountProperty(IPropertySymbol propertySymbol);
    private static bool IsListCapacityProperty(IPropertySymbol propertySymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EquatableClassShouldBeSealed : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string EqualsMethodName;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EquatableClassShouldBeSealed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAnyInvalidIEquatableEqualsMethod(INamedTypeSymbol classSymbol);
    private static bool IsCompilableIEquatableTSymbol(INamedTypeSymbol namedTypeSymbol);
    private static bool IsIEquatableEqualsMethodCandidate(IMethodSymbol methodSymbol);
}
internal class SonarAnalyzer.Rules.CSharp.EquivalentNameSyntax : object {
    [CompilerGeneratedAttribute]
private NameSyntax <Name>k__BackingField;
    public NameSyntax Name { get; }
    public EquivalentNameSyntax(NameSyntax name);
    [CompilerGeneratedAttribute]
public NameSyntax get_Name();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EquivalentNameSyntax other);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.EventHandlerDelegateShouldHaveProperArguments : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string NullEventArgsMessage;
    private static string NullSenderMessage;
    private static string NonNullSenderMessage;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> EventHandlerTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EventHandlerDelegateShouldHaveProperArguments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEventSymbol GetEventSymbol(ExpressionSyntax expression, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionRethrow : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionRethrow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionRethrowCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionShouldNotBeThrownFromUnexpectedMethods : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> DefaultAllowedExceptions;
    private static ImmutableArray`1<KnownType> EventAccessorAllowedExceptions;
    private static HashSet`1<SyntaxKind> TrackedOperators;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionShouldNotBeThrownFromUnexpectedMethods();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForIssue(SonarSyntaxNodeReportingContext analysisContext, Func`2<TSyntax, bool> isTrackedSyntax, ImmutableArray`1<KnownType> allowedThrowTypes);
    private static bool IsTrackedOperator(OperatorDeclarationSyntax declaration);
    private static bool IsTrackedMethod(MethodDeclarationSyntax declaration, SemanticModel model);
    private static bool HasTrackedMethodOrAttributeName(MethodDeclarationSyntax declaration);
    private static bool HasTrackedMethodOrAttributeType(IMethodSymbol method);
    private static bool IsModuleInitializer(IMethodSymbol method);
    private static void ReportOnInvalidThrow(SonarSyntaxNodeReportingContext context, SyntaxNode node, ImmutableArray`1<KnownType> allowedTypes);
    private static bool ShouldReport(INamedTypeSymbol exceptionType, ImmutableArray`1<KnownType> allowedTypes);
    [CompilerGeneratedAttribute]
internal static bool <HasTrackedMethodOrAttributeName>g__CanBeModuleInitializer|13_0(<>c__DisplayClass13_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionsNeedStandardConstructors : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionsNeedStandardConstructors();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasStandardConstructors(INamedTypeSymbol classSymbol);
    private static bool HasConstructor(ImmutableArray`1<IMethodSymbol> constructors, Accessibility accessibility, KnownType[] expectedParameterTypes);
    private static bool IsMatchingConstructor(IMethodSymbol constructor, Accessibility accessibility, KnownType[] expectedParameterTypes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionsShouldBeLogged : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static KnownAssembly[] SupportedLoggingFrameworks;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionsShouldBeLogged();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionsShouldBeLoggedOrThrown : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string LoggingStatementMessage;
    private static string ThrownExceptionMessage;
    private static DiagnosticDescriptor Rule;
    private static KnownAssembly[] SupportedLoggingFrameworks;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionsShouldBeLoggedOrThrown();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionsShouldBePublic : ExceptionsShouldBePublicBase`1<SyntaxKind> {
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual string get_MessageFormat();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExceptionsShouldBeUsed : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionsShouldBeUsed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExcludeFromCodeCoverageAttributesNeedJustification : ExcludeFromCodeCoverageAttributesNeedJustificationBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode GetJustificationExpression(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExecutingSqlQueries : ExecutingSqlQueriesBase`3<SyntaxKind, ExpressionSyntax, IdentifierNameSyntax> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal ExecutingSqlQueries(IAnalyzerConfiguration configuration);
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual ExpressionSyntax GetArgumentAtIndex(InvocationContext context, int index);
    protected virtual ExpressionSyntax GetArgumentAtIndex(ObjectCreationContext context, int index);
    protected virtual ExpressionSyntax GetSetValue(PropertyAccessContext context);
    protected virtual bool IsTracked(ExpressionSyntax expression, SyntaxBaseContext context);
    protected virtual bool IsSensitiveExpression(ExpressionSyntax expression, SemanticModel semanticModel);
    protected virtual Location SecondaryLocationForExpression(ExpressionSyntax node, string identifierNameToFind, String& identifierNameFound);
    private static bool IsInvocationOfInterest(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsConcatenation(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool AllConstants(IEnumerable`1<ArgumentSyntax> arguments, SemanticModel semanticModel);
    private static bool IsConcatenationOfConstants(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExpandingArchives : ExpandingArchivesBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal ExpandingArchives(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExpectedExceptionAttributeShouldNotBeUsed : ExpectedExceptionAttributeShouldNotBeUsedBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode FindExpectedExceptionAttribute(SyntaxNode node);
    protected virtual bool HasMultiLineBody(SyntaxNode node);
    protected virtual bool AssertInCatchFinallyBlock(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExpressionComplexity : ExpressionComplexityBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TransparentKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <ComplexityIncreasingKinds>k__BackingField;
    protected ILanguageFacade Language { get; }
    protected SyntaxKind[] TransparentKinds { get; }
    protected SyntaxKind[] ComplexityIncreasingKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_TransparentKinds();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_ComplexityIncreasingKinds();
    protected virtual SyntaxNode[] ExpressionChildren(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExtensionMethodShouldBeInSeparateNamespace : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExtensionMethodShouldBeInSeparateNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ExtensionMethodShouldNotExtendObject : ExtensionMethodShouldNotExtendObjectBase`2<SyntaxKind, MethodDeclarationSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsExtensionMethod(MethodDeclarationSyntax declaration, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FieldShadowsParentField : FieldShadowsParentFieldBase`2<SyntaxKind, VariableDeclaratorSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FieldShouldBeReadonly : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<SyntaxKind> AssignmentKinds;
    private static ISet`1<SyntaxKind> PrefixUnaryKinds;
    private static ISet`1<SyntaxKind> PostfixUnaryKinds;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FieldShouldBeReadonly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FieldShouldBeReadonlyCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static bool HasAnyAccessibilityModifier(FieldDeclarationSyntax fieldDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FieldShouldNotBePublic : FieldShouldNotBePublicBase`3<SyntaxKind, FieldDeclarationSyntax, VariableDeclaratorSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IEnumerable`1<VariableDeclaratorSyntax> Variables(FieldDeclarationSyntax fieldDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FieldsShouldBeEncapsulatedInProperties : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> ValidModifiers;
    private static ImmutableArray`1<KnownType> IgnoredTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FieldsShouldBeEncapsulatedInProperties();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool Serializable(ISymbol symbol, ISymbol parentSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FileLines : FileLinesBase {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static FileLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual bool IsEndOfFileToken(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FileMetadataAnalyzer : FileMetadataAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FileShouldEndWithEmptyNewLine : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FileShouldEndWithEmptyNewLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FinalizerShouldNotBeEmpty : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FinalizerShouldNotBeEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FindInsteadOfFirstOrDefault : FindInsteadOfFirstOrDefaultBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FlagsEnumWithoutInitializer : FlagsEnumWithoutInitializerBase`2<SyntaxKind, EnumMemberDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsInitialized(EnumMemberDeclarationSyntax member);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FlagsEnumZeroMember : FlagsEnumZeroMemberBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForeachLoopExplicitConversion : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForeachLoopExplicitConversion();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForeachLoopExplicitConversionCodeFix : SonarCodeFix {
    private static string Title;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode CalculateNewRoot(SyntaxNode root, ForEachStatementSyntax foreachSyntax, SemanticModel semanticModel);
    private static InvocationExpressionSyntax GetOfTypeInvocation(string typeName, ExpressionSyntax collection);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForLoopConditionAlwaysFalse : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static CSharpExpressionNumericConverter ExpressionNumericConverter;
    private static ISet`1<SyntaxKind> ConditionsToCheck;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForLoopConditionAlwaysFalse();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsAlwaysFalseCondition(ExpressionSyntax condition);
    private bool IsAlwaysTrueCondition(ExpressionSyntax condition);
    private static bool IsConditionFalseAtInitialization(ForStatementSyntax forNode);
    private static bool ConditionIsTrue(SyntaxKind syntaxKind, decimal leftValue, decimal rightValue);
    private static bool IsLogicalNot(ExpressionSyntax expression, PrefixUnaryExpressionSyntax& logicalNot);
    private static bool DecimalValue(IDictionary`2<string, decimal> variableNameToDecimalValue, ExpressionSyntax expression, Decimal& parsedValue);
    private static IDictionary`2<string, decimal> VariableDeclarationMapping(VariableDeclarationSyntax variableDeclarationSyntax);
    private static IDictionary`2<string, decimal> LoopInitializerMapping(IEnumerable`1<ExpressionSyntax> initializers);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForLoopCounterChanged : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static IImmutableList`1<SideEffectExpression> SideEffectExpressions;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForLoopCounterChanged();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<ISymbol> LoopCounters(ForStatementSyntax node, SemanticModel semanticModel);
    private static SyntaxNode[] ComputeAffectedExpressions(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForLoopCounterCondition : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatNotEmpty;
    private static string MessageFormatEmpty;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForLoopCounterCondition();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<ISymbol> GetIncrementorSymbols(ForStatementSyntax forNode, SemanticModel semanticModel);
    private static IEnumerable`1<ISymbol> GetReadSymbolsCondition(ForStatementSyntax forNode, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ForLoopIncrementSign : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    private Dictionary`2<SyntaxKind, ArithmeticOperation> incrementorToOperation;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForLoopIncrementSign();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private IncrementData GetIncrementData(ExpressionSyntax incrementor);
    private Condition GetCondition(BinaryExpressionSyntax conditionSyntax, string identifierName);
    private bool IsVariableAndLiteralBinaryExpression(BinaryExpressionSyntax binaryExpression, string identifierName);
    private bool IsIdentifier(SyntaxNode node, string identifierName);
    private ExpressionSyntax GetUnnaryExpressionOperand(ExpressionSyntax syntax);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FrameworkTypeNaming : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int SelfAndBaseTypesCount;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static Dictionary`2<string, string> FrameworkTypesWithEnding;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FrameworkTypeNaming();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FunctionComplexity : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int DefaultValueMaximum;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [RuleParameterAttribute("maximumFunctionComplexityThreshold", "3", "The maximum authorized complexity.", "10")]
public int Maximum { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FunctionComplexity();
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private void CheckComplexity(SonarSyntaxNodeReportingContext context, Func`2<TSyntax, Location> getLocation, string declarationType, bool onlyGlobalStatements);
    private void CheckComplexity(SonarSyntaxNodeReportingContext context, Func`2<TSyntax, Location> getLocation, Func`2<TSyntax, SyntaxNode> getNodeToCheck, string declarationType, bool onlyGlobalStatements);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_3(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_4(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_5(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_6(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_7(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.FunctionNestingDepth : FunctionNestingDepthBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericInheritanceShouldNotBeRecursive : GenericInheritanceShouldNotBeRecursiveBase`2<SyntaxKind, TypeDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual SyntaxToken GetKeyword(TypeDeclarationSyntax declaration);
    protected virtual Location GetLocation(TypeDeclarationSyntax declaration);
    protected virtual INamedTypeSymbol GetNamedTypeSymbol(TypeDeclarationSyntax declaration, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericLoggerInjectionShouldMatchEnclosingType : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericLoggerInjectionShouldMatchEnclosingType();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GenericLoggerInjectionShouldMatchEnclosingType/<InvalidTypeParameters>d__6")]
private static IEnumerable`1<TypeSyntax> InvalidTypeParameters(ConstructorDeclarationSyntax constructor, SemanticModel model);
    private static bool IsGenericLogger(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericReadonlyFieldPropertyAssignment : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericReadonlyFieldPropertyAssignment();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ProcessPropertyChange(SonarSyntaxNodeReportingContext context, SemanticModel semanticModel, ExpressionSyntax expression);
    private static bool IsFieldReadonlyAndPossiblyValueType(IFieldSymbol fieldSymbol);
    private static bool IsInsideConstructorDeclaration(ExpressionSyntax expression, INamedTypeSymbol currentType, SemanticModel semanticModel);
    private static bool GenericParameterMightBeValueType(ITypeParameterSymbol typeParameterSymbol);
    private static bool MightBeValueType(ITypeSymbol type);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericReadonlyFieldPropertyAssignmentCodeFix : SonarCodeFix {
    internal static string TitleRemove;
    internal static string TitleAddClassConstraint;
    private static SyntaxAnnotation Annotation;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static GenericReadonlyFieldPropertyAssignmentCodeFix();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GenericReadonlyFieldPropertyAssignmentCodeFix/<RegisterCodeFixesAsync>d__5")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static MultiValueDictionary`2<DocumentId, ClassDeclarationSyntax> GetDocumentIdClassDeclarationMapping(IEnumerable`1<ClassDeclarationSyntax> classDeclarations, Solution currentSolution);
    private static SyntaxNode GetNewDocumentRoot(SyntaxNode docRoot, ITypeParameterSymbol typeParameterSymbol, KeyValuePair`2<DocumentId, ICollection`1<ClassDeclarationSyntax>> classes);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GetNewConstraintClause(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, string typeParameterName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericTypeParameterEmptinessChecking : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParameterEmptinessChecking();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericTypeParameterEmptinessCheckingCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GenericTypeParameterEmptinessCheckingCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericTypeParameterInOut : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParameterInOut();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckInterfaceVariance(SonarSyntaxNodeReportingContext context, InterfaceDeclarationSyntax declaration);
    private static void CheckDelegateVariance(SonarSyntaxNodeReportingContext context, DelegateDeclarationSyntax declaration);
    private static bool CheckTypeParameter(ITypeParameterSymbol typeParameter, VarianceKind variance, ITypeSymbol returnType, ImmutableArray`1<IParameterSymbol> parameters);
    private static bool CheckTypeParameter(ITypeParameterSymbol typeParameter, VarianceKind variance, ITypeSymbol interfaceType);
    private static void ReportIssue(SonarSyntaxNodeReportingContext context, ITypeParameterSymbol typeParameter, VarianceKind variance);
    private static bool CheckTypeParameterInMethod(ITypeParameterSymbol typeParameter, VarianceKind variance, IMethodSymbol method);
    private static bool CheckTypeParameterInEvent(ITypeParameterSymbol typeParameter, VarianceKind variance, IEventSymbol event);
    private static bool CheckTypeParameterInParameters(ITypeParameterSymbol typeParameter, VarianceKind variance, ImmutableArray`1<IParameterSymbol> parameters);
    private static bool CheckTypeParameterConstraintsInSymbol(ITypeParameterSymbol typeParameter, VarianceKind variance);
    private static bool CanTypeParameterBeVariant(ITypeParameterSymbol parameter, VarianceKind variance, ITypeSymbol type, bool requireOutputSafety, bool requireInputSafety);
    private static bool CanTypeParameterBeVariant(ITypeParameterSymbol parameter, VarianceKind variance, INamedTypeSymbol namedType, bool requireOutputSafety, bool requireInputSafety);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericTypeParametersRequired : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParametersRequired();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AddTypeParameters(ITypeSymbol argumentSymbol, ISet`1<ITypeParameterSymbol> set);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GenericTypeParameterUnused : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static SyntaxKind[] MethodModifiersToSkip;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParameterUnused();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckGenericTypeParameters(SonarSyntaxNodeReportingContext c, ISymbol symbol);
    private static ParametersInfo CreateParametersInfo(SonarSyntaxNodeReportingContext c);
    private static bool IsMethodCandidate(MethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel);
    private static List`1<string> GetUsedTypeParameters(SonarSyntaxNodeReportingContext context, IEnumerable`1<SyntaxNode> declarations, String[] typeParameterNames);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GetHashCodeEqualsOverride : SonarDiagnosticAnalyzer {
    internal static string EqualsName;
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<string> MethodNames;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GetHashCodeEqualsOverride();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    internal static bool IsEqualsCallInGuardCondition(InvocationExpressionSyntax invocation, IMethodSymbol invokedMethod);
    internal static bool MethodIsRelevant(ISymbol symbol, ISet`1<string> methodNames);
    private static bool TryGetLocationFromInvocationInsideMethod(SonarSyntaxNodeReportingContext context, ISymbol symbol, Location& location);
    private static bool IfStatementWithSingleReturnTrue(IfStatementSyntax ifStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GetHashCodeMutable : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string IssueMessage;
    private static string SecondaryMessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GetHashCodeMutable();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SecondaryLocation CreateSecondaryLocation(SimpleNameSyntax identifierSyntax);
    private static IEnumerable`1<IdentifierNameSyntax> GetAllFirstMutableFieldsUsed(SonarSyntaxNodeReportingContext context, ICollection`1<IFieldSymbol> fieldsOfClass, IEnumerable`1<IdentifierNameSyntax> identifiers);
    private static bool IsFieldRelevant(IFieldSymbol fieldSymbol, ICollection`1<IFieldSymbol> fieldsOfClass);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GetHashCodeMutableCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GetHashCodeMutableCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GetHashCodeMutableCodeFix/<GetFieldDeclarationSyntaxAsync>d__4")]
private static Task`1<FieldDeclarationSyntax> GetFieldDeclarationSyntaxAsync(SemanticModel semanticModel, IdentifierNameSyntax identifierName, CancellationToken cancel);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.GetHashCodeMutableCodeFix/<AddReadonlyToFieldDeclarationsAsync>d__5")]
private static Task`1<Document> AddReadonlyToFieldDeclarationsAsync(Document document, CancellationToken cancel, IEnumerable`1<FieldDeclarationSyntax> fieldDeclarations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GetTypeWithIsAssignableFrom : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string UseIsOperatorKey;
    internal static string ShouldRemoveGetTypeKey;
    private static string MessageFormat;
    private static string MessageIsOperator;
    private static string MessageIsInstanceOfType;
    private static string MessageNullCheck;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GetTypeWithIsAssignableFrom();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckAsOperatorComparedToNull(SonarSyntaxNodeReportingContext context, ExpressionSyntax sideA, ExpressionSyntax sideB);
    private static void CheckGetTypeAndTypeOfEquality(SonarSyntaxNodeReportingContext context, ExpressionSyntax sideA, ExpressionSyntax sideB);
    private static void CheckForIsInstanceOfType(SonarSyntaxNodeReportingContext context, MemberAccessExpressionSyntax memberAccess, IMethodSymbol methodSymbol);
    private static void CheckForIsAssignableFrom(SonarSyntaxNodeReportingContext context, MemberAccessExpressionSyntax memberAccess, IMethodSymbol methodSymbol, ExpressionSyntax argument);
    private static bool IsUnboundedGenericType(TypeOfExpressionSyntax typeOf);
    private static ExpressionSyntax ConstantPatternExpression(SyntaxNode node);
    private static void ReportDiagnostic(SonarSyntaxNodeReportingContext context, string messageArg, bool useIsOperator, bool shouldRemoveGetType);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GetTypeWithIsAssignableFromCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode NewRoot(SyntaxNode root, Diagnostic diagnostic, SyntaxNode node);
    private static SyntaxNode ChangeInvocation(SyntaxNode root, Diagnostic diagnostic, InvocationExpressionSyntax invocation);
    private static SyntaxNode ChangeBinary(SyntaxNode root, BinaryExpressionSyntax binary);
    private static SyntaxNode ChangeIsPattern(SyntaxNode root, IsPatternExpressionSyntaxWrapper isPattern);
    private static SyntaxNode ChangeIsExpressionToNullCheck(SyntaxNode root, BinaryExpressionSyntax binary);
    private static BinaryExpressionSyntax NullCheck(BinaryExpressionSyntax binary);
    private static ExpressionSyntax RefactoredExpression(BinaryExpressionSyntax binary);
    private static ExpressionSyntax RefactoredExpression(InvocationExpressionSyntax invocation, bool useIsOperator, bool shouldRemoveGetType);
    private static ExpressionSyntax NegatedExpression(bool negationRequired, SyntaxNode parent, ExpressionSyntax expression);
    private static ExpressionSyntax GetIsExpression(BinaryExpressionSyntax asExpression);
    private static BinaryExpressionSyntax AsOperatorComparisonToNull(BinaryExpressionSyntax binary);
    private static bool TryGetTypeOfComparison(BinaryExpressionSyntax binary, TypeOfExpressionSyntax& typeofExpression, ExpressionSyntax& getTypeSide);
    private static InvocationExpressionSyntax IsInstanceOfTypeCall(InvocationExpressionSyntax invocation, ExpressionSyntax typeInstance, ArgumentSyntax getTypeCallInArgument);
    private static ExpressionSyntax ExpressionWithParensIfNeeded(ExpressionSyntax expression, SyntaxNode parent);
    private static ExpressionSyntax CreateIsExpression(ExpressionSyntax typeInstance, ExpressionSyntax getTypeCall, bool shouldRemoveGetType);
    private static ExpressionSyntax ExpressionFromGetType(ExpressionSyntax getTypeCall);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GotoStatement : GotoStatementBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] GotoSyntaxKinds { get; }
    protected string GoToLabel { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind[] get_GotoSyntaxKinds();
    protected virtual string get_GoToLabel();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.GuardConditionOnEqualsOverride : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> MethodNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GuardConditionOnEqualsOverride();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckInvocationInsideMethod(SonarSyntaxNodeReportingContext context, ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.HardcodedIpAddress : HardcodedIpAddressBase`2<SyntaxKind, LiteralExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    public HardcodedIpAddress(IAnalyzerConfiguration analyzerConfiguration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool HasAttributes(SyntaxNode literalExpression);
    protected virtual string GetAssignedVariableName(SyntaxNode stringLiteral);
    private static bool IsVariableIdentifier(SyntaxNode syntaxNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.IfChainWithoutElse : IfChainWithoutElseBase`2<SyntaxKind, IfStatementSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind SyntaxKind { get; }
    protected string ElseClause { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_SyntaxKind();
    protected virtual string get_ElseClause();
    protected virtual bool IsElseIfWithoutElse(IfStatementSyntax ifSyntax);
    protected virtual Location IssueLocation(SonarSyntaxNodeReportingContext context, IfStatementSyntax ifSyntax);
    private static bool IsEmptyBlock(ElseClauseSyntax elseClause);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.IfCollapsible : IfCollapsibleBase {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IfCollapsible();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IfStatementSyntax GetParentIfStatement(IfStatementSyntax ifStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ImplementIDisposableCorrectly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ISet`1<SyntaxKind> NotAllowedDisposeModifiers;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImplementIDisposableCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ImplementISerializableCorrectly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImplementISerializableCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ImplementISerializableCorrectly/<CheckSerializableAttribute>d__7")]
private static IEnumerable`1<SecondaryLocation> CheckSerializableAttribute(SyntaxToken typeKeyword, INamedTypeSymbol typeSymbol);
    private static IEnumerable`1<TSyntax> DeclarationOrImplementation(TypeDeclarationSyntax typeDeclaration, IMethodSymbol symbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ImplementISerializableCorrectly/<CheckGetObjectData>d__9")]
private static IEnumerable`1<SecondaryLocation> CheckGetObjectData(TypeDeclarationSyntax typeDeclaration, INamedTypeSymbol typeSymbol, IMethodSymbol getObjectData);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ImplementISerializableCorrectly/<CheckGetObjectDataAccessibility>d__10")]
private static IEnumerable`1<SecondaryLocation> CheckGetObjectDataAccessibility(TypeDeclarationSyntax typeDeclaration, INamedTypeSymbol typeSymbol, IMethodSymbol getObjectData);
    private static IEnumerable`1<string> GetSerializableFieldNames(INamedTypeSymbol typeSymbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ImplementISerializableCorrectly/<CheckConstructor>d__12")]
private static IEnumerable`1<SecondaryLocation> CheckConstructor(TypeDeclarationSyntax typeDeclaration, INamedTypeSymbol typeSymbol);
    private static bool IsCallingBase(IMethodSymbol methodSymbol);
    private static bool IsCallingBaseConstructor(IMethodSymbol constructorSymbol);
    private static bool ImplementsISerializable(ITypeSymbol typeSymbol);
    private static bool OptsInForSerialization(INamedTypeSymbol typeSymbol);
    private static bool HasSerializableAttribute(ISymbol symbol);
    private static bool IsPublicVirtual(IMethodSymbol methodSymbol);
    private static bool IsExplicitImplementation(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ImplementSerializationMethodsCorrectly : ImplementSerializationMethodsCorrectlyBase {
    private static string ProblemStatic;
    private static string ProblemReturnVoidText;
    protected ILanguageFacade Language { get; }
    protected string MethodStaticMessage { get; }
    protected string MethodReturnTypeShouldBeVoidMessage { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual string get_MethodStaticMessage();
    protected virtual string get_MethodReturnTypeShouldBeVoidMessage();
    protected virtual Location GetIdentifierLocation(IMethodSymbol methodSymbol);
    protected virtual void Initialize(SonarAnalysisContext context);
    private void ReportOnAttributes(SonarSyntaxNodeReportingContext context, IEnumerable`1<AttributeSyntax> attributes, string memberType);
    private static IEnumerable`1<AttributeSyntax> GetSerializationAttributes(SyntaxList`1<AttributeListSyntax> attributeList, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.IndentSingleLineFollowingConditional : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IndentSingleLineFollowingConditional();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckWhile(SonarSyntaxNodeReportingContext context);
    private static void CheckDo(SonarSyntaxNodeReportingContext context);
    private static void CheckFor(SonarSyntaxNodeReportingContext context);
    private static void CheckForEach(SonarSyntaxNodeReportingContext context);
    private static void CheckIf(SonarSyntaxNodeReportingContext context);
    private static void CheckElse(SonarSyntaxNodeReportingContext context);
    private static bool IsStatementIndentationOk(SyntaxNode controlNode, SyntaxNode conditionallyExecutedNode);
    private static void ReportIssue(SonarSyntaxNodeReportingContext context, Location primaryLocation, SyntaxNode secondaryLocationNode, string conditionLabelText);
    private static Location GetFirstLineOfNode(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.IndexOfCheckAgainstZero : IndexOfCheckAgainstZeroBase`2<SyntaxKind, BinaryExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind LessThanExpression { get; }
    protected SyntaxKind GreaterThanExpression { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_LessThanExpression();
    protected virtual SyntaxKind get_GreaterThanExpression();
    protected virtual SyntaxNode Left(BinaryExpressionSyntax binaryExpression);
    protected virtual SyntaxToken OperatorToken(BinaryExpressionSyntax binaryExpression);
    protected virtual SyntaxNode Right(BinaryExpressionSyntax binaryExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InfiniteRecursion : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private IChecker checker;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DiagnosticDescriptor Rule { get; }
    internal InfiniteRecursion(IAnalyzerConfiguration configuration);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static DiagnosticDescriptor get_Rule();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckForNoExitMethod(SonarSyntaxNodeReportingContext c, SyntaxToken identifier);
    private static bool IsInstructionOnThisAndMatchesDeclaringSymbol(SyntaxNode node, ISymbol declaringSymbol, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_3(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_4(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_5(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_6(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InheritedCollidingInterfaceMembers : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int MaxMemberDisplayCount;
    private static int MinBaseListTypes;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<SymbolDisplayPartKind> PartKindsToStartWith;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InheritedCollidingInterfaceMembers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.InheritedCollidingInterfaceMembers/<GetCollidingMembers>d__9")]
private static IEnumerable`1<IMethodSymbol> GetCollidingMembers(ITypeSymbol interfaceSymbol);
    private static bool IsNotEventRemoveAccessor(IMethodSymbol methodSymbol);
    private static string GetIssueMessageText(IEnumerable`1<IMethodSymbol> collidingMembers, SemanticModel semanticModel, int spanStart);
    private static string GetMemberDisplayName(IMethodSymbol method, int spanStart, SemanticModel semanticModel);
    private static bool AreCollidingMethods(IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IMethodSymbol> <GetCollidingMembers>g__GetCollidingMembersForMember|9_2(IMethodSymbol member, IEnumerable`1<INamedTypeSymbol> interfaces);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IMethodSymbol> <GetCollidingMembers>g__GetCollidingMembersForMemberAndInterface|9_3(IMethodSymbol member, INamedTypeSymbol interfaceToCheck);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InitializeStaticFieldsInline : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InitializeStaticFieldsInline();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InsecureDeserialization : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public InsecureDeserialization(IAnalyzerConfiguration analyzerConfiguration);
    private static InsecureDeserialization();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnInsecureDeserializations(SonarSyntaxNodeReportingContext context, TypeDeclarationSyntax declaration, ITypeSymbol typeSymbol);
    private static bool OnDeserializationHasConditions(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel);
    private static bool IsOnDeserialization(MethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel);
    private static bool HasConstructorsWithParameters(TypeDeclarationSyntax typeDeclaration);
    private static bool HasSerializableAttribute(ISymbol symbol);
    private static bool ImplementsISerializable(ITypeSymbol symbol);
    private static bool ImplementsIDeserializationCallback(ITypeSymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
internal static void <ReportOnInsecureDeserializations>g__ReportIssue|8_0(SonarSyntaxNodeReportingContext context, ConstructorInfo constructor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InsecureEncryptionAlgorithm : InsecureEncryptionAlgorithmBase`4<SyntaxKind, InvocationExpressionSyntax, ArgumentListSyntax, ArgumentSyntax> {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual ArgumentListSyntax ArgumentList(InvocationExpressionSyntax invocationExpression);
    protected virtual SeparatedSyntaxList`1<ArgumentSyntax> Arguments(ArgumentListSyntax argumentList);
    protected virtual bool IsStringLiteralArgument(ArgumentSyntax argument);
    protected virtual SyntaxNode Expression(ArgumentSyntax argument);
    protected virtual Location Location(SyntaxNode objectCreation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InsecureTemporaryFilesCreation : InsecureTemporaryFilesCreationBase`2<MemberAccessExpressionSyntax, SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InsteadOfAny : InsteadOfAnyBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsSimpleEqualityCheck(InvocationExpressionSyntax node, SemanticModel model);
    private bool HasValidBinaryOperands(string lambdaVariableName, SyntaxNode first, SyntaxNode second, SemanticModel model);
    private static bool IsNullOrValueTypeOrString(SyntaxNode node, SemanticModel model);
    protected virtual bool AreValidOperands(string lambdaVariable, SyntaxNode first, SyntaxNode second);
    protected virtual SyntaxNode GetArgumentExpression(InvocationExpressionSyntax invocation, int index);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InterfaceMethodsShouldBeCallableByChildTypes : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InterfaceMethodsShouldBeCallableByChildTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnIssue(SonarSyntaxNodeReportingContext analysisContext, Func`2<TMemberSyntax, ExplicitInterfaceSpecifierSyntax> getExplicitInterfaceSpecifier, Func`2<TMemberSyntax, SyntaxToken> getIdentifierName, Func`3<TMemberSyntax, TMemberSyntax, bool> areMembersEquivalent);
    private static bool IsDeclarationTracked(BaseTypeDeclarationSyntax declaration, SemanticModel semanticModel);
    private static bool AreMethodsEquivalent(MethodDeclarationSyntax currentMethod, MethodDeclarationSyntax targetedMethod);
    private static bool ArePropertiesEquivalent(PropertyDeclarationSyntax currentProperty, PropertyDeclarationSyntax targetedProperty);
    private static bool AreEventsEquivalent(EventDeclarationSyntax currentEvent, EventDeclarationSyntax targetedEvent);
    private static bool IsPublicOrProtected(SyntaxToken modifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InterfacesShouldNotBeEmpty : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InterfacesShouldNotBeEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsAggregatingOtherInterfaces(ITypeSymbol interfaceSymbol);
    private static bool IsSpecializedGeneric(INamedTypeSymbol interfaceSymbol);
    private static bool IsConstraintGeneric(INamedTypeSymbol interfaceSymbol);
    private static bool IsBoundGeneric(INamedTypeSymbol interfaceSymbol);
    private static bool HasEnhancingAttribute(INamedTypeSymbol interfaceSymbol);
    private static bool IsImplementingInterface(INamedTypeSymbol interfaceSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InvalidCastToInterface : InvalidCastToInterfaceBase`1<SyntaxKind> {
    public static DiagnosticDescriptor S1944;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static InvalidCastToInterface();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual DiagnosticDescriptor get_Rule();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.InvocationResolvesToOverrideWithParams : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InvocationResolvesToOverrideWithParams();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckCall(SonarSyntaxNodeReportingContext context, SyntaxNode node, ArgumentListSyntax argumentList);
    private static ITypeSymbol[] ArgumentTypes(SonarSyntaxNodeReportingContext context, ArgumentListSyntax argumentList);
    private static IEnumerable`1<IMethodSymbol> OtherOverloadsOf(IMethodSymbol method);
    private static bool IsInvocationWithExplicitArray(ArgumentListSyntax argumentList, IMethodSymbol invokedMethodSymbol, SemanticModel semanticModel);
    private static bool ArgumentsMatchParameters(ArgumentListSyntax argumentList, ITypeSymbol[] argumentTypes, IMethodSymbol possibleOtherMethod, SemanticModel semanticModel);
    private static bool MethodAccessibleWithinType(IMethodSymbol method, ITypeSymbol type);
    private static bool IsInTypeOrNested(IMethodSymbol method, ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.IssueSuppression : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IssueSuppression();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckTrivias(SonarSyntaxTreeReportingContext c, SyntaxTriviaList triviaList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.JSInvokableMethodsShouldBePublic : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static JSInvokableMethodsShouldBePublic();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckMethod(SonarSyntaxNodeReportingContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.JwtSigned : JwtSignedBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual BuilderPatternCondition`2<SyntaxKind, InvocationExpressionSyntax> CreateBuilderPatternCondition();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LdapConnectionShouldBeSecure : ObjectShouldBeInitializedCorrectlyBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int AuthenticationTypesNone;
    private static int AuthenticationTypesAnonymous;
    [CompilerGeneratedAttribute]
private CSharpObjectInitializationTracker <ObjectInitializationTracker>k__BackingField;
    protected CSharpObjectInitializationTracker ObjectInitializationTracker { get; }
    [CompilerGeneratedAttribute]
protected virtual CSharpObjectInitializationTracker get_ObjectInitializationTracker();
    private static bool IsAllowedObject(ISymbol authTypeSymbol, SyntaxNode authTypeExpression, SemanticModel semanticModel);
    private static bool IsUnsafe(int authType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LineLength : LineLengthBase {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static LineLength();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LinkedListPropertiesInsteadOfMethods : LinkedListPropertiesInsteadOfMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsRelevantCallAndType(InvocationExpressionSyntax invocation, SemanticModel model);
    private static bool IsCorrectType(SyntaxNode left, SemanticModel model);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LinkedListPropertiesInsteadOfMethodsCodeFix : SonarCodeFix {
    private static string Title;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LiteralsShouldNotBePassedAsLocalizedParameters : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> LocalizableSymbolNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LiteralsShouldNotBePassedAsLocalizedParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeInvocations(SonarSyntaxNodeReportingContext context);
    private static void AnalyzeAssignments(SonarSyntaxNodeReportingContext context);
    private static bool IsStringLiteral(SyntaxNode expression, SemanticModel semanticModel);
    private static bool IsLocalizable(ISymbol symbol);
    private static bool IsLocalizable(string symbolName, IReadOnlyCollection`1<AttributeData> localizableAttributes);
    private static bool IsLocalizableStringLiteral(ISymbol symbol, ArgumentSyntax argumentSyntax, SemanticModel semanticModel);
    private static bool HasConstructorWitValue(AttributeData attribute, bool expectedValue);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LiteralSuffixUpperCase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LiteralSuffixUpperCase();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ShouldIgnore(string text);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LiteralSuffixUpperCaseCodeFix : SonarCodeFix {
    private static string Title;
    private static string LowercaseEllSuffix;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LockedFieldShouldBeReadonly : SonarDiagnosticAnalyzer {
    private static string LockedFieldDiagnosticId;
    private static string LocalVariableDiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor LockedFieldRule;
    private static DiagnosticDescriptor LocalVariableRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LockedFieldShouldBeReadonly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckLockStatement(SonarSyntaxNodeReportingContext context);
    private static bool IsCreation(ExpressionSyntax expression);
    private static bool IsOfTypeString(ExpressionSyntax expression, Lazy`1<ISymbol> lazySymbol);
    private static IFieldSymbol FieldWritable(ExpressionSyntax expression, Lazy`1<ISymbol> lazySymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LogAnalyzer : LogAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string LanguageVersion(Compilation compilation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LoggerFieldsShouldBePrivateStaticReadonly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static KnownAssembly[] LoggingFrameworks;
    private static ImmutableArray`1<KnownType> Loggers;
    private static HashSet`1<SyntaxKind> InvalidAccessModifiers;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LoggerFieldsShouldBePrivateStaticReadonly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.LoggerFieldsShouldBePrivateStaticReadonly/<InvalidFields>d__9")]
private static IEnumerable`1<SyntaxToken> InvalidFields(BaseFieldDeclarationSyntax field, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LoggerMembersNamesShouldComply : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string DefaultFormat;
    private static ImmutableHashSet`1<string> DefaultAllowedNames;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <NameRegex>k__BackingField;
    private static ImmutableArray`1<KnownType> Loggers;
    private static KnownAssembly[] Assemblies;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("format", "5", "Regular expression used to check the field or property names against", "^_?[Ll]og(ger)?$")]
public string Format { get; public set; }
    private bool UsesDefaultFormat { get; }
    private Regex NameRegex { get; private set; }
    private static LoggerMembersNamesShouldComply();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    private bool get_UsesDefaultFormat();
    [CompilerGeneratedAttribute]
private Regex get_NameRegex();
    [CompilerGeneratedAttribute]
private void set_NameRegex(Regex value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private bool MatchesFormat(string name);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.LoggerMembersNamesShouldComply/<Declarations>d__21")]
private static IEnumerable`1<MemberData> Declarations(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__19_0(SonarCompilationStartAnalysisContext cc);
    [CompilerGeneratedAttribute]
private void <Initialize>b__19_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LoggersShouldBeNamedForEnclosingType : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static KnownAssembly[] SupportedFrameworks;
    private static ImmutableArray`1<KnownType> Loggers;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LoggersShouldBeNamedForEnclosingType();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void Process(SonarSyntaxNodeReportingContext context);
    private static SyntaxNode EnclosingTypeNode(InvocationExpressionSyntax invocation);
    private static SyntaxNode ExtractArgument(InvocationExpressionSyntax invocation);
    private static bool IsValidMethod(IMethodSymbol method);
    private static bool MatchesEnclosingType(SyntaxNode argument, SyntaxNode enclosingNode, SemanticModel model);
    private static ITypeSymbol EnclosingTypeSymbol(SemanticModel model, SyntaxNode enclosingNode);
    private static SyntaxNode ExtractGeneric(InvocationExpressionSyntax invocation);
    private static SyntaxNode ExtractTypeOfName(MemberAccessExpressionSyntax memberAccess);
    private static SyntaxNode ExtractNameOf(InvocationExpressionSyntax invocation);
    [CompilerGeneratedAttribute]
internal static bool <IsValidMethod>g__Matches|11_0(KnownType containingType, bool checkDerived, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsValidMethod>g__MatchesGeneric|11_1(<>c__DisplayClass11_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LoggingArgumentsShouldBePassedCorrectly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> MicrosoftLoggingExtensionsInvalidTypes;
    private static ImmutableArray`1<KnownType> CastleCoreInvalidTypes;
    private static ImmutableArray`1<KnownType> NLogAndSerilogInvalidTypes;
    private static HashSet`1<string> LoggingMethodNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LoggingArgumentsShouldBePassedCorrectly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckInvalidParams(InvocationExpressionSyntax invocation, IMethodSymbol invocationSymbol, SonarSyntaxNodeReportingContext c, ImmutableArray`1<KnownType> knownTypes);
    private static void CheckInvalidTypeParams(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol, SonarSyntaxNodeReportingContext c, ImmutableArray`1<KnownType> knownTypes);
    private static bool IsNLogIgnoredOverload(IMethodSymbol methodSymbol);
    private static bool MatchesParams(IMethodSymbol methodSymbol, KnownType[] knownTypes);
    private static IEnumerable`1<ArgumentSyntax> InvalidArguments(InvocationExpressionSyntax invocation, SemanticModel model, IEnumerable`1<int> positionsToCheck, ImmutableArray`1<KnownType> knownTypes);
    private static bool IsInvalidArgument(ArgumentSyntax argumentSyntax, SemanticModel model, ImmutableArray`1<KnownType> knownTypes);
    private static ImmutableArray`1<KnownType> Filter(IMethodSymbol methodSymbol, ImmutableArray`1<KnownType> knownTypes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LoopsAndLinq : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string WhereMessageFormat;
    private static string SelectMessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LoopsAndLinq();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool CanBeSimplifiedUsingWhere(SyntaxNode statement, SecondaryLocation& ifConditionLocation);
    private static IfStatementSyntax GetIfStatement(SyntaxNode node);
    private static bool CanIfStatementBeMoved(IfStatementSyntax ifStatementSyntax);
    private static void CheckIfCanBeSimplifiedUsingSelect(SonarSyntaxNodeReportingContext c, ForEachStatementSyntax forEachStatementSyntax);
    [CompilerGeneratedAttribute]
internal static bool <CanIfStatementBeMoved>g__ConditionValidIsPattern|10_0(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanIfStatementBeMoved>g__ConditionValidInvocation|10_1(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IdentifierNameSyntax> <CheckIfCanBeSimplifiedUsingSelect>g__GetStatementIdentifiers|11_2(ForEachStatementSyntax forEachStatementSyntax);
    [CompilerGeneratedAttribute]
internal static bool <CheckIfCanBeSimplifiedUsingSelect>g__IsNotLeftSideOfAssignment|11_3(MemberAccessExpressionSyntax memberAccess);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LooseFilePermissions : LooseFilePermissionsBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal LooseFilePermissions(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void VisitAssignments(SonarSyntaxNodeReportingContext context);
    protected virtual void VisitInvocations(SonarSyntaxNodeReportingContext context);
    private static bool IsSetAccessRule(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsAddAccessRule(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static IObjectCreation GetObjectCreation(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsFileSystemAccessRuleForEveryoneWithAllow(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static bool IsEveryone(SyntaxNode syntaxNode, SemanticModel semanticModel);
    private static bool IsNTAccountWithEveryone(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static bool IsSecurityIdentifierWithEveryone(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static IEnumerable`1<IObjectCreation> FilterObjectCreations(IEnumerable`1<SyntaxNode> nodes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.LossOfFractionInDivision : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LossOfFractionInDivision();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool DivisionIsInReturnAndTypeIsNonIntegral(SyntaxNode division, SemanticModel semanticModel, ITypeSymbol& divisionResultType);
    private static bool DivisionIsArgumentAndTypeIsNonIntegral(SyntaxNode division, SemanticModel semanticModel, ITypeSymbol& divisionResultType);
    private static bool DivisionIsInAssignmentAndTypeIsNonIntegral(SyntaxNode division, SemanticModel semanticModel, ITypeSymbol& divisionResultType);
    private static bool DivisionIsInTupleTypeIsNonIntegral(SyntaxNode division, SemanticModel semanticModel, ITypeSymbol& divisionResultType);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <DivisionIsInTupleTypeIsNonIntegral>g__GetMostOuterTuple|10_0(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static int <DivisionIsInTupleTypeIsNonIntegral>g__DivisionArgumentIndex|10_1(ImmutableArray`1<ArgumentSyntax> arguments, SyntaxNode division);
    [CompilerGeneratedAttribute]
internal static List`1<ITypeSymbol> <DivisionIsInTupleTypeIsNonIntegral>g__AllTupleElements|10_2(ITypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static void <DivisionIsInTupleTypeIsNonIntegral>g__CollectTupleTypes|10_7(List`1<ITypeSymbol> symbolList, ITypeSymbol tupleTypeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MagicNumberShouldNotBeUsed : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> NotConsideredAsMagicNumbers;
    private static String[] AcceptedCollectionMembersForSingleDigitComparison;
    private static SyntaxKind[] AllowedSingleDigitComparisons;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MagicNumberShouldNotBeUsed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsExceptionToTheRule(LiteralExpressionSyntax literalExpression);
    private static bool IsInsideProperty(SyntaxNode node);
    private static bool IsSingleDigitInToleratedComparisons(LiteralExpressionSyntax literalExpression);
    private static bool IsToleratedArgument(LiteralExpressionSyntax literalExpression);
    private static bool IsToleratedMethodArgument(LiteralExpressionSyntax literalExpression);
    private static bool LooksLikeTimeApi(SyntaxNode node);
    private static bool IsSingleOrNamedAttributeArgument(LiteralExpressionSyntax literalExpression);
    private static bool IsSingleDigit(string text);
    private static bool IsComparingCollectionSize(BinaryExpressionSyntax binaryComparisonToLiteral);
    [CompilerGeneratedAttribute]
internal static string <IsComparingCollectionSize>g__GetMemberName|18_0(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MarkAssemblyWithAssemblyVersionAttribute : MarkAssemblyWithAssemblyVersionAttributeBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MarkAssemblyWithClsCompliantAttribute : MarkAssemblyWithClsCompliantAttributeBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MarkAssemblyWithComVisibleAttribute : MarkAssemblyWithComVisibleAttributeBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MarkAssemblyWithNeutralResourcesLanguageAttribute : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string StronglyTypedResourceBuilder;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkAssemblyWithNeutralResourcesLanguageAttribute();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsDesignerFile(SyntaxTree tree);
    private static bool HasGeneratedCodeAttributeWithStronglyTypedResourceBuilderValue(SemanticModel semanticModel, ClassDeclarationSyntax classSyntax);
    private static bool IsResxGeneratedFile(SemanticModel semanticModel, ClassDeclarationSyntax classSyntax);
    private static bool HasNeutralResourcesLanguageAttribute(IAssemblySymbol assemblySymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MarkWindowsFormsMainWithStaThread : MarkWindowsFormsMainWithStaThreadBase`2<SyntaxKind, MethodDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual Location GetLocation(MethodDeclarationSyntax method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberInitializedToDefault : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string Zero;
    private static CSharpExpressionNumericConverter ExpressionNumericConverter;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MemberInitializedToDefault();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckAutoProperty(SonarSyntaxNodeReportingContext context);
    private static void CheckEvent(SonarSyntaxNodeReportingContext context);
    private static void CheckField(SonarSyntaxNodeReportingContext context);
    internal static bool IsDefaultValueInitializer(EqualsValueClauseSyntax initializer, ITypeSymbol type);
    private static bool IsDefaultExpressionInitializer(EqualsValueClauseSyntax initializer);
    private static bool IsReferenceTypeNullInitializer(EqualsValueClauseSyntax initializer, ITypeSymbol type);
    private static bool IsValueTypeDefaultValueInitializer(EqualsValueClauseSyntax initializer, ITypeSymbol type);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberInitializedToDefaultCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberInitializerRedundant : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string InstanceMemberMessage;
    private static string StaticMemberMessage;
    private bool useSonarCfg;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal MemberInitializerRedundant(IAnalyzerConfiguration configuration);
    private static MemberInitializerRedundant();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckInstanceMembers(SonarSyntaxNodeReportingContext c, TypeDeclarationSyntax declaration, IEnumerable`1<ISymbol> typeMembers);
    private void CheckStaticMembers(SonarSyntaxNodeReportingContext c, TypeDeclarationSyntax declaration, IEnumerable`1<ISymbol> typeMembers);
    private bool IsSymbolFirstSetInCfg(ISymbol classMember, BaseMethodDeclarationSyntax constructorOrInitializer, SemanticModel semanticModel, CancellationToken cancel);
    private static bool IsNotStaticOrConst(SyntaxTokenList tokenList);
    private static bool IsStatic(SyntaxTokenList tokenList);
    private static Dictionary`2<ISymbol, EqualsValueClauseSyntax> GetInitializedMembers(SemanticModel semanticModel, TypeDeclarationSyntax declaration, Func`2<SyntaxTokenList, bool> filterModifiers);
    private static List`1<NodeSymbolAndModel`2<TSyntax, IMethodSymbol>> GetConstructorDeclarations(SonarSyntaxNodeReportingContext context, List`1<IMethodSymbol> constructorSymbols);
    private static IEnumerable`1<DeclarationTuple`1<IPropertySymbol>> GetInitializedPropertyDeclarations(TypeDeclarationSyntax declaration, Func`2<SyntaxTokenList, bool> filterModifiers, SemanticModel semanticModel);
    private static IEnumerable`1<DeclarationTuple`1<TSymbol>> GetInitializedFieldLikeDeclarations(TypeDeclarationSyntax declaration, Func`2<SyntaxTokenList, bool> filterModifiers, SemanticModel semanticModel, Func`2<TSymbol, ITypeSymbol> typeSelector);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberOverrideCallsBaseMember : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static String[] IgnoredMethodNames;
    private static String[] IgnoredRecordMethodNames;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MemberOverrideCallsBaseMember();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsPropertyCandidate(PropertyDeclarationSyntax propertySyntax, SemanticModel semanticModel);
    private static bool CheckGetAccessorIfAny(PropertyDeclarationSyntax propertySyntax, IPropertySymbol propertySymbol, SemanticModel semanticModel);
    private static bool IsBaseProperty(IPropertySymbol propertySymbol, SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess);
    private static bool CheckSetAccessorIfAny(PropertyDeclarationSyntax propertySyntax, IPropertySymbol propertySymbol, SemanticModel semanticModel);
    private static bool IsMethodCandidate(MethodDeclarationSyntax methodSyntax, SemanticModel semanticModel);
    private static bool IsMethodSymbolExcluded(IMethodSymbol methodSymbol);
    private static bool IsRecordCompilerGenerated(IMethodSymbol methodSymbol);
    private static bool HasDocumentationComment(SyntaxNode node);
    private static bool AreArgumentsMatchParameters(IMethodSymbol methodSymbol, SemanticModel semanticModel, InvocationExpressionSyntax expressionToCheck, IMethodSymbol invokedMethod);
    private static ExpressionSyntax GetSingleStatementExpression(BlockSyntax block, bool isVoid);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberOverrideCallsBaseMemberCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberShadowsOuterStaticMember : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MemberShadowsOuterStaticMember();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckNamedType(SonarSymbolReportingContext context, IReadOnlyList`1<ISymbol> outerMembersOfSameName, INamedTypeSymbol namedType);
    private static void CheckMember(SonarSymbolReportingContext context, IReadOnlyList`1<ISymbol> outerMembersOfSameName, ISymbol member);
    private static IReadOnlyList`1<INamedTypeSymbol> SelfAndOuterNamedTypes(INamedTypeSymbol symbol);
    private static bool IsValidType(INamedTypeSymbol symbol);
    private static bool IsStaticAndVirtualOrAbstract(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberShouldBeStatic : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableHashSet`1<string> MethodNameWhitelist;
    private static ImmutableHashSet`1<SymbolKind> InstanceSymbolKinds;
    private static ImmutableArray`1<KnownType> WebControllerTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MemberShouldBeStatic();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<SyntaxNode> GetPropertyDescendants(PropertyDeclarationSyntax propertyDeclaration);
    private static IEnumerable`1<SyntaxNode> GetMethodDescendants(MethodDeclarationSyntax methodDeclaration);
    private static void CheckIssue(SonarSyntaxNodeReportingContext context, Func`2<TDeclarationSyntax, IEnumerable`1<SyntaxNode>> getDescendants, Func`2<TDeclarationSyntax, SyntaxToken> getIdentifier, string memberKind);
    private static bool IsIgnoredAttribute(AttributeData attribute);
    private static bool IsEmptyMethod(MemberDeclarationSyntax node);
    private static bool IsNewMethod(ISymbol symbol);
    private static bool IsNewProperty(ISymbol symbol);
    private static bool IsAutoProperty(ISymbol symbol);
    private static bool IsPublicControllerMethod(ISymbol symbol);
    private static bool IsWindowsFormsEventHandler(ISymbol symbol);
    private static bool HasInstanceReferences(IEnumerable`1<SyntaxNode> nodes, SemanticModel model);
    private static bool IsLeftmostIdentifierName(ExpressionSyntax node);
    private static bool IsInstanceMember(ExpressionSyntax node, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static bool <CheckIssue>g__IsStaticVirtualAbstractOrOverride|12_0(<>c__DisplayClass12_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <CheckIssue>g__IsOverrideInterfaceOrNew|12_1(<>c__DisplayClass12_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <CheckIssue>g__IsExcludedByEnclosingType|12_2(<>c__DisplayClass12_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <IsInstanceMember>g__IsConstructorParameter|22_0(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MemberShouldNotHaveConflictingTransparencyAttributes : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected bool EnableConcurrentExecution { get; }
    private static MemberShouldNotHaveConflictingTransparencyAttributes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool get_EnableConcurrentExecution();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CollectSecurityAttributes(SonarSyntaxNodeReportingContext syntaxNodeAnalysisContext, Dictionary`2<SyntaxNode, AttributeSyntax> nodesWithSecuritySafeCritical, Dictionary`2<SyntaxNode, AttributeSyntax> nodesWithSecurityCritical);
    private static void ReportOnConflictingTransparencyAttributes(SonarCompilationReportingContext compilationContext, Dictionary`2<SyntaxNode, AttributeSyntax> nodesWithSecuritySafeCritical, Dictionary`2<SyntaxNode, AttributeSyntax> nodesWithSecurityCritical);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MessageTemplateAnalyzer : SonarDiagnosticAnalyzer {
    private static ImmutableHashSet`1<SyntaxKind> ValidTemplateKinds;
    private static ImmutableHashSet`1<IMessageTemplateCheck> Checks;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MessageTemplateAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasValidExpression(ArgumentSyntax argument);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MessageTemplatesShouldBeCorrect : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MessageTemplatesShouldBeCorrect();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverloadOptionalParameter : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodOverloadOptionalParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportIssue(SonarSymbolReportingContext c, ParameterHidingMethodInfo hidingInfo);
    private static List`1<ParameterHidingMethodInfo> GetParameterHidingInfo(IMethodSymbol methodSymbol);
    private static bool MethodsUsingSameParameterNames(ParameterHidingMethodInfo hidingInfo);
    private static bool IsMoreParameterAvailableInConflicting(ParameterHidingMethodInfo hidingInfo);
    private static bool IsMethodHidingOriginal(IMethodSymbol candidateHidingMethod, IMethodSymbol method);
    private static bool AreTypesEqual(ITypeSymbol t1, ITypeSymbol t2);
    private static bool AreGenericInstancesTypesEqual(ITypeSymbol t1, ITypeSymbol t2);
    private static bool ShouldSkip(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverloadsShouldBeGrouped : MethodOverloadsShouldBeGroupedBase`2<SyntaxKind, MemberDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual MemberInfo<SyntaxKind, MemberDeclarationSyntax> CreateMemberInfo(SonarSyntaxNodeReportingContext c, MemberDeclarationSyntax member);
    protected virtual IEnumerable`1<MemberDeclarationSyntax> GetMemberDeclarations(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideAddsParams : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodOverrideAddsParams();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsNotSemanticallyParams(ParameterSyntax parameter, SemanticModel semanticModel);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideAddsParamsCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideChangedDefaultValue : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static string MessageAdd;
    internal static string MessageRemove;
    internal static string MessageUseSame;
    internal static string MessageRemoveExplicit;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodOverrideChangedDefaultValue();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportParameterIfNeeded(SonarSyntaxNodeReportingContext context, IParameterSymbol overridingParameter, IParameterSymbol overriddenParameter, ParameterSyntax parameterSyntax, bool isExplicitImplementation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideChangedDefaultValueCodeFix : SonarCodeFix {
    internal static string TitleGeneral;
    internal static string TitleExplicitInterface;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.MethodOverrideChangedDefaultValueCodeFix/<RegisterCodeFixesAsync>d__4")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void RegisterCodeFix(SonarCodeFixContext context, SyntaxNode root, ParameterSyntax parameter, ParameterSyntax newParameter, string codeFixTitle);
    private static bool TryGetNewParameterSyntax(ParameterSyntax parameter, IParameterSymbol overriddenParameter, ParameterSyntax& newParameterSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideNoParams : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodOverrideNoParams();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodOverrideNoParamsCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodParameterMissingOptional : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodParameterMissingOptional();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodParameterMissingOptionalCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.MethodParameterMissingOptionalCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static AttributeListSyntax GetNewAttributeList(AttributeListSyntax attributeList, ISymbol optionalAttribute, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodParameterUnused : MethodParameterUnusedBase {
    internal static string IsRemovableKey;
    private static string MessageUnused;
    private static string MessageDead;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private bool useSonarCfg;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal MethodParameterUnused(IAnalyzerConfiguration configuration);
    private static MethodParameterUnused();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static MethodContext CreateContext(SonarSyntaxNodeReportingContext c);
    private static bool OnlyThrowsNotImplementedException(MethodContext declaration);
    private void ReportUnusedParametersOnMethod(MethodContext declaration);
    private void ReportOnDeadParametersAtEntry(MethodContext declaration, IImmutableList`1<IParameterSymbol> noReportOnParameters);
    private LvaResult ComputeLva(MethodContext declaration);
    private static void ReportOnUnusedParameters(MethodContext declaration, IEnumerable`1<ISymbol> parametersToReportOn, string messagePattern, bool isRemovable);
    private static bool MethodCanBeSafelyChanged(IMethodSymbol methodSymbol);
    private static IImmutableList`1<IParameterSymbol> GetUnusedParameters(MethodContext declaration);
    private static ISet`1<IParameterSymbol> GetUsedParameters(ImmutableArray`1<IParameterSymbol> parameters, SyntaxNode body, SemanticModel semanticModel);
    private static bool IsUsedAsEventHandlerFunctionOrAction(MethodContext declaration);
    private static bool IsMethodUsedAsEventHandlerFunctionOrActionWithinNode(IMethodSymbol methodSymbol, SyntaxNode typeDeclaration, SemanticModel semanticModel);
    private static bool IsMethodUsedAsEventHandlerFunctionOrActionInExpression(IMethodSymbol methodSymbol, ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsStandaloneExpression(ExpressionSyntax expression);
    private static bool IsCandidateSerializableConstructor(IImmutableList`1<IParameterSymbol> unusedParameters, IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(SonarSyntaxNodeReportingContext c);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodParameterUnusedCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodShouldBeNamedAccordingToSynchronicity : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string AddAsyncSuffixMessage;
    private static string RemoveAsyncSuffixMessage;
    private static ImmutableArray`1<KnownType> AsyncReturnTypes;
    private static ImmutableArray`1<KnownType> AsyncReturnInterfaces;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodShouldBeNamedAccordingToSynchronicity();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAsyncReturnType(IMethodSymbol methodSymbol);
    private static bool IsAsyncType(ITypeSymbol typeSymbol);
    private static bool HasAsyncSuffix(MethodDeclarationSyntax methodDeclaration);
    private static bool IsSignalRHubMethod(ISymbol methodSymbol);
    private static bool IsSignalRHubMethod(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodShouldNotOnlyReturnConstant : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodShouldNotOnlyReturnConstant();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsVirtual(BaseMethodDeclarationSyntax methodDeclaration);
    private static ExpressionSyntax GetSingleExpressionOrDefault(MethodDeclarationSyntax methodDeclaration);
    private static bool IsConstantExpression(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodsShouldNotHaveIdenticalImplementations : MethodsShouldNotHaveIdenticalImplementationsBase`2<SyntaxKind, IMethodDeclaration> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual IEnumerable`1<IMethodDeclaration> GetMethodDeclarations(SyntaxNode node);
    protected virtual bool AreDuplicates(SemanticModel model, IMethodDeclaration firstMethod, IMethodDeclaration secondMethod);
    protected virtual SyntaxToken GetMethodIdentifier(IMethodDeclaration method);
    protected virtual bool IsExcludedFromBeingExamined(SonarSyntaxNodeReportingContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodsShouldNotHaveTooManyLines : MethodsShouldNotHaveTooManyLinesBase`2<SyntaxKind, BaseMethodDeclarationSyntax> {
    private static string LocalFunctionMessageFormat;
    private static DiagnosticDescriptor DefaultRule;
    private static DiagnosticDescriptor LocalFunctionRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected string MethodKeyword { get; }
    private static MethodsShouldNotHaveTooManyLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual string get_MethodKeyword();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected virtual IEnumerable`1<SyntaxToken> GetMethodTokens(BaseMethodDeclarationSyntax baseMethodDeclaration);
    protected virtual Nullable`1<SyntaxToken> GetMethodIdentifierToken(BaseMethodDeclarationSyntax baseMethodDeclaration);
    protected virtual string GetMethodKindAndName(SyntaxToken identifierToken);
    private static IEnumerable`1<SyntaxToken> GetMethodTokens(LocalFunctionStatementSyntaxWrapper wrapper);
    private static long CountLines(LocalFunctionStatementSyntaxWrapper wrapper);
    private static bool IsStaticLocalFunction(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MethodsShouldUseBaseTypes : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MethodsShouldUseBaseTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static List`1<Diagnostic> FindViolations(BaseMethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel);
    private static bool IsNestedGeneric(ISymbol symbol);
    private static bool IsTrackedParameter(IParameterSymbol parameterSymbol);
    private static SyntaxNode GetFirstNonParenthesizedParent(SyntaxNode node);
    private static ITypeSymbol FindParameterUseAsType(SyntaxNode identifier, SemanticModel semanticModel);
    private static ITypeSymbol HandleConditionalAccess(ConditionalAccessExpressionSyntax conditionalAccess, SyntaxNode identifier, SemanticModel semanticModel, IAssemblySymbol callSite);
    private static ITypeSymbol HandlePropertyOrField(SyntaxNode identifier, ISymbol symbol, IAssemblySymbol callSite);
    private static ITypeSymbol HandleInvocation(SyntaxNode invokedOn, ISymbol invocationSymbol, SemanticModel semanticModel, IAssemblySymbol callSite);
    private static INamedTypeSymbol FindOriginatingSymbol(ISymbol accessedMember, ISymbol usageSite);
    [CompilerGeneratedAttribute]
internal static bool <FindOriginatingSymbol>g__IsNotInternalOrSameAssembly|15_0(ISymbol namedTypeSymbol, <>c__DisplayClass15_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MetricsAnalyzer : MetricsAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual MetricsBase GetMetrics(SyntaxTree syntaxTree, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MultilineBlocksWithoutBrace : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MultilineBlocksWithoutBrace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckLoop(SonarSyntaxNodeReportingContext context, StatementSyntax statement);
    private static void CheckIf(SonarSyntaxNodeReportingContext context, IfStatementSyntax ifStatement);
    private static StatementSyntax LastStatementInIfChain(IfStatementSyntax ifStatement);
    private static void CheckStatement(SonarSyntaxNodeReportingContext context, StatementSyntax first, string executed, string execute);
    private static bool IsNotEmpty(SyntaxNode node);
    private static bool MisleadingtIndenting(SyntaxNode first, SyntaxNode second);
    private static LinePosition StartPosition(SyntaxNode node);
    private static SyntaxNode SecondStatement(SyntaxNode root, SyntaxNode first);
    private static bool IsNestedStatement(StatementSyntax statement);
    private static bool IsStatementCandidateLoop(StatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MultipleVariableDeclaration : MultipleVariableDeclarationBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MultipleVariableDeclarationCodeFix : MultipleVariableDeclarationCodeFixBase {
    protected virtual SyntaxNode CalculateNewRoot(SyntaxNode root, SyntaxNode node);
    private static IEnumerable`1<SyntaxNode> CreateNewNodes(VariableDeclarationSyntax declaration);
    private static VariableDeclarationSyntax CreateNewDeclaration(VariableDeclaratorSyntax variable, VariableDeclarationSyntax declaration);
    private static IEnumerable`1<SyntaxTrivia> GetLeadingTriviaFor(VariableDeclaratorSyntax variable);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MutableFieldsShouldNotBePublicReadonly : MutableFieldsShouldNotBe {
    private static string DiagnosticId;
    private static string MessageFormat;
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <InvalidModifiers>k__BackingField;
    protected ISet`1<SyntaxKind> InvalidModifiers { get; }
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_InvalidModifiers();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.MutableFieldsShouldNotBePublicStatic : MutableFieldsShouldNotBe {
    private static string DiagnosticId;
    private static string MessageFormat;
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <InvalidModifiers>k__BackingField;
    protected ISet`1<SyntaxKind> InvalidModifiers { get; }
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_InvalidModifiers();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NameOfShouldBeUsed : NameOfShouldBeUsedBase`3<BaseMethodDeclarationSyntax, SyntaxKind, ThrowStatementSyntax> {
    private static HashSet`1<SyntaxKind> StringTokenTypes;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected string NameOf { get; }
    private static NameOfShouldBeUsed();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string get_NameOf();
    protected virtual BaseMethodDeclarationSyntax MethodSyntax(SyntaxNode node);
    protected virtual bool IsStringLiteral(SyntaxToken t);
    protected virtual IEnumerable`1<string> GetParameterNames(BaseMethodDeclarationSyntax method);
    protected virtual bool LeastLanguageVersionMatches(SonarSyntaxNodeReportingContext context);
    protected virtual bool IsArgumentExceptionCallingNameOf(SyntaxNode node, IEnumerable`1<string> arguments);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NativeMethodsShouldBeWrapped : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MakeThisMethodPrivateMessage;
    private static string MakeThisWrapperLessTrivialMessage;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NativeMethodsShouldBeWrapped();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportPublicExternalMethods(SonarSymbolReportingContext c);
    private static bool IsExternMethod(IMethodSymbol methodSymbol);
    private static void ReportTrivialWrappers(SonarSyntaxNodeReportingContext c);
    private static ISet`1<IMethodSymbol> GetExternalMethods(IMethodSymbol methodSymbol);
    private static IEnumerable`1<SyntaxNode> GetBodyDescendants(MethodDeclarationSyntax methodDeclaration);
    private static bool HasAtLeastTwo(IEnumerable`1<T> collection);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NestedCodeBlock : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NestedCodeBlock();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NoExceptionsInFinally : NoExceptionsInFinallyBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NonAsyncTaskShouldNotReturnNull : NonAsyncTaskShouldNotReturnNullBase {
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<SyntaxKind> TrackedNullLiteralLocations;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NonAsyncTaskShouldNotReturnNull();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SyntaxNode GetEnclosingMember(LiteralExpressionSyntax literal);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NonDerivedPrivateClassesShouldBeSealed : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableHashSet`1<SyntaxKind> KindsToBeDescended;
    private static ImmutableHashSet`1<SyntaxKind> PossiblyVirtualKinds;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NonDerivedPrivateClassesShouldBeSealed();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasVirtualMembers(TypeDeclarationSyntax typeDeclaration);
    private static bool IsSealed(TypeDeclarationSyntax typeDeclaration);
    private static bool IsPossiblyDerived(TypeDeclarationSyntax declaration, Lazy`1<SemanticModel> model, Lazy`1<List`1<INamedTypeSymbol>> otherSymbols, String& modifierDescription, String& scopeDescription);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NonFlagsEnumInBitwiseOperation : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageRemove;
    private static string MessageChangeOrRemove;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NonFlagsEnumInBitwiseOperation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckExpressionWithOperator(SonarSyntaxNodeReportingContext context, Func`2<T, SyntaxToken> operatorSelector);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NonFlagsEnumInBitwiseOperationCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.NonFlagsEnumInBitwiseOperationCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NormalizeStringsToUppercase : DoNotCallMethodsCSharpBase {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual bool ShouldReportOnMethodCall(InvocationExpressionSyntax invocation, SemanticModel semanticModel, MemberDescriptor memberDescriptor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NotAssignedPrivateMember : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static Accessibility MaxAccessibility;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> PreOrPostfixOpSyntaxKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NotAssignedPrivateMember();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static List`1<NodeSymbolAndModel`2<SyntaxNode, ISymbol>> GetCandidateDeclarations(CSharpRemovableDeclarationCollector removableDeclarationCollector);
    private static bool TypeDefinitionShouldBeSkipped(ITypeSymbol namedType);
    private static bool HasStructLayoutAttribute(ISymbol namedTypeSymbol);
    private static bool IsInitializedOrFixed(VariableDeclaratorSyntax declarator);
    private static bool IsAutoPropertyWithNoInitializer(PropertyDeclarationSyntax declaration);
    private static IList`1<NodeSymbolAndModel`2<SimpleNameSyntax, ISymbol>> GetMemberUsages(CSharpRemovableDeclarationCollector removableDeclarationCollector, HashSet`1<ISymbol> declaredPrivateSymbols);
    private static ISet`1<ISymbol> GetAssignedMemberSymbols(IList`1<NodeSymbolAndModel`2<SimpleNameSyntax, ISymbol>> memberUsages);
    private static bool IsParentMemberAccess(MemberAccessExpressionSyntax parent, ExpressionSyntax node);
    private static bool IsValueType(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.NumberPatternShouldBeRegular : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static char Underscore;
    private static char Dot;
    private static int NotFound;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NumberPatternShouldBeRegular();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    internal static bool HasIrregularPattern(string numericToken);
    private static string StripNumericPreAndSuffix(string numericToken);
    private static bool HasIrregularGroupLengths(Int32[] groupLengths);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ObjectCreatedDropped : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ObjectCreatedDropped();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ObsoleteAttributes : ObsoleteAttributesBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode GetExplanationExpression(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OperatorOverloadsShouldHaveNamedAlternatives : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static Dictionary`2<string, string> operatorAlternatives;
    private static Dictionary`2<string, string> otherOperatorAlternatives;
    private static Dictionary`2<string, string> operatorNames;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OperatorOverloadsShouldHaveNamedAlternatives();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAlternativeMethod(IMethodSymbol operatorSymbol, String& operatorAlternativeMethodName);
    [CompilerGeneratedAttribute]
internal static bool <HasAlternativeMethod>g__HasMethodWithName|10_0(string name, <>c__DisplayClass10_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OperatorsShouldBeOverloadedConsistently : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OperatorsShouldBeOverloadedConsistently();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<string> FindMissingMethods(INamedTypeSymbol classSymbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.OperatorsShouldBeOverloadedConsistently/<GetImplementedMethods>d__8")]
private static IEnumerable`1<string> GetImplementedMethods(INamedTypeSymbol classSymbol);
    private static string ImplementedOperator(IMethodSymbol member);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalParameter : OptionalParameterBase`3<SyntaxKind, BaseMethodDeclarationSyntax, ParameterSyntax> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<SyntaxKind> kindsOfInterest;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static OptionalParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual IEnumerable`1<ParameterSyntax> GetParameters(BaseMethodDeclarationSyntax method);
    protected virtual bool IsOptional(ParameterSyntax parameter);
    protected virtual Location GetReportLocation(ParameterSyntax parameter);
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalParameterNotPassedToBaseCall : OptionalParameterNotPassedToBaseCallBase`1<InvocationExpressionSyntax> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static OptionalParameterNotPassedToBaseCall();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual int GetArgumentCount(InvocationExpressionSyntax invocation);
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalParameterWithDefaultValue : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OptionalParameterWithDefaultValue();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalParameterWithDefaultValueCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.OptionalParameterWithDefaultValueCodeFix/<RegisterCodeFixesAsync>d__3")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalRefOutParameter : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OptionalRefOutParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OptionalRefOutParameterCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OrderByRepeated : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OrderByRepeated();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsMethodOrderByExtension(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsMethodThenByExtension(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool MethodIsOnIOrderedEnumerable(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsOrderByOrThenBy|6_1(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OrderByRepeatedCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.OrderByRepeatedCodeFix/<ChangeToThenByAsync>d__4")]
private static Task`1<Document> ChangeToThenByAsync(Document document, SyntaxNode syntaxNode, CancellationToken cancel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.OverrideGetHashCodeOnOverridingEquals : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OverrideGetHashCodeOnOverridingEquals();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static string GetMissingMethodName(string overridenMethodName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterAssignedTo : ParameterAssignedToBase`2<SyntaxKind, IdentifierNameSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsAssignmentToCatchVariable(ISymbol symbol, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterNameMatchesOriginal : ParameterNameMatchesOriginalBase`2<SyntaxKind, MethodDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual IEnumerable`1<SyntaxToken> ParameterIdentifiers(MethodDeclarationSyntax method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterNamesShouldNotDuplicateMethodNames : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParameterNamesShouldNotDuplicateMethodNames();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckMethodParameters(SonarSyntaxNodeReportingContext context, SyntaxToken identifier, ParameterListSyntax parameterList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParametersCorrectOrder : ParametersCorrectOrderBase`1<SyntaxKind> {
    protected SyntaxKind[] InvocationKinds { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual SyntaxKind[] get_InvocationKinds();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterTypeShouldMatchRouteTypeConstraint : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string ImplicitStringPrimaryMessageFormat;
    private static string PrimaryMessageFormat;
    private static string MessageWithSecondaryLocationFormat;
    private static string SecondaryMessageFormat;
    private static string ImplicitStringSecondaryMessage;
    private static string ImplicitStringConstraint;
    private static DiagnosticDescriptor Rule;
    private static Dictionary`2<string, SupportedType> ConstraintMapping;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParameterTypeShouldMatchRouteTypeConstraint();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IReadOnlyList`1<PropertyTypeMismatch> GetPropertyTypeMismatches(INamedTypeSymbol classSymbol, Compilation compilation);
    private static bool IsTypeMatchRouteConstraint(ITypeSymbol type, string routeConstraintType, Compilation compilation);
    private static Dictionary`2<string, List`1<RouteParameter>> GetRouteParametersWithValidConstraint(INamedTypeSymbol classDeclaration);
    private static Location CalculateRouteParamLocation(Location attributeLocation, AttributeSyntax routeNode, string routeParam);
    [CompilerGeneratedAttribute]
internal static Location <CalculateRouteParamLocation>g__CreateLocationFromRoute|16_0(Location routeLocation, int index, int lenght);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterValidationInAsyncShouldBeWrapped : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParameterValidationInAsyncShouldBeWrapped();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ParameterValidationInYieldShouldBeWrapped : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParameterValidationInYieldShouldBeWrapped();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PartCreationPolicyShouldBeUsedWithExportAttribute : PartCreationPolicyShouldBeUsedWithExportAttributeBase`2<AttributeSyntax, TypeDeclarationSyntax> {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PartCreationPolicyShouldBeUsedWithExportAttribute();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual TypeDeclarationSyntax GetTypeDeclaration(AttributeSyntax attribute);
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PartialMethodNoImplementation : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageAdditional;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PartialMethodNoImplementation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForCandidatePartialDeclaration(SonarSyntaxNodeReportingContext context);
    private static void CheckForCandidatePartialInvocation(SonarSyntaxNodeReportingContext context);
    private static IEnumerable`1<MethodDeclarationSyntax> PartialMethodsWithoutAccessModifier(IMethodSymbol methodSymbol);
    private static bool HasAccessModifier(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PasswordsShouldBeStoredCorrectly : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string UseMoreIterationsMessageFormat;
    private static int IterationCountThreshold;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PasswordsShouldBeStoredCorrectly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AspNetCore(SonarAnalysisContext context);
    private static void AspNetFramework(SonarAnalysisContext context);
    private static void Rfc2898DeriveBytes(SonarAnalysisContext context);
    private static void BouncyCastle(SonarAnalysisContext context);
    private static bool HasFewIterations(PropertyAccessContext context, PropertyAccessTracker`1<SyntaxKind> tracker);
    private static bool ArgumentLessThan(ArgumentContext context, int threshold);
    private static void Track(SyntaxTrackerBase`2<SyntaxKind, TContext> tracker, SonarAnalysisContext context, string message, Condition[] conditions);
    [CompilerGeneratedAttribute]
internal static void <BouncyCastle>g__TrackSCrypt|11_3(string argumentName, int argumentPosition, string diagnosticMessage, int threshold, <>c__DisplayClass11_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PermissiveCors : TrackerHotspotDiagnosticAnalyzer`1<SyntaxKind> {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string AccessControlAllowOriginHeader;
    private static string AccessControlAllowOriginPropertyName;
    private static string StarConstant;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    public PermissiveCors(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual void Initialize(TrackerInput input);
    private static void SetupInvocationTracker(InvocationTracker`1<SyntaxKind> tracker, TrackerInput input);
    private static void SetupObjectCreationTracker(ObjectCreationTracker`1<SyntaxKind> tracker, TrackerInput input);
    private void VisitAttribute(SonarSyntaxNodeReportingContext context);
    private static bool IsFirstArgumentAccessControlAllowOrigin(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsAccessControlAllowOriginProperty(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
    private static bool IsSecondArgumentStarString(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsStar(ExpressionSyntax expressionSyntax, SemanticModel semanticModel);
    private static bool ContainsStar(IEnumerable`1<ExpressionSyntax> expressions, SemanticModel semanticModel);
    private static bool ContainsStar(Optional`1<object> constantValue);
    private static bool ContainsStar(IObjectCreation objectCreation, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarCompilationStartAnalysisContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PInvokesShouldNotBeVisible : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PInvokesShouldNotBeVisible();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PointersShouldBePrivate : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PointersShouldBePrivate();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IFieldSymbol SymbolIfPointerType(VariableDeclarationSyntax variableDeclaration, VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel);
    private static bool IsPointerStructure(VariableDeclarationSyntax variableDeclaration);
    private static bool IsNameOfPointerStruct(string typeName);
    private static bool IsUnmanagedFunctionPointer(VariableDeclarationSyntax variableDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PreferGuidEmpty : PreferGuidEmptyBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PreferGuidEmptyCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode ToReplace(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode Replacement(SyntaxNode root, SyntaxNode toReplace);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PreferJaggedArraysOverMultidimensional : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferJaggedArraysOverMultidimensional();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeNode(SonarSyntaxNodeReportingContext context, Func`3<SemanticModel, TSyntax, ITypeSymbol> getTypeSymbol, Func`2<TSyntax, Location> getLocation);
    private static bool IsMultiDimensionalArray(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> NonPrivateModifiers;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PrivateFieldUsedAsLocalVariable();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IDictionary`2<IFieldSymbol, VariableDeclaratorSyntax> GetPrivateFields(SemanticModel model, TypeDeclarationSyntax typeDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <GetPrivateFields>g__IsPrivate|8_3(FieldDeclarationSyntax fieldDeclaration);
    [CompilerGeneratedAttribute]
internal static bool <GetPrivateFields>g__HasNoAttributes|8_4(FieldDeclarationSyntax fieldDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PrivateStaticMethodUsedOnlyByNestedClass : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static SyntaxKind[] AnalyzedSyntaxKinds;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PrivateStaticMethodUsedOnlyByNestedClass();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsPartial(TypeDeclarationSyntax type);
    private static bool HasNestedTypeDeclarations(TypeDeclarationSyntax type);
    private static MethodDeclarationSyntax[] PrivateStaticMethodsOf(TypeDeclarationSyntax type);
    private static bool IsPrivateAndStatic(MethodDeclarationSyntax method, TypeDeclarationSyntax containingType);
    private static TypeDeclarationSyntax LowestCommonAncestorOrSelf(IEnumerable`1<TypeDeclarationSyntax> declaredTypes);
    private static IEnumerable`1<MethodUsedByTypes> TypesWhichUseTheMethods(IEnumerable`1<MethodDeclarationSyntax> methods, TypeDeclarationSyntax outerType, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static bool <IsPrivateAndStatic>g__IsExplicitlyPrivate|10_1(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsPrivateAndStatic>g__IsImplicityPrivate|10_2(<>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsPrivateAndStatic>g__IsClassOrRecordClassOrInterfaceDeclaration|10_3(TypeDeclarationSyntax type);
    [CompilerGeneratedAttribute]
internal static bool <IsPrivateAndStatic>g__HasAnyModifier|10_4(MethodDeclarationSyntax method, SyntaxKind[] modifiers);
    [CompilerGeneratedAttribute]
internal static TypeDeclarationSyntax[] <LowestCommonAncestorOrSelf>g__PathFromTop|11_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <TypesWhichUseTheMethods>g__IsRecursiveMethodCall|12_3(IdentifierNameSyntax methodCall, MethodDeclarationSyntax methodDeclaration);
    [CompilerGeneratedAttribute]
internal static TypeDeclarationSyntax <TypesWhichUseTheMethods>g__ContainingTypeDeclaration|12_5(IdentifierNameSyntax identifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertiesAccessCorrectField : PropertiesAccessCorrectFieldBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IEnumerable`1<FieldData<SyntaxKind>> FindFieldAssignments(IPropertySymbol property, Compilation compilation);
    protected virtual IEnumerable`1<FieldData<SyntaxKind>> FindFieldReads(IPropertySymbol property, Compilation compilation);
    protected virtual bool ShouldIgnoreAccessor(IMethodSymbol accessorMethod, Compilation compilation);
    protected virtual bool ImplementsExplicitGetterOrSetter(IPropertySymbol property);
    private static void FillAssignments(IDictionary`2<IFieldSymbol, FieldData<SyntaxKind>> assignments, Compilation compilation, SyntaxNode root, bool useFieldLocation);
    private static ExpressionSyntax SingleReturn(SyntaxNode body);
    private static ExpressionSyntax SingleInvocation(SyntaxNode body);
    private static Nullable`1<FieldData<SyntaxKind>> ExtractFieldFromExpression(AccessorKind<SyntaxKind> accessorKind, ExpressionSyntax expression, Compilation compilation, bool useFieldLocation);
    private static bool IsLeftSideOfAssignment(ExpressionSyntax expression);
    private static bool HasExplicitAccessor(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static void <FindFieldReads>g__FillReads|3_0(SyntaxNode root, bool useFieldLocation, <>c__DisplayClass3_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertiesShouldBePreferred : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertiesShouldBePreferred();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasCandidateSignature(IMethodSymbol method);
    private static bool HasCandidateReturnType(IMethodSymbol method);
    private static bool HasCandidateName(IMethodSymbol method);
    private static bool UsageAttributesAllowProperties(IMethodSymbol method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertyGetterWithThrow : PropertyGetterWithThrowBase`2<SyntaxKind, AccessorDeclarationSyntax> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected SyntaxKind ThrowSyntaxKind { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static PropertyGetterWithThrow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual SyntaxKind get_ThrowSyntaxKind();
    protected virtual bool IsGetter(AccessorDeclarationSyntax propertyGetter);
    protected virtual bool IsIndexer(AccessorDeclarationSyntax propertyGetter);
    protected virtual SyntaxNode GetThrowExpression(SyntaxNode syntaxNode);
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertyNamesShouldNotMatchGetMethods : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertyNamesShouldNotMatchGetMethods();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.PropertyNamesShouldNotMatchGetMethods/<CollidingMembers>d__7")]
private static IEnumerable`1<Tuple`2<SyntaxToken, SyntaxToken>> CollidingMembers(IPropertySymbol[] properties, IMethodSymbol[] methods);
    private static bool AreCollidingNames(string propertyName, string methodName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertyToAutoProperty : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertyToAutoProperty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAttributes(SyntaxList`1<AccessorDeclarationSyntax> accessors);
    private static bool HasDifferentModifiers(SyntaxList`1<AccessorDeclarationSyntax> accessors);
    private static IEnumerable`1<SyntaxKind> ModifierKinds(AccessorDeclarationSyntax accessor);
    private static IFieldSymbol FieldFromSetter(AccessorDeclarationSyntax setter, SemanticModel semanticModel);
    private static IFieldSymbol FieldSymbol(ExpressionSyntax expression, INamedTypeSymbol declaringType, SemanticModel semanticModel);
    private static IFieldSymbol FieldFromGetter(AccessorDeclarationSyntax getter, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static AssignmentExpressionSyntax <FieldFromSetter>g__AssignmentFromBody|10_0(BlockSyntax body);
    [CompilerGeneratedAttribute]
internal static AssignmentExpressionSyntax <FieldFromSetter>g__AssignmentFromExpressionBody|10_1(ArrowExpressionClauseSyntax expressionBody);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <FieldFromGetter>g__GetReturnExpressionFromBody|12_0(BlockSyntax body);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PropertyWriteOnly : PropertyWriteOnlyBase`2<SyntaxKind, PropertyDeclarationSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind SyntaxKind { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_SyntaxKind();
    protected virtual bool IsWriteOnlyProperty(PropertyDeclarationSyntax prop);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ProvideDeserializationMethodsForOptionalFields : ProvideDeserializationMethodsForOptionalFieldsBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual Location GetNamedTypeIdentifierLocation(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PublicConstantField : PublicConstantFieldBase`3<SyntaxKind, FieldDeclarationSyntax, VariableDeclaratorSyntax> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public SyntaxKind FieldDeclarationKind { get; }
    public string MessageArgument { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static PublicConstantField();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual SyntaxKind get_FieldDeclarationKind();
    public virtual string get_MessageArgument();
    protected virtual Location GetReportLocation(VariableDeclaratorSyntax node);
    protected virtual IEnumerable`1<VariableDeclaratorSyntax> GetVariables(FieldDeclarationSyntax node);
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PubliclyWritableDirectories : PubliclyWritableDirectoriesBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal PubliclyWritableDirectories(IAnalyzerConfiguration configuration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    private protected virtual bool IsGetTempPathAssignment(InvocationExpressionSyntax invocationExpression, KnownType type, string methodName, SemanticModel semanticModel);
    private protected virtual bool IsInsecureEnvironmentVariableRetrieval(InvocationExpressionSyntax invocation, KnownType type, string methodName, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PublicMethodWithMultidimensionalArray : PublicMethodWithMultidimensionalArrayBase`1<SyntaxKind> {
    private static ImmutableArray`1<SyntaxKind> KindsOfInterest;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    private static PublicMethodWithMultidimensionalArray();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual Location GetIssueLocation(SyntaxNode node);
    protected virtual string GetType(SyntaxNode node);
    protected virtual IMethodSymbol MethodSymbolOfNode(SemanticModel semanticModel, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.PureAttributeOnVoidMethod : PureAttributeOnVoidMethodBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsPureAttribute(AttributeSyntax attribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundancyInConstructorDestructorDeclaration : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static SyntaxKind[] TypesWithPrimaryConstructorDeclarations;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundancyInConstructorDestructorDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckTypesWithPrimaryConstructor(SonarSyntaxNodeReportingContext context);
    private static void CheckDestructorDeclaration(SonarSyntaxNodeReportingContext context);
    private static void CheckConstructorDeclaration(SonarSyntaxNodeReportingContext context);
    private static bool IsInitializerRedundant(ConstructorInitializerSyntax initializer);
    private static bool IsConstructorRedundant(ConstructorDeclarationSyntax constructorDeclaration, SemanticModel model);
    private static bool IsStructWithInitializedFieldOrProperty(BaseTypeDeclarationSyntax typeDeclaration, SemanticModel model);
    private static bool IsSinglePublicConstructor(ConstructorDeclarationSyntax constructorDeclaration, SemanticModel model);
    private static bool IsInitializerEmptyOrRedundant(ConstructorInitializerSyntax initializer);
    private static bool TypeHasExactlyOneConstructor(BaseTypeDeclarationSyntax containingTypeDeclaration, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static bool <CheckTypesWithPrimaryConstructor>g__IsInheritingFromTypeWithValueInPrimaryConstructor|8_0(TypeDeclarationSyntax node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundancyInConstructorDestructorDeclarationCodeFix : SonarCodeFix {
    internal static string TitleRemoveBaseCall;
    internal static string TitleRemoveConstructor;
    internal static string TitleRemoveDestructor;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void RegisterActionForDestructor(SonarCodeFixContext context, SyntaxNode root, SyntaxNode method);
    private static void RegisterActionForConstructor(SonarCodeFixContext context, SyntaxNode root, SyntaxNode method);
    private static void RegisterActionForBaseCall(SonarCodeFixContext context, SyntaxNode root, SyntaxNode initializer);
    private static SyntaxNode RemoveInitializer(SyntaxNode root, ConstructorDeclarationSyntax constructor);
    private static ConstructorDeclarationSyntax GetConstructor(SyntaxNode newRoot, SyntaxAnnotation annotation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantArgument : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantArgument();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    internal static bool ArgumentHasDefaultValue(NodeAndSymbol`2<ArgumentSyntax, IParameterSymbol> argumentMapping, SemanticModel semanticModel);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantArgumentCodeFix : SonarCodeFix {
    internal static string TitleRemove;
    internal static string TitleRemoveWithNameAdditions;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.RedundantArgumentCodeFix/<RegisterCodeFixesAsync>d__4")]
protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.RedundantArgumentCodeFix/<RemoveArgumentsAndAddNecessaryNamesAsync>d__5")]
private static Task`1<Document> RemoveArgumentsAndAddNecessaryNamesAsync(Document document, ArgumentListSyntax argumentList, IEnumerable`1<NodeAndSymbol`2<ArgumentSyntax, IParameterSymbol>> argumentMappings, List`1<ArgumentSyntax> argumentsToRemove, SemanticModel semanticModel, CancellationToken cancel);
    private static ArgumentListSyntax AddArgument(ArgumentListSyntax argumentList, string parameterName, ArgumentSyntax argument, bool alreadyRemovedOne);
    private static ArgumentListSyntax AddParamsArguments(SemanticModel semanticModel, IEnumerable`1<NodeAndSymbol`2<ArgumentSyntax, IParameterSymbol>> paramsArguments, ArgumentListSyntax argumentList);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.RedundantArgumentCodeFix/<RemoveArgumentsAsync>d__8")]
private static Task`1<Document> RemoveArgumentsAsync(Document document, IEnumerable`1<ArgumentSyntax> arguments, CancellationToken cancel);
    private static InvocationExpressionSyntax GetInvocation(SyntaxNode root, TextSpan diagnosticSpan);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantCast : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> CastIEnumerableMethods;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantCast();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckCastExpression(SonarSyntaxNodeReportingContext context, ExpressionSyntax expression, ExpressionSyntax type, Location location);
    private static bool FlowStateEquals(TypeInfo expressionTypeInfo, ExpressionSyntax type);
    private static void CheckExtensionMethodInvocation(SonarSyntaxNodeReportingContext context);
    private static void ReportIssue(SonarSyntaxNodeReportingContext context, ExpressionSyntax expression, ITypeSymbol castType, Location location);
    private static IMethodSymbol GetEnumerableExtensionSymbol(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static ITypeSymbol GetGenericTypeArgument(ITypeSymbol type);
    private static bool CanHaveNullValue(ITypeSymbol type);
    private static Location GetReportLocation(InvocationExpressionSyntax invocation, bool methodCalledAsStatic);
    private static ITypeSymbol GetElementType(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetElementType>g__CollectionExpression|16_0(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetElementType>g__ReducedExtensionExpression|16_1(InvocationExpressionSyntax invocation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantCastCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNode RemoveCall(SyntaxNode root, InvocationExpressionSyntax castInvocation, MemberAccessExpressionSyntax memberAccess);
    private static SyntaxNode RemoveStaticMemberCall(SyntaxNode root, MemberAccessExpressionSyntax memberAccess);
    private static SyntaxNode RemoveExtensionMethodCall(SyntaxNode root, InvocationExpressionSyntax invocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantConditionalAroundAssignment : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantConditionalAroundAssignment();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void UselessConditionIfStatement(SonarSyntaxNodeReportingContext c);
    private static void UselessConditionSwitchExpression(SonarSyntaxNodeReportingContext c);
    private static bool TryGetNotEqualsCondition(IfStatementSyntax ifStatement, BinaryExpressionSyntax& condition);
    private static bool TryGetSingleAssignment(IfStatementSyntax ifStatement, AssignmentExpressionSyntax& assignment);
    private static bool AreMatchingExpressions(SyntaxNode condition1, SyntaxNode condition2, SyntaxNode assignment1, SyntaxNode assignment2);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantConditionalAroundAssignmentCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static Task HandleIfStatement(SyntaxNode root, SonarCodeFixContext context, IfStatementSyntax ifStatement);
    private static Task HandleSwitchExpression(SyntaxNode root, SonarCodeFixContext context, SyntaxNode switchExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantDeclaration : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string DiagnosticTypeKey;
    internal static string ParameterNameKey;
    private static string MessageFormat;
    private static string UseDiscardMessageFormat;
    private static DiagnosticDescriptor Rule;
    private static DiagnosticDescriptor DiscardRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<SyntaxKind> RefOutKeywords;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VisitParenthesizedLambdaExpression(SonarSyntaxNodeReportingContext context);
    private static void CheckTypeSpecifications(SonarSyntaxNodeReportingContext context, ParenthesizedLambdaExpressionSyntax lambda);
    private static void CheckUnusedParameters(SonarSyntaxNodeReportingContext context, ParenthesizedLambdaExpressionSyntax lambda);
    private static IEnumerable`1<string> GetUsedIdentifiers(ParenthesizedLambdaExpressionSyntax lambda);
    private static bool IsParameterListModifiable(ParenthesizedLambdaExpressionSyntax lambda);
    private static bool ParameterTypesDoNotMatch(IMethodSymbol method1, IMethodSymbol method2);
    private static void ReportRedundantNullableConstructorCall(SonarSyntaxNodeReportingContext context);
    private static bool IsNullableCreation(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static bool IsInAssignmentOrReturnValue(SyntaxNode objectCreation);
    private static bool IsInNotVarDeclaration(SyntaxNode objectCreation);
    private static void ReportRedundancyInArrayCreation(SonarSyntaxNodeReportingContext context);
    private static void ReportRedundantArraySizeSpecifier(SonarSyntaxNodeReportingContext context, ArrayCreationExpressionSyntax array);
    private static void ReportRedundantArrayTypeSpecifier(SonarSyntaxNodeReportingContext context, ArrayCreationExpressionSyntax array);
    private static void ReportOnRedundantObjectInitializer(SonarSyntaxNodeReportingContext context);
    private static void ReportOnExplicitDelegateCreation(SonarSyntaxNodeReportingContext context);
    private static bool IsDynamic(ArgumentSyntax argument, SemanticModel semanticModel);
    private static bool IsInDeclarationNotVarNotDelegate(SyntaxNode objectCreation, SemanticModel semanticModel);
    private static bool IsDelegateCreation(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static bool IsReturnValueNotDelegate(SyntaxNode objectCreation, SemanticModel semanticModel);
    private static bool IsAssignmentNotDelegate(SyntaxNode objectCreation, SemanticModel semanticModel);
    private static void ReportOnRedundantParameterList(SonarSyntaxNodeReportingContext context);
    private static bool IsInArgumentAndCanBeChanged(IObjectCreation objectCreation, SemanticModel semanticModel, Func`2<InvocationExpressionSyntax, bool> additionalFilter);
    private static void ReportIssueOnRedundantObjectCreation(SonarSyntaxNodeReportingContext context, SyntaxNode node, string message, RedundancyType redundancyType);
    private static T ChangeSyntaxElement(T originalNode, T newNode, SemanticModel originalSemanticModel, SemanticModel& newSemanticModel);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantDeclarationCodeFix : SonarCodeFix {
    internal static string TitleRedundantArraySize;
    internal static string TitleRedundantArrayType;
    internal static string TitleRedundantLambdaParameterType;
    internal static string TitleRedundantExplicitDelegate;
    internal static string TitleRedundantExplicitNullable;
    internal static string TitleRedundantObjectInitializer;
    internal static string TitleRedundantDelegateParameterList;
    internal static string TitleRedundantParameterName;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void RegisterRedundantLambdaParameterAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, ImmutableDictionary`2<string, string> properties, SonarCodeFixContext context);
    private static void RegisterRedundantArraySizeAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, SonarCodeFixContext context);
    private static void RegisterRedundantArrayTypeAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, SonarCodeFixContext context);
    private static void RegisterRedundantExplicitObjectCreationAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, RedundancyType diagnosticType, SonarCodeFixContext context);
    private static void RegisterRedundantObjectInitializerAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, SonarCodeFixContext context);
    private static void RegisterRedundantParameterTypeAction(SyntaxNode syntaxNode, SyntaxNode root, Document document, SonarCodeFixContext context);
    private static void RegisterAction(SyntaxNode syntaxNode, SyntaxNode root, RedundancyType diagnosticType, Document document, ImmutableDictionary`2<string, string> properties, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantInheritanceList : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string RedundantIndexKey;
    private static string MessageEnum;
    private static string MessageObjectBase;
    private static string MessageAlreadyImplements;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantInheritanceList();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportRedundantBaseType(SonarSyntaxNodeReportingContext context, BaseTypeDeclarationSyntax typeDeclaration, KnownType redundantType, string message);
    private static void ReportRedundantInterfaces(SonarSyntaxNodeReportingContext context, BaseTypeDeclarationSyntax typeDeclaration);
    private static MultiValueDictionary`2<INamedTypeSymbol, INamedTypeSymbol> GetImplementedInterfaceMappings(BaseListSyntax baseList, SemanticModel semanticModel);
    private static INamedTypeSymbol CollidingDeclaration(INamedTypeSymbol declaredType, INamedTypeSymbol interfaceType, MultiValueDictionary`2<INamedTypeSymbol, INamedTypeSymbol> interfaceMappings);
    private static bool CanInterfaceBeRemovedBasedOnMembers(INamedTypeSymbol declaredType, INamedTypeSymbol interfaceType);
    private static Location GetLocationWithToken(TypeSyntax type, SeparatedSyntaxList`1<BaseTypeSyntax> baseTypes);
    private static ImmutableDictionary`2<string, string> DiagnosticsProperties(int redundantIndex);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<INamedTypeSymbol> <CanInterfaceBeRemovedBasedOnMembers>g__AllInterfacesAndSelf|15_1(INamedTypeSymbol interfaceType);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantInheritanceListCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    internal static bool HasLineEnding(SyntaxNode node);
    private static bool HasLineEnding(SyntaxToken token);
    private static SyntaxNode RemoveDeclaration(SyntaxNode root, BaseListSyntax baseList, int redundantIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantJumpStatement : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantJumpStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForRedundantJumps(SonarSyntaxNodeReportingContext context);
    private static bool IsJumpRemovable(JumpBlock jumpBlock, int yieldStatementCount);
    private static bool IsValidJumpInsideTryCatch(JumpBlock jumpBlock);
    private static bool IsInsideSwitch(JumpBlock jumpBlock);
    private static bool IsYieldReturn(JumpBlock jumpBlock);
    private static bool IsOnlyYieldBreak(JumpBlock jumpBlock, int yieldStatementCount);
    private static bool IsThrow(JumpBlock jumpBlock);
    private static bool IsReturnWithExpression(JumpBlock jumpBlock);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantModifier : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> UnsafeConstructKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantModifier();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForUnnecessaryUnsafeBlocks(SonarSyntaxNodeReportingContext context);
    private static void CheckForUnnecessaryUnsafeBlocksBelow(SonarSyntaxNodeReportingContext context, TypeDeclarationSyntax typeDeclaration);
    private static void CheckForUnnecessaryUnsafeBlocksInMember(SonarSyntaxNodeReportingContext context, MemberDeclarationSyntax member);
    private static bool HasUnsafeConstructInside(SyntaxNode container, SemanticModel semanticModel);
    private static bool ContainsUnsafeParameter(SyntaxNode container, SemanticModel semanticModel);
    private static bool ContainsUnsafeInvocationReturnValue(SyntaxNode container, SemanticModel semanticModel);
    private static bool ContainsUnsafeTypedIdentifier(SyntaxNode container, SemanticModel semanticModel);
    private static bool ContainsFixedDeclaration(SyntaxNode container);
    private static bool ContainsUnsafeConstruct(SyntaxNode container);
    private static bool IsUnsafe(ITypeSymbol type);
    private static void MarkAllUnsafeBlockInside(SonarSyntaxNodeReportingContext context, SyntaxNode container);
    private static void ReportOnUnsafeBlock(SonarSyntaxNodeReportingContext context, Location issueLocation);
    private static SyntaxToken FindUnsafeKeyword(MemberDeclarationSyntax memberDeclaration);
    private static void CheckTypeDeclarationForRedundantPartial(SonarSyntaxNodeReportingContext context);
    private static SyntaxTokenList Modifiers(MemberDeclarationSyntax memberDeclaration);
    private static void CheckSealedMemberInSealedClass(SonarSyntaxNodeReportingContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantModifierCodeFix : SonarCodeFix {
    internal static string TitleUnsafe;
    internal static string TitleChecked;
    internal static string TitlePartial;
    internal static string TitleSealed;
    private static SyntaxKind[] SimpleTokenKinds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static RedundantModifierCodeFix();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static Task`1<Document> ReplaceRoot(SonarCodeFixContext context, SyntaxNode newRoot);
    private static SyntaxNode RemoveRedundantUnsafe(SyntaxNode root, SyntaxToken token);
    private static SyntaxNode RemoveRedundantToken(SyntaxNode root, SyntaxToken token);
    private static SyntaxNode RemoveRedundantCheckedStatement(SyntaxNode root, CheckedStatementSyntax checkedStatement);
    private static SyntaxNode RemoveRedundantCheckedExpression(SyntaxNode root, CheckedExpressionSyntax checkedExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantNullableTypeComparison : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantNullableTypeComparison();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckGetTypeAndTypeOfEquality(SonarSyntaxNodeReportingContext context, ExpressionSyntax sideA, ExpressionSyntax sideB, Location location);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantNullCheck : RedundantNullCheckBase`1<BinaryExpressionSyntax> {
    private static string MessageFormat;
    private static string MessageFormatForPatterns;
    private static DiagnosticDescriptor RuleForIs;
    private static DiagnosticDescriptor RuleForPatternSyntax;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantNullCheck();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual SyntaxNode GetLeftNode(BinaryExpressionSyntax binaryExpression);
    protected virtual SyntaxNode GetRightNode(BinaryExpressionSyntax binaryExpression);
    protected virtual SyntaxNode GetNullCheckVariable(SyntaxNode node);
    protected virtual SyntaxNode GetNonNullCheckVariable(SyntaxNode node);
    protected virtual SyntaxNode GetIsOperatorCheckVariable(SyntaxNode node);
    protected virtual SyntaxNode GetInvertedIsOperatorCheckVariable(SyntaxNode node);
    protected virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    private static void CheckAndPattern(SonarSyntaxNodeReportingContext context);
    private static void CheckOrPattern(SonarSyntaxNodeReportingContext context);
    private static SyntaxNode GetNullCheckVariable(SyntaxNode node, bool expectedAffirmative);
    [CompilerGeneratedAttribute]
internal static bool <GetIsOperatorCheckVariable>g__IsAffirmativePatternMatch|12_0(IsPatternExpressionSyntaxWrapper isPatternWrapper);
    [CompilerGeneratedAttribute]
internal static bool <GetInvertedIsOperatorCheckVariable>g__IsNegativePatternMatch|13_0(IsPatternExpressionSyntaxWrapper patternSyntaxWrapper);
    [CompilerGeneratedAttribute]
internal static bool <CheckAndPattern>g__IsNotNullPattern|15_0(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <CheckAndPattern>g__IsAffirmativePatternMatch|15_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <CheckOrPattern>g__IsNegativePatternMatch|16_0(PatternSyntaxWrapper node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantNullCheckCodeFix : SonarCodeFix {
    internal static string Title;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void RegisterBinaryExpressionCodeFix(SonarCodeFixContext context, SyntaxNode root, SyntaxNode mustBeReplaced);
    private static void RegisterBinaryPatternCodeFix(SonarCodeFixContext context, SyntaxNode root, SyntaxNode mustBeReplaced);
    private static SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode binaryExpression, SyntaxNode binaryLeft, SyntaxNode binaryRight, SyntaxNode mustBeReplaced);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantParentheses : RedundantParenthesesBase`2<ParenthesizedExpressionSyntax, SyntaxKind> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind <ParenthesizedExpressionSyntaxKind>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected SyntaxKind ParenthesizedExpressionSyntaxKind { get; }
    private static RedundantParentheses();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind get_ParenthesizedExpressionSyntaxKind();
    protected virtual SyntaxNode GetExpression(ParenthesizedExpressionSyntax parenthesizedExpression);
    protected virtual SyntaxToken GetOpenParenToken(ParenthesizedExpressionSyntax parenthesizedExpression);
    protected virtual SyntaxToken GetCloseParenToken(ParenthesizedExpressionSyntax parenthesizedExpression);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantParenthesesCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantParenthesesObjectsCreation : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantParenthesesObjectsCreation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantPropertyNamesInAnonymousClass : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantPropertyNamesInAnonymousClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<AnonymousObjectMemberDeclaratorSyntax> GetRedundantInitializers(IEnumerable`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantPropertyNamesInAnonymousClassCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static SyntaxNodeOrToken GetNewSyntaxListItem(SyntaxNodeOrToken item);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantToArrayCall : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantToArrayCall();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static MemberAccessExpressionSyntax GetRedundantMemberAccess(SonarSyntaxNodeReportingContext context, string targetMethodName, KnownType targetKnownType);
    [CompilerGeneratedAttribute]
internal static bool <GetRedundantMemberAccess>g__IsTargetMethod|6_0(MemberAccessExpressionSyntax memberAccess, <>c__DisplayClass6_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantToArrayCallCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantToStringCall : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static string MessageCallOnString;
    internal static string MessageCompiler;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static string additionOperatorName;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RedundantToStringCall();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckRightSideOfAddAssignmentsForToStringCall(SonarAnalysisContext context);
    private static void CheckSidesOfAddExpressionsForToStringCall(SonarAnalysisContext context);
    private static void CheckToStringInvocationsOnStringAndInStringFormat(SonarAnalysisContext context);
    private static void CheckLeftExpressionForRemovableToStringCall(SonarSyntaxNodeReportingContext context, BinaryExpressionSyntax binary);
    private static void CheckRightExpressionForRemovableToStringCall(SonarSyntaxNodeReportingContext context, BinaryExpressionSyntax binary);
    private static void CheckRightExpressionForRemovableToStringCall(SonarSyntaxNodeReportingContext context, AssignmentExpressionSyntax assignment);
    private static void CheckExpressionForRemovableToStringCall(SonarSyntaxNodeReportingContext context, ExpressionSyntax expressionWithToStringCall, ExpressionSyntax otherOperandOfAddition, int checkedSideIndex);
    private static bool TryGetExpressionTypeOfOwner(InvocationExpressionSyntax invocation, SemanticModel semanticModel, ITypeSymbol& subExpressionType);
    private static bool DoesCollidingAdditionExist(ITypeSymbol subExpressionType, int stringParameterIndex);
    private static bool IsStringFormatCall(IMethodSymbol stringFormatSymbol);
    private static bool IsOperationAddOnString(IMethodSymbol operation);
    private static bool IsArgumentlessToStringCallNotOnBaseExpression(ExpressionSyntax expression, SemanticModel semanticModel, Location& location, IMethodSymbol& methodSymbol);
    private static bool IsParameterlessToString(IMethodSymbol methodSymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RedundantToStringCallCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ReferenceEqualityCheckWhenEqualsExists : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string EqualsName;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> AllowedTypes;
    private static ImmutableArray`1<KnownType> AllowedTypesWithAllDerived;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReferenceEqualityCheckWhenEqualsExists();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool MightOverrideEquals(ITypeSymbol type, ISet`1<INamedTypeSymbol> allInterfacesWithImplementationsOverriddenEquals);
    private static bool HasTypeConstraintsWhichMightOverrideEquals(ITypeSymbol type, ISet`1<INamedTypeSymbol> allInterfacesWithImplementationsOverriddenEquals);
    private static bool IsAllowedTypeOrNull(ITypeSymbol type);
    private static bool HasAllowedBaseType(ITypeSymbol type);
    private static bool IsBinaryCandidateForReporting(BinaryExpressionSyntax binary, SemanticModel semanticModel);
    private static bool HasEqualsOverride(ITypeSymbol type);
    private static IEnumerable`1<IMethodSymbol> GetEqualsOverrides(ITypeSymbol type);
    private static bool IsInEqualsOverride(IMethodSymbol method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ReferenceEqualsOnValueType : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string ReferenceEqualsName;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReferenceEqualsOnValueType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool AnyArgumentIsValueType(ArgumentListSyntax argumentList, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RegexMustHaveValidSyntax : RegexMustHaveValidSyntaxBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RequestsWithExcessiveLength : RequestsWithExcessiveLengthBase`2<SyntaxKind, AttributeSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal RequestsWithExcessiveLength(IAnalyzerConfiguration analyzerConfiguration);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual AttributeSyntax IsInvalidRequestFormLimits(AttributeSyntax attribute, SemanticModel semanticModel);
    protected virtual AttributeSyntax IsInvalidRequestSizeLimit(AttributeSyntax attribute, SemanticModel semanticModel);
    protected virtual SyntaxNode GetMethodLocalFunctionOrClassDeclaration(AttributeSyntax attribute);
    protected virtual string AttributeName(AttributeSyntax attribute);
    private static bool IsMultipartBodyLengthLimit(AttributeArgumentSyntax argument);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RequireAttributeUsageAttribute : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RequireAttributeUsageAttribute();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool InheritsAttributeUsage(INamedTypeSymbol classSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ReturnEmptyCollectionInsteadOfNull : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> CollectionTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReturnEmptyCollectionInsteadOfNull();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportIfReturnsNullOrDefault(SonarSyntaxNodeReportingContext context);
    private static BlockSyntax GetBody(SyntaxNode node);
    private static bool IsReturningCollection(SonarSyntaxNodeReportingContext context);
    private static ITypeSymbol GetType(SonarSyntaxNodeReportingContext context);
    private static ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode node);
    private static AccessorDeclarationSyntax GetAccessor(PropertyDeclarationSyntax property);
    private static IEnumerable`1<SyntaxNode> GetReturnNullOrDefaultExpressions(SyntaxNode methodBlock);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.ReturnEmptyCollectionInsteadOfNull/<GetNullOrDefaultExpressions>d__15")]
private static IEnumerable`1<SyntaxNode> GetNullOrDefaultExpressions(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <ReportIfReturnsNullOrDefault>g__ReportIfAny|8_0(List`1<Location> nullOrDefaultLiterals, <>c__DisplayClass8_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ReturnValueIgnored : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> ImmutableKnownTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReturnValueIgnored();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckExpressionForPureMethod(SonarSyntaxNodeReportingContext context, ExpressionSyntax expression);
    private static bool IsSideEffectFreeOrPure(IMethodSymbol invokedMethodSymbol);
    private static bool IsPureMethod(IMethodSymbol invokedMethodSymbol, INamedTypeSymbol containingType);
    private static bool HasOnlySideEffectFreeMethods(INamedTypeSymbol containingType);
    private static bool IsLinqMethod(IMethodSymbol methodSymbol);
}
public abstract class SonarAnalyzer.Rules.CSharp.ReuseClientBase : SonarDiagnosticAnalyzer {
    protected ImmutableArray`1<KnownType> ReusableClients { get; }
    protected abstract virtual ImmutableArray`1<KnownType> get_ReusableClients();
    protected static bool IsAssignedForReuse(SonarSyntaxNodeReportingContext context);
    protected bool IsReusableClient(SonarSyntaxNodeReportingContext context);
    private static bool IsInVariableDeclaration(SyntaxNode node);
    private static bool IsInFieldOrPropertyInitializer(SyntaxNode node);
    private static bool IsInConditionalCode(SyntaxNode node);
    private static bool IsAssignedToStaticFieldOrProperty(SonarSyntaxNodeReportingContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ReversedOperators : ReversedOperatorsBase`1<PrefixUnaryExpressionSyntax> {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReversedOperators();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual SyntaxToken GetOperatorToken(PrefixUnaryExpressionSyntax e);
    protected virtual bool IsEqualsToken(SyntaxToken token);
    protected virtual bool IsMinusToken(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RightCurlyBraceStartsLine : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RightCurlyBraceStartsLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool StartsLine(SyntaxToken token);
    private static bool IsOnSameLineAsOpenBrace(SyntaxToken closeBraceToken);
    private static bool IsInitializer(SyntaxNode node);
    private static IEnumerable`1<SyntaxToken> GetDescendantCloseBraceTokens(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.RouteTemplateShouldNotStartWithSlash : RouteTemplateShouldNotStartWithSlashBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SecurityPInvokeMethodShouldNotBeCalled : SecurityPInvokeMethodShouldNotBeCalledBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual IMethodSymbol MethodSymbolForInvalidInvocation(SyntaxNode syntaxNode, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SelfAssignment : SelfAssignmentBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
[ObsoleteAttribute("This rule has been deprecated since 9.14")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SerializationConstructorsShouldBeSecured : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static AttributeComparer attributeComparer;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SerializationConstructorsShouldBeSecured();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void FindPossibleViolations(SonarSyntaxNodeReportingContext c);
    private static IEnumerable`1<AttributeData> GetCASAttributes(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static bool <GetCASAttributes>g__IsCASAttribute|9_0(AttributeData data);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SetLocaleForDataTypes : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> CheckedTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected bool EnableConcurrentExecution { get; }
    private static SetLocaleForDataTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool get_EnableConcurrentExecution();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ProcessObjectCreations(SonarSyntaxNodeReportingContext c, IDictionary`2<ISymbol, SyntaxNode> symbolsWhereTypeIsCreated);
    private static void ProcessSimpleAssignments(SonarSyntaxNodeReportingContext c, ISet`1<ISymbol> symbolsWhereLocaleIsSet);
    private static void ProcessCollectedSymbols(SonarCompilationReportingContext c, IDictionary`2<ISymbol, SyntaxNode> symbolsWhereTypeIsCreated, ISet`1<ISymbol> symbolsWhereLocaleIsSet);
    private static ISymbol GetSymbolFromConstructorInvocation(SyntaxNode constructorCall, SemanticModel semanticModel);
    private static SyntaxNode GetAssignmentTargetVariable(SyntaxNode objectCreation);
    private static ISymbol GetAccessedVariable(SyntaxNode node, SemanticModel model);
    private static ISymbol GetAssignmentTargetSymbol(SyntaxNode objectCreation, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SetPropertiesInsteadOfMethods : SetPropertiesInsteadOfMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool HasCorrectArgumentCount(InvocationExpressionSyntax invocation);
    protected virtual bool TryGetOperands(InvocationExpressionSyntax invocation, SyntaxNode& typeNode, SyntaxNode& methodNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ShiftDynamicNotInteger : ShiftDynamicNotIntegerBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool ShouldRaise(SemanticModel semanticModel, SyntaxNode left, SyntaxNode right);
    protected virtual bool CanBeConvertedTo(SyntaxNode expression, ITypeSymbol type, SemanticModel semanticModel);
    private static bool IsDynamic(SyntaxNode expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ShouldImplementExportedInterfaces : ShouldImplementExportedInterfacesBase`3<AttributeArgumentSyntax, AttributeSyntax, SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual Nullable`1<SeparatedSyntaxList`1<AttributeArgumentSyntax>> GetAttributeArguments(AttributeSyntax attributeSyntax);
    protected virtual SyntaxNode GetAttributeName(AttributeSyntax attributeSyntax);
    protected virtual bool IsClassOrRecordSyntax(SyntaxNode syntaxNode);
    protected virtual SyntaxNode GetTypeOfOrGetTypeExpression(SyntaxNode expressionSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SingleStatementPerLine : SingleStatementPerLineBase`2<SyntaxKind, StatementSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual bool StatementShouldBeExcluded(StatementSyntax statement);
    private static bool StatementIsSingleInLambda(StatementSyntax st);
    private static bool StatementIsBlock(StatementSyntax st);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SpecifyIFormatProviderOrCultureInfo : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> formatAndCultureType;
    private static ImmutableArray`1<KnownType> formattableTypes;
    private static ISet`1<MemberDescriptor> whitelistMethods;
    private static ISet`1<MemberDescriptor> blacklistMethods;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyIFormatProviderOrCultureInfo();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsIgnored(IMethodSymbol methodSymbol);
    private bool CanPotentiallyRaise(IMethodSymbol methodSymbol);
    private static bool ReturnsOrAcceptsFormattableType(IMethodSymbol methodSymbol);
    public static bool HasAnyFormatOrCultureParameter(ISymbol method);
    private static bool Matches(MemberDescriptor memberDescriptor, IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SpecifyRouteAttribute : SonarDiagnosticAnalyzer`1<SyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual string get_MessageFormat();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void ReportIssues(SonarSymbolReportingContext context, ISymbol symbol, ConcurrentStack`1<SecondaryLocation> secondaryLocations);
    private static bool UsesAttributeRouting(Compilation compilation);
    private static bool CanBeIgnored(string template);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarCompilationStartAnalysisContext compilationStart);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_1(SonarSymbolStartAnalysisContext symbolStart);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SpecifyStringComparison : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> stringComparisonType;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyStringComparison();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsInvalidCall(ExpressionSyntax expression, SemanticModel semanticModel);
    public static bool HasAnyStringComparisonParameter(IMethodSymbol method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SpecifyTimeoutOnRegex : SpecifyTimeoutOnRegexBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    internal SpecifyTimeoutOnRegex(IAnalyzerConfiguration config);
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SqlKeywordsDelimitedBySpace : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static IList`1<NameSyntax> SqlNamespaces;
    private static ISet`1<char> InvalidCharacters;
    private static IList`1<string> SqlStartQueryKeywords;
    private static int SqlKeywordMinSize;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SqlKeywordsDelimitedBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasSqlNamespace(SyntaxList`1<UsingDirectiveSyntax> usings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticFieldInGenericClass : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StaticFieldInGenericClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckMember(SonarSyntaxNodeReportingContext context, SyntaxNode root, Location location, String[] typeParameterNames);
    private static String[] CollectTypeParameterNames(SyntaxNode current);
    private static bool HasGenericType(SonarSyntaxNodeReportingContext context, SyntaxNode root, String[] typeParameterNames);
    private static bool BaseTypeHasGenericTypeArgument(TypeDeclarationSyntax typeDeclaration, String[] typeParameterNames);
    private static bool HasGenericTypeArgument(GenericNameSyntax genericType, String[] typeParameterNames);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticFieldInitializerOrder : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static SyntaxKind[] EnclosingTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StaticFieldInitializerOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.StaticFieldInitializerOrder/<IdentifierFields>d__8")]
private static IEnumerable`1<IFieldSymbol> IdentifierFields(VariableDeclaratorSyntax variable, INamedTypeSymbol containingType, SemanticModel semanticModel);
    private static TypeDeclarationSyntax GetTypeDeclaration(IFieldSymbol field);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticFieldVisible : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StaticFieldVisible();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<Diagnostic> GetDiagnostics(SemanticModel model, FieldDeclarationSyntax declaration);
    private static bool FieldIsRelevant(FieldDeclarationSyntax node);
    private static bool FieldIsThreadSafe(IFieldSymbol fieldSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticFieldWrittenFromInstanceConstructor : StaticFieldWrittenFrom {
    private static string DiagnosticId;
    private static string MessageFormat;
    protected DiagnosticDescriptor Rule { get; }
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual bool IsValidCodeBlockContext(SyntaxNode node, ISymbol owningSymbol);
    protected virtual string GetDiagnosticMessageArgument(SyntaxNode node, ISymbol owningSymbol, IFieldSymbol field);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticFieldWrittenFromInstanceMember : StaticFieldWrittenFrom {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatMultipleOptions;
    private static string MessageFormatRemoveSet;
    protected DiagnosticDescriptor Rule { get; }
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual bool IsValidCodeBlockContext(SyntaxNode node, ISymbol owningSymbol);
    protected virtual string GetDiagnosticMessageArgument(SyntaxNode node, ISymbol owningSymbol, IFieldSymbol field);
    private static string GetDeclarationType(SyntaxNode declaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StaticSealedClassProtectedMembers : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StaticSealedClassProtectedMembers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportDiagnostics(SonarSyntaxNodeReportingContext context, SyntaxNode declaration, IEnumerable`1<SyntaxToken> modifiers);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StreamReadStatement : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<string> ReadMethodNames;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StreamReadStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringConcatenationInLoop : StringConcatenationInLoopBase`3<SyntaxKind, AssignmentExpressionSyntax, BinaryExpressionSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <CompoundAssignmentKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <ExpressionConcatenationKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <LoopKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] CompoundAssignmentKinds { get; }
    protected ISet`1<SyntaxKind> ExpressionConcatenationKinds { get; }
    protected ISet`1<SyntaxKind> LoopKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_CompoundAssignmentKinds();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_ExpressionConcatenationKinds();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_LoopKinds();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringFormatValidator : SonarDiagnosticAnalyzer {
    private static string BugDiagnosticId;
    private static string CodeSmellDiagnosticId;
    private static string MessageFormat;
    private static int MaxValueForArgumentIndexAndAlignment;
    private static DiagnosticDescriptor BugRule;
    private static DiagnosticDescriptor CodeSmellRule;
    private static HashSet`1<MemberDescriptor> HandledFormatMethods;
    private static HashSet`1<ValidationFailure> BugRelatedFailures;
    private static HashSet`1<ValidationFailure> CodeSmellRelatedFailures;
    private static Regex StringFormatItemRegex;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringFormatValidator();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckForFormatStringIssues(SonarSyntaxNodeReportingContext analysisContext);
    private static bool CanIgnoreFailure(ValidationFailureWithAdditionalData failure, string methodName, int argumentsCount);
    private static ValidationFailureWithAdditionalData TryParseAndValidate(string formatStringText, ArgumentListSyntax argumentList, int formatArgumentIndex, SemanticModel semanticModel);
    private static ValidationFailureWithAdditionalData ExtractFormatItems(string formatString, List`1& formatStringItems);
    private static ValidationFailure TryParseItem(string formatItem, FormatStringItem& formatStringItem);
    private static ValidationFailureWithAdditionalData TryValidateFormatString(ICollection`1<FormatStringItem> formatStringItems, ArgumentListSyntax argumentList, int formatArgumentIndex, SemanticModel semanticModel);
    private static ValidationFailureWithAdditionalData HasFormatItemIndexTooBig(Nullable`1<int> maxFormatItemIndex, int argumentsCount);
    private static ValidationFailureWithAdditionalData IsSimpleString(int formatStringItemsCount, int argumentsCount);
    private static ValidationFailureWithAdditionalData HasMissingFormatItemIndex(IEnumerable`1<FormatStringItem> formatStringItems, Nullable`1<int> maxFormatItemIndex);
    private static ValidationFailureWithAdditionalData HasUnusedArguments(List`1<FormatStringArgument> formatArguments, Nullable`1<int> maxFormatItemIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringLiteralShouldNotBeDuplicated : StringLiteralShouldNotBeDuplicatedBase`2<SyntaxKind, LiteralExpressionSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <TypeDeclarationSyntaxKinds>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    private SyntaxKind[] TypeDeclarationSyntaxKinds { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    [CompilerGeneratedAttribute]
private SyntaxKind[] get_TypeDeclarationSyntaxKinds();
    protected virtual bool IsMatchingMethodParameterName(LiteralExpressionSyntax literalExpression);
    protected virtual bool IsInnerInstance(SonarSyntaxNodeReportingContext context);
    protected virtual IEnumerable`1<LiteralExpressionSyntax> FindLiteralExpressions(SyntaxNode node);
    protected virtual SyntaxToken LiteralToken(LiteralExpressionSyntax literal);
    protected virtual bool IsNamedTypeOrTopLevelMain(SonarSyntaxNodeReportingContext context);
    [CompilerGeneratedAttribute]
private bool <IsInnerInstance>b__9_0(SyntaxNode x);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringOffsetMethods : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    private String[] methodsToCheck;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringOffsetMethods();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsTargetMethodInvocation(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel);
    private bool HasSubstringMethodInvocationChild(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext analysisContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringOperationWithoutCulture : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static string MessageDefineLocale;
    internal static string MessageChangeCompareTo;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> CommonCultureSpecificMethodNames;
    private static ISet`1<string> IndexLookupMethodNames;
    private static string CompareToMethodName;
    private static string ToStringMethodName;
    private static ImmutableArray`1<KnownType> StringCultureSpecifierNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringOperationWithoutCulture();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportOnViolation(SonarSyntaxNodeReportingContext context);
    private static bool IsMethodOnNonIntegralOrDateTime(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.StringOrIntegralTypesForIndexers : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> AllowedIndexerTypes;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringOrIntegralTypesForIndexers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsGenericTypeParameter(IParameterSymbol parameterSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SuppressFinalizeUseless : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SuppressFinalizeUseless();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SuppressFinalizeUselessCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwaggerActionReturnType : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string NoAttributeMessageFormat;
    private static string NoTypeMessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> ControllerActionReturnTypes;
    private static ImmutableArray`1<KnownType> ProducesAttributes;
    private static HashSet`1<string> ActionResultMethods { get; }
    private static HashSet`1<string> ResultMethods { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwaggerActionReturnType();
    private static HashSet`1<string> get_ActionResultMethods();
    private static HashSet`1<string> get_ResultMethods();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static InvalidMethodResult InvalidMethod(BaseMethodDeclarationSyntax methodDeclaration, SonarSyntaxNodeReportingContext nodeContext);
    private static SyntaxNode[] FindSuccessResponses(SyntaxNode node, SemanticModel model);
    private static bool IsControllerCandidate(ISymbol symbol);
    private static string GetMessage(ISymbol symbol);
    private static bool HasProducesAttributesWithReturnType(AttributeData attribute);
    private static bool HasApiExplorerSettingsWithIgnoreApiTrue(AttributeData attribute);
    private static bool ContainsReturnType(AttributeData attribute);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchCaseFallsThroughToDefault : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwitchCaseFallsThroughToDefault();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchCaseFallsThroughToDefaultCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchCasesMinimumThree : SwitchCasesMinimumThreeBase {
    private static string SwitchStatementMessage;
    private static string TwoReturnValueSwitchExpressionMessage;
    private static string SingleReturnValueSwitchExpressionMessage;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwitchCasesMinimumThree();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAtLeastThreeLabels(SwitchStatementSyntax node);
    private static SwitchExpressionType EvaluateType(SwitchExpressionSyntaxWrapper switchExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchDefaultClauseEmpty : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwitchDefaultClauseEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAnyComment(SwitchSectionSyntax section);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchDefaultClauseEmptyCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchSectionShouldNotHaveTooManyStatements : SwitchSectionShouldNotHaveTooManyStatementsBase {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwitchSectionShouldNotHaveTooManyStatements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private IEnumerable`1<StatementSyntax> GetSubStatements(StatementSyntax statement);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchShouldNotBeNested : SwitchShouldNotBeNestedBase {
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SwitchShouldNotBeNested();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SwitchWithoutDefault : SwitchWithoutDefaultBase`1<SyntaxKind> {
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<SyntaxKind> kindsOfInterest;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static SwitchWithoutDefault();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual bool TryGetDiagnostic(SyntaxNode node, Diagnostic& diagnostic);
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SymbolicExecutionRunner : SymbolicExecutionRunnerBase {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<DiagnosticDescriptor, RuleFactory> <AllRules>k__BackingField;
    protected ImmutableDictionary`2<DiagnosticDescriptor, RuleFactory> AllRules { get; }
    protected SyntaxClassifierBase SyntaxClassifier { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal SymbolicExecutionRunner(IAnalyzerConfiguration configuration);
    [CompilerGeneratedAttribute]
protected virtual ImmutableDictionary`2<DiagnosticDescriptor, RuleFactory> get_AllRules();
    protected virtual SyntaxClassifierBase get_SyntaxClassifier();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual ControlFlowGraph CreateCfg(SemanticModel model, SyntaxNode node, CancellationToken cancel);
    protected virtual void AnalyzeSonar(SonarSyntaxNodeReportingContext context, ISymbol symbol);
    private static void ReportDiagnosticsSonar(SonarSyntaxNodeReportingContext context, IEnumerable`1<ISymbolicExecutionAnalysisContext> analyzerContexts, bool supportsPartialResults);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.SymbolReferenceAnalyzer : SymbolReferenceAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode GetBindableParent(SyntaxToken token);
    protected virtual ReferenceInfo[] CreateDeclarationReferenceInfo(SyntaxNode node, SemanticModel model);
    protected virtual IList`1<SyntaxNode> GetDeclarations(SyntaxNode node);
    private static ReferenceInfo[] CreateDeclarationReferenceInfo(VariableDeclarationSyntax declaration, SemanticModel model);
    private static ReferenceInfo<SyntaxKind> CreateDeclarationReferenceInfo(SyntaxNode node, SyntaxToken identifier, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TabCharacter : TabCharacterBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static TabCharacter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TaskConfigureAwait : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TaskConfigureAwait();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TestClassShouldHaveTestMethod : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableArray`1<KnownType> HandledSetupAndCleanUpAttributes;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestClassShouldHaveTestMethod();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAnyTestMethod(INamespaceOrTypeSymbol symbol);
    private static bool IsViolatingRule(INamedTypeSymbol symbol);
    private static bool IsExceptionToTheRule(ITypeSymbol symbol);
    private static bool HasSetupOrCleanupAttributes(INamespaceOrTypeSymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TestMethodShouldContainAssertion : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string CustomAssertionAttributeName;
    private static int MaxInvocationDepth;
    private static Dictionary`2<string, KnownType[]> KnownAssertions;
    private static ImmutableArray`1<KnownType> KnownAssertionTypes;
    private static ImmutableArray`1<KnownType> KnownAssertionExceptionTypes;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestMethodShouldContainAssertion();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsTestMethod(IMethodSymbol symbol, bool isLocalFunction);
    private static bool IsXunitTestMethod(IMethodSymbol methodSymbol);
    private static bool ContainsAssertion(SyntaxNode methodDeclaration, SemanticModel model, ISet`1<IMethodSymbol> visitedSymbols, int level);
    private static bool IsTestIgnored(IMethodSymbol method);
    private static bool IsAssertion(InvocationExpressionSyntax invocation);
    private static bool IsKnownAssertion(ISymbol methodSymbol);
    private static bool IsCustomAssertion(ISymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TestMethodShouldHaveCorrectSignature : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MakePublicMessage;
    private static string MakeNonAsyncOrTaskMessage;
    private static string MakeNotGenericMessage;
    private static string MakeMethodNotLocalFunction;
    private static SignatureValidator NullValidator;
    private static Dictionary`2<KnownType, SignatureValidator> AttributeToConstraintsMap;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestMethodShouldHaveCorrectSignature();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeMethod(SonarSyntaxNodeReportingContext c);
    private static bool HasAttributes(SyntaxNode node);
    private static SignatureValidator GetValidator(IMethodSymbol method);
    private static string GetFaultMessage(SyntaxNode methodNode, IMethodSymbol methodSymbol, bool publicOnly, bool allowGenerics, bool allowAsyncVoid);
    private static string GetFaultMessage(IMethodSymbol methodSymbol, bool publicOnly, bool allowGenerics, bool allowAsyncVoid);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.TestMethodShouldHaveCorrectSignature/<GetFaultMessageParts>d__19")]
private static IEnumerable`1<string> GetFaultMessageParts(IMethodSymbol methodSymbol, bool publicOnly, bool allowGenerics, bool allowAsyncVoid);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TestMethodShouldNotBeIgnored : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> TrackedTestIdentifierAttributes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestMethodShouldNotBeIgnored();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<AttributeData> GetAllAttributes(SyntaxNode syntaxNode, SemanticModel semanticModel);
    private static bool HasReasonPhrase(AttributeSyntax ignoreAttributeSyntax);
    private static bool HasTrailingComment(SyntaxNode ignoreAttributeSyntax);
    private static bool IsWorkItemAttribute(AttributeData a);
    private static bool IsKnownIgnoreAttribute(AttributeSyntax attributeSyntax, SemanticModel semanticModel);
    private static bool IsTestOrTestClassAttribute(AttributeData a);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TestsShouldNotUseThreadSleep : TestsShouldNotUseThreadSleepBase`2<MethodDeclarationSyntax, SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode MethodDeclaration(MethodDeclarationSyntax method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThisShouldNotBeExposedFromConstructors : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ThisShouldNotBeExposedFromConstructors();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsClassMember(ExpressionSyntax expression);
    private static bool IsThisExpression(ExpressionSyntax expression);
    private static bool IsInstanceConstructor(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarCodeBlockStartAnalysisContext`1<SyntaxKind> cbc);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
internal static bool <IsInstanceConstructor>g__IsStaticKeyword|9_0(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThreadResumeOrSuspendShouldNotBeCalled : ThreadResumeOrSuspendShouldNotBeCalledBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThreadStaticNonStaticField : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ThreadStaticNonStaticField();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThreadStaticNonStaticFieldCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThreadStaticWithInitializer : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ThreadStaticWithInitializer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasThreadStaticAttribute(SyntaxList`1<AttributeListSyntax> attributeLists, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ThrowReservedExceptions : ThrowReservedExceptionsBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TokenTypeAnalyzer : TokenTypeAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ILanguageFacade`1<SyntaxKind> <Language>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    [CompilerGeneratedAttribute]
protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual TokenClassifierBase<SyntaxKind> GetTokenClassifier(SemanticModel semanticModel, bool skipIdentifierTokens);
    protected virtual TriviaClassifierBase<SyntaxKind> GetTriviaClassifier();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TooManyGenericParameters : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int DefaultMaxNumberOfGenericParametersInClass;
    private static int DefaultMaxNumberOfGenericParametersInMethod;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfGenericParametersInClass>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfGenericParametersInMethod>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("max", "3", "Maximum authorized number of generic parameters.", "2")]
public int MaxNumberOfGenericParametersInClass { get; public set; }
    [RuleParameterAttribute("maxMethod", "3", "Maximum authorized number of generic parameters for methods.", "3")]
public int MaxNumberOfGenericParametersInMethod { get; public set; }
    private static TooManyGenericParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfGenericParametersInClass();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfGenericParametersInClass(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfGenericParametersInMethod();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfGenericParametersInMethod(int value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private static string EnclosingTypeName(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__16_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__16_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TooManyLabelsInSwitch : TooManyLabelsInSwitchBase`2<SyntaxKind, SwitchStatementSyntax> {
    private static ISet`1<SyntaxKind> IgnoredStatementsInSwitch;
    private static ISet`1<SyntaxKind> TransparentSyntax;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected DiagnosticDescriptor Rule { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static TooManyLabelsInSwitch();
    [CompilerGeneratedAttribute]
protected virtual DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual SyntaxNode GetExpression(SwitchStatementSyntax statement);
    protected virtual int GetSectionsCount(SwitchStatementSyntax statement);
    protected virtual bool AllSectionsAreOneLiners(SwitchStatementSyntax statement);
    protected virtual Location GetKeywordLocation(SwitchStatementSyntax statement);
    private static bool HasOneLine(SwitchSectionSyntax switchSection);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TooManyLoggingCalls : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    public static DiagnosticDescriptor Rule;
    private static KnownAssembly[] SupportedLoggingLibraries;
    private static ImmutableArray`1<KnownType> LoggerTypes;
    private static ImmutableArray`1<LoggingCategory> LoggingCategories;
    [CompilerGeneratedAttribute]
private int <DebugThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InformationThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningThreshold>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("debugThreshold", "3", "The maximum number of DEBUG, TRACE and VERBOSE statements allowed in the same code block.", "4")]
public int DebugThreshold { get; public set; }
    [RuleParameterAttribute("errorThreshold", "3", "The maximum number of ERROR and FATAL statements allowed in the same code block.", "1")]
public int ErrorThreshold { get; public set; }
    [RuleParameterAttribute("informationThreshold", "3", "The maximum number of INFORMATION statements allowed in the same code block.", "2")]
public int InformationThreshold { get; public set; }
    [RuleParameterAttribute("warningThreshold", "3", "The maximum number of WARNING statements allowed in the same code block.", "1")]
public int WarningThreshold { get; public set; }
    private static TooManyLoggingCalls();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_DebugThreshold();
    [CompilerGeneratedAttribute]
public void set_DebugThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorThreshold();
    [CompilerGeneratedAttribute]
public void set_ErrorThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_InformationThreshold();
    [CompilerGeneratedAttribute]
public void set_InformationThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_WarningThreshold();
    [CompilerGeneratedAttribute]
public void set_WarningThreshold(int value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private void Process(SonarSyntaxNodeReportingContext context);
    private int Threshold(string category);
    private static bool IsBlockNodeSupported(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__26_0(SonarCompilationStartAnalysisContext cc);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TooManyParameters : TooManyParametersBase`2<SyntaxKind, ParameterListSyntax> {
    private static ImmutableDictionary`2<SyntaxKind, string> NodeToDeclarationName;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static TooManyParameters();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string UserFriendlyNameForNode(SyntaxNode node);
    protected virtual int CountParameters(ParameterListSyntax parameterList);
    protected virtual bool CanBeChanged(SyntaxNode node, SemanticModel semanticModel);
    protected virtual int BaseParameterCount(SyntaxNode node);
    protected virtual bool IsExtern(SyntaxNode node);
    private static int RetrieveBasePrimaryConstructorArguments(ClassDeclarationSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ToStringShouldNotReturnNull : ToStringShouldNotReturnNullBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected SyntaxKind MethodKind { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxKind get_MethodKind();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual IEnumerable`1<SyntaxNode> Conditionals(SyntaxNode expression);
    protected virtual bool IsLocalOrLambda(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TrackNotImplementedException : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TrackNotImplementedException();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void ReportDiagnostic(SonarSyntaxNodeReportingContext c, ExpressionSyntax newExceptionExpression, SyntaxNode throwExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TryStatementsWithIdenticalCatchShouldBeMerged : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TryStatementsWithIdenticalCatchShouldBeMerged();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TypeExaminationOnSystemType : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageGetType;
    private static string MessageIsInstanceOfType;
    private static string MessageIsInstanceOfTypeWithGetType;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypeExaminationOnSystemType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckIsInstanceOfTypeCallWithTypeArgument(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, ISymbol methodSymbol);
    private static void CheckGetTypeCallOnType(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, IMethodSymbol invokedMethod);
    private static bool IsException(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TypeMemberVisibility : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static SyntaxKind[] TypeKinds;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypeMemberVisibility();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SecondaryLocation[] GetInvalidMemberLocations(SemanticModel semanticModel, BaseTypeDeclarationSyntax type);
    private static bool IsInterfaceImplementation(SemanticModel semanticModel, MemberDeclarationSyntax declaration);
    private static BaseTypeDeclarationSyntax GetParentType(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TypeNamesShouldNotMatchNamespaces : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ISet`1<string> FrameworkNamespaces;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypeNamesShouldNotMatchNamespaces();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.TypesShouldNotExtendOutdatedBaseTypes : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<KnownType> OutdatedTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypesShouldNotExtendOutdatedBaseTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnaryPrefixOperatorRepeated : UnaryPrefixOperatorRepeatedBase`2<SyntaxKind, PrefixUnaryExpressionSyntax> {
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <SyntaxKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedCodeRecognizer <GeneratedCodeRecognizer>k__BackingField;
    protected DiagnosticDescriptor Rule { get; }
    protected ISet`1<SyntaxKind> SyntaxKinds { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    [CompilerGeneratedAttribute]
protected virtual DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_SyntaxKinds();
    [CompilerGeneratedAttribute]
protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual SyntaxNode GetOperand(PrefixUnaryExpressionSyntax unarySyntax);
    protected virtual SyntaxToken GetOperatorToken(PrefixUnaryExpressionSyntax unarySyntax);
    protected virtual bool SameOperators(PrefixUnaryExpressionSyntax expression1, PrefixUnaryExpressionSyntax expression2);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnaryPrefixOperatorRepeatedCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static void GetExpression(PrefixUnaryExpressionSyntax prefix, ExpressionSyntax& expression, UInt32& count);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnchangedLocalVariablesShouldBeConst : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageFormatVarHint;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnchangedLocalVariablesShouldBeConst();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static DeclarationType FindDeclarationType(LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel);
    private static bool IsInitializedWithCompatibleConstant(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel, DeclarationType declarationType);
    private static bool HasMutableUsagesInMethod(SemanticModel semanticModel, VariableDeclaratorSyntax variable);
    private static bool IsMutatingUse(SemanticModel semanticModel, IdentifierNameSyntax identifier);
    private static bool IsUsedAsLambdaExpression(SemanticModel semanticModel, IdentifierNameSyntax identifier);
    private static bool ContainsInterpolation(VariableDeclaratorSyntax declaratorSyntax);
    private static void Report(SonarSyntaxNodeReportingContext c, VariableDeclaratorSyntax declaratorSyntax);
    private static string AddionalMessageHints(SemanticModel semanticModel, VariableDeclaratorSyntax declaratorSyntax);
    [CompilerGeneratedAttribute]
internal static bool <HasMutableUsagesInMethod>g__IsMethodLike|11_2(SyntaxNode arg);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnchangedLocalVariablesShouldBeConstCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    [AsyncStateMachineAttribute("SonarAnalyzer.Rules.CSharp.UnchangedLocalVariablesShouldBeConstCodeFix/<ChangeDocument>d__4")]
public static Task`1<Document> ChangeDocument(Document document, SyntaxNode root, VariableDeclarationSyntax variable, LocalDeclarationStatementSyntax oldNode, CancellationToken cancel);
    private static VariableDeclarationSyntax VariableDeclaration(SyntaxNode root, SonarCodeFixContext context);
    private static LocalDeclarationStatementSyntax ConstantDeclaration(VariableDeclarationSyntax declaration);
    private static VariableDeclarationSyntax WithExplictType(VariableDeclarationSyntax declaration, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnconditionalJumpStatement : UnconditionalJumpStatementBase`2<StatementSyntax, SyntaxKind> {
    [CompilerGeneratedAttribute]
private ISet`1<SyntaxKind> <LoopStatements>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected ISet`1<SyntaxKind> LoopStatements { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<SyntaxKind> get_LoopStatements();
    protected virtual LoopWalkerBase`2<StatementSyntax, SyntaxKind> GetWalker(SonarSyntaxNodeReportingContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UninvokedEventDeclaration : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static Accessibility MaxAccessibility;
    private static DiagnosticDescriptor Rule;
    private static ISet`1<SyntaxKind> EventSyntax;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UninvokedEventDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void RaiseOnUninvokedEventDeclaration(SonarSymbolReportingContext context);
    private static IEnumerable`1<ISymbol> GetInvokedEventSymbols(CSharpRemovableDeclarationCollector removableDeclarationCollector);
    private static IEnumerable`1<ISymbol> GetPossiblyCopiedSymbols(CSharpRemovableDeclarationCollector removableDeclarationCollector);
    private static ExpressionSyntax GetEventExpressionFromInvocation(InvocationExpressionSyntax invocation, IMethodSymbol symbol);
    private static bool IsExplicitDelegateInvocation(IMethodSymbol symbol, SimpleNameSyntax invokedMethodName);
    private static bool IsDelegateInvocation(IMethodSymbol symbol);
    private static bool IsInvoke(IMethodSymbol symbol);
    private static bool IsDynamicInvoke(IMethodSymbol symbol);
    private static bool IsBeginInvoke(IMethodSymbol symbol);
    [CompilerGeneratedAttribute]
internal static Location <RaiseOnUninvokedEventDeclaration>g__GetLocation|9_0(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnnecessaryBitwiseOperation : UnnecessaryBitwiseOperationBase {
    protected ILanguageFacade Language { get; }
    protected virtual ILanguageFacade get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckAssignment(SonarSyntaxNodeReportingContext context, int constValueToLookFor);
    private void CheckBinary(SonarSyntaxNodeReportingContext context, int constValueToLookFor);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_3(SonarSyntaxNodeReportingContext c);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnnecessaryBitwiseOperationCodeFix : UnnecessaryBitwiseOperationCodeFixBase {
    protected virtual Func`1<SyntaxNode> CreateNewRoot(SyntaxNode root, TextSpan diagnosticSpan, bool isReportingOnLeft);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnnecessaryMathematicalComparison : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MathComparisonMessage;
    private static DiagnosticDescriptor MathComparisonRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnnecessaryMathematicalComparison();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void CheckComparisonOutOfRange(SonarSyntaxNodeReportingContext context);
    private static bool TryGetConstantValue(SemanticModel model, BinaryExpressionSyntax binary, Double& constant, SyntaxNode& other);
    private static bool TryConvertToDouble(object constant, Double& typedConstant);
    private static Nullable`1<ValuesRange> TryGetRange(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnnecessaryUsings : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static HashSet`1<string> IgnoredRazorFiles;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnnecessaryUsings();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VisitContent(ISafeSyntaxWalker visitor, SyntaxList`1<MemberDeclarationSyntax> members, IEnumerable`1<SyntaxTrivia> trivias);
    private static void CheckUnnecessaryUsings(SonarSyntaxNodeReportingContext context, IEnumerable`1<UsingDirectiveSyntax> usingDirectives, ISet`1<INamespaceSymbol> necessaryNamespaces);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnnecessaryUsingsCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnsafeCodeBlocks : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public UnsafeCodeBlocks(IAnalyzerConfiguration configuration);
    private static UnsafeCodeBlocks();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void ReportIfUnsafe(SonarSyntaxNodeReportingContext context, SyntaxTokenList modifiers);
    private void Report(SonarSyntaxNodeReportingContext context, SyntaxToken token);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_2(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_3(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_4(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_5(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_6(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnusedPrivateMember : SonarDiagnosticAnalyzer {
    internal static string S1144DiagnosticId;
    private static string S1144MessageFormat;
    private static string S1144MessageFormatForPublicCtor;
    private static string S4487DiagnosticId;
    private static string S4487MessageFormat;
    private static DiagnosticDescriptor RuleS1144;
    private static DiagnosticDescriptor RuleS1144ForPublicCtor;
    private static DiagnosticDescriptor RuleS4487;
    private static ImmutableArray`1<KnownType> IgnoredTypes;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected bool EnableConcurrentExecution { get; }
    private static UnusedPrivateMember();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool get_EnableConcurrentExecution();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void NamedSymbolAction(SonarSymbolReportingContext context, HashSet`1<ISymbol> removableInternalTypes);
    private static IEnumerable`1<ISymbol> AssociatedSymbols(IEnumerable`1<ISymbol> privateSymbols);
    private static bool GatherSymbols(INamedTypeSymbol namedType, Compilation compilation, HashSet`1<ISymbol> privateSymbols, HashSet`1<ISymbol> internalSymbols, BidirectionalDictionary`2<ISymbol, SyntaxNode> fieldLikeSymbols, SonarSymbolReportingContext context);
    private static void ReportUnusedPrivateMembers(SonarCompilationReportingContextBase`1<TContext> context, CSharpSymbolUsageCollector usageCollector, ISet`1<ISymbol> removableSymbols, string accessibility, BidirectionalDictionary`2<ISymbol, SyntaxNode> fieldLikeSymbols);
    private static bool IsUsedWithReflection(ISymbol symbol, HashSet`1<ISymbol> symbolsUsedWithReflection);
    private static bool IsMentionedInDebuggerDisplay(ISymbol symbol, CSharpSymbolUsageCollector usageCollector);
    private static void ReportUsedButUnreadFields(SonarSymbolReportingContext context, CSharpSymbolUsageCollector usageCollector, IEnumerable`1<ISymbol> removableSymbols);
    private static HashSet`1<ISymbol> GetUnusedSymbols(CSharpSymbolUsageCollector usageCollector, IEnumerable`1<ISymbol> removableSymbols);
    private static bool IsDeconstructMethod(ISymbol symbol);
    private static bool IsAccessorUsed(ISymbol symbol, CSharpSymbolUsageCollector usageCollector);
    private static string GetFieldAccessibilityForMessage(ISymbol symbol);
    private static void ReportDiagnosticsForMembers(SonarCompilationReportingContextBase`1<TContext> context, ICollection`1<ISymbol> unusedSymbols, string accessibility, BidirectionalDictionary`2<ISymbol, SyntaxNode> fieldLikeSymbols);
    private static void ReportProperty(SonarCompilationReportingContextBase`1<TContext> context, IPropertySymbol property, IReadOnlyDictionary`2<IPropertySymbol, AccessorAccess> propertyAccessorAccess);
    private static string GetMemberName(ISymbol symbol);
    private static bool VisitDeclaringReferences(ISymbol symbol, ISafeSyntaxWalker visitor, SonarSymbolReportingContext context, bool includeGeneratedFile);
    private static CSharpRemovableSymbolWalker RetrieveRemovableSymbols(INamedTypeSymbol namedType, Compilation compilation, SonarSymbolReportingContext context);
    private static void CopyRetrievedSymbols(CSharpRemovableSymbolWalker removableSymbolCollector, HashSet`1<ISymbol> privateSymbols, HashSet`1<ISymbol> internalSymbols, BidirectionalDictionary`2<ISymbol, SyntaxNode> fieldLikeSymbols);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<BaseTypeDeclarationSyntax> <GatherSymbols>g__PrivateNestedMembersFromNonGeneratedCode|17_0(INamedTypeSymbol namedType, SonarSymbolReportingContext context);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<VariableDeclaratorSyntax> <ReportDiagnosticsForMembers>g__GetSiblingDeclarators|26_1(SyntaxNode variableDeclarator);
    [CompilerGeneratedAttribute]
internal static Location <ReportDiagnosticsForMembers>g__GetIdentifierLocation|26_2(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static AccessorDeclarationSyntax <ReportProperty>g__GetAccessorSyntax|27_0(ISymbol symbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnusedPrivateMemberCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected sealed virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnusedReturnValue : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnusedReturnValue();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeNamedTypes(SonarSymbolReportingContext context);
    private static void AnalyzeLocalFunctionStatements(SonarSyntaxNodeReportingContext context);
    private static bool IsReturnValueUsed(NodeSymbolAndModel`2<InvocationExpressionSyntax, IMethodSymbol> matchingInvocation);
    private static bool IsActionLambda(SyntaxNode node, SemanticModel semanticModel);
    private static bool IsExpressionStatement(SyntaxNode node);
    private static IEnumerable`1<NodeSymbolAndModel`2<InvocationExpressionSyntax, IMethodSymbol>> GetLocalMatchingInvocations(SyntaxNode containingMethod, IMethodSymbol invocationSymbol, SemanticModel semanticModel);
    private static IEnumerable`1<NodeSymbolAndModel`2<InvocationExpressionSyntax, IMethodSymbol>> FilterInvocations(NodeAndModel`1<BaseTypeDeclarationSyntax> container);
    private static IEnumerable`1<NodeSymbolAndModel`2<MethodDeclarationSyntax, IMethodSymbol>> CollectRemovableMethods(CSharpRemovableDeclarationCollector removableDeclarationCollector);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UnusedStringBuilder : UnusedStringBuilderBase`3<SyntaxKind, VariableDeclaratorSyntax, IdentifierNameSyntax> {
    private static SyntaxKind[] SkipChildren;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static UnusedStringBuilder();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SyntaxNode GetScope(VariableDeclaratorSyntax declarator);
    protected virtual ILocalSymbol RetrieveStringBuilderObject(SemanticModel semanticModel, VariableDeclaratorSyntax declarator);
    protected virtual bool IsStringBuilderRead(SemanticModel model, ILocalSymbol symbol, SyntaxNode node);
    protected virtual bool DescendIntoChildren(SyntaxNode node);
    private static bool IsStringBuilderObjectCreation(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UriShouldNotBeHardcoded : UriShouldNotBeHardcodedBase`3<SyntaxKind, LiteralExpressionSyntax, ArgumentSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected SyntaxKind[] StringConcatenateExpressions { get; }
    protected SyntaxKind[] InvocationOrObjectCreationKind { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual SyntaxKind[] get_StringConcatenateExpressions();
    protected virtual SyntaxKind[] get_InvocationOrObjectCreationKind();
    protected virtual SyntaxNode GetRelevantAncestor(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseAspNetModelBinding : SonarDiagnosticAnalyzer`1<SyntaxKind> {
    private static string DiagnosticId;
    private static string UseAspNetModelBindingMessage;
    private static string UseIFormFileBindingMessage;
    private static KnownType[] ActionFilterTypes;
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    private static UseAspNetModelBinding();
    protected virtual string get_MessageFormat();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void RegisterForSymbols(SonarCompilationStartAnalysisContext compilationStartContext, Descriptors descriptors);
    private void RegisterCodeBlockActions(SonarCodeBlockStartAnalysisContext`1<SyntaxKind> codeBlockStart, Descriptors descriptors, ConcurrentStack`1<ReportCandidate> controllerCandidates);
    private bool AddMatchingArgumentToCandidates(SemanticModel model, ConcurrentStack`1<ReportCandidate> codeBlockCandidates, ArgumentSyntax argument, ArgumentDescriptor[] argumentDescriptors);
    private static Descriptors GetDescriptors(Compilation compilation);
    private static void AddAspNetCoreDescriptors(List`1<ArgumentDescriptor> argumentDescriptors, List`1<MemberDescriptor> propertyAccessDescriptors);
    private static bool IsAccessedViaHeaderDictionary(SemanticModel model, ILanguageFacade language, SyntaxNode invocation);
    private static bool IsOverridingFilterMethods(ISymbol owningSymbol);
    private static bool IsOriginatingFromParameter(SemanticModel semanticModel, ArgumentSyntax argument);
    private static bool IsOriginatingFromParameter(SemanticModel semanticModel, ExpressionSyntax expression);
    private static ExpressionSyntax GetLeftOfDot(ExpressionSyntax expression);
    private static ExpressionSyntax MostLeftOfDottedChain(ExpressionSyntax root);
    private static ExpressionSyntax GetExpressionOfArgumentParent(ArgumentSyntax argument);
    private static Location GetPrimaryLocation(ArgumentSyntax argument);
    private static bool IsGetterParameter(IParameterSymbol parameter);
    private static bool IsIDictionaryStringStringValuesInvocation(IMethodSymbol method, string name);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarCompilationStartAnalysisContext compilationStartContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseAwaitableMethod : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static String[] ExcludedMethodNames;
    private static ImmutableArray`1<KnownType> ExcludedTypes;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseAwaitableMethod();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static MultiValueDictionary`2<ITypeSymbol, INamedTypeSymbol> BuildWellKnownExtensionMethodContainers(Compilation compilation);
    private static ImmutableArray`1<Func`2<IMethodSymbol, bool>> BuildExclusions(Compilation compilation);
    private static ImmutableArray`1<ISymbol> FindAwaitableAlternatives(MultiValueDictionary`2<ITypeSymbol, INamedTypeSymbol> wellKnownExtensionMethodContainer, ImmutableArray`1<Func`2<IMethodSymbol, bool>> exclusions, InvocationExpressionSyntax invocationExpression, SemanticModel model, ISymbol containingSymbol, CancellationToken cancel);
    private static IEnumerable`1<IMethodSymbol> GetMethodSymbolsInScope(string methodName, MultiValueDictionary`2<ITypeSymbol, INamedTypeSymbol> wellKnownExtensionMethodContainer, ITypeSymbol invokedType, ITypeSymbol methodContainer);
    private static IEnumerable`1<INamedTypeSymbol> WellKnownExtensionMethodContainer(MultiValueDictionary`2<ITypeSymbol, INamedTypeSymbol> lookup, ITypeSymbol invokedType);
    private static IEnumerable`1<ISymbol> SpeculativeBindCandidates(SemanticModel model, SyntaxNode awaitableRoot, InvocationExpressionSyntax invocationExpression, IEnumerable`1<IMethodSymbol> awaitableCandidates);
    private static IMethodSymbol SpeculativeBindCandidate(SemanticModel model, string candidateName, SyntaxNode awaitableRoot, InvocationExpressionSyntax invocationExpression);
    private static SyntaxNode ReplaceInvocation(SyntaxNode awaitableRoot, InvocationExpressionSyntax invocationExpression, SyntaxNode invocationIdentifierName, string candidateName);
    private static ExpressionSyntax GetAwaitableRootOfInvocation(ExpressionSyntax expression);
    private static bool IsAsyncCodeBlock(SyntaxNode codeBlock);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseCharOverloadOfStringMethods : UseCharOverloadOfStringMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool HasCorrectArguments(InvocationExpressionSyntax invocation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseCharOverloadOfStringMethodsCodeFix : SonarCodeFix {
    private static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    private static LiteralExpressionSyntax Convert(LiteralExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseConstantLoggingTemplate : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string OnUsingStringInterpolation;
    private static string OnUsingStringFormat;
    private static string OnUsingStringConcatenation;
    private static DiagnosticDescriptor Rule;
    private static ImmutableDictionary`2<SyntaxKind, string> Messages;
    private static ImmutableArray`1<KnownType> LoggerTypes;
    private static ImmutableHashSet`1<string> LoggerMethodNames;
    private static ImmutableHashSet`1<string> LogMessageParameterNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseConstantLoggingTemplate();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static CSharpSyntaxNode ArgumentValue(InvocationExpressionSyntax invocation, IMethodSymbol method, IParameterSymbol parameter);
    private static SyntaxNode InvalidSyntaxNode(SyntaxNode messageArgument, SemanticModel model);
    private static bool AllMembersAreConstantStrings(BinaryExpressionSyntax addExpression, SemanticModel model);
    private static bool IsConstantStringOrConcatenation(SyntaxNode node, SemanticModel model);
    private static bool IsStringFormatInvocation(SyntaxNode node, SemanticModel model);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseConstantsWhereAppropriate : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> RelevantTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseConstantsWhereAppropriate();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsFieldRelevant(IFieldSymbol fieldSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseCurlyBraces : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableList`1<CheckedKind> CheckedKinds;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseCurlyBraces();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseDateTimeOffsetInsteadOfDateTime : UseDateTimeOffsetInsteadOfDateTimeBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private String[] <ValidNames>k__BackingField;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected String[] ValidNames { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected virtual String[] get_ValidNames();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseFindSystemTimeZoneById : UseFindSystemTimeZoneByIdBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseGenericEventHandlerInstances : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableArray`1<KnownType> allowedTypes;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseGenericEventHandlerInstances();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void AnalyzeEventType(SonarSyntaxNodeReportingContext analysisContext, SyntaxNode eventNode, Func`1<Location> getLocationToReportOn);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseGenericWithRefParameters : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseGenericWithRefParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsRefObject(IParameterSymbol parameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseIFormatProviderForParsingDateAndTime : UseIFormatProviderForParsingDateAndTimeBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseIndexingInsteadOfLinqMethods : UseIndexingInsteadOfLinqMethodsBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual int GetArgumentCount(InvocationExpressionSyntax invocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseLambdaParameterInConcurrentDictionary : UseLambdaParameterInConcurrentDictionaryBase`3<SyntaxKind, InvocationExpressionSyntax, ArgumentSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual SeparatedSyntaxList`1<ArgumentSyntax> GetArguments(InvocationExpressionSyntax invocation);
    protected virtual bool IsLambdaAndContainsIdentifier(ArgumentSyntax argument, string keyName);
    protected virtual bool TryGetKeyName(ArgumentSyntax argument, String& keyName);
    private bool IsContainingValidIdentifier(SyntaxNode node, string keyName);
    private bool IsContainedInNameOfInvocation(IdentifierNameSyntax identifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseNumericLiteralSeparator : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static int BinaryMinimumDigits;
    private static int HexadecimalMinimumDigits;
    private static int DecimalMinimumDigits;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseNumericLiteralSeparator();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ShouldHaveSeparator(LiteralExpressionSyntax numericLiteral);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseParamsForVariableArguments : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseParamsForVariableArguments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IMethodSymbol MethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    private static bool CheckModifiers(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseShortCircuitingOperator : UseShortCircuitingOperatorBase`2<SyntaxKind, BinaryExpressionSyntax> {
    internal static IDictionary`2<SyntaxKind, SyntaxKind> ShortCircuitingAlternative;
    private static IDictionary`2<SyntaxKind, string> OperatorNames;
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    private static UseShortCircuitingOperator();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual string GetSuggestedOpName(BinaryExpressionSyntax node);
    protected virtual string GetCurrentOpName(BinaryExpressionSyntax node);
    protected virtual SyntaxToken GetOperator(BinaryExpressionSyntax expression);
    protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseShortCircuitingOperatorCodeFix : UseShortCircuitingOperatorCodeFixBase`2<SyntaxKind, BinaryExpressionSyntax> {
    internal virtual bool IsCandidateExpression(BinaryExpressionSyntax expression);
    protected virtual BinaryExpressionSyntax GetShortCircuitingExpressionNode(BinaryExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseStringCreate : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    private ImmutableArray`1<string> methodNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStringCreate();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool NameIsEqual(SyntaxNode node, string name);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarCompilationStartAnalysisContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_2(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseStringIsNullOrEmpty : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static string EqualsName;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStringIsNullOrEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool TryGetFirstArgument(InvocationExpressionSyntax invocationExpression, ArgumentSyntax& firstArgument);
    private static bool IsStringEqualsMethod(MemberAccessExpressionSyntax memberAccessExpression, SemanticModel semanticModel);
    private static bool IsStringIdentifier(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsConstantEmptyString(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsStringEmptyConst(ExpressionSyntax expression, SemanticModel semanticModel);
    private static bool IsStringEmptyLiteral(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseTestableTimeProvider : UseTestableTimeProviderBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool Ignore(SyntaxNode ancestor, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseTrueForAll : UseTrueForAllBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseUnixEpoch : UseUnixEpochBase`3<SyntaxKind, LiteralExpressionSyntax, MemberAccessExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsDateTimeKindUtc(MemberAccessExpressionSyntax memberAccess);
    protected virtual bool IsGregorianCalendar(SyntaxNode node);
    protected virtual bool IsZeroTimeOffset(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseUnixEpochCodeFix : UseUnixEpochCodeFixBase`1<SyntaxKind> {
    protected virtual SyntaxNode ReplaceConstructorWithField(SyntaxNode root, SyntaxNode node, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseUriInsteadOfString : SonarDiagnosticAnalyzer {
    private static string DiagnosticIdRuleS3994;
    private static string DiagnosticIdRuleS3995;
    private static string DiagnosticIdRuleS3996;
    private static string DiagnosticIdRuleS3997;
    private static string DiagnosticIdRuleS4005;
    private static string MessageFormatRuleS3994;
    private static string MessageFormatRuleS3995;
    private static string MessageFormatRuleS3996;
    private static string MessageFormatRuleS3997;
    private static string MessageFormatRuleS4005;
    private static DiagnosticDescriptor RuleS3994;
    private static DiagnosticDescriptor RuleS3995;
    private static DiagnosticDescriptor RuleS3996;
    private static DiagnosticDescriptor RuleS3997;
    private static DiagnosticDescriptor RuleS4005;
    private static ISet`1<string> UrlNameVariants;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseUriInsteadOfString();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VerifyMethodDeclaration(SonarSyntaxNodeReportingContext context);
    private static void VerifyPropertyDeclaration(SonarSyntaxNodeReportingContext context);
    private static void VerifyRecordDeclaration(SonarSyntaxNodeReportingContext context);
    private static bool HasStringUriParams(BaseParameterListSyntax parameterList, SemanticModel model);
    private static void VerifyInvocationAndCreation(SonarSyntaxNodeReportingContext context);
    private static void VerifyReturnType(SonarSyntaxNodeReportingContext context, BaseMethodDeclarationSyntax methodDeclaration, IMethodSymbol methodSymbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CSharp.UseUriInsteadOfString/<FindOverloadsThatUseUriTypeInPlaceOfString>d__25")]
private static IEnumerable`1<IMethodSymbol> FindOverloadsThatUseUriTypeInPlaceOfString(IMethodSymbol originalMethodSymbol, ISet`1<int> paramIdx);
    private static ISet`1<int> StringUrlParamIndexes(IMethodSymbol methodSymbol);
    private static IEnumerable`1<IMethodSymbol> OtherMethodOverrides(IMethodSymbol methodSymbol);
    private static bool UsesUriInPlaceOfStringUri(IParameterSymbol paramSymbol, IParameterSymbol originalParamSymbol, bool isStringUri);
    private static bool NameContainsUri(string name);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseValueParameter : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseValueParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool OnlyThrows(AccessorDeclarationSyntax accessor);
    private static bool IsAccessorValue(IdentifierNameSyntax identifier, SemanticModel semanticModel);
    private static string GetAccessorType(AccessorDeclarationSyntax accessorDeclaration);
    private static string GetPropertyAccessorKind(AccessorDeclarationSyntax accessorDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseWhereBeforeOrderBy : UseWhereBeforeOrderByBase`2<SyntaxKind, InvocationExpressionSyntax> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UseWhileLoopInstead : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseWhileLoopInstead();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.UsingNonstandardCryptography : UsingNonstandardCryptographyBase`2<SyntaxKind, TypeDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind[] <SyntaxKinds>k__BackingField;
    protected ILanguageFacade Language { get; }
    protected SyntaxKind[] SyntaxKinds { get; }
    public UsingNonstandardCryptography(IAnalyzerConfiguration analyzerConfiguration);
    protected virtual ILanguageFacade get_Language();
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind[] get_SyntaxKinds();
    protected virtual INamedTypeSymbol DeclaredSymbol(TypeDeclarationSyntax typeDeclarationSyntax, SemanticModel semanticModel);
    protected virtual Location Location(TypeDeclarationSyntax typeDeclarationSyntax);
    protected virtual bool DerivesOrImplementsAny(TypeDeclarationSyntax typeDeclarationSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ValuesUselesslyIncremented : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ValuesUselesslyIncremented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static void VisitParent(SonarSyntaxNodeReportingContext context, PostfixUnaryExpressionSyntax increment);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.ValueTypeShouldImplementIEquatable : ValueTypeShouldImplementIEquatableBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.VariableShadowsField : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VariableShadowsField();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static SyntaxNode GetDeclarationOrDesignation(SyntaxNode node);
    private static void Process(SonarSyntaxNodeReportingContext context, SyntaxNode node);
    private static List`1<SyntaxToken> ExtractIdentifiers(SyntaxNode node);
    private static List`1<ISymbol> GetContextSymbols(SonarSyntaxNodeReportingContext context);
    private static void ReportOnVariableMatchingField(SonarSyntaxNodeReportingContext context, IEnumerable`1<ISymbol> members, SyntaxToken identifier);
    private static string GetSymbolName(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.VariableUnused : VariableUnusedBase {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VariableUnused();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.VirtualEventField : SonarDiagnosticAnalyzer {
    private static string MessageFormat;
    internal static string DiagnosticId;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static VirtualEventField();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.VirtualEventFieldCodeFix : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.WcfMissingContractAttribute : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageOperation;
    private static string MessageService;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WcfMissingContractAttribute();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAnyMethodWithOperationContract(INamespaceOrTypeSymbol namedType);
    private static TypeDeclarationSyntax GetTypeDeclaration(SonarSymbolReportingContext context, ISymbol namedType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.WcfNonVoidOneWay : WcfNonVoidOneWayBase`2<MethodDeclarationSyntax, SyntaxKind> {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected SyntaxKind MethodDeclarationKind { get; }
    private static WcfNonVoidOneWay();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual SyntaxKind get_MethodDeclarationKind();
    protected virtual Location GetReturnTypeLocation(MethodDeclarationSyntax method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.WeakSslTlsProtocols : WeakSslTlsProtocolsBase`1<SyntaxKind> {
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsPartOfBinaryNegationOrCondition(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.XmlExternalEntityShouldNotBeParsed : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string SecondaryMessage;
    private static DiagnosticDescriptor Rule;
    private INetFrameworkVersionProvider versionProvider;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal XmlExternalEntityShouldNotBeParsed(INetFrameworkVersionProvider netFrameworkVersionProvider);
    private static XmlExternalEntityShouldNotBeParsed();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void VerifyXmlReaderInvocations(SonarSyntaxNodeReportingContext context);
    private void VerifyXPathDocumentConstructor(SonarSyntaxNodeReportingContext context, IObjectCreation objectCreation);
    private static bool IsXPathDocumentSecureByDefault(NetFrameworkVersion version);
    private static bool ConstructorIsSafe(NetFrameworkVersion version);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarCompilationStartAnalysisContext ccc);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_1(SonarSyntaxNodeReportingContext c);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SonarAnalyzer.Rules.CSharp.XmlSignatureCheck : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static XmlSignatureCheck();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
public interface SonarAnalyzer.Rules.MessageTemplates.IMessageTemplateCheck {
    public DiagnosticDescriptor Rule { get; }
    public abstract virtual DiagnosticDescriptor get_Rule();
    public abstract virtual void Execute(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, ArgumentSyntax templateArgument, Placeholder[] placeholders);
}
public class SonarAnalyzer.Rules.MessageTemplates.LoggingTemplatePlaceHoldersShouldBeInOrder : object {
    private static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S6673;
    public DiagnosticDescriptor Rule { get; }
    private static LoggingTemplatePlaceHoldersShouldBeInOrder();
    public sealed virtual DiagnosticDescriptor get_Rule();
    public sealed virtual void Execute(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, ArgumentSyntax templateArgument, Placeholder[] placeholders);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.MessageTemplates.LoggingTemplatePlaceHoldersShouldBeInOrder/<PlaceholderValues>d__6")]
private static IEnumerable`1<SyntaxNode> PlaceholderValues(InvocationExpressionSyntax invocation, IMethodSymbol methodSymbol);
    private static SyntaxNode OutOfOrderPlaceholderValue(Placeholder placeholder, int placeholderIndex, ImmutableArray`1<SyntaxNode> placeholderValues);
    private static Nullable`1<bool> MatchesName(string placeholderName, SyntaxNode placeholderValue, bool isStrict);
    private static bool SimpleStringMatches(string placeholderName, string argumentName, bool isStrict);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.MessageTemplates.LoggingTemplatePlaceHoldersShouldBeInOrder/<SplitByCamelCase>d__10")]
private static IEnumerable`1<string> SplitByCamelCase(string text);
    private static string OnlyLetters(string text);
}
internal static class SonarAnalyzer.Rules.MessageTemplates.MessageTemplateExtractor : object {
    public static ArgumentSyntax TemplateArgument(InvocationExpressionSyntax invocation, SemanticModel model);
    private static ArgumentSyntax TemplateArgument(InvocationExpressionSyntax invocation, SemanticModel model, KnownType type, ICollection`1<string> methods, string template, bool checkDerivedTypes);
}
public class SonarAnalyzer.Rules.MessageTemplates.NamedPlaceholdersShouldBeUnique : object {
    private static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S6677;
    public DiagnosticDescriptor Rule { get; }
    private static NamedPlaceholdersShouldBeUnique();
    public sealed virtual DiagnosticDescriptor get_Rule();
    public sealed virtual void Execute(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, ArgumentSyntax templateArgument, Placeholder[] placeholders);
}
public class SonarAnalyzer.Rules.MessageTemplates.UsePascalCaseForNamedPlaceHolders : object {
    private static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S6678;
    public DiagnosticDescriptor Rule { get; }
    private static UsePascalCaseForNamedPlaceHolders();
    public sealed virtual DiagnosticDescriptor get_Rule();
    public sealed virtual void Execute(SonarSyntaxNodeReportingContext context, InvocationExpressionSyntax invocation, ArgumentSyntax templateArgument, Placeholder[] placeholders);
}
public abstract class SonarAnalyzer.Rules.MutableFieldsShouldNotBe : SonarDiagnosticAnalyzer {
    private static ImmutableArray`1<KnownType> MutableBaseTypes;
    private static ImmutableArray`1<KnownType> ImmutableBaseTypes;
    private DiagnosticDescriptor rule;
    protected ISet`1<SyntaxKind> InvalidModifiers { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected MutableFieldsShouldNotBe(string diagnosticId, string messageFormat);
    private static MutableFieldsShouldNotBe();
    protected abstract virtual ISet`1<SyntaxKind> get_InvalidModifiers();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool HasAllInvalidModifiers(FieldDeclarationSyntax fieldDeclaration);
    private static Dictionary`2<string, Nullable`1<bool>> FieldAssignmentImmutability(TypeDeclarationSyntax typeDeclaration, IEnumerable`1<FieldDeclarationSyntax> fieldDeclarations, SemanticModel semanticModel);
    private static IEnumerable`1<string> CollectInvalidFieldVariables(FieldDeclarationSyntax fieldDeclaration, Dictionary`2<string, Nullable`1<bool>> assignmentsInCtors, SemanticModel semanticModel);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.MutableFieldsShouldNotBe/<CollectReadonlyInvalidFieldVariables>d__12")]
private static IEnumerable`1<string> CollectReadonlyInvalidFieldVariables(FieldDeclarationSyntax fieldDeclaration, Dictionary`2<string, Nullable`1<bool>> assignmentsInCtors, SemanticModel semanticModel);
    private static bool IsImmutableOrValidMutableType(ITypeSymbol typeSymbol, ExpressionSyntax value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <HasAllInvalidModifiers>b__9_0(SyntaxToken m);
}
public abstract class SonarAnalyzer.Rules.ObjectShouldBeInitializedCorrectlyBase : TrackerHotspotDiagnosticAnalyzer`1<SyntaxKind> {
    protected CSharpObjectInitializationTracker ObjectInitializationTracker { get; }
    protected ILanguageFacade`1<SyntaxKind> Language { get; }
    protected ObjectShouldBeInitializedCorrectlyBase(IAnalyzerConfiguration configuration, string diagnosticId, string messageFormat);
    protected abstract virtual CSharpObjectInitializationTracker get_ObjectInitializationTracker();
    protected virtual ILanguageFacade`1<SyntaxKind> get_Language();
    protected virtual bool IsDefaultConstructorSafe(SonarCompilationStartAnalysisContext context);
    protected virtual void Initialize(TrackerInput input);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsWebConfigCookieSet(SonarCompilationStartAnalysisContext context, string attribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_2(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.StaticFieldWrittenFrom : SonarDiagnosticAnalyzer {
    protected DiagnosticDescriptor Rule { get; }
    protected bool EnableConcurrentExecution { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual DiagnosticDescriptor get_Rule();
    protected virtual bool get_EnableConcurrentExecution();
    protected abstract virtual bool IsValidCodeBlockContext(SyntaxNode node, ISymbol owningSymbol);
    protected abstract virtual string GetDiagnosticMessageArgument(SyntaxNode node, ISymbol owningSymbol, IFieldSymbol field);
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static void CollectLocationOfStaticField(SemanticModel semanticModel, MultiValueDictionary`2<IFieldSymbol, Location> locationsForFields, ExpressionSyntax expression);
    private static IFieldSymbol GetStaticFieldSymbol(SemanticModel semanticModel, SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarCodeBlockStartAnalysisContext`1<SyntaxKind> cbc);
}
internal class SonarAnalyzer.Rules.XXE.XmlReaderSettingsValidator : object {
    private SemanticModel semanticModel;
    private bool isXmlResolverSafeByDefault;
    public XmlReaderSettingsValidator(SemanticModel semanticModel, NetFrameworkVersion version);
    public IList`1<SecondaryLocation> GetUnsafeAssignmentLocations(InvocationExpressionSyntax invocation, ISymbol settings, string message);
    private static bool IsMemberAccessOnSymbol(ExpressionSyntax expression, ISymbol symbol, SemanticModel semanticModel);
    private static IEnumerable`1<AssignmentExpressionSyntax> GetAssignments(SyntaxNode node);
    private static bool IsXmlResolverPropertySafeByDefault(NetFrameworkVersion version);
    private static IObjectCreation GetObjectCreation(ISymbol symbol, InvocationExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsXmlReaderSettingsCreationWithInitializer(IObjectCreation objectCreation, SemanticModel semanticModel);
    private static bool IsXmlResolverDtdProcessingUnsafe(AssignmentExpressionSyntax assignment, SemanticModel semanticModel);
    private static bool IsXmlResolverAssignmentUnsafe(AssignmentExpressionSyntax assignment, SemanticModel semanticModel);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.CSharp.CSharpSyntaxClassifier : SyntaxClassifierBase {
    private static CSharpSyntaxClassifier instance;
    public static CSharpSyntaxClassifier Instance { get; }
    public static CSharpSyntaxClassifier get_Instance();
    protected virtual bool IsStatement(SyntaxNode node);
    protected virtual SyntaxNode ParentLoopCondition(SyntaxNode node);
    protected virtual bool IsCfgBoundary(SyntaxNode node);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.CalculationsShouldNotOverflow : CalculationsShouldNotOverflowBase {
    public static DiagnosticDescriptor S3949;
    protected DiagnosticDescriptor Rule { get; }
    private static CalculationsShouldNotOverflow();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.ConditionEvaluatesToConstant : ConditionEvaluatesToConstantBase {
    public static DiagnosticDescriptor S2583;
    public static DiagnosticDescriptor S2589;
    protected DiagnosticDescriptor Rule { get; }
    protected DiagnosticDescriptor Rule2583 { get; }
    protected DiagnosticDescriptor Rule2589 { get; }
    protected string NullName { get; }
    private static ConditionEvaluatesToConstant();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual DiagnosticDescriptor get_Rule2583();
    protected virtual DiagnosticDescriptor get_Rule2589();
    protected virtual string get_NullName();
    public virtual bool ShouldExecute();
    protected virtual bool IsInsideUsingDeclaration(SyntaxNode node);
    protected virtual bool IsLockStatement(SyntaxNode syntax);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.EmptyCollectionsShouldNotBeEnumerated : EmptyCollectionsShouldNotBeEnumeratedBase {
    public static DiagnosticDescriptor S4158;
    protected DiagnosticDescriptor Rule { get; }
    private static EmptyCollectionsShouldNotBeEnumerated();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.EmptyNullableValueAccess : EmptyNullableValueAccessBase {
    private static string MessageFormat;
    internal static DiagnosticDescriptor S3655;
    protected DiagnosticDescriptor Rule { get; }
    private static EmptyNullableValueAccess();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.HardcodedBytesRuleBase : SymbolicRuleCheck {
    protected SymbolicConstraint Hardcoded { get; }
    protected SymbolicConstraint NotHardcoded { get; }
    protected abstract virtual SymbolicConstraint get_Hardcoded();
    protected abstract virtual SymbolicConstraint get_NotHardcoded();
    protected ProgramState ProcessArrayCreation(ProgramState state, IArrayCreationOperationWrapper arrayCreation);
    protected ProgramState ProcessArrayElementReference(ProgramState state, IArrayElementReferenceOperationWrapper arrayElementReference);
    protected ProgramState ProcessArraySetValue(ProgramState state, IInvocationOperationWrapper invocation);
    protected ProgramState ProcessArrayInitialize(ProgramState state, IInvocationOperationWrapper invocation);
    protected ProgramState ProcessStringToBytes(ProgramState state, IInvocationOperationWrapper invocation);
    [CompilerGeneratedAttribute]
internal static bool <ProcessArrayElementReference>g__IsAssignedToNonConstant|5_0(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessArrayElementReference>g__IsCompoundAssignedToNonConstant|5_1(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
private bool <ProcessStringToBytes>g__IsEncodingGetBytes|8_0(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private bool <ProcessStringToBytes>g__IsConvertFromBase64CharArray|8_1(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private bool <ProcessStringToBytes>g__IsConvertFromBase64String|8_2(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private bool <ProcessStringToBytes>g__ArgumentIsHardcoded|8_3(string parameterName, <>c__DisplayClass8_0& );
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.HashesShouldHaveUnpredictableSalt : HashesShouldHaveUnpredictableSaltBase {
    public static DiagnosticDescriptor S2053;
    protected DiagnosticDescriptor Rule { get; }
    private static HashesShouldHaveUnpredictableSalt();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.InitializationVectorShouldBeRandom : InitializationVectorShouldBeRandomBase {
    public static DiagnosticDescriptor S3329;
    protected DiagnosticDescriptor Rule { get; }
    private static InitializationVectorShouldBeRandom();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.JwtSecretKeys : HardcodedBytesRuleBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    public static DiagnosticDescriptor S6781;
    protected DiagnosticDescriptor Rule { get; }
    protected SymbolicConstraint Hardcoded { get; }
    protected SymbolicConstraint NotHardcoded { get; }
    private static JwtSecretKeys();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual SymbolicConstraint get_Hardcoded();
    protected virtual SymbolicConstraint get_NotHardcoded();
    public virtual bool ShouldExecute();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
    private ProgramState ProcessAssignment(ProgramState state, IAssignmentOperationWrapper assignment);
    private static ProgramState ProcessPropertyReference(ProgramState state, IPropertyReferenceOperationWrapper propertyReference);
    private ProgramState ProcessSymmetricSecurityKeyConstructor(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    [CompilerGeneratedAttribute]
internal static bool <ProcessSymmetricSecurityKeyConstructor>g__HasUnsafeValue|14_0(<>c__DisplayClass14_0& );
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.LocksReleasedAllPaths : LocksReleasedAllPathsBase {
    public static DiagnosticDescriptor S2222;
    protected DiagnosticDescriptor Rule { get; }
    private static LocksReleasedAllPaths();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual ISafeSyntaxWalker CreateSyntaxWalker(LockAcquireReleaseCollector collector);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.NullPointerDereference : NullPointerDereferenceBase {
    private static string MessageFormat;
    internal static DiagnosticDescriptor S2259;
    protected DiagnosticDescriptor Rule { get; }
    private static NullPointerDereference();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual bool IsSupressed(SyntaxNode node);
    public virtual bool ShouldExecute();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.ObjectsShouldNotBeDisposedMoreThanOnce : ObjectsShouldNotBeDisposedMoreThanOnceBase {
    public static DiagnosticDescriptor S3966;
    private static String[] DisposeMethods;
    protected DiagnosticDescriptor Rule { get; }
    private static ObjectsShouldNotBeDisposedMoreThanOnce();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
    protected virtual bool IsDispose(IMethodSymbol method);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.PublicMethodArgumentsShouldBeCheckedForNull : PublicMethodArgumentsShouldBeCheckedForNullBase {
    internal static DiagnosticDescriptor S3900;
    protected DiagnosticDescriptor Rule { get; }
    protected string NullName { get; }
    private static PublicMethodArgumentsShouldBeCheckedForNull();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual string get_NullName();
    public virtual bool ShouldExecute();
    protected virtual bool IsInConstructorInitializer(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <ShouldExecute>g__IsRelevantMethod|5_0();
    [CompilerGeneratedAttribute]
private bool <ShouldExecute>g__IsRelevantPropertyAccessor|5_1();
    [CompilerGeneratedAttribute]
internal static bool <ShouldExecute>g__MethodDereferencesArguments|5_2(BaseMethodDeclarationSyntax method);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.RestrictDeserializedTypes : RestrictDeserializedTypesBase {
    public static DiagnosticDescriptor S5773;
    protected DiagnosticDescriptor Rule { get; }
    private static RestrictDeserializedTypes();
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
    protected virtual SyntaxNode FindBindToTypeMethodDeclaration(IOperation operation);
    protected virtual SyntaxNode FindResolveTypeMethodDeclaration(IOperation operation);
    protected virtual bool ThrowsOrReturnsNull(SyntaxNode methodDeclaration);
    protected virtual SyntaxToken GetIdentifier(SyntaxNode methodDeclaration);
    private static IEnumerable`1<SyntaxNode> MethodCandidates(IOperation operation);
    [CompilerGeneratedAttribute]
private bool <FindBindToTypeMethodDeclaration>b__4_0(SyntaxNode x);
    [CompilerGeneratedAttribute]
private bool <FindResolveTypeMethodDeclaration>b__5_0(SyntaxNode x);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CSharp.SecureRandomSeedsShouldNotBePredictable : HardcodedBytesRuleBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static ImmutableHashSet`1<string> SecureRandomNextMethods;
    public static DiagnosticDescriptor S4347;
    protected DiagnosticDescriptor Rule { get; }
    protected SymbolicConstraint Hardcoded { get; }
    protected SymbolicConstraint NotHardcoded { get; }
    private static SecureRandomSeedsShouldNotBePredictable();
    protected virtual DiagnosticDescriptor get_Rule();
    protected virtual SymbolicConstraint get_Hardcoded();
    protected virtual SymbolicConstraint get_NotHardcoded();
    public virtual bool ShouldExecute();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    private static ProgramState ProcessRandomGeneratorCreation(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    private static ProgramState ProcessSecureRandomCreation(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    private static ProgramState ProcessSecureRandomGetInstance(ProgramState state, IInvocationOperationWrapper invocation);
    private static ProgramState ProcessSeedingMethods(ProgramState state, IInvocationOperationWrapper invocation);
    private ProgramState ProcessNextMethods(ProgramState state, IInvocationOperationWrapper invocation);
    private static bool IsSecureRandom(IInvocationOperationWrapper invocation);
    private static bool IsIRandomGenerator(IInvocationOperationWrapper invocation);
    [CompilerGeneratedAttribute]
internal static CryptographicSeedConstraint <ProcessSecureRandomCreation>g__GeneratorConstraint|13_0(<>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessSecureRandomCreation>g__HasSmallAutoseed|13_1(<>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessSeedingMethods>g__IsSetSeed|15_0(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessSeedingMethods>g__IsAddSeedMaterial|15_1(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessNextMethods>g__IsSecureRandomMethod|16_0(<>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProcessNextMethods>g__IsRandomGeneratorMethod|16_1(<>c__DisplayClass16_0& );
}
internal abstract class SonarAnalyzer.SymbolicExecution.Sonar.AbstractExplodedGraph : object {
    internal static int MaxStepCount;
    internal static int MaxInternalStateCount;
    private static int MaxProgramPointExecutionCount;
    private Dictionary`2<ProgramPoint, ProgramPoint> programPoints;
    private Queue`1<ExplodedGraphNode> workList;
    private HashSet`1<ExplodedGraphNode> nodesAlreadyInGraph;
    private IControlFlowGraph cfg;
    private ISymbol declaration;
    private IEnumerable`1<IParameterSymbol> declarationParameters;
    private IEnumerable`1<IParameterSymbol> nonInDeclarationParameters;
    private SonarCSharpLiveVariableAnalysis lva;
    protected ICollection`1<ExplodedGraphCheck> explodedGraphChecks;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler ExplorationEnded;
    [CompilerGeneratedAttribute]
private EventHandler MaxStepCountReached;
    [CompilerGeneratedAttribute]
private EventHandler MaxInternalStateCountReached;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstructionProcessedEventArgs> InstructionProcessed;
    [CompilerGeneratedAttribute]
private EventHandler`1<VisitCountExceedLimitEventArgs> ProgramPointVisitCountExceedLimit;
    [CompilerGeneratedAttribute]
private EventHandler ExitBlockReached;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConditionEvaluatedEventArgs> ConditionEvaluated;
    internal SemanticModel SemanticModel { get; }
    protected AbstractExplodedGraph(IControlFlowGraph cfg, ISymbol declaration, SemanticModel semanticModel, SonarCSharpLiveVariableAnalysis lva);
    [CompilerGeneratedAttribute]
internal SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void add_ExplorationEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ExplorationEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_MaxStepCountReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MaxStepCountReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_MaxInternalStateCountReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MaxInternalStateCountReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_InstructionProcessed(EventHandler`1<InstructionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_InstructionProcessed(EventHandler`1<InstructionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProgramPointVisitCountExceedLimit(EventHandler`1<VisitCountExceedLimitEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProgramPointVisitCountExceedLimit(EventHandler`1<VisitCountExceedLimitEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExitBlockReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ExitBlockReached(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ConditionEvaluated(EventHandler`1<ConditionEvaluatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConditionEvaluated(EventHandler`1<ConditionEvaluatedEventArgs> value);
    public void Walk();
    internal void AddExplodedGraphCheck(T check);
    private void OnExplorationEnded();
    private void OnMaxStepCountReached();
    private void OnMaxInternalStateCountReached();
    private void OnExitBlockReached();
    private void OnProgramPointVisitCountExceedLimit(ProgramPoint programPoint, ProgramState programState);
    protected void OnInstructionProcessed(SyntaxNode instruction, ProgramPoint programPoint, ProgramState programState);
    protected void OnConditionEvaluated(SyntaxNode condition, bool evaluationValue);
    protected abstract virtual void VisitBinaryBranch(BinaryBranchBlock binaryBranchBlock, ExplodedGraphNode node);
    protected abstract virtual void VisitInstruction(ExplodedGraphNode node);
    protected virtual void VisitBranchBlock(BranchBlock branchBlock, ExplodedGraphNode node);
    protected virtual void VisitSingleSuccessorBinaryBranch(BinaryBranchingSimpleBlock block, ExplodedGraphNode node);
    protected virtual void VisitSimpleBlock(SimpleBlock block, ExplodedGraphNode node);
    protected abstract virtual bool IsValueConsumingStatement(SyntaxNode jumpNode);
    protected ProgramState CleanStateAfterBlock(ProgramState programState, Block block);
    internal bool IsSymbolTracked(ISymbol symbol);
    protected bool IsFieldSymbol(ISymbol symbol);
    protected abstract virtual Block GetForEachExitBlock(Block block);
    private void EnqueueStartNode();
    protected void EnqueueAllSuccessors(Block block, ProgramState newProgramState);
    protected void EnqueueNewNode(ProgramPoint programPoint, ProgramState programState);
    protected ProgramState SetNewSymbolicValueIfTracked(ISymbol symbol, SymbolicValue symbolicValue, ProgramState programState);
    private static bool IsPointer(ITypeSymbol typeSymbol);
    private static bool IsValueTypeWithOverloadedNullCompatibleOpEquals(ITypeSymbol type);
    private static bool IsNullCompatibleType(ITypeSymbol type);
    protected static ProgramState SetNonNullConstraintIfValueType(ITypeSymbol typeSymbol, SymbolicValue symbolicValue, ProgramState programState);
    protected static ProgramState SetNonNullConstraintIfValueType(ISymbol symbol, SymbolicValue symbolicValue, ProgramState programState);
    protected ProgramState SetNonNullConstraintIfValueType(SyntaxNode node, SymbolicValue symbolicValue, ProgramState programState);
    private static bool IsNonNullableValueType(ITypeSymbol type);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.ConditionEvaluatesToConstant : object {
    private static string S2583DiagnosticId;
    private static string S2583MessageFormatBool;
    private static string S2583MessageNotNull;
    private static string S2589DiagnosticId;
    private static string S2589MessageFormatBool;
    private static string S2589MessageNull;
    internal static DiagnosticDescriptor S2583;
    internal static DiagnosticDescriptor S2589;
    private static ISet`1<SyntaxKind> OmittedSyntaxKinds;
    private static ISet`1<SyntaxKind> LoopBreakingStatements;
    private static ISet`1<SyntaxKind> LoopStatements;
    private static ISet`1<SyntaxKind> ConditionalStatements;
    private static ISet`1<SyntaxKind> CoalesceExpressions;
    private static ISet`1<SyntaxKind> IgnoredBlocks;
    private static ISet`1<SyntaxKind> BooleanLiterals;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConditionEvaluatesToConstant();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.EmptyCollectionsShouldNotBeEnumerated : object {
    private static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S4158;
    private static ImmutableArray`1<KnownType> TrackedCollectionTypes;
    private static HashSet`1<string> AddMethods;
    private static HashSet`1<string> IgnoredMethods;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EmptyCollectionsShouldNotBeEnumerated();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.EmptyNullableValueAccess : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string ValueLiteral;
    private static string HasValueLiteral;
    internal static DiagnosticDescriptor S3655;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EmptyNullableValueAccess();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.HashesShouldHaveUnpredictableSalt : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string MakeSaltUnpredictableMessage;
    private static string MakeThisSaltLongerMessage;
    internal static DiagnosticDescriptor S2053;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static HashesShouldHaveUnpredictableSalt();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.InitializationVectorShouldBeRandom : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S3329;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InitializationVectorShouldBeRandom();
    public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.InvalidCastToInterfaceSymbolicExecution : object {
    private static string MessageDefinite;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.NullPointerDereference : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S2259;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NullPointerDereference();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.ObjectsShouldNotBeDisposedMoreThanOnce : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    internal static DiagnosticDescriptor S3966;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ObjectsShouldNotBeDisposedMoreThanOnce();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.PublicMethodArgumentsShouldBeCheckedForNull : object {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string Constructor;
    private static string Method;
    public static DiagnosticDescriptor S3900;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PublicMethodArgumentsShouldBeCheckedForNull();
    public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
    private static void CollectMemberAccesses(MemberAccessingEventArgs args, ISet`1<IdentifierNameSyntax> identifiers, SemanticModel semanticModel);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Analyzers.RestrictDeserializedTypes : object {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string RestrictTypesMessage;
    private static string VerifyMacMessage;
    internal static DiagnosticDescriptor S5773;
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RestrictDeserializedTypes();
    public sealed virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Checks.ByteArrayCheck : ExplodedGraphCheck {
    public ByteArrayCheck(AbstractExplodedGraph explodedGraph);
    public virtual ProgramState PostProcessInstruction(ProgramPoint programPoint, ProgramState programState);
    private ProgramState ArrayCreationPostProcess(ArrayCreationExpressionSyntax arrayCreation, ProgramState programState);
    private ProgramState ImplicitlyTypedArrayPostProcess(InitializerExpressionSyntax initializerExpression, ProgramState programState);
    private ProgramState InvocationExpressionPostProcess(InvocationExpressionSyntax invocation, ProgramState programState);
    private static bool IsSanitizer(InvocationExpressionSyntax invocation, SemanticModel semanticModel);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.ConditionEvaluatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SyntaxNode <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluationValue>k__BackingField;
    public SyntaxNode Condition { get; public set; }
    public bool EvaluationValue { get; public set; }
    [CompilerGeneratedAttribute]
public SyntaxNode get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(SyntaxNode value);
    [CompilerGeneratedAttribute]
public bool get_EvaluationValue();
    [CompilerGeneratedAttribute]
public void set_EvaluationValue(bool value);
}
[ExtensionAttribute]
public static class SonarAnalyzer.SymbolicExecution.Sonar.Constraints.CollectionConstraintExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> AddConstraintForSymbolicValue(ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> constraintMap, SymbolicValue symbolicValue, SymbolicConstraint constraint);
    [ExtensionAttribute]
public static ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> RemoveConstraintForSymbolicValue(ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> constraintMap, SymbolicValue symbolicValue, SymbolicConstraint constraint);
    [ExtensionAttribute]
public static ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> AddConstraintTo(ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> constraintsMap, SymbolicValue symbolicValue, SymbolicConstraint constraint, ProgramState programState);
    private static SymbolicValue GetOtherOperandFromMatchingRelationship(SymbolicValue symbolicValue, BinaryRelationship relationship);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Constraints.InitializationVectorConstraint : SymbolicConstraint {
    public static InitializationVectorConstraint NotInitialized;
    public static InitializationVectorConstraint Initialized;
    public SymbolicConstraint Opposite { get; }
    private InitializationVectorConstraint(ConstraintKind kind);
    private static InitializationVectorConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Constraints.NullableConstraint : SymbolicConstraint {
    public static NullableConstraint NoValue;
    public static NullableConstraint HasValue;
    public SymbolicConstraint Opposite { get; }
    private NullableConstraint(ConstraintKind kind);
    private static NullableConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.Constraints.StringConstraint : SymbolicConstraint {
    public static StringConstraint EmptyString;
    public static StringConstraint FullString;
    public static StringConstraint FullOrNullString;
    public static StringConstraint WhiteSpaceString;
    public static StringConstraint NotWhiteSpaceString;
    public static StringConstraint FullNotWhiteSpaceString;
    public SymbolicConstraint Opposite { get; }
    private StringConstraint(ConstraintKind kind);
    private static StringConstraint();
    public virtual SymbolicConstraint get_Opposite();
    public static bool IsNotNull(StringConstraint constraint);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Constraints.SymbolicValueConstraints : object {
    private Dictionary`2<Type, SymbolicConstraint> constraints;
    private int hashCode;
    private SymbolicValueConstraints(SymbolicConstraint constraint);
    private SymbolicValueConstraints(Dictionary`2<Type, SymbolicConstraint> constraints);
    public static SymbolicValueConstraints Create(SymbolicConstraint constraint);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    internal IEnumerable`1<SymbolicConstraint> GetConstraints();
    internal SymbolicValueConstraints WithConstraint(SymbolicConstraint constraint);
    internal SymbolicValueConstraints WithoutConstraint(SymbolicConstraint constraint);
    internal T GetConstraintOrDefault();
    internal bool HasConstraint(SymbolicConstraint constraint);
    internal bool HasConstraint();
    private static void SetConstraint(SymbolicConstraint constraint, IDictionary`2<Type, SymbolicConstraint> constraints);
    private int ComputeHashcode();
}
internal abstract class SonarAnalyzer.SymbolicExecution.Sonar.DefaultAnalysisContext`1 : object {
    private List`1<T> locations;
    public bool SupportsPartialResults { get; }
    protected abstract virtual Diagnostic CreateDiagnostic(T location);
    public sealed virtual bool get_SupportsPartialResults();
    public sealed virtual IEnumerable`1<Diagnostic> GetDiagnostics();
    public void AddLocation(T location);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.ExplodedGraphCheck : object {
    protected AbstractExplodedGraph explodedGraph;
    protected SemanticModel semanticModel;
    protected ExplodedGraphCheck(AbstractExplodedGraph explodedGraph);
    public virtual ProgramState PreProcessInstruction(ProgramPoint programPoint, ProgramState programState);
    public virtual ProgramState PostProcessInstruction(ProgramPoint programPoint, ProgramState programState);
    public virtual ProgramState PreProcessUsingStatement(ProgramPoint programPoint, ProgramState programState);
    public virtual ProgramState ObjectCreated(ProgramState programState, SymbolicValue symbolicValue, SyntaxNode instruction);
    public virtual ProgramState ObjectCreating(ProgramState programState, SyntaxNode instruction);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.ExplodedGraphNode : object {
    [CompilerGeneratedAttribute]
private ProgramState <ProgramState>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramPoint <ProgramPoint>k__BackingField;
    private Nullable`1<int> hash;
    public ProgramState ProgramState { get; }
    public ProgramPoint ProgramPoint { get; }
    public ExplodedGraphNode(ProgramPoint programPoint, ProgramState programState);
    [CompilerGeneratedAttribute]
public ProgramState get_ProgramState();
    [CompilerGeneratedAttribute]
public ProgramPoint get_ProgramPoint();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExplodedGraphNode other);
    public virtual int GetHashCode();
    private int ComputeHash();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.InstructionProcessedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SyntaxNode <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramPoint <ProgramPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramState <ProgramState>k__BackingField;
    public SyntaxNode Instruction { get; public set; }
    public ProgramPoint ProgramPoint { get; public set; }
    public ProgramState ProgramState { get; public set; }
    [CompilerGeneratedAttribute]
public SyntaxNode get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(SyntaxNode value);
    [CompilerGeneratedAttribute]
public ProgramPoint get_ProgramPoint();
    [CompilerGeneratedAttribute]
public void set_ProgramPoint(ProgramPoint value);
    [CompilerGeneratedAttribute]
public ProgramState get_ProgramState();
    [CompilerGeneratedAttribute]
public void set_ProgramState(ProgramState value);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.InvocationVisitor : object {
    private static string EqualsLiteral;
    private static string ReferenceEqualsLiteral;
    private InvocationExpressionSyntax invocation;
    private SemanticModel semanticModel;
    private ProgramState programState;
    public InvocationVisitor(InvocationExpressionSyntax invocation, SemanticModel semanticModel, ProgramState programState);
    internal ProgramState ProcessInvocation();
    private ProgramState HandleNameofExpression();
    private ProgramState HandleStringNullOrWhiteSpaceCheckMethod();
    private ProgramState HandleStringNullOrEmptyCheckMethod();
    private ProgramState HandleStaticEqualsCall();
    private ProgramState HandleReferenceEqualsCall();
    private ProgramState HandleInstanceEqualsCall();
    private ProgramState HandleNullValidationMethod(int validatedArgumentIndex, int invocationArgsCount);
    private static bool IsStringStaticMethod(IMethodSymbol methodSymbol, string methodName);
    private static bool IsStringNullOrWhiteSpaceCheckMethod(IMethodSymbol methodSymbol);
    private static bool IsStringNullOrEmptyCheckMethod(IMethodSymbol methodSymbol);
    private static bool IsReferenceEqualsCall(IMethodSymbol methodSymbol);
    private static bool IsInstanceEqualsCall(IMethodSymbol methodSymbol);
    private static bool IsStaticEqualsCall(IMethodSymbol methodSymbol);
    private static bool ValidatesNotNull(IMethodSymbol methodSymbol, Int32& validatedArgumentIndex);
    internal static ProgramState SetConstraintOnValueEquals(ValueEqualsSymbolicValue equals, ProgramState programState);
    [CompilerGeneratedAttribute]
internal static bool <ValidatesNotNull>g__IsValidatedParameter|20_0(IParameterSymbol parameterSymbol);
    [CompilerGeneratedAttribute]
internal static bool <ValidatesNotNull>g__IsValidatedNotNullAttribute|20_1(AttributeData attribute);
}
public interface SonarAnalyzer.SymbolicExecution.Sonar.ISymbolicExecutionAnalysisContext {
    public bool SupportsPartialResults { get; }
    public abstract virtual bool get_SupportsPartialResults();
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics();
}
internal interface SonarAnalyzer.SymbolicExecution.Sonar.ISymbolicExecutionAnalyzer {
    public IEnumerable`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public abstract virtual IEnumerable`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public abstract virtual ISymbolicExecutionAnalysisContext CreateContext(SonarSyntaxNodeReportingContext context, SonarExplodedGraph explodedGraph);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.MemberAccessedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IdentifierNameSyntax <Identifier>k__BackingField;
    public IdentifierNameSyntax Identifier { get; }
    public MemberAccessedEventArgs(IdentifierNameSyntax identifier);
    [CompilerGeneratedAttribute]
public IdentifierNameSyntax get_Identifier();
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.MemberAccessingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IdentifierNameSyntax <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramState <ProgramState>k__BackingField;
    public IdentifierNameSyntax Identifier { get; }
    public ISymbol Symbol { get; }
    public ProgramState ProgramState { get; }
    public MemberAccessingEventArgs(IdentifierNameSyntax identifier, ISymbol symbol, ProgramState programState);
    [CompilerGeneratedAttribute]
public IdentifierNameSyntax get_Identifier();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public ProgramState get_ProgramState();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.ProgramPoint : object {
    [CompilerGeneratedAttribute]
private Block <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    private Nullable`1<int> hash;
    public Block Block { get; }
    public int Offset { get; }
    public SyntaxNode CurrentInstruction { get; }
    internal ProgramPoint(Block block, int offset);
    internal ProgramPoint(Block block);
    [CompilerGeneratedAttribute]
public Block get_Block();
    [CompilerGeneratedAttribute]
public int get_Offset();
    public SyntaxNode get_CurrentInstruction();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProgramPoint other);
    public virtual int GetHashCode();
    private int ComputeHash();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.ProgramState : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SymbolicValue> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> <Constraints>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ProgramPoint, int> <ProgramPointVisitCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<SymbolicValue> <ExpressionStack>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<BinaryRelationship> <Relationships>k__BackingField;
    private static ISet`1<SymbolicValue> ProtectedSymbolicValues;
    private static ISet`1<SymbolicValue> DistinguishedReferences;
    private Nullable`1<int> hash;
    private ImmutableDictionary`2<ISymbol, SymbolicValue> Values { get; }
    public ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> Constraints { get; }
    private ImmutableDictionary`2<ProgramPoint, int> ProgramPointVisitCounts { get; }
    internal ImmutableStack`1<SymbolicValue> ExpressionStack { get; }
    internal ImmutableHashSet`1<BinaryRelationship> Relationships { get; }
    private static ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> InitialConstraints { get; }
    internal bool HasValue { get; }
    internal ProgramState(ImmutableDictionary`2<ISymbol, SymbolicValue> values, ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> constraints, ImmutableDictionary`2<ProgramPoint, int> programPointVisitCounts, ImmutableStack`1<SymbolicValue> expressionStack, ImmutableHashSet`1<BinaryRelationship> relationships);
    private static ProgramState();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SymbolicValue> get_Values();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> get_Constraints();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ProgramPoint, int> get_ProgramPointVisitCounts();
    [CompilerGeneratedAttribute]
internal ImmutableStack`1<SymbolicValue> get_ExpressionStack();
    [CompilerGeneratedAttribute]
internal ImmutableHashSet`1<BinaryRelationship> get_Relationships();
    private static ImmutableDictionary`2<SymbolicValue, SymbolicValueConstraints> get_InitialConstraints();
    private int ComputeHash();
    internal ProgramState TrySetRelationship(BinaryRelationship relationship);
    private ImmutableHashSet`1<BinaryRelationship> GetAllRelationshipsWith(BinaryRelationship relationship);
    private static void RemoveRedundantRelationships(HashSet`1<BinaryRelationship> relationships);
    private static void RemoveRedundantLessEquals(HashSet`1<BinaryRelationship> relationships);
    private static void RemoveRedundantLessEqualWithNotEqual(HashSet`1<BinaryRelationship> relationships);
    private static void RemoveRedundantMatchingLessEquals(HashSet`1<BinaryRelationship> relationships);
    private static List`1<ComparisonRelationship> GetComparisions(HashSet`1<BinaryRelationship> relationships, SymbolicComparisonKind kind);
    private bool IsRelationshipOnLocalValues(BinaryRelationship relationship);
    public ProgramState PushValue(SymbolicValue symbolicValue);
    public ProgramState PushValues(IEnumerable`1<SymbolicValue> values);
    public ProgramState PopValue();
    public ProgramState PopValue(SymbolicValue& poppedValue);
    public ProgramState PopValues(int numberOfValuesToPop);
    public SymbolicValue PeekValue();
    internal bool get_HasValue();
    internal ProgramState StoreSymbolicValue(ISymbol symbol, SymbolicValue newSymbolicValue);
    public SymbolicValue GetSymbolValue(ISymbol symbol);
    internal ProgramState AddVisit(ProgramPoint visitedProgramPoint);
    internal int GetVisitedCount(ProgramPoint programPoint);
    internal ProgramState RemoveConstraint(SymbolicValue symbolicValue);
    internal ProgramState RemoveSymbols(Func`2<ISymbol, bool> predicate);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProgramState other);
    public virtual int GetHashCode();
    public ProgramState SetConstraint(SymbolicValue symbolicValue, SymbolicConstraint constraint);
    public ProgramState RemoveConstraint(SymbolicValue symbolicValue, SymbolicConstraint constraint);
    public bool HasConstraint(SymbolicValue symbolicValue, SymbolicConstraint constraint);
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.BinaryRelationship : object {
    private Lazy`1<int> hash;
    [CompilerGeneratedAttribute]
private SymbolicValue <LeftOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolicValue <RightOperand>k__BackingField;
    internal SymbolicValue LeftOperand { get; }
    internal SymbolicValue RightOperand { get; }
    protected BinaryRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    [CompilerGeneratedAttribute]
internal SymbolicValue get_LeftOperand();
    [CompilerGeneratedAttribute]
internal SymbolicValue get_RightOperand();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BinaryRelationship other);
    public virtual int GetHashCode();
    internal abstract virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal abstract virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    public abstract virtual BinaryRelationship Negate();
    internal bool AreOperandsMatching(BinaryRelationship other);
    internal abstract virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    protected BinaryRelationship ComputeTransitiveRelationship(BinaryRelationship other, BinaryRelationship factory);
    [CompilerGeneratedAttribute]
private int <.ctor>b__7_0();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ComparisonRelationship : BinaryRelationship {
    private Lazy`1<int> hash;
    [CompilerGeneratedAttribute]
private SymbolicComparisonKind <ComparisonKind>k__BackingField;
    internal SymbolicComparisonKind ComparisonKind { get; }
    public ComparisonRelationship(SymbolicComparisonKind comparisonKind, SymbolicValue leftOperand, SymbolicValue rightOperand);
    [CompilerGeneratedAttribute]
internal SymbolicComparisonKind get_ComparisonKind();
    public virtual BinaryRelationship Negate();
    internal virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    [IteratorStateMachineAttribute("SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ComparisonRelationship/<GetTransitiveRelationships>d__7")]
internal virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    private ComparisonRelationship GetTransitiveRelationship(ComparisonRelationship other);
    private BinaryRelationship GetTransitiveRelationship(EqualsRelationship other);
    internal bool AreOperandsSwapped(ComparisonRelationship rel);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ComparisonRelationship other);
    public virtual int GetHashCode();
    internal virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    [CompilerGeneratedAttribute]
private int <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__6_1(ComparisonRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__6_3(ComparisonRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__6_4(EqualsRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__6_6(ComparisonRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__6_7(ValueNotEqualsRelationship rel);
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.EqualsRelationship : BinaryRelationship {
    private Lazy`1<int> hash;
    protected EqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    public sealed virtual bool Equals(EqualsRelationship other);
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    internal static int GetHashCodeMinMaxOrdered(int leftHash, int rightHash, int typeHash);
    [CompilerGeneratedAttribute]
private int <.ctor>b__1_0();
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.NotEqualsRelationship : BinaryRelationship {
    private Lazy`1<int> hash;
    protected NotEqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(NotEqualsRelationship other);
    public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private int <.ctor>b__1_0();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ReferenceEqualsRelationship : EqualsRelationship {
    public ReferenceEqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    public virtual BinaryRelationship Negate();
    public virtual string ToString();
    internal virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    internal virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_0(NotEqualsRelationship rel);
    [CompilerGeneratedAttribute]
private BinaryRelationship <GetTransitiveRelationships>b__4_0(BinaryRelationship other);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ReferenceNotEqualsRelationship : NotEqualsRelationship {
    public ReferenceNotEqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    public virtual BinaryRelationship Negate();
    public virtual string ToString();
    internal virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_0(ReferenceEqualsRelationship rel);
    [CompilerGeneratedAttribute]
private BinaryRelationship <GetTransitiveRelationships>b__5_0(ReferenceEqualsRelationship other);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ValueEqualsRelationship : EqualsRelationship {
    public ValueEqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    public virtual BinaryRelationship Negate();
    public virtual string ToString();
    internal virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    [IteratorStateMachineAttribute("SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ValueEqualsRelationship/<GetTransitiveRelationships>d__5")]
internal virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_0(ValueNotEqualsRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_2(ComparisonRelationship c);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.Relationships.ValueNotEqualsRelationship : NotEqualsRelationship {
    public ValueNotEqualsRelationship(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual bool IsContradicting(IEnumerable`1<BinaryRelationship> relationships);
    public virtual BinaryRelationship Negate();
    public virtual string ToString();
    internal virtual BinaryRelationship CreateNew(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual IEnumerable`1<BinaryRelationship> GetTransitiveRelationships(IEnumerable`1<BinaryRelationship> relationships);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_0(EqualsRelationship rel);
    [CompilerGeneratedAttribute]
private bool <IsContradicting>b__1_2(ComparisonRelationship c);
    [CompilerGeneratedAttribute]
private BinaryRelationship <GetTransitiveRelationships>b__5_0(EqualsRelationship other);
}
internal class SonarAnalyzer.SymbolicExecution.Sonar.SonarExplodedGraph : AbstractExplodedGraph {
    private static string isNullOrEmpty;
    private static string isNullOrWhiteSpace;
    [CompilerGeneratedAttribute]
private NullPointerCheck <NullPointerCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableValueAccessedCheck <NullableValueAccessedCheck>k__BackingField;
    internal NullPointerCheck NullPointerCheck { get; }
    internal NullableValueAccessedCheck NullableValueAccessedCheck { get; }
    public SonarExplodedGraph(IControlFlowGraph cfg, ISymbol declaration, SemanticModel semanticModel, SonarCSharpLiveVariableAnalysis lva);
    [CompilerGeneratedAttribute]
internal NullPointerCheck get_NullPointerCheck();
    [CompilerGeneratedAttribute]
internal NullableValueAccessedCheck get_NullableValueAccessedCheck();
    protected virtual void VisitSimpleBlock(SimpleBlock block, ExplodedGraphNode node);
    protected virtual void VisitBinaryBranch(BinaryBranchBlock binaryBranchBlock, ExplodedGraphNode node);
    protected virtual void VisitInstruction(ExplodedGraphNode node);
    private static ProgramState VisitRecursivePattern(RecursivePatternSyntaxWrapper recursivePattern, ProgramState programState);
    private ProgramState VisitDeclarationExpression(DeclarationExpressionSyntaxWrapper wrapper, ProgramState programState);
    private static ProgramState VisitDiscardDesignationSyntax(ProgramState programState);
    private ProgramState VisitParenthesizedVariableDesignationSyntax(ParenthesizedVariableDesignationSyntaxWrapper designation, ProgramState programState);
    private ProgramState VisitVarPattern(VarPatternSyntaxWrapper varPatternSyntax, ProgramState programState);
    private ProgramState VisitDeclarationPattern(DeclarationPatternSyntaxWrapper declarationPattern, ProgramState newProgramState);
    private ProgramState VisitVariableDesignation(VariableDesignationSyntaxWrapper variableDesignation, ProgramState programState, bool isInParanthesizedVariableDesignation);
    private ProgramState InvokeChecks(ProgramState programState, Func`3<ProgramState, ExplodedGraphCheck, ProgramState> invoke);
    private ProgramState EnsureStackState(ExpressionSyntax parenthesizedExpression, ProgramState programState);
    private void VisitForeachBinaryBranch(BinaryBranchBlock binaryBranchBlock, ProgramState programState);
    private void VisitCoalesceExpressionBinaryBranch(BinaryBranchBlock binaryBranchBlock, ProgramState programState);
    private void VisitConditionalAccessBinaryBranch(BinaryBranchBlock binaryBranchBlock, ProgramState programState);
    private void VisitCaseSwitchBinaryBranchBlock(BinaryBranchBlock branchBlock, ExplodedGraphNode node, CaseSwitchLabelSyntax simpleCaseLabel);
    private void VisitSwitchExpressionArmBinaryBranch(BinaryBranchBlock branchBlock, ExplodedGraphNode node, SwitchExpressionArmSyntaxWrapper armSyntaxWrapper);
    private void VisitBinaryBranch(BinaryBranchBlock binaryBranchBlock, ExplodedGraphNode node, SyntaxNode instruction);
    private static IEnumerable`1<ProgramState> GenerateNewProgramFalseState(BinaryBranchBlock binaryBranchBlock, SymbolicValue sv, ProgramState newProgramState);
    private static IEnumerable`1<ProgramState> GenerateNewProgramTrueState(BinaryBranchBlock binaryBranchBlock, SymbolicValue sv, ProgramState newProgramState);
    private static IEnumerable`1<ProgramState> NullOrEmptyStringStates(ProgramState nps, ReferenceEqualsSymbolicValue referenceEqualsSymbolicValue);
    private static IEnumerable`1<ProgramState> NullOrEmptyOrWhiteSpaceStringStates(ProgramState nps, ReferenceEqualsSymbolicValue referenceEqualsSymbolicValue);
    private ProgramState VisitMemberAccess(MemberAccessExpressionSyntax memberAccess, ProgramState programState);
    private static ProgramState VisitSafeCastExpression(BinaryExpressionSyntax instruction, ProgramState programState);
    private ProgramState VisitDefaultExpression(SyntaxNode instruction, ProgramState programState);
    private bool IsOperatorOnObject(SyntaxNode instruction);
    private static ProgramState VisitValueEquals(ProgramState programState);
    private ProgramState VisitReferenceEquals(BinaryExpressionSyntax equals, ProgramState programState);
    private ProgramState VisitComparisonBinaryOperator(ProgramState programState, SyntaxNode instruction, Func`3<SymbolicValue, SymbolicValue, SymbolicValue> svFactory);
    private static ProgramState VisitBinaryOperator(ProgramState programState, Func`3<SymbolicValue, SymbolicValue, SymbolicValue> svFactory);
    private ProgramState VisitBooleanBinaryOpAssignment(ProgramState programState, AssignmentExpressionSyntax assignment, Func`3<SymbolicValue, SymbolicValue, SymbolicValue> symbolicValueFactory);
    private ProgramState VisitObjectCreation(ObjectCreationExpressionSyntax ctor, ProgramState programState);
    private static ProgramState VisitInitializer(SyntaxNode instruction, ExpressionSyntax parenthesizedExpression, ProgramState programState);
    private ProgramState VisitIdentifier(IdentifierNameSyntax identifier, ProgramState programState);
    private ProgramState VisitPostfixIncrement(PostfixUnaryExpressionSyntax unary, ProgramState programState);
    private ProgramState VisitPrefixIncrement(PrefixUnaryExpressionSyntax unary, ProgramState programState);
    private ProgramState VisitOpAssignment(AssignmentExpressionSyntax assignment, ProgramState programState);
    private ProgramState VisitSimpleAssignment(AssignmentExpressionSyntax assignment, ProgramState programState);
    private ProgramState VisitVariableDeclarator(VariableDeclaratorSyntax declarator, ProgramState programState);
    private ProgramState VisitTuple(TupleExpressionSyntaxWrapper tuple, ProgramState programState);
    protected virtual bool IsValueConsumingStatement(SyntaxNode jumpNode);
    private static bool ShouldConsumeValue(ExpressionSyntax expression);
    private static bool IsEmptyNullableCtorCall(IMethodSymbol nullableConstructorCall);
    protected virtual Block GetForEachExitBlock(Block block);
    private static SymbolicValue CreateFieldSymbolicValue(IFieldSymbol fieldSymbol);
    [CompilerGeneratedAttribute]
internal static ProgramState <VisitParenthesizedVariableDesignationSyntax>g__SetSymbolValue|15_0(ISymbol variableSymbol, <>c__DisplayClass15_0& );
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValue : object {
    public static SymbolicValue True;
    public static SymbolicValue False;
    public static SymbolicValue Null;
    public static SymbolicValue This;
    public static SymbolicValue Base;
    protected object identifier;
    private static int symbolicValueCounter;
    private SymbolicValue(object identifier);
    private static SymbolicValue();
    internal static SymbolicValue Create(ITypeSymbol type);
    public virtual string ToString();
    public bool TryGetConstraints(ProgramState programState, SymbolicValueConstraints& constraints);
    public bool IsNull(ProgramState programState);
    public virtual IEnumerable`1<ProgramState> TrySetConstraint(SymbolicConstraint constraint, ProgramState programState);
    public virtual IEnumerable`1<ProgramState> TrySetOppositeConstraint(SymbolicConstraint constraint, ProgramState programState);
    public IEnumerable`1<ProgramState> TrySetConstraints(SymbolicValueConstraints constraints, ProgramState programState);
    public IEnumerable`1<ProgramState> TrySetOppositeConstraints(SymbolicValueConstraints constraints, ProgramState programState);
    protected static IEnumerable`1<ProgramState> ThrowIfTooMany(IEnumerable`1<ProgramState> states);
    private IEnumerable`1<ProgramState> TrySetConstraints(SymbolicValueConstraints constraints, ProgramState programState, bool isOppositeConstraints);
    private IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, SymbolicValueConstraints oldConstraints, ProgramState programState);
    private IEnumerable`1<ProgramState> TrySetObjectConstraint(ObjectConstraint constraint, SymbolicValueConstraints oldConstraints, ProgramState programState);
    private IEnumerable`1<ProgramState> TrySetStringConstraint(StringConstraint constraint, ProgramState programState);
    private IEnumerable`1<ProgramState> UpdateObjectConstraint(StringConstraint constraint, ProgramState programState, ObjectConstraint oldObjectConstraint);
    private static IEnumerable`1<ProgramState> UpdateStringConstraint(StringConstraint constraint, ProgramState programState, StringConstraint oldConstraint, SymbolicValue sv);
    private IEnumerable`1<ProgramState> SetNewStringConstraint(StringConstraint constraint, ProgramState& programState);
    private static Exception UnexpectedConstraintException(SymbolicConstraint constraint, SymbolicValueConstraints oldConstraints);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.AndSymbolicValue : BoolBinarySymbolicValue {
    public AndSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, ProgramState programState);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_0(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_1(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_2(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_3(ProgramState ps);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.BinarySymbolicValue : SymbolicValue {
    [CompilerGeneratedAttribute]
private SymbolicValue <LeftOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolicValue <RightOperand>k__BackingField;
    public SymbolicValue LeftOperand { get; }
    public SymbolicValue RightOperand { get; }
    public BinarySymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    [CompilerGeneratedAttribute]
public SymbolicValue get_LeftOperand();
    [CompilerGeneratedAttribute]
public SymbolicValue get_RightOperand();
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.BoolBinarySymbolicValue : BinarySymbolicValue {
    private static int NestedSizeLimit;
    protected BoolBinarySymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected abstract virtual IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, ProgramState programState);
    public sealed virtual IEnumerable`1<ProgramState> TrySetConstraint(SymbolicConstraint constraint, ProgramState programState);
    private int NestedSize();
}
public enum SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ComparisonKind : Enum {
    public int value__;
    public static ComparisonKind Less;
    public static ComparisonKind LessOrEqual;
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ComparisonSymbolicValue : BoolBinarySymbolicValue {
    private SymbolicComparisonKind comparisonKind;
    public ComparisonSymbolicValue(SymbolicComparisonKind comparisonKind, SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, ProgramState programState);
    private BinaryRelationship GetRelationship(BoolConstraint boolConstraint);
    public virtual string ToString();
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.EqualityLikeSymbolicValue : RelationalSymbolicValue {
    protected EqualityLikeSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    private BinaryRelationship GetNormalizedRelationship(BoolConstraint boolConstraint, SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected abstract virtual BinaryRelationship GetRelationship(SymbolicValue left, SymbolicValue right);
    private BinaryRelationship GetRelationship(BoolConstraint boolConstraint, SymbolicValue left, SymbolicValue right);
    private BinaryRelationship GetRelationship(BoolConstraint boolConstraint);
    public virtual IEnumerable`1<ProgramState> TrySetConstraint(SymbolicConstraint constraint, ProgramState programState);
    internal abstract virtual IEnumerable`1<ProgramState> SetConstraint(BoolConstraint boolConstraint, SymbolicValueConstraints leftConstraints, SymbolicValueConstraints rightConstraints, ProgramState programState);
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.EqualsSymbolicValue : EqualityLikeSymbolicValue {
    protected EqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual IEnumerable`1<ProgramState> SetConstraint(BoolConstraint boolConstraint, SymbolicValueConstraints leftConstraints, SymbolicValueConstraints rightConstraints, ProgramState programState);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.LogicalNotSymbolicValue : UnarySymbolicValue {
    public LogicalNotSymbolicValue(SymbolicValue operand);
    public virtual IEnumerable`1<ProgramState> TrySetConstraint(SymbolicConstraint constraint, ProgramState programState);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.MemberAccessSymbolicValue : SymbolicValue {
    [CompilerGeneratedAttribute]
private SymbolicValue <MemberExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public SymbolicValue MemberExpression { get; }
    public string MemberName { get; }
    public MemberAccessSymbolicValue(SymbolicValue memberExpression, string memberName);
    [CompilerGeneratedAttribute]
public SymbolicValue get_MemberExpression();
    [CompilerGeneratedAttribute]
public string get_MemberName();
    public virtual string ToString();
}
public abstract class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.NotEqualsSymbolicValue : EqualityLikeSymbolicValue {
    protected NotEqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    internal virtual IEnumerable`1<ProgramState> SetConstraint(BoolConstraint boolConstraint, SymbolicValueConstraints leftConstraints, SymbolicValueConstraints rightConstraints, ProgramState programState);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.NullableSymbolicValue : SymbolicValue {
    [CompilerGeneratedAttribute]
private SymbolicValue <WrappedValue>k__BackingField;
    public SymbolicValue WrappedValue { get; }
    public NullableSymbolicValue(SymbolicValue wrappedValue);
    [CompilerGeneratedAttribute]
public SymbolicValue get_WrappedValue();
    public virtual IEnumerable`1<ProgramState> TrySetConstraint(SymbolicConstraint constraint, ProgramState programState);
    public virtual IEnumerable`1<ProgramState> TrySetOppositeConstraint(SymbolicConstraint constraint, ProgramState programState);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.OrSymbolicValue : BoolBinarySymbolicValue {
    public OrSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, ProgramState programState);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_0(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_1(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_2(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_3(ProgramState ps);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ReferenceEqualsSymbolicValue : EqualsSymbolicValue {
    public ReferenceEqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual BinaryRelationship GetRelationship(SymbolicValue left, SymbolicValue right);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ReferenceNotEqualsSymbolicValue : NotEqualsSymbolicValue {
    public ReferenceNotEqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual BinaryRelationship GetRelationship(SymbolicValue left, SymbolicValue right);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.RelationalSymbolicValue : BinarySymbolicValue {
    protected RelationalSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
}
public enum SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.SymbolicComparisonKind : Enum {
    public int value__;
    public static SymbolicComparisonKind Less;
    public static SymbolicComparisonKind LessOrEqual;
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.UnarySymbolicValue : SymbolicValue {
    [CompilerGeneratedAttribute]
private SymbolicValue <Operand>k__BackingField;
    internal SymbolicValue Operand { get; }
    public UnarySymbolicValue(SymbolicValue operand);
    [CompilerGeneratedAttribute]
internal SymbolicValue get_Operand();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ValueEqualsSymbolicValue : EqualsSymbolicValue {
    public ValueEqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual BinaryRelationship GetRelationship(SymbolicValue left, SymbolicValue right);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.ValueNotEqualsSymbolicValue : NotEqualsSymbolicValue {
    public ValueNotEqualsSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual BinaryRelationship GetRelationship(SymbolicValue left, SymbolicValue right);
    public virtual string ToString();
}
public class SonarAnalyzer.SymbolicExecution.Sonar.SymbolicValues.XorSymbolicValue : BoolBinarySymbolicValue {
    public XorSymbolicValue(SymbolicValue leftOperand, SymbolicValue rightOperand);
    protected virtual IEnumerable`1<ProgramState> TrySetBoolConstraint(BoolConstraint constraint, ProgramState programState);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_0(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_1(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_2(ProgramState ps);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProgramState> <TrySetBoolConstraint>b__1_3(ProgramState ps);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.TooManyInternalStatesException : Exception {
    public TooManyInternalStatesException(string message);
    public TooManyInternalStatesException(string message, Exception innerException);
    [ExcludeFromCodeCoverageAttribute]
protected TooManyInternalStatesException(SerializationInfo info, StreamingContext context);
}
public class SonarAnalyzer.SymbolicExecution.Sonar.VisitCountExceedLimitEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ProgramPoint <ProgramPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramState <ProgramState>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    public ProgramPoint ProgramPoint { get; public set; }
    public ProgramState ProgramState { get; public set; }
    public int Limit { get; public set; }
    [CompilerGeneratedAttribute]
public ProgramPoint get_ProgramPoint();
    [CompilerGeneratedAttribute]
public void set_ProgramPoint(ProgramPoint value);
    [CompilerGeneratedAttribute]
public ProgramState get_ProgramState();
    [CompilerGeneratedAttribute]
public void set_ProgramState(ProgramState value);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
}
public interface SonarAnalyzer.Wrappers.IMethodDeclaration {
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public bool HasImplementation { get; }
    public bool IsLocal { get; }
    public abstract virtual BlockSyntax get_Body();
    public abstract virtual ArrowExpressionClauseSyntax get_ExpressionBody();
    public abstract virtual SyntaxToken get_Identifier();
    public abstract virtual ParameterListSyntax get_ParameterList();
    public abstract virtual TypeParameterListSyntax get_TypeParameterList();
    public abstract virtual bool get_HasImplementation();
    public abstract virtual bool get_IsLocal();
}
internal interface SonarAnalyzer.Wrappers.IObjectCreation {
    public InitializerExpressionSyntax Initializer { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public ExpressionSyntax Expression { get; }
    public IEnumerable`1<ExpressionSyntax> InitializerExpressions { get; }
    public abstract virtual InitializerExpressionSyntax get_Initializer();
    public abstract virtual ArgumentListSyntax get_ArgumentList();
    public abstract virtual ExpressionSyntax get_Expression();
    public abstract virtual IEnumerable`1<ExpressionSyntax> get_InitializerExpressions();
    public abstract virtual bool IsKnownType(KnownType knownType, SemanticModel semanticModel);
    public abstract virtual string TypeAsString(SemanticModel semanticModel);
    public abstract virtual ITypeSymbol TypeSymbol(SemanticModel semanticModel);
    public abstract virtual IMethodSymbol MethodSymbol(SemanticModel semanticModel);
}
internal static class SonarAnalyzer.Wrappers.MethodDeclarationFactory : object {
    public static IMethodDeclaration Create(SyntaxNode node);
}
internal class SonarAnalyzer.Wrappers.ObjectCreationFactory : object {
    public static IObjectCreation Create(SyntaxNode node);
    public static IObjectCreation TryCreate(SyntaxNode node);
    public static bool TryCreate(SyntaxNode node, IObjectCreation& objectCreation);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
