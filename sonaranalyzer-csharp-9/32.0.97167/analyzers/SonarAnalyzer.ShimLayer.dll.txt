[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
[ExtensionAttribute]
public static class SonarAnalyzer.ShimLayer.AnalysisContext.CompilationStartAnalysisContextExtensions : object {
    private static Action`3<CompilationStartAnalysisContext, Action`1<SymbolStartAnalysisContextWrapper>, SymbolKind> RegisterSymbolStartActionWrapper;
    private static CompilationStartAnalysisContextExtensions();
    [ExtensionAttribute]
public static void RegisterSymbolStartAction(CompilationStartAnalysisContext context, Action`1<SymbolStartAnalysisContextWrapper> action, SymbolKind symbolKind);
    [ExcludeFromCodeCoverageAttribute]
private static Action`3<CompilationStartAnalysisContext, Action`1<SymbolStartAnalysisContextWrapper>, SymbolKind> CreateRegisterSymbolStartAnalysisWrapper();
}
[IsReadOnlyAttribute]
public class SonarAnalyzer.ShimLayer.AnalysisContext.SymbolStartAnalysisContextWrapper : ValueType {
    private static string VBSyntaxKind;
    private static Func`2<object, CancellationToken> CancellationTokenAccessor;
    private static Func`2<object, Compilation> CompilationAccessor;
    private static Func`2<object, AnalyzerOptions> OptionsAccessor;
    private static Func`2<object, ISymbol> SymbolAccessor;
    private static Action`2<object, Action`1<CodeBlockAnalysisContext>> RegisterCodeBlockActionMethod;
    private static Action`2<object, Action`1<CodeBlockStartAnalysisContext`1<SyntaxKind>>> RegisterCodeBlockStartActionCS;
    private static Action`2<object, Action`1<object>> RegisterCodeBlockStartActionVB;
    private static Action`3<object, Action`1<OperationAnalysisContext>, ImmutableArray`1<OperationKind>> RegisterOperationActionMethod;
    private static Action`2<object, Action`1<OperationBlockAnalysisContext>> RegisterOperationBlockActionMethod;
    private static Action`2<object, Action`1<OperationBlockStartAnalysisContext>> RegisterOperationBlockStartActionMethod;
    private static Action`2<object, Action`1<SymbolAnalysisContext>> RegisterSymbolEndActionMethod;
    private static Action`3<object, Action`1<SyntaxNodeAnalysisContext>, ImmutableArray`1<SyntaxKind>> RegisterSyntaxNodeActionCS;
    private static Action`3<object, Action`1<SyntaxNodeAnalysisContext>, object> RegisterSyntaxNodeActionVB;
    [CompilerGeneratedAttribute]
private object <RoslynSymbolStartAnalysisContext>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public ISymbol Symbol { get; }
    private object RoslynSymbolStartAnalysisContext { get; }
    [ExcludeFromCodeCoverageAttribute]
private static SymbolStartAnalysisContextWrapper();
    public SymbolStartAnalysisContextWrapper(object roslynSymbolStartAnalysisContext);
    public CancellationToken get_CancellationToken();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
private object get_RoslynSymbolStartAnalysisContext();
    public void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public void RegisterSymbolEndAction(Action`1<SymbolAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    [CompilerGeneratedAttribute]
internal static Func`2<object, TProperty> <.cctor>g__CreatePropertyAccessor|25_0(string propertyName, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Action`2<object, Action`1<TContext>> <.cctor>g__CreateRegistrationMethod|25_1(string registrationMethodName, Type[] typeArguments, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Action`2<object, Action`1<object>> <.cctor>g__CreateRegistrationMethodCodeBlockStart|25_2(Type languageKindEnumType, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Action`3<object, Action`1<TContext>, TParameter> <.cctor>g__CreateRegistrationMethodWithAdditionalParameter|25_3(string registrationMethodName, Type[] typeArguments, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Action`3<object, Action`1<SyntaxNodeAnalysisContext>, object> <.cctor>g__CreateRegistrationMethodSyntaxNode|25_4(Type languageKindEnumType, <>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Type <.cctor>g__LoadSymbolStartAnalysisContextType|25_5();
    [CompilerGeneratedAttribute]
internal static Type <.cctor>g__LoadLanguageKindEnumVBType|25_6();
}
internal static class SonarAnalyzer.Signing : object {
    private static string PublicKey;
    internal static string InternalsVisibleToPublicKey;
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.AccessorDeclarationSyntaxExtensions : object {
    private static Func`2<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`3<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax, AccessorDeclarationSyntax> WithExpressionBodyAccessor;
    private static AccessorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(AccessorDeclarationSyntax syntax);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.AllowsConstraintClauseSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeParameterConstraintSyntax, SyntaxToken> AllowsKeywordAccessor;
    private static Func`2<TypeParameterConstraintSyntax, SeparatedSyntaxListWrapper`1<AllowsConstraintSyntaxWrapper>> ConstraintsAccessor;
    private static Func`3<TypeParameterConstraintSyntax, SyntaxToken, TypeParameterConstraintSyntax> WithAllowsKeywordAccessor;
    private static Func`3<TypeParameterConstraintSyntax, SeparatedSyntaxListWrapper`1<AllowsConstraintSyntaxWrapper>, TypeParameterConstraintSyntax> WithConstraintsAccessor;
    private TypeParameterConstraintSyntax node;
    public TypeParameterConstraintSyntax SyntaxNode { get; }
    public SyntaxToken AllowsKeyword { get; }
    public SeparatedSyntaxListWrapper`1<AllowsConstraintSyntaxWrapper> Constraints { get; }
    private static AllowsConstraintClauseSyntaxWrapper();
    private AllowsConstraintClauseSyntaxWrapper(TypeParameterConstraintSyntax node);
    public sealed virtual TypeParameterConstraintSyntax get_SyntaxNode();
    public SyntaxToken get_AllowsKeyword();
    public SeparatedSyntaxListWrapper`1<AllowsConstraintSyntaxWrapper> get_Constraints();
    public static AllowsConstraintClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeParameterConstraintSyntax op_Implicit(AllowsConstraintClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public AllowsConstraintClauseSyntaxWrapper WithAllowsKeyword(SyntaxToken allowsKeyword);
    public AllowsConstraintClauseSyntaxWrapper WithConstraints(SeparatedSyntaxListWrapper`1<AllowsConstraintSyntaxWrapper> constraints);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.AllowsConstraintSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static AllowsConstraintSyntaxWrapper();
    private AllowsConstraintSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static AllowsConstraintSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(AllowsConstraintSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public static AllowsConstraintSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.AnalyzerConfigOptionsProviderWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<object, object> GlobalOptionsAccessor;
    private static Func`3<object, SyntaxTree, object> GetOptionsSyntaxTreeAccessor;
    private static Func`3<object, AdditionalText, object> GetOptionsAdditionalTextAccessor;
    private object node;
    public AnalyzerConfigOptionsWrapper GlobalOptions { get; }
    private static AnalyzerConfigOptionsProviderWrapper();
    private AnalyzerConfigOptionsProviderWrapper(object node);
    public AnalyzerConfigOptionsWrapper get_GlobalOptions();
    public static AnalyzerConfigOptionsProviderWrapper FromObject(object node);
    public static bool IsInstance(object obj);
    public AnalyzerConfigOptionsWrapper GetOptions(SyntaxTree tree);
    public AnalyzerConfigOptionsWrapper GetOptions(AdditionalText textFile);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.AnalyzerConfigOptionsWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`1<StringComparer> KeyComparerAccessor;
    private static TryGetValueAccessor`3<object, string, string> TryGetValueAccessor;
    private object node;
    public static StringComparer KeyComparer { get; }
    private static AnalyzerConfigOptionsWrapper();
    private AnalyzerConfigOptionsWrapper(object node);
    public static StringComparer get_KeyComparer();
    public static AnalyzerConfigOptionsWrapper FromObject(object node);
    public static bool IsInstance(object obj);
    public bool TryGetValue(string key, String& value);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.AnalyzerOptionsExtensions : object {
    private static Func`2<AnalyzerOptions, object> AnalyzerConfigOptionsProviderAccessor;
    private static AnalyzerOptionsExtensions();
    [ExtensionAttribute]
public static AnalyzerConfigOptionsProviderWrapper AnalyzerConfigOptionsProvider(AnalyzerOptions options);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.AnonymousFunctionExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<ExpressionSyntax, BlockSyntax> BlockAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionBodyAccessor;
    private static Func`3<ExpressionSyntax, SyntaxTokenList, ExpressionSyntax> WithModifiersAccessor;
    private static Func`3<ExpressionSyntax, BlockSyntax, ExpressionSyntax> WithBlockAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionBodyAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxTokenList Modifiers { get; }
    public BlockSyntax Block { get; }
    public ExpressionSyntax ExpressionBody { get; }
    private static AnonymousFunctionExpressionSyntaxWrapper();
    private AnonymousFunctionExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxTokenList get_Modifiers();
    public BlockSyntax get_Block();
    public ExpressionSyntax get_ExpressionBody();
    public static AnonymousFunctionExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(AnonymousFunctionExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public AnonymousFunctionExpressionSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public AnonymousFunctionExpressionSyntaxWrapper WithBlock(BlockSyntax block);
    public AnonymousFunctionExpressionSyntaxWrapper WithExpressionBody(ExpressionSyntax expressionBody);
    public static AnonymousFunctionExpressionSyntaxWrapper FromUpcast(ExpressionSyntax node);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ArgumentSyntaxExtensions : object {
    private static Func`2<ArgumentSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<ArgumentSyntax, SyntaxToken, ArgumentSyntax> WithRefKindKeywordAccessor;
    private static ArgumentSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(ArgumentSyntax syntax);
    [ExtensionAttribute]
public static ArgumentSyntax WithRefKindKeyword(ArgumentSyntax syntax, SyntaxToken refKindKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.BaseExpressionColonSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> ColonTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithColonTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken ColonToken { get; }
    private static BaseExpressionColonSyntaxWrapper();
    private BaseExpressionColonSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_ColonToken();
    public static BaseExpressionColonSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(BaseExpressionColonSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseExpressionColonSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public BaseExpressionColonSyntaxWrapper WithColonToken(SyntaxToken colonToken);
    public static BaseExpressionColonSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.BaseMethodDeclarationSyntaxExtensions : object {
    private static Func`2<BaseMethodDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static BaseMethodDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(BaseMethodDeclarationSyntax syntax);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.BaseNamespaceDeclarationSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<MemberDeclarationSyntax, SyntaxToken> NamespaceKeywordAccessor;
    private static Func`2<MemberDeclarationSyntax, NameSyntax> NameAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>> ExternsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>> UsingsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>> MembersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithNamespaceKeywordAccessor;
    private static Func`3<MemberDeclarationSyntax, NameSyntax, MemberDeclarationSyntax> WithNameAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>, MemberDeclarationSyntax> WithExternsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>, MemberDeclarationSyntax> WithUsingsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, MemberDeclarationSyntax> WithMembersAccessor;
    private MemberDeclarationSyntax node;
    public MemberDeclarationSyntax SyntaxNode { get; }
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    private static BaseNamespaceDeclarationSyntaxWrapper();
    private BaseNamespaceDeclarationSyntaxWrapper(MemberDeclarationSyntax node);
    public static BaseNamespaceDeclarationSyntaxWrapper op_Implicit(NamespaceDeclarationSyntax node);
    public sealed virtual MemberDeclarationSyntax get_SyntaxNode();
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public static BaseNamespaceDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static MemberDeclarationSyntax op_Implicit(BaseNamespaceDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseNamespaceDeclarationSyntaxWrapper WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public BaseNamespaceDeclarationSyntaxWrapper WithName(NameSyntax name);
    public BaseNamespaceDeclarationSyntaxWrapper WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public BaseNamespaceDeclarationSyntaxWrapper WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public BaseNamespaceDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public static BaseNamespaceDeclarationSyntaxWrapper FromUpcast(MemberDeclarationSyntax node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.BaseObjectCreationExpressionSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> NewKeywordAccessor;
    private static Func`2<ExpressionSyntax, ArgumentListSyntax> ArgumentListAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithNewKeywordAccessor;
    private static Func`3<ExpressionSyntax, ArgumentListSyntax, ExpressionSyntax> WithArgumentListAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken NewKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static BaseObjectCreationExpressionSyntaxWrapper();
    private BaseObjectCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public static BaseObjectCreationExpressionSyntaxWrapper op_Implicit(ObjectCreationExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_NewKeyword();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    public static BaseObjectCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(BaseObjectCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseObjectCreationExpressionSyntaxWrapper WithNewKeyword(SyntaxToken newKeyword);
    public BaseObjectCreationExpressionSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
    public BaseObjectCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
    public static BaseObjectCreationExpressionSyntaxWrapper FromUpcast(ExpressionSyntax node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.BaseParameterSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>, CSharpSyntaxNode> WithAttributeListsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxTokenList, CSharpSyntaxNode> WithModifiersAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    private static BaseParameterSyntaxWrapper();
    private BaseParameterSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public static BaseParameterSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(BaseParameterSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseParameterSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public BaseParameterSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public BaseParameterSyntaxWrapper WithType(TypeSyntax type);
    public static BaseParameterSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
public enum StyleCop.Analyzers.Lightup.BinaryOperatorKind : Enum {
    public int value__;
    public static BinaryOperatorKind None;
    public static BinaryOperatorKind Add;
    public static BinaryOperatorKind Subtract;
    public static BinaryOperatorKind Multiply;
    public static BinaryOperatorKind Divide;
    public static BinaryOperatorKind IntegerDivide;
    public static BinaryOperatorKind Remainder;
    public static BinaryOperatorKind Power;
    public static BinaryOperatorKind LeftShift;
    public static BinaryOperatorKind RightShift;
    public static BinaryOperatorKind And;
    public static BinaryOperatorKind Or;
    public static BinaryOperatorKind ExclusiveOr;
    public static BinaryOperatorKind ConditionalAnd;
    public static BinaryOperatorKind ConditionalOr;
    public static BinaryOperatorKind Concatenate;
    public static BinaryOperatorKind Equals;
    public static BinaryOperatorKind ObjectValueEquals;
    public static BinaryOperatorKind NotEquals;
    public static BinaryOperatorKind ObjectValueNotEquals;
    public static BinaryOperatorKind LessThan;
    public static BinaryOperatorKind LessThanOrEqual;
    public static BinaryOperatorKind GreaterThanOrEqual;
    public static BinaryOperatorKind GreaterThan;
    public static BinaryOperatorKind Like;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.BinaryPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> LeftAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> RightAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithLeftAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithRightAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public PatternSyntaxWrapper Left { get; }
    public SyntaxToken OperatorToken { get; }
    public PatternSyntaxWrapper Right { get; }
    private static BinaryPatternSyntaxWrapper();
    private BinaryPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public PatternSyntaxWrapper get_Left();
    public SyntaxToken get_OperatorToken();
    public PatternSyntaxWrapper get_Right();
    public static BinaryPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static BinaryPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static BinaryPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BinaryPatternSyntaxWrapper WithLeft(PatternSyntaxWrapper left);
    public BinaryPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public BinaryPatternSyntaxWrapper WithRight(PatternSyntaxWrapper right);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CaptureId : ValueType {
    private object instance;
    public CaptureId(object instance);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CaptureId other);
    public virtual int GetHashCode();
    public string Serialize();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CasePatternSwitchLabelSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> WhenClauseAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithKeywordAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithPatternAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithWhenClauseAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithColonTokenAccessor;
    private SwitchLabelSyntax node;
    public SwitchLabelSyntax SyntaxNode { get; }
    public SyntaxToken Keyword { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public WhenClauseSyntaxWrapper WhenClause { get; }
    public SyntaxToken ColonToken { get; }
    private static CasePatternSwitchLabelSyntaxWrapper();
    private CasePatternSwitchLabelSyntaxWrapper(SwitchLabelSyntax node);
    public sealed virtual SwitchLabelSyntax get_SyntaxNode();
    public SyntaxToken get_Keyword();
    public PatternSyntaxWrapper get_Pattern();
    public WhenClauseSyntaxWrapper get_WhenClause();
    public SyntaxToken get_ColonToken();
    public static CasePatternSwitchLabelSyntaxWrapper op_Explicit(SyntaxNode node);
    public static SwitchLabelSyntax op_Implicit(CasePatternSwitchLabelSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CasePatternSwitchLabelSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public CasePatternSwitchLabelSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public CasePatternSwitchLabelSyntaxWrapper WithWhenClause(WhenClauseSyntaxWrapper whenClause);
    public CasePatternSwitchLabelSyntaxWrapper WithColonToken(SyntaxToken colonToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ClassDeclarationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, TypeDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxTokenList, TypeDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithIdentifierAccessor;
    private static Func`3<TypeDeclarationSyntax, TypeParameterListSyntax, TypeDeclarationSyntax> WithTypeParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, ParameterListSyntax, TypeDeclarationSyntax> WithParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, BaseListSyntax, TypeDeclarationSyntax> WithBaseListAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, TypeDeclarationSyntax> WithConstraintClausesAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, TypeDeclarationSyntax> WithMembersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithCloseBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithSemicolonTokenAccessor;
    private TypeDeclarationSyntax node;
    public TypeDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    private static ClassDeclarationSyntaxWrapper();
    private ClassDeclarationSyntaxWrapper(TypeDeclarationSyntax node);
    public sealed virtual TypeDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Keyword();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public BaseListSyntax get_BaseList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    public static ClassDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeDeclarationSyntax op_Implicit(ClassDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ClassDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ClassDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public ClassDeclarationSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public ClassDeclarationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public ClassDeclarationSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public ClassDeclarationSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public ClassDeclarationSyntaxWrapper WithBaseList(BaseListSyntax baseList);
    public ClassDeclarationSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public ClassDeclarationSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public ClassDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public ClassDeclarationSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
    public ClassDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ClassOrStructConstraintSyntaxExtensions : object {
    private static Func`2<ClassOrStructConstraintSyntax, SyntaxToken> QuestionTokenAccessor;
    private static Func`3<ClassOrStructConstraintSyntax, SyntaxToken, ClassOrStructConstraintSyntax> WithQuestionTokenAccessor;
    private static ClassOrStructConstraintSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken QuestionToken(ClassOrStructConstraintSyntax syntax);
    [ExtensionAttribute]
public static ClassOrStructConstraintSyntax WithQuestionToken(ClassOrStructConstraintSyntax syntax, SyntaxToken questionToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CollectionElementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static CollectionElementSyntaxWrapper();
    private CollectionElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static CollectionElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(CollectionElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public static CollectionElementSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CollectionExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxListWrapper`1<CollectionElementSyntaxWrapper>> ElementsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxListWrapper`1<CollectionElementSyntaxWrapper>, ExpressionSyntax> WithElementsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBracketTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxListWrapper`1<CollectionElementSyntaxWrapper> Elements { get; }
    public SyntaxToken CloseBracketToken { get; }
    private static CollectionExpressionSyntaxWrapper();
    private CollectionExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxListWrapper`1<CollectionElementSyntaxWrapper> get_Elements();
    public SyntaxToken get_CloseBracketToken();
    public static CollectionExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(CollectionExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CollectionExpressionSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public CollectionExpressionSyntaxWrapper WithElements(SeparatedSyntaxListWrapper`1<CollectionElementSyntaxWrapper> elements);
    public CollectionExpressionSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CommonForEachStatementSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> ForEachKeywordAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> InKeywordAccessor;
    private static Func`2<StatementSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`2<StatementSyntax, StatementSyntax> StatementAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithForEachKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithOpenParenTokenAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithInKeywordAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithExpressionAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithCloseParenTokenAccessor;
    private static Func`3<StatementSyntax, StatementSyntax, StatementSyntax> WithStatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxToken AwaitKeyword { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static CommonForEachStatementSyntaxWrapper();
    private CommonForEachStatementSyntaxWrapper(StatementSyntax node);
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachStatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxToken get_AwaitKeyword();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static CommonForEachStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(CommonForEachStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CommonForEachStatementSyntaxWrapper WithAwaitKeyword(SyntaxToken awaitKeyword);
    public CommonForEachStatementSyntaxWrapper WithForEachKeyword(SyntaxToken forEachKeyword);
    public CommonForEachStatementSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public CommonForEachStatementSyntaxWrapper WithInKeyword(SyntaxToken inKeyword);
    public CommonForEachStatementSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public CommonForEachStatementSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
    public CommonForEachStatementSyntaxWrapper WithStatement(StatementSyntax statement);
    public static CommonForEachStatementSyntaxWrapper FromUpcast(StatementSyntax node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.CompilationOptionsWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CompilationOptions, object> SyntaxTreeOptionsProviderAccessor;
    private CompilationOptions node;
    public SyntaxTreeOptionsProviderWrapper SyntaxTreeOptionsProvider { get; }
    private static CompilationOptionsWrapper();
    private CompilationOptionsWrapper(CompilationOptions node);
    public SyntaxTreeOptionsProviderWrapper get_SyntaxTreeOptionsProvider();
    public static CompilationOptionsWrapper FromObject(CompilationOptions node);
    public static bool IsInstance(object obj);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ConstantPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    private static ConstantPatternSyntaxWrapper();
    private ConstantPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public static ConstantPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ConstantPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static ConstantPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ConstantPatternSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ConstructorDeclarationSyntaxExtensions : object {
    private static Func`3<ConstructorDeclarationSyntax, ArrowExpressionClauseSyntax, ConstructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static ConstructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.CrefParameterSyntaxExtensions : object {
    private static Func`2<CrefParameterSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<CrefParameterSyntax, SyntaxToken, CrefParameterSyntax> WithRefKindKeywordAccessor;
    private static CrefParameterSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(CrefParameterSyntax syntax);
    [ExtensionAttribute]
public static CrefParameterSyntax WithRefKindKeyword(CrefParameterSyntax syntax, SyntaxToken refKindKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.DeclarationExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, TypeSyntax> TypeAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<ExpressionSyntax, TypeSyntax, ExpressionSyntax> WithTypeAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithDesignationAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationExpressionSyntaxWrapper();
    private DeclarationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(DeclarationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationExpressionSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationExpressionSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.DeclarationPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationPatternSyntaxWrapper();
    private DeclarationPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static DeclarationPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static DeclarationPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationPatternSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.DefaultConstraintSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeParameterConstraintSyntax, SyntaxToken> DefaultKeywordAccessor;
    private static Func`3<TypeParameterConstraintSyntax, SyntaxToken, TypeParameterConstraintSyntax> WithDefaultKeywordAccessor;
    private TypeParameterConstraintSyntax node;
    public TypeParameterConstraintSyntax SyntaxNode { get; }
    public SyntaxToken DefaultKeyword { get; }
    private static DefaultConstraintSyntaxWrapper();
    private DefaultConstraintSyntaxWrapper(TypeParameterConstraintSyntax node);
    public sealed virtual TypeParameterConstraintSyntax get_SyntaxNode();
    public SyntaxToken get_DefaultKeyword();
    public static DefaultConstraintSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeParameterConstraintSyntax op_Implicit(DefaultConstraintSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DefaultConstraintSyntaxWrapper WithDefaultKeyword(SyntaxToken defaultKeyword);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.DestructorDeclarationSyntaxExtensions : object {
    private static Func`3<DestructorDeclarationSyntax, ArrowExpressionClauseSyntax, DestructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static DestructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static DestructorDeclarationSyntax WithExpressionBody(DestructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.DiscardDesignationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> UnderscoreTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithUnderscoreTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken UnderscoreToken { get; }
    private static DiscardDesignationSyntaxWrapper();
    private DiscardDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_UnderscoreToken();
    public static DiscardDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static DiscardDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DiscardDesignationSyntaxWrapper WithUnderscoreToken(SyntaxToken underscoreToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.DiscardPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> UnderscoreTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithUnderscoreTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken UnderscoreToken { get; }
    private static DiscardPatternSyntaxWrapper();
    private DiscardPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_UnderscoreToken();
    public static DiscardPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static DiscardPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static DiscardPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DiscardPatternSyntaxWrapper WithUnderscoreToken(SyntaxToken underscoreToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ExpressionColonSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithColonTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken ColonToken { get; }
    private static ExpressionColonSyntaxWrapper();
    private ExpressionColonSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_ColonToken();
    public static ExpressionColonSyntaxWrapper op_Explicit(BaseExpressionColonSyntaxWrapper node);
    public static ExpressionColonSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseExpressionColonSyntaxWrapper op_Implicit(ExpressionColonSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ExpressionColonSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ExpressionColonSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public ExpressionColonSyntaxWrapper WithColonToken(SyntaxToken colonToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ExpressionElementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    private static ExpressionElementSyntaxWrapper();
    private ExpressionElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public static ExpressionElementSyntaxWrapper op_Explicit(CollectionElementSyntaxWrapper node);
    public static ExpressionElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CollectionElementSyntaxWrapper op_Implicit(ExpressionElementSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ExpressionElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ExpressionElementSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ExpressionOrPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static ExpressionOrPatternSyntaxWrapper();
    private ExpressionOrPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static ExpressionOrPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(ExpressionOrPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public static ExpressionOrPatternSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FileScopedNamespaceDeclarationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<MemberDeclarationSyntax, SyntaxToken> SemicolonTokenAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, MemberDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxTokenList, MemberDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithNamespaceKeywordAccessor;
    private static Func`3<MemberDeclarationSyntax, NameSyntax, MemberDeclarationSyntax> WithNameAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithSemicolonTokenAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>, MemberDeclarationSyntax> WithExternsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>, MemberDeclarationSyntax> WithUsingsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, MemberDeclarationSyntax> WithMembersAccessor;
    private MemberDeclarationSyntax node;
    public MemberDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxToken SemicolonToken { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    private static FileScopedNamespaceDeclarationSyntaxWrapper();
    private FileScopedNamespaceDeclarationSyntaxWrapper(MemberDeclarationSyntax node);
    public sealed virtual MemberDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxToken get_SemicolonToken();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public static FileScopedNamespaceDeclarationSyntaxWrapper op_Explicit(BaseNamespaceDeclarationSyntaxWrapper node);
    public static FileScopedNamespaceDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseNamespaceDeclarationSyntaxWrapper op_Implicit(FileScopedNamespaceDeclarationSyntaxWrapper wrapper);
    public static MemberDeclarationSyntax op_Implicit(FileScopedNamespaceDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithName(NameSyntax name);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ForEachStatementSyntaxExtensions : object {
    private static Func`2<ForEachStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`3<ForEachStatementSyntax, SyntaxToken, ForEachStatementSyntax> WithAwaitKeywordAccessor;
    private static ForEachStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(ForEachStatementSyntax syntax);
    [ExtensionAttribute]
public static ForEachStatementSyntax WithAwaitKeyword(ForEachStatementSyntax syntax, SyntaxToken awaitKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ForEachVariableStatementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, ExpressionSyntax> VariableAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithForEachKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithOpenParenTokenAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithVariableAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithInKeywordAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithExpressionAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithCloseParenTokenAccessor;
    private static Func`3<StatementSyntax, StatementSyntax, StatementSyntax> WithStatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken AwaitKeyword { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Variable { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static ForEachVariableStatementSyntaxWrapper();
    private ForEachVariableStatementSyntaxWrapper(StatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_AwaitKeyword();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Variable();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(CommonForEachStatementSyntaxWrapper node);
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static StatementSyntax op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ForEachVariableStatementSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ForEachVariableStatementSyntaxWrapper WithAwaitKeyword(SyntaxToken awaitKeyword);
    public ForEachVariableStatementSyntaxWrapper WithForEachKeyword(SyntaxToken forEachKeyword);
    public ForEachVariableStatementSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ForEachVariableStatementSyntaxWrapper WithVariable(ExpressionSyntax variable);
    public ForEachVariableStatementSyntaxWrapper WithInKeyword(SyntaxToken inKeyword);
    public ForEachVariableStatementSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public ForEachVariableStatementSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
    public ForEachVariableStatementSyntaxWrapper WithStatement(StatementSyntax statement);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerCallingConventionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> ManagedOrUnmanagedKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> UnmanagedCallingConventionListAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithManagedOrUnmanagedKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithUnmanagedCallingConventionListAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken ManagedOrUnmanagedKeyword { get; }
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper UnmanagedCallingConventionList { get; }
    private static FunctionPointerCallingConventionSyntaxWrapper();
    private FunctionPointerCallingConventionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_ManagedOrUnmanagedKeyword();
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper get_UnmanagedCallingConventionList();
    public static FunctionPointerCallingConventionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerCallingConventionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerCallingConventionSyntaxWrapper WithManagedOrUnmanagedKeyword(SyntaxToken managedOrUnmanagedKeyword);
    public FunctionPointerCallingConventionSyntaxWrapper WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntaxWrapper unmanagedCallingConventionList);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerParameterListSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> LessThanTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper>> ParametersAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> GreaterThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithLessThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper>, CSharpSyntaxNode> WithParametersAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithGreaterThanTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> Parameters { get; }
    public SyntaxToken GreaterThanToken { get; }
    private static FunctionPointerParameterListSyntaxWrapper();
    private FunctionPointerParameterListSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> get_Parameters();
    public SyntaxToken get_GreaterThanToken();
    public static FunctionPointerParameterListSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerParameterListSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerParameterListSyntaxWrapper WithLessThanToken(SyntaxToken lessThanToken);
    public FunctionPointerParameterListSyntaxWrapper WithParameters(SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> parameters);
    public FunctionPointerParameterListSyntaxWrapper WithGreaterThanToken(SyntaxToken greaterThanToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerParameterSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>, CSharpSyntaxNode> WithAttributeListsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxTokenList, CSharpSyntaxNode> WithModifiersAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    private static FunctionPointerParameterSyntaxWrapper();
    private FunctionPointerParameterSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public static FunctionPointerParameterSyntaxWrapper op_Explicit(BaseParameterSyntaxWrapper node);
    public static FunctionPointerParameterSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseParameterSyntaxWrapper op_Implicit(FunctionPointerParameterSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerParameterSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerParameterSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FunctionPointerParameterSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public FunctionPointerParameterSyntaxWrapper WithType(TypeSyntax type);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerTypeSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> DelegateKeywordAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> AsteriskTokenAccessor;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> CallingConventionAccessor;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> ParameterListAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithDelegateKeywordAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithAsteriskTokenAccessor;
    private static Func`3<TypeSyntax, CSharpSyntaxNode, TypeSyntax> WithCallingConventionAccessor;
    private static Func`3<TypeSyntax, CSharpSyntaxNode, TypeSyntax> WithParameterListAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken DelegateKeyword { get; }
    public SyntaxToken AsteriskToken { get; }
    public FunctionPointerCallingConventionSyntaxWrapper CallingConvention { get; }
    public FunctionPointerParameterListSyntaxWrapper ParameterList { get; }
    private static FunctionPointerTypeSyntaxWrapper();
    private FunctionPointerTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_DelegateKeyword();
    public SyntaxToken get_AsteriskToken();
    public FunctionPointerCallingConventionSyntaxWrapper get_CallingConvention();
    public FunctionPointerParameterListSyntaxWrapper get_ParameterList();
    public static FunctionPointerTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(FunctionPointerTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerTypeSyntaxWrapper WithDelegateKeyword(SyntaxToken delegateKeyword);
    public FunctionPointerTypeSyntaxWrapper WithAsteriskToken(SyntaxToken asteriskToken);
    public FunctionPointerTypeSyntaxWrapper WithCallingConvention(FunctionPointerCallingConventionSyntaxWrapper callingConvention);
    public FunctionPointerTypeSyntaxWrapper WithParameterList(FunctionPointerParameterListSyntaxWrapper parameterList);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerUnmanagedCallingConventionListSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper>> CallingConventionsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper>, CSharpSyntaxNode> WithCallingConventionsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseBracketTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> CallingConventions { get; }
    public SyntaxToken CloseBracketToken { get; }
    private static FunctionPointerUnmanagedCallingConventionListSyntaxWrapper();
    private FunctionPointerUnmanagedCallingConventionListSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> get_CallingConventions();
    public SyntaxToken get_CloseBracketToken();
    public static FunctionPointerUnmanagedCallingConventionListSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerUnmanagedCallingConventionListSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithCallingConventions(SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> callingConventions);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.FunctionPointerUnmanagedCallingConventionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> NameAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithNameAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Name { get; }
    private static FunctionPointerUnmanagedCallingConventionSyntaxWrapper();
    private FunctionPointerUnmanagedCallingConventionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Name();
    public static FunctionPointerUnmanagedCallingConventionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerUnmanagedCallingConventionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerUnmanagedCallingConventionSyntaxWrapper WithName(SyntaxToken name);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAddressOfOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ReferenceAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Reference { get; }
    private static IAddressOfOperationWrapper();
    private IAddressOfOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Reference();
    public static IAddressOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAnonymousFunctionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    public IBlockOperationWrapper Body { get; }
    private static IAnonymousFunctionOperationWrapper();
    private IAnonymousFunctionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public IBlockOperationWrapper get_Body();
    public static IAnonymousFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAnonymousObjectCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> InitializersAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    private static IAnonymousObjectCreationOperationWrapper();
    private IAnonymousObjectCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Initializers();
    public static IAnonymousObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IArgumentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object ArgumentKind { get; }
    [NullableAttribute("2")]
public IParameterSymbol Parameter { get; }
    public IOperation Value { get; }
    public object InConversion { get; }
    public object OutConversion { get; }
    private static IArgumentOperationWrapper();
    private IArgumentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_ArgumentKind();
    [NullableContextAttribute("2")]
public IParameterSymbol get_Parameter();
    public IOperation get_Value();
    public object get_InConversion();
    public object get_OutConversion();
    public static IArgumentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IArrayCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DimensionSizesAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperationWrapper Initializer { get; }
    private static IArrayCreationOperationWrapper();
    private IArrayCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_DimensionSizes();
    public IArrayInitializerOperationWrapper get_Initializer();
    public static IArrayCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IArrayElementReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ArrayReferenceAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IndicesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    private static IArrayElementReferenceOperationWrapper();
    private IArrayElementReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_ArrayReference();
    public ImmutableArray`1<IOperation> get_Indices();
    public static IArrayElementReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IArrayInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ElementValuesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> ElementValues { get; }
    private static IArrayInitializerOperationWrapper();
    private IArrayInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_ElementValues();
    public static IArrayInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static IAssignmentOperationWrapper();
    private IAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Target();
    public IOperation get_Value();
    public static IAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static IAssignmentOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAttributeOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static IAttributeOperationWrapper();
    private IAttributeOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static IAttributeOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IAwaitOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static IAwaitOperationWrapper();
    private IAwaitOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static IAwaitOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IBinaryOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, BinaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, bool> IsCompareTextAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public bool IsCompareText { get; }
    [NullableAttribute("2")]
public IMethodSymbol OperatorMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IBinaryOperationWrapper();
    private IBinaryOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public BinaryOperatorKind get_OperatorKind();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public bool get_IsCompareText();
    [NullableContextAttribute("2")]
public IMethodSymbol get_OperatorMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IBinaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IBinaryPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, BinaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, IOperation> LeftPatternAccessor;
    private static Func`2<IOperation, IOperation> RightPatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public IPatternOperationWrapper LeftPattern { get; }
    public IPatternOperationWrapper RightPattern { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IBinaryPatternOperationWrapper();
    private IBinaryPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public BinaryOperatorKind get_OperatorKind();
    public IPatternOperationWrapper get_LeftPattern();
    public IPatternOperationWrapper get_RightPattern();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IBinaryPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IBinaryPatternOperationWrapper wrapper);
    public static IBinaryPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IBlockOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> OperationsAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Operations { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static IBlockOperationWrapper();
    private IBlockOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Operations();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static IBlockOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IBranchOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> TargetAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Target { get; }
    public object BranchKind { get; }
    private static IBranchOperationWrapper();
    private IBranchOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILabelSymbol get_Target();
    public object get_BranchKind();
    public static IBranchOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object CaseKind { get; }
    [NullableAttribute("2")]
public ILabelSymbol Label { get; }
    private static ICaseClauseOperationWrapper();
    private ICaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_CaseKind();
    [NullableContextAttribute("2")]
public ILabelSymbol get_Label();
    public static ICaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static ICaseClauseOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICatchClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExceptionDeclarationOrExpressionAccessor;
    private static Func`2<IOperation, ITypeSymbol> ExceptionTypeAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> FilterAccessor;
    private static Func`2<IOperation, IOperation> HandlerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ExceptionDeclarationOrExpression { get; }
    public ITypeSymbol ExceptionType { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Filter { get; }
    public IBlockOperationWrapper Handler { get; }
    private static ICatchClauseOperationWrapper();
    private ICatchClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_ExceptionDeclarationOrExpression();
    public ITypeSymbol get_ExceptionType();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Filter();
    public IBlockOperationWrapper get_Handler();
    public static ICatchClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICaughtExceptionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static ICaughtExceptionOperationWrapper();
    private ICaughtExceptionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static ICaughtExceptionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICoalesceAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ICoalesceAssignmentOperationWrapper();
    private ICoalesceAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Target();
    public IOperation get_Value();
    public static ICoalesceAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ICoalesceAssignmentOperationWrapper wrapper);
    public static ICoalesceAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICoalesceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, IOperation> WhenNullAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    public object ValueConversion { get; }
    private static ICoalesceOperationWrapper();
    private ICoalesceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public IOperation get_WhenNull();
    public object get_ValueConversion();
    public static ICoalesceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICollectionElementInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> AddMethodAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private static Func`2<IOperation, bool> IsDynamicAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol AddMethod { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public bool IsDynamic { get; }
    private static ICollectionElementInitializerOperationWrapper();
    private ICollectionElementInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_AddMethod();
    public ImmutableArray`1<IOperation> get_Arguments();
    public bool get_IsDynamic();
    public static ICollectionElementInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICollectionExpressionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> ConstructMethodAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ElementsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public IMethodSymbol ConstructMethod { get; }
    public ImmutableArray`1<IOperation> Elements { get; }
    private static ICollectionExpressionOperationWrapper();
    private ICollectionExpressionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
public IMethodSymbol get_ConstructMethod();
    public ImmutableArray`1<IOperation> get_Elements();
    public static ICollectionExpressionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ICompoundAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, BinaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object InConversion { get; }
    public object OutConversion { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    [NullableAttribute("2")]
public IMethodSymbol OperatorMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ICompoundAssignmentOperationWrapper();
    private ICompoundAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_InConversion();
    public object get_OutConversion();
    public BinaryOperatorKind get_OperatorKind();
    public bool get_IsLifted();
    public bool get_IsChecked();
    [NullableContextAttribute("2")]
public IMethodSymbol get_OperatorMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public IOperation get_Target();
    public IOperation get_Value();
    public static ICompoundAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ICompoundAssignmentOperationWrapper wrapper);
    public static ICompoundAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConditionalAccessInstanceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IConditionalAccessInstanceOperationWrapper();
    private IConditionalAccessInstanceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IConditionalAccessInstanceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConditionalAccessOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, IOperation> WhenNotNullAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    private static IConditionalAccessOperationWrapper();
    private IConditionalAccessOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public IOperation get_WhenNotNull();
    public static IConditionalAccessOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConditionalOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, IOperation> WhenTrueAccessor;
    private static Func`2<IOperation, IOperation> WhenFalseAccessor;
    private static Func`2<IOperation, bool> IsRefAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public bool IsRef { get; }
    private static IConditionalOperationWrapper();
    private IConditionalOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Condition();
    public IOperation get_WhenTrue();
    public IOperation get_WhenFalse();
    public bool get_IsRef();
    public static IConditionalOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConstantPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IConstantPatternOperationWrapper();
    private IConstantPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IConstantPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IConstantPatternOperationWrapper wrapper);
    public static IConstantPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConstructorBodyOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Initializer { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IConstructorBodyOperationWrapper();
    private IConstructorBodyOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Initializer();
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IConstructorBodyOperationWrapper op_Explicit(IMethodBodyBaseOperationWrapper wrapper);
    public static IMethodBodyBaseOperationWrapper op_Implicit(IConstructorBodyOperationWrapper wrapper);
    public static IConstructorBodyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IConversionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private static Func`2<IOperation, bool> IsTryCastAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    [NullableAttribute("2")]
public IMethodSymbol OperatorMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    public object Conversion { get; }
    public bool IsTryCast { get; }
    public bool IsChecked { get; }
    private static IConversionOperationWrapper();
    private IConversionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    [NullableContextAttribute("2")]
public IMethodSymbol get_OperatorMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public object get_Conversion();
    public bool get_IsTryCast();
    public bool get_IsChecked();
    public static IConversionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDeclarationExpressionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExpressionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Expression { get; }
    private static IDeclarationExpressionOperationWrapper();
    private IDeclarationExpressionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Expression();
    public static IDeclarationExpressionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDeclarationPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    private static Func`2<IOperation, bool> MatchesNullAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> DeclaredSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public ITypeSymbol MatchedType { get; }
    public bool MatchesNull { get; }
    [NullableAttribute("2")]
public ISymbol DeclaredSymbol { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IDeclarationPatternOperationWrapper();
    private IDeclarationPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
public ITypeSymbol get_MatchedType();
    public bool get_MatchesNull();
    [NullableContextAttribute("2")]
public ISymbol get_DeclaredSymbol();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IDeclarationPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IDeclarationPatternOperationWrapper wrapper);
    public static IDeclarationPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDeconstructionAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static IDeconstructionAssignmentOperationWrapper();
    private IDeconstructionAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Target();
    public IOperation get_Value();
    public static IDeconstructionAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(IDeconstructionAssignmentOperationWrapper wrapper);
    public static IDeconstructionAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDefaultCaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object CaseKind { get; }
    [NullableAttribute("2")]
public ILabelSymbol Label { get; }
    private static IDefaultCaseClauseOperationWrapper();
    private IDefaultCaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_CaseKind();
    [NullableContextAttribute("2")]
public ILabelSymbol get_Label();
    public static IDefaultCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IDefaultCaseClauseOperationWrapper wrapper);
    public static IDefaultCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDefaultValueOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IDefaultValueOperationWrapper();
    private IDefaultValueOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IDefaultValueOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDelegateCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    private static IDelegateCreationOperationWrapper();
    private IDelegateCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Target();
    public static IDelegateCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDiscardOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object DiscardSymbol { get; }
    private static IDiscardOperationWrapper();
    private IDiscardOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_DiscardSymbol();
    public static IDiscardOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDiscardPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IDiscardPatternOperationWrapper();
    private IDiscardPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IDiscardPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IDiscardPatternOperationWrapper wrapper);
    public static IDiscardPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDynamicIndexerAccessOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicIndexerAccessOperationWrapper();
    private IDynamicIndexerAccessOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicIndexerAccessOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDynamicInvocationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicInvocationOperationWrapper();
    private IDynamicInvocationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDynamicMemberReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, string> MemberNameAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ITypeSymbol>> TypeArgumentsAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ContainingTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public string MemberName { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    [NullableAttribute("2")]
public ITypeSymbol ContainingType { get; }
    private static IDynamicMemberReferenceOperationWrapper();
    private IDynamicMemberReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Instance();
    public string get_MemberName();
    public ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ContainingType();
    public static IDynamicMemberReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IDynamicObjectCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicObjectCreationOperationWrapper();
    private IDynamicObjectCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IEmptyOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IEmptyOperationWrapper();
    private IEmptyOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IEmptyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IEndOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IEndOperationWrapper();
    private IEndOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IEndOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IEventAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> EventReferenceAccessor;
    private static Func`2<IOperation, IOperation> HandlerValueAccessor;
    private static Func`2<IOperation, bool> AddsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    public bool Adds { get; }
    private static IEventAssignmentOperationWrapper();
    private IEventAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_EventReference();
    public IOperation get_HandlerValue();
    public bool get_Adds();
    public static IEventAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IEventReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IEventSymbol> EventAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IEventSymbol Event { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IEventReferenceOperationWrapper();
    private IEventReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IEventSymbol get_Event();
    public IOperation get_Instance();
    public ISymbol get_Member();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IEventReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IEventReferenceOperationWrapper wrapper);
    public static IEventReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IExpressionStatementOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static IExpressionStatementOperationWrapper();
    private IExpressionStatementOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static IExpressionStatementOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFieldInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IFieldSymbol>> InitializedFieldsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IFieldSymbol> InitializedFields { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IFieldInitializerOperationWrapper();
    private IFieldInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IFieldSymbol> get_InitializedFields();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IFieldInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IFieldInitializerOperationWrapper wrapper);
    public static IFieldInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFieldReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IFieldSymbol> FieldAccessor;
    private static Func`2<IOperation, bool> IsDeclarationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IFieldSymbol Field { get; }
    public bool IsDeclaration { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IFieldReferenceOperationWrapper();
    private IFieldReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IFieldSymbol get_Field();
    public bool get_IsDeclaration();
    public IOperation get_Instance();
    public ISymbol get_Member();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IFieldReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IFieldReferenceOperationWrapper wrapper);
    public static IFieldReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.IFieldSymbolExtensions : object {
    private static Func`2<IFieldSymbol, IFieldSymbol> CorrespondingTupleFieldAccessor;
    private static IFieldSymbolExtensions();
    [ExtensionAttribute]
public static IFieldSymbol CorrespondingTupleField(IFieldSymbol symbol);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFlowAnonymousFunctionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    private static IFlowAnonymousFunctionOperationWrapper();
    private IFlowAnonymousFunctionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public static IFlowAnonymousFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFlowCaptureOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, CaptureId> IdAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public CaptureId Id { get; }
    public IOperation Value { get; }
    private static IFlowCaptureOperationWrapper();
    private IFlowCaptureOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public CaptureId get_Id();
    public IOperation get_Value();
    public static IFlowCaptureOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFlowCaptureReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, CaptureId> IdAccessor;
    private static Func`2<IOperation, bool> IsInitializationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public CaptureId Id { get; }
    public bool IsInitialization { get; }
    private static IFlowCaptureReferenceOperationWrapper();
    private IFlowCaptureReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public CaptureId get_Id();
    public bool get_IsInitialization();
    public static IFlowCaptureReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IForEachLoopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LoopControlVariableAccessor;
    private static Func`2<IOperation, IOperation> CollectionAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> NextVariablesAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public bool IsAsynchronous { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForEachLoopOperationWrapper();
    private IForEachLoopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_LoopControlVariable();
    public IOperation get_Collection();
    public ImmutableArray`1<IOperation> get_NextVariables();
    public bool get_IsAsynchronous();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForEachLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForEachLoopOperationWrapper wrapper);
    public static IForEachLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IForLoopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> BeforeAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> ConditionLocalsAccessor;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> AtLoopBottomAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Before { get; }
    public ImmutableArray`1<ILocalSymbol> ConditionLocals { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForLoopOperationWrapper();
    private IForLoopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Before();
    public ImmutableArray`1<ILocalSymbol> get_ConditionLocals();
    public IOperation get_Condition();
    public ImmutableArray`1<IOperation> get_AtLoopBottom();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForLoopOperationWrapper wrapper);
    public static IForLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IForToLoopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LoopControlVariableAccessor;
    private static Func`2<IOperation, IOperation> InitialValueAccessor;
    private static Func`2<IOperation, IOperation> LimitValueAccessor;
    private static Func`2<IOperation, IOperation> StepValueAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> NextVariablesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public bool IsChecked { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForToLoopOperationWrapper();
    private IForToLoopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_LoopControlVariable();
    public IOperation get_InitialValue();
    public IOperation get_LimitValue();
    public IOperation get_StepValue();
    public bool get_IsChecked();
    public ImmutableArray`1<IOperation> get_NextVariables();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForToLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForToLoopOperationWrapper wrapper);
    public static IForToLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IFunctionPointerInvocationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IFunctionPointerInvocationOperationWrapper();
    private IFunctionPointerInvocationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Target();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IFunctionPointerInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IImplicitIndexerReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, IOperation> ArgumentAccessor;
    private static Func`2<IOperation, ISymbol> LengthSymbolAccessor;
    private static Func`2<IOperation, ISymbol> IndexerSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public IOperation Argument { get; }
    public ISymbol LengthSymbol { get; }
    public ISymbol IndexerSymbol { get; }
    private static IImplicitIndexerReferenceOperationWrapper();
    private IImplicitIndexerReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Instance();
    public IOperation get_Argument();
    public ISymbol get_LengthSymbol();
    public ISymbol get_IndexerSymbol();
    public static IImplicitIndexerReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IIncrementOrDecrementOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, bool> IsPostfixAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public bool IsPostfix { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IOperation Target { get; }
    [NullableAttribute("2")]
public IMethodSymbol OperatorMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IIncrementOrDecrementOperationWrapper();
    private IIncrementOrDecrementOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public bool get_IsPostfix();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public IOperation get_Target();
    [NullableContextAttribute("2")]
public IMethodSymbol get_OperatorMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IIncrementOrDecrementOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInlineArrayAccessOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, IOperation> ArgumentAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public IOperation Argument { get; }
    private static IInlineArrayAccessOperationWrapper();
    private IInlineArrayAccessOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Instance();
    public IOperation get_Argument();
    public static IInlineArrayAccessOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInstanceReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object ReferenceKind { get; }
    private static IInstanceReferenceOperationWrapper();
    private IInstanceReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_ReferenceKind();
    public static IInstanceReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringAdditionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftAccessor;
    private static Func`2<IOperation, IOperation> RightAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Left { get; }
    public IOperation Right { get; }
    private static IInterpolatedStringAdditionOperationWrapper();
    private IInterpolatedStringAdditionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Left();
    public IOperation get_Right();
    public static IInterpolatedStringAdditionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringAppendOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> AppendCallAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation AppendCall { get; }
    private static IInterpolatedStringAppendOperationWrapper();
    private IInterpolatedStringAppendOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_AppendCall();
    public static IInterpolatedStringAppendOperationWrapper op_Explicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper op_Implicit(IInterpolatedStringAppendOperationWrapper wrapper);
    public static IInterpolatedStringAppendOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringContentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IInterpolatedStringContentOperationWrapper();
    private IInterpolatedStringContentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IInterpolatedStringContentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static IInterpolatedStringContentOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringHandlerArgumentPlaceholderOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, int> ArgumentIndexAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public int ArgumentIndex { get; }
    public object PlaceholderKind { get; }
    private static IInterpolatedStringHandlerArgumentPlaceholderOperationWrapper();
    private IInterpolatedStringHandlerArgumentPlaceholderOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public int get_ArgumentIndex();
    public object get_PlaceholderKind();
    public static IInterpolatedStringHandlerArgumentPlaceholderOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringHandlerCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> HandlerCreationAccessor;
    private static Func`2<IOperation, bool> HandlerCreationHasSuccessParameterAccessor;
    private static Func`2<IOperation, bool> HandlerAppendCallsReturnBoolAccessor;
    private static Func`2<IOperation, IOperation> ContentAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation HandlerCreation { get; }
    public bool HandlerCreationHasSuccessParameter { get; }
    public bool HandlerAppendCallsReturnBool { get; }
    public IOperation Content { get; }
    private static IInterpolatedStringHandlerCreationOperationWrapper();
    private IInterpolatedStringHandlerCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_HandlerCreation();
    public bool get_HandlerCreationHasSuccessParameter();
    public bool get_HandlerAppendCallsReturnBool();
    public IOperation get_Content();
    public static IInterpolatedStringHandlerCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> PartsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Parts { get; }
    private static IInterpolatedStringOperationWrapper();
    private IInterpolatedStringOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Parts();
    public static IInterpolatedStringOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolatedStringTextOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TextAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Text { get; }
    private static IInterpolatedStringTextOperationWrapper();
    private IInterpolatedStringTextOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Text();
    public static IInterpolatedStringTextOperationWrapper op_Explicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper op_Implicit(IInterpolatedStringTextOperationWrapper wrapper);
    public static IInterpolatedStringTextOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInterpolationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExpressionAccessor;
    private static Func`2<IOperation, IOperation> AlignmentAccessor;
    private static Func`2<IOperation, IOperation> FormatStringAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    private static IInterpolationOperationWrapper();
    private IInterpolationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Expression();
    public IOperation get_Alignment();
    public IOperation get_FormatString();
    public static IInterpolationOperationWrapper op_Explicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper op_Implicit(IInterpolationOperationWrapper wrapper);
    public static IInterpolationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInvalidOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IInvalidOperationWrapper();
    private IInvalidOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IInvalidOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IInvocationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> TargetMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, bool> IsVirtualAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol TargetMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    public IOperation Instance { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IInvocationOperationWrapper();
    private IInvocationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_TargetMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public IOperation get_Instance();
    public bool get_IsVirtual();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IIsNullOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    private static IIsNullOperationWrapper();
    private IIsNullOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    public static IIsNullOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IIsPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public IPatternOperationWrapper Pattern { get; }
    private static IIsPatternOperationWrapper();
    private IIsPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public IPatternOperationWrapper get_Pattern();
    public static IIsPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IIsTypeOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueOperandAccessor;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private static Func`2<IOperation, bool> IsNegatedAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ValueOperand { get; }
    public ITypeSymbol TypeOperand { get; }
    public bool IsNegated { get; }
    private static IIsTypeOperationWrapper();
    private IIsTypeOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_ValueOperand();
    public ITypeSymbol get_TypeOperand();
    public bool get_IsNegated();
    public static IIsTypeOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILabeledOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Label { get; }
    public IOperation Operation { get; }
    private static ILabeledOperationWrapper();
    private ILabeledOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILabelSymbol get_Label();
    public IOperation get_Operation();
    public static ILabeledOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IListPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> LengthSymbolAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> IndexerSymbolAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> PatternsAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> DeclaredSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public ISymbol LengthSymbol { get; }
    [NullableAttribute("2")]
public ISymbol IndexerSymbol { get; }
    public ImmutableArray`1<IOperation> Patterns { get; }
    [NullableAttribute("2")]
public ISymbol DeclaredSymbol { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IListPatternOperationWrapper();
    private IListPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
public ISymbol get_LengthSymbol();
    [NullableContextAttribute("2")]
public ISymbol get_IndexerSymbol();
    public ImmutableArray`1<IOperation> get_Patterns();
    [NullableContextAttribute("2")]
public ISymbol get_DeclaredSymbol();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IListPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IListPatternOperationWrapper wrapper);
    public static IListPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILiteralOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static ILiteralOperationWrapper();
    private ILiteralOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static ILiteralOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILocalFunctionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, IOperation> IgnoredBodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    public IBlockOperationWrapper Body { get; }
    public IBlockOperationWrapper IgnoredBody { get; }
    private static ILocalFunctionOperationWrapper();
    private ILocalFunctionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public IBlockOperationWrapper get_Body();
    public IBlockOperationWrapper get_IgnoredBody();
    public static ILocalFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILocalReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> LocalAccessor;
    private static Func`2<IOperation, bool> IsDeclarationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Local { get; }
    public bool IsDeclaration { get; }
    private static ILocalReferenceOperationWrapper();
    private ILocalReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILocalSymbol get_Local();
    public bool get_IsDeclaration();
    public static ILocalReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILockOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LockedValueAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    private static ILockOperationWrapper();
    private ILockOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_LockedValue();
    public IOperation get_Body();
    public static ILockOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ILoopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, ILabelSymbol> ContinueLabelAccessor;
    private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static ILoopOperationWrapper();
    private ILoopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static ILoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static ILoopOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IMemberInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializedMemberAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static IMemberInitializerOperationWrapper();
    private IMemberInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_InitializedMember();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static IMemberInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IMemberReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, ISymbol> MemberAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IMemberReferenceOperationWrapper();
    private IMemberReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Instance();
    public ISymbol get_Member();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IMemberReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static IMemberReferenceOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IMethodBodyBaseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BlockBodyAccessor;
    private static Func`2<IOperation, IOperation> ExpressionBodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IMethodBodyBaseOperationWrapper();
    private IMethodBodyBaseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IMethodBodyBaseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static IMethodBodyBaseOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IMethodBodyOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IMethodBodyOperationWrapper();
    private IMethodBodyOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IMethodBodyOperationWrapper op_Explicit(IMethodBodyBaseOperationWrapper wrapper);
    public static IMethodBodyBaseOperationWrapper op_Implicit(IMethodBodyOperationWrapper wrapper);
    public static IMethodBodyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IMethodReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> MethodAccessor;
    private static Func`2<IOperation, bool> IsVirtualAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Method { get; }
    public bool IsVirtual { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IMethodReferenceOperationWrapper();
    private IMethodReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IMethodSymbol get_Method();
    public bool get_IsVirtual();
    public IOperation get_Instance();
    public ISymbol get_Member();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IMethodReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IMethodReferenceOperationWrapper wrapper);
    public static IMethodReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ImplicitObjectCreationExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithNewKeywordAccessor;
    private static Func`3<ExpressionSyntax, ArgumentListSyntax, ExpressionSyntax> WithArgumentListAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken NewKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static ImplicitObjectCreationExpressionSyntaxWrapper();
    private ImplicitObjectCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_NewKeyword();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    public static ImplicitObjectCreationExpressionSyntaxWrapper op_Explicit(BaseObjectCreationExpressionSyntaxWrapper node);
    public static ImplicitObjectCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseObjectCreationExpressionSyntaxWrapper op_Implicit(ImplicitObjectCreationExpressionSyntaxWrapper wrapper);
    public static ExpressionSyntax op_Implicit(ImplicitObjectCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithNewKeyword(SyntaxToken newKeyword);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ImplicitStackAllocArrayCreationExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> StackAllocKeywordAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithStackAllocKeywordAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken StackAllocKeyword { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SyntaxToken CloseBracketToken { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper();
    private ImplicitStackAllocArrayCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper AddInitializerExpressions(ExpressionSyntax[] items);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_StackAllocKeyword();
    public SyntaxToken get_OpenBracketToken();
    public SyntaxToken get_CloseBracketToken();
    public InitializerExpressionSyntax get_Initializer();
    public static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ImplicitStackAllocArrayCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithStackAllocKeyword(SyntaxToken stackAllocKeyword);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.INamedTypeSymbolExtensions : object {
    private static Func`2<INamedTypeSymbol, INamedTypeSymbol> TupleUnderlyingTypeAccessor;
    private static Func`2<INamedTypeSymbol, ImmutableArray`1<IFieldSymbol>> TupleElementsAccessor;
    private static Func`2<INamedTypeSymbol, bool> IsSerializableAccessor;
    private static INamedTypeSymbolExtensions();
    [ExtensionAttribute]
public static INamedTypeSymbol TupleUnderlyingType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IFieldSymbol> TupleElements(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsSerializable(INamedTypeSymbol symbol);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.INamedTypeSymbolExtensionsSonar : object {
    private static Func`2<INamedTypeSymbol, ImmutableArray`1<NullableAnnotation>> TypeArgumentNullableAnnotationsAccessor;
    private static INamedTypeSymbolExtensionsSonar();
    [ExtensionAttribute]
public static ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations(INamedTypeSymbol symbol);
    private static Func`2<INamedTypeSymbol, ImmutableArray`1<NullableAnnotation>> CreateTypeArgumentNullableAnnotationsAccessor();
    private static Type OriginalNullableAnnotationType();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.INameOfOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ArgumentAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Argument { get; }
    private static INameOfOperationWrapper();
    private INameOfOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Argument();
    public static INameOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.INegatedPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPatternOperationWrapper Pattern { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static INegatedPatternOperationWrapper();
    private INegatedPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IPatternOperationWrapper get_Pattern();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static INegatedPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(INegatedPatternOperationWrapper wrapper);
    public static INegatedPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IObjectCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> ConstructorAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public IMethodSymbol Constructor { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IObjectCreationOperationWrapper();
    private IObjectCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
public IMethodSymbol get_Constructor();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IObjectOrCollectionInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> InitializersAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    private static IObjectOrCollectionInitializerOperationWrapper();
    private IObjectOrCollectionInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Initializers();
    public static IObjectOrCollectionInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IOmittedArgumentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IOmittedArgumentOperationWrapper();
    private IOmittedArgumentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IOmittedArgumentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("2")]
public interface StyleCop.Analyzers.Lightup.IOperationWrapper {
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public abstract virtual IOperation get_WrappedOperation();
    public abstract virtual ITypeSymbol get_Type();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IOperationWrapperSonar : ValueType {
    private static Func`2<IOperation, IOperation> ParentAccessor;
    private static Func`2<IOperation, IEnumerable`1<IOperation>> ChildrenAccessor;
    private static Func`2<IOperation, string> LanguageAccessor;
    private static Func`2<IOperation, bool> IsImplicitAccessor;
    private static Func`2<IOperation, SemanticModel> SemanticModelAccessor;
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    public IOperation Instance { get; }
    public IOperation Parent { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public string Language { get; }
    public bool IsImplicit { get; }
    public SemanticModel SemanticModel { get; }
    public IOperationWrapperSonar(IOperation instance);
    private static IOperationWrapperSonar();
    [CompilerGeneratedAttribute]
public IOperation get_Instance();
    public IOperation get_Parent();
    public IEnumerable`1<IOperation> get_Children();
    public string get_Language();
    public bool get_IsImplicit();
    public SemanticModel get_SemanticModel();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IParameterInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IParameterSymbol Parameter { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IParameterInitializerOperationWrapper();
    private IParameterInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IParameterSymbol get_Parameter();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IParameterInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IParameterInitializerOperationWrapper wrapper);
    public static IParameterInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IParameterReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IParameterSymbol Parameter { get; }
    private static IParameterReferenceOperationWrapper();
    private IParameterReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IParameterSymbol get_Parameter();
    public static IParameterReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IParenthesizedOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    private static IParenthesizedOperationWrapper();
    private IParenthesizedOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    public static IParenthesizedOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IPatternCaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private static Func`2<IOperation, IOperation> GuardAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Label { get; }
    public IPatternOperationWrapper Pattern { get; }
    public IOperation Guard { get; }
    public object CaseKind { get; }
    private static IPatternCaseClauseOperationWrapper();
    private IPatternCaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILabelSymbol get_Label();
    public IPatternOperationWrapper get_Pattern();
    public IOperation get_Guard();
    public object get_CaseKind();
    public static IPatternCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IPatternCaseClauseOperationWrapper wrapper);
    public static IPatternCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> InputTypeAccessor;
    private static Func`2<IOperation, ITypeSymbol> NarrowedTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IPatternOperationWrapper();
    private IPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static IPatternOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IPropertyInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IPropertySymbol>> InitializedPropertiesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IPropertySymbol> InitializedProperties { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IPropertyInitializerOperationWrapper();
    private IPropertyInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IPropertySymbol> get_InitializedProperties();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IPropertyInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IPropertyInitializerOperationWrapper wrapper);
    public static IPropertyInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IPropertyReferenceOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IPropertySymbol> PropertyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPropertySymbol Property { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IPropertyReferenceOperationWrapper();
    private IPropertyReferenceOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IPropertySymbol get_Property();
    public ImmutableArray`1<IOperation> get_Arguments();
    public IOperation get_Instance();
    public ISymbol get_Member();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IPropertyReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IPropertyReferenceOperationWrapper wrapper);
    public static IPropertyReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IPropertySubpatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> MemberAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Member { get; }
    public IPatternOperationWrapper Pattern { get; }
    private static IPropertySubpatternOperationWrapper();
    private IPropertySubpatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Member();
    public IPatternOperationWrapper get_Pattern();
    public static IPropertySubpatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.IPropertySymbolExtensions : object {
    private static Func`2<IPropertySymbol, bool> IsRequiredAccessor;
    private static IPropertySymbolExtensions();
    [ExtensionAttribute]
public static bool IsRequired(IPropertySymbol propertySymbol);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRaiseEventOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> EventReferenceAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IEventReferenceOperationWrapper EventReference { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IRaiseEventOperationWrapper();
    private IRaiseEventOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IEventReferenceOperationWrapper get_EventReference();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IRaiseEventOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRangeCaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> MinimumValueAccessor;
    private static Func`2<IOperation, IOperation> MaximumValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public object CaseKind { get; }
    [NullableAttribute("2")]
public ILabelSymbol Label { get; }
    private static IRangeCaseClauseOperationWrapper();
    private IRangeCaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_MinimumValue();
    public IOperation get_MaximumValue();
    public object get_CaseKind();
    [NullableContextAttribute("2")]
public ILabelSymbol get_Label();
    public static IRangeCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IRangeCaseClauseOperationWrapper wrapper);
    public static IRangeCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRangeOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> MethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public bool IsLifted { get; }
    [NullableAttribute("2")]
public IMethodSymbol Method { get; }
    private static IRangeOperationWrapper();
    private IRangeOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public bool get_IsLifted();
    [NullableContextAttribute("2")]
public IMethodSymbol get_Method();
    public static IRangeOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRecursivePatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> DeconstructSymbolAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeconstructionSubpatternsAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> PropertySubpatternsAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> DeclaredSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol MatchedType { get; }
    [NullableAttribute("2")]
public ISymbol DeconstructSymbol { get; }
    public ImmutableArray`1<IOperation> DeconstructionSubpatterns { get; }
    public ImmutableArray`1<IOperation> PropertySubpatterns { get; }
    [NullableAttribute("2")]
public ISymbol DeclaredSymbol { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IRecursivePatternOperationWrapper();
    private IRecursivePatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_MatchedType();
    [NullableContextAttribute("2")]
public ISymbol get_DeconstructSymbol();
    public ImmutableArray`1<IOperation> get_DeconstructionSubpatterns();
    public ImmutableArray`1<IOperation> get_PropertySubpatterns();
    [NullableContextAttribute("2")]
public ISymbol get_DeclaredSymbol();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IRecursivePatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IRecursivePatternOperationWrapper wrapper);
    public static IRecursivePatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IReDimClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DimensionSizesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    private static IReDimClauseOperationWrapper();
    private IReDimClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    public ImmutableArray`1<IOperation> get_DimensionSizes();
    public static IReDimClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IReDimOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ClausesAccessor;
    private static Func`2<IOperation, bool> PreserveAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Clauses { get; }
    public bool Preserve { get; }
    private static IReDimOperationWrapper();
    private IReDimOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Clauses();
    public bool get_Preserve();
    public static IReDimOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRelationalCaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, BinaryOperatorKind> RelationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public BinaryOperatorKind Relation { get; }
    public object CaseKind { get; }
    [NullableAttribute("2")]
public ILabelSymbol Label { get; }
    private static IRelationalCaseClauseOperationWrapper();
    private IRelationalCaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public BinaryOperatorKind get_Relation();
    public object get_CaseKind();
    [NullableContextAttribute("2")]
public ILabelSymbol get_Label();
    public static IRelationalCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IRelationalCaseClauseOperationWrapper wrapper);
    public static IRelationalCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IRelationalPatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, BinaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation Value { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IRelationalPatternOperationWrapper();
    private IRelationalPatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public BinaryOperatorKind get_OperatorKind();
    public IOperation get_Value();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IRelationalPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IRelationalPatternOperationWrapper wrapper);
    public static IRelationalPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IReturnOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ReturnedValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ReturnedValue { get; }
    private static IReturnOperationWrapper();
    private IReturnOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_ReturnedValue();
    public static IReturnOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISimpleAssignmentOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, bool> IsRefAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public bool IsRef { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ISimpleAssignmentOperationWrapper();
    private ISimpleAssignmentOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public bool get_IsRef();
    public IOperation get_Target();
    public IOperation get_Value();
    public static ISimpleAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ISimpleAssignmentOperationWrapper wrapper);
    public static ISimpleAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISingleValueCaseClauseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public object CaseKind { get; }
    [NullableAttribute("2")]
public ILabelSymbol Label { get; }
    private static ISingleValueCaseClauseOperationWrapper();
    private ISingleValueCaseClauseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public object get_CaseKind();
    [NullableContextAttribute("2")]
public ILabelSymbol get_Label();
    public static ISingleValueCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(ISingleValueCaseClauseOperationWrapper wrapper);
    public static ISingleValueCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISizeOfOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol TypeOperand { get; }
    private static ISizeOfOperationWrapper();
    private ISizeOfOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_TypeOperand();
    public static ISizeOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISlicePatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ISymbol> SliceSymbolAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public ISymbol SliceSymbol { get; }
    public IPatternOperationWrapper Pattern { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static ISlicePatternOperationWrapper();
    private ISlicePatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
public ISymbol get_SliceSymbol();
    public IPatternOperationWrapper get_Pattern();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static ISlicePatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(ISlicePatternOperationWrapper wrapper);
    public static ISlicePatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IsPatternExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> IsKeywordAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithIsKeywordAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithPatternAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken IsKeyword { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static IsPatternExpressionSyntaxWrapper();
    private IsPatternExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_IsKeyword();
    public PatternSyntaxWrapper get_Pattern();
    public static IsPatternExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(IsPatternExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public IsPatternExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public IsPatternExpressionSyntaxWrapper WithIsKeyword(SyntaxToken isKeyword);
    public IsPatternExpressionSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISpreadOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ElementTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    [NullableAttribute("2")]
public ITypeSymbol ElementType { get; }
    public object ElementConversion { get; }
    private static ISpreadOperationWrapper();
    private ISpreadOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ElementType();
    public object get_ElementConversion();
    public static ISpreadOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IStaticLocalInitializationSemaphoreOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> LocalAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Local { get; }
    private static IStaticLocalInitializationSemaphoreOperationWrapper();
    private IStaticLocalInitializationSemaphoreOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILocalSymbol get_Local();
    public static IStaticLocalInitializationSemaphoreOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IStopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IStopOperationWrapper();
    private IStopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public static IStopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISwitchCaseOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ClausesAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Clauses { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static ISwitchCaseOperationWrapper();
    private ISwitchCaseOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Clauses();
    public ImmutableArray`1<IOperation> get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static ISwitchCaseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISwitchExpressionArmOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private static Func`2<IOperation, IOperation> GuardAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPatternOperationWrapper Pattern { get; }
    public IOperation Guard { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static ISwitchExpressionArmOperationWrapper();
    private ISwitchExpressionArmOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IPatternOperationWrapper get_Pattern();
    public IOperation get_Guard();
    public IOperation get_Value();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static ISwitchExpressionArmOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISwitchExpressionOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArmsAccessor;
    private static Func`2<IOperation, bool> IsExhaustiveAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<IOperation> Arms { get; }
    public bool IsExhaustive { get; }
    private static ISwitchExpressionOperationWrapper();
    private ISwitchExpressionOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Value();
    public ImmutableArray`1<IOperation> get_Arms();
    public bool get_IsExhaustive();
    public static ISwitchExpressionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISwitchOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> CasesAccessor;
    private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<IOperation> Cases { get; }
    public ILabelSymbol ExitLabel { get; }
    private static ISwitchOperationWrapper();
    private ISwitchOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public ImmutableArray`1<IOperation> get_Cases();
    public ILabelSymbol get_ExitLabel();
    public static ISwitchOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ISymbolInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static ISymbolInitializerOperationWrapper();
    private ISymbolInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static ISymbolInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    public static ISymbolInitializerOperationWrapper FromUpcast(IOperation operation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ISymbolNullableExtensions : object {
    private static Func`2<ITypeSymbol, NullableAnnotation> TypeSymbolAccessor;
    private static Func`2<IArrayTypeSymbol, NullableAnnotation> ArrayTypeSymbolElementAccessor;
    private static Func`2<IParameterSymbol, NullableAnnotation> ParameterSymbolAccessor;
    private static Func`2<ILocalSymbol, NullableAnnotation> LocalSymbolAccessor;
    private static Func`2<IPropertySymbol, NullableAnnotation> PropertySymbolAccessor;
    private static Func`2<IFieldSymbol, NullableAnnotation> FieldSymbolAccessor;
    private static Func`2<IEventSymbol, NullableAnnotation> EventSymbolAccessor;
    private static Func`2<ITypeParameterSymbol, NullableAnnotation> TypeParameterSymbolReferenceTypeConstraintAccessor;
    private static Func`2<IMethodSymbol, NullableAnnotation> MethodSymbolReceiverAccessor;
    private static Func`2<IMethodSymbol, NullableAnnotation> MethodSymbolReturnAccessor;
    private static ISymbolNullableExtensions();
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(ITypeSymbol type);
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(IParameterSymbol parameter);
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(ILocalSymbol local);
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(IPropertySymbol property);
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(IFieldSymbol field);
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static NullableAnnotation ElementNullableAnnotation(IArrayTypeSymbol arrayType);
    [ExtensionAttribute]
public static NullableAnnotation ReferenceTypeConstraintNullableAnnotation(ITypeParameterSymbol eventSymbol);
    [ExtensionAttribute]
public static NullableAnnotation ReceiverNullableAnnotation(IMethodSymbol method);
    [ExtensionAttribute]
public static NullableAnnotation ReturnNullableAnnotation(IMethodSymbol method);
    private static Func`2<T, NullableAnnotation> CreateSymbolNullableAnnotationAccessor(string propertyName);
}
public interface StyleCop.Analyzers.Lightup.ISyntaxWrapper`1 {
    public T SyntaxNode { get; }
    public abstract virtual T get_SyntaxNode();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IThrowOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExceptionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Exception { get; }
    private static IThrowOperationWrapper();
    private IThrowOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Exception();
    public static IThrowOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITranslatedQueryOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static ITranslatedQueryOperationWrapper();
    private ITranslatedQueryOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static ITranslatedQueryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITryOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> CatchesAccessor;
    private static Func`2<IOperation, IOperation> FinallyAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper Body { get; }
    public ImmutableArray`1<IOperation> Catches { get; }
    public IBlockOperationWrapper Finally { get; }
    [NullableAttribute("2")]
public ILabelSymbol ExitLabel { get; }
    private static ITryOperationWrapper();
    private ITryOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IBlockOperationWrapper get_Body();
    public ImmutableArray`1<IOperation> get_Catches();
    public IBlockOperationWrapper get_Finally();
    [NullableContextAttribute("2")]
public ILabelSymbol get_ExitLabel();
    public static ITryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITupleBinaryOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, BinaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    private static ITupleBinaryOperationWrapper();
    private ITupleBinaryOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public BinaryOperatorKind get_OperatorKind();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public static ITupleBinaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITupleOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ElementsAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> NaturalTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Elements { get; }
    [NullableAttribute("2")]
public ITypeSymbol NaturalType { get; }
    private static ITupleOperationWrapper();
    private ITupleOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Elements();
    [NullableContextAttribute("2")]
public ITypeSymbol get_NaturalType();
    public static ITupleOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITypeOfOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol TypeOperand { get; }
    private static ITypeOfOperationWrapper();
    private ITypeOfOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_TypeOperand();
    public static ITypeOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITypeParameterObjectCreationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static ITypeParameterObjectCreationOperationWrapper();
    private ITypeParameterObjectCreationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static ITypeParameterObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ITypeParameterSymbolExtensions : object {
    private static Func`2<ITypeParameterSymbol, bool> HasUnmanagedTypeConstraintAccessor;
    private static ITypeParameterSymbolExtensions();
    [ExtensionAttribute]
public static bool HasUnmanagedTypeConstraint(ITypeParameterSymbol symbol);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ITypePatternOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol MatchedType { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static ITypePatternOperationWrapper();
    private ITypePatternOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ITypeSymbol get_MatchedType();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static ITypePatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(ITypePatternOperationWrapper wrapper);
    public static ITypePatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.ITypeSymbolExtensions : object {
    private static Func`2<ITypeSymbol, bool> IsTupleTypeAccessor;
    private static Func`2<ITypeSymbol, bool> IsRefLikeTypeAccessor;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static bool IsTupleType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsRefLikeType(ITypeSymbol symbol);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IUnaryOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, UnaryOperatorKind> OperatorKindAccessor;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ITypeSymbol> ConstrainedToTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public UnaryOperatorKind OperatorKind { get; }
    public IOperation Operand { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    [NullableAttribute("2")]
public IMethodSymbol OperatorMethod { get; }
    [NullableAttribute("2")]
public ITypeSymbol ConstrainedToType { get; }
    private static IUnaryOperationWrapper();
    private IUnaryOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public UnaryOperatorKind get_OperatorKind();
    public IOperation get_Operand();
    public bool get_IsLifted();
    public bool get_IsChecked();
    [NullableContextAttribute("2")]
public IMethodSymbol get_OperatorMethod();
    [NullableContextAttribute("2")]
public ITypeSymbol get_ConstrainedToType();
    public static IUnaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IUsingDeclarationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> DeclarationGroupAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IVariableDeclarationGroupOperationWrapper DeclarationGroup { get; }
    public bool IsAsynchronous { get; }
    private static IUsingDeclarationOperationWrapper();
    private IUsingDeclarationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IVariableDeclarationGroupOperationWrapper get_DeclarationGroup();
    public bool get_IsAsynchronous();
    public static IUsingDeclarationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IUsingOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ResourcesAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Resources { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public bool IsAsynchronous { get; }
    private static IUsingOperationWrapper();
    private IUsingOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Resources();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public bool get_IsAsynchronous();
    public static IUsingOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IUtf8StringOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, string> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public string Value { get; }
    private static IUtf8StringOperationWrapper();
    private IUtf8StringOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public string get_Value();
    public static IUtf8StringOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IVariableDeclarationGroupOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeclarationsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Declarations { get; }
    private static IVariableDeclarationGroupOperationWrapper();
    private IVariableDeclarationGroupOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Declarations();
    public static IVariableDeclarationGroupOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IVariableDeclarationOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeclaratorsAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IgnoredDimensionsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Declarators { get; }
    public IVariableInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredDimensions { get; }
    private static IVariableDeclarationOperationWrapper();
    private IVariableDeclarationOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Declarators();
    public IVariableInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_IgnoredDimensions();
    public static IVariableDeclarationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IVariableDeclaratorOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IgnoredArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Symbol { get; }
    public IVariableInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    private static IVariableDeclaratorOperationWrapper();
    private IVariableDeclaratorOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ILocalSymbol get_Symbol();
    public IVariableInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_IgnoredArguments();
    public static IVariableDeclaratorOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IVariableInitializerOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IVariableInitializerOperationWrapper();
    private IVariableInitializerOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IVariableInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IVariableInitializerOperationWrapper wrapper);
    public static IVariableInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IWhileLoopOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, bool> ConditionIsTopAccessor;
    private static Func`2<IOperation, bool> ConditionIsUntilAccessor;
    private static Func`2<IOperation, IOperation> IgnoredConditionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Condition { get; }
    public bool ConditionIsTop { get; }
    public bool ConditionIsUntil { get; }
    public IOperation IgnoredCondition { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IWhileLoopOperationWrapper();
    private IWhileLoopOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Condition();
    public bool get_ConditionIsTop();
    public bool get_ConditionIsUntil();
    public IOperation get_IgnoredCondition();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IWhileLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IWhileLoopOperationWrapper wrapper);
    public static IWhileLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.IWithOperationWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, IMethodSymbol> CloneMethodAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    [NullableAttribute("2")]
public IMethodSymbol CloneMethod { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static IWithOperationWrapper();
    private IWithOperationWrapper(IOperation operation);
    public sealed virtual IOperation get_WrappedOperation();
    public sealed virtual ITypeSymbol get_Type();
    public IOperation get_Operand();
    [NullableContextAttribute("2")]
public IMethodSymbol get_CloneMethod();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static IWithOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.LambdaExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> ArrowTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxList`1<AttributeListSyntax>, ExpressionSyntax> WithAttributeListsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithArrowTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken ArrowToken { get; }
    private static LambdaExpressionSyntaxWrapper();
    private LambdaExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_ArrowToken();
    public static LambdaExpressionSyntaxWrapper op_Explicit(AnonymousFunctionExpressionSyntaxWrapper node);
    public static LambdaExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static AnonymousFunctionExpressionSyntaxWrapper op_Implicit(LambdaExpressionSyntaxWrapper wrapper);
    public static ExpressionSyntax op_Implicit(LambdaExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LambdaExpressionSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public LambdaExpressionSyntaxWrapper WithArrowToken(SyntaxToken arrowToken);
    public static LambdaExpressionSyntaxWrapper FromUpcast(ExpressionSyntax node);
}
public static class StyleCop.Analyzers.Lightup.LanguageVersionEx : object {
    public static LanguageVersion Default;
    public static LanguageVersion CSharp7;
    public static LanguageVersion CSharp7_1;
    public static LanguageVersion CSharp7_2;
    public static LanguageVersion CSharp7_3;
    public static LanguageVersion CSharp8;
    public static LanguageVersion CSharp9;
    public static LanguageVersion CSharp10;
    public static LanguageVersion CSharp11;
    public static LanguageVersion CSharp12;
    public static LanguageVersion LatestMajor;
    public static LanguageVersion Preview;
    public static LanguageVersion Latest;
}
public static class StyleCop.Analyzers.Lightup.LightupHelpers : object {
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<Type, bool>> SupportedObjectWrappers;
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<SyntaxKind, bool>> SupportedSyntaxWrappers;
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<OperationKind, bool>> SupportedOperationWrappers;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp7>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp71>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp72>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp73>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp8>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp9>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp10>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp11>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp12>k__BackingField;
    public static bool SupportsCSharp7 { get; }
    public static bool SupportsCSharp71 { get; }
    public static bool SupportsCSharp72 { get; }
    public static bool SupportsCSharp73 { get; }
    public static bool SupportsCSharp8 { get; }
    public static bool SupportsCSharp9 { get; }
    public static bool SupportsCSharp10 { get; }
    public static bool SupportsCSharp11 { get; }
    public static bool SupportsCSharp12 { get; }
    public static bool SupportsIOperation { get; }
    private static LightupHelpers();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp7();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp71();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp72();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp73();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp8();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp9();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp10();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp11();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp12();
    public static bool get_SupportsIOperation();
    internal static bool CanWrapObject(object obj, Type underlyingType);
    internal static bool CanWrapNode(SyntaxNode node, Type underlyingType);
    internal static bool CanWrapOperation(IOperation operation, Type underlyingType);
    internal static Func`2<TOperation, TProperty> CreateOperationPropertyAccessor(Type type, string propertyName);
    internal static Func`2<TOperation, ImmutableArray`1<IOperation>> CreateOperationListPropertyAccessor(Type type, string propertyName);
    internal static Func`1<TProperty> CreateStaticPropertyAccessor(Type type, string propertyName);
    public static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, TArg, TProperty> CreateSyntaxPropertyAccessor(Type type, Type argumentType, string accessorMethodName);
    internal static TryGetValueAccessor`3<TSyntax, TKey, TValue> CreateTryGetValueAccessor(Type type, Type keyType, string methodName);
    internal static TryGetValueAccessor`4<TSender, TFirst, TSecond, TValue> CreateTryGetValueAccessor(Type type, Type firstType, Type secondType, string methodName);
    internal static TryGetValueAccessor`5<TSender, TFirst, TSecond, TThird, TValue> CreateTryGetValueAccessor(Type type, Type firstType, Type secondType, Type thirdType, string methodName);
    internal static Func`2<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>> CreateSeparatedSyntaxListPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>, TSyntax> CreateSeparatedSyntaxListWithPropertyAccessor(Type type, string propertyName);
    private static bool ValidatePropertyType(Type returnType, Type actualType);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateOperationPropertyAccessor>g__FallbackAccessor|35_0(TOperation syntax);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOperation> <CreateOperationListPropertyAccessor>g__FallbackAccessor|36_0(TOperation syntax);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateStaticPropertyAccessor>g__FallbackAccessor|37_0();
    [CompilerGeneratedAttribute]
internal static TProperty <CreateSyntaxPropertyAccessor>g__FallbackAccessor|38_0(TSyntax syntax);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateSyntaxPropertyAccessor>g__FallbackAccessor|39_0(TSyntax syntax, TArg argument);
    [CompilerGeneratedAttribute]
internal static bool <CreateTryGetValueAccessor>g__FallbackAccessor|40_0(TSyntax syntax, TKey key, TValue& value);
    [CompilerGeneratedAttribute]
internal static bool <CreateTryGetValueAccessor>g__FallbackAccessor|41_0(TSender sender, TFirst first, TSecond second, TValue& value);
    [CompilerGeneratedAttribute]
internal static bool <CreateTryGetValueAccessor>g__FallbackAccessor|42_0(TSender sender, TFirst first, TSecond second, TThird third, TValue& value);
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxListWrapper`1<TProperty> <CreateSeparatedSyntaxListPropertyAccessor>g__FallbackAccessor|43_0(TSyntax syntax);
    [CompilerGeneratedAttribute]
internal static TSyntax <CreateSyntaxWithPropertyAccessor>g__FallbackAccessor|44_0(TSyntax syntax, TProperty newValue);
    [CompilerGeneratedAttribute]
internal static TSyntax <CreateSeparatedSyntaxListWithPropertyAccessor>g__FallbackAccessor|45_0(TSyntax syntax, SeparatedSyntaxListWrapper`1<TProperty> newValue);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.LineDirectivePositionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> LineAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CommaTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CharacterAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithLineAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCommaTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCharacterAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken Line { get; }
    public SyntaxToken CommaToken { get; }
    public SyntaxToken Character { get; }
    public SyntaxToken CloseParenToken { get; }
    private static LineDirectivePositionSyntaxWrapper();
    private LineDirectivePositionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_Line();
    public SyntaxToken get_CommaToken();
    public SyntaxToken get_Character();
    public SyntaxToken get_CloseParenToken();
    public static LineDirectivePositionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(LineDirectivePositionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineDirectivePositionSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public LineDirectivePositionSyntaxWrapper WithLine(SyntaxToken line);
    public LineDirectivePositionSyntaxWrapper WithCommaToken(SyntaxToken commaToken);
    public LineDirectivePositionSyntaxWrapper WithCharacter(SyntaxToken character);
    public LineDirectivePositionSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.LineOrSpanDirectiveTriviaSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> LineKeywordAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> FileAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithLineKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithFileAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken LineKeyword { get; }
    public SyntaxToken File { get; }
    private static LineOrSpanDirectiveTriviaSyntaxWrapper();
    private LineOrSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_LineKeyword();
    public SyntaxToken get_File();
    public static LineOrSpanDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static DirectiveTriviaSyntax op_Implicit(LineOrSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineOrSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword);
    public LineOrSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file);
    public static LineOrSpanDirectiveTriviaSyntaxWrapper FromUpcast(DirectiveTriviaSyntax node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.LineSpanDirectiveTriviaSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, CSharpSyntaxNode> StartAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> MinusTokenAccessor;
    private static Func`2<DirectiveTriviaSyntax, CSharpSyntaxNode> EndAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> CharacterOffsetAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithHashTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithLineKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, CSharpSyntaxNode, DirectiveTriviaSyntax> WithStartAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithMinusTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, CSharpSyntaxNode, DirectiveTriviaSyntax> WithEndAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithCharacterOffsetAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithFileAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithEndOfDirectiveTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, bool, DirectiveTriviaSyntax> WithIsActiveAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken HashToken { get; }
    public SyntaxToken LineKeyword { get; }
    public LineDirectivePositionSyntaxWrapper Start { get; }
    public SyntaxToken MinusToken { get; }
    public LineDirectivePositionSyntaxWrapper End { get; }
    public SyntaxToken CharacterOffset { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    private static LineSpanDirectiveTriviaSyntaxWrapper();
    private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_HashToken();
    public SyntaxToken get_LineKeyword();
    public LineDirectivePositionSyntaxWrapper get_Start();
    public SyntaxToken get_MinusToken();
    public LineDirectivePositionSyntaxWrapper get_End();
    public SyntaxToken get_CharacterOffset();
    public SyntaxToken get_File();
    public SyntaxToken get_EndOfDirectiveToken();
    public bool get_IsActive();
    public static LineSpanDirectiveTriviaSyntaxWrapper op_Explicit(LineOrSpanDirectiveTriviaSyntaxWrapper node);
    public static LineSpanDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static LineOrSpanDirectiveTriviaSyntaxWrapper op_Implicit(LineSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static DirectiveTriviaSyntax op_Implicit(LineSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword);
    public LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start);
    public LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end);
    public LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset);
    public LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file);
    public LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(bool isActive);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ListPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<PatternSyntaxWrapper>> PatternsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<PatternSyntaxWrapper>, CSharpSyntaxNode> WithPatternsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxListWrapper`1<PatternSyntaxWrapper> Patterns { get; }
    public SyntaxToken CloseBracketToken { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static ListPatternSyntaxWrapper();
    private ListPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxListWrapper`1<PatternSyntaxWrapper> get_Patterns();
    public SyntaxToken get_CloseBracketToken();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static ListPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ListPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static ListPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ListPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(ListPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ListPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ListPatternSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public ListPatternSyntaxWrapper WithPatterns(SeparatedSyntaxListWrapper`1<PatternSyntaxWrapper> patterns);
    public ListPatternSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ListPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.LocalDeclarationStatementSyntaxExtensions : object {
    private static Func`2<LocalDeclarationStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`2<LocalDeclarationStatementSyntax, SyntaxToken> UsingKeywordAccessor;
    private static Func`3<LocalDeclarationStatementSyntax, SyntaxToken, LocalDeclarationStatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<LocalDeclarationStatementSyntax, SyntaxToken, LocalDeclarationStatementSyntax> WithUsingKeywordAccessor;
    private static LocalDeclarationStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(LocalDeclarationStatementSyntax syntax);
    [ExtensionAttribute]
public static SyntaxToken UsingKeyword(LocalDeclarationStatementSyntax syntax);
    [ExtensionAttribute]
public static LocalDeclarationStatementSyntax WithAwaitKeyword(LocalDeclarationStatementSyntax syntax, SyntaxToken awaitKeyword);
    [ExtensionAttribute]
public static LocalDeclarationStatementSyntax WithUsingKeyword(LocalDeclarationStatementSyntax syntax, SyntaxToken usingKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.LocalFunctionStatementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<StatementSyntax, TypeSyntax> ReturnTypeAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> IdentifierAccessor;
    private static Func`2<StatementSyntax, TypeParameterListSyntax> TypeParameterListAccessor;
    private static Func`2<StatementSyntax, ParameterListSyntax> ParameterListAccessor;
    private static Func`2<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>> ConstraintClausesAccessor;
    private static Func`2<StatementSyntax, BlockSyntax> BodyAccessor;
    private static Func`2<StatementSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> SemicolonTokenAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxTokenList, StatementSyntax> WithModifiersAccessor;
    private static Func`3<StatementSyntax, TypeSyntax, StatementSyntax> WithReturnTypeAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithIdentifierAccessor;
    private static Func`3<StatementSyntax, TypeParameterListSyntax, StatementSyntax> WithTypeParameterListAccessor;
    private static Func`3<StatementSyntax, ParameterListSyntax, StatementSyntax> WithParameterListAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, StatementSyntax> WithConstraintClausesAccessor;
    private static Func`3<StatementSyntax, BlockSyntax, StatementSyntax> WithBodyAccessor;
    private static Func`3<StatementSyntax, ArrowExpressionClauseSyntax, StatementSyntax> WithExpressionBodyAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithSemicolonTokenAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    private static LocalFunctionStatementSyntaxWrapper();
    private LocalFunctionStatementSyntaxWrapper(StatementSyntax node);
    public LocalFunctionStatementSyntaxWrapper AddModifiers(SyntaxToken[] items);
    public LocalFunctionStatementSyntaxWrapper AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddParameterListParameters(ParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddBodyStatements(StatementSyntax[] items);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public SyntaxToken get_SemicolonToken();
    public static LocalFunctionStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(LocalFunctionStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LocalFunctionStatementSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public LocalFunctionStatementSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public LocalFunctionStatementSyntaxWrapper WithReturnType(TypeSyntax returnType);
    public LocalFunctionStatementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public LocalFunctionStatementSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public LocalFunctionStatementSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public LocalFunctionStatementSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public LocalFunctionStatementSyntaxWrapper WithBody(BlockSyntax body);
    public LocalFunctionStatementSyntaxWrapper WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public LocalFunctionStatementSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.MemberDeclarationSyntaxExtensions : object {
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, MemberDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxTokenList, MemberDeclarationSyntax> WithModifiersAccessor;
    private static MemberDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> AttributeLists(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
public static SyntaxTokenList Modifiers(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithAttributeLists(MemberDeclarationSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithModifiers(MemberDeclarationSyntax syntax, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static MemberDeclarationSyntax AddAttributeLists(MemberDeclarationSyntax syntax, AttributeListSyntax[] items);
    [ExtensionAttribute]
public static MemberDeclarationSyntax AddModifiers(MemberDeclarationSyntax syntax, SyntaxToken[] items);
}
public static class StyleCop.Analyzers.Lightup.MethodKindEx : object {
    public static MethodKind LocalFunction;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.NullabilityInfo : ValueType {
    [CompilerGeneratedAttribute]
private NullableAnnotation <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableFlowState <FlowState>k__BackingField;
    public NullableAnnotation Annotation { get; }
    public NullableFlowState FlowState { get; }
    public NullabilityInfo(NullableAnnotation annotation, NullableFlowState flowState);
    [CompilerGeneratedAttribute]
public NullableAnnotation get_Annotation();
    [CompilerGeneratedAttribute]
public NullableFlowState get_FlowState();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NullabilityInfo left, NullabilityInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NullabilityInfo left, NullabilityInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullabilityInfo other);
}
public enum StyleCop.Analyzers.Lightup.NullableAnnotation : Enum {
    public byte value__;
    public static NullableAnnotation None;
    public static NullableAnnotation NotAnnotated;
    public static NullableAnnotation Annotated;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.NullableDirectiveTriviaSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> NullableKeywordAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> SettingTokenAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> TargetTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithHashTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithNullableKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithSettingTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithTargetTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithEndOfDirectiveTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, bool, DirectiveTriviaSyntax> WithIsActiveAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken HashToken { get; }
    public SyntaxToken NullableKeyword { get; }
    public SyntaxToken SettingToken { get; }
    public SyntaxToken TargetToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    private static NullableDirectiveTriviaSyntaxWrapper();
    private NullableDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_HashToken();
    public SyntaxToken get_NullableKeyword();
    public SyntaxToken get_SettingToken();
    public SyntaxToken get_TargetToken();
    public SyntaxToken get_EndOfDirectiveToken();
    public bool get_IsActive();
    public static NullableDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static DirectiveTriviaSyntax op_Implicit(NullableDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public NullableDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken);
    public NullableDirectiveTriviaSyntaxWrapper WithNullableKeyword(SyntaxToken nullableKeyword);
    public NullableDirectiveTriviaSyntaxWrapper WithSettingToken(SyntaxToken settingToken);
    public NullableDirectiveTriviaSyntaxWrapper WithTargetToken(SyntaxToken targetToken);
    public NullableDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public NullableDirectiveTriviaSyntaxWrapper WithIsActive(bool isActive);
}
public enum StyleCop.Analyzers.Lightup.NullableFlowState : Enum {
    public byte value__;
    public static NullableFlowState None;
    public static NullableFlowState NotNull;
    public static NullableFlowState MaybeNull;
}
public static class StyleCop.Analyzers.Lightup.OperationKindEx : object {
    public static OperationKind Invalid;
    public static OperationKind Block;
    public static OperationKind VariableDeclarationGroup;
    public static OperationKind Switch;
    public static OperationKind Loop;
    public static OperationKind Labeled;
    public static OperationKind Branch;
    public static OperationKind Empty;
    public static OperationKind Return;
    public static OperationKind YieldBreak;
    public static OperationKind Lock;
    public static OperationKind Try;
    public static OperationKind Using;
    public static OperationKind YieldReturn;
    public static OperationKind ExpressionStatement;
    public static OperationKind LocalFunction;
    public static OperationKind Stop;
    public static OperationKind End;
    public static OperationKind RaiseEvent;
    public static OperationKind Literal;
    public static OperationKind Conversion;
    public static OperationKind Invocation;
    public static OperationKind ArrayElementReference;
    public static OperationKind LocalReference;
    public static OperationKind ParameterReference;
    public static OperationKind FieldReference;
    public static OperationKind MethodReference;
    public static OperationKind PropertyReference;
    public static OperationKind EventReference;
    public static OperationKind Unary;
    public static OperationKind Binary;
    public static OperationKind Conditional;
    public static OperationKind Coalesce;
    public static OperationKind AnonymousFunction;
    public static OperationKind ObjectCreation;
    public static OperationKind TypeParameterObjectCreation;
    public static OperationKind ArrayCreation;
    public static OperationKind InstanceReference;
    public static OperationKind IsType;
    public static OperationKind Await;
    public static OperationKind SimpleAssignment;
    public static OperationKind CompoundAssignment;
    public static OperationKind Parenthesized;
    public static OperationKind EventAssignment;
    public static OperationKind ConditionalAccess;
    public static OperationKind ConditionalAccessInstance;
    public static OperationKind InterpolatedString;
    public static OperationKind AnonymousObjectCreation;
    public static OperationKind ObjectOrCollectionInitializer;
    public static OperationKind MemberInitializer;
    public static OperationKind CollectionElementInitializer;
    public static OperationKind NameOf;
    public static OperationKind Tuple;
    public static OperationKind DynamicObjectCreation;
    public static OperationKind DynamicMemberReference;
    public static OperationKind DynamicInvocation;
    public static OperationKind DynamicIndexerAccess;
    public static OperationKind TranslatedQuery;
    public static OperationKind DelegateCreation;
    public static OperationKind DefaultValue;
    public static OperationKind TypeOf;
    public static OperationKind SizeOf;
    public static OperationKind AddressOf;
    public static OperationKind IsPattern;
    public static OperationKind Increment;
    public static OperationKind Throw;
    public static OperationKind Decrement;
    public static OperationKind DeconstructionAssignment;
    public static OperationKind DeclarationExpression;
    public static OperationKind OmittedArgument;
    public static OperationKind FieldInitializer;
    public static OperationKind VariableInitializer;
    public static OperationKind PropertyInitializer;
    public static OperationKind ParameterInitializer;
    public static OperationKind ArrayInitializer;
    public static OperationKind VariableDeclarator;
    public static OperationKind VariableDeclaration;
    public static OperationKind Argument;
    public static OperationKind CatchClause;
    public static OperationKind SwitchCase;
    public static OperationKind CaseClause;
    public static OperationKind InterpolatedStringText;
    public static OperationKind Interpolation;
    public static OperationKind ConstantPattern;
    public static OperationKind DeclarationPattern;
    public static OperationKind TupleBinary;
    public static OperationKind MethodBody;
    public static OperationKind ConstructorBody;
    public static OperationKind Discard;
    public static OperationKind FlowCapture;
    public static OperationKind FlowCaptureReference;
    public static OperationKind IsNull;
    public static OperationKind CaughtException;
    public static OperationKind StaticLocalInitializationSemaphore;
    public static OperationKind FlowAnonymousFunction;
    public static OperationKind CoalesceAssignment;
    public static OperationKind Range;
    public static OperationKind ReDim;
    public static OperationKind ReDimClause;
    public static OperationKind RecursivePattern;
    public static OperationKind DiscardPattern;
    public static OperationKind SwitchExpression;
    public static OperationKind SwitchExpressionArm;
    public static OperationKind PropertySubpattern;
    public static OperationKind UsingDeclaration;
    public static OperationKind NegatedPattern;
    public static OperationKind BinaryPattern;
    public static OperationKind TypePattern;
    public static OperationKind RelationalPattern;
    public static OperationKind With;
    public static OperationKind InterpolatedStringHandlerCreation;
    public static OperationKind InterpolatedStringAddition;
    public static OperationKind InterpolatedStringAppendLiteral;
    public static OperationKind InterpolatedStringAppendFormatted;
    public static OperationKind InterpolatedStringAppendInvalid;
    public static OperationKind InterpolatedStringHandlerArgumentPlaceholder;
    public static OperationKind FunctionPointerInvocation;
    public static OperationKind ListPattern;
    public static OperationKind SlicePattern;
    public static OperationKind ImplicitIndexerReference;
    public static OperationKind Utf8String;
    public static OperationKind Attribute;
    public static OperationKind InlineArrayAccess;
    public static OperationKind CollectionExpression;
    public static OperationKind Spread;
}
public static class StyleCop.Analyzers.Lightup.OperationWrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static OperationWrapperHelper();
    public static Type GetWrappedType(Type wrapperType);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ParenthesizedLambdaExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, TypeSyntax> ReturnTypeAccessor;
    private static Func`2<ExpressionSyntax, ParameterListSyntax> ParameterListAccessor;
    private static Func`3<ExpressionSyntax, SyntaxList`1<AttributeListSyntax>, ExpressionSyntax> WithAttributeListsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxTokenList, ExpressionSyntax> WithModifiersAccessor;
    private static Func`3<ExpressionSyntax, TypeSyntax, ExpressionSyntax> WithReturnTypeAccessor;
    private static Func`3<ExpressionSyntax, ParameterListSyntax, ExpressionSyntax> WithParameterListAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithArrowTokenAccessor;
    private static Func`3<ExpressionSyntax, BlockSyntax, ExpressionSyntax> WithBlockAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionBodyAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxToken ArrowToken { get; }
    public BlockSyntax Block { get; }
    public ExpressionSyntax ExpressionBody { get; }
    private static ParenthesizedLambdaExpressionSyntaxWrapper();
    private ParenthesizedLambdaExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public ParameterListSyntax get_ParameterList();
    public SyntaxToken get_ArrowToken();
    public BlockSyntax get_Block();
    public ExpressionSyntax get_ExpressionBody();
    public static ParenthesizedLambdaExpressionSyntaxWrapper op_Explicit(LambdaExpressionSyntaxWrapper node);
    public static ParenthesizedLambdaExpressionSyntaxWrapper op_Explicit(AnonymousFunctionExpressionSyntaxWrapper node);
    public static ParenthesizedLambdaExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static LambdaExpressionSyntaxWrapper op_Implicit(ParenthesizedLambdaExpressionSyntaxWrapper wrapper);
    public static AnonymousFunctionExpressionSyntaxWrapper op_Implicit(ParenthesizedLambdaExpressionSyntaxWrapper wrapper);
    public static ExpressionSyntax op_Implicit(ParenthesizedLambdaExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithReturnType(TypeSyntax returnType);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithArrowToken(SyntaxToken arrowToken);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithBlock(BlockSyntax block);
    public ParenthesizedLambdaExpressionSyntaxWrapper WithExpressionBody(ExpressionSyntax expressionBody);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ParenthesizedPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public SyntaxToken CloseParenToken { get; }
    private static ParenthesizedPatternSyntaxWrapper();
    private ParenthesizedPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public PatternSyntaxWrapper get_Pattern();
    public SyntaxToken get_CloseParenToken();
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedPatternSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ParenthesizedPatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public ParenthesizedPatternSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ParenthesizedVariableDesignationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>> VariablesAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>, CSharpSyntaxNode> WithVariablesAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> Variables { get; }
    public SyntaxToken CloseParenToken { get; }
    private static ParenthesizedVariableDesignationSyntaxWrapper();
    private ParenthesizedVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public ParenthesizedVariableDesignationSyntaxWrapper AddVariables(VariableDesignationSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> get_Variables();
    public SyntaxToken get_CloseParenToken();
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedVariableDesignationSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ParenthesizedVariableDesignationSyntaxWrapper WithVariables(SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> variables);
    public ParenthesizedVariableDesignationSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.PatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static PatternSyntaxWrapper();
    private PatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static PatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static PatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(PatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(PatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public static PatternSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.PositionalPatternClauseSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>> SubpatternsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> WithSubpatternsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> Subpatterns { get; }
    public SyntaxToken CloseParenToken { get; }
    private static PositionalPatternClauseSyntaxWrapper();
    private PositionalPatternClauseSyntaxWrapper(CSharpSyntaxNode node);
    public PositionalPatternClauseSyntaxWrapper AddSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> get_Subpatterns();
    public SyntaxToken get_CloseParenToken();
    public static PositionalPatternClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(PositionalPatternClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PositionalPatternClauseSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public PositionalPatternClauseSyntaxWrapper WithSubpatterns(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public PositionalPatternClauseSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<BaseTypeSyntax, ArgumentListSyntax> ArgumentListAccessor;
    private static Func`3<BaseTypeSyntax, TypeSyntax, BaseTypeSyntax> WithTypeAccessor;
    private static Func`3<BaseTypeSyntax, ArgumentListSyntax, BaseTypeSyntax> WithArgumentListAccessor;
    private BaseTypeSyntax node;
    public BaseTypeSyntax SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArgumentList { get; }
    private static PrimaryConstructorBaseTypeSyntaxWrapper();
    private PrimaryConstructorBaseTypeSyntaxWrapper(BaseTypeSyntax node);
    public sealed virtual BaseTypeSyntax get_SyntaxNode();
    public TypeSyntax get_Type();
    public ArgumentListSyntax get_ArgumentList();
    public static PrimaryConstructorBaseTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseTypeSyntax op_Implicit(PrimaryConstructorBaseTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PrimaryConstructorBaseTypeSyntaxWrapper WithType(TypeSyntax type);
    public PrimaryConstructorBaseTypeSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.PropertyPatternClauseSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenBraceTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>> SubpatternsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseBraceTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenBraceTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> WithSubpatternsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseBraceTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> Subpatterns { get; }
    public SyntaxToken CloseBraceToken { get; }
    private static PropertyPatternClauseSyntaxWrapper();
    private PropertyPatternClauseSyntaxWrapper(CSharpSyntaxNode node);
    public PropertyPatternClauseSyntaxWrapper AddSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> get_Subpatterns();
    public SyntaxToken get_CloseBraceToken();
    public static PropertyPatternClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(PropertyPatternClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PropertyPatternClauseSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public PropertyPatternClauseSyntaxWrapper WithSubpatterns(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public PropertyPatternClauseSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RangeExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> LeftOperandAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> RightOperandAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithLeftOperandAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOperatorTokenAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithRightOperandAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax LeftOperand { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax RightOperand { get; }
    private static RangeExpressionSyntaxWrapper();
    private RangeExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_LeftOperand();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_RightOperand();
    public static RangeExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(RangeExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RangeExpressionSyntaxWrapper WithLeftOperand(ExpressionSyntax leftOperand);
    public RangeExpressionSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public RangeExpressionSyntaxWrapper WithRightOperand(ExpressionSyntax rightOperand);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RecordDeclarationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeDeclarationSyntax, SyntaxToken> ClassOrStructKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, TypeDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxTokenList, TypeDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithClassOrStructKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithIdentifierAccessor;
    private static Func`3<TypeDeclarationSyntax, TypeParameterListSyntax, TypeDeclarationSyntax> WithTypeParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, ParameterListSyntax, TypeDeclarationSyntax> WithParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, BaseListSyntax, TypeDeclarationSyntax> WithBaseListAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, TypeDeclarationSyntax> WithConstraintClausesAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, TypeDeclarationSyntax> WithMembersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithCloseBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithSemicolonTokenAccessor;
    private TypeDeclarationSyntax node;
    public TypeDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken ClassOrStructKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    private static RecordDeclarationSyntaxWrapper();
    private RecordDeclarationSyntaxWrapper(TypeDeclarationSyntax node);
    public sealed virtual TypeDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Keyword();
    public SyntaxToken get_ClassOrStructKeyword();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public BaseListSyntax get_BaseList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    public static RecordDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeDeclarationSyntax op_Implicit(RecordDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RecordDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public RecordDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public RecordDeclarationSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public RecordDeclarationSyntaxWrapper WithClassOrStructKeyword(SyntaxToken classOrStructKeyword);
    public RecordDeclarationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public RecordDeclarationSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public RecordDeclarationSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public RecordDeclarationSyntaxWrapper WithBaseList(BaseListSyntax baseList);
    public RecordDeclarationSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public RecordDeclarationSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public RecordDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public RecordDeclarationSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
    public RecordDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RecursivePatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PositionalPatternClauseAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PropertyPatternClauseAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPositionalPatternClauseAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPropertyPatternClauseAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public PositionalPatternClauseSyntaxWrapper PositionalPatternClause { get; }
    public PropertyPatternClauseSyntaxWrapper PropertyPatternClause { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static RecursivePatternSyntaxWrapper();
    private RecursivePatternSyntaxWrapper(CSharpSyntaxNode node);
    public RecursivePatternSyntaxWrapper AddPositionalPatternClauseSubpatterns(SubpatternSyntaxWrapper[] items);
    public RecursivePatternSyntaxWrapper AddPropertyPatternClauseSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public PositionalPatternClauseSyntaxWrapper get_PositionalPatternClause();
    public PropertyPatternClauseSyntaxWrapper get_PropertyPatternClause();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static RecursivePatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static RecursivePatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static RecursivePatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RecursivePatternSyntaxWrapper WithType(TypeSyntax type);
    public RecursivePatternSyntaxWrapper WithPositionalPatternClause(PositionalPatternClauseSyntaxWrapper positionalPatternClause);
    public RecursivePatternSyntaxWrapper WithPropertyPatternClause(PropertyPatternClauseSyntaxWrapper propertyPatternClause);
    public RecursivePatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RefExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithRefKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static RefExpressionSyntaxWrapper();
    private RefExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public ExpressionSyntax get_Expression();
    public static RefExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(RefExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefExpressionSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RefStructConstraintSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> RefKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> StructKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithRefKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithStructKeywordAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public SyntaxToken StructKeyword { get; }
    private static RefStructConstraintSyntaxWrapper();
    private RefStructConstraintSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public SyntaxToken get_StructKeyword();
    public static RefStructConstraintSyntaxWrapper op_Explicit(AllowsConstraintSyntaxWrapper node);
    public static RefStructConstraintSyntaxWrapper op_Explicit(SyntaxNode node);
    public static AllowsConstraintSyntaxWrapper op_Implicit(RefStructConstraintSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(RefStructConstraintSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefStructConstraintSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefStructConstraintSyntaxWrapper WithStructKeyword(SyntaxToken structKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RefTypeSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> ReadOnlyKeywordAccessor;
    private static Func`2<TypeSyntax, TypeSyntax> TypeAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithRefKeywordAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithReadOnlyKeywordAccessor;
    private static Func`3<TypeSyntax, TypeSyntax, TypeSyntax> WithTypeAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public SyntaxToken ReadOnlyKeyword { get; }
    public TypeSyntax Type { get; }
    private static RefTypeSyntaxWrapper();
    private RefTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public SyntaxToken get_ReadOnlyKeyword();
    public TypeSyntax get_Type();
    public static RefTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(RefTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefTypeSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefTypeSyntaxWrapper WithReadOnlyKeyword(SyntaxToken readOnlyKeyword);
    public RefTypeSyntaxWrapper WithType(TypeSyntax type);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.RelationalPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Expression { get; }
    private static RelationalPatternSyntaxWrapper();
    private RelationalPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Expression();
    public static RelationalPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static RelationalPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static RelationalPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RelationalPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public RelationalPatternSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ScopedTypeSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> ScopedKeywordAccessor;
    private static Func`2<TypeSyntax, TypeSyntax> TypeAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithScopedKeywordAccessor;
    private static Func`3<TypeSyntax, TypeSyntax, TypeSyntax> WithTypeAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken ScopedKeyword { get; }
    public TypeSyntax Type { get; }
    private static ScopedTypeSyntaxWrapper();
    private ScopedTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_ScopedKeyword();
    public TypeSyntax get_Type();
    public static ScopedTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(ScopedTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ScopedTypeSyntaxWrapper WithScopedKeyword(SyntaxToken scopedKeyword);
    public ScopedTypeSyntaxWrapper WithType(TypeSyntax type);
}
[DefaultMemberAttribute("Item")]
public abstract class StyleCop.Analyzers.Lightup.SeparatedSyntaxListWrapper`1 : object {
    private static SyntaxWrapper`1<TNode> SyntaxWrapper;
    [CompilerGeneratedAttribute]
private static SeparatedSyntaxListWrapper`1<TNode> <UnsupportedEmpty>k__BackingField;
    public static SeparatedSyntaxListWrapper`1<TNode> UnsupportedEmpty { get; }
    public int Count { get; }
    public TextSpan FullSpan { get; }
    public int SeparatorCount { get; }
    public TextSpan Span { get; }
    [EditorBrowsableAttribute("1")]
public object UnderlyingList { get; }
    public TNode Item { get; }
    private static SeparatedSyntaxListWrapper`1();
    [CompilerGeneratedAttribute]
public static SeparatedSyntaxListWrapper`1<TNode> get_UnsupportedEmpty();
    public abstract virtual int get_Count();
    public abstract virtual TextSpan get_FullSpan();
    public abstract virtual int get_SeparatorCount();
    public abstract virtual TextSpan get_Span();
    public abstract virtual object get_UnderlyingList();
    public abstract virtual TNode get_Item(int index);
    public static bool op_Equality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public SeparatedSyntaxListWrapper`1<TNode> Add(TNode node);
    public SeparatedSyntaxListWrapper`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public abstract virtual bool Any();
    public abstract virtual bool Contains(TNode node);
    public sealed virtual bool Equals(SeparatedSyntaxListWrapper`1<TNode> other);
    public virtual bool Equals(object obj);
    public abstract virtual TNode First();
    public abstract virtual TNode FirstOrDefault();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual int GetHashCode();
    public abstract virtual SyntaxToken GetSeparator(int index);
    public abstract virtual IEnumerable`1<SyntaxToken> GetSeparators();
    public abstract virtual SyntaxNodeOrTokenList GetWithSeparators();
    public abstract virtual int IndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int IndexOf(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Insert(int index, TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    public abstract virtual TNode Last();
    public abstract virtual int LastIndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int LastIndexOf(TNode node);
    public abstract virtual TNode LastOrDefault();
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Remove(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> RemoveAt(int index);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
    public abstract virtual string ToFullString();
    public abstract virtual string ToString();
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SimpleLambdaExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ParameterSyntax> ParameterAccessor;
    private static Func`3<ExpressionSyntax, SyntaxList`1<AttributeListSyntax>, ExpressionSyntax> WithAttributeListsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxTokenList, ExpressionSyntax> WithModifiersAccessor;
    private static Func`3<ExpressionSyntax, ParameterSyntax, ExpressionSyntax> WithParameterAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithArrowTokenAccessor;
    private static Func`3<ExpressionSyntax, BlockSyntax, ExpressionSyntax> WithBlockAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionBodyAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public ParameterSyntax Parameter { get; }
    public SyntaxToken ArrowToken { get; }
    public BlockSyntax Block { get; }
    public ExpressionSyntax ExpressionBody { get; }
    private static SimpleLambdaExpressionSyntaxWrapper();
    private SimpleLambdaExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public ParameterSyntax get_Parameter();
    public SyntaxToken get_ArrowToken();
    public BlockSyntax get_Block();
    public ExpressionSyntax get_ExpressionBody();
    public static SimpleLambdaExpressionSyntaxWrapper op_Explicit(LambdaExpressionSyntaxWrapper node);
    public static SimpleLambdaExpressionSyntaxWrapper op_Explicit(AnonymousFunctionExpressionSyntaxWrapper node);
    public static SimpleLambdaExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static LambdaExpressionSyntaxWrapper op_Implicit(SimpleLambdaExpressionSyntaxWrapper wrapper);
    public static AnonymousFunctionExpressionSyntaxWrapper op_Implicit(SimpleLambdaExpressionSyntaxWrapper wrapper);
    public static ExpressionSyntax op_Implicit(SimpleLambdaExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SimpleLambdaExpressionSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public SimpleLambdaExpressionSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public SimpleLambdaExpressionSyntaxWrapper WithParameter(ParameterSyntax parameter);
    public SimpleLambdaExpressionSyntaxWrapper WithArrowToken(SyntaxToken arrowToken);
    public SimpleLambdaExpressionSyntaxWrapper WithBlock(BlockSyntax block);
    public SimpleLambdaExpressionSyntaxWrapper WithExpressionBody(ExpressionSyntax expressionBody);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SingleVariableDesignationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Identifier { get; }
    private static SingleVariableDesignationSyntaxWrapper();
    private SingleVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Identifier();
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SingleVariableDesignationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SlicePatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> DotDotTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithDotDotTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken DotDotToken { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static SlicePatternSyntaxWrapper();
    private SlicePatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_DotDotToken();
    public PatternSyntaxWrapper get_Pattern();
    public static SlicePatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static SlicePatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static SlicePatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(SlicePatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(SlicePatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(SlicePatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SlicePatternSyntaxWrapper WithDotDotToken(SyntaxToken dotDotToken);
    public SlicePatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SpreadElementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Expression { get; }
    private static SpreadElementSyntaxWrapper();
    private SpreadElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Expression();
    public static SpreadElementSyntaxWrapper op_Explicit(CollectionElementSyntaxWrapper node);
    public static SpreadElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CollectionElementSyntaxWrapper op_Implicit(SpreadElementSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(SpreadElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SpreadElementSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public SpreadElementSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.StackAllocArrayCreationExpressionSyntaxExtensions : object {
    private static Func`2<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax, StackAllocArrayCreationExpressionSyntax> WithInitializerAccessor;
    private static StackAllocArrayCreationExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static InitializerExpressionSyntax Initializer(StackAllocArrayCreationExpressionSyntax syntax);
    [ExtensionAttribute]
public static StackAllocArrayCreationExpressionSyntax WithInitializer(StackAllocArrayCreationExpressionSyntax syntax, InitializerExpressionSyntax initializer);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.StatementSyntaxExtensions : object {
    private static Func`2<StatementSyntax, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static StatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> AttributeLists(StatementSyntax syntax);
    [ExtensionAttribute]
public static StatementSyntax WithAttributeLists(StatementSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static StatementSyntax AddAttributeLists(StatementSyntax syntax, AttributeListSyntax[] items);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.StructDeclarationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, TypeDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxTokenList, TypeDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithIdentifierAccessor;
    private static Func`3<TypeDeclarationSyntax, TypeParameterListSyntax, TypeDeclarationSyntax> WithTypeParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, ParameterListSyntax, TypeDeclarationSyntax> WithParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, BaseListSyntax, TypeDeclarationSyntax> WithBaseListAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, TypeDeclarationSyntax> WithConstraintClausesAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, TypeDeclarationSyntax> WithMembersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithCloseBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithSemicolonTokenAccessor;
    private TypeDeclarationSyntax node;
    public TypeDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    private static StructDeclarationSyntaxWrapper();
    private StructDeclarationSyntaxWrapper(TypeDeclarationSyntax node);
    public sealed virtual TypeDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Keyword();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public BaseListSyntax get_BaseList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    public static StructDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeDeclarationSyntax op_Implicit(StructDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public StructDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public StructDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public StructDeclarationSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public StructDeclarationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public StructDeclarationSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public StructDeclarationSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public StructDeclarationSyntaxWrapper WithBaseList(BaseListSyntax baseList);
    public StructDeclarationSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public StructDeclarationSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public StructDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public StructDeclarationSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
    public StructDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SubpatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> ExpressionColonAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithExpressionColonAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public BaseExpressionColonSyntaxWrapper ExpressionColon { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static SubpatternSyntaxWrapper();
    private SubpatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public BaseExpressionColonSyntaxWrapper get_ExpressionColon();
    public PatternSyntaxWrapper get_Pattern();
    public static SubpatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(SubpatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SubpatternSyntaxWrapper WithExpressionColon(BaseExpressionColonSyntaxWrapper expressionColon);
    public SubpatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SwitchExpressionArmSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> WhenClauseAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> EqualsGreaterThanTokenAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithWhenClauseAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithEqualsGreaterThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public WhenClauseSyntaxWrapper WhenClause { get; }
    public SyntaxToken EqualsGreaterThanToken { get; }
    public ExpressionSyntax Expression { get; }
    private static SwitchExpressionArmSyntaxWrapper();
    private SwitchExpressionArmSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public PatternSyntaxWrapper get_Pattern();
    public WhenClauseSyntaxWrapper get_WhenClause();
    public SyntaxToken get_EqualsGreaterThanToken();
    public ExpressionSyntax get_Expression();
    public static SwitchExpressionArmSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(SwitchExpressionArmSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SwitchExpressionArmSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public SwitchExpressionArmSyntaxWrapper WithWhenClause(WhenClauseSyntaxWrapper whenClause);
    public SwitchExpressionArmSyntaxWrapper WithEqualsGreaterThanToken(SyntaxToken equalsGreaterThanToken);
    public SwitchExpressionArmSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SwitchExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> GoverningExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> SwitchKeywordAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBraceTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper>> ArmsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBraceTokenAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithGoverningExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithSwitchKeywordAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper>, ExpressionSyntax> WithArmsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBraceTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax GoverningExpression { get; }
    public SyntaxToken SwitchKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> Arms { get; }
    public SyntaxToken CloseBraceToken { get; }
    private static SwitchExpressionSyntaxWrapper();
    private SwitchExpressionSyntaxWrapper(ExpressionSyntax node);
    public SwitchExpressionSyntaxWrapper AddArms(SwitchExpressionArmSyntaxWrapper[] arms);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_GoverningExpression();
    public SyntaxToken get_SwitchKeyword();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> get_Arms();
    public SyntaxToken get_CloseBraceToken();
    public static SwitchExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(SwitchExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SwitchExpressionSyntaxWrapper WithGoverningExpression(ExpressionSyntax governingExpression);
    public SwitchExpressionSyntaxWrapper WithSwitchKeyword(SyntaxToken switchKeyword);
    public SwitchExpressionSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public SwitchExpressionSyntaxWrapper WithArms(SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> arms);
    public SwitchExpressionSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
}
public static class StyleCop.Analyzers.Lightup.SymbolDisplayLocalOptionsEx : object {
    public static SymbolDisplayLocalOptions IncludeRef;
}
public static class StyleCop.Analyzers.Lightup.SymbolDisplayMemberOptionsEx : object {
    public static SymbolDisplayMemberOptions IncludeRef;
}
public static class StyleCop.Analyzers.Lightup.SymbolKindEx : object {
    public static SymbolKind Discard;
    public static SymbolKind FunctionPointerType;
}
public static class StyleCop.Analyzers.Lightup.SyntaxFactoryEx : object {
    private static Func`2<SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> PositionalPatternClauseAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, SyntaxToken, CSharpSyntaxNode> PositionalPatternClauseAccessor2;
    private static Func`2<SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> PropertyPatternClauseAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, SyntaxToken, CSharpSyntaxNode> PropertyPatternClauseAccessor2;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> TupleElementAccessor1;
    private static Func`3<TypeSyntax, SyntaxToken, CSharpSyntaxNode> TupleElementAccessor2;
    private static Func`2<SeparatedSyntaxList`1<ArgumentSyntax>, ExpressionSyntax> TupleExpressionAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxList`1<ArgumentSyntax>, SyntaxToken, ExpressionSyntax> TupleExpressionAccessor2;
    private static Func`2<SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, TypeSyntax> TupleTypeAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, SyntaxToken, TypeSyntax> TupleTypeAccessor2;
    private static SyntaxFactoryEx();
    public static PositionalPatternClauseSyntaxWrapper PositionalPatternClause(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public static PositionalPatternClauseSyntaxWrapper PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns, SyntaxToken closeParenToken);
    public static PropertyPatternClauseSyntaxWrapper PropertyPatternClause(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public static PropertyPatternClauseSyntaxWrapper PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns, SyntaxToken closeBraceToken);
    public static TupleElementSyntaxWrapper TupleElement(TypeSyntax type);
    public static TupleElementSyntaxWrapper TupleElement(TypeSyntax type, SyntaxToken identifier);
    public static TupleExpressionSyntaxWrapper TupleExpression(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public static TupleExpressionSyntaxWrapper TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static TupleTypeSyntaxWrapper TupleType(SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements);
    public static TupleTypeSyntaxWrapper TupleType(SyntaxToken openParenToken, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements, SyntaxToken closeParenToken);
    private static Func`2<T, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
    private static Func`3<T1, T2, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
    private static Func`4<T1, T2, T3, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.SyntaxFactsEx : object {
    private static Func`2<SyntaxNode, string> TryGetInferredMemberNameAccessor;
    private static Func`2<string, bool> IsReservedTupleElementNameAccessor;
    private static SyntaxFactsEx();
    [ExtensionAttribute]
public static string TryGetInferredMemberName(SyntaxNode syntax);
    public static bool IsReservedTupleElementName(string elementName);
    [CompilerGeneratedAttribute]
internal static string <.cctor>g__FallbackAccessor|2_0(SyntaxNode syntax);
}
public static class StyleCop.Analyzers.Lightup.SyntaxKindEx : object {
    public static SyntaxKind GreaterThanGreaterThanGreaterThanToken;
    public static SyntaxKind GreaterThanGreaterThanGreaterThanEqualsToken;
    public static SyntaxKind NameOfKeyword;
    public static SyntaxKind SingleLineRawStringLiteralToken;
    public static SyntaxKind MultiLineRawStringLiteralToken;
    public static SyntaxKind Utf8StringLiteralToken;
    public static SyntaxKind Utf8SingleLineRawStringLiteralToken;
    public static SyntaxKind Utf8MultiLineRawStringLiteralToken;
    public static SyntaxKind PragmaChecksumDirectiveTrivia;
    public static SyntaxKind Utf8StringLiteralExpression;
    public static SyntaxKind GlobalStatement;
    public static SyntaxKind ArrowExpressionClause;
    public static SyntaxKind RelationalPattern;
    public static SyntaxKind TypePattern;
    public static SyntaxKind OrPattern;
    public static SyntaxKind AndPattern;
    public static SyntaxKind NotPattern;
    public static SyntaxKind FunctionPointerParameterList;
    public static SyntaxKind FunctionPointerCallingConvention;
    public static SyntaxKind FunctionPointerUnmanagedCallingConvention;
    public static SyntaxKind ExpressionColon;
    public static SyntaxKind InterpolatedSingleLineRawStringStartToken;
    public static SyntaxKind InterpolatedMultiLineRawStringStartToken;
    public static SyntaxKind InterpolatedRawStringEndToken;
    public static SyntaxKind ScopedType;
    public static SyntaxKind SpreadElement;
    public static SyntaxKind DotDotToken;
    public static SyntaxKind QuestionQuestionEqualsToken;
    public static SyntaxKind OrKeyword;
    public static SyntaxKind AndKeyword;
    public static SyntaxKind NotKeyword;
    public static SyntaxKind InitKeyword;
    public static SyntaxKind ManagedKeyword;
    public static SyntaxKind UnmanagedKeyword;
    public static SyntaxKind RequiredKeyword;
    public static SyntaxKind FileKeyword;
    public static SyntaxKind NullableKeyword;
    public static SyntaxKind EnableKeyword;
    public static SyntaxKind WarningsKeyword;
    public static SyntaxKind AnnotationsKeyword;
    public static SyntaxKind VarKeyword;
    public static SyntaxKind UnderscoreToken;
    public static SyntaxKind ConflictMarkerTrivia;
    public static SyntaxKind IsPatternExpression;
    public static SyntaxKind RangeExpression;
    public static SyntaxKind ImplicitObjectCreationExpression;
    public static SyntaxKind UnsignedRightShiftExpression;
    public static SyntaxKind CoalesceAssignmentExpression;
    public static SyntaxKind UnsignedRightShiftAssignmentExpression;
    public static SyntaxKind IndexExpression;
    public static SyntaxKind DefaultLiteralExpression;
    public static SyntaxKind LocalFunctionStatement;
    public static SyntaxKind FileScopedNamespaceDeclaration;
    public static SyntaxKind TupleType;
    public static SyntaxKind TupleElement;
    public static SyntaxKind TupleExpression;
    public static SyntaxKind SingleVariableDesignation;
    public static SyntaxKind ParenthesizedVariableDesignation;
    public static SyntaxKind ForEachVariableStatement;
    public static SyntaxKind DeclarationPattern;
    public static SyntaxKind ConstantPattern;
    public static SyntaxKind CasePatternSwitchLabel;
    public static SyntaxKind WhenClause;
    public static SyntaxKind DiscardDesignation;
    public static SyntaxKind RecursivePattern;
    public static SyntaxKind PropertyPatternClause;
    public static SyntaxKind Subpattern;
    public static SyntaxKind PositionalPatternClause;
    public static SyntaxKind DiscardPattern;
    public static SyntaxKind SwitchExpression;
    public static SyntaxKind SwitchExpressionArm;
    public static SyntaxKind VarPattern;
    public static SyntaxKind ParenthesizedPattern;
    public static SyntaxKind SlicePattern;
    public static SyntaxKind ListPattern;
    public static SyntaxKind DeclarationExpression;
    public static SyntaxKind RefExpression;
    public static SyntaxKind RefType;
    public static SyntaxKind ThrowExpression;
    public static SyntaxKind ImplicitStackAllocArrayCreationExpression;
    public static SyntaxKind SuppressNullableWarningExpression;
    public static SyntaxKind NullableDirectiveTrivia;
    public static SyntaxKind FunctionPointerType;
    public static SyntaxKind FunctionPointerParameter;
    public static SyntaxKind InitAccessorDeclaration;
    public static SyntaxKind WithExpression;
    public static SyntaxKind WithInitializerExpression;
    public static SyntaxKind RecordDeclaration;
    public static SyntaxKind PrimaryConstructorBaseType;
    public static SyntaxKind FunctionPointerUnmanagedCallingConventionList;
    public static SyntaxKind RecordStructDeclaration;
    public static SyntaxKind CollectionExpression;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.SyntaxTreeOptionsProviderWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static TryGetValueAccessor`5<object, SyntaxTree, string, CancellationToken, ReportDiagnostic> TryGetDiagnosticValueAccessor;
    private static TryGetValueAccessor`4<object, string, CancellationToken, ReportDiagnostic> TryGetGlobalDiagnosticValueAccessor;
    private object node;
    private static SyntaxTreeOptionsProviderWrapper();
    private SyntaxTreeOptionsProviderWrapper(object node);
    public static SyntaxTreeOptionsProviderWrapper FromObject(object node);
    public static bool IsInstance(object obj);
    public bool TryGetDiagnosticValue(SyntaxTree tree, string diagnosticId, CancellationToken cancellationToken, ReportDiagnostic& severity);
    public bool TryGetGlobalDiagnosticValue(string diagnosticId, CancellationToken cancellationToken, ReportDiagnostic& severity);
}
public abstract class StyleCop.Analyzers.Lightup.SyntaxWrapper`1 : object {
    [CompilerGeneratedAttribute]
private static SyntaxWrapper`1<TNode> <Default>k__BackingField;
    public static SyntaxWrapper`1<TNode> Default { get; }
    private static SyntaxWrapper`1();
    [CompilerGeneratedAttribute]
public static SyntaxWrapper`1<TNode> get_Default();
    public abstract virtual TNode Wrap(SyntaxNode node);
    public abstract virtual SyntaxNode Unwrap(TNode node);
    private static SyntaxWrapper`1<TNode> FindDefaultSyntaxWrapper();
}
public static class StyleCop.Analyzers.Lightup.SyntaxWrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static SyntaxWrapperHelper();
    public static Type GetWrappedType(Type wrapperType);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.ThrowExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> ThrowKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithThrowKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static ThrowExpressionSyntaxWrapper();
    private ThrowExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_ThrowKeyword();
    public ExpressionSyntax get_Expression();
    public static ThrowExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ThrowExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ThrowExpressionSyntaxWrapper WithThrowKeyword(SyntaxToken throwKeyword);
    public ThrowExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Lightup.TryGetValueAccessor`3 : MulticastDelegate {
    public TryGetValueAccessor`3(object object, IntPtr method);
    public virtual bool Invoke(T instance, TKey key, TValue& value);
    public virtual IAsyncResult BeginInvoke(T instance, TKey key, TValue& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(TValue& value, IAsyncResult result);
}
internal class StyleCop.Analyzers.Lightup.TryGetValueAccessor`4 : MulticastDelegate {
    public TryGetValueAccessor`4(object object, IntPtr method);
    public virtual bool Invoke(T instance, TFirst first, TSecond second, TValue& value);
    public virtual IAsyncResult BeginInvoke(T instance, TFirst first, TSecond second, TValue& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(TValue& value, IAsyncResult result);
}
internal class StyleCop.Analyzers.Lightup.TryGetValueAccessor`5 : MulticastDelegate {
    public TryGetValueAccessor`5(object object, IntPtr method);
    public virtual bool Invoke(T instance, TFirst first, TSecond second, TThird third, TValue& value);
    public virtual IAsyncResult BeginInvoke(T instance, TFirst first, TSecond second, TThird third, TValue& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(TValue& value, IAsyncResult result);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.TupleElementSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    private static TupleElementSyntaxWrapper();
    private TupleElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public static TupleElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(TupleElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleElementSyntaxWrapper WithType(TypeSyntax type);
    public TupleElementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.TupleExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>> ArgumentsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>, ExpressionSyntax> WithArgumentsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseParenTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleExpressionSyntaxWrapper();
    private TupleExpressionSyntaxWrapper(ExpressionSyntax node);
    public TupleExpressionSyntaxWrapper AddArguments(ArgumentSyntax[] items);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    public static TupleExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(TupleExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleExpressionSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleExpressionSyntaxWrapper WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public TupleExpressionSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.TupleTypeSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>> ElementsAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithOpenParenTokenAccessor;
    private static Func`3<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, TypeSyntax> WithElementsAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithCloseParenTokenAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> Elements { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleTypeSyntaxWrapper();
    private TupleTypeSyntaxWrapper(TypeSyntax node);
    public TupleTypeSyntaxWrapper AddElements(TupleElementSyntaxWrapper[] items);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> get_Elements();
    public SyntaxToken get_CloseParenToken();
    public static TupleTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(TupleTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleTypeSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleTypeSyntaxWrapper WithElements(SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements);
    public TupleTypeSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.TypeDeclarationSyntaxExtensions : object {
    private static Func`2<TypeDeclarationSyntax, ParameterListSyntax> RecordDeclarationParameterListAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<TypeDeclarationSyntax, ParameterListSyntax> ParameterListAccessor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<TypeDeclarationSyntax, ParameterListSyntax, TypeDeclarationSyntax> WithParameterListAccessor;
    private static TypeDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ParameterListSyntax ParameterList(TypeDeclarationSyntax syntax);
    [ExtensionAttribute]
public static TypeDeclarationSyntax WithParameterList(TypeDeclarationSyntax syntax, ParameterListSyntax parameterList);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.TypeInfoExtensions : object {
    private static Func`2<TypeInfo, NullabilityInfo> ConvertedNullabilityAccessor;
    private static Func`2<TypeInfo, NullabilityInfo> NullabilityAccessor;
    private static TypeInfoExtensions();
    [ExtensionAttribute]
public static NullabilityInfo ConvertedNullability(TypeInfo typeInfo);
    [ExtensionAttribute]
public static NullabilityInfo Nullability(TypeInfo typeInfo);
    private static Func`2<TypeInfo, NullabilityInfo> CreateNullabilityAccessor(string propertyName);
}
public static class StyleCop.Analyzers.Lightup.TypeKindEx : object {
    public static TypeKind FunctionPointer;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.TypePatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    private static TypePatternSyntaxWrapper();
    private TypePatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public static TypePatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static TypePatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static TypePatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TypePatternSyntaxWrapper WithType(TypeSyntax type);
}
public enum StyleCop.Analyzers.Lightup.UnaryOperatorKind : Enum {
    public int value__;
    public static UnaryOperatorKind None;
    public static UnaryOperatorKind BitwiseNegation;
    public static UnaryOperatorKind Not;
    public static UnaryOperatorKind Plus;
    public static UnaryOperatorKind Minus;
    public static UnaryOperatorKind True;
    public static UnaryOperatorKind False;
    public static UnaryOperatorKind Hat;
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.UnaryPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OperatorToken { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static UnaryPatternSyntaxWrapper();
    private UnaryPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OperatorToken();
    public PatternSyntaxWrapper get_Pattern();
    public static UnaryPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static UnaryPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static UnaryPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public UnaryPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public UnaryPatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[ExtensionAttribute]
public static class StyleCop.Analyzers.Lightup.UsingStatementSyntaxExtensions : object {
    private static Func`2<UsingStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`3<UsingStatementSyntax, SyntaxToken, UsingStatementSyntax> WithAwaitKeywordAccessor;
    private static UsingStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(UsingStatementSyntax syntax);
    [ExtensionAttribute]
public static UsingStatementSyntax WithAwaitKeyword(UsingStatementSyntax syntax, SyntaxToken awaitKeyword);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.VariableDesignationSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static VariableDesignationSyntaxWrapper();
    private VariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static VariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(VariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.VarPatternSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> VarKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithVarKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken VarKeyword { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static VarPatternSyntaxWrapper();
    private VarPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_VarKeyword();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static VarPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static VarPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static VarPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public VarPatternSyntaxWrapper WithVarKeyword(SyntaxToken varKeyword);
    public VarPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.WhenClauseSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> WhenKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ConditionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithWhenKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithConditionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken WhenKeyword { get; }
    public ExpressionSyntax Condition { get; }
    private static WhenClauseSyntaxWrapper();
    private WhenClauseSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_WhenKeyword();
    public ExpressionSyntax get_Condition();
    public static WhenClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(WhenClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public WhenClauseSyntaxWrapper WithWhenKeyword(SyntaxToken whenKeyword);
    public WhenClauseSyntaxWrapper WithCondition(ExpressionSyntax condition);
}
[IsReadOnlyAttribute]
public class StyleCop.Analyzers.Lightup.WithExpressionSyntaxWrapper : ValueType {
    public static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> WithKeywordAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithWithKeywordAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken WithKeyword { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static WithExpressionSyntaxWrapper();
    private WithExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_WithKeyword();
    public InitializerExpressionSyntax get_Initializer();
    public static WithExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(WithExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public WithExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public WithExpressionSyntaxWrapper WithWithKeyword(SyntaxToken withKeyword);
    public WithExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
public static class StyleCop.Analyzers.Lightup.WrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static WrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
