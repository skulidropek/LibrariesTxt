[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
public static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol);
    [NullableContextAttribute("1")]
private static bool VerifyGetAwaiter(IMethodSymbol getAwaiter);
}
[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static bool IsChildNode(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static TNode GetAncestor(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
public class SonarAnalyzer.AnalysisContext.SonarAnalysisContext : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private HashSet`1<string> rulesDisabledForRazor;
    private AnalysisContext analysisContext;
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<DiagnosticDescriptor>, SyntaxTree, bool> <ShouldExecuteRegisteredAction>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`3<SyntaxTree, Diagnostic, bool> <ShouldDiagnosticBeReported>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<IReportingContext> <ReportDiagnostic>k__BackingField;
    internal ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public static Func`3<IEnumerable`1<DiagnosticDescriptor>, SyntaxTree, bool> ShouldExecuteRegisteredAction { get; public set; }
    public static Func`3<SyntaxTree, Diagnostic, bool> ShouldDiagnosticBeReported { get; public set; }
    public static Action`1<IReportingContext> ReportDiagnostic { get; public set; }
    internal SonarAnalysisContext(AnalysisContext analysisContext, ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics);
    private protected SonarAnalysisContext(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public static Func`3<IEnumerable`1<DiagnosticDescriptor>, SyntaxTree, bool> get_ShouldExecuteRegisteredAction();
    [CompilerGeneratedAttribute]
public static void set_ShouldExecuteRegisteredAction(Func`3<IEnumerable`1<DiagnosticDescriptor>, SyntaxTree, bool> value);
    [CompilerGeneratedAttribute]
public static Func`3<SyntaxTree, Diagnostic, bool> get_ShouldDiagnosticBeReported();
    [CompilerGeneratedAttribute]
public static void set_ShouldDiagnosticBeReported(Func`3<SyntaxTree, Diagnostic, bool> value);
    [CompilerGeneratedAttribute]
public static Action`1<IReportingContext> get_ReportDiagnostic();
    [CompilerGeneratedAttribute]
public static void set_ReportDiagnostic(Action`1<IReportingContext> value);
    public bool TryGetValue(SourceText text, SourceTextValueProvider`1<TValue> valueProvider, TValue& value);
    internal static bool LegacyIsRegisteredActionEnabled(IEnumerable`1<DiagnosticDescriptor> diagnostics, SyntaxTree tree);
    internal static bool LegacyIsRegisteredActionEnabled(DiagnosticDescriptor diagnostic, SyntaxTree tree);
    public void RegisterCodeBlockStartAction(GeneratedCodeRecognizer generatedCodeRecognizer, Action`1<SonarCodeBlockStartAnalysisContext`1<TSyntaxKind>> action);
    public void RegisterCompilationAction(Action`1<SonarCompilationReportingContext> action);
    public virtual void RegisterCompilationStartAction(Action`1<SonarCompilationStartAnalysisContext> action);
    public void RegisterSymbolAction(Action`1<SonarSymbolReportingContext> action, SymbolKind[] symbolKinds);
    public void RegisterNodeAction(GeneratedCodeRecognizer generatedCodeRecognizer, Action`1<SonarSyntaxNodeReportingContext> action, TSyntaxKind[] syntaxKinds);
    public void RegisterSemanticModelAction(GeneratedCodeRecognizer generatedCodeRecognizer, Action`1<SonarSemanticModelReportingContext> action);
    public void RegisterTreeAction(GeneratedCodeRecognizer generatedCodeRecognizer, Action`1<SonarSyntaxTreeReportingContext> action);
    public void RegisterNodeActionInAllFiles(Action`1<SonarSyntaxNodeReportingContext> action, TSyntaxKind[] syntaxKinds);
    internal bool ShouldAnalyzeRazorFile(SyntaxTree sourceTree);
    private void Execute(TSonarContext context, Action`1<TSonarContext> action, SyntaxTree sourceTree, GeneratedCodeRecognizer generatedCodeRecognizer);
    [CompilerGeneratedAttribute]
private bool <ShouldAnalyzeRazorFile>b__30_0(DiagnosticDescriptor x);
}
public class SonarAnalyzer.AnalysisContext.SonarAnalysisContextBase : object {
    protected static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<string, bool>> FileInclusionCache;
    protected static ConditionalWeakTable`2<Compilation, ImmutableHashSet`1<string>> UnchangedFilesCache;
    protected static SourceTextValueProvider`1<ProjectConfigReader> ProjectConfigProvider;
    protected static SourceTextValueProvider`1<SonarLintXmlReader> SonarLintXmlProvider;
    private static SonarAnalysisContextBase();
}
public abstract class SonarAnalyzer.AnalysisContext.SonarAnalysisContextBase`1 : SonarAnalysisContextBase {
    private static string RazorGeneratedFileSuffix;
    [CompilerGeneratedAttribute]
private SonarAnalysisContext <AnalysisContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public SonarAnalysisContext AnalysisContext { get; }
    public TContext Context { get; }
    protected SonarAnalysisContextBase`1(SonarAnalysisContext analysisContext, TContext context);
    public abstract virtual Compilation get_Compilation();
    public abstract virtual AnalyzerOptions get_Options();
    public abstract virtual CancellationToken get_Cancel();
    [CompilerGeneratedAttribute]
public SonarAnalysisContext get_AnalysisContext();
    [CompilerGeneratedAttribute]
public TContext get_Context();
    public bool ShouldAnalyzeTree(SyntaxTree tree, GeneratedCodeRecognizer generatedCodeRecognizer);
    public ProjectConfigReader ProjectConfiguration();
    public SonarLintXmlReader SonarLintXml();
    public bool IsRazorAnalysisEnabled();
    public bool IsTestProject();
    public bool IsUnchanged(SyntaxTree tree);
    public bool HasMatchingScope(ImmutableArray`1<DiagnosticDescriptor> descriptors);
    public bool HasMatchingScope(DiagnosticDescriptor descriptor);
    private bool IsExcluded(SonarLintXmlReader sonarLintXml, string filePath);
    private ImmutableHashSet`1<string> CreateUnchangedFilesHashSet();
    private static string MapFilePath(SyntaxTree tree);
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <IsUnchanged>b__19_0(Compilation _);
    [CompilerGeneratedAttribute]
internal static bool <HasMatchingScope>g__ContainsTag|21_0(string tag, <>c__DisplayClass21_0& );
}
public class SonarAnalyzer.AnalysisContext.SonarCodeBlockReportingContext : SonarTreeReportingContextBase`1<CodeBlockAnalysisContext> {
    public SyntaxTree Tree { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    internal SonarCodeBlockReportingContext(SonarAnalysisContext analysisContext, CodeBlockAnalysisContext context);
    public virtual SyntaxTree get_Tree();
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
}
public class SonarAnalyzer.AnalysisContext.SonarCodeBlockStartAnalysisContext`1 : SonarAnalysisContextBase`1<CodeBlockStartAnalysisContext`1<TSyntaxKind>> {
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    internal SonarCodeBlockStartAnalysisContext`1(SonarAnalysisContext analysisContext, CodeBlockStartAnalysisContext`1<TSyntaxKind> context);
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    public void RegisterNodeAction(Action`1<SonarSyntaxNodeReportingContext> action, TSyntaxKind[] symbolKinds);
    public void RegisterCodeBlockEndAction(Action`1<SonarCodeBlockReportingContext> action);
}
[IsReadOnlyAttribute]
public class SonarAnalyzer.AnalysisContext.SonarCodeFixContext : ValueType {
    private CodeFixContext context;
    public CancellationToken CancellationToken { get; }
    public Document Document { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public TextSpan Span { get; }
    public SonarCodeFixContext(CodeFixContext context);
    public CancellationToken get_CancellationToken();
    public Document get_Document();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public TextSpan get_Span();
    public void RegisterCodeFix(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, ImmutableArray`1<Diagnostic> diagnostics);
    public void RegisterCodeFix(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedDocument, ImmutableArray`1<Diagnostic> diagnostics);
}
public class SonarAnalyzer.AnalysisContext.SonarCompilationReportingContext : SonarCompilationReportingContextBase`1<CompilationAnalysisContext> {
    private static TimeSpan FileNameTimeout;
    private static Regex WebConfigRegex;
    private static Regex AppSettingsRegex;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    internal SonarCompilationReportingContext(SonarAnalysisContext analysisContext, CompilationAnalysisContext context);
    private static SonarCompilationReportingContext();
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public IEnumerable`1<string> WebConfigFiles();
    public IEnumerable`1<string> AppSettingsFiles();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
internal static bool <WebConfigFiles>g__ShouldProcess|10_0(string path);
    [CompilerGeneratedAttribute]
internal static bool <AppSettingsFiles>g__ShouldProcess|11_0(string path);
}
public abstract class SonarAnalyzer.AnalysisContext.SonarCompilationReportingContextBase`1 : SonarReportingContextBase`1<TContext> {
    protected SonarCompilationReportingContextBase`1(SonarAnalysisContext analysisContext, TContext context);
    [ObsoleteAttribute("Use another overload of ReportIssue, without calling Diagnostic.Create")]
public void ReportIssue(GeneratedCodeRecognizer generatedCodeRecognizer, Diagnostic diagnostic);
    public void ReportIssue(GeneratedCodeRecognizer generatedCodeRecognizer, DiagnosticDescriptor rule, SyntaxNode locationSyntax, String[] messageArgs);
    public void ReportIssue(GeneratedCodeRecognizer generatedCodeRecognizer, DiagnosticDescriptor rule, SyntaxToken locationToken, String[] messageArgs);
    public void ReportIssue(GeneratedCodeRecognizer generatedCodeRecognizer, DiagnosticDescriptor rule, Location location, String[] messageArgs);
    public void ReportIssue(GeneratedCodeRecognizer generatedCodeRecognizer, DiagnosticDescriptor rule, Location primaryLocation, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    [CompilerGeneratedAttribute]
private bool <ReportIssue>b__5_0(SecondaryLocation x);
}
public class SonarAnalyzer.AnalysisContext.SonarCompilationStartAnalysisContext : SonarAnalysisContextBase`1<CompilationStartAnalysisContext> {
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    internal SonarCompilationStartAnalysisContext(SonarAnalysisContext analysisContext, CompilationStartAnalysisContext context);
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public void RegisterSymbolAction(Action`1<SonarSymbolReportingContext> action, SymbolKind[] symbolKinds);
    public void RegisterSymbolStartAction(Action`1<SonarSymbolStartAnalysisContext> action, SymbolKind symbolKind);
    public void RegisterCompilationEndAction(Action`1<SonarCompilationReportingContext> action);
    public void RegisterSemanticModelAction(Action`1<SonarSemanticModelReportingContext> action);
    public void RegisterNodeAction(GeneratedCodeRecognizer generatedCodeRecognizer, Action`1<SonarSyntaxNodeReportingContext> action, TSyntaxKind[] syntaxKinds);
    private bool GetOrAddCanProceedWithAnalysis(GeneratedCodeRecognizer codeRecognizer, ConcurrentDictionary`2<SyntaxTree, bool> cache, SyntaxTree tree);
}
public class SonarAnalyzer.AnalysisContext.SonarParametrizedAnalysisContext : SonarAnalysisContext {
    private List`1<Action`1<SonarCompilationStartAnalysisContext>> postponedActions;
    internal SonarParametrizedAnalysisContext(SonarAnalysisContext context);
    public virtual void RegisterCompilationStartAction(Action`1<SonarCompilationStartAnalysisContext> action);
    public void ExecutePostponedActions(SonarCompilationStartAnalysisContext context);
}
public abstract class SonarAnalyzer.AnalysisContext.SonarReportingContextBase`1 : SonarAnalysisContextBase`1<TContext> {
    protected SonarReportingContextBase`1(SonarAnalysisContext analysisContext, TContext context);
    private protected abstract virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
    protected void ReportIssueCore(Diagnostic diagnostic);
    private static Diagnostic EnsureDiagnosticLocation(Diagnostic diagnostic);
}
public class SonarAnalyzer.AnalysisContext.SonarSemanticModelReportingContext : SonarTreeReportingContextBase`1<SemanticModelAnalysisContext> {
    public SyntaxTree Tree { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public SemanticModel SemanticModel { get; }
    internal SonarSemanticModelReportingContext(SonarAnalysisContext analysisContext, SemanticModelAnalysisContext context);
    public virtual SyntaxTree get_Tree();
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public SemanticModel get_SemanticModel();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
}
public class SonarAnalyzer.AnalysisContext.SonarSymbolReportingContext : SonarCompilationReportingContextBase`1<SymbolAnalysisContext> {
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public ISymbol Symbol { get; }
    internal SonarSymbolReportingContext(SonarAnalysisContext analysisContext, SymbolAnalysisContext context);
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public ISymbol get_Symbol();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
}
public class SonarAnalyzer.AnalysisContext.SonarSymbolStartAnalysisContext : SonarAnalysisContextBase`1<SymbolStartAnalysisContextWrapper> {
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public ISymbol Symbol { get; }
    internal SonarSymbolStartAnalysisContext(SonarAnalysisContext analysisContext, SymbolStartAnalysisContextWrapper context);
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public ISymbol get_Symbol();
    public void RegisterCodeBlockAction(Action`1<SonarCodeBlockReportingContext> action);
    public void RegisterCodeBlockStartAction(Action`1<SonarCodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public void RegisterSymbolEndAction(Action`1<SonarSymbolReportingContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SonarSyntaxNodeReportingContext> action, TLanguageKindEnum[] syntaxKinds);
}
public class SonarAnalyzer.AnalysisContext.SonarSyntaxNodeReportingContext : SonarTreeReportingContextBase`1<SyntaxNodeAnalysisContext> {
    public SyntaxTree Tree { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    public SyntaxNode Node { get; }
    public SemanticModel SemanticModel { get; }
    public ISymbol ContainingSymbol { get; }
    internal SonarSyntaxNodeReportingContext(SonarAnalysisContext analysisContext, SyntaxNodeAnalysisContext context);
    public virtual SyntaxTree get_Tree();
    public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    public SyntaxNode get_Node();
    public SemanticModel get_SemanticModel();
    public ISymbol get_ContainingSymbol();
    public bool IsRedundantPositionalRecordContext();
    public bool IsRedundantPrimaryConstructorBaseTypeContext();
    public bool IsAzureFunction();
    public IMethodSymbol AzureFunctionMethod();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
}
public class SonarAnalyzer.AnalysisContext.SonarSyntaxTreeReportingContext : SonarTreeReportingContextBase`1<SyntaxTreeAnalysisContext> {
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    public SyntaxTree Tree { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken Cancel { get; }
    internal SonarSyntaxTreeReportingContext(SonarAnalysisContext analysisContext, SyntaxTreeAnalysisContext context, Compilation compilation);
    public virtual SyntaxTree get_Tree();
    [CompilerGeneratedAttribute]
public virtual Compilation get_Compilation();
    public virtual AnalyzerOptions get_Options();
    public virtual CancellationToken get_Cancel();
    private protected virtual ReportingContext CreateReportingContext(Diagnostic diagnostic);
}
public abstract class SonarAnalyzer.AnalysisContext.SonarTreeReportingContextBase`1 : SonarReportingContextBase`1<TContext> {
    public SyntaxTree Tree { get; }
    protected SonarTreeReportingContextBase`1(SonarAnalysisContext analysisContext, TContext context);
    public abstract virtual SyntaxTree get_Tree();
    [ObsoleteAttribute("Use another overload of ReportIssue, without calling Diagnostic.Create")]
public void ReportIssue(Diagnostic diagnostic);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxNode locationSyntax, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxNode locationSyntax, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxNode primaryLocationSyntax, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxToken locationToken, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxToken locationToken, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, SyntaxToken primaryLocationToken, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, Location location, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, Location location, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    public void ReportIssue(DiagnosticDescriptor rule, Location primaryLocation, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    [CompilerGeneratedAttribute]
private bool <ReportIssue>b__12_0(SecondaryLocation x);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Analyzers.DiagnosticDescriptorFactory : object {
    public static string SonarWayTag;
    public static string UtilityTag;
    public static string MainSourceScopeTag;
    public static string TestSourceScopeTag;
    private static DiagnosticDescriptorFactory();
    public static DiagnosticDescriptor CreateUtility(string diagnosticId, string title);
    public static DiagnosticDescriptor Create(AnalyzerLanguage language, RuleDescriptor rule, string messageFormat, Nullable`1<bool> isEnabledByDefault, bool fadeOutCode);
    private static String[] BuildTags(AnalyzerLanguage language, RuleDescriptor rule, bool fadeOutCode);
    [ExtensionAttribute]
private static IEnumerable`1<string> ToTags(SourceScope sourceScope);
    private static String[] BuildUtilityTags();
    [CompilerGeneratedAttribute]
internal static void <BuildTags>g__Add|6_0(bool condition, string tag, <>c__DisplayClass6_0& );
}
public abstract class SonarAnalyzer.Analyzers.HotspotDiagnosticAnalyzer : SonarDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private IAnalyzerConfiguration <Configuration>k__BackingField;
    protected IAnalyzerConfiguration Configuration { get; }
    protected HotspotDiagnosticAnalyzer(IAnalyzerConfiguration configuration);
    [CompilerGeneratedAttribute]
protected IAnalyzerConfiguration get_Configuration();
    protected bool IsEnabled(AnalyzerOptions options);
    [CompilerGeneratedAttribute]
private bool <IsEnabled>b__4_0(DiagnosticDescriptor x);
}
public abstract class SonarAnalyzer.Analyzers.ParametrizedDiagnosticAnalyzer : SonarDiagnosticAnalyzer {
    protected abstract virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
}
public abstract class SonarAnalyzer.Analyzers.SonarDiagnosticAnalyzer : DiagnosticAnalyzer {
    public static string EnableConcurrentExecutionVariable;
    protected bool EnableConcurrentExecution { get; }
    private static SonarDiagnosticAnalyzer();
    protected abstract virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool get_EnableConcurrentExecution();
    public sealed virtual void Initialize(AnalysisContext context);
    protected static bool IsConcurrentExecutionEnabled();
}
public abstract class SonarAnalyzer.Analyzers.SonarDiagnosticAnalyzer`1 : SonarDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    protected string MessageFormat { get; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected DiagnosticDescriptor Rule { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected SonarDiagnosticAnalyzer`1(string diagnosticId);
    protected abstract virtual string get_MessageFormat();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_Rule();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
public abstract class SonarAnalyzer.Analyzers.TrackerHotspotDiagnosticAnalyzer`1 : HotspotDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected DiagnosticDescriptor Rule { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected TrackerHotspotDiagnosticAnalyzer`1(IAnalyzerConfiguration configuration, string diagnosticId, string messageFormat);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual void Initialize(TrackerInput input);
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_Rule();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
}
public class SonarAnalyzer.Common.AnalyzerAdditionalFile : AdditionalText {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    public AnalyzerAdditionalFile(string path);
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancel);
}
public class SonarAnalyzer.Common.AnalyzerConfiguration : object {
    [CompilerGeneratedAttribute]
private static IAnalyzerConfiguration <Hotspot>k__BackingField;
    [CompilerGeneratedAttribute]
private static IAnalyzerConfiguration <AlwaysEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static IAnalyzerConfiguration <AlwaysEnabledWithSonarCfg>k__BackingField;
    public static IAnalyzerConfiguration Hotspot { get; }
    public static IAnalyzerConfiguration AlwaysEnabled { get; }
    public static IAnalyzerConfiguration AlwaysEnabledWithSonarCfg { get; }
    private static AnalyzerConfiguration();
    [CompilerGeneratedAttribute]
public static IAnalyzerConfiguration get_Hotspot();
    [CompilerGeneratedAttribute]
public static IAnalyzerConfiguration get_AlwaysEnabled();
    [CompilerGeneratedAttribute]
public static IAnalyzerConfiguration get_AlwaysEnabledWithSonarCfg();
}
public class SonarAnalyzer.Common.AnalyzerLanguage : object {
    public static AnalyzerLanguage CSharp;
    public static AnalyzerLanguage VisualBasic;
    private string helpLinkFormat;
    [CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    public string LanguageName { get; }
    public string FileExtension { get; }
    private AnalyzerLanguage(string languageName, string fileExtension, string helpLinkFormat);
    private static AnalyzerLanguage();
    [CompilerGeneratedAttribute]
public string get_LanguageName();
    [CompilerGeneratedAttribute]
public string get_FileExtension();
    public virtual string ToString();
    public static AnalyzerLanguage FromName(string name);
    public static AnalyzerLanguage FromPath(string path);
    public string HelpLink(string id);
}
internal class SonarAnalyzer.Common.BidirectionalDictionary`2 : object {
    private IDictionary`2<TA, TB> aToB;
    private IDictionary`2<TB, TA> bToA;
    public ICollection`1<TA> AKeys { get; }
    public ICollection`1<TB> BKeys { get; }
    public ICollection`1<TA> get_AKeys();
    public ICollection`1<TB> get_BKeys();
    public void Add(TA a, TB b);
    public TB GetByA(TA a);
    public TA GetByB(TB b);
    public bool ContainsKeyByA(TA a);
    public bool ContainsKeyByB(TB b);
}
public class SonarAnalyzer.Common.CognitiveComplexity : object {
    [CompilerGeneratedAttribute]
private int <Complexity>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SecondaryLocation> <Locations>k__BackingField;
    public int Complexity { get; }
    public ImmutableArray`1<SecondaryLocation> Locations { get; }
    public CognitiveComplexity(int complexity, ImmutableArray`1<SecondaryLocation> locations);
    [CompilerGeneratedAttribute]
public int get_Complexity();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SecondaryLocation> get_Locations();
}
public class SonarAnalyzer.Common.CognitiveComplexityWalkerState`1 : object {
    [CompilerGeneratedAttribute]
private TMethodSyntax <CurrentMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SecondaryLocation> <IncrementLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SyntaxNode> <LogicalOperationsToIgnore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDirectRecursiveCall>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NestingLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Complexity>k__BackingField;
    public TMethodSyntax CurrentMethod { get; public set; }
    public IList`1<SecondaryLocation> IncrementLocations { get; }
    public IList`1<SyntaxNode> LogicalOperationsToIgnore { get; }
    public bool HasDirectRecursiveCall { get; public set; }
    public int NestingLevel { get; public set; }
    public int Complexity { get; public set; }
    [CompilerGeneratedAttribute]
public TMethodSyntax get_CurrentMethod();
    [CompilerGeneratedAttribute]
public void set_CurrentMethod(TMethodSyntax value);
    [CompilerGeneratedAttribute]
public IList`1<SecondaryLocation> get_IncrementLocations();
    [CompilerGeneratedAttribute]
public IList`1<SyntaxNode> get_LogicalOperationsToIgnore();
    [CompilerGeneratedAttribute]
public bool get_HasDirectRecursiveCall();
    [CompilerGeneratedAttribute]
public void set_HasDirectRecursiveCall(bool value);
    [CompilerGeneratedAttribute]
public int get_NestingLevel();
    [CompilerGeneratedAttribute]
public void set_NestingLevel(int value);
    [CompilerGeneratedAttribute]
public int get_Complexity();
    [CompilerGeneratedAttribute]
public void set_Complexity(int value);
    public void VisitWithNesting(TSyntaxNode node, Action`1<TSyntaxNode> visit);
    public void IncreaseComplexityByOne(SyntaxToken token);
    public void IncreaseComplexityByNestingPlusOne(SyntaxToken token);
    public void IncreaseComplexity(SyntaxToken token, int increment, string message);
}
public class SonarAnalyzer.Common.DisjointSets : object {
    private Dictionary`2<string, string> parents;
    public DisjointSets(IEnumerable`1<string> elements);
    public void Union(string from, string to);
    public string FindRoot(string element);
    public List`1<List`1<string>> GetAllSets();
    [CompilerGeneratedAttribute]
private string <GetAllSets>b__4_0(KeyValuePair`2<string, string> x);
}
public class SonarAnalyzer.Common.DocumentBasedFixAllProvider : FixAllProvider {
    private static Lazy`1<DocumentBasedFixAllProvider> Lazy;
    private static string TitleSolutionPattern;
    private static string TitleScopePattern;
    private static string TitleFixAll;
    public static DocumentBasedFixAllProvider Instance { get; }
    private static DocumentBasedFixAllProvider();
    public static DocumentBasedFixAllProvider get_Instance();
    private static string GetFixAllTitle(FixAllContext fixAllContext);
    public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("SonarAnalyzer.Common.DocumentBasedFixAllProvider/<GetFixedSolutionAsync>d__9")]
private static Task`1<Solution> GetFixedSolutionAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("SonarAnalyzer.Common.DocumentBasedFixAllProvider/<GetFixedProjectAsync>d__10")]
private static Task`1<Solution> GetFixedProjectAsync(FixAllContext fixAllContext, Project project);
    [AsyncStateMachineAttribute("SonarAnalyzer.Common.DocumentBasedFixAllProvider/<GetFixedDocumentAsync>d__11")]
private static Task`1<SyntaxNode> GetFixedDocumentAsync(FixAllContext fixAllContext, Document document);
    private static SyntaxNodeOrToken GetReportedElement(Diagnostic diagnostic, SyntaxNode root);
    private static SyntaxNode RemoveAnnotationIfExists(SyntaxNode root, SyntaxAnnotation annotation);
    private static SyntaxNode GetRootWithAnnotatedElements(SyntaxNode root, Dictionary`2<SyntaxNodeOrToken, Diagnostic> elementDiagnosticPairs, BidirectionalDictionary`2<Diagnostic, SyntaxAnnotation> diagnosticAnnotationPairs);
    private static void CreateAnnotationForDiagnostics(ImmutableArray`1<Diagnostic> diagnostics, string annotationKind, BidirectionalDictionary`2<Diagnostic, SyntaxAnnotation> diagnosticAnnotationPairs);
}
public class SonarAnalyzer.Common.FileComments : object {
    [CompilerGeneratedAttribute]
private ISet`1<int> <NoSonar>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<int> <NonBlank>k__BackingField;
    public ISet`1<int> NoSonar { get; }
    public ISet`1<int> NonBlank { get; }
    public FileComments(ISet`1<int> noSonar, ISet`1<int> nonBlank);
    [CompilerGeneratedAttribute]
public ISet`1<int> get_NoSonar();
    [CompilerGeneratedAttribute]
public ISet`1<int> get_NonBlank();
}
public interface SonarAnalyzer.Common.IAnalyzerConfiguration {
    public bool ForceSonarCfg { get; }
    public abstract virtual bool get_ForceSonarCfg();
    public abstract virtual bool IsEnabled(string ruleKey);
    public abstract virtual void Initialize(AnalyzerOptions options);
}
public interface SonarAnalyzer.Common.IRuleLoader {
    public abstract virtual ISet`1<string> GetEnabledRules(string content);
}
public interface SonarAnalyzer.Common.ISafeSyntaxWalker {
    public abstract virtual bool SafeVisit(SyntaxNode syntaxNode);
}
public abstract class SonarAnalyzer.Common.MetricsBase : object {
    protected static string InitializationErrorTextPattern;
    private SyntaxTree tree;
    private string filePath;
    internal static String[] LineTerminators;
    public ImmutableArray`1<int> ExecutableLines { get; }
    public ISet`1<int> CodeLines { get; }
    public int ClassCount { get; }
    public int StatementCount { get; }
    public int FunctionCount { get; }
    public int Complexity { get; }
    public int CognitiveComplexity { get; }
    private IEnumerable`1<SyntaxNode> ClassNodes { get; }
    private IEnumerable`1<SyntaxNode> FunctionNodes { get; }
    protected MetricsBase(SyntaxTree tree);
    private static MetricsBase();
    public abstract virtual ImmutableArray`1<int> get_ExecutableLines();
    public abstract virtual int ComputeCyclomaticComplexity(SyntaxNode node);
    protected abstract virtual bool IsEndOfFile(SyntaxToken token);
    protected abstract virtual int ComputeCognitiveComplexity(SyntaxNode node);
    protected abstract virtual bool IsNoneToken(SyntaxToken token);
    protected abstract virtual bool IsCommentTrivia(SyntaxTrivia trivia);
    protected abstract virtual bool IsClass(SyntaxNode node);
    protected abstract virtual bool IsStatement(SyntaxNode node);
    protected abstract virtual bool IsFunction(SyntaxNode node);
    public ISet`1<int> get_CodeLines();
    public FileComments GetComments(bool ignoreHeaderComments);
    public int get_ClassCount();
    public int get_StatementCount();
    public int get_FunctionCount();
    public int get_Complexity();
    public int get_CognitiveComplexity();
    protected bool IsInSameFile(FileLinePositionSpan span);
    private IEnumerable`1<SyntaxNode> get_ClassNodes();
    private IEnumerable`1<SyntaxNode> get_FunctionNodes();
    private Nullable`1<FileLinePositionSpan> GetMappedLineSpan(SyntaxToken token);
    private static void CategorizeLines(string line, int lineNumber, ISet`1<int> noSonar, ISet`1<int> nonBlank);
    private static bool HasValidCommentContent(string content);
}
public class SonarAnalyzer.Common.MultiValueDictionary`2 : Dictionary`2<TKey, ICollection`1<TValue>> {
    [CompilerGeneratedAttribute]
private Func`1<ICollection`1<TValue>> <UnderlyingCollectionFactory>k__BackingField;
    private Func`1<ICollection`1<TValue>> UnderlyingCollectionFactory { get; private set; }
    public static MultiValueDictionary`2<TKey, TValue> Create();
    [CompilerGeneratedAttribute]
private Func`1<ICollection`1<TValue>> get_UnderlyingCollectionFactory();
    [CompilerGeneratedAttribute]
private void set_UnderlyingCollectionFactory(Func`1<ICollection`1<TValue>> value);
    public void Add(TKey key, TValue value);
    public void AddWithKey(TKey key, TValue value);
    public void AddRangeWithKey(TKey key, IEnumerable`1<TValue> addedValues);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Common.MultiValueDictionaryExtensions : object {
    [ExtensionAttribute]
public static MultiValueDictionary`2<TSource, TElement> ToMultiValueDictionary(IEnumerable`1<TSource> source, Func`2<TSource, ICollection`1<TElement>> elementSelector);
    [ExtensionAttribute]
public static MultiValueDictionary`2<TKey, TElement> ToMultiValueDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, ICollection`1<TElement>> elementSelector);
}
public class SonarAnalyzer.Common.NodeAndModel`1 : object {
    [CompilerGeneratedAttribute]
private SemanticModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private TSyntax <Node>k__BackingField;
    public SemanticModel Model { get; }
    public TSyntax Node { get; }
    public NodeAndModel`1(SemanticModel model, TSyntax node);
    [CompilerGeneratedAttribute]
public SemanticModel get_Model();
    [CompilerGeneratedAttribute]
public TSyntax get_Node();
}
public class SonarAnalyzer.Common.NodeAndSymbol : NodeAndSymbol`2<SyntaxNode, ISymbol> {
    public NodeAndSymbol(SyntaxNode node, ISymbol symbol);
}
public class SonarAnalyzer.Common.NodeAndSymbol`2 : object {
    [CompilerGeneratedAttribute]
private TSyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private TSymbol <Symbol>k__BackingField;
    public TSyntaxNode Node { get; }
    public TSymbol Symbol { get; }
    public NodeAndSymbol`2(TSyntaxNode node, TSymbol symbol);
    [CompilerGeneratedAttribute]
public TSyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public TSymbol get_Symbol();
}
public class SonarAnalyzer.Common.NodeSymbolAndModel`2 : NodeAndModel`1<TSyntax> {
    [CompilerGeneratedAttribute]
private TSymbol <Symbol>k__BackingField;
    public TSymbol Symbol { get; }
    public NodeSymbolAndModel`2(SemanticModel model, TSyntax node, TSymbol symbol);
    [CompilerGeneratedAttribute]
public TSymbol get_Symbol();
}
public enum SonarAnalyzer.Common.PropertyType : Enum {
    public int value__;
    public static PropertyType String;
    public static PropertyType Text;
    public static PropertyType Boolean;
    public static PropertyType Integer;
    public static PropertyType Float;
    public static PropertyType RegularExpression;
}
public static class SonarAnalyzer.Common.RegexConstants : object {
    public static TimeSpan DefaultTimeout { get; }
    public static TimeSpan get_DefaultTimeout();
}
public class SonarAnalyzer.Common.RuleDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SonarWay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Type { get; public set; }
    public string DefaultSeverity { get; public set; }
    public string Status { get; public set; }
    public SourceScope Scope { get; public set; }
    public bool SonarWay { get; public set; }
    public string Description { get; public set; }
    public string Category { get; }
    private string ReadableType { get; }
    public bool IsHotspot { get; }
    public RuleDescriptor(string Id, string Title, string Type, string DefaultSeverity, string Status, SourceScope Scope, bool SonarWay, string Description);
    [CompilerGeneratedAttribute]
protected RuleDescriptor(RuleDescriptor original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultSeverity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DefaultSeverity(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Status(string value);
    [CompilerGeneratedAttribute]
public SourceScope get_Scope();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Scope(SourceScope value);
    [CompilerGeneratedAttribute]
public bool get_SonarWay();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SonarWay(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Description(string value);
    public string get_Category();
    private string get_ReadableType();
    public bool get_IsHotspot();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuleDescriptor left, RuleDescriptor right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuleDescriptor left, RuleDescriptor right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(RuleDescriptor other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual RuleDescriptor <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Title, String& Type, String& DefaultSeverity, String& Status, SourceScope& Scope, Boolean& SonarWay, String& Description);
}
public class SonarAnalyzer.Common.RuleLoader : object {
    public sealed virtual ISet`1<string> GetEnabledRules(string content);
}
[AttributeUsageAttribute("128")]
public class SonarAnalyzer.Common.RuleParameterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public string Key { get; }
    public string Description { get; }
    public PropertyType Type { get; }
    public string DefaultValue { get; }
    public RuleParameterAttribute(string key, PropertyType type, string description, string defaultValue);
    public RuleParameterAttribute(string key, PropertyType type, string description, int defaultValue);
    public RuleParameterAttribute(string key, PropertyType type, string description);
    public RuleParameterAttribute(string key, PropertyType type);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public PropertyType get_Type();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
}
public class SonarAnalyzer.Common.SecondaryLocation : object {
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Location Location { get; public set; }
    public string Message { get; public set; }
    public SecondaryLocation(Location Location, string Message);
    [CompilerGeneratedAttribute]
protected SecondaryLocation(SecondaryLocation original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Location(Location value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SecondaryLocation left, SecondaryLocation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SecondaryLocation left, SecondaryLocation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SecondaryLocation other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual SecondaryLocation <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Location& Location, String& Message);
}
public enum SonarAnalyzer.Common.SourceScope : Enum {
    public int value__;
    public static SourceScope Main;
    public static SourceScope Tests;
    public static SourceScope All;
}
public static class SonarAnalyzer.Common.TopLevelStatements : object {
    public static string MainMethodImplicitName;
    public static ImmutableHashSet`1<string> ProgramClassImplicitName;
    private static TopLevelStatements();
}
public class SonarAnalyzer.Common.UnexpectedLanguageException : Exception {
    public UnexpectedLanguageException(AnalyzerLanguage language);
    public UnexpectedLanguageException(string language);
}
public class SonarAnalyzer.Common.UnexpectedValueException : Exception {
    public UnexpectedValueException(string name, object value);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.AnalyzerOptionsExtensions : object {
    [ExtensionAttribute]
public static AdditionalText SonarLintXml(AnalyzerOptions options);
    [ExtensionAttribute]
public static AdditionalText SonarProjectConfig(AnalyzerOptions options);
    [ExtensionAttribute]
public static AdditionalText ProjectOutFolderPath(AnalyzerOptions options);
    [ExtensionAttribute]
private static AdditionalText AdditionalFile(AnalyzerOptions options, string fileName);
    [CompilerGeneratedAttribute]
internal static bool <AdditionalFile>g__IsDirectorySeparator|3_0(char c);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.AttributeDataExtensions : object {
    [ExtensionAttribute]
public static bool HasName(AttributeData attribute, string name);
    [ExtensionAttribute]
public static bool HasAnyName(AttributeData attribute, String[] names);
    [ExtensionAttribute]
public static string GetAttributeRouteTemplate(AttributeData attribute);
    [ExtensionAttribute]
public static bool TryGetAttributeValue(AttributeData attribute, string valueName, T& value);
    [ExtensionAttribute]
public static bool HasAttributeUsageInherited(AttributeData attribute);
    private static bool TryConvertConstant(TypedConstant constant, T& value);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.BinaryOperatorKindExtensions : object {
    [ExtensionAttribute]
public static bool IsAnyEquality(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsEquals(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsNotEquals(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsAnyRelational(BinaryOperatorKind kind);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.CompilationExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetTypeByMetadataName(Compilation compilation, KnownType knownType);
    [ExtensionAttribute]
public static IMethodSymbol SpecialTypeMethod(Compilation compilation, SpecialType type, string methodName);
    [ExtensionAttribute]
public static bool IsNetFrameworkTarget(Compilation compilation);
    [ExtensionAttribute]
public static bool ReferencesAny(Compilation compilation, KnownAssembly[] assemblies);
    [ExtensionAttribute]
public static bool ReferencesAll(Compilation compilation, KnownAssembly[] assemblies);
    [ExtensionAttribute]
public static bool References(Compilation compilation, KnownAssembly assembly);
    [ExtensionAttribute]
public static bool IsMemberAvailable(Compilation compilation, KnownType type, string memberName, Func`2<TMemberType, bool> memberCheck);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.DiagnosticDescriptorExtensions : object {
    [ExtensionAttribute]
public static bool IsEnabled(DiagnosticDescriptor descriptor, SonarSyntaxNodeReportingContext context);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsExtensionOn(IMethodSymbol methodSymbol, KnownType type);
    [ExtensionAttribute]
public static bool IsDestructor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsAnyAttributeInOverridingChain(IMethodSymbol method);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.INamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsTopLevelProgram(INamedTypeSymbol symbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Extensions.INamedTypeSymbolExtensions/<GetAllNamedTypes>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllNamedTypes(INamedTypeSymbol type);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.INamespaceSymbolExtensions : object {
    [ExtensionAttribute]
public static bool Is(INamespaceSymbol symbol, string name);
    [IteratorStateMachineAttribute("SonarAnalyzer.Extensions.INamespaceSymbolExtensions/<GetAllNamedTypes>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllNamedTypes(INamespaceSymbol namespace);
    [ExtensionAttribute]
public static bool IsSameNamespace(INamespaceSymbol namespace1, INamespaceSymbol namespace2);
    [ExtensionAttribute]
public static bool IsSameOrAncestorOf(INamespaceSymbol thisNamespace, INamespaceSymbol namespaceToCheck);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.IParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsType(IParameterSymbol parameter, KnownType type);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsAnyAttributeInOverridingChain(IPropertySymbol property);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ISymbolExtensions : object {
    [ExtensionAttribute]
public static bool HasAnyAttribute(ISymbol symbol, ImmutableArray`1<KnownType> types);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, KnownType type);
    [ExtensionAttribute]
public static SyntaxNode GetFirstSyntaxRef(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAutoProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTopLevelMain(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsGlobalNamespace(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsInSameAssembly(ISymbol symbol, ISymbol anotherSymbol);
    [ExtensionAttribute]
public static bool HasNotNullAttribute(ISymbol parameter);
    private static bool IsNotNullAttribute(AttributeData attribute);
    [ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
public static ImmutableArray`1<ISymbol> ExplicitOrImplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasContainingType(ISymbol method, KnownType containingType, bool checkDerivedTypes);
    [ExtensionAttribute]
public static bool IsInType(ISymbol symbol, KnownType type);
    [ExtensionAttribute]
public static bool IsInType(ISymbol symbol, ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsInType(ISymbol symbol, ImmutableArray`1<KnownType> types);
    [ExtensionAttribute]
public static T GetInterfaceMember(T symbol);
    [ExtensionAttribute]
public static T GetOverriddenMember(T symbol);
    [ExtensionAttribute]
public static bool IsChangeable(ISymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static Accessibility GetEffectiveAccessibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPubliclyAccessible(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, KnownType attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, ImmutableArray`1<KnownType> attributeTypes);
    [IteratorStateMachineAttribute("SonarAnalyzer.Extensions.ISymbolExtensions/<GetAttributesWithInherited>d__23")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributesWithInherited(ISymbol symbol);
    [ExtensionAttribute]
public static bool AnyAttributeDerivesFrom(ISymbol symbol, KnownType attributeType);
    [ExtensionAttribute]
public static bool AnyAttributeDerivesFromAny(ISymbol symbol, ImmutableArray`1<KnownType> attributeTypes);
    [ExtensionAttribute]
public static bool AnyAttributeDerivesFromOrImplementsAny(ISymbol symbol, ImmutableArray`1<KnownType> attributeTypesOrInterfaces);
    [ExtensionAttribute]
public static string GetClassification(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsSerializableMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnyAttributeInOverridingChain(TSymbol symbol, Func`2<TSymbol, TSymbol> overriddenMember);
    private static bool CanBeInterfaceMember(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static ISymbol <GetAttributesWithInherited>g__BaseSymbol|23_0(ISymbol symbol);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool HasAnyConstraint(ITypeParameterSymbol typeParameter);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.ITypeSymbolExtensions : object {
    private static PropertyInfo ITypeSymbolIsRecord;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static bool IsInterface(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsClass(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsStruct(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsClassOrStruct(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsNullableValueType(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol self);
    [ExtensionAttribute]
public static bool IsEnum(ITypeSymbol self);
    [ExtensionAttribute]
public static bool CanBeNull(ITypeSymbol self);
    [ExtensionAttribute]
public static bool Is(ITypeSymbol self, TypeKind typeKind);
    [ExtensionAttribute]
public static bool Is(ITypeSymbol typeSymbol, KnownType type);
    [ExtensionAttribute]
public static bool IsAny(ITypeSymbol typeSymbol, KnownType[] types);
    [ExtensionAttribute]
public static bool IsAny(ITypeSymbol typeSymbol, ImmutableArray`1<KnownType> types);
    [ExtensionAttribute]
public static bool IsNullableOfAny(ITypeSymbol type, ImmutableArray`1<KnownType> argumentTypes);
    [ExtensionAttribute]
public static bool IsNullableOf(ITypeSymbol type, KnownType typeArgument);
    [ExtensionAttribute]
public static bool IsNullableBoolean(ITypeSymbol type);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol typeSymbol, KnownType type);
    [ExtensionAttribute]
private static bool Implements(ITypeSymbol typeSymbol, ISymbol type);
    [ExtensionAttribute]
public static bool ImplementsAny(ITypeSymbol typeSymbol, ImmutableArray`1<KnownType> types);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol typeSymbol, KnownType type);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol typeSymbol, ITypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFromAny(ITypeSymbol typeSymbol, ImmutableArray`1<KnownType> baseTypes);
    [ExtensionAttribute]
public static bool DerivesOrImplements(ITypeSymbol type, KnownType baseType);
    [ExtensionAttribute]
public static bool DerivesOrImplements(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool DerivesOrImplementsAny(ITypeSymbol type, ImmutableArray`1<KnownType> baseTypes);
    [ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [IteratorStateMachineAttribute("SonarAnalyzer.Extensions.ITypeSymbolExtensions/<GetSelfAndBaseTypes>d__26")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetSelfAndBaseTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsRecord(ITypeSymbol typeSymbol);
    private static ITypeSymbol NullableTypeArgument(ITypeSymbol type);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.KnownAssemblyExtensions : object {
    [ExtensionAttribute]
internal static Func`2<AssemblyIdentity, bool> And(Func`2<AssemblyIdentity, bool> this, Func`2<AssemblyIdentity, bool> predicate);
    [ExtensionAttribute]
internal static Func`2<AssemblyIdentity, bool> Or(Func`2<AssemblyIdentity, bool> this, Func`2<AssemblyIdentity, bool> predicate);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.LocationExtensions : object {
    [ExtensionAttribute]
public static FileLinePositionSpan GetMappedLineSpanIfAvailable(Location location);
    [ExtensionAttribute]
public static Location EnsureMappedLocation(Location location);
    [ExtensionAttribute]
public static int StartLine(Location location);
    [ExtensionAttribute]
public static int EndLine(Location location);
    [ExtensionAttribute]
public static bool IsValid(Location location, Compilation compilation);
    [ExtensionAttribute]
public static SecondaryLocation ToSecondary(Location location, string message);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.RegexExtensions : object {
    private static MatchCollection EmptyMatchCollection;
    private static RegexExtensions();
    [ExtensionAttribute]
public static Match SafeMatch(Regex regex, string input);
    [ExtensionAttribute]
public static bool SafeIsMatch(Regex regex, string input);
    [ExtensionAttribute]
public static bool SafeIsMatch(Regex regex, string input, bool timeoutFallback);
    [ExtensionAttribute]
public static MatchCollection SafeMatches(Regex regex, string input);
}
public static class SonarAnalyzer.Extensions.SafeRegex : object {
    public static bool IsMatch(string input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static bool TryPop(Stack`1<T> stack, T& result);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, IEnumerable`1<T> items);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SymbolInfoExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> AllSymbols(SymbolInfo symbolInfo);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static bool IsKnownType(SyntaxNode syntaxNode, KnownType knownType, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsDeclarationKnownType(SyntaxNode syntaxNode, KnownType knownType, SemanticModel semanticModel);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static int Line(SyntaxToken token);
    [ExtensionAttribute]
public static SecondaryLocation ToSecondaryLocation(SyntaxToken token, string message);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Extensions.SyntaxTreeExtensions : object {
    private static ConditionalWeakTable`2<SyntaxTree, object> GeneratedCodeCache;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
public static bool IsGenerated(SyntaxTree tree, GeneratedCodeRecognizer generatedCodeRecognizer);
    private static bool IsGeneratedGetOrAdd(SyntaxTree tree, GeneratedCodeRecognizer generatedCodeRecognizer);
    [ExtensionAttribute]
public static bool IsConsideredGenerated(SyntaxTree tree, GeneratedCodeRecognizer generatedCodeRecognizer, bool isRazorAnalysisEnabled);
    [ExtensionAttribute]
public static string GetOriginalFilePath(SyntaxTree tree);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.AccessibilityExtensions : object {
    [ExtensionAttribute]
public static bool IsAccessibleOutsideTheType(Accessibility accessibility);
}
[FlagsAttribute]
public enum SonarAnalyzer.Helpers.AccessorAccess : Enum {
    public int value__;
    public static AccessorAccess None;
    public static AccessorAccess Get;
    public static AccessorAccess Set;
    public static AccessorAccess Both;
}
internal class SonarAnalyzer.Helpers.AnalysisConfig : object {
    [CompilerGeneratedAttribute]
private ConfigSetting[] <AdditionalConfig>k__BackingField;
    public ConfigSetting[] AdditionalConfig { get; }
    public AnalysisConfig(XDocument document);
    [CompilerGeneratedAttribute]
public ConfigSetting[] get_AdditionalConfig();
}
public class SonarAnalyzer.Helpers.AnalysisConfigReader : object {
    private AnalysisConfig analysisConfig;
    public AnalysisConfigReader(string analysisConfigPath);
    public String[] UnchangedFiles();
    private string ConfigValue(string id);
}
public class SonarAnalyzer.Helpers.ArgumentContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    public IParameterSymbol Parameter { get; internal set; }
    public ArgumentContext(SonarSyntaxNodeReportingContext context);
    public ArgumentContext(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public IParameterSymbol get_Parameter();
    [CompilerGeneratedAttribute]
internal void set_Parameter(IParameterSymbol value);
}
public class SonarAnalyzer.Helpers.ArgumentDescriptor : object {
    [CompilerGeneratedAttribute]
private MemberKind <MemberKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> <ArgumentListConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RefKind> <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IParameterSymbol, bool> <ParameterConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, StringComparison, bool> <InvokedMemberNameConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> <InvokedMemberNodeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IMethodSymbol, bool> <InvokedMemberConstraint>k__BackingField;
    public MemberKind MemberKind { get; }
    public Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> ArgumentListConstraint { get; }
    public Nullable`1<RefKind> RefKind { get; }
    public Func`2<IParameterSymbol, bool> ParameterConstraint { get; }
    public Func`3<string, StringComparison, bool> InvokedMemberNameConstraint { get; }
    public Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> InvokedMemberNodeConstraint { get; }
    public Func`2<IMethodSymbol, bool> InvokedMemberConstraint { get; }
    private ArgumentDescriptor(MemberKind memberKind, Func`2<IMethodSymbol, bool> invokedMemberConstraint, Func`3<string, StringComparison, bool> invokedMemberNameConstraint, Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> invokedMemberNodeConstraint, Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> argumentListConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Nullable`1<RefKind> refKind);
    [CompilerGeneratedAttribute]
public MemberKind get_MemberKind();
    [CompilerGeneratedAttribute]
public Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> get_ArgumentListConstraint();
    [CompilerGeneratedAttribute]
public Nullable`1<RefKind> get_RefKind();
    [CompilerGeneratedAttribute]
public Func`2<IParameterSymbol, bool> get_ParameterConstraint();
    [CompilerGeneratedAttribute]
public Func`3<string, StringComparison, bool> get_InvokedMemberNameConstraint();
    [CompilerGeneratedAttribute]
public Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> get_InvokedMemberNodeConstraint();
    [CompilerGeneratedAttribute]
public Func`2<IMethodSymbol, bool> get_InvokedMemberConstraint();
    public static ArgumentDescriptor MethodInvocation(KnownType invokedType, string methodName, string parameterName, int argumentPosition);
    public static ArgumentDescriptor MethodInvocation(KnownType invokedType, string methodName, string parameterName, Func`2<int, bool> argumentPosition);
    public static ArgumentDescriptor MethodInvocation(KnownType invokedType, string methodName, string parameterName, Func`2<int, bool> argumentPosition, RefKind refKind);
    public static ArgumentDescriptor MethodInvocation(KnownType invokedType, Func`3<string, StringComparison, bool> invokedMemberNameConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<int, bool> argumentPosition, Nullable`1<RefKind> refKind);
    public static ArgumentDescriptor MethodInvocation(Func`2<IMethodSymbol, bool> invokedMemberConstraint, Func`3<string, StringComparison, bool> invokedMemberNameConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<int, bool> argumentPosition, Nullable`1<RefKind> refKind);
    public static ArgumentDescriptor MethodInvocation(Func`2<IMethodSymbol, bool> invokedMemberConstraint, Func`3<string, StringComparison, bool> invokedMemberNameConstraint, Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> invokedMemberNodeConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> argumentListConstraint, Nullable`1<RefKind> refKind);
    public static ArgumentDescriptor ConstructorInvocation(KnownType constructedType, string parameterName, int argumentPosition);
    public static ArgumentDescriptor ConstructorInvocation(Func`2<IMethodSymbol, bool> invokedMethodSymbol, Func`3<string, StringComparison, bool> invokedMemberNameConstraint, Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> invokedMemberNodeConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> argumentListConstraint, Nullable`1<RefKind> refKind);
    public static ArgumentDescriptor ElementAccess(KnownType invokedIndexerContainer, Func`2<IParameterSymbol, bool> parameterConstraint, int argumentPosition);
    public static ArgumentDescriptor ElementAccess(KnownType invokedIndexerContainer, string invokedIndexerExpression, Func`2<IParameterSymbol, bool> parameterConstraint, int argumentPosition);
    public static ArgumentDescriptor ElementAccess(KnownType invokedIndexerContainer, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<int, bool> argumentPositionConstraint);
    public static ArgumentDescriptor ElementAccess(KnownType invokedIndexerContainer, string invokedIndexerExpression, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<int, bool> argumentPositionConstraint);
    public static ArgumentDescriptor ElementAccess(Func`2<IMethodSymbol, bool> invokedIndexerPropertyMethod, Func`3<string, StringComparison, bool> invokedIndexerExpression, Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> invokedIndexerExpressionNodeConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> argumentListConstraint);
    public static ArgumentDescriptor AttributeArgument(string attributeName, string parameterName, int argumentPosition);
    public static ArgumentDescriptor AttributeArgument(Func`2<IMethodSymbol, bool> attributeConstructorConstraint, Func`3<string, StringComparison, bool> attributeNameConstraint, Func`4<SemanticModel, ILanguageFacade, SyntaxNode, bool> attributeNodeConstraint, Func`2<IParameterSymbol, bool> parameterConstraint, Func`3<IReadOnlyCollection`1<SyntaxNode>, Nullable`1<int>, bool> argumentListConstraint);
    public static ArgumentDescriptor AttributeProperty(string attributeName, string propertyName);
    private static bool AttributeClassNameConstraint(string expectedAttributeName, string nodeClassName, StringComparison c);
    private static ArgumentDescriptor MethodInvocation(KnownType invokedType, string methodName, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<int, bool> argumentPosition, Nullable`1<RefKind> refKind);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.AspNetMvcHelper : object {
    public static ImmutableArray`1<KnownType> RouteTemplateProviders;
    private static ImmutableArray`1<KnownType> ControllerTypes;
    private static ImmutableArray`1<KnownType> NonActionTypes;
    private static ImmutableArray`1<KnownType> NonControllerAttributeTypes;
    private static ImmutableArray`1<KnownType> ControllerAttributeTypes;
    private static AspNetMvcHelper();
    [ExtensionAttribute]
public static bool IsControllerActionMethod(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsControllerType(INamedTypeSymbol namedType);
    [ExtensionAttribute]
public static bool IsCoreApiController(INamedTypeSymbol namedType);
    [ExtensionAttribute]
public static bool ReferencesNetCoreControllers(Compilation compilation);
    [ExtensionAttribute]
public static bool ReferencesNetFrameworkControllers(Compilation compilation);
}
public abstract class SonarAnalyzer.Helpers.AssignmentFinder : object {
    protected abstract virtual SyntaxNode GetTopMostContainingMethod(SyntaxNode node);
    protected abstract virtual bool IsAssignmentToIdentifier(SyntaxNode node, string identifierName, bool anyAssignmentKind, SyntaxNode& rightExpression);
    protected abstract virtual bool IsIdentifierDeclaration(SyntaxNode node, string identifierName, SyntaxNode& initializer);
    protected abstract virtual bool IsLoop(SyntaxNode node);
    public SyntaxNode FindLinearPrecedingAssignmentExpression(string identifierName, SyntaxNode current, Func`1<SyntaxNode> defaultValue);
}
public class SonarAnalyzer.Helpers.BaseContext : object {
    [CompilerGeneratedAttribute]
private IList`1<SecondaryLocation> <SecondaryLocations>k__BackingField;
    public IList`1<SecondaryLocation> SecondaryLocations { get; }
    [CompilerGeneratedAttribute]
public IList`1<SecondaryLocation> get_SecondaryLocations();
    public void AddSecondaryLocation(Location location, string message, String[] formatArgs);
}
public class SonarAnalyzer.Helpers.BaseTypeContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxNode> <AllBaseTypeNodes>k__BackingField;
    public IEnumerable`1<SyntaxNode> AllBaseTypeNodes { get; }
    public BaseTypeContext(SonarSyntaxNodeReportingContext context, IEnumerable`1<SyntaxNode> allBaseTypeNodes);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxNode> get_AllBaseTypeNodes();
}
public abstract class SonarAnalyzer.Helpers.BuilderPatternCondition`2 : object {
    private bool constructorIsSafe;
    private BuilderPatternDescriptor`2[] descriptors;
    private AssignmentFinder assignmentFinder;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected BuilderPatternCondition`2(bool constructorIsSafe, BuilderPatternDescriptor`2[] descriptors, AssignmentFinder assignmentFinder);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual SyntaxNode GetExpression(TInvocationSyntax node);
    protected abstract virtual string GetIdentifierName(TInvocationSyntax node);
    protected abstract virtual bool IsMemberAccess(SyntaxNode node, SyntaxNode& memberAccessExpression);
    protected abstract virtual bool IsObjectCreation(SyntaxNode node);
    protected abstract virtual bool IsIdentifier(SyntaxNode node, String& identifierName);
    public bool IsInvalidBuilderInitialization(InvocationContext context);
}
public class SonarAnalyzer.Helpers.BuilderPatternDescriptor`2 : object {
    private Condition[] invocationConditions;
    private Func`2<TInvocationSyntax, bool> isValid;
    public BuilderPatternDescriptor`2(bool isValid, Condition[] invocationConditions);
    public BuilderPatternDescriptor`2(Func`2<TInvocationSyntax, bool> isValid, Condition[] invocationConditions);
    public bool IsMatch(InvocationContext context);
    public bool IsValid(TInvocationSyntax invocation);
}
internal static class SonarAnalyzer.Helpers.Common.EquivalenceChecker : object {
    public static bool AreEquivalent(SyntaxNode node1, SyntaxNode node2, Func`3<SyntaxNode, SyntaxNode, bool> nodeComparator);
    public static bool AreEquivalent(SyntaxList`1<SyntaxNode> nodeList1, SyntaxList`1<SyntaxNode> nodeList2, Func`3<SyntaxNode, SyntaxNode, bool> nodeComparator);
}
public enum SonarAnalyzer.Helpers.ComparisonKind : Enum {
    public int value__;
    public static ComparisonKind None;
    public static ComparisonKind Equals;
    public static ComparisonKind NotEquals;
    public static ComparisonKind LessThan;
    public static ComparisonKind LessThanOrEqual;
    public static ComparisonKind GreaterThan;
    public static ComparisonKind GreaterThanOrEqual;
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.ComparisonKindExtensions : object {
    [ExtensionAttribute]
public static ComparisonKind Mirror(ComparisonKind comparison);
}
internal class SonarAnalyzer.Helpers.ConfigSetting : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Value { get; public set; }
    public ConfigSetting(string Id, string Value);
    public ConfigSetting(XElement element);
    [CompilerGeneratedAttribute]
private ConfigSetting(ConfigSetting original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ConfigSetting left, ConfigSetting right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ConfigSetting left, ConfigSetting right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConfigSetting other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ConfigSetting <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Value);
}
public abstract class SonarAnalyzer.Helpers.ConstantValueFinder`2 : object {
    protected SemanticModel SemanticModel;
    private AssignmentFinder assignmentFinder;
    private int nullLiteralExpressionSyntaxKind;
    protected ConstantValueFinder`2(SemanticModel semanticModel, AssignmentFinder assignmentFinder, int nullLiteralExpressionSyntaxKind);
    protected abstract virtual string IdentifierName(TIdentifierNameSyntax node);
    protected abstract virtual SyntaxNode InitializerValue(TVariableDeclaratorSyntax node);
    protected abstract virtual TVariableDeclaratorSyntax VariableDeclarator(SyntaxNode node);
    protected abstract virtual bool IsPtrZero(SyntaxNode node);
    public object FindConstant(SyntaxNode node);
    private object FindConstant(SyntaxNode node, HashSet`1<SyntaxNode> visitedVariables);
    private object FindAssignedConstant(SyntaxNode node, SemanticModel nodeSemanticModel, HashSet`1<SyntaxNode> visitedVariables);
}
public static class SonarAnalyzer.Helpers.ConversionHelper : object {
    public static Nullable`1<int> TryConvertToInt(object o);
    public static bool TryConvertWith(object o, Func`2<object, T> converter, T& value);
}
public enum SonarAnalyzer.Helpers.CountComparisonResult : Enum {
    public int value__;
    public static CountComparisonResult None;
    public static CountComparisonResult SizeDepedendent;
    public static CountComparisonResult Empty;
    public static CountComparisonResult NotEmpty;
    public static CountComparisonResult AlwaysTrue;
    public static CountComparisonResult AlwaysFalse;
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.CountComparisonResultExtensions : object {
    [ExtensionAttribute]
public static bool IsEmptyOrNotEmpty(CountComparisonResult comparison);
    [ExtensionAttribute]
public static bool IsInvalid(CountComparisonResult comparison);
    [ExtensionAttribute]
public static CountComparisonResult Compare(ComparisonKind comparison, int count);
    private static CountComparisonResult Equals(int count);
    private static CountComparisonResult NotEquals(int count);
    private static CountComparisonResult GreaterThan(int count);
    private static CountComparisonResult GreaterThanOrEqual(int count);
    private static CountComparisonResult LessThan(int count);
    private static CountComparisonResult LessThanOrEqual(int count);
    private static CountComparisonResult Check(int count, int threshold, CountComparisonResult belowThreshold, CountComparisonResult onThreshold);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.DiagnosticReportHelper : object {
    [ExtensionAttribute]
public static int GetLineNumberToReport(SyntaxNode self);
    [ExtensionAttribute]
public static int GetLineNumberToReport(Diagnostic self);
    [ExtensionAttribute]
public static int GetLineNumberToReport(Location self);
    [ExtensionAttribute]
public static int GetLineNumberToReport(LinePosition self);
    [ExtensionAttribute]
public static int GetLineNumberToReport(FileLinePositionSpan self);
    [ExtensionAttribute]
public static string ToSentence(IEnumerable`1<string> words, bool quoteWords, LastJoiningWord lastJoiningWord);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
    [ExtensionAttribute]
public static bool DictionaryEquals(IDictionary`2<TKey, TValue> dict1, IDictionary`2<TKey, TValue> dict2);
}
public class SonarAnalyzer.Helpers.ElementAccessContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private Lazy`1<IPropertySymbol> <InvokedPropertySymbol>k__BackingField;
    public Lazy`1<IPropertySymbol> InvokedPropertySymbol { get; }
    public ElementAccessContext(SonarSyntaxNodeReportingContext context);
    [CompilerGeneratedAttribute]
public Lazy`1<IPropertySymbol> get_InvokedPropertySymbol();
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.EnumerableExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> enumerable, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static bool Equals(IEnumerable`1<T> first, IEnumerable`1<V> second, Func`3<T, V, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<Nullable`1<T>> enumerable);
    [IteratorStateMachineAttribute("SonarAnalyzer.Helpers.EnumerableExtensions/<Merge>d__4`3")]
[ExtensionAttribute]
public static IEnumerable`1<TResult> Merge(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> operation);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static string JoinStr(IEnumerable`1<T> enumerable, string separator, Func`2<T, string> selector);
    [ExtensionAttribute]
public static string JoinStr(IEnumerable`1<T> enumerable, string separator, Func`2<T, int> selector);
    [ExtensionAttribute]
public static string JoinStr(IEnumerable`1<string> enumerable, string separator);
    [ExtensionAttribute]
public static string JoinStr(IEnumerable`1<int> enumerable, string separator);
    [ExtensionAttribute]
public static string JoinNonEmpty(IEnumerable`1<string> enumerable, string separator);
    [ExtensionAttribute]
public static string JoinAnd(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static IEnumerable`1<SecondaryLocation> ToSecondary(IEnumerable`1<Location> locations, string message);
    [ExtensionAttribute]
public static IEnumerable`1<SecondaryLocation> ToSecondaryLocations(IEnumerable`1<SyntaxNode> nodes, string message);
    [ExtensionAttribute]
public static IEnumerable`1<SecondaryLocation> ToSecondaryLocations(IEnumerable`1<SyntaxToken> nodes, string message);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.EnumHelper : object {
    [ExtensionAttribute]
internal static bool HasFlagsAttribute(SyntaxNode node, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Helpers.ExpressionNumericConverterBase`2 : object {
    protected abstract virtual object TokenValue(TLiteralExpressionSyntax literalExpression);
    protected abstract virtual SyntaxNode Operand(TUnaryExpressionSyntax unaryExpression);
    protected abstract virtual bool IsSupportedOperator(TUnaryExpressionSyntax unaryExpression);
    protected abstract virtual bool IsMinusOperator(TUnaryExpressionSyntax unaryExpression);
    protected abstract virtual SyntaxNode RemoveParentheses(SyntaxNode expression);
    public sealed virtual bool TryGetConstantIntValue(SemanticModel semanticModel, SyntaxNode expression, Int32& value);
    public sealed virtual bool TryGetConstantIntValue(SyntaxNode expression, Int32& value);
    public sealed virtual bool TryGetConstantDoubleValue(SyntaxNode expression, Double& value);
    public bool TryGetConstantDecimalValue(SyntaxNode expression, Decimal& value);
    private bool TryGetConstantValue(SemanticModel semanticModel, SyntaxNode expression, Func`2<object, T> converter, Func`3<int, T, T> multiplierCalculator, T& value);
    private Nullable`1<int> GetMultiplier(SyntaxNode expression, SyntaxNode& internalExpression);
}
public interface SonarAnalyzer.Helpers.Facade.ISyntaxKindFacade`1 {
    public TSyntaxKind Attribute { get; }
    public TSyntaxKind[] CastExpressions { get; }
    public TSyntaxKind ClassDeclaration { get; }
    public TSyntaxKind[] ClassAndRecordDeclarations { get; }
    public TSyntaxKind[] ClassAndModuleDeclarations { get; }
    public TSyntaxKind[] CommentTrivia { get; }
    public TSyntaxKind[] ComparisonKinds { get; }
    public TSyntaxKind ConstructorDeclaration { get; }
    public TSyntaxKind[] DefaultExpressions { get; }
    public TSyntaxKind EndOfLineTrivia { get; }
    public TSyntaxKind EnumDeclaration { get; }
    public TSyntaxKind FieldDeclaration { get; }
    public TSyntaxKind IdentifierName { get; }
    public TSyntaxKind IdentifierToken { get; }
    public TSyntaxKind InvocationExpression { get; }
    public TSyntaxKind InterpolatedStringExpression { get; }
    public TSyntaxKind LeftShiftAssignmentStatement { get; }
    public TSyntaxKind LeftShiftExpression { get; }
    public TSyntaxKind LocalDeclaration { get; }
    public TSyntaxKind[] MethodDeclarations { get; }
    public TSyntaxKind[] ObjectCreationExpressions { get; }
    public TSyntaxKind Parameter { get; }
    public TSyntaxKind RefKeyword { get; }
    public TSyntaxKind RightShiftExpression { get; }
    public TSyntaxKind RightShiftAssignmentStatement { get; }
    public TSyntaxKind ParameterList { get; }
    public TSyntaxKind ReturnStatement { get; }
    public TSyntaxKind SimpleAssignment { get; }
    public TSyntaxKind SimpleCommentTrivia { get; }
    public TSyntaxKind SimpleMemberAccessExpression { get; }
    public TSyntaxKind[] StringLiteralExpressions { get; }
    public TSyntaxKind StructDeclaration { get; }
    public TSyntaxKind SubtractExpression { get; }
    public TSyntaxKind[] TypeDeclaration { get; }
    public TSyntaxKind VariableDeclarator { get; }
    public TSyntaxKind WhitespaceTrivia { get; }
    public abstract virtual TSyntaxKind get_Attribute();
    public abstract virtual TSyntaxKind[] get_CastExpressions();
    public abstract virtual TSyntaxKind get_ClassDeclaration();
    public abstract virtual TSyntaxKind[] get_ClassAndRecordDeclarations();
    public abstract virtual TSyntaxKind[] get_ClassAndModuleDeclarations();
    public abstract virtual TSyntaxKind[] get_CommentTrivia();
    public abstract virtual TSyntaxKind[] get_ComparisonKinds();
    public abstract virtual TSyntaxKind get_ConstructorDeclaration();
    public abstract virtual TSyntaxKind[] get_DefaultExpressions();
    public abstract virtual TSyntaxKind get_EndOfLineTrivia();
    public abstract virtual TSyntaxKind get_EnumDeclaration();
    public abstract virtual TSyntaxKind get_FieldDeclaration();
    public abstract virtual TSyntaxKind get_IdentifierName();
    public abstract virtual TSyntaxKind get_IdentifierToken();
    public abstract virtual TSyntaxKind get_InvocationExpression();
    public abstract virtual TSyntaxKind get_InterpolatedStringExpression();
    public abstract virtual TSyntaxKind get_LeftShiftAssignmentStatement();
    public abstract virtual TSyntaxKind get_LeftShiftExpression();
    public abstract virtual TSyntaxKind get_LocalDeclaration();
    public abstract virtual TSyntaxKind[] get_MethodDeclarations();
    public abstract virtual TSyntaxKind[] get_ObjectCreationExpressions();
    public abstract virtual TSyntaxKind get_Parameter();
    public abstract virtual TSyntaxKind get_RefKeyword();
    public abstract virtual TSyntaxKind get_RightShiftExpression();
    public abstract virtual TSyntaxKind get_RightShiftAssignmentStatement();
    public abstract virtual TSyntaxKind get_ParameterList();
    public abstract virtual TSyntaxKind get_ReturnStatement();
    public abstract virtual TSyntaxKind get_SimpleAssignment();
    public abstract virtual TSyntaxKind get_SimpleCommentTrivia();
    public abstract virtual TSyntaxKind get_SimpleMemberAccessExpression();
    public abstract virtual TSyntaxKind[] get_StringLiteralExpressions();
    public abstract virtual TSyntaxKind get_StructDeclaration();
    public abstract virtual TSyntaxKind get_SubtractExpression();
    public abstract virtual TSyntaxKind[] get_TypeDeclaration();
    public abstract virtual TSyntaxKind get_VariableDeclarator();
    public abstract virtual TSyntaxKind get_WhitespaceTrivia();
}
public interface SonarAnalyzer.Helpers.Facade.ITrackerFacade`1 {
    public ArgumentTracker`1<TSyntaxKind> Argument { get; }
    public BaseTypeTracker`1<TSyntaxKind> BaseType { get; }
    public ElementAccessTracker`1<TSyntaxKind> ElementAccess { get; }
    public FieldAccessTracker`1<TSyntaxKind> FieldAccess { get; }
    public InvocationTracker`1<TSyntaxKind> Invocation { get; }
    public MethodDeclarationTracker`1<TSyntaxKind> MethodDeclaration { get; }
    public ObjectCreationTracker`1<TSyntaxKind> ObjectCreation { get; }
    public PropertyAccessTracker`1<TSyntaxKind> PropertyAccess { get; }
    public abstract virtual ArgumentTracker`1<TSyntaxKind> get_Argument();
    public abstract virtual BaseTypeTracker`1<TSyntaxKind> get_BaseType();
    public abstract virtual ElementAccessTracker`1<TSyntaxKind> get_ElementAccess();
    public abstract virtual FieldAccessTracker`1<TSyntaxKind> get_FieldAccess();
    public abstract virtual InvocationTracker`1<TSyntaxKind> get_Invocation();
    public abstract virtual MethodDeclarationTracker`1<TSyntaxKind> get_MethodDeclaration();
    public abstract virtual ObjectCreationTracker`1<TSyntaxKind> get_ObjectCreation();
    public abstract virtual PropertyAccessTracker`1<TSyntaxKind> get_PropertyAccess();
}
public abstract class SonarAnalyzer.Helpers.Facade.SyntaxFacade`1 : object {
    public abstract virtual bool AreEquivalent(SyntaxNode firstNode, SyntaxNode secondNode);
    public abstract virtual IEnumerable`1<SyntaxNode> ArgumentExpressions(SyntaxNode node);
    public abstract virtual Nullable`1<int> ArgumentIndex(SyntaxNode argument);
    public abstract virtual IReadOnlyList`1<SyntaxNode> ArgumentList(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> ArgumentNameColon(SyntaxNode argument);
    public abstract virtual SyntaxNode AssignmentLeft(SyntaxNode assignment);
    public abstract virtual SyntaxNode AssignmentRight(SyntaxNode assignment);
    public abstract virtual ImmutableArray`1<SyntaxNode> AssignmentTargets(SyntaxNode assignment);
    public abstract virtual SyntaxNode BinaryExpressionLeft(SyntaxNode binary);
    public abstract virtual SyntaxNode BinaryExpressionRight(SyntaxNode binary);
    public abstract virtual SyntaxNode CastType(SyntaxNode cast);
    public abstract virtual SyntaxNode CastExpression(SyntaxNode cast);
    public abstract virtual ComparisonKind ComparisonKind(SyntaxNode node);
    public abstract virtual IEnumerable`1<SyntaxNode> EnumMembers(SyntaxNode enum);
    public abstract virtual ImmutableArray`1<SyntaxToken> FieldDeclarationIdentifiers(SyntaxNode node);
    public abstract virtual bool HasExactlyNArguments(SyntaxNode invocation, int count);
    public abstract virtual Nullable`1<SyntaxToken> InvocationIdentifier(SyntaxNode invocation);
    public abstract virtual bool IsAnyKind(SyntaxNode node, ISet`1<TSyntaxKind> syntaxKinds);
    public abstract virtual bool IsAnyKind(SyntaxNode node, TSyntaxKind[] syntaxKinds);
    public abstract virtual bool IsAnyKind(SyntaxTrivia trivia, TSyntaxKind[] syntaxKinds);
    public abstract virtual bool IsInExpressionTree(SemanticModel model, SyntaxNode node);
    public abstract virtual bool IsKind(SyntaxNode node, TSyntaxKind kind);
    public abstract virtual bool IsKind(SyntaxToken token, TSyntaxKind kind);
    public abstract virtual bool IsKind(SyntaxTrivia trivia, TSyntaxKind kind);
    public abstract virtual bool IsKnownAttributeType(SemanticModel model, SyntaxNode attribute, KnownType knownType);
    public abstract virtual bool IsMemberAccessOnKnownType(SyntaxNode memberAccess, string name, KnownType knownType, SemanticModel semanticModel);
    public abstract virtual bool IsNullLiteral(SyntaxNode node);
    public abstract virtual bool IsStatic(SyntaxNode node);
    public abstract virtual bool IsWrittenTo(SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public abstract virtual TSyntaxKind Kind(SyntaxNode node);
    public abstract virtual string LiteralText(SyntaxNode literal);
    public abstract virtual ImmutableArray`1<SyntaxToken> LocalDeclarationIdentifiers(SyntaxNode node);
    public abstract virtual TSyntaxKind[] ModifierKinds(SyntaxNode node);
    public abstract virtual SyntaxNode NodeExpression(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> NodeIdentifier(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> ObjectCreationTypeIdentifier(SyntaxNode objectCreation);
    public abstract virtual SyntaxNode RemoveConditionalAccess(SyntaxNode node);
    public abstract virtual SyntaxNode RemoveParentheses(SyntaxNode node);
    public abstract virtual string StringValue(SyntaxNode node, SemanticModel semanticModel);
    public abstract virtual bool TryGetInterpolatedTextValue(SyntaxNode node, SemanticModel semanticModel, String& interpolatedValue);
    public abstract virtual bool TryGetOperands(SyntaxNode invocation, SyntaxNode& left, SyntaxNode& right);
    protected static T Cast(SyntaxNode node);
    protected static Exception InvalidOperation(SyntaxNode node, string method);
}
public class SonarAnalyzer.Helpers.FieldAccessContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IFieldSymbol> <InvokedFieldSymbol>k__BackingField;
    public string FieldName { get; }
    public Lazy`1<IFieldSymbol> InvokedFieldSymbol { get; }
    public FieldAccessContext(SonarSyntaxNodeReportingContext context, string fieldName);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public Lazy`1<IFieldSymbol> get_InvokedFieldSymbol();
    [CompilerGeneratedAttribute]
private IFieldSymbol <.ctor>b__6_0();
}
public class SonarAnalyzer.Helpers.FilesToAnalyzeProvider : object {
    private IEnumerable`1<string> allFiles;
    public FilesToAnalyzeProvider(string filePath);
    public IEnumerable`1<string> FindFiles(string fileName, bool onlyExistingFiles);
    public IEnumerable`1<string> FindFiles(Regex fullPathRegex, bool onlyExistingFiles);
    private static IEnumerable`1<string> ReadLines(string filePath);
    private static bool FilterByFileName(string fullPath, string fileName);
}
public abstract class SonarAnalyzer.Helpers.GeneratedCodeRecognizer : object {
    private static ImmutableArray`1<string> GeneratedFileParts;
    private static ImmutableArray`1<string> AutoGeneratedCommentParts;
    private static ImmutableArray`1<string> GeneratedCodeAttributes;
    private static GeneratedCodeRecognizer();
    protected abstract virtual bool IsTriviaComment(SyntaxTrivia trivia);
    protected abstract virtual string GetAttributeName(SyntaxNode node);
    public bool IsGenerated(SyntaxTree tree);
    public static bool IsRazorGeneratedFile(SyntaxTree tree);
    public static bool IsRazor(SyntaxTree tree);
    public static bool IsCshtml(SyntaxTree tree);
    private bool HasGeneratedCommentOrAttribute(SyntaxTree tree);
    private bool HasAutoGeneratedComment(SyntaxNode root);
    private bool HasGeneratedCodeAttribute(SyntaxNode root);
    private static bool HasGeneratedFileName(SyntaxTree tree);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.HashCode : object {
    private static UInt32 Seed;
    private static UInt32 PreMultiplier;
    private static UInt32 PostMultiplier;
    private static int RotateOffset;
    private static int IntSeed;
    public static int DictionaryContentHash(ImmutableDictionary`2<TKey, TValue> dictionary);
    public static int EnumerableUnorderedContentHash(IEnumerable`1<TValue> enumerable);
    public static int EnumerableOrderedContentHash(IEnumerable`1<TValue> enumerable);
    public static int Combine(T1 a, T2 b);
    public static int Combine(T1 a, T2 b, T3 c);
    public static int Combine(T1 a, T2 b, T3 c, T4 d);
    public static int Combine(T1 a, T2 b, T3 c, T4 d, T5 e);
    [ExtensionAttribute]
private static UInt32 AddHash(int hash, Nullable`1<int> value);
    [ExtensionAttribute]
private static UInt32 AddHash(UInt32 hash, Nullable`1<int> value);
    private static UInt32 RotateLeft(UInt32 value);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.HashSetExtensions : object {
    [ExtensionAttribute]
public static void AddRange(HashSet`1<T> hashset, IEnumerable`1<T> values);
}
public interface SonarAnalyzer.Helpers.IExpressionNumericConverter {
    public abstract virtual bool TryGetConstantIntValue(SemanticModel semanticModel, SyntaxNode expression, Int32& value);
    public abstract virtual bool TryGetConstantIntValue(SyntaxNode expression, Int32& value);
    public abstract virtual bool TryGetConstantDoubleValue(SyntaxNode expression, Double& value);
}
public interface SonarAnalyzer.Helpers.ILanguageFacade {
    public AssignmentFinder AssignmentFinder { get; }
    public StringComparison NameComparison { get; }
    public StringComparer NameComparer { get; }
    public GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    public IExpressionNumericConverter ExpressionNumericConverter { get; }
    public abstract virtual AssignmentFinder get_AssignmentFinder();
    public abstract virtual StringComparison get_NameComparison();
    public abstract virtual StringComparer get_NameComparer();
    public abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    public abstract virtual IExpressionNumericConverter get_ExpressionNumericConverter();
    public abstract virtual DiagnosticDescriptor CreateDescriptor(string id, string messageFormat, Nullable`1<bool> isEnabledByDefault, bool fadeOutCode);
    public abstract virtual object FindConstantValue(SemanticModel model, SyntaxNode node);
    public abstract virtual IMethodParameterLookup MethodParameterLookup(SyntaxNode invocation, IMethodSymbol methodSymbol);
    public abstract virtual IMethodParameterLookup MethodParameterLookup(SyntaxNode invocation, SemanticModel semanticModel);
    public abstract virtual string GetName(SyntaxNode expression);
}
public interface SonarAnalyzer.Helpers.ILanguageFacade`1 {
    public SyntaxFacade`1<TSyntaxKind> Syntax { get; }
    public ISyntaxKindFacade`1<TSyntaxKind> SyntaxKind { get; }
    public ITrackerFacade`1<TSyntaxKind> Tracker { get; }
    public abstract virtual SyntaxFacade`1<TSyntaxKind> get_Syntax();
    public abstract virtual ISyntaxKindFacade`1<TSyntaxKind> get_SyntaxKind();
    public abstract virtual ITrackerFacade`1<TSyntaxKind> get_Tracker();
}
public interface SonarAnalyzer.Helpers.IMethodParameterLookup {
    public IMethodSymbol MethodSymbol { get; }
    public abstract virtual IMethodSymbol get_MethodSymbol();
    public abstract virtual bool TryGetSymbol(SyntaxNode argument, IParameterSymbol& parameter);
    public abstract virtual bool TryGetSyntax(IParameterSymbol parameter, ImmutableArray`1& expressions);
    public abstract virtual bool TryGetSyntax(string parameterName, ImmutableArray`1& expressions);
    public abstract virtual bool TryGetNonParamsSyntax(IParameterSymbol parameter, SyntaxNode& expression);
}
public interface SonarAnalyzer.Helpers.INetFrameworkVersionProvider {
    public abstract virtual NetFrameworkVersion GetDotNetFrameworkVersion(Compilation compilation);
}
public class SonarAnalyzer.Helpers.InvocationContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IMethodSymbol> <MethodSymbol>k__BackingField;
    public string MethodName { get; }
    public Lazy`1<IMethodSymbol> MethodSymbol { get; }
    public InvocationContext(SonarSyntaxNodeReportingContext context, string methodName);
    public InvocationContext(SyntaxNode node, string methodName, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public Lazy`1<IMethodSymbol> get_MethodSymbol();
    [CompilerGeneratedAttribute]
private IMethodSymbol <.ctor>b__7_0();
}
public interface SonarAnalyzer.Helpers.IReportingContext {
    public SyntaxTree SyntaxTree { get; }
    public Diagnostic Diagnostic { get; }
    public abstract virtual SyntaxTree get_SyntaxTree();
    public abstract virtual Diagnostic get_Diagnostic();
    public abstract virtual void ReportDiagnostic(Diagnostic diagnostic);
}
public class SonarAnalyzer.Helpers.KnownAssembly : object {
    private Func`2<IEnumerable`1<AssemblyIdentity>, bool> predicate;
    [CompilerGeneratedAttribute]
private static KnownAssembly <XUnit_Assert>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <MSTest>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <NFluent>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <FluentAssertions>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <NSubstitute>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <MicrosoftExtensionsLoggingAbstractions>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <Serilog>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <MicrosoftAspNetCoreMvcCore>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <SwashbuckleAspNetCoreSwagger>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <NLog>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <Log4Net>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <CommonLoggingCore>k__BackingField;
    [CompilerGeneratedAttribute]
private static KnownAssembly <CastleCore>k__BackingField;
    private static StringComparison AssemblyNameComparission;
    public static KnownAssembly XUnit_Assert { get; }
    public static KnownAssembly MSTest { get; }
    public static KnownAssembly NFluent { get; }
    public static KnownAssembly FluentAssertions { get; }
    public static KnownAssembly NSubstitute { get; }
    public static KnownAssembly MicrosoftExtensionsLoggingAbstractions { get; }
    public static KnownAssembly Serilog { get; }
    public static KnownAssembly MicrosoftAspNetCoreMvcCore { get; }
    public static KnownAssembly SwashbuckleAspNetCoreSwagger { get; }
    public static KnownAssembly NLog { get; }
    public static KnownAssembly Log4Net { get; }
    public static KnownAssembly CommonLoggingCore { get; }
    public static KnownAssembly CastleCore { get; }
    internal KnownAssembly(Func`2<AssemblyIdentity, bool> predicate, Func`2[] or);
    internal KnownAssembly(Func`2<IEnumerable`1<AssemblyIdentity>, bool> predicate);
    private static KnownAssembly();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_XUnit_Assert();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_MSTest();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_NFluent();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_FluentAssertions();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_NSubstitute();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_MicrosoftExtensionsLoggingAbstractions();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_Serilog();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_MicrosoftAspNetCoreMvcCore();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_SwashbuckleAspNetCoreSwagger();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_NLog();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_Log4Net();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_CommonLoggingCore();
    [CompilerGeneratedAttribute]
public static KnownAssembly get_CastleCore();
    public bool IsReferencedBy(Compilation compilation);
    internal static Func`2<AssemblyIdentity, bool> And(Func`2<AssemblyIdentity, bool> left, Func`2<AssemblyIdentity, bool> right);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.KnownMethods : object {
    private static int NumberOfParamsForBinaryOperator;
    [ExtensionAttribute]
public static bool IsMainMethod(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsObjectEquals(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsStaticObjectEquals(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsObjectGetHashCode(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsObjectToString(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsIDisposableDispose(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsIAsyncDisposableDisposeAsync(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsIEquatableEquals(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsGetObjectData(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsSerializationConstructor(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsArrayClone(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsRecordPrintMembers(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsGcSuppressFinalize(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsDebugAssert(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsDiagnosticDebugMethod(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorBinaryPlus(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorBinaryMinus(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorBinaryMultiply(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorBinaryDivide(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorBinaryModulus(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorEquals(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperatorNotEquals(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsConsoleWriteLine(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsConsoleWrite(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableConcat(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableCount(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableExcept(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableIntersect(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableSequenceEqual(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableToList(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableToArray(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEnumerableUnion(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsListAddRange(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsEventHandler(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
private static bool IsEnumerableMethod(IMethodSymbol methodSymbol, string methodName, Int32[] parametersCount);
    [ExtensionAttribute]
private static bool HasExactlyNParameters(IMethodSymbol methodSymbol, int parametersCount);
    private static INamedTypeSymbol ContainingInterface(IMethodSymbol symbol);
    [CompilerGeneratedAttribute]
internal static bool <IsMainMethod>g__HasMainParameters|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsMainMethod>g__HasMainReturnType|1_1(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsStaticObjectEquals>g__HasCorrectParameters|3_0(<>c__DisplayClass3_0& );
}
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
public class SonarAnalyzer.Helpers.KnownType : object {
    public static KnownType Azure_Messaging_ServiceBus_Administration_ServiceBusAdministrationClient;
    public static KnownType Azure_Messaging_ServiceBus_ServiceBusClient;
    public static KnownType Azure_Storage_Blobs_BlobServiceClient;
    public static KnownType Azure_Storage_Queues_QueueServiceClient;
    public static KnownType Azure_Storage_Files_Shares_ShareServiceClient;
    public static KnownType Azure_Storage_Files_DataLake_DataLakeServiceClient;
    public static KnownType Azure_ResourceManager_ArmClient;
    public static KnownType Castle_Core_Logging_ILogger;
    public static KnownType Common_Logging_ILog;
    public static KnownType Dapper_SqlMapper;
    public static KnownType Dapper_CommandDefinition;
    public static KnownType FluentAssertions_AssertionExtensions;
    public static KnownType FluentAssertions_Execution_AssertionScope;
    public static KnownType FluentAssertions_Primitives_ReferenceTypeAssertions;
    public static KnownType FluentValidation_IValidator;
    public static KnownType FluentValidation_IValidator_T;
    public static KnownType JWT_Builder_JwtBuilder;
    public static KnownType JWT_IJwtDecoder;
    public static KnownType JWT_JwtDecoderExtensions;
    public static KnownType log4net_Config_BasicConfigurator;
    public static KnownType log4net_Config_DOMConfigurator;
    public static KnownType log4net_Config_XmlConfigurator;
    public static KnownType log4net_Core_ILogger;
    public static KnownType log4net_ILog;
    public static KnownType log4net_LogManager;
    public static KnownType log4net_Util_ILogExtensions;
    public static KnownType Microsoft_AspNet_Identity_PasswordHasherOptions;
    public static KnownType Microsoft_AspNet_SignalR_Hub;
    public static KnownType Microsoft_AspNetCore_Builder_DeveloperExceptionPageExtensions;
    public static KnownType Microsoft_AspNetCore_Builder_DatabaseErrorPageExtensions;
    public static KnownType Microsoft_AspNetCore_Components_ParameterAttribute;
    public static KnownType Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilder;
    public static KnownType Microsoft_AspNetCore_Components_RouteAttribute;
    public static KnownType Microsoft_AspNetCore_Components_SupplyParameterFromQueryAttribute;
    public static KnownType Microsoft_AspNetCore_Cors_Infrastructure_CorsPolicyBuilder;
    public static KnownType Microsoft_AspNetCore_Cryptography_KeyDerivation_KeyDerivation;
    public static KnownType Microsoft_AspNetCore_Hosting_HostingEnvironmentExtensions;
    public static KnownType Microsoft_AspNetCore_Hosting_WebHostBuilderExtensions;
    public static KnownType Microsoft_AspNetCore_Http_CookieOptions;
    public static KnownType Microsoft_AspNetCore_Http_HeaderDictionaryExtensions;
    public static KnownType Microsoft_AspNetCore_Http_IFormCollection;
    public static KnownType Microsoft_AspNetCore_Http_IFormFile;
    public static KnownType Microsoft_AspNetCore_Http_IFormFileCollection;
    public static KnownType Microsoft_AspNetCore_Http_IHeaderDictionary;
    public static KnownType Microsoft_AspNetCore_Http_IQueryCollection;
    public static KnownType Microsoft_AspNetCore_Http_IRequestCookieCollection;
    public static KnownType Microsoft_AspNetCore_Http_IResponseCookies;
    public static KnownType Microsoft_AspNetCore_Http_IResult;
    public static KnownType Microsoft_AspNetCore_Http_Results;
    public static KnownType Microsoft_AspNetCore_Identity_PasswordHasherOptions;
    public static KnownType Microsoft_AspNetCore_Mvc_AcceptVerbsAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ApiControllerAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ApiConventionMethodAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ApiConventionTypeAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ApiExplorerSettingsAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Controller;
    public static KnownType Microsoft_AspNetCore_Mvc_ControllerBase;
    public static KnownType Microsoft_AspNetCore_Mvc_ControllerAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_DisableRequestSizeLimitAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Filters_ActionFilterAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Filters_IActionFilter;
    public static KnownType Microsoft_AspNetCore_Mvc_Filters_IAsyncActionFilter;
    public static KnownType Microsoft_AspNetCore_Mvc_FromServicesAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpDeleteAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpGetAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpHeadAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpOptionsAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpPatchAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpPostAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_HttpPutAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_IActionResult;
    public static KnownType Microsoft_AspNetCore_Mvc_IgnoreAntiforgeryTokenAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Infrastructure_ActionResultObjectValueAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ModelBinding_BindNeverAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ModelBinding_ModelStateDictionary;
    public static KnownType Microsoft_AspNetCore_Mvc_ModelBinding_Validation_ValidateNeverAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_NonActionAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_NonControllerAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ObjectResult;
    public static KnownType Microsoft_AspNetCore_Mvc_ProducesAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ProducesAttribute_T;
    public static KnownType Microsoft_AspNetCore_Mvc_ProducesResponseTypeAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_ProducesResponseTypeAttribute_T;
    public static KnownType Microsoft_AspNetCore_Mvc_RazorPages_PageModel;
    public static KnownType Microsoft_AspNetCore_Mvc_RequestFormLimitsAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_RequestSizeLimitAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_RouteAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Routing_HttpMethodAttribute;
    public static KnownType Microsoft_AspNetCore_Mvc_Routing_IRouteTemplateProvider;
    public static KnownType Microsoft_AspNetCore_Razor_Hosting_RazorCompiledItemAttribute;
    public static KnownType Microsoft_AspNetCore_Routing_RouteValueDictionary;
    public static KnownType Microsoft_Azure_Cosmos_CosmosClient;
    public static KnownType Microsoft_Azure_Documents_Client_DocumentClient;
    public static KnownType Microsoft_Azure_ServiceBus_Management_ManagementClient;
    public static KnownType Microsoft_Azure_ServiceBus_QueueClient;
    public static KnownType Microsoft_Azure_ServiceBus_SessionClient;
    public static KnownType Microsoft_Azure_ServiceBus_SubscriptionClient;
    public static KnownType Microsoft_Azure_ServiceBus_TopicClient;
    public static KnownType Microsoft_Azure_WebJobs_Extensions_DurableTask_IDurableEntityClient;
    public static KnownType Microsoft_Azure_WebJobs_Extensions_DurableTask_IDurableEntityContext;
    public static KnownType Microsoft_Azure_WebJobs_Extensions_DurableTask_IDurableOrchestrationContext;
    public static KnownType Microsoft_Azure_WebJobs_FunctionNameAttribute;
    public static KnownType Microsoft_Data_Sqlite_SqliteCommand;
    public static KnownType Microsoft_EntityFramework_DbContext;
    public static KnownType Microsoft_EntityFrameworkCore_DbContext;
    public static KnownType Microsoft_EntityFrameworkCore_DbContextOptionsBuilder;
    public static KnownType Microsoft_EntityFrameworkCore_DbSet_TEntity;
    public static KnownType Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_IDbContextFactory_TContext;
    public static KnownType Microsoft_EntityFrameworkCore_Migrations_Migration;
    public static KnownType Microsoft_EntityFrameworkCore_MySQLDbContextOptionsExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_NpgsqlDbContextOptionsExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_NpgsqlDbContextOptionsBuilderExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_OracleDbContextOptionsExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_RawSqlString;
    public static KnownType Microsoft_EntityFrameworkCore_RelationalDatabaseFacadeExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_RelationalQueryableExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_SqliteDbContextOptionsBuilderExtensions;
    public static KnownType Microsoft_EntityFrameworkCore_SqlServerDbContextOptionsExtensions;
    public static KnownType Microsoft_Extensions_DependencyInjection_LoggingServiceCollectionExtensions;
    public static KnownType Microsoft_Extensions_Hosting_HostEnvironmentEnvExtensions;
    public static KnownType Microsoft_Extensions_Configuration_IConfiguration;
    public static KnownType Microsoft_Extensions_Logging_AzureAppServicesLoggerFactoryExtensions;
    public static KnownType Microsoft_Extensions_Logging_ConsoleLoggerExtensions;
    public static KnownType Microsoft_Extensions_Logging_DebugLoggerFactoryExtensions;
    public static KnownType Microsoft_Extensions_Logging_EventLoggerFactoryExtensions;
    public static KnownType Microsoft_Extensions_Logging_EventSourceLoggerFactoryExtensions;
    public static KnownType Microsoft_Extensions_Logging_EventId;
    public static KnownType Microsoft_Extensions_Logging_ILogger;
    public static KnownType Microsoft_Extensions_Logging_ILogger_TCategoryName;
    public static KnownType Microsoft_Extensions_Logging_ILoggerFactory;
    public static KnownType Microsoft_Extensions_Logging_LoggerExtensions;
    public static KnownType Microsoft_Extensions_Logging_LoggerFactoryExtensions;
    public static KnownType Microsoft_Extensions_Logging_LogLevel;
    public static KnownType Microsoft_Extensions_Primitives_StringValues;
    public static KnownType Microsoft_IdentityModel_Tokens_SymmetricSecurityKey;
    public static KnownType Microsoft_Net_Http_Headers_HeaderNames;
    public static KnownType Microsoft_JSInterop_JSInvokable;
    public static KnownType Microsoft_VisualBasic_Information;
    public static KnownType Microsoft_VisualBasic_Interaction;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_Assert;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_AssertFailedException;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_ExpectedExceptionBaseAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_ExpectedExceptionAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_IgnoreAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_TestClassAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_TestMethodAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_DataTestMethodAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_WorkItemAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_AssemblyCleanupAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_AssemblyInitializeAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_ClassCleanupAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_ClassInitializeAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_TestCleanupAttribute;
    public static KnownType Microsoft_VisualStudio_TestTools_UnitTesting_TestInitializeAttribute;
    public static KnownType Microsoft_Web_XmlTransform_XmlFileInfoDocument;
    public static KnownType Microsoft_Web_XmlTransform_XmlTransformableDocument;
    public static KnownType MongoDB_Driver_IMongoCollectionExtensions;
    public static KnownType Mono_Data_Sqlite_SqliteCommand;
    public static KnownType Mono_Data_Sqlite_SqliteDataAdapter;
    public static KnownType Mono_Unix_FileAccessPermissions;
    public static KnownType MySql_Data_MySqlClient_MySqlDataAdapter;
    public static KnownType MySql_Data_MySqlClient_MySqlCommand;
    public static KnownType MySql_Data_MySqlClient_MySqlHelper;
    public static KnownType MySql_Data_MySqlClient_MySqlScript;
    public static KnownType Nancy_Cookies_NancyCookie;
    public static KnownType NFluent_Check;
    public static KnownType NFluent_FluentCheckException;
    public static KnownType NFluent_Kernel_FluentCheckException;
    public static KnownType NHibernate_ISession;
    public static KnownType NHibernate_Impl_AbstractSessionImpl;
    public static KnownType NLog_ILogger;
    public static KnownType NLog_ILoggerBase;
    public static KnownType NLog_ILoggerExtensions;
    public static KnownType NLog_LogLevel;
    public static KnownType NLog_LogFactory;
    public static KnownType NLog_LogManager;
    public static KnownType NLog_Logger;
    public static KnownType Newtonsoft_Json_JsonPropertyAttribute;
    public static KnownType Newtonsoft_Json_JsonRequiredAttribute;
    public static KnownType Newtonsoft_Json_JsonIgnoreAttribute;
    public static KnownType NUnit_Framework_Assert;
    public static KnownType NUnit_Framework_AssertionException;
    public static KnownType NUnit_Framework_ExpectedExceptionAttribute;
    public static KnownType NUnit_Framework_IgnoreAttribute;
    public static KnownType NUnit_Framework_ITestBuilderInterface;
    public static KnownType NUnit_Framework_TestAttribute;
    public static KnownType NUnit_Framework_TestCaseAttribute;
    public static KnownType NUnit_Framework_TestCaseSourceAttribute;
    public static KnownType NUnit_Framework_TestFixtureAttribute;
    public static KnownType NUnit_Framework_TheoryAttribute;
    public static KnownType Org_BouncyCastle_Asn1_Nist_NistNamedCurves;
    public static KnownType Org_BouncyCastle_Asn1_Sec_SecNamedCurves;
    public static KnownType Org_BouncyCastle_Asn1_TeleTrust_TeleTrusTNamedCurves;
    public static KnownType Org_BouncyCastle_Asn1_X9_ECNamedCurveTable;
    public static KnownType Org_BouncyCastle_Asn1_X9_X962NamedCurves;
    public static KnownType Org_BouncyCastle_Crypto_Engines_AesFastEngine;
    public static KnownType Org_BouncyCastle_Crypto_Generators_BCrypt;
    public static KnownType Org_BouncyCastle_Crypto_Generators_SCrypt;
    public static KnownType Org_BouncyCastle_Crypto_Generators_DHParametersGenerator;
    public static KnownType Org_BouncyCastle_Crypto_Generators_OpenBsdBCrypt;
    public static KnownType Org_BouncyCastle_Crypto_Generators_DsaParametersGenerator;
    public static KnownType Org_BouncyCastle_Crypto_Parameters_RsaKeyGenerationParameters;
    public static KnownType Org_BouncyCastle_Crypto_PbeParametersGenerator;
    public static KnownType Org_BouncyCastle_Crypto_Prng_DigestRandomGenerator;
    public static KnownType Org_BouncyCastle_Crypto_Prng_IRandomGenerator;
    public static KnownType Org_BouncyCastle_Crypto_Prng_VmpcRandomGenerator;
    public static KnownType Org_BouncyCastle_Security_SecureRandom;
    public static KnownType Serilog_Events_LogEventLevel;
    public static KnownType Serilog_ILogger;
    public static KnownType Serilog_LoggerConfiguration;
    public static KnownType Serilog_Log;
    public static KnownType ServiceStack_OrmLite_OrmLiteReadApi;
    public static KnownType ServiceStack_OrmLite_OrmLiteReadApiAsync;
    public static KnownType System_Action;
    public static KnownType System_Action_T;
    public static KnownType System_Action_T1_T2;
    public static KnownType System_Action_T1_T2_T3;
    public static KnownType System_Action_T1_T2_T3_T4;
    public static KnownType System_Activator;
    public static KnownType System_ApplicationException;
    public static KnownType System_AppDomain;
    public static KnownType System_ArgumentException;
    public static KnownType System_ArgumentNullException;
    public static KnownType System_ArgumentOutOfRangeException;
    public static KnownType System_Array;
    public static KnownType System_Attribute;
    public static KnownType System_AttributeUsageAttribute;
    public static KnownType System_Boolean;
    public static KnownType System_Byte;
    public static KnownType System_Byte_Array;
    public static KnownType System_Char;
    public static KnownType System_Char_Array;
    public static KnownType System_Convert;
    public static KnownType System_CLSCompliantAttribute;
    public static KnownType System_CodeDom_Compiler_GeneratedCodeAttribute;
    public static KnownType System_Collections_CollectionBase;
    public static KnownType System_Collections_Concurrent_ConcurrentDictionary_TKey_TValue;
    public static KnownType System_Collections_DictionaryBase;
    public static KnownType System_Collections_Frozen_FrozenDictionary_TKey_TValue;
    public static KnownType System_Collections_Frozen_FrozenSet_T;
    public static KnownType System_Collections_Generic_Comparer_T;
    public static KnownType System_Collections_Generic_Dictionary_TKey_TValue;
    public static KnownType System_Collections_Generic_HashSet_T;
    public static KnownType System_Collections_Generic_IAsyncEnumerable_T;
    public static KnownType System_Collections_Generic_ICollection_T;
    public static KnownType System_Collections_Generic_IDictionary_TKey_TValue;
    public static KnownType System_Collections_Generic_IEnumerable_T;
    public static KnownType System_Collections_Generic_IList_T;
    public static KnownType System_Collections_Generic_IReadOnlyCollection_T;
    public static KnownType System_Collections_Generic_IReadOnlyList_T;
    public static KnownType System_Collections_Generic_ISet_T;
    public static KnownType System_Collections_Generic_KeyValuePair_TKey_TValue;
    public static KnownType System_Collections_Generic_List_T;
    public static KnownType System_Collections_Generic_Queue_T;
    public static KnownType System_Collections_Generic_SortedSet_T;
    public static KnownType System_Collections_Generic_Stack_T;
    public static KnownType System_Collections_Generic_LinkedList_T;
    public static KnownType System_Collections_ICollection;
    public static KnownType System_Collections_IEnumerable;
    public static KnownType System_Collections_IList;
    public static KnownType System_Collections_Immutable_IImmutableArray_T;
    public static KnownType System_Collections_Immutable_IImmutableDictionary_TKey_TValue;
    public static KnownType System_Collections_Immutable_IImmutableList_T;
    public static KnownType System_Collections_Immutable_IImmutableQueue_T;
    public static KnownType System_Collections_Immutable_IImmutableSet_T;
    public static KnownType System_Collections_Immutable_IImmutableStack_T;
    public static KnownType System_Collections_Immutable_ImmutableArray;
    public static KnownType System_Collections_Immutable_ImmutableArray_T;
    public static KnownType System_Collections_Immutable_ImmutableDictionary;
    public static KnownType System_Collections_Immutable_ImmutableDictionary_TKey_TValue;
    public static KnownType System_Collections_Immutable_ImmutableHashSet;
    public static KnownType System_Collections_Immutable_ImmutableHashSet_T;
    public static KnownType System_Collections_Immutable_ImmutableList;
    public static KnownType System_Collections_Immutable_ImmutableList_T;
    public static KnownType System_Collections_Immutable_ImmutableQueue;
    public static KnownType System_Collections_Immutable_ImmutableQueue_T;
    public static KnownType System_Collections_Immutable_ImmutableSortedDictionary;
    public static KnownType System_Collections_Immutable_ImmutableSortedDictionary_TKey_TValue;
    public static KnownType System_Collections_Immutable_ImmutableSortedSet;
    public static KnownType System_Collections_Immutable_ImmutableSortedSet_T;
    public static KnownType System_Collections_Immutable_ImmutableStack;
    public static KnownType System_Collections_Immutable_ImmutableStack_T;
    public static KnownType System_Collections_ObjectModel_Collection_T;
    public static KnownType System_Collections_ObjectModel_ObservableCollection_T;
    public static KnownType System_Collections_ObjectModel_ReadOnlyCollection_T;
    public static KnownType System_Collections_ObjectModel_ReadOnlyDictionary_TKey_TValue;
    public static KnownType System_Collections_Queue;
    public static KnownType System_Collections_ReadOnlyCollectionBase;
    public static KnownType System_Collections_SortedList;
    public static KnownType System_Collections_Stack;
    public static KnownType System_Collections_Specialized_NameObjectCollectionBase;
    public static KnownType System_Collections_Specialized_NameValueCollection;
    public static KnownType System_Composition_ExportAttribute;
    public static KnownType System_ComponentModel_Composition_CreationPolicy;
    public static KnownType System_ComponentModel_Composition_ExportAttribute;
    public static KnownType System_ComponentModel_Composition_InheritedExportAttribute;
    public static KnownType System_ComponentModel_Composition_PartCreationPolicyAttribute;
    public static KnownType System_ComponentModel_DataAnnotations_KeyAttribute;
    public static KnownType System_ComponentModel_DataAnnotations_RegularExpressionAttribute;
    public static KnownType System_ComponentModel_DataAnnotations_RangeAttribute;
    public static KnownType System_ComponentModel_DataAnnotations_IValidatableObject;
    public static KnownType System_ComponentModel_DataAnnotations_RequiredAttribute;
    public static KnownType System_ComponentModel_DataAnnotations_ValidationAttribute;
    public static KnownType System_ComponentModel_DefaultValueAttribute;
    public static KnownType System_ComponentModel_EditorBrowsableAttribute;
    public static KnownType System_ComponentModel_LocalizableAttribute;
    public static KnownType System_Configuration_ConfigXmlDocument;
    public static KnownType System_Configuration_ConfigurationManager;
    public static KnownType System_Console;
    public static KnownType System_Data_Common_CommandTrees_DbExpression;
    public static KnownType System_Data_DataSet;
    public static KnownType System_Data_DataTable;
    public static KnownType System_Data_Entity_Core_Objects_ObjectQuery;
    public static KnownType System_Data_Entity_Database;
    public static KnownType System_Data_Entity_DbSet;
    public static KnownType System_Data_Entity_DbSet_TEntity;
    public static KnownType System_Data_Entity_Infrastructure_DbQuery;
    public static KnownType System_Data_Entity_Infrastructure_DbQuery_TResult;
    public static KnownType System_Data_IDbCommand;
    public static KnownType System_Data_Linq_ITable;
    public static KnownType System_Data_Odbc_OdbcCommand;
    public static KnownType System_Data_Odbc_OdbcDataAdapter;
    public static KnownType System_Data_OracleClient_OracleCommand;
    public static KnownType System_Data_OracleClient_OracleDataAdapter;
    public static KnownType System_Data_SqlClient_SqlCommand;
    public static KnownType System_Data_SqlClient_SqlDataAdapter;
    public static KnownType System_Data_Sqlite_SqliteCommand;
    public static KnownType System_Data_Sqlite_SQLiteDataAdapter;
    public static KnownType System_Data_SqlServerCe_SqlCeCommand;
    public static KnownType System_Data_SqlServerCe_SqlCeDataAdapter;
    public static KnownType System_DateOnly;
    public static KnownType System_DateTime;
    public static KnownType System_DateTimeKind;
    public static KnownType System_DateTimeOffset;
    public static KnownType System_Decimal;
    public static KnownType System_Delegate;
    public static KnownType System_Diagnostics_CodeAnalysis_DynamicallyAccessedMembersAttribute;
    public static KnownType System_Diagnostics_CodeAnalysis_ExcludeFromCodeCoverageAttribute;
    public static KnownType System_Diagnostics_CodeAnalysis_SuppressMessageAttribute;
    public static KnownType System_Diagnostics_CodeAnalysis_StringSyntaxAttribute;
    public static KnownType System_Diagnostics_ConditionalAttribute;
    public static KnownType System_Diagnostics_Contracts_PureAttribute;
    public static KnownType System_Diagnostics_Debug;
    public static KnownType System_Diagnostics_Debugger;
    public static KnownType System_Diagnostics_DebuggerDisplayAttribute;
    public static KnownType System_Diagnostics_Process;
    public static KnownType System_Diagnostics_ProcessStartInfo;
    public static KnownType System_Diagnostics_Trace;
    public static KnownType System_Diagnostics_TraceSource;
    public static KnownType System_Diagnostics_TraceSwitch;
    public static KnownType System_DirectoryServices_AuthenticationTypes;
    public static KnownType System_DirectoryServices_DirectoryEntry;
    public static KnownType System_Double;
    public static KnownType System_Drawing_Bitmap;
    public static KnownType System_Drawing_Image;
    public static KnownType System_DuplicateWaitObjectException;
    public static KnownType System_Enum;
    public static KnownType System_Environment;
    public static KnownType System_EventArgs;
    public static KnownType System_EventHandler;
    public static KnownType System_EventHandler_TEventArgs;
    public static KnownType System_Exception;
    public static KnownType System_ExecutionEngineException;
    public static KnownType System_FlagsAttribute;
    public static KnownType System_FormattableString;
    public static KnownType System_Func_TResult;
    public static KnownType System_Func_T_TResult;
    public static KnownType System_Func_T1_T2_TResult;
    public static KnownType System_Func_T1_T2_T3_TResult;
    public static KnownType System_Func_T1_T2_T3_T4_TResult;
    public static KnownType System_GC;
    public static KnownType System_Globalization_CompareOptions;
    public static KnownType System_Globalization_CultureInfo;
    public static KnownType System_Guid;
    public static KnownType System_Half;
    public static KnownType System_IAsyncDisposable;
    public static KnownType System_IComparable;
    public static KnownType System_IComparable_T;
    public static KnownType System_IdentityModel_Tokens_SecurityTokenHandler;
    public static KnownType System_IdentityModel_Tokens_SymmetricSecurityKey;
    public static KnownType System_IDisposable;
    public static KnownType System_IEquatable_T;
    public static KnownType System_IFormatProvider;
    public static KnownType System_Index;
    public static KnownType System_IndexOutOfRangeException;
    public static KnownType System_Int16;
    public static KnownType System_Int32;
    public static KnownType System_Int64;
    public static KnownType System_IntPtr;
    public static KnownType System_InvalidOperationException;
    public static KnownType System_IO_Compression_ZipFile;
    public static KnownType System_IO_Compression_ZipFileExtensions;
    public static KnownType System_IO_FileStream;
    public static KnownType System_IO_Path;
    public static KnownType System_IO_Stream;
    public static KnownType System_IO_StreamReader;
    public static KnownType System_IO_StreamWriter;
    public static KnownType System_IO_TextWriter;
    public static KnownType System_Lazy;
    public static KnownType System_Linq_Enumerable;
    public static KnownType System_Linq_Expressions_Expression;
    public static KnownType System_Linq_Expressions_Expression_T;
    public static KnownType System_Linq_ImmutableArrayExtensions;
    public static KnownType System_Linq_IQueryable;
    public static KnownType System_Linq_Queryable;
    public static KnownType System_MarshalByRefObject;
    public static KnownType System_MTAThreadAttribute;
    public static KnownType System_Net_FtpWebRequest;
    public static KnownType System_Net_Http_HttpClient;
    public static KnownType System_Net_Http_Headers_HttpHeaders;
    public static KnownType System_Net_Http_HttpClientHandler;
    public static KnownType System_Net_Mail_SmtpClient;
    public static KnownType System_Net_NetworkCredential;
    public static KnownType System_Net_Security_RemoteCertificateValidationCallback;
    public static KnownType System_Net_Security_SslPolicyErrors;
    public static KnownType System_Net_SecurityProtocolType;
    public static KnownType System_Net_Sockets_Socket;
    public static KnownType System_Net_Sockets_SocketTaskExtensions;
    public static KnownType System_Net_Sockets_TcpClient;
    public static KnownType System_Net_Sockets_UdpClient;
    public static KnownType System_Net_WebClient;
    public static KnownType System_NonSerializedAttribute;
    public static KnownType System_NotImplementedException;
    public static KnownType System_NotSupportedException;
    public static KnownType System_Nullable_T;
    public static KnownType System_NullReferenceException;
    public static KnownType System_Numerics_IEqualityOperators_TSelf_TOther_TResult;
    public static KnownType System_Numerics_IFloatingPointIeee754_TSelf;
    public static KnownType System_Object;
    public static KnownType System_Object_Array;
    public static KnownType System_ObsoleteAttribute;
    public static KnownType System_OutOfMemoryException;
    public static KnownType System_Random;
    public static KnownType System_Range;
    public static KnownType System_ReadOnlySpan_T;
    public static KnownType System_Reflection_Assembly;
    public static KnownType System_Reflection_BindingFlags;
    public static KnownType System_Reflection_AssemblyVersionAttribute;
    public static KnownType System_Reflection_MemberInfo;
    public static KnownType System_Reflection_Module;
    public static KnownType System_Reflection_ParameterInfo;
    public static KnownType System_Resources_NeutralResourcesLanguageAttribute;
    public static KnownType System_Runtime_CompilerServices_ExtensionAttribute;
    public static KnownType System_Runtime_CompilerServices_CallerArgumentExpressionAttribute;
    public static KnownType System_Runtime_CompilerServices_CallerFilePathAttribute;
    public static KnownType System_Runtime_CompilerServices_CallerLineNumberAttribute;
    public static KnownType System_Runtime_CompilerServices_CallerMemberNameAttribute;
    public static KnownType System_Runtime_CompilerServices_InternalsVisibleToAttribute;
    public static KnownType System_Runtime_CompilerServices_ModuleInitializerAttribute;
    public static KnownType System_Runtime_CompilerServices_ValueTaskAwaiter;
    public static KnownType System_Runtime_CompilerServices_ValueTaskAwaiter_TResult;
    public static KnownType System_Runtime_CompilerServices_TaskAwaiter;
    public static KnownType System_Runtime_CompilerServices_TaskAwaiter_TResult;
    public static KnownType System_Runtime_InteropServices_ComImportAttribute;
    public static KnownType System_Runtime_InteropServices_ComVisibleAttribute;
    public static KnownType System_Runtime_InteropServices_DefaultParameterValueAttribute;
    public static KnownType System_Runtime_InteropServices_DllImportAttribute;
    public static KnownType System_Runtime_InteropServices_Exception;
    public static KnownType System_Runtime_InteropServices_HandleRef;
    public static KnownType System_Runtime_InteropServices_InterfaceTypeAttribute;
    public static KnownType System_Runtime_InteropServices_LibraryImportAttribute;
    public static KnownType System_Runtime_InteropServices_NFloat;
    public static KnownType System_Runtime_InteropServices_OptionalAttribute;
    public static KnownType System_Runtime_InteropServices_SafeHandle;
    public static KnownType System_Runtime_InteropServices_StructLayoutAttribute;
    public static KnownType System_Runtime_Serialization_DataMemberAttribute;
    public static KnownType System_Runtime_Serialization_Formatters_Binary_BinaryFormatter;
    public static KnownType System_Runtime_Serialization_Formatters_Soap_SoapFormatter;
    public static KnownType System_Runtime_Serialization_ISerializable;
    public static KnownType System_Runtime_Serialization_IDeserializationCallback;
    public static KnownType System_Runtime_Serialization_NetDataContractSerializer;
    public static KnownType System_Runtime_Serialization_OnDeserializedAttribute;
    public static KnownType System_Runtime_Serialization_OnDeserializingAttribute;
    public static KnownType System_Runtime_Serialization_OnSerializedAttribute;
    public static KnownType System_Runtime_Serialization_OnSerializingAttribute;
    public static KnownType System_Runtime_Serialization_OptionalFieldAttribute;
    public static KnownType System_Runtime_Serialization_SerializationInfo;
    public static KnownType System_Runtime_Serialization_StreamingContext;
    public static KnownType System_SByte;
    public static KnownType System_Security_AccessControl_FileSystemAccessRule;
    public static KnownType System_Security_AccessControl_FileSystemSecurity;
    public static KnownType System_Security_AllowPartiallyTrustedCallersAttribute;
    public static KnownType System_Security_Authentication_SslProtocols;
    public static KnownType System_Security_Cryptography_AesManaged;
    public static KnownType System_Security_Cryptography_AsymmetricAlgorithm;
    public static KnownType System_Security_Cryptography_AsymmetricKeyExchangeDeformatter;
    public static KnownType System_Security_Cryptography_AsymmetricKeyExchangeFormatter;
    public static KnownType System_Security_Cryptography_AsymmetricSignatureDeformatter;
    public static KnownType System_Security_Cryptography_AsymmetricSignatureFormatter;
    public static KnownType System_Security_Cryptography_CryptoConfig;
    public static KnownType System_Security_Cryptography_CspParameters;
    public static KnownType System_Security_Cryptography_DES;
    public static KnownType System_Security_Cryptography_DeriveBytes;
    public static KnownType System_Security_Cryptography_DSA;
    public static KnownType System_Security_Cryptography_DSACryptoServiceProvider;
    public static KnownType System_Security_Cryptography_ECDiffieHellman;
    public static KnownType System_Security_Cryptography_ECDsa;
    public static KnownType System_Security_Cryptography_ECAlgorythm;
    public static KnownType System_Security_Cryptography_HashAlgorithm;
    public static KnownType System_Security_Cryptography_HMAC;
    public static KnownType System_Security_Cryptography_HMACMD5;
    public static KnownType System_Security_Cryptography_HMACRIPEMD160;
    public static KnownType System_Security_Cryptography_HMACSHA1;
    public static KnownType System_Security_Cryptography_ICryptoTransform;
    public static KnownType System_Security_Cryptography_KeyedHashAlgorithm;
    public static KnownType System_Security_Cryptography_MD5;
    public static KnownType System_Security_Cryptography_PasswordDeriveBytes;
    public static KnownType System_Security_Cryptography_RC2;
    public static KnownType System_Security_Cryptography_RandomNumberGenerator;
    public static KnownType System_Security_Cryptography_Rfc2898DeriveBytes;
    public static KnownType System_Security_Cryptography_RIPEMD160;
    public static KnownType System_Security_Cryptography_RNGCryptoServiceProvider;
    public static KnownType System_Security_Cryptography_RSA;
    public static KnownType System_Security_Cryptography_RSACryptoServiceProvider;
    public static KnownType System_Security_Cryptography_SHA1;
    public static KnownType System_Security_Cryptography_SymmetricAlgorithm;
    public static KnownType System_Security_Cryptography_TripleDES;
    public static KnownType System_Security_Cryptography_X509Certificates_X509Certificate2;
    public static KnownType System_Security_Cryptography_X509Certificates_X509Chain;
    public static KnownType System_Security_Cryptography_Xml_SignedXml;
    public static KnownType System_Security_Permissions_CodeAccessSecurityAttribute;
    public static KnownType System_Security_Permissions_PrincipalPermission;
    public static KnownType System_Security_Permissions_PrincipalPermissionAttribute;
    public static KnownType System_Security_PermissionSet;
    public static KnownType System_Security_Principal_IIdentity;
    public static KnownType System_Security_Principal_IPrincipal;
    public static KnownType System_Security_Principal_NTAccount;
    public static KnownType System_Security_Principal_SecurityIdentifier;
    public static KnownType System_Security_Principal_WindowsIdentity;
    public static KnownType System_Security_SecureString;
    public static KnownType System_Security_SecurityCriticalAttribute;
    public static KnownType System_Security_SecuritySafeCriticalAttribute;
    public static KnownType System_SerializableAttribute;
    public static KnownType System_ServiceModel_OperationContractAttribute;
    public static KnownType System_ServiceModel_ServiceContractAttribute;
    public static KnownType System_Single;
    public static KnownType System_StackOverflowException;
    public static KnownType System_STAThreadAttribute;
    public static KnownType System_String;
    public static KnownType System_String_Array;
    public static KnownType System_StringComparison;
    public static KnownType System_SystemException;
    public static KnownType System_Text_Encoding;
    public static KnownType System_Text_Json_Serialization_JsonIgnoreAttribute;
    public static KnownType System_Text_Json_Serialization_JsonRequiredAttribute;
    public static KnownType System_Text_RegularExpressions_Regex;
    public static KnownType System_Text_RegularExpressions_RegexOptions;
    public static KnownType System_Text_StringBuilder;
    public static KnownType System_Threading_CancellationToken;
    public static KnownType System_Threading_CancellationTokenSource;
    public static KnownType System_Threading_Monitor;
    public static KnownType System_Threading_Mutex;
    public static KnownType System_Threading_ReaderWriterLock;
    public static KnownType System_Threading_ReaderWriterLockSlim;
    public static KnownType System_Threading_SpinLock;
    public static KnownType System_Threading_Tasks_Task;
    public static KnownType System_Threading_Tasks_Task_T;
    public static KnownType System_Threading_Tasks_TaskFactory;
    public static KnownType System_Threading_Tasks_ValueTask;
    public static KnownType System_Threading_Tasks_ValueTask_TResult;
    public static KnownType System_Threading_Thread;
    public static KnownType System_Threading_WaitHandle;
    public static KnownType System_ThreadStaticAttribute;
    public static KnownType System_TimeOnly;
    public static KnownType System_TimeSpan;
    public static KnownType System_Type;
    public static KnownType System_UInt16;
    public static KnownType System_UInt32;
    public static KnownType System_UInt64;
    public static KnownType System_UIntPtr;
    public static KnownType System_Uri;
    public static KnownType System_ValueTuple;
    public static KnownType System_ValueType;
    public static KnownType System_Web_HttpApplication;
    public static KnownType System_Web_HttpCookie;
    public static KnownType System_Web_HttpContext;
    public static KnownType System_Web_HttpResponse;
    public static KnownType System_Web_HttpResponseBase;
    public static KnownType System_Web_Http_ApiController;
    public static KnownType System_Web_Http_Cors_EnableCorsAttribute;
    public static KnownType System_Web_Mvc_Controller;
    public static KnownType System_Web_Mvc_HttpPostAttribute;
    public static KnownType System_Web_Mvc_NonActionAttribute;
    public static KnownType System_Web_Mvc_RouteAttribute;
    public static KnownType System_Web_Mvc_Routing_IRouteInfoProvider;
    public static KnownType System_Web_Mvc_RoutePrefixAttribute;
    public static KnownType System_Web_Mvc_ValidateInputAttribute;
    public static KnownType System_Web_Script_Serialization_JavaScriptSerializer;
    public static KnownType System_Web_Script_Serialization_JavaScriptTypeResolver;
    public static KnownType System_Web_Script_Serialization_SimpleTypeResolver;
    public static KnownType System_Web_UI_LosFormatter;
    public static KnownType System_Windows_DependencyObject;
    public static KnownType System_Windows_Forms_Application;
    public static KnownType System_Windows_Forms_IContainerControl;
    public static KnownType System_Windows_Markup_ConstructorArgumentAttribute;
    public static KnownType System_Windows_Markup_XmlnsPrefixAttribute;
    public static KnownType System_Windows_Markup_XmlnsDefinitionAttribute;
    public static KnownType System_Windows_Markup_XmlnsCompatibleWithAttribute;
    public static KnownType System_Xml_Resolvers_XmlPreloadedResolver;
    public static KnownType System_Xml_Serialization_XmlElementAttribute;
    public static KnownType System_Xml_XmlDocument;
    public static KnownType System_Xml_XmlDataDocument;
    public static KnownType System_Xml_XmlNode;
    public static KnownType System_Xml_XPath_XPathDocument;
    public static KnownType System_Xml_XmlReader;
    public static KnownType System_Xml_XmlReaderSettings;
    public static KnownType System_Xml_XmlUrlResolver;
    public static KnownType System_Xml_XmlTextReader;
    public static KnownType System_Xml_XmlWriter;
    public static KnownType Void;
    public static KnownType NSubstitute_SubstituteExtensions;
    public static KnownType NSubstitute_Received;
    public static KnownType NSubstitute_ReceivedExtensions_ReceivedExtensions;
    public static ImmutableArray`1<KnownType> SystemActionVariants;
    public static ImmutableArray`1<KnownType> SystemFuncVariants;
    public static ImmutableArray`1<KnownType> SystemTasks;
    public static KnownType System_Resources_ResourceManager;
    public static KnownType TimeZoneConverter_TZConvert;
    public static KnownType UnityEditor_AssetModificationProcessor;
    public static KnownType UnityEditor_AssetPostprocessor;
    public static KnownType UnityEngine_MonoBehaviour;
    public static KnownType UnityEngine_ScriptableObject;
    public static KnownType Xunit_Assert;
    public static KnownType Xunit_Sdk_AssertException;
    public static KnownType Xunit_FactAttribute;
    public static KnownType Xunit_Sdk_XunitException;
    public static KnownType Xunit_TheoryAttribute;
    public static KnownType LegacyXunit_TheoryAttribute;
    public static ImmutableArray`1<KnownType> CallerInfoAttributes;
    public static ImmutableArray`1<KnownType> DatabaseBaseQueryTypes;
    public static ImmutableArray`1<KnownType> FloatingPointNumbers;
    public static ImmutableArray`1<KnownType> IntegralNumbers;
    public static ImmutableArray`1<KnownType> IntegralNumbersIncludingNative;
    public static ImmutableArray`1<KnownType> NonIntegralNumbers;
    public static ImmutableArray`1<KnownType> PointerTypes;
    public static ImmutableArray`1<KnownType> UnsignedIntegers;
    public static ImmutableArray`1<KnownType> RouteAttributes;
    private IList`1<string> namespaceParts;
    private String[] genericParameters;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    public string TypeName { get; }
    public string FullName { get; }
    public bool IsArray { get; public set; }
    public IReadOnlyList`1<string> GenericParameters { get; }
    public string MetadataName { get; }
    internal string DebuggerDisplay { get; }
    public KnownType(string fullName, String[] genericParameters);
    private static KnownType();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsArray(bool value);
    public IReadOnlyList`1<string> get_GenericParameters();
    public string get_MetadataName();
    internal string get_DebuggerDisplay();
    public bool Matches(ITypeSymbol symbol);
    private bool IsMatch(ITypeSymbol symbol);
    private bool GenericParametersMatch(ISymbol symbol);
    private bool NamespaceMatches(ISymbol symbol);
}
public enum SonarAnalyzer.Helpers.LastJoiningWord : Enum {
    public int value__;
    public static LastJoiningWord And;
    public static LastJoiningWord Or;
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.LocationHelper : object {
    [ExtensionAttribute]
public static Location CreateLocation(SyntaxToken from, SyntaxToken to);
    [ExtensionAttribute]
public static Location CreateLocation(SyntaxNode from, SyntaxNode to);
    [ExtensionAttribute]
public static Location CreateLocation(SyntaxNode from, SyntaxToken to);
    [ExtensionAttribute]
public static Location CreateLocation(SyntaxToken from, SyntaxNode to);
}
public class SonarAnalyzer.Helpers.MemberDescriptor : object {
    [CompilerGeneratedAttribute]
private KnownType <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal KnownType ContainingType { get; }
    internal string Name { get; }
    internal MemberDescriptor(KnownType containingType, string name);
    [CompilerGeneratedAttribute]
internal KnownType get_ContainingType();
    [CompilerGeneratedAttribute]
internal string get_Name();
    public virtual string ToString();
    public bool IsMatch(string memberName, ITypeSymbol containingType, StringComparison nameComparison);
    public bool IsMatch(string memberName, Lazy`1<TSymbolType> memberSymbol, StringComparison nameComparison);
    public static bool MatchesAny(string memberName, Lazy`1<TSymbolType> memberSymbol, bool checkOverriddenMethods, StringComparison nameComparison, MemberDescriptor[] members);
    private static bool HasSameName(string name1, string name2, StringComparison comparison);
    private bool HasSameContainingType(TSymbolType memberSymbol, bool checkOverriddenMethods);
}
public enum SonarAnalyzer.Helpers.MemberKind : Enum {
    public int value__;
    public static MemberKind Method;
    public static MemberKind Constructor;
    public static MemberKind Indexer;
    public static MemberKind Attribute;
}
public static class SonarAnalyzer.Helpers.MessageTemplatesParser : object {
    private static string NamePattern;
    private static string PlaceholderPattern;
    private static string AlignmentPattern;
    private static string FormatPattern;
    private static string HolePattern;
    private static string TextPattern;
    private static string TemplatePattern;
    private static Regex TemplateRegex;
    private static MessageTemplatesParser();
    public static ParseResult Parse(string template);
    public static ParseResult Parse(string template, Regex regex);
}
public class SonarAnalyzer.Helpers.MethodDeclarationContext : BaseContext {
    private Compilation compilation;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodSymbol>k__BackingField;
    public IMethodSymbol MethodSymbol { get; }
    public MethodDeclarationContext(IMethodSymbol methodSymbol, Compilation compilation);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodSymbol();
    public SemanticModel GetSemanticModel(SyntaxNode syntaxNode);
}
internal abstract class SonarAnalyzer.Helpers.MethodParameterLookupBase`1 : object {
    private SeparatedSyntaxList`1<TArgumentSyntax> argumentList;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <MethodSymbolOrCandidates>k__BackingField;
    public IMethodSymbol MethodSymbol { get; }
    private ImmutableArray`1<IMethodSymbol> MethodSymbolOrCandidates { get; }
    protected MethodParameterLookupBase`1(SeparatedSyntaxList`1<TArgumentSyntax> argumentList, Nullable`1<SymbolInfo> methodSymbolInfo);
    protected MethodParameterLookupBase`1(SeparatedSyntaxList`1<TArgumentSyntax> argumentList, IMethodSymbol methodSymbol);
    private MethodParameterLookupBase`1(SeparatedSyntaxList`1<TArgumentSyntax> argumentList, IMethodSymbol methodSymbol, IEnumerable`1<IMethodSymbol> methodSymbolOrCandidates);
    protected abstract virtual Nullable`1<SyntaxToken> GetNameColonIdentifier(TArgumentSyntax argument);
    protected abstract virtual Nullable`1<SyntaxToken> GetNameEqualsIdentifier(TArgumentSyntax argument);
    protected abstract virtual SyntaxNode Expression(TArgumentSyntax argument);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_MethodSymbol();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> get_MethodSymbolOrCandidates();
    public sealed virtual bool TryGetSymbol(SyntaxNode argument, IParameterSymbol& parameter);
    private bool TryGetSymbol(SyntaxNode argument, IMethodSymbol methodSymbol, IParameterSymbol& parameter);
    public sealed virtual bool TryGetSyntax(IParameterSymbol parameter, ImmutableArray`1& expressions);
    public sealed virtual bool TryGetSyntax(string parameterName, ImmutableArray`1& expressions);
    public sealed virtual bool TryGetNonParamsSyntax(IParameterSymbol parameter, SyntaxNode& expression);
    internal IEnumerable`1<NodeAndSymbol`2<TArgumentSyntax, IParameterSymbol>> GetAllArgumentParameterMappings();
    [IteratorStateMachineAttribute("SonarAnalyzer.Helpers.MethodParameterLookupBase`1/<GetAllArgumentParameterMappings>d__19")]
private IEnumerable`1<NodeAndSymbol`2<TArgumentSyntax, IParameterSymbol>> GetAllArgumentParameterMappings(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static bool <TryGetSyntax>g__AllArgumentsAreTheSame|16_1(ImmutableArray`1<ImmutableArray`1<SyntaxNode>> candidateArgumentLists);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.MethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool Is(IMethodSymbol methodSymbol, KnownType knownType, string name);
    [ExtensionAttribute]
public static bool IsAny(IMethodSymbol methodSymbol, KnownType knownType, String[] names);
    [ExtensionAttribute]
public static bool IsImplementingInterfaceMember(IMethodSymbol methodSymbol, KnownType knownInterfaceType, string name);
    [ExtensionAttribute]
public static ComparisonKind ComparisonKind(IMethodSymbol method);
    private static ComparisonKind ComparisonKind(string method);
}
public static class SonarAnalyzer.Helpers.NamingHelper : object {
    internal static string MaxTwoLongIdPattern;
    internal static string PascalCasingInternalPattern;
    internal static string CamelCasingInternalPattern;
    internal static string PascalCasingPattern;
    internal static string CamelCasingPattern;
    internal static string CamelCasingPatternWithOptionalPrefixes;
    internal static bool IsRegexMatch(string name, string pattern);
}
public enum SonarAnalyzer.Helpers.NetFrameworkVersion : Enum {
    public int value__;
    public static NetFrameworkVersion Unknown;
    public static NetFrameworkVersion Probably35;
    public static NetFrameworkVersion Between4And451;
    public static NetFrameworkVersion After452;
}
public class SonarAnalyzer.Helpers.NetFrameworkVersionProvider : object {
    public sealed virtual NetFrameworkVersion GetDotNetFrameworkVersion(Compilation compilation);
}
public class SonarAnalyzer.Helpers.ObjectCreationContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private Lazy`1<IMethodSymbol> <InvokedConstructorSymbol>k__BackingField;
    public Lazy`1<IMethodSymbol> InvokedConstructorSymbol { get; }
    public ObjectCreationContext(SonarSyntaxNodeReportingContext context);
    [CompilerGeneratedAttribute]
public Lazy`1<IMethodSymbol> get_InvokedConstructorSymbol();
}
internal static class SonarAnalyzer.Helpers.ParameterLoader : object {
    internal static void SetParameterValues(ParametrizedDiagnosticAnalyzer parameteredAnalyzer, SonarLintXmlReader sonarLintXml);
    private static bool TryConvertToParameterType(string parameter, PropertyType type, Object& result);
}
internal class SonarAnalyzer.Helpers.ProjectConfig : object {
    public static ProjectConfig Empty;
    [CompilerGeneratedAttribute]
private string <AnalysisConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilesToAnalyzePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    public string AnalysisConfigPath { get; public set; }
    public string ProjectPath { get; public set; }
    public string FilesToAnalyzePath { get; public set; }
    public string OutPath { get; public set; }
    public string ProjectType { get; public set; }
    public string TargetFramework { get; public set; }
    public ProjectConfig(XDocument document);
    private ProjectConfig(string projectType);
    private static ProjectConfig();
    [CompilerGeneratedAttribute]
public string get_AnalysisConfigPath();
    [CompilerGeneratedAttribute]
public void set_AnalysisConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_FilesToAnalyzePath();
    [CompilerGeneratedAttribute]
public void set_FilesToAnalyzePath(string value);
    [CompilerGeneratedAttribute]
public string get_OutPath();
    [CompilerGeneratedAttribute]
public void set_OutPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectType();
    [CompilerGeneratedAttribute]
public void set_ProjectType(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
internal static string <.ctor>g__Read|25_0(string name, <>c__DisplayClass25_0& , <>c__DisplayClass25_1& );
}
public class SonarAnalyzer.Helpers.ProjectConfigReader : object {
    public static ProjectConfigReader Empty;
    private ProjectConfig projectConfig;
    private Lazy`1<ProjectType> projectType;
    private Lazy`1<FilesToAnalyzeProvider> filesToAnalyze;
    private Lazy`1<AnalysisConfigReader> analysisConfig;
    public bool IsScannerRun { get; }
    public string AnalysisConfigPath { get; }
    public string FilesToAnalyzePath { get; }
    public string OutPath { get; }
    public string ProjectPath { get; }
    public string TargetFramework { get; }
    public ProjectType ProjectType { get; }
    public FilesToAnalyzeProvider FilesToAnalyze { get; }
    public AnalysisConfigReader AnalysisConfig { get; }
    public ProjectConfigReader(SourceText sonarProjectConfig);
    private static ProjectConfigReader();
    public bool get_IsScannerRun();
    public string get_AnalysisConfigPath();
    public string get_FilesToAnalyzePath();
    public string get_OutPath();
    public string get_ProjectPath();
    public string get_TargetFramework();
    public ProjectType get_ProjectType();
    public FilesToAnalyzeProvider get_FilesToAnalyze();
    public AnalysisConfigReader get_AnalysisConfig();
    private static ProjectConfig ReadContent(SourceText sonarProjectConfig);
    private ProjectType ParseProjectType();
}
public enum SonarAnalyzer.Helpers.ProjectType : Enum {
    public int value__;
    public static ProjectType Unknown;
    public static ProjectType Product;
    public static ProjectType Test;
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.ProjectTypeHelper : object {
    public static ISet`1<string> TestAssemblyNames;
    private static ConditionalWeakTable`2<Compilation, IsTestWrapper> Cache;
    private static ProjectTypeHelper();
    [ExtensionAttribute]
public static bool IsTest(Compilation compilation);
}
public class SonarAnalyzer.Helpers.PropertyAccessContext : SyntaxBaseContext {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IPropertySymbol> <PropertySymbol>k__BackingField;
    public string PropertyName { get; }
    public Lazy`1<IPropertySymbol> PropertySymbol { get; }
    public PropertyAccessContext(SonarSyntaxNodeReportingContext context, string propertyName);
    public PropertyAccessContext(SyntaxNode node, SemanticModel semanticModel, string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Lazy`1<IPropertySymbol> get_PropertySymbol();
}
public static class SonarAnalyzer.Helpers.RefKindEx : object {
    public static RefKind In;
    public static RefKind RefReadOnlyParameter;
}
public abstract class SonarAnalyzer.Helpers.RemovableDeclarationCollectorBase`3 : object {
    private Compilation compilation;
    private INamedTypeSymbol namedType;
    private IEnumerable`1<NodeAndModel`1<TOwnerOfSubnodes>> typeDeclarations;
    public IEnumerable`1<NodeAndModel`1<TOwnerOfSubnodes>> TypeDeclarations { get; }
    protected RemovableDeclarationCollectorBase`3(INamedTypeSymbol namedType, Compilation compilation);
    public abstract virtual IEnumerable`1<NodeSymbolAndModel`2<SyntaxNode, ISymbol>> GetRemovableFieldLikeDeclarations(ISet`1<TSyntaxKind> kinds, Accessibility maxAccessibility);
    internal abstract virtual TOwnerOfSubnodes GetOwnerOfSubnodes(TDeclaration node);
    protected abstract virtual IEnumerable`1<SyntaxNode> SelectMatchingDeclarations(NodeAndModel`1<TOwnerOfSubnodes> container, ISet`1<TSyntaxKind> kinds);
    public IEnumerable`1<NodeAndModel`1<TOwnerOfSubnodes>> get_TypeDeclarations();
    public IEnumerable`1<NodeSymbolAndModel`2<SyntaxNode, ISymbol>> GetRemovableDeclarations(ISet`1<TSyntaxKind> kinds, Accessibility maxAccessibility);
    public static bool IsRemovable(IMethodSymbol methodSymbol, Accessibility maxAccessibility);
    protected static bool IsRemovable(ISymbol symbol, Accessibility maxAccessibility);
    protected static NodeSymbolAndModel`2<SyntaxNode, ISymbol> SelectNodeTuple(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private NodeAndModel`1<TOwnerOfSubnodes> <get_TypeDeclarations>b__7_1(TDeclaration x);
}
internal class SonarAnalyzer.Helpers.ReportingContext : object {
    private Action`1<Diagnostic> roslynReportDiagnostic;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private Diagnostic <Diagnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    public SyntaxTree SyntaxTree { get; }
    public Diagnostic Diagnostic { get; }
    public Compilation Compilation { get; }
    public ReportingContext(SonarSyntaxNodeReportingContext context, Diagnostic diagnostic);
    public ReportingContext(SonarSyntaxTreeReportingContext context, Diagnostic diagnostic);
    public ReportingContext(SonarCompilationReportingContext context, Diagnostic diagnostic);
    public ReportingContext(SonarSymbolReportingContext context, Diagnostic diagnostic);
    public ReportingContext(SonarCodeBlockReportingContext context, Diagnostic diagnostic);
    public ReportingContext(SonarSemanticModelReportingContext context, Diagnostic diagnostic);
    private ReportingContext(Diagnostic diagnostic, Action`1<Diagnostic> roslynReportDiagnostic, Compilation compilation, SyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public sealed virtual SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public sealed virtual Diagnostic get_Diagnostic();
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public sealed virtual void ReportDiagnostic(Diagnostic diagnostic);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static bool IsExtensionMethod(SemanticModel semanticModel, SyntaxNode expression);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.SemanticModelHelper : object {
    [ExtensionAttribute]
public static SemanticModel GetSemanticModelOrDefault(SyntaxTree syntaxTree, SemanticModel model);
}
public abstract class SonarAnalyzer.Helpers.SonarCodeFix : CodeFixProvider {
    [AsyncStateMachineAttribute("SonarAnalyzer.Helpers.SonarCodeFix/<RegisterCodeFixesAsync>d__0")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
[XmlRootAttribute]
public class SonarAnalyzer.Helpers.SonarLintXml : object {
    public static SonarLintXml Empty;
    [CompilerGeneratedAttribute]
private List`1<SonarLintXmlKeyValuePair> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SonarLintXmlRule> <Rules>k__BackingField;
    [XmlArrayAttribute("Settings")]
[XmlArrayItemAttribute("Setting")]
public List`1<SonarLintXmlKeyValuePair> Settings { get; public set; }
    [XmlArrayAttribute("Rules")]
[XmlArrayItemAttribute("Rule")]
public List`1<SonarLintXmlRule> Rules { get; public set; }
    private static SonarLintXml();
    [CompilerGeneratedAttribute]
public List`1<SonarLintXmlKeyValuePair> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(List`1<SonarLintXmlKeyValuePair> value);
    [CompilerGeneratedAttribute]
public List`1<SonarLintXmlRule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(List`1<SonarLintXmlRule> value);
}
public class SonarAnalyzer.Helpers.SonarLintXmlKeyValuePair : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
public class SonarAnalyzer.Helpers.SonarLintXmlReader : object {
    public static SonarLintXmlReader Empty;
    private bool ignoreHeaderCommentsCS;
    private bool ignoreHeaderCommentsVB;
    private bool analyzeGeneratedCodeCS;
    private bool analyzeGeneratedCodeVB;
    private bool analyzeRazorCodeCS;
    [CompilerGeneratedAttribute]
private String[] <Exclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Inclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <GlobalExclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TestExclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TestInclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <GlobalTestExclusions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SonarLintXmlRule> <ParametrizedRules>k__BackingField;
    public String[] Exclusions { get; }
    public String[] Inclusions { get; }
    public String[] GlobalExclusions { get; }
    public String[] TestExclusions { get; }
    public String[] TestInclusions { get; }
    public String[] GlobalTestExclusions { get; }
    public List`1<SonarLintXmlRule> ParametrizedRules { get; }
    public SonarLintXmlReader(SourceText sonarLintXmlText);
    private static SonarLintXmlReader();
    [CompilerGeneratedAttribute]
public String[] get_Exclusions();
    [CompilerGeneratedAttribute]
public String[] get_Inclusions();
    [CompilerGeneratedAttribute]
public String[] get_GlobalExclusions();
    [CompilerGeneratedAttribute]
public String[] get_TestExclusions();
    [CompilerGeneratedAttribute]
public String[] get_TestInclusions();
    [CompilerGeneratedAttribute]
public String[] get_GlobalTestExclusions();
    [CompilerGeneratedAttribute]
public List`1<SonarLintXmlRule> get_ParametrizedRules();
    public bool IgnoreHeaderComments(string language);
    public bool AnalyzeGeneratedCode(string language);
    public bool AnalyzeRazorCode(string language);
    public bool IsFileIncluded(string filePath, bool isTestProject);
    private static bool IsFileIncluded(String[] inclusions, String[] exclusions, String[] globalExclusions, string filePath);
    private static bool IsIncluded(String[] inclusions, string filePath);
    private static bool IsExcluded(String[] exclusions, string filePath);
    private static SonarLintXml ParseContent(SourceText sonarLintXml);
    [CompilerGeneratedAttribute]
internal static String[] <.ctor>g__ReadArray|27_3(string key, <>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__ReadBoolean|27_4(string key, bool defaultValue, <>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static List`1<SonarLintXmlRule> <.ctor>g__ReadRuleParameters|27_5(<>c__DisplayClass27_0& );
}
public class SonarAnalyzer.Helpers.SonarLintXmlRule : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SonarLintXmlKeyValuePair> <Parameters>k__BackingField;
    [XmlElementAttribute("Key")]
public string Key { get; public set; }
    [XmlArrayAttribute("Parameters")]
[XmlArrayItemAttribute("Parameter")]
public List`1<SonarLintXmlKeyValuePair> Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public List`1<SonarLintXmlKeyValuePair> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(List`1<SonarLintXmlKeyValuePair> value);
}
public abstract class SonarAnalyzer.Helpers.StringInterpolationConstantValueResolver`5 : object {
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual IEnumerable`1<TInterpolatedStringContentSyntax> Contents(TInterpolatedStringExpressionSyntax interpolatedStringExpression);
    protected abstract virtual SyntaxToken TextToken(TInterpolatedStringTextSyntax interpolatedStringText);
    public bool TryGetInterpolatedTextValue(TInterpolatedStringExpressionSyntax interpolatedStringExpression, SemanticModel semanticModel, String& interpolatedValue);
}
public class SonarAnalyzer.Helpers.SymbolUsage : object {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<SyntaxNode> <Readings>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<SyntaxNode> <Writings>k__BackingField;
    public ISymbol Symbol { get; }
    public SyntaxNode Declaration { get; public set; }
    public SyntaxNode Initializer { get; public set; }
    public HashSet`1<SyntaxNode> Readings { get; }
    public HashSet`1<SyntaxNode> Writings { get; }
    public SymbolUsage(ISymbol symbol);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Declaration();
    [CompilerGeneratedAttribute]
public void set_Declaration(SyntaxNode value);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Initializer();
    [CompilerGeneratedAttribute]
public void set_Initializer(SyntaxNode value);
    [CompilerGeneratedAttribute]
public HashSet`1<SyntaxNode> get_Readings();
    [CompilerGeneratedAttribute]
public HashSet`1<SyntaxNode> get_Writings();
}
public class SonarAnalyzer.Helpers.SyntaxBaseContext : BaseContext {
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <PrimaryLocation>k__BackingField;
    public SemanticModel SemanticModel { get; }
    public SyntaxNode Node { get; }
    public Location PrimaryLocation { get; public set; }
    public SyntaxBaseContext(SonarSyntaxNodeReportingContext context);
    public SyntaxBaseContext(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public Location get_PrimaryLocation();
    [CompilerGeneratedAttribute]
public void set_PrimaryLocation(Location value);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.SyntaxHelper : object {
    [ExtensionAttribute]
public static IEnumerable`1<int> GetLineNumbers(SyntaxToken token, bool isZeroBasedCount);
    [ExtensionAttribute]
public static IEnumerable`1<int> GetLineNumbers(SyntaxTrivia trivia, bool isZeroBasedCount);
    [ExtensionAttribute]
public static IEnumerable`1<int> GetLineNumbers(FileLinePositionSpan lineSpan, bool isZeroBasedCount);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static SemanticModel EnsureCorrectSemanticModelOrDefault(SyntaxNode node, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool ToStringContains(SyntaxNode node, string s);
    [ExtensionAttribute]
public static bool ToStringContains(SyntaxNode node, string s, StringComparison comparison);
    [ExtensionAttribute]
public static bool ToStringContainsEitherOr(SyntaxNode node, string a, string b);
    [ExtensionAttribute]
public static string GetMappedFilePathFromRoot(SyntaxNode root);
    [ExtensionAttribute]
public static TSyntaxKind Kind(SyntaxNode node);
    [ExtensionAttribute]
public static SecondaryLocation ToSecondaryLocation(SyntaxNode node, string message);
}
public abstract class SonarAnalyzer.Helpers.SyntaxTrackerBase`2 : TrackerBase`2<TSyntaxKind, TContext> {
    protected TSyntaxKind[] TrackedSyntaxKinds { get; }
    protected abstract virtual TSyntaxKind[] get_TrackedSyntaxKinds();
    protected abstract virtual TContext CreateContext(SonarSyntaxNodeReportingContext context);
    public void Track(TrackerInput input, Condition[] conditions);
    public void Track(TrackerInput input, String[] diagnosticMessageArgs, Condition[] conditions);
    public Condition<TSyntaxKind, TContext> ExceptWhen(Condition<TSyntaxKind, TContext> condition);
    public Condition<TSyntaxKind, TContext> And(Condition<TSyntaxKind, TContext> condition1, Condition<TSyntaxKind, TContext> condition2);
    public Condition<TSyntaxKind, TContext> Or(Condition<TSyntaxKind, TContext> condition1, Condition<TSyntaxKind, TContext> condition2);
    public Condition<TSyntaxKind, TContext> Or(Condition<TSyntaxKind, TContext> condition1, Condition<TSyntaxKind, TContext> condition2, Condition<TSyntaxKind, TContext> condition3);
}
public abstract class SonarAnalyzer.Helpers.TrackerBase`2 : object {
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
}
public class SonarAnalyzer.Helpers.TrackerInput : object {
    private IAnalyzerConfiguration configuration;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private SonarAnalysisContext <Context>k__BackingField;
    public DiagnosticDescriptor Rule { get; }
    public SonarAnalysisContext Context { get; }
    public TrackerInput(SonarAnalysisContext context, IAnalyzerConfiguration configuration, DiagnosticDescriptor rule);
    [CompilerGeneratedAttribute]
public DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
public SonarAnalysisContext get_Context();
    public bool IsEnabled(AnalyzerOptions options);
}
public abstract class SonarAnalyzer.Helpers.Trackers.ArgumentTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, ArgumentContext> {
    protected abstract virtual Nullable`1<RefKind> ArgumentRefKind(SyntaxNode argumentNode);
    protected abstract virtual IReadOnlyCollection`1<SyntaxNode> ArgumentList(SyntaxNode argumentNode);
    protected abstract virtual Nullable`1<int> Position(SyntaxNode argumentNode);
    protected abstract virtual bool InvocationMatchesMemberKind(SyntaxNode invokedExpression, MemberKind memberKind);
    protected abstract virtual bool InvokedMemberMatches(SemanticModel model, SyntaxNode invokedExpression, MemberKind memberKind, Func`2<string, bool> invokedMemberNameConstraint);
    protected virtual ArgumentContext CreateContext(SonarSyntaxNodeReportingContext context);
    public Condition<TSyntaxKind, ArgumentContext> MatchArgument(ArgumentDescriptor descriptor);
    private IMethodSymbol MethodSymbol(SemanticModel model, SyntaxNode invoked);
    private bool SyntacticChecks(SemanticModel model, ArgumentDescriptor descriptor, SyntaxNode argumentNode, SyntaxNode invokedExpression);
    private bool RefKindMatches(ArgumentDescriptor descriptor, SyntaxNode argumentNode);
    private static bool ParameterMatches(IParameterSymbol parameter, Func`2<IParameterSymbol, bool> parameterConstraint, Func`2<IMethodSymbol, bool> invokedMemberConstraint);
}
public abstract class SonarAnalyzer.Helpers.Trackers.BaseTypeTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, BaseTypeContext> {
    protected abstract virtual IEnumerable`1<SyntaxNode> GetBaseTypeNodes(SyntaxNode contextNode);
    internal Condition<TSyntaxKind, BaseTypeContext> MatchSubclassesOf(KnownType[] types);
    protected virtual BaseTypeContext CreateContext(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Helpers.Trackers.ElementAccessTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, ElementAccessContext> {
    public abstract virtual Condition<TSyntaxKind, ElementAccessContext> ArgumentAtIndexEquals(int index, string value);
    public abstract virtual Condition<TSyntaxKind, ElementAccessContext> MatchSetter();
    public abstract virtual Condition<TSyntaxKind, ElementAccessContext> MatchProperty(MemberDescriptor member);
    internal Condition<TSyntaxKind, ElementAccessContext> ArgumentAtIndexIs(int index, KnownType[] types);
    internal Condition<TSyntaxKind, ElementAccessContext> MatchIndexerIn(KnownType[] types);
    protected virtual ElementAccessContext CreateContext(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Helpers.Trackers.FieldAccessTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, FieldAccessContext> {
    public abstract virtual Condition<TSyntaxKind, FieldAccessContext> WhenRead();
    public abstract virtual Condition<TSyntaxKind, FieldAccessContext> MatchSet();
    public abstract virtual Condition<TSyntaxKind, FieldAccessContext> AssignedValueIsConstant();
    protected abstract virtual bool IsIdentifierWithinMemberAccess(SyntaxNode expression);
    public Condition<TSyntaxKind, FieldAccessContext> MatchField(MemberDescriptor[] fields);
    protected virtual FieldAccessContext CreateContext(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Helpers.Trackers.InvocationTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, InvocationContext> {
    public abstract virtual Condition<TSyntaxKind, InvocationContext> ArgumentAtIndexIsStringConstant(int index);
    public abstract virtual Condition<TSyntaxKind, InvocationContext> ArgumentAtIndexIsAny(int index, String[] values);
    public abstract virtual Condition<TSyntaxKind, InvocationContext> ArgumentAtIndexIs(int index, Func`3<SyntaxNode, SemanticModel, bool> predicate);
    public abstract virtual Condition<TSyntaxKind, InvocationContext> MatchProperty(MemberDescriptor member);
    internal abstract virtual object ConstArgumentForParameter(InvocationContext context, string parameterName);
    protected abstract virtual Nullable`1<SyntaxToken> ExpectedExpressionIdentifier(SyntaxNode expression);
    public Condition<TSyntaxKind, InvocationContext> MatchMethod(MemberDescriptor[] methods);
    public Condition<TSyntaxKind, InvocationContext> MethodNameIs(string methodName);
    public Condition<TSyntaxKind, InvocationContext> MethodIsStatic();
    public Condition<TSyntaxKind, InvocationContext> MethodIsExtension();
    public Condition<TSyntaxKind, InvocationContext> MethodHasParameters(int count);
    public Condition<TSyntaxKind, InvocationContext> IsInvalidBuilderInitialization(BuilderPatternCondition`2<TSyntaxKind, TInvocationSyntax> condition);
    internal Condition<TSyntaxKind, InvocationContext> MethodReturnTypeIs(KnownType returnType);
    internal Condition<TSyntaxKind, InvocationContext> ArgumentIsBoolConstant(string parameterName, bool expectedValue);
    internal Condition<TSyntaxKind, InvocationContext> IsIHeadersDictionary();
    protected virtual InvocationContext CreateContext(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Helpers.Trackers.MethodDeclarationTracker`1 : TrackerBase`2<TSyntaxKind, MethodDeclarationContext> {
    public abstract virtual Condition<TSyntaxKind, MethodDeclarationContext> ParameterAtIndexIsUsed(int index);
    protected abstract virtual Nullable`1<SyntaxToken> GetMethodIdentifier(SyntaxNode methodDeclaration);
    public void Track(TrackerInput input, Condition[] conditions);
    public Condition<TSyntaxKind, MethodDeclarationContext> MatchMethodName(String[] methodNames);
    public Condition<TSyntaxKind, MethodDeclarationContext> IsOrdinaryMethod();
    public Condition<TSyntaxKind, MethodDeclarationContext> IsMainMethod();
    internal Condition<TSyntaxKind, MethodDeclarationContext> AnyParameterIsOfType(KnownType[] types);
    internal Condition<TSyntaxKind, MethodDeclarationContext> DecoratedWithAnyAttribute(KnownType[] attributeTypes);
}
public abstract class SonarAnalyzer.Helpers.Trackers.ObjectCreationTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, ObjectCreationContext> {
    protected TSyntaxKind[] TrackedSyntaxKinds { get; }
    protected virtual TSyntaxKind[] get_TrackedSyntaxKinds();
    internal abstract virtual Condition<TSyntaxKind, ObjectCreationContext> ArgumentAtIndexIsConst(int index);
    internal abstract virtual object ConstArgumentForParameter(ObjectCreationContext context, string parameterName);
    internal Condition<TSyntaxKind, ObjectCreationContext> ArgumentIsBoolConstant(string parameterName, bool expectedValue);
    internal Condition<TSyntaxKind, ObjectCreationContext> ArgumentAtIndexIs(int index, KnownType type);
    internal Condition<TSyntaxKind, ObjectCreationContext> WhenDerivesOrImplementsAny(KnownType[] types);
    internal Condition<TSyntaxKind, ObjectCreationContext> MatchConstructor(KnownType[] types);
    internal Condition<TSyntaxKind, ObjectCreationContext> WhenDerivesFrom(KnownType baseType);
    internal Condition<TSyntaxKind, ObjectCreationContext> WhenImplements(KnownType baseType);
    protected virtual ObjectCreationContext CreateContext(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Helpers.Trackers.PropertyAccessTracker`1 : SyntaxTrackerBase`2<TSyntaxKind, PropertyAccessContext> {
    public abstract virtual object AssignedValue(PropertyAccessContext context);
    public abstract virtual Condition<TSyntaxKind, PropertyAccessContext> MatchGetter();
    public abstract virtual Condition<TSyntaxKind, PropertyAccessContext> MatchSetter();
    public abstract virtual Condition<TSyntaxKind, PropertyAccessContext> AssignedValueIsConstant();
    protected abstract virtual bool IsIdentifierWithinMemberAccess(SyntaxNode expression);
    public Condition<TSyntaxKind, PropertyAccessContext> MatchProperty(MemberDescriptor[] properties);
    public Condition<TSyntaxKind, PropertyAccessContext> MatchProperty(bool checkOverridenProperties, MemberDescriptor[] properties);
    protected virtual PropertyAccessContext CreateContext(SonarSyntaxNodeReportingContext context);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.Helpers.UnitTestHelper : object {
    public static ImmutableArray`1<KnownType> KnownTestMethodAttributesOfMSTest;
    public static ImmutableArray`1<KnownType> KnownTestMethodAttributesOfNUnit;
    public static ImmutableArray`1<KnownType> KnownTestMethodAttributesOfxUnit;
    public static ImmutableArray`1<KnownType> KnownExpectedExceptionAttributes;
    public static ImmutableArray`1<KnownType> KnownIgnoreAttributes;
    public static ImmutableArray`1<string> KnownAssertionMethodParts;
    private static ImmutableArray`1<KnownType> KnownTestMethodAttributes;
    private static ImmutableArray`1<KnownType> KnownTestClassAttributes;
    private static ImmutableArray`1<KnownType> NoExpectedResultTestMethodReturnTypes;
    private static UnitTestHelper();
    [ExtensionAttribute]
public static bool IsTestClass(INamedTypeSymbol classSymbol);
    [ExtensionAttribute]
public static bool IsTestMethod(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasExpectedExceptionAttribute(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasAssertionInAttribute(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsMsTestOrNUnitTestIgnored(IMethodSymbol method);
    [ExtensionAttribute]
public static AttributeData FindXUnitTestAttribute(IMethodSymbol method);
    [ExtensionAttribute]
public static KnownType FindFirstTestMethodType(IMethodSymbol method);
    private static bool IsAnyTestCaseAttributeWithExpectedResult(AttributeData a);
    private static bool IsTestAttributeWithExpectedResult(AttributeData a);
}
public static class SonarAnalyzer.Helpers.VbcHelper : object {
    public static Regex VbNetErrorPattern;
    private static VbcHelper();
    public static bool IsTriggeringVbcError(Diagnostic diagnostic);
    public static bool IsTextMatchingVbcErrorPattern(string text);
}
internal static class SonarAnalyzer.Helpers.VisualIndentComparer : object {
    public static bool IsSecondIndentLonger(SyntaxNode node1, SyntaxNode node2);
    internal static bool IsSecondIndentLonger(string indent1, string indent2);
    private static int GetTabCount(string text);
}
internal static class SonarAnalyzer.Helpers.WildcardPatternMatcher : object {
    private static ConcurrentDictionary`2<string, Regex> Cache;
    private static WildcardPatternMatcher();
    public static bool IsMatch(string pattern, string input, bool timeoutFallbackResult);
    private static string ToRegex(string wildcardPattern);
    private static bool IsSlash(char ch);
}
[ExtensionAttribute]
public static class SonarAnalyzer.Helpers.XmlHelper : object {
    public static XDocument ParseXDocument(string text);
    [ExtensionAttribute]
public static XAttribute GetAttributeIfBoolValueIs(XElement element, string attributeName, bool value);
    [ExtensionAttribute]
public static Location CreateLocation(XAttribute attribute, string path);
    [ExtensionAttribute]
public static Location CreateLocation(XElement element, string path);
    private static Location CreateLocation(IXmlLineInfo startPos, string path, XName name);
}
public class SonarAnalyzer.Json.JsonException : Exception {
    public JsonException(string message, LinePosition position);
    [ExcludeFromCodeCoverageAttribute]
private JsonException(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class SonarAnalyzer.Json.JsonNode : object {
    [CompilerGeneratedAttribute]
private Kind <Kind>k__BackingField;
    private List`1<JsonNode> list;
    private Dictionary`2<string, JsonNode> map;
    private object value;
    [CompilerGeneratedAttribute]
private LinePosition <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <End>k__BackingField;
    public Kind Kind { get; }
    public LinePosition Start { get; }
    public LinePosition End { get; private set; }
    public JsonNode Item { get; }
    public JsonNode Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public object Value { get; }
    public int Count { get; }
    public JsonNode(LinePosition start, LinePosition end, object value);
    public JsonNode(LinePosition start, Kind kind);
    [CompilerGeneratedAttribute]
public Kind get_Kind();
    [CompilerGeneratedAttribute]
public LinePosition get_Start();
    [CompilerGeneratedAttribute]
public LinePosition get_End();
    [CompilerGeneratedAttribute]
private void set_End(LinePosition value);
    public JsonNode get_Item(int index);
    public JsonNode get_Item(string key);
    public IEnumerable`1<string> get_Keys();
    public object get_Value();
    public int get_Count();
    public static JsonNode FromString(string json);
    public Location ToLocation(string path);
    public void UpdateEnd(LinePosition end);
    public void Add(JsonNode value);
    public void Add(string key, JsonNode value);
    public bool ContainsKey(string key);
    public bool TryGetPropertyNode(string key, JsonNode& node);
    public sealed virtual IEnumerator`1<JsonNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private InvalidOperationException InvalidKind();
    private bool NotInitializedEnd();
}
public class SonarAnalyzer.Json.JsonWalker : object {
    public virtual void Visit(JsonNode node);
    protected virtual void VisitObject(JsonNode node);
    protected virtual void VisitObject(string key, JsonNode value);
    protected virtual void VisitList(JsonNode node);
    protected virtual void VisitValue(JsonNode node);
}
public enum SonarAnalyzer.Json.Parsing.Kind : Enum {
    public int value__;
    public static Kind Unknown;
    public static Kind Object;
    public static Kind List;
    public static Kind Value;
}
internal class SonarAnalyzer.Json.Parsing.LexicalAnalyzer : object {
    private List`1<string> lines;
    private int line;
    private int column;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <LastStart>k__BackingField;
    public object Value { get; private set; }
    public LinePosition LastStart { get; private set; }
    private char CurrentChar { get; }
    private bool ReachedEndOfInput { get; }
    public LexicalAnalyzer(string source);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public LinePosition get_LastStart();
    [CompilerGeneratedAttribute]
private void set_LastStart(LinePosition value);
    private char get_CurrentChar();
    private bool get_ReachedEndOfInput();
    public LinePosition CurrentPosition(int increment);
    public Symbol NextSymbol();
    private void NextPosition(bool throwIfReachedEndOfInput);
    private void SeekToNextLine(bool throwIfReachedEndOfInput);
    private void SkipWhitespaceAndComments();
    private void ReadKeyword(string keyword);
    private string ReadStringValue();
    private object ReadNumberValue();
    [CompilerGeneratedAttribute]
private Nullable`1<char> <SkipWhitespaceAndComments>g__NextCharSameLine|20_0(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
private bool <SkipWhitespaceAndComments>g__IsSingleLineComment|20_1(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
private bool <SkipWhitespaceAndComments>g__IsMultiLineComment|20_2(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
private bool <SkipWhitespaceAndComments>g__IsEndOfMultiLineComment|20_3(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
private object <ReadNumberValue>g__BuildResult|23_0(<>c__DisplayClass23_0& );
}
internal enum SonarAnalyzer.Json.Parsing.Symbol : Enum {
    public int value__;
    public static Symbol Unknown;
    public static Symbol EndOfInput;
    public static Symbol OpenCurlyBracket;
    public static Symbol CloseCurlyBracket;
    public static Symbol OpenSquareBracket;
    public static Symbol CloseSquareBracket;
    public static Symbol Comma;
    public static Symbol Colon;
    public static Symbol Value;
}
internal class SonarAnalyzer.Json.Parsing.SyntaxAnalyzer : object {
    private LexicalAnalyzer lexer;
    private Symbol symbol;
    public SyntaxAnalyzer(string source);
    public JsonNode Parse();
    private Symbol ReadNext();
    private JsonNode ParseObject();
    private void ObjectKeyValue(JsonNode target);
    private JsonNode ParseList();
    private JsonNode ParseValue();
    private JsonException Unexpected(string expected);
}
public static class SonarAnalyzer.Protobuf.AnalyzerReportReflection : object {
    private static FileDescriptor descriptor;
    public static FileDescriptor Descriptor { get; }
    private static AnalyzerReportReflection();
    public static FileDescriptor get_Descriptor();
}
public class SonarAnalyzer.Protobuf.CopyPasteTokenInfo : object {
    private static MessageParser`1<CopyPasteTokenInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FilePathFieldNumber;
    private string filePath_;
    public static int TokenInfoFieldNumber;
    private static FieldCodec`1<TokenInfo> _repeated_tokenInfo_codec;
    private RepeatedField`1<TokenInfo> tokenInfo_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<CopyPasteTokenInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public string FilePath { get; public set; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<TokenInfo> TokenInfo { get; }
    [DebuggerNonUserCodeAttribute]
public CopyPasteTokenInfo(CopyPasteTokenInfo other);
    private static CopyPasteTokenInfo();
    public static MessageParser`1<CopyPasteTokenInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual CopyPasteTokenInfo Clone();
    public string get_FilePath();
    public void set_FilePath(string value);
    public RepeatedField`1<TokenInfo> get_TokenInfo();
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(CopyPasteTokenInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CopyPasteTokenInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public class SonarAnalyzer.Protobuf.FileMetadataInfo : object {
    private static MessageParser`1<FileMetadataInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FilePathFieldNumber;
    private string filePath_;
    public static int IsGeneratedFieldNumber;
    private bool isGenerated_;
    public static int EncodingFieldNumber;
    private string encoding_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<FileMetadataInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public string FilePath { get; public set; }
    [DebuggerNonUserCodeAttribute]
public bool IsGenerated { get; public set; }
    [DebuggerNonUserCodeAttribute]
public string Encoding { get; public set; }
    [DebuggerNonUserCodeAttribute]
public FileMetadataInfo(FileMetadataInfo other);
    private static FileMetadataInfo();
    public static MessageParser`1<FileMetadataInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual FileMetadataInfo Clone();
    public string get_FilePath();
    public void set_FilePath(string value);
    public bool get_IsGenerated();
    public void set_IsGenerated(bool value);
    public string get_Encoding();
    public void set_Encoding(string value);
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(FileMetadataInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(FileMetadataInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public class SonarAnalyzer.Protobuf.LogInfo : object {
    private static MessageParser`1<LogInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int SeverityFieldNumber;
    private LogSeverity severity_;
    public static int TextFieldNumber;
    private string text_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<LogInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public LogSeverity Severity { get; public set; }
    [DebuggerNonUserCodeAttribute]
public string Text { get; public set; }
    [DebuggerNonUserCodeAttribute]
public LogInfo(LogInfo other);
    private static LogInfo();
    public static MessageParser`1<LogInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual LogInfo Clone();
    public LogSeverity get_Severity();
    public void set_Severity(LogSeverity value);
    public string get_Text();
    public void set_Text(string value);
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(LogInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(LogInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public enum SonarAnalyzer.Protobuf.LogSeverity : Enum {
    public int value__;
    [OriginalNameAttribute("UNKNOWN_SEVERITY")]
public static LogSeverity UnknownSeverity;
    [OriginalNameAttribute("DEBUG")]
public static LogSeverity Debug;
    [OriginalNameAttribute("INFO")]
public static LogSeverity Info;
    [OriginalNameAttribute("WARNING")]
public static LogSeverity Warning;
}
public class SonarAnalyzer.Protobuf.MetricsInfo : object {
    private static MessageParser`1<MetricsInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FilePathFieldNumber;
    private string filePath_;
    public static int ClassCountFieldNumber;
    private int classCount_;
    public static int StatementCountFieldNumber;
    private int statementCount_;
    public static int FunctionCountFieldNumber;
    private int functionCount_;
    public static int ComplexityFieldNumber;
    private int complexity_;
    public static int NoSonarCommentFieldNumber;
    private static FieldCodec`1<int> _repeated_noSonarComment_codec;
    private RepeatedField`1<int> noSonarComment_;
    public static int NonBlankCommentFieldNumber;
    private static FieldCodec`1<int> _repeated_nonBlankComment_codec;
    private RepeatedField`1<int> nonBlankComment_;
    public static int CodeLineFieldNumber;
    private static FieldCodec`1<int> _repeated_codeLine_codec;
    private RepeatedField`1<int> codeLine_;
    public static int CognitiveComplexityFieldNumber;
    private int cognitiveComplexity_;
    public static int ExecutableLinesFieldNumber;
    private static FieldCodec`1<int> _repeated_executableLines_codec;
    private RepeatedField`1<int> executableLines_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<MetricsInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public string FilePath { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int ClassCount { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int StatementCount { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int FunctionCount { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int Complexity { get; public set; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<int> NoSonarComment { get; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<int> NonBlankComment { get; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<int> CodeLine { get; }
    [DebuggerNonUserCodeAttribute]
public int CognitiveComplexity { get; public set; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<int> ExecutableLines { get; }
    [DebuggerNonUserCodeAttribute]
public MetricsInfo(MetricsInfo other);
    private static MetricsInfo();
    public static MessageParser`1<MetricsInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual MetricsInfo Clone();
    public string get_FilePath();
    public void set_FilePath(string value);
    public int get_ClassCount();
    public void set_ClassCount(int value);
    public int get_StatementCount();
    public void set_StatementCount(int value);
    public int get_FunctionCount();
    public void set_FunctionCount(int value);
    public int get_Complexity();
    public void set_Complexity(int value);
    public RepeatedField`1<int> get_NoSonarComment();
    public RepeatedField`1<int> get_NonBlankComment();
    public RepeatedField`1<int> get_CodeLine();
    public int get_CognitiveComplexity();
    public void set_CognitiveComplexity(int value);
    public RepeatedField`1<int> get_ExecutableLines();
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(MetricsInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(MetricsInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public class SonarAnalyzer.Protobuf.SymbolReferenceInfo : object {
    private static MessageParser`1<SymbolReferenceInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FilePathFieldNumber;
    private string filePath_;
    public static int ReferenceFieldNumber;
    private static FieldCodec`1<SymbolReference> _repeated_reference_codec;
    private RepeatedField`1<SymbolReference> reference_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<SymbolReferenceInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public string FilePath { get; public set; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<SymbolReference> Reference { get; }
    [DebuggerNonUserCodeAttribute]
public SymbolReferenceInfo(SymbolReferenceInfo other);
    private static SymbolReferenceInfo();
    public static MessageParser`1<SymbolReferenceInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual SymbolReferenceInfo Clone();
    public string get_FilePath();
    public void set_FilePath(string value);
    public RepeatedField`1<SymbolReference> get_Reference();
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(SymbolReferenceInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(SymbolReferenceInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public class SonarAnalyzer.Protobuf.TextRange : object {
    private static MessageParser`1<TextRange> _parser;
    private UnknownFieldSet _unknownFields;
    public static int StartLineFieldNumber;
    private int startLine_;
    public static int EndLineFieldNumber;
    private int endLine_;
    public static int StartOffsetFieldNumber;
    private int startOffset_;
    public static int EndOffsetFieldNumber;
    private int endOffset_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<TextRange> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public int StartLine { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int EndLine { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int StartOffset { get; public set; }
    [DebuggerNonUserCodeAttribute]
public int EndOffset { get; public set; }
    [DebuggerNonUserCodeAttribute]
public TextRange(TextRange other);
    private static TextRange();
    public static MessageParser`1<TextRange> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual TextRange Clone();
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_StartOffset();
    public void set_StartOffset(int value);
    public int get_EndOffset();
    public void set_EndOffset(int value);
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(TextRange other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(TextRange other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
public enum SonarAnalyzer.Protobuf.TokenType : Enum {
    public int value__;
    [OriginalNameAttribute("UNKNOWN_TOKENTYPE")]
public static TokenType UnknownTokentype;
    [OriginalNameAttribute("TYPE_NAME")]
public static TokenType TypeName;
    [OriginalNameAttribute("NUMERIC_LITERAL")]
public static TokenType NumericLiteral;
    [OriginalNameAttribute("STRING_LITERAL")]
public static TokenType StringLiteral;
    [OriginalNameAttribute("KEYWORD")]
public static TokenType Keyword;
    [OriginalNameAttribute("COMMENT")]
public static TokenType Comment;
}
public class SonarAnalyzer.Protobuf.TokenTypeInfo : object {
    private static MessageParser`1<TokenTypeInfo> _parser;
    private UnknownFieldSet _unknownFields;
    public static int FilePathFieldNumber;
    private string filePath_;
    public static int TokenInfoFieldNumber;
    private static FieldCodec`1<TokenInfo> _repeated_tokenInfo_codec;
    private RepeatedField`1<TokenInfo> tokenInfo_;
    [DebuggerNonUserCodeAttribute]
public static MessageParser`1<TokenTypeInfo> Parser { get; }
    [DebuggerNonUserCodeAttribute]
public static MessageDescriptor Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
private MessageDescriptor pb::Google.Protobuf.IMessage.Descriptor { get; }
    [DebuggerNonUserCodeAttribute]
public string FilePath { get; public set; }
    [DebuggerNonUserCodeAttribute]
public RepeatedField`1<TokenInfo> TokenInfo { get; }
    [DebuggerNonUserCodeAttribute]
public TokenTypeInfo(TokenTypeInfo other);
    private static TokenTypeInfo();
    public static MessageParser`1<TokenTypeInfo> get_Parser();
    public static MessageDescriptor get_Descriptor();
    private sealed virtual override MessageDescriptor pb::Google.Protobuf.IMessage.get_Descriptor();
    [DebuggerNonUserCodeAttribute]
public sealed virtual TokenTypeInfo Clone();
    public string get_FilePath();
    public void set_FilePath(string value);
    public RepeatedField`1<TokenInfo> get_TokenInfo();
    [DebuggerNonUserCodeAttribute]
public virtual bool Equals(object other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(TokenTypeInfo other);
    [DebuggerNonUserCodeAttribute]
public virtual int GetHashCode();
    [DebuggerNonUserCodeAttribute]
public virtual string ToString();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void WriteTo(CodedOutputStream output);
    [DebuggerNonUserCodeAttribute]
public sealed virtual int CalculateSize();
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(TokenTypeInfo other);
    [DebuggerNonUserCodeAttribute]
public sealed virtual void MergeFrom(CodedInputStream input);
}
internal class SonarAnalyzer.RegularExpressions.RegexContext : object {
    private static RegexOptions ValidationMask;
    private static String[] MatchMethods;
    [CompilerGeneratedAttribute]
private SyntaxNode <PatternNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <OptionsNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RegexOptions> <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ParseError>k__BackingField;
    public SyntaxNode PatternNode { get; }
    public string Pattern { get; }
    public SyntaxNode OptionsNode { get; }
    public Nullable`1<RegexOptions> Options { get; }
    public Regex Regex { get; }
    public Exception ParseError { get; }
    public RegexContext(SyntaxNode patternNode, string pattern, SyntaxNode optionsNode, Nullable`1<RegexOptions> options);
    private static RegexContext();
    [CompilerGeneratedAttribute]
public SyntaxNode get_PatternNode();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public SyntaxNode get_OptionsNode();
    [CompilerGeneratedAttribute]
public Nullable`1<RegexOptions> get_Options();
    [CompilerGeneratedAttribute]
public Regex get_Regex();
    [CompilerGeneratedAttribute]
public Exception get_ParseError();
    public static RegexContext FromAttribute(ILanguageFacade`1<TSyntaxKind> language, SemanticModel model, SyntaxNode node);
    public static RegexContext FromCtor(ILanguageFacade`1<TSyntaxKind> language, SemanticModel model, SyntaxNode node);
    public static RegexContext FromMethod(ILanguageFacade`1<TSyntaxKind> language, SemanticModel model, SyntaxNode node);
    private static RegexContext FromMethod(ILanguageFacade`1<TSyntaxKind> language, SemanticModel model, SyntaxNode node, IMethodSymbol method);
    private static SyntaxNode TryGetNonParamsSyntax(IMethodSymbol method, IMethodParameterLookup parameters, string paramName);
}
public abstract class SonarAnalyzer.Rules.AllBranchesShouldNotHaveSameImplementationBase : SonarDiagnosticAnalyzer {
    protected static string StatementsMessage;
    protected static string TernaryMessage;
    internal static string DiagnosticId;
    internal static string MessageFormat;
}
public abstract class SonarAnalyzer.Rules.AlwaysSetDateTimeKindBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected TSyntaxKind ObjectCreationExpression { get; }
    protected String[] ValidNames { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind get_ObjectCreationExpression();
    protected abstract virtual String[] get_ValidNames();
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsDateTimeConstructorWithoutKindParameter(SyntaxNode objectCreation, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.AnalysisWarningAnalyzerBase : UtilityAnalyzerBase {
    private static string DiagnosticId;
    private static string Title;
    protected int VS2017MajorVersion { get; }
    protected int MinimalSupportedRoslynVersion { get; }
    protected virtual int get_VS2017MajorVersion();
    protected virtual int get_MinimalSupportedRoslynVersion();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static void WriteAllText(string path, string text);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ArrayPassedAsParamsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected TSyntaxKind[] ExpressionKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_ExpressionKinds();
    protected abstract virtual TArgumentNode LastArgumentIfArrayCreation(SyntaxNode expression);
    protected abstract virtual ITypeSymbol ArrayElementType(TArgumentNode argument, SemanticModel model);
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static bool IsJaggedArrayParam(IParameterSymbol param);
    private bool IsArrayOfCandidateTypes(TArgumentNode lastArgument, IMethodParameterLookup parameterLookup, IParameterSymbol param, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <IsArrayOfCandidateTypes>g__ParamArgumentsAreReferenceTypeArrays|10_0(TArgumentNode lastArgument, IMethodParameterLookup parameterLookup, SemanticModel model, <>c__DisplayClass10_0& );
}
public abstract class SonarAnalyzer.Rules.AvoidDateTimeNowForBenchmarkingBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual bool ContainsDateTimeArgument(TInvocationExpression invocation, SemanticModel model);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private void CheckBinaryExpression(SonarSyntaxNodeReportingContext context);
    private void CheckInvocation(SonarSyntaxNodeReportingContext context);
    private bool IsDateTimeNow(TMemberAccess node, SemanticModel model);
}
public abstract class SonarAnalyzer.Rules.AvoidUnsealedAttributesBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.BackslashShouldBeAvoidedInAspNetRoutesBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual bool IsNamedAttributeArgument(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected void Check(SonarSyntaxNodeReportingContext c);
    private bool IsRouteTemplate(SemanticModel model, SyntaxNode node);
    private static bool HasStringSyntaxAttributeOfTypeRoute(IParameterSymbol parameter);
    private static bool IsRouteTemplateBeforeAspNet6(IParameterSymbol parameter, IMethodSymbol method);
    private static bool ContainsBackslash(string value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationStartAnalysisContext compilationStartContext);
}
public abstract class SonarAnalyzer.Rules.BeginInvokePairedWithEndInvokeBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string EndInvoke;
    private static string BeginInvoke;
    protected TSyntaxKind InvocationExpressionKind { get; }
    protected ISet`1<TSyntaxKind> ParentDeclarationKinds { get; }
    protected string CallbackParameterName { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind get_InvocationExpressionKind();
    protected abstract virtual ISet`1<TSyntaxKind> get_ParentDeclarationKinds();
    protected abstract virtual string get_CallbackParameterName();
    protected abstract virtual void VisitInvocation(EndInvokeContext<TSyntaxKind, TInvocationExpressionSyntax> context);
    protected virtual string get_MessageFormat();
    protected abstract virtual bool IsInvalidCallback(SyntaxNode callbackArg, SemanticModel semanticModel);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsDelegate(IMethodSymbol methodSymbol);
    protected bool IsParentDeclarationWithEndInvoke(SyntaxNode node, SemanticModel semanticModel);
    private bool ParentMethodContainsEndInvoke(SyntaxNode node, SemanticModel model);
    private bool IsParentDeclaration(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__14_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__14_1(IParameterSymbol x);
}
public abstract class SonarAnalyzer.Rules.BinaryOperationWithIdenticalExpressionsBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string OperatorMessageFormat;
    protected static string EqualsMessage;
}
public abstract class SonarAnalyzer.Rules.BooleanCheckInvertedBase`1 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected abstract virtual bool IsLogicalNot(TBinaryExpression expression, SyntaxNode& logicalNot);
    protected abstract virtual string GetSuggestedReplacement(TBinaryExpression expression);
    protected abstract virtual bool IsIgnoredNullableOperation(TBinaryExpression expression, SemanticModel semanticModel);
    protected Action`1<SonarSyntaxNodeReportingContext> GetAnalysisAction(DiagnosticDescriptor rule);
    private static bool IsUserDefinedOperator(TBinaryExpression expression, SemanticModel semanticModel);
    protected static bool IsNullable(SyntaxNode expression, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.BooleanLiteralUnnecessaryBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    private ImmutableArray`1<INamedTypeSymbol> systemBooleanInterfaces;
    protected string MessageFormat { get; }
    protected abstract virtual SyntaxNode GetLeftNode(SyntaxNode node);
    protected abstract virtual SyntaxNode GetRightNode(SyntaxNode node);
    protected abstract virtual Nullable`1<SyntaxToken> GetOperatorToken(SyntaxNode node);
    protected abstract virtual bool IsTrue(SyntaxNode syntaxNode);
    protected abstract virtual bool IsFalse(SyntaxNode syntaxNode);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool IsInsideTernaryWithThrowExpression(SyntaxNode syntaxNode);
    protected virtual string get_MessageFormat();
    protected void CheckAndExpression(SonarSyntaxNodeReportingContext context);
    protected void CheckOrExpression(SonarSyntaxNodeReportingContext context);
    protected void CheckEquals(SonarSyntaxNodeReportingContext context);
    protected void CheckNotEquals(SonarSyntaxNodeReportingContext context);
    protected void CheckTernaryExpressionBranches(SonarSyntaxNodeReportingContext context, SyntaxNode thenBranch, SyntaxNode elseBranch);
    protected bool CheckForNullabilityAndBooleanConstantsReport(SonarSyntaxNodeReportingContext context, SyntaxNode node, bool reportOnTrue);
    protected void CheckForBooleanConstant(SonarSyntaxNodeReportingContext context, SyntaxNode node, IsBooleanLiteralKind<TSyntaxKind> isBooleanLiteralKind, ErrorLocation<TSyntaxKind> errorLocation, bool isLeftSide);
    private void CheckForBooleanConstantOnLeft(SonarSyntaxNodeReportingContext context, SyntaxNode node, IsBooleanLiteralKind<TSyntaxKind> isBooleanLiteralKind, ErrorLocation<TSyntaxKind> errorLocation);
    private void CheckForBooleanConstantOnRight(SonarSyntaxNodeReportingContext context, SyntaxNode node, IsBooleanLiteralKind<TSyntaxKind> isBooleanLiteralKind, ErrorLocation<TSyntaxKind> errorLocation);
    private Location CalculateExtendedLocation(SyntaxNode parent, bool isLeftSide);
    private bool TypeShouldBeIgnored(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarCompilationStartAnalysisContext x);
    [CompilerGeneratedAttribute]
private Location <CheckForBooleanConstant>g__GetLocation|20_0(<>c__DisplayClass20_0& );
}
public abstract class SonarAnalyzer.Rules.BypassingAccessibilityBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected BypassingAccessibilityBase`1(IAnalyzerConfiguration configuration);
    protected virtual void Initialize(TrackerInput input);
}
public abstract class SonarAnalyzer.Rules.CatchRethrowBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual TCatchClause[] AllCatches(SyntaxNode node);
    protected abstract virtual SyntaxNode DeclarationType(TCatchClause catchClause);
    protected abstract virtual bool HasFilter(TCatchClause catchClause);
    protected abstract virtual bool ContainsOnlyThrow(TCatchClause currentCatch);
    protected virtual string get_MessageFormat();
    protected void RaiseOnInvalidCatch(SonarSyntaxNodeReportingContext context);
    private static bool IsRedundantToFollowingCatches(int catchIndex, TCatchClause[] catches, INamedTypeSymbol[] caughtExceptionTypes, ISet`1<TCatchClause> redundantCatches);
    private INamedTypeSymbol[] ComputeExceptionTypes(IEnumerable`1<TCatchClause> catches, SemanticModel model);
}
public abstract class SonarAnalyzer.Rules.CertificateValidationCheckBase`10 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string SecondaryMessage;
    private static string DiagnosticId;
    protected TSyntaxKind[] MethodDeclarationKinds { get; }
    protected string MessageFormat { get; }
    internal abstract virtual MethodParameterLookupBase`1<TArgumentSyntax> CreateParameterLookup(SyntaxNode argumentListNode, IMethodSymbol method);
    protected abstract virtual TSyntaxKind[] get_MethodDeclarationKinds();
    protected abstract virtual Location ExpressionLocation(SyntaxNode expression);
    protected abstract virtual void SplitAssignment(TAssignmentExpressionSyntax assignment, TIdentifierNameSyntax& leftIdentifier, TExpressionSyntax& right);
    protected abstract virtual IEqualityComparer`1<TExpressionSyntax> CreateNodeEqualityComparer();
    protected abstract virtual TExpressionSyntax[] FindReturnAndThrowExpressions(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode block);
    protected abstract virtual bool IsTrueLiteral(TExpressionSyntax expression);
    protected abstract virtual TExpressionSyntax VariableInitializer(TVariableSyntax variable);
    protected abstract virtual ImmutableArray`1<Location> LambdaLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, TLambdaSyntax lambda);
    protected abstract virtual SyntaxNode LocalVariableScope(TVariableSyntax variable);
    protected abstract virtual SyntaxNode ExtractArgumentExpressionNode(SyntaxNode expression);
    protected abstract virtual SyntaxNode SyntaxFromReference(SyntaxReference reference);
    protected virtual string get_MessageFormat();
    protected void CheckAssignmentSyntax(SonarSyntaxNodeReportingContext c);
    protected void CheckConstructorParameterSyntax(SonarSyntaxNodeReportingContext c);
    protected ImmutableArray`1<Location> ParamLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, TParameterSyntax param);
    protected ImmutableArray`1<Location> BlockLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode block);
    protected virtual SyntaxNode FindRootTypeDeclaration(SyntaxNode node);
    private bool IsTypeDeclaration(SyntaxNode expression);
    private void TryReportLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, Location primaryLocation, SyntaxNode expression);
    private static bool IsValidationDelegateType(ITypeSymbol type);
    private ImmutableArray`1<Location> ArgumentLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode expression);
    private ImmutableArray`1<Location> VisitInvocation(TInvocationExpressionSyntax invocation, InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c);
    private ImmutableArray`1<Location> IdentifierLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode syntax);
    private ImmutableArray`1<Location> VariableLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, TVariableSyntax variable);
    private ImmutableArray`1<Location> InvocationLocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode method);
    private bool IsVisited(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode expression);
    private ImmutableArray`1<Location> MultiExpressionSublocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, IEnumerable`1<TExpressionSyntax> expressions);
    private ImmutableArray`1<Location> CallStackSublocations(InspectionContext<TSyntaxKind, TArgumentSyntax, TExpressionSyntax, TIdentifierNameSyntax, TAssignmentExpressionSyntax, TInvocationExpressionSyntax, TParameterSyntax, TVariableSyntax, TLambdaSyntax, TMemberAccessSyntax> c, SyntaxNode expression);
    private ImmutableArray`1<TInvocationExpressionSyntax> FindInvocationList(SonarSyntaxNodeReportingContext c, SyntaxNode root, IMethodSymbol method);
    [CompilerGeneratedAttribute]
private bool <ParamLocations>b__20_0(SyntaxNode x);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType4`2<TIdentifierNameSyntax, TExpressionSyntax> <VariableLocations>b__29_0(TAssignmentExpressionSyntax x);
}
public abstract class SonarAnalyzer.Rules.CheckFileLicenseBase : ParametrizedDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string HeaderFormatPropertyKey;
    internal static string IsRegularExpressionPropertyKey;
    protected static string HeaderFormatRuleParameterKey;
    private static string IsRegularExpressionRuleParameterKey;
    private static string IsRegularExpressionDefaultValue;
    private static string MessageFormat;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private bool <IsRegularExpression>k__BackingField;
    protected ILanguageFacade Language { get; }
    public string HeaderFormat { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("isRegularExpression", "2", "Whether the headerFormat is a regular expression.", "false")]
public bool IsRegularExpression { get; public set; }
    protected abstract virtual ILanguageFacade get_Language();
    public abstract virtual string get_HeaderFormat();
    public abstract virtual void set_HeaderFormat(string value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public bool get_IsRegularExpression();
    [CompilerGeneratedAttribute]
public void set_IsRegularExpression(bool value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    private static bool IsRegexPatternValid(string pattern);
    private bool HasValidLicenseHeader(SyntaxNode node);
    private bool AreHeadersEqual(string currentHeader);
    private ImmutableDictionary`2<string, string> CreateDiagnosticProperties();
    [CompilerGeneratedAttribute]
private void <Initialize>b__20_0(SonarSyntaxTreeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ClassNamedExceptionBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ClassNotInstantiatableBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual IEnumerable`1<ConstructorContext<TBaseTypeSyntax, TSyntaxKind>> CollectRemovableDeclarations(INamedTypeSymbol namedType, Compilation compilation, string messageArg);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsClassTypeDeclaration(SyntaxNode node);
    private bool IsAnyConstructorCalled(INamedTypeSymbol namedType, IEnumerable`1<ConstructorContext<TBaseTypeSyntax, TSyntaxKind>> typeDeclarations);
    private void CheckClassWithOnlyUnusedPrivateConstructors(SonarSymbolReportingContext context);
    private bool IsAnyNestedTypeExtendingCurrentType(IEnumerable`1<SyntaxNode> descendantNodes, INamedTypeSymbol namedType, SemanticModel semanticModel);
    private bool IsAnyConstructorToCurrentType(IEnumerable`1<SyntaxNode> descendantNodes, INamedTypeSymbol namedType, SemanticModel semanticModel);
    private static bool HasNonPrivateConstructor(IEnumerable`1<IMethodSymbol> constructors);
    private static IEnumerable`1<IMethodSymbol> GetConstructors(IEnumerable`1<ISymbol> members);
    private static bool HasOnlyStaticMembers(ICollection`1<ISymbol> members);
    private static bool IsNonStaticClassWithNoAttributes(INamedTypeSymbol namedType);
    private static bool HasOnlyCandidateConstructors(ICollection`1<IMethodSymbol> constructors);
    private static bool DerivesFromSafeHandle(ITypeSymbol typeSymbol);
}
public abstract class SonarAnalyzer.Rules.ClassShouldNotBeEmptyBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static ImmutableArray`1<KnownType> BaseClassesToIgnore;
    private static IEnumerable`1<string> IgnoredNames;
    private static IEnumerable`1<string> IgnoredSuffixes;
    protected string MessageFormat { get; }
    private static ClassShouldNotBeEmptyBase`2();
    protected abstract virtual bool IsEmptyAndNotPartial(SyntaxNode node);
    protected abstract virtual TDeclarationSyntax GetIfHasDeclaredBaseClassOrInterface(SyntaxNode node);
    protected abstract virtual bool HasInterfaceOrGenericBaseClass(TDeclarationSyntax declaration);
    protected abstract virtual bool HasAnyAttribute(SyntaxNode node);
    protected abstract virtual string DeclarationTypeKeyword(SyntaxNode node);
    protected abstract virtual bool HasConditionalCompilationDirectives(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ShouldIgnoreBecauseOfName(SyntaxToken identifier);
    private bool ShouldIgnoreBecauseOfBaseClassOrInterface(SyntaxNode node, SemanticModel model);
    private static bool ShouldIgnoreType(TDeclarationSyntax node, SemanticModel model);
    private static bool HasNonPublicDefaultConstructor(TDeclarationSyntax declaration, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.CognitiveComplexityBase`1 : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private static int DefaultThreshold;
    private static int DefaultPropertyThreshold;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PropertyThreshold>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    [RuleParameterAttribute("threshold", "3", "The maximum authorized complexity.", "15")]
public int Threshold { get; public set; }
    [RuleParameterAttribute("propertyThreshold", "3", "The maximum authorized complexity in a property.", "3")]
public int PropertyThreshold { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(int value);
    [CompilerGeneratedAttribute]
public int get_PropertyThreshold();
    [CompilerGeneratedAttribute]
public void set_PropertyThreshold(int value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected void CheckComplexity(SonarSyntaxNodeReportingContext context, Func`2<TSyntax, SyntaxNode> nodeSelector, Func`2<TSyntax, Location> getLocationToReport, Func`2<SyntaxNode, CognitiveComplexity> getComplexity, string declarationType, int threshold);
}
public abstract class SonarAnalyzer.Rules.CollectionEmptinessCheckingBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckExpression(SonarSyntaxNodeReportingContext context, SyntaxNode expression, int constant, ComparisonKind comparison);
    private bool TryGetCountCall(SyntaxNode expression, SemanticModel semanticModel, Location& countLocation, String& typeArgument);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.CommandPathBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private Regex validPath;
    protected CommandPathBase`1(IAnalyzerConfiguration configuration);
    protected abstract virtual string FirstArgument(InvocationContext context);
    protected virtual void Initialize(TrackerInput input);
    private bool IsInvalid(string path);
}
public abstract class SonarAnalyzer.Rules.CommentKeywordBase : SonarDiagnosticAnalyzer {
    private static string ToDoKeyword;
    protected static string ToDoDiagnosticId;
    protected static string ToDoMessageFormat;
    private static string FixMeKeyword;
    protected static string FixMeDiagnosticId;
    protected static string FixMeMessageFormat;
    private DiagnosticDescriptor toDoRule;
    private DiagnosticDescriptor fixMeRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade get_Language();
    protected abstract virtual bool IsComment(SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<Location> GetKeywordLocations(SyntaxTree tree, SyntaxTrivia comment, string word);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.CommentKeywordBase/<AllIndexesOf>d__17")]
private static IEnumerable`1<int> AllIndexesOf(string text, string value, StringComparison comparisonType);
    private static bool IsWordAt(string text, int index, int count);
    [CompilerGeneratedAttribute]
private void <Initialize>b__15_0(SonarSyntaxTreeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__15_1(SyntaxTrivia trivia);
}
public abstract class SonarAnalyzer.Rules.CommentsShouldNotBeEmptyBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual string GetCommentText(SyntaxTrivia trivia);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckTrivia(SonarSyntaxTreeReportingContext context, IEnumerable`1<SyntaxTrivia> trivia);
    private List`1<List`1<SyntaxTrivia>> PartitionComments(IEnumerable`1<SyntaxTrivia> trivia);
    private bool IsValidTriviaType(SyntaxTrivia trivia);
    private bool IsSimpleComment(SyntaxTrivia trivia);
    private bool IsEndOfLine(SyntaxTrivia trivia);
    private bool IsWhitespace(SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxTreeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <CheckTrivia>b__6_0(List`1<SyntaxTrivia> trivia);
    [CompilerGeneratedAttribute]
private bool <CheckTrivia>b__6_1(SyntaxTrivia x);
    [CompilerGeneratedAttribute]
internal static void <PartitionComments>g__AddTriviaToPartition|7_0(List`1& current, SyntaxTrivia trivia, Boolean& firstEndOfLineFound);
    [CompilerGeneratedAttribute]
internal static void <PartitionComments>g__CloseCurrentPartition|7_1(List`1& current, List`1& partitions, Boolean& firstEndOfLineFound);
}
public abstract class SonarAnalyzer.Rules.ConditionalStructureSameConditionBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected DiagnosticDescriptor rule;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
public abstract class SonarAnalyzer.Rules.ConditionalStructureSameImplementationBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string MessageFormat;
}
[ObsoleteAttribute("This rule has been deprecated since 9.16")]
public abstract class SonarAnalyzer.Rules.ConfiguringLoggersBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected ConfiguringLoggersBase`1(IAnalyzerConfiguration configuration);
    protected virtual void Initialize(TrackerInput input);
}
public abstract class SonarAnalyzer.Rules.ConstructorArgumentValueShouldExistBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected static AttributeData GetConstructorArgumentAttributeOrDefault(IPropertySymbol propertySymbol);
    protected void CheckConstructorArgumentProperty(SonarSyntaxNodeReportingContext c, SyntaxNode propertyDeclaration, IPropertySymbol propertySymbol);
    protected abstract virtual IEnumerable`1<string> GetAllParentClassConstructorArgumentNames(SyntaxNode propertyDeclaration);
    protected abstract virtual void ReportIssue(SonarSyntaxNodeReportingContext c, AttributeData constructorArgumentAttribute);
}
public abstract class SonarAnalyzer.Rules.CopyPasteTokenAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, CopyPasteTokenInfo> {
    private static string DiagnosticId;
    private static string Title;
    protected bool AnalyzeUnchangedFiles { get; }
    protected string FileName { get; }
    protected abstract virtual string GetCpdValue(SyntaxToken token);
    protected abstract virtual bool IsUsingDirective(SyntaxNode node);
    protected virtual UtilityAnalyzerParameters ReadParameters(SonarAnalysisContextBase`1<T> context);
    protected sealed virtual bool get_AnalyzeUnchangedFiles();
    protected sealed virtual string get_FileName();
    protected sealed virtual bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    protected sealed virtual CopyPasteTokenInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
    [CompilerGeneratedAttribute]
private bool <CreateMessage>b__11_0(SyntaxNode n);
}
public abstract class SonarAnalyzer.Rules.CreatingHashAlgorithmsBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static string CreateMethodName;
    private KnownType[] algorithmTypes;
    private String[] unsafeAlgorithms;
    protected CreatingHashAlgorithmsBase`1(IAnalyzerConfiguration configuration);
    protected virtual void Initialize(TrackerInput input);
}
public abstract class SonarAnalyzer.Rules.DangerousGetHandleShouldNotBeCalledBase`2 : DoNotCallMethodsBase`2<TSyntaxKind, TInvocation> {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
}
public abstract class SonarAnalyzer.Rules.DateAndTimeShouldNotBeUsedasTypeForPrimaryKeyBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected static String[] KeyAttributeTypeNames;
    protected static KnownType[] TemporalTypes;
    protected string MessageFormat { get; }
    private static DateAndTimeShouldNotBeUsedasTypeForPrimaryKeyBase`1();
    protected abstract virtual IEnumerable`1<SyntaxNode> TypeNodesOfTemporalKeyProperties(SonarSyntaxNodeReportingContext context);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsKeyPropertyBasedOnName(string propertyName, string className);
    protected virtual bool IsTemporalType(string propertyTypeName);
    protected bool MatchesAttributeName(string attributeName, String[] candidates);
    private static bool ShouldRegisterAction(Compilation compilation);
    private static String[] TypeNamesForAttribute(KnownType attributeType);
    private static string RemoveFromEnd(string text, string subtextFromEnd);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationStartAnalysisContext startContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(SonarSyntaxNodeReportingContext nodeContext);
}
public abstract class SonarAnalyzer.Rules.DateTimeFormatShouldNotBeHardcodedBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<KnownType> <CheckedTypes>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<KnownType> CheckedTypes { get; }
    protected abstract virtual Location HardCodedArgumentLocation(TInvocation invocation);
    protected abstract virtual bool HasInvalidFirstArgument(TInvocation invocation, SemanticModel semanticModel);
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected IEnumerable`1<KnownType> get_CheckedTypes();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void AnalyzeInvocation(SonarSyntaxNodeReportingContext analysisContext);
}
public abstract class SonarAnalyzer.Rules.DebuggerDisplayUsesExistingMembersBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private Regex evaluatedExpressionRegex;
    protected string MessageFormat { get; }
    protected abstract virtual SyntaxNode AttributeFormatString(TAttributeSyntax attribute);
    protected abstract virtual bool IsValidMemberName(string memberName);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private string FirstInvalidMemberName(SonarSyntaxNodeReportingContext context, string formatString, TAttributeSyntax attributeSyntax);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private string <FirstInvalidMemberName>g__FirstInvalidMemberName|8_0(ITypeSymbol typeSymbol, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private string <FirstInvalidMemberName>g__ExtractValidMemberName|8_1(string evaluatedExpression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <FirstInvalidMemberName>g__TypeContainingReferencedMembers|8_2(ISymbol symbol);
}
public abstract class SonarAnalyzer.Rules.DeclareTypesInNamespacesBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual bool IsInnerTypeOrWithinNamespace(SyntaxNode declaration, SemanticModel semanticModel);
    protected abstract virtual SyntaxToken GetTypeIdentifier(SyntaxNode declaration);
    protected abstract virtual bool IsException(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.DeliveringDebugFeaturesInProductionBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected static string StartupDevelopment;
    private static string MessageFormat;
    private ImmutableArray`1<MemberDescriptor> isDevelopmentMethods;
    protected DeliveringDebugFeaturesInProductionBase`1(IAnalyzerConfiguration configuration);
    protected abstract virtual bool IsDevelopmentCheckInvoked(SyntaxNode node, SemanticModel semanticModel);
    protected abstract virtual bool IsInDevelopmentContext(SyntaxNode node);
    protected virtual void Initialize(TrackerInput input);
    protected bool IsValidationMethod(SemanticModel semanticModel, SyntaxNode condition, string methodName);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__7_0(InvocationContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__7_1(InvocationContext c);
}
public abstract class SonarAnalyzer.Rules.DisablingRequestValidationBase : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int MinimumAcceptedRequestValidationModeValue;
    private DiagnosticDescriptor rule;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DisablingRequestValidationBase(IAnalyzerConfiguration configuration);
    protected abstract virtual ILanguageFacade get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckController(SonarSymbolReportingContext context);
    private void CheckWebConfig(SonarCompilationReportingContext context);
    private void ReportValidateRequest(SonarCompilationReportingContext context, XDocument doc, string webConfigPath);
    private void ReportRequestValidationMode(SonarCompilationReportingContext context, XDocument doc, string webConfigPath);
}
public abstract class SonarAnalyzer.Rules.DoNotCallInsecureSecurityAlgorithmBase`4 : SonarDiagnosticAnalyzer {
    protected ISet`1<string> AlgorithmParameterlessFactoryMethods { get; }
    protected ISet`1<string> AlgorithmParameterizedFactoryMethods { get; }
    protected ISet`1<string> FactoryParameterNames { get; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    private protected ImmutableArray`1<KnownType> AlgorithmTypes { get; }
    protected abstract virtual ISet`1<string> get_AlgorithmParameterlessFactoryMethods();
    protected abstract virtual ISet`1<string> get_AlgorithmParameterizedFactoryMethods();
    protected abstract virtual ISet`1<string> get_FactoryParameterNames();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    private protected abstract virtual ImmutableArray`1<KnownType> get_AlgorithmTypes();
    protected abstract virtual Location Location(SyntaxNode objectCreation);
    protected abstract virtual TArgumentListSyntax ArgumentList(TInvocationExpressionSyntax invocationExpression);
    protected abstract virtual SeparatedSyntaxList`1<TArgumentSyntax> Arguments(TArgumentListSyntax argumentList);
    protected abstract virtual bool IsStringLiteralArgument(TArgumentSyntax argument);
    protected abstract virtual SyntaxNode Expression(TArgumentSyntax argument);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private void CheckInvocation(SonarSyntaxNodeReportingContext context);
    private void CheckObjectCreation(SonarSyntaxNodeReportingContext context);
    private bool IsInsecureBaseAlgorithmCreationFactoryCall(IMethodSymbol methodSymbol, TInvocationExpressionSyntax invocationExpression);
    private void ReportAllDiagnostics(SonarSyntaxNodeReportingContext context, Location location);
}
public abstract class SonarAnalyzer.Rules.DoNotCallMethodsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected DoNotCallMethodsBase`2(string diagnosticId);
    protected abstract virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual bool ShouldReportOnMethodCall(TInvocationExpressionSyntax invocation, SemanticModel semanticModel, MemberDescriptor memberDescriptor);
    protected virtual bool IsInValidContext(TInvocationExpressionSyntax invocationSyntax, SemanticModel semanticModel);
    protected virtual bool ShouldRegisterAction(Compilation compilation);
    protected virtual void Initialize(SonarAnalysisContext context);
    private void AnalyzeInvocation(SonarSyntaxNodeReportingContext analysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarCompilationStartAnalysisContext c);
}
public abstract class SonarAnalyzer.Rules.DoNotCheckZeroSizeCollectionBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static string CountName;
    private static string LengthName;
    private static string LongLengthName;
    protected string IEnumerableTString { get; }
    protected string MessageFormat { get; }
    protected abstract virtual string get_IEnumerableTString();
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected void CheckExpression(SonarSyntaxNodeReportingContext context, SyntaxNode issue, SyntaxNode expression, int constant, ComparisonKind comparison);
    private bool HasCandidateName(string name);
    private bool IsEnumerableCountMethod(ISymbol symbol);
    private bool IsArrayLengthProperty(ISymbol symbol);
    private bool IsStringLengthProperty(ISymbol symbol);
    private bool IsCollectionCountProperty(ISymbol symbol);
    private bool IsReadonlyCollectionCountProperty(ISymbol symbol);
    private string CollecionSizeTypeName(ISymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.DoNotHardcodeCredentialsBase`1 : ParametrizedDiagnosticAnalyzer {
    protected static char CredentialSeparator;
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string MessageHardcodedPassword;
    private static string MessageFormatCredential;
    private static string MessageUriUserInfo;
    private static string DefaultCredentialWords;
    private static TimeSpan RegexTimeout;
    private static Regex ValidCredentialPattern;
    private static Regex UriUserInfoPattern;
    private IAnalyzerConfiguration configuration;
    private DiagnosticDescriptor rule;
    private string credentialWords;
    private ImmutableList`1<string> splitCredentialWords;
    private Regex passwordValuePattern;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("credentialWords", "0", "Comma separated list of words identifying potential credentials", "password, passwd, pwd, passphrase")]
public string CredentialWords { get; public set; }
    protected DoNotHardcodeCredentialsBase`1(IAnalyzerConfiguration configuration);
    private static DoNotHardcodeCredentialsBase`1();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual void InitializeActions(SonarParametrizedAnalysisContext context);
    protected abstract virtual bool IsSecureStringAppendCharFromConstant(SyntaxNode argumentNode, SemanticModel model);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public string get_CredentialWords();
    public void set_CredentialWords(string value);
    private static ImmutableList`1<string> SplitCredentialWordsByComma(string credentialWords);
    private static Regex CreateUriUserInfoPattern();
    protected sealed virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected bool IsEnabled(AnalyzerOptions options);
    private void CheckWebConfig(SonarCompilationReportingContext context);
    private void CheckWebConfig(SonarCompilationReportingContext context, string path, IEnumerable`1<XElement> elements);
    private void CheckAppSettings(SonarCompilationReportingContext context);
    private string IssueMessage(string variableName, string variableValue);
    private IEnumerable`1<string> FindCredentialWords(string variableName, string variableValue);
    private static bool IsValidCredential(string suffix);
    private static bool ContainsUriUserInfo(string variableValue);
    [CompilerGeneratedAttribute]
internal static string <CreateUriUserInfoPattern>g__CreateUserInfoGroup|26_0(string name, string additionalCharacters);
}
public abstract class SonarAnalyzer.Rules.DoNotInstantiateSharedClassesBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected static bool IsShared(AttributeData data);
}
public abstract class SonarAnalyzer.Rules.DoNotLockOnSharedResourceBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static ImmutableArray`1<KnownType> _invalidLockTypes;
    private static DoNotLockOnSharedResourceBase();
    protected static bool IsLockOnForbiddenKnownType(SyntaxNode expression, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.DoNotLockWeakIdentityObjectsBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private ImmutableArray`1<KnownType> weakIdentityTypes;
    protected TSyntaxKind SyntaxKind { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind get_SyntaxKind();
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.DoNotNestTernaryOperatorsBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.DoNotOverwriteCollectionElementsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual SyntaxNode GetIndexOrKey(TStatementSyntax statement);
    protected abstract virtual SyntaxNode GetCollectionIdentifier(TStatementSyntax statement);
    protected abstract virtual bool IsIdentifierOrLiteral(SyntaxNode syntaxNode);
    protected virtual string get_MessageFormat();
    protected void AnalysisAction(SonarSyntaxNodeReportingContext context);
    private Func`2<TStatementSyntax, bool> IsSameCollection(SyntaxNode collectionIdentifier);
    private Func`2<TStatementSyntax, bool> IsSameIndexOrKey(SyntaxNode indexOrKey);
    private static bool IsDictionaryOrCollection(SyntaxNode identifier, SemanticModel semanticModel);
    private static IEnumerable`1<TStatementSyntax> GetPreviousStatements(TStatementSyntax statement);
}
public abstract class SonarAnalyzer.Rules.DoNotThrowFromDestructorsBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.DoNotUseDateTimeNowBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static MemberDescriptor DateTimeNow;
    private static MemberDescriptor DateTimeToday;
    private static MemberDescriptor DateTimeOffsetNow;
    private static MemberDescriptor DateTimeOffsetDate;
    private static MemberDescriptor DateTimeOffsetDateTime;
    protected string MessageFormat { get; }
    private static DoNotUseDateTimeNowBase`1();
    protected virtual string get_MessageFormat();
    protected abstract virtual bool IsInsideNameOf(SyntaxNode node);
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsDateTimeNowOrToday(SyntaxNode node, SemanticModel semanticModel);
    private bool IsDateTimeOffsetNowDateTime(SyntaxNode node, SemanticModel semanticModel);
    private bool MatchesAnyProperty(SyntaxNode node, SemanticModel semanticModel, MemberDescriptor[] members);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.EmptyMethodBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual void CheckMethod(SonarSyntaxNodeReportingContext context);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
}
public abstract class SonarAnalyzer.Rules.EmptyNestedBlockBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual IEnumerable`1<SyntaxNode> EmptyBlocks(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.EncryptionAlgorithmsShouldBeSecureBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static string MessageFormat;
    protected EncryptionAlgorithmsShouldBeSecureBase`1(IAnalyzerConfiguration configuration);
    protected abstract virtual Condition<TSyntaxKind, PropertyAccessContext> IsInsideObjectInitializer();
    protected abstract virtual Condition<TSyntaxKind, InvocationContext> HasPkcs1PaddingArgument();
    protected virtual void Initialize(TrackerInput input);
}
public abstract class SonarAnalyzer.Rules.EnumNameHasEnumSuffixBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private IEnumerable`1<string> nameEndings;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.EnumNameShouldFollowRegexBase`1 : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private static string DefaultEnumNamePattern;
    private static string DefaultFlagsEnumNamePattern;
    [CompilerGeneratedAttribute]
private string <EnumNamePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlagsEnumNamePattern>k__BackingField;
    private DiagnosticDescriptor rule;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    [RuleParameterAttribute("format", "0", "Regular expression used to check the enumeration type names against.", "^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?$")]
public string EnumNamePattern { get; public set; }
    [RuleParameterAttribute("flagsAttributeFormat", "0", "Regular expression used to check the flags enumeration type names against.", "^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?s$")]
public string FlagsEnumNamePattern { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    [CompilerGeneratedAttribute]
public string get_EnumNamePattern();
    [CompilerGeneratedAttribute]
public void set_EnumNamePattern(string value);
    [CompilerGeneratedAttribute]
public string get_FlagsEnumNamePattern();
    [CompilerGeneratedAttribute]
public void set_FlagsEnumNamePattern(string value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__18_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ExceptionsShouldBePublicBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static KnownType[] BaseTypes;
    private static ExceptionsShouldBePublicBase`1();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ExcludeFromCodeCoverageAttributesNeedJustificationBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected static string JustificationPropertyName;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual SyntaxNode GetJustificationExpression(SyntaxNode node);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool NoJustification(SyntaxNode node, SemanticModel model);
    private static bool HasJustificationProperty(INamedTypeSymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ExecutingSqlQueriesBase`3 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static string AssignmentWithFormattingMessage;
    private static string AssignmentMessage;
    private static string MessageFormat;
    private static int FirstArgumentIndex;
    private static int SecondArgumentIndex;
    private KnownType[] constructorsForFirstArgument;
    private KnownType[] constructorsForSecondArgument;
    private MemberDescriptor[] invocationsForFirstTwoArguments;
    private MemberDescriptor[] invocationsForFirstTwoArgumentsAfterV2;
    private MemberDescriptor[] invocationsForFirstArgument;
    private MemberDescriptor[] invocationsForSecondArgument;
    private MemberDescriptor[] properties;
    protected ExecutingSqlQueriesBase`3(IAnalyzerConfiguration configuration);
    protected abstract virtual TExpressionSyntax GetArgumentAtIndex(InvocationContext context, int index);
    protected abstract virtual TExpressionSyntax GetArgumentAtIndex(ObjectCreationContext context, int index);
    protected abstract virtual TExpressionSyntax GetSetValue(PropertyAccessContext context);
    protected abstract virtual bool IsTracked(TExpressionSyntax expression, SyntaxBaseContext context);
    protected abstract virtual bool IsSensitiveExpression(TExpressionSyntax expression, SemanticModel semanticModel);
    protected abstract virtual Location SecondaryLocationForExpression(TExpressionSyntax node, string identifierNameToFind, String& identifierNameFound);
    protected virtual void Initialize(TrackerInput input);
    protected bool IsTrackedVariableDeclaration(TExpressionSyntax expression, SyntaxBaseContext context);
    private void TrackObjectCreation(TrackerInput input, KnownType[] objectCreationTypes, int argumentIndex);
    private void TrackInvocations(TrackerInput input, MemberDescriptor[] invocationsDescriptors, int argumentIndex);
    private Condition<TSyntaxKind, InvocationContext> MethodHasRawSqlQueryParameter();
    private Condition<TSyntaxKind, InvocationContext> ArgumentAtIndexIsTracked(int index);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__20_0(PropertyAccessContext c);
    [CompilerGeneratedAttribute]
private bool <MethodHasRawSqlQueryParameter>b__24_0(InvocationContext context);
    [CompilerGeneratedAttribute]
internal static bool <MethodHasRawSqlQueryParameter>g__ParameterIsRawString|24_1(IMethodSymbol method, int index);
}
public abstract class SonarAnalyzer.Rules.ExpandingArchivesBase`1 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected ExpandingArchivesBase`1(IAnalyzerConfiguration configuration);
    protected virtual void Initialize(TrackerInput input);
}
public abstract class SonarAnalyzer.Rules.ExpectedExceptionAttributeShouldNotBeUsedBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual SyntaxNode FindExpectedExceptionAttribute(SyntaxNode node);
    protected abstract virtual bool HasMultiLineBody(SyntaxNode node);
    protected abstract virtual bool AssertInCatchFinallyBlock(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool ContainExpectedExceptionType(Compilation compilation);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarCompilationStartAnalysisContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(SonarSyntaxNodeReportingContext cc);
}
public abstract class SonarAnalyzer.Rules.ExpressionComplexityBase`1 : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private static int DefaultValueMaximum;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    protected ILanguageFacade Language { get; }
    protected TSyntaxKind[] ComplexityIncreasingKinds { get; }
    protected TSyntaxKind[] TransparentKinds { get; }
    [RuleParameterAttribute("max", "3", "Maximum number of allowed conditional operators in an expression", "3")]
public int Maximum { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade get_Language();
    protected abstract virtual TSyntaxKind[] get_ComplexityIncreasingKinds();
    protected abstract virtual TSyntaxKind[] get_TransparentKinds();
    protected abstract virtual SyntaxNode[] ExpressionChildren(SyntaxNode node);
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarParametrizedAnalysisContext context);
    private bool IsRoot(SyntaxNode node);
    private int CalculateComplexity(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__18_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ExtensionMethodShouldNotExtendObjectBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual bool IsExtensionMethod(TMethodDeclaration declaration, SemanticModel semanticModel);
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
[ObsoleteAttribute("This rule has been deprecated since 9.32")]
public abstract class SonarAnalyzer.Rules.FieldShadowsParentFieldBase`2 : SonarDiagnosticAnalyzer {
    private static string S2387DiagnosticId;
    private static string S2387MessageFormat;
    private static string S4025DiagnosticId;
    private static string S4025MessageFormat;
    private DiagnosticDescriptor s2387;
    private DiagnosticDescriptor s4025;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.FieldShadowsParentFieldBase`2/<CheckFields>d__11")]
protected IEnumerable`1<Diagnostic> CheckFields(SemanticModel model, TVariableDeclaratorSyntax variableDeclarator);
}
public abstract class SonarAnalyzer.Rules.FieldShouldNotBePublicBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual IEnumerable`1<TVariableSyntax> Variables(TFieldDeclarationSyntax fieldDeclaration);
    protected virtual string get_MessageFormat();
    protected static bool FieldIsRelevant(IFieldSymbol fieldSymbol);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.FileLinesBase : ParametrizedDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string MessageFormat;
    private static int DefaultValueMaximum;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    [RuleParameterAttribute("maximumFileLocThreshold", "3", "Maximum authorized lines in a file.", "1000")]
public int Maximum { get; public set; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual bool IsEndOfFileToken(SyntaxToken token);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxTreeReportingContext stac);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__7_1(SyntaxToken token);
}
public abstract class SonarAnalyzer.Rules.FileMetadataAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, FileMetadataInfo> {
    protected static string DiagnosticId;
    private static string Title;
    protected string FileName { get; }
    protected sealed virtual string get_FileName();
    protected virtual UtilityAnalyzerParameters ReadParameters(SonarAnalysisContextBase`1<T> context);
    protected virtual bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    protected sealed virtual FileMetadataInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
}
public abstract class SonarAnalyzer.Rules.FindInsteadOfFirstOrDefaultBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static int NumberOfArgument;
    private static string GenericMessage;
    private static string ArrayMessage;
    private static ImmutableArray`1<KnownType> ListTypes;
    protected string MessageFormat { get; }
    private static FindInsteadOfFirstOrDefaultBase`2();
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static bool IsCorrectCall(SyntaxNode right, SemanticModel model);
    private static bool IsCorrectType(SyntaxNode left, SemanticModel model, Boolean& isArray);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.FlagsEnumWithoutInitializerBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static int AllowedEmptyMemberCount;
    protected string MessageFormat { get; }
    protected abstract virtual bool IsInitialized(TEnumMemberDeclarationSyntax member);
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool AreAllRequiredMembersInitialized(SyntaxNode declaration);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <AreAllRequiredMembersInitialized>b__7_0(TEnumMemberDeclarationSyntax m);
    [CompilerGeneratedAttribute]
private bool <AreAllRequiredMembersInitialized>b__7_1(TEnumMemberDeclarationSyntax m);
    [CompilerGeneratedAttribute]
private bool <AreAllRequiredMembersInitialized>b__7_2(TEnumMemberDeclarationSyntax m);
}
public abstract class SonarAnalyzer.Rules.FlagsEnumZeroMemberBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private SyntaxNode ZeroMember(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.FunctionComplexityBase : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected static int DefaultValueMaximum;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    [RuleParameterAttribute("maximumFunctionComplexityThreshold", "3", "The maximum authorized complexity.", "10")]
public int Maximum { get; public set; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected void CheckComplexity(SonarSyntaxNodeReportingContext context, Func`2<TSyntax, SyntaxNode> nodeSelector, Func`2<TSyntax, Location> location, string declarationType);
    protected void CheckComplexity(SonarSyntaxNodeReportingContext context, Func`2<TSyntax, Location> location, string declarationType);
    protected abstract virtual int GetComplexity(SyntaxNode node, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.FunctionNestingDepthBase : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private static int DefaultValueMaximum;
    protected DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("maximumNestingLevel", "3", "Maximum allowed control flow statement nesting depth.", "3")]
public int Maximum { get; public set; }
    protected abstract virtual ILanguageFacade get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
}
public abstract class SonarAnalyzer.Rules.GenericInheritanceShouldNotBeRecursiveBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual INamedTypeSymbol GetNamedTypeSymbol(TDeclaration declaration, SemanticModel semanticModel);
    protected abstract virtual Location GetLocation(TDeclaration declaration);
    protected abstract virtual SyntaxToken GetKeyword(TDeclaration declaration);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(INamedTypeSymbol typeSymbol);
    private static bool HasRecursiveGenericSubstitution(INamedTypeSymbol typeSymbol, INamedTypeSymbol declaredType);
    private static bool IsGenericType(INamedTypeSymbol type);
    private static bool HasSubstitutedTypeArguments(INamedTypeSymbol type);
    private static bool IsRecursiveInheritance(INamedTypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.GotoStatementBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected TSyntaxKind[] GotoSyntaxKinds { get; }
    protected string GoToLabel { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual TSyntaxKind[] get_GotoSyntaxKinds();
    protected abstract virtual string get_GoToLabel();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.HardcodedIpAddressBase`2 : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int IPv4AddressParts;
    private static string IPv4Broadcast;
    private static string OIDPrefix;
    private String[] ignoredVariableNames;
    private Byte[][] interNetworkDocumentationRanges;
    private Byte[] interNetwork6DocumentationRange;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticDescriptor Rule { get; protected set; }
    protected HardcodedIpAddressBase`2(IAnalyzerConfiguration analyzerConfiguration);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual string GetAssignedVariableName(SyntaxNode stringLiteral);
    protected abstract virtual bool HasAttributes(SyntaxNode literalExpression);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Rule(DiagnosticDescriptor value);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected bool IsHardcodedIp(string literalValue, SyntaxNode node);
    private void CheckForHardcodedIpAddressesInStringLiteral(SonarSyntaxNodeReportingContext context);
    private void CheckForHardcodedIpAddressesInStringInterpolation(SonarSyntaxNodeReportingContext context);
    private static bool IsRoutableNonLoopbackIPAddress(string literalValue, IPAddress& ipAddress);
    private bool IsInDocumentationBlock(IPAddress address);
    private static bool IsObjectIdentifier(string literalValue);
    private bool IsIgnoredVariableName(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <IsInDocumentationBlock>g__SequenceStartsWith|24_0(Byte[] sequence, Byte[] startsWith);
}
public abstract class SonarAnalyzer.Rules.IfChainWithoutElseBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind SyntaxKind { get; }
    protected string ElseClause { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind get_SyntaxKind();
    protected abstract virtual string get_ElseClause();
    protected abstract virtual bool IsElseIfWithoutElse(TIfSyntax ifSyntax);
    protected abstract virtual Location IssueLocation(SonarSyntaxNodeReportingContext context, TIfSyntax ifSyntax);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.IfCollapsibleBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
}
public abstract class SonarAnalyzer.Rules.ImplementSerializationMethodsCorrectlyBase : SonarDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static string AttributeNotConsideredMessageFormat;
    private static string ProblemParameterText;
    private static string ProblemGenericParameterText;
    private static string ProblemPublicText;
    private DiagnosticDescriptor rule;
    private static ImmutableArray`1<KnownType> SerializationAttributes;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <AttributeNotConsideredRule>k__BackingField;
    protected ILanguageFacade Language { get; }
    protected string MethodStaticMessage { get; }
    protected string MethodReturnTypeShouldBeVoidMessage { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticDescriptor AttributeNotConsideredRule { get; protected set; }
    private static ImplementSerializationMethodsCorrectlyBase();
    protected abstract virtual ILanguageFacade get_Language();
    protected abstract virtual string get_MethodStaticMessage();
    protected abstract virtual string get_MethodReturnTypeShouldBeVoidMessage();
    protected abstract virtual Location GetIdentifierLocation(IMethodSymbol methodSymbol);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_AttributeNotConsideredRule();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AttributeNotConsideredRule(DiagnosticDescriptor value);
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool HiddenByEditorBrowsableAttribute(IMethodSymbol methodSymbol);
    private IEnumerable`1<string> FindIssues(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__22_0(SonarSymbolReportingContext c);
    [CompilerGeneratedAttribute]
internal static void <FindIssues>g__Evaluate|24_0(string message, bool condition, <>c__DisplayClass24_0& );
}
public abstract class SonarAnalyzer.Rules.IndexOfCheckAgainstZeroBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static String[] TrackedMethods;
    private static ImmutableArray`1<KnownType> CheckedTypes;
    protected TSyntaxKind LessThanExpression { get; }
    protected TSyntaxKind GreaterThanExpression { get; }
    protected string MessageFormat { get; }
    private static IndexOfCheckAgainstZeroBase`2();
    protected abstract virtual TSyntaxKind get_LessThanExpression();
    protected abstract virtual TSyntaxKind get_GreaterThanExpression();
    protected abstract virtual SyntaxNode Left(TBinaryExpressionSyntax binaryExpression);
    protected abstract virtual SyntaxNode Right(TBinaryExpressionSyntax binaryExpression);
    protected abstract virtual SyntaxToken OperatorToken(TBinaryExpressionSyntax binaryExpression);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsInvalidComparison(SyntaxNode constantExpression, SyntaxNode methodInvocationExpression, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.InsecureEncryptionAlgorithmBase`4 : DoNotCallInsecureSecurityAlgorithmBase`4<TSyntaxKind, TInvocationExpressionSyntax, TArgumentListSyntax, TArgumentSyntax> {
    protected static string DiagnosticId;
    private static string MessageFormat;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <AlgorithmParameterlessFactoryMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <AlgorithmParameterizedFactoryMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <FactoryParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<KnownType> <AlgorithmTypes>k__BackingField;
    protected DiagnosticDescriptor Rule { get; }
    protected ISet`1<string> AlgorithmParameterlessFactoryMethods { get; }
    protected ISet`1<string> AlgorithmParameterizedFactoryMethods { get; }
    protected ISet`1<string> FactoryParameterNames { get; }
    private protected ImmutableArray`1<KnownType> AlgorithmTypes { get; }
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<string> get_AlgorithmParameterlessFactoryMethods();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<string> get_AlgorithmParameterizedFactoryMethods();
    [CompilerGeneratedAttribute]
protected virtual ISet`1<string> get_FactoryParameterNames();
    [CompilerGeneratedAttribute]
private protected virtual ImmutableArray`1<KnownType> get_AlgorithmTypes();
}
public abstract class SonarAnalyzer.Rules.InsecureTemporaryFilesCreationBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private static string VulnerableApiName;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void Visit(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Rules.InsteadOfAnyBase`2 : SonarDiagnosticAnalyzer {
    private static string ExistsDiagnosticId;
    private static string ContainsDiagnosticId;
    private static string MessageFormat;
    private DiagnosticDescriptor existsRule;
    private DiagnosticDescriptor containsRule;
    private static ImmutableArray`1<KnownType> ExistsTypes;
    private static ImmutableArray`1<KnownType> ContainsTypes;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InsteadOfAnyBase`2();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsSimpleEqualityCheck(TInvocationExpression node, SemanticModel model);
    protected abstract virtual SyntaxNode GetArgumentExpression(TInvocationExpression invocation, int index);
    protected abstract virtual bool AreValidOperands(string lambdaVariable, SyntaxNode first, SyntaxNode second);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected bool IsNameEqualTo(SyntaxNode node, string name);
    protected static bool IsValueTypeOrString(SyntaxNode expression, SemanticModel model);
    protected bool HasValidInvocationOperands(TInvocationExpression invocation, string lambdaVariableName, SemanticModel model);
    private static bool IsCorrectCall(SyntaxNode right, SemanticModel model);
    private void RaiseIssue(SonarSyntaxNodeReportingContext c, SyntaxNode invocation, DiagnosticDescriptor rule, string methodName);
    [CompilerGeneratedAttribute]
private void <Initialize>b__15_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <HasValidInvocationOperands>g__HasInvocationValidOperands|18_0(SyntaxNode first, SyntaxNode second, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
private bool <HasValidInvocationOperands>g__IsSystemEquals|18_1(<>c__DisplayClass18_0& );
}
public abstract class SonarAnalyzer.Rules.InvalidCastToInterfaceBase`1 : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static string MessageInterface;
    private static string MessageClass;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected DiagnosticDescriptor Rule { get; }
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual DiagnosticDescriptor get_Rule();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static Dictionary`2<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>> BuildTypeMap(IEnumerable`1<INamedTypeSymbol> allTypes);
    private static bool IsImpossibleCast(Dictionary`2<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>> interfaceImplementers, INamedTypeSymbol interfaceType, INamedTypeSymbol expressionType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarCompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
internal static void <BuildTypeMap>g__Add|11_0(INamedTypeSymbol key, INamedTypeSymbol value, <>c__DisplayClass11_0& );
}
public abstract class SonarAnalyzer.Rules.JwtSignedBase`2 : TrackerHotspotDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static bool JwtBuilderConstructorIsSafe;
    private static string MessageFormat;
    private static int ExtensionStaticCallParameters;
    protected JwtSignedBase`2(IAnalyzerConfiguration configuration);
    protected abstract virtual BuilderPatternCondition`2<TSyntaxKind, TInvocationSyntax> CreateBuilderPatternCondition();
    protected virtual void Initialize(TrackerInput input);
    protected BuilderPatternDescriptor`2[] JwtBuilderDescriptors(Func`2<TInvocationSyntax, bool> singleArgumentIsNotFalseLiteral);
}
public abstract class SonarAnalyzer.Rules.LineLengthBase : ParametrizedDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string MessageFormat;
    private static int DefaultValueMaximum;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    [RuleParameterAttribute("maximumLineLength", "3", "The maximum authorized line length.", "200")]
public int Maximum { get; public set; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected sealed virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxTreeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__9_1(TextLine line);
}
public abstract class SonarAnalyzer.Rules.LinkedListPropertiesInsteadOfMethodsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual bool IsRelevantCallAndType(TInvocationExpression invocation, SemanticModel model);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsRelevantType(SyntaxNode right, SemanticModel model);
    private bool IsFirstOrLast(string methodName);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.LogAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, LogInfo> {
    private static string DiagnosticId;
    private static string Title;
    protected string FileName { get; }
    protected abstract virtual string LanguageVersion(Compilation compilation);
    protected sealed virtual string get_FileName();
    protected virtual UtilityAnalyzerParameters ReadParameters(SonarAnalysisContextBase`1<T> context);
    protected sealed virtual IEnumerable`1<LogInfo> CreateAnalysisMessages(SonarCompilationReportingContext c);
    protected sealed virtual LogInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
    private static LogInfo CreateMessage(SyntaxTree tree);
}
public abstract class SonarAnalyzer.Rules.LoopWalkerBase`2 : object {
    protected SyntaxNode rootExpression;
    protected SemanticModel semanticModel;
    private ISet`1<TLanguageKindEnum> ignoredSyntaxesKind;
    [CompilerGeneratedAttribute]
private List`1<TStatementSyntax> <ConditionalContinues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TStatementSyntax> <ConditionalTerminates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TStatementSyntax> <UnconditionalContinues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TStatementSyntax> <UnconditionalTerminates>k__BackingField;
    protected ILanguageFacade`1<TLanguageKindEnum> Language { get; }
    protected ISet`1<TLanguageKindEnum> ConditionalStatements { get; }
    protected ISet`1<TLanguageKindEnum> StatementsThatCanThrow { get; }
    protected ISet`1<TLanguageKindEnum> LambdaSyntaxes { get; }
    protected ISet`1<TLanguageKindEnum> LocalFunctionSyntaxes { get; }
    protected List`1<TStatementSyntax> ConditionalContinues { get; }
    protected List`1<TStatementSyntax> ConditionalTerminates { get; }
    protected List`1<TStatementSyntax> UnconditionalContinues { get; }
    protected List`1<TStatementSyntax> UnconditionalTerminates { get; }
    protected LoopWalkerBase`2(SonarSyntaxNodeReportingContext context, ISet`1<TLanguageKindEnum> loopStatements);
    protected abstract virtual ILanguageFacade`1<TLanguageKindEnum> get_Language();
    protected abstract virtual ISet`1<TLanguageKindEnum> get_ConditionalStatements();
    protected abstract virtual ISet`1<TLanguageKindEnum> get_StatementsThatCanThrow();
    protected abstract virtual ISet`1<TLanguageKindEnum> get_LambdaSyntaxes();
    protected abstract virtual ISet`1<TLanguageKindEnum> get_LocalFunctionSyntaxes();
    public abstract virtual void Visit();
    protected abstract virtual bool TryGetTryAncestorStatements(TStatementSyntax node, List`1<SyntaxNode> ancestors, IEnumerable`1& tryAncestorStatements);
    protected abstract virtual bool IsPropertyAccess(TStatementSyntax node);
    [CompilerGeneratedAttribute]
protected List`1<TStatementSyntax> get_ConditionalContinues();
    [CompilerGeneratedAttribute]
protected List`1<TStatementSyntax> get_ConditionalTerminates();
    [CompilerGeneratedAttribute]
protected List`1<TStatementSyntax> get_UnconditionalContinues();
    [CompilerGeneratedAttribute]
protected List`1<TStatementSyntax> get_UnconditionalTerminates();
    public List`1<TStatementSyntax> GetRuleViolations();
    protected void StoreVisitData(TStatementSyntax node, List`1<TStatementSyntax> conditionalCollection, List`1<TStatementSyntax> unconditionalCollection);
    private bool IsInTryCatchWithStatementThatCanThrow(TStatementSyntax node, List`1<SyntaxNode> ancestors);
    [CompilerGeneratedAttribute]
private bool <StoreVisitData>b__30_0(SyntaxNode n);
    [CompilerGeneratedAttribute]
private bool <StoreVisitData>b__30_1(SyntaxNode n);
    [CompilerGeneratedAttribute]
private bool <StoreVisitData>b__30_2(SyntaxNode n);
}
public abstract class SonarAnalyzer.Rules.LooseFilePermissionsBase`1 : HotspotDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string Everyone;
    private static string MessageFormat;
    protected DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected LooseFilePermissionsBase`1(IAnalyzerConfiguration configuration);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual void VisitAssignments(SonarSyntaxNodeReportingContext context);
    protected abstract virtual void VisitInvocations(SonarSyntaxNodeReportingContext context);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected bool IsFileAccessPermissions(SyntaxNode syntaxNode, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(SonarCompilationStartAnalysisContext c);
}
public static class SonarAnalyzer.Rules.LooseFilePermissionsConfig : object {
    public static ImmutableHashSet`1<string> WeakFileAccessPermissions;
    private static LooseFilePermissionsConfig();
}
public abstract class SonarAnalyzer.Rules.MarkAssemblyWithAssemblyVersionAttributeBase : MarkAssemblyWithAttributeBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private protected KnownType AttributeToFind { get; }
    private protected virtual KnownType get_AttributeToFind();
}
public abstract class SonarAnalyzer.Rules.MarkAssemblyWithAttributeBase : SonarDiagnosticAnalyzer {
    private DiagnosticDescriptor rule;
    protected ILanguageFacade Language { get; }
    private protected KnownType AttributeToFind { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected bool EnableConcurrentExecution { get; }
    protected MarkAssemblyWithAttributeBase(string diagnosticId, string messageFormat);
    protected abstract virtual ILanguageFacade get_Language();
    private protected abstract virtual KnownType get_AttributeToFind();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool get_EnableConcurrentExecution();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarCompilationStartAnalysisContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_1(SonarCompilationReportingContext cc);
}
public abstract class SonarAnalyzer.Rules.MarkAssemblyWithClsCompliantAttributeBase : MarkAssemblyWithAttributeBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private protected KnownType AttributeToFind { get; }
    private protected virtual KnownType get_AttributeToFind();
}
public abstract class SonarAnalyzer.Rules.MarkAssemblyWithComVisibleAttributeBase : MarkAssemblyWithAttributeBase {
    private static string DiagnosticId;
    private static string MessageFormat;
    private protected KnownType AttributeToFind { get; }
    private protected virtual KnownType get_AttributeToFind();
}
public abstract class SonarAnalyzer.Rules.MarkWindowsFormsMainWithStaThreadBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static string AddStaThreadMessage;
    private static string ChangeMtaThreadToStaThreadMessage;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual Location GetLocation(TMethodSyntax method);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void Action(SonarSyntaxNodeReportingContext c);
    private static bool IsAssemblyReferencingWindowsForms(Compilation compilation);
}
public abstract class SonarAnalyzer.Rules.MethodOverloadsShouldBeGroupedBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual IEnumerable`1<TMemberDeclarationSyntax> GetMemberDeclarations(SyntaxNode node);
    protected abstract virtual MemberInfo<TSyntaxKind, TMemberDeclarationSyntax> CreateMemberInfo(SonarSyntaxNodeReportingContext c, TMemberDeclarationSyntax member);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected List`1[] GetMisplacedOverloads(SonarSyntaxNodeReportingContext c, IEnumerable`1<TMemberDeclarationSyntax> members);
    private static Dictionary`2<TMemberDeclarationSyntax, ImmutableArray`1<INamedTypeSymbol>> MembersGroupedByInterface(SonarSyntaxNodeReportingContext c, IEnumerable`1<TMemberDeclarationSyntax> members);
    private static ImmutableArray`1<INamedTypeSymbol> FindInterfaces(SemanticModel semanticModel, TMemberDeclarationSyntax member);
    private static IEnumerable`1<ISymbol> ExplicitInterfaceImplementations(ISymbol symbol);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.MethodParameterUnusedBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.MethodsShouldNotHaveIdenticalImplementationsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual IEnumerable`1<TMethodDeclarationSyntax> GetMethodDeclarations(SyntaxNode node);
    protected abstract virtual SyntaxToken GetMethodIdentifier(TMethodDeclarationSyntax method);
    protected abstract virtual bool AreDuplicates(SemanticModel model, TMethodDeclarationSyntax firstMethod, TMethodDeclarationSyntax secondMethod);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool IsExcludedFromBeingExamined(SonarSyntaxNodeReportingContext context);
    protected static bool HaveSameParameters(Nullable`1<SeparatedSyntaxList`1<TSyntax>> leftParameters, Nullable`1<SeparatedSyntaxList`1<TSyntax>> rightParameters);
    protected static bool HaveSameTypeParameters(SemanticModel model, Nullable`1<SeparatedSyntaxList`1<TSyntax>> firstTypeParameterList, Nullable`1<SeparatedSyntaxList`1<TSyntax>> secondTypeParameterList);
    private static bool HaveSameParameterLists(SeparatedSyntaxList`1<TSyntax> firstParameters, SeparatedSyntaxList`1<TSyntax> secondParameters);
    private static bool TypeParametersHaveSameNameAndConstraints(ITypeParameterSymbol first, ITypeParameterSymbol second);
    private static bool TypeConstraintsAreSame(ITypeSymbol first, ITypeSymbol second);
    private static bool TypesAreSameGenericType(ITypeSymbol firstParameterType, ITypeSymbol secondParameterType);
    private static bool AreSameNamedTypeParameters(ITypeSymbol first, ITypeSymbol second);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.MethodsShouldNotHaveTooManyLinesBase`2 : ParametrizedDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    private static int DefaultMaxMethodLines;
    [CompilerGeneratedAttribute]
private int <Max>k__BackingField;
    [RuleParameterAttribute("max", "3", "Maximum authorized lines of code in a method", "80")]
public int Max { get; public set; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MethodKeyword { get; }
    [CompilerGeneratedAttribute]
public int get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(int value);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual string get_MethodKeyword();
    protected abstract virtual IEnumerable`1<SyntaxToken> GetMethodTokens(TBaseMethodSyntax baseMethodDeclaration);
    protected abstract virtual Nullable`1<SyntaxToken> GetMethodIdentifierToken(TBaseMethodSyntax baseMethodDeclaration);
    protected abstract virtual string GetMethodKindAndName(SyntaxToken identifierToken);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__16_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.MetricsAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, MetricsInfo> {
    private static string DiagnosticId;
    private static string Title;
    protected string FileName { get; }
    protected abstract virtual MetricsBase GetMetrics(SyntaxTree syntaxTree, SemanticModel semanticModel);
    protected sealed virtual string get_FileName();
    protected virtual UtilityAnalyzerParameters ReadParameters(SonarAnalysisContextBase`1<T> context);
    protected sealed virtual MetricsInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
}
public abstract class SonarAnalyzer.Rules.MultipleVariableDeclarationBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static void CheckAndReportVariables(SonarSyntaxNodeReportingContext context, DiagnosticDescriptor rule, ICollection`1<SyntaxToken> variables);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.MultipleVariableDeclarationCodeFixBase : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected sealed virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    protected abstract virtual SyntaxNode CalculateNewRoot(SyntaxNode root, SyntaxNode node);
}
public static class SonarAnalyzer.Rules.MultipleVariableDeclarationConstants : object {
    internal static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.NameOfShouldBeUsedBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static int MinStringLength;
    private Char[] separators;
    protected string NameOf { get; }
    protected string MessageFormat { get; }
    protected abstract virtual string get_NameOf();
    protected abstract virtual IEnumerable`1<string> GetParameterNames(TMethodSyntax method);
    protected abstract virtual bool IsStringLiteral(SyntaxToken t);
    protected abstract virtual bool LeastLanguageVersionMatches(SonarSyntaxNodeReportingContext context);
    protected abstract virtual bool IsArgumentExceptionCallingNameOf(SyntaxNode node, IEnumerable`1<string> arguments);
    protected abstract virtual TMethodSyntax MethodSyntax(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected int ArgumentExceptionNameOfPosition(string name);
    private void ReportIssues(SonarSyntaxNodeReportingContext context);
    private Dictionary`2<SyntaxToken, string> GetStringTokenAndParamNamePairs(IEnumerable`1<SyntaxToken> tokens, IEnumerable`1<string> parameterNames);
}
public abstract class SonarAnalyzer.Rules.NoExceptionsInFinallyBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
}
public abstract class SonarAnalyzer.Rules.NonAsyncTaskShouldNotReturnNullBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static ImmutableArray`1<KnownType> TaskTypes;
    private static NonAsyncTaskShouldNotReturnNullBase();
    protected static bool IsInvalidEnclosingSymbolContext(SyntaxNode enclosingMember, SemanticModel model);
    private static bool IsTaskReturnType(ISymbol symbol, IMethodSymbol methodSymbol);
    private static bool IsSafeTaskReturnType(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <IsTaskReturnType>g__GetReturnType|3_0(<>c__DisplayClass3_0& );
}
public abstract class SonarAnalyzer.Rules.ObsoleteAttributesBase`1 : SonarDiagnosticAnalyzer {
    private static string ExplanationNeededDiagnosticId;
    private static string ExplanationNeededMessageFormat;
    private static string RemoveDiagnosticId;
    private static string RemoveMessageFormat;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <ExplanationNeededRule>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <RemoveRule>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal DiagnosticDescriptor ExplanationNeededRule { get; }
    internal DiagnosticDescriptor RemoveRule { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual SyntaxNode GetExplanationExpression(SyntaxNode node);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
internal DiagnosticDescriptor get_ExplanationNeededRule();
    [CompilerGeneratedAttribute]
internal DiagnosticDescriptor get_RemoveRule();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool NoExplanation(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__17_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.OptionalParameterBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
public abstract class SonarAnalyzer.Rules.OptionalParameterBase`3 : OptionalParameterBase {
    public ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static bool HasAllowedAttribute(TParameterSyntax parameterSyntax, SemanticModel semanticModel);
    protected abstract virtual IEnumerable`1<TParameterSyntax> GetParameters(TMethodSyntax method);
    protected abstract virtual bool IsOptional(TParameterSyntax parameter);
    protected abstract virtual Location GetReportLocation(TParameterSyntax parameter);
    public abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.OptionalParameterNotPassedToBaseCallBase`1 : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected DiagnosticDescriptor Rule { get; }
    protected void ReportOptionalParameterNotPassedToBase(SonarSyntaxNodeReportingContext c, TInvocationExpressionSyntax invocation);
    protected abstract virtual int GetArgumentCount(TInvocationExpressionSyntax invocation);
    protected abstract virtual DiagnosticDescriptor get_Rule();
    protected static bool IsCallInsideOverride(SyntaxNode invocation, IMethodSymbol calledMethod, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.ParameterAssignedToBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual bool IsAssignmentToCatchVariable(ISymbol symbol, SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool IsReadBefore(SemanticModel semanticModel, ISymbol parameterSymbol, SyntaxNode assignment);
    private static IEnumerable`1<SyntaxNode> GetPreviousNodes(Location stopLocation, SyntaxNode statement);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ParameterNameMatchesOriginalBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual IEnumerable`1<SyntaxToken> ParameterIdentifiers(TMethodDeclarationSyntax method);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void VerifyParameters(SonarSyntaxNodeReportingContext context, TMethodDeclarationSyntax methodSyntax, IList`1<IParameterSymbol> expectedParameters, string expectedLocation);
    private void VerifyGenericParameters(SonarSyntaxNodeReportingContext context, TMethodDeclarationSyntax methodSyntax, IList`1<IParameterSymbol> actualParameters, IList`1<IParameterSymbol> expectedParameters, string expectedLocation);
    private static bool AreGenericTypeParametersWithDifferentTypes(ITypeSymbol actualType, ITypeSymbol expectedType);
    private static bool AreTypeArgumentsDifferent(INamedTypeSymbol namedType, INamedTypeSymbol otherNamedType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <VerifyParameters>b__8_1(<>f__AnonymousType6`2<SyntaxToken, IParameterSymbol> x);
}
public abstract class SonarAnalyzer.Rules.ParametersCorrectOrderBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind[] InvocationKinds { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind[] get_InvocationKinds();
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected virtual Location PrimaryLocation(SyntaxNode node);
    private bool MatchingNames(IParameterSymbol parameter, string argumentName);
    private string ArgumentName(SyntaxNode argument);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private SecondaryLocation <Initialize>b__6_3(SyntaxReference x);
}
public abstract class SonarAnalyzer.Rules.PartCreationPolicyShouldBeUsedWithExportAttributeBase`2 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected abstract virtual TDeclarationSyntax GetTypeDeclaration(TAttributeSyntax attribute);
    protected void AnalyzeNode(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeNode>g__IsPartCreationPolicyAttribute|3_1(TAttributeSyntax attributeSyntax, <>c__DisplayClass3_0& );
}
public abstract class SonarAnalyzer.Rules.PreferGuidEmptyBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsInvalidCtor(SyntaxNode ctorNode, SemanticModel semanticModel);
    private bool IsInParameter(SyntaxNode defaultExpression);
    private static bool CreatesEmptyGuid(SyntaxNode[] arguments, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <IsInParameter>b__6_0(SyntaxNode x);
}
public abstract class SonarAnalyzer.Rules.PropertiesAccessCorrectFieldBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual IEnumerable`1<FieldData<TSyntaxKind>> FindFieldAssignments(IPropertySymbol property, Compilation compilation);
    protected abstract virtual IEnumerable`1<FieldData<TSyntaxKind>> FindFieldReads(IPropertySymbol property, Compilation compilation);
    protected abstract virtual bool ImplementsExplicitGetterOrSetter(IPropertySymbol property);
    protected abstract virtual bool ShouldIgnoreAccessor(IMethodSymbol accessorMethod, Compilation compilation);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static SyntaxNode FindInvokedMethod(Compilation compilation, INamedTypeSymbol containingType, SyntaxNode expression);
    private void CheckType(SonarSymbolReportingContext context);
    private static IEnumerable`1<IFieldSymbol> SelfAndBaseTypesFieldSymbols(INamedTypeSymbol typeSymbol);
    private IEnumerable`1<IPropertySymbol> GetExplicitlyDeclaredProperties(INamedTypeSymbol symbol);
    private void CheckExpectedFieldIsUsed(SonarSymbolReportingContext context, IMethodSymbol methodSymbol, IFieldSymbol expectedField, ImmutableArray`1<FieldData<TSyntaxKind>> actualFields);
    private IList`1<PropertyData<TSyntaxKind>> CollectPropertyData(IEnumerable`1<IPropertySymbol> properties, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Location, string> <CheckExpectedFieldIsUsed>g__GetLocationAndAccessor|13_1(ImmutableArray`1<FieldData<TSyntaxKind>> fields, IMethodSymbol method);
}
public abstract class SonarAnalyzer.Rules.PropertyGetterWithThrowBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    internal static ImmutableArray`1<KnownType> AllowedExceptionBaseTypes;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    private static PropertyGetterWithThrowBase();
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
public abstract class SonarAnalyzer.Rules.PropertyGetterWithThrowBase`2 : PropertyGetterWithThrowBase {
    protected TLanguageKindEnum ThrowSyntaxKind { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual bool IsIndexer(TAccessorSyntax propertyGetter);
    protected abstract virtual bool IsGetter(TAccessorSyntax propertyGetter);
    protected abstract virtual TLanguageKindEnum get_ThrowSyntaxKind();
    protected abstract virtual SyntaxNode GetThrowExpression(SyntaxNode syntaxNode);
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_0(SonarCodeBlockStartAnalysisContext`1<TLanguageKindEnum> cbc);
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.PropertyWriteOnlyBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected TSyntaxKind SyntaxKind { get; }
    protected string MessageFormat { get; }
    protected abstract virtual TSyntaxKind get_SyntaxKind();
    protected abstract virtual bool IsWriteOnlyProperty(TPropertyDeclaration prop);
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ProvideDeserializationMethodsForOptionalFieldsBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    private static string MessageFormat;
    private static string BothDeserializationMethodsMissing;
    private static string OnDeserializedMethodMissing;
    private static string OnDeserializingMethodMissing;
    private static ImmutableArray`1<KnownType> AttributesToFind;
    private DiagnosticDescriptor rule;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvideDeserializationMethodsForOptionalFieldsBase();
    protected abstract virtual ILanguageFacade get_Language();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual Location GetNamedTypeIdentifierLocation(SyntaxNode node);
    private static string GetErrorMessage(IReadOnlyCollection`1<AttributeData> attributes);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_0(SonarSymbolReportingContext c);
}
public abstract class SonarAnalyzer.Rules.PublicConstantFieldBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
public abstract class SonarAnalyzer.Rules.PublicConstantFieldBase`3 : PublicConstantFieldBase {
    public TLanguageKindEnum FieldDeclarationKind { get; }
    public string MessageArgument { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual IEnumerable`1<TFieldName> GetVariables(TFieldDeclarationSyntax node);
    public abstract virtual TLanguageKindEnum get_FieldDeclarationKind();
    public abstract virtual string get_MessageArgument();
    protected abstract virtual Location GetReportLocation(TFieldName node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.PubliclyWritableDirectoriesBase`2 : HotspotDiagnosticAnalyzer {
    protected static string DiagnosticId;
    private static string MessageFormat;
    private static RegexOptions WindowsAndUnixOptions;
    [CompilerGeneratedAttribute]
private static String[] <InsecureEnvironmentVariables>k__BackingField;
    private static Regex UserProfile;
    private static Regex LinuxDirectories;
    private static Regex MacDirectories;
    private static Regex WindowsDirectories;
    private static Regex EnvironmentVariables;
    private DiagnosticDescriptor rule;
    protected static String[] InsecureEnvironmentVariables { get; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PubliclyWritableDirectoriesBase`2();
    protected PubliclyWritableDirectoriesBase`2(IAnalyzerConfiguration configuration);
    [CompilerGeneratedAttribute]
protected static String[] get_InsecureEnvironmentVariables();
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    private protected abstract virtual bool IsGetTempPathAssignment(TInvocationExpression invocationExpression, KnownType type, string methodName, SemanticModel semanticModel);
    private protected abstract virtual bool IsInsecureEnvironmentVariableRetrieval(TInvocationExpression invocation, KnownType type, string methodName, SemanticModel semanticModel);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsSensitiveDirectoryUsage(string directory);
    private static String[] LinuxDirs();
    private static String[] MacDirs();
    [CompilerGeneratedAttribute]
private void <Initialize>b__20_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__20_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.PublicMethodWithMultidimensionalArrayBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected ImmutableArray`1<TSyntaxKind> SyntaxKindsOfInterest { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual ImmutableArray`1<TSyntaxKind> get_SyntaxKindsOfInterest();
    protected abstract virtual Location GetIssueLocation(SyntaxNode node);
    protected abstract virtual string GetType(SyntaxNode node);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected virtual IMethodSymbol MethodSymbolOfNode(SemanticModel semanticModel, SyntaxNode node);
    private static bool MethodHasMultidimensionalArrayParameters(IMethodSymbol methodSymbol);
    private static bool IsMultidimensionalArrayParameter(IParameterSymbol param);
    private static bool IsJaggedArrayParam(IParameterSymbol param, IArrayTypeSymbol arrayType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.PureAttributeOnVoidMethodBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static AttributeData InvalidPureDataAttributeUsage(IMethodSymbol method);
    private static bool NoOutParameters(IMethodSymbol method);
    private static bool ReturnsTask(IMethodSymbol method);
    private static AttributeData GetPureAttribute(IMethodSymbol method);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSymbolReportingContext c);
}
public abstract class SonarAnalyzer.Rules.RedundantNullCheckBase`1 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected abstract virtual SyntaxNode GetLeftNode(TBinaryExpression binaryExpression);
    protected abstract virtual SyntaxNode GetRightNode(TBinaryExpression binaryExpression);
    protected abstract virtual SyntaxNode GetNullCheckVariable(SyntaxNode node);
    protected abstract virtual SyntaxNode GetNonNullCheckVariable(SyntaxNode node);
    protected abstract virtual SyntaxNode GetIsOperatorCheckVariable(SyntaxNode node);
    protected abstract virtual SyntaxNode GetInvertedIsOperatorCheckVariable(SyntaxNode node);
    protected abstract virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    protected void CheckAndExpression(SonarSyntaxNodeReportingContext context);
    protected void CheckOrExpression(SonarSyntaxNodeReportingContext context);
}
public abstract class SonarAnalyzer.Rules.RedundantParenthesesBase`2 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected TSyntaxKind ParenthesizedExpressionSyntaxKind { get; }
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual TSyntaxKind get_ParenthesizedExpressionSyntaxKind();
    protected abstract virtual SyntaxNode GetExpression(TParenthesizedExpression parenthesizedExpression);
    protected abstract virtual SyntaxToken GetOpenParenToken(TParenthesizedExpression parenthesizedExpression);
    protected abstract virtual SyntaxToken GetCloseParenToken(TParenthesizedExpression parenthesizedExpression);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.RedundantParenthesesBase`2/<GetSelfAndDescendantParenthesizedExpressions>d__10")]
protected IEnumerable`1<TParenthesizedExpression> GetSelfAndDescendantParenthesizedExpressions(TParenthesizedExpression expression);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.RegexMustHaveValidSyntaxBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected sealed virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void Analyze(SonarSyntaxNodeReportingContext c, RegexContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_2(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.RequestsWithExcessiveLengthBase`2 : ParametrizedDiagnosticAnalyzer {
    protected static string MultipartBodyLengthLimit;
    private static string DiagnosticId;
    private static string RequestSizeLimit;
    private static string RequestSizeLimitAttribute;
    private static string DisableRequestSizeLimit;
    private static string DisableRequestSizeLimitAttribute;
    private static string RequestFormLimits;
    private static string RequestFormLimitsAttribute;
    private static string MessageFormat;
    private static string Attribute;
    private static int DefaultFileUploadSizeLimit;
    private static int OneKilobyte;
    private IAnalyzerConfiguration analyzerConfiguration;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <FileUploadSizeLimit>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("fileUploadSizeLimit", "3", "The maximum size of HTTP requests handling file uploads (in bytes).", "8388608")]
public int FileUploadSizeLimit { get; public set; }
    protected bool EnableConcurrentExecution { get; }
    protected RequestsWithExcessiveLengthBase`2(IAnalyzerConfiguration analyzerConfiguration);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual TAttributeSyntax IsInvalidRequestFormLimits(TAttributeSyntax attribute, SemanticModel semanticModel);
    protected abstract virtual TAttributeSyntax IsInvalidRequestSizeLimit(TAttributeSyntax attribute, SemanticModel semanticModel);
    protected abstract virtual SyntaxNode GetMethodLocalFunctionOrClassDeclaration(TAttributeSyntax attribute);
    protected abstract virtual string AttributeName(TAttributeSyntax attribute);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_FileUploadSizeLimit();
    [CompilerGeneratedAttribute]
public void set_FileUploadSizeLimit(int value);
    protected virtual bool get_EnableConcurrentExecution();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected bool IsRequestFormLimits(string attributeName);
    protected bool IsRequestSizeLimit(string attributeName);
    private void CollectAttributesOverTheLimit(SonarSyntaxNodeReportingContext context, IDictionary`2<SyntaxNode, Attributes<TSyntaxKind, TAttributeSyntax>> attributesOverTheLimit);
    private void ReportOnCollectedAttributes(SonarCompilationReportingContext context, IDictionary`2<SyntaxNode, Attributes<TSyntaxKind, TAttributeSyntax>> attributesOverTheLimit);
    private bool IsDisableRequestSizeLimit(string attributeName);
    private bool IsEnabled(AnalyzerOptions options);
    private void CheckWebConfig(SonarCompilationReportingContext c);
    private void ReportRequestLengthViolation(SonarCompilationReportingContext c, XDocument doc, string webConfigPath);
    private static bool IsVulnerable(string value, int limit);
    [CompilerGeneratedAttribute]
private void <Initialize>b__29_0(SonarCompilationStartAnalysisContext c);
    [CompilerGeneratedAttribute]
private bool <IsEnabled>b__35_0(DiagnosticDescriptor d);
}
public abstract class SonarAnalyzer.Rules.ReversedOperatorsBase`1 : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected abstract virtual SyntaxToken GetOperatorToken(TUnaryExpressionSyntax e);
    protected abstract virtual bool IsEqualsToken(SyntaxToken token);
    protected abstract virtual bool IsMinusToken(SyntaxToken token);
    private static bool TiedTogether(FileLinePositionSpan left, FileLinePositionSpan right);
    protected Action`1<SonarSyntaxNodeReportingContext> GetAnalysisAction(DiagnosticDescriptor rule);
}
public abstract class SonarAnalyzer.Rules.RouteTemplateShouldNotStartWithSlashBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static string MessageOnlyActions;
    private static string MessageActionsAndController;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void ReportIssues(SonarSymbolReportingContext context, INamedTypeSymbol controllerSymbol, ConcurrentStack`1<ActionParametersInfo<TSyntaxKind>> actions);
    private static Dictionary`2<Location, string> RouteAttributeTemplateArguments(ImmutableArray`1<AttributeData> attributes);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarCompilationStartAnalysisContext compilationStartContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_1(SonarSymbolStartAnalysisContext symbolStartContext);
    [CompilerGeneratedAttribute]
private Nullable`1<SyntaxToken> <ReportIssues>b__7_4(SyntaxReference x);
}
[ObsoleteAttribute("This rule has been deprecated since 9.18")]
public abstract class SonarAnalyzer.Rules.SecurityPInvokeMethodShouldNotBeCalledBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string InteropName;
    protected static string InteropDllName;
    [CompilerGeneratedAttribute]
private ISet`1<string> <InvalidMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected ISet`1<string> InvalidMethods { get; }
    protected abstract virtual IMethodSymbol MethodSymbolForInvalidInvocation(SyntaxNode syntaxNode, SemanticModel semanticModel);
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected ISet`1<string> get_InvalidMethods();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool IsImportFromInteropDll(IMethodSymbol symbol, SemanticModel semanticModel);
    protected virtual string GetMethodName(ISymbol symbol, SemanticModel semanticModel);
    protected static bool IsInterop(string dllName);
    private void CheckForIssue(SonarSyntaxNodeReportingContext analysisContext);
}
public abstract class SonarAnalyzer.Rules.SelfAssignmentBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
}
public abstract class SonarAnalyzer.Rules.SetPropertiesInsteadOfMethodsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static ImmutableArray`1<KnownType> TargetTypes;
    protected string MessageFormat { get; }
    private static SetPropertiesInsteadOfMethodsBase`2();
    protected virtual string get_MessageFormat();
    protected abstract virtual bool HasCorrectArgumentCount(TInvocation invocation);
    protected abstract virtual bool TryGetOperands(TInvocation invocation, SyntaxNode& typeNode, SyntaxNode& methodNode);
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool HasCorrectName(string methodName);
    private static bool IsCorrectType(SyntaxNode node, SemanticModel model);
    private static bool IsCorrectCall(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ShiftDynamicNotIntegerBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected abstract virtual bool CanBeConvertedTo(SyntaxNode expression, ITypeSymbol type, SemanticModel semanticModel);
    protected abstract virtual bool ShouldRaise(SemanticModel semanticModel, SyntaxNode left, SyntaxNode right);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected void CheckExpressionWithTwoParts(SonarSyntaxNodeReportingContext context, Func`2<SyntaxNode, SyntaxNode> getLeft, Func`2<SyntaxNode, SyntaxNode> getRight);
    private static string GetTypeNameForMessage(SyntaxNode expression, ITypeSymbol typeOfRight, SemanticModel semanticModel);
    private static bool IsErrorType(SyntaxNode expression, SemanticModel semanticModel, ITypeSymbol& type);
    protected bool IsConvertibleToInt(SyntaxNode expression, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private SyntaxNode <Initialize>b__6_2(SyntaxNode b);
    [CompilerGeneratedAttribute]
private SyntaxNode <Initialize>b__6_3(SyntaxNode b);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private SyntaxNode <Initialize>b__6_4(SyntaxNode b);
    [CompilerGeneratedAttribute]
private SyntaxNode <Initialize>b__6_5(SyntaxNode b);
}
public abstract class SonarAnalyzer.Rules.ShouldImplementExportedInterfacesBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static string ActionForInterface;
    private static string ActionForClass;
    private ImmutableArray`1<KnownType> exportAttributes;
    protected string MessageFormat { get; }
    protected abstract virtual Nullable`1<SeparatedSyntaxList`1<TArgumentSyntax>> GetAttributeArguments(TAttributeSyntax attributeSyntax);
    protected abstract virtual SyntaxNode GetAttributeName(TAttributeSyntax attributeSyntax);
    protected abstract virtual bool IsClassOrRecordSyntax(SyntaxNode syntaxNode);
    protected abstract virtual SyntaxNode GetTypeOfOrGetTypeExpression(SyntaxNode expressionSyntax);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool IsOfExportType(ITypeSymbol type, INamedTypeSymbol exportedType);
    private INamedTypeSymbol GetExportedTypeSymbol(Nullable`1<SeparatedSyntaxList`1<TArgumentSyntax>> attributeArguments, SemanticModel semanticModel);
    private ITypeSymbol GetAttributeTargetSymbol(SyntaxNode syntaxNode, SemanticModel semanticModel);
    private TArgumentSyntax GetArgumentFromNamedArgument(IEnumerable`1<TArgumentSyntax> arguments);
    private TArgumentSyntax GetArgumentFromDoubleArgumentAttribute(SeparatedSyntaxList`1<TArgumentSyntax> arguments, SemanticModel semanticModel);
    private static TArgumentSyntax GetArgumentFromSingleArgumentAttribute(SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <GetArgumentFromNamedArgument>b__15_0(TArgumentSyntax x);
}
public abstract class SonarAnalyzer.Rules.SingleStatementPerLineBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual bool StatementShouldBeExcluded(TStatementSyntax statement);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static Location CalculateLocationForLine(TextLine line, SyntaxTree tree, ICollection`1<TStatementSyntax> statements);
    private void AddStatementToLineCache(TStatementSyntax statement, MultiValueDictionary`2<int, TStatementSyntax> statementsByLines);
    private TStatementSyntax GetContainingStatement(SyntaxToken token);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxTreeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__7_1(TStatementSyntax st);
}
public abstract class SonarAnalyzer.Rules.SpecifyTimeoutOnRegexBase`1 : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static int NonBacktracking;
    private String[] matchMethods;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected string MessageFormat { get; }
    private DiagnosticDescriptor Rule { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected SpecifyTimeoutOnRegexBase`1(IAnalyzerConfiguration config);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected virtual string get_MessageFormat();
    private DiagnosticDescriptor get_Rule();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool RegexMethodLacksTimeout(SyntaxNode node, SemanticModel model);
    private static bool ContainsMatchTimeout(IMethodSymbol method);
    private bool NoBacktracking(IMethodSymbol method, SyntaxNode node, SemanticModel model);
    private bool IsCandidateCtor(SyntaxNode ctorNode);
    private bool IsRegexMatchMethod(string name);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.StringConcatenationInLoopBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected string MessageFormat { get; }
    protected TSyntaxKind[] CompoundAssignmentKinds { get; }
    protected ISet`1<TSyntaxKind> ExpressionConcatenationKinds { get; }
    protected ISet`1<TSyntaxKind> LoopKinds { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual TSyntaxKind[] get_CompoundAssignmentKinds();
    protected abstract virtual ISet`1<TSyntaxKind> get_ExpressionConcatenationKinds();
    protected abstract virtual ISet`1<TSyntaxKind> get_LoopKinds();
    protected virtual void Initialize(SonarAnalysisContext context);
    private void CheckSimpleAssignment(SonarSyntaxNodeReportingContext context);
    private void CheckCompoundAssignment(SonarSyntaxNodeReportingContext context);
    private bool IsIdentifierOnTheRight(SyntaxNode identifier, SyntaxNode expression);
    private static bool IsSystemString(SyntaxNode node, SemanticModel semanticModel);
    private bool TryGetNearestLoop(SyntaxNode node, SyntaxNode& nearestLoop);
    private bool AreNotDefinedInTheSameLoop(SyntaxNode expression, SyntaxNode assignment, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.StringLiteralShouldNotBeDuplicatedBase`2 : ParametrizedDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private static int MinimumStringLength;
    private static int ThresholdDefaultValue;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected TSyntaxKind[] SyntaxKinds { get; }
    [RuleParameterAttribute("threshold", "3", "Number of times a literal must be duplicated to trigger an issue.", "3")]
public int Threshold { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual bool IsMatchingMethodParameterName(TLiteralExpressionSyntax literalExpression);
    protected abstract virtual bool IsInnerInstance(SonarSyntaxNodeReportingContext context);
    protected abstract virtual IEnumerable`1<TLiteralExpressionSyntax> FindLiteralExpressions(SyntaxNode node);
    protected abstract virtual SyntaxToken LiteralToken(TLiteralExpressionSyntax literal);
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(int value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected virtual bool IsNamedTypeOrTopLevelMain(SonarSyntaxNodeReportingContext context);
    protected static bool IsNamedType(SonarSyntaxNodeReportingContext context);
    private void ReportOnViolation(SonarSyntaxNodeReportingContext context);
    private static string ExtractStringContent(SyntaxToken literalToken);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType7`2<TLiteralExpressionSyntax, SyntaxToken> <ReportOnViolation>b__23_0(TLiteralExpressionSyntax x);
    [CompilerGeneratedAttribute]
private bool <ReportOnViolation>b__23_1(<>f__AnonymousType7`2<TLiteralExpressionSyntax, SyntaxToken> x);
    [CompilerGeneratedAttribute]
private bool <ReportOnViolation>b__23_4(IGrouping`2<string, SyntaxToken> x);
}
public abstract class SonarAnalyzer.Rules.SwitchCasesMinimumThreeBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.SwitchSectionShouldNotHaveTooManyStatementsBase : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static int ThresholdDefaultValue;
    [CompilerGeneratedAttribute]
private int <Threshold>k__BackingField;
    [RuleParameterAttribute("max", "3", "Maximum number of statements.", "8")]
public int Threshold { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(int value);
}
public abstract class SonarAnalyzer.Rules.SwitchShouldNotBeNestedBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.SwitchWithoutDefaultBase : SonarDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
}
public abstract class SonarAnalyzer.Rules.SwitchWithoutDefaultBase`1 : SwitchWithoutDefaultBase {
    public ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual bool TryGetDiagnostic(SyntaxNode node, Diagnostic& diagnostic);
    public abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.SymbolicExecutionRunnerBase : SonarDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private IAnalyzerConfiguration <Configuration>k__BackingField;
    protected ImmutableDictionary`2<DiagnosticDescriptor, RuleFactory> AllRules { get; }
    protected SyntaxClassifierBase SyntaxClassifier { get; }
    protected IAnalyzerConfiguration Configuration { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected bool EnableConcurrentExecution { get; }
    private protected SymbolicExecutionRunnerBase(IAnalyzerConfiguration configuration);
    protected abstract virtual ImmutableDictionary`2<DiagnosticDescriptor, RuleFactory> get_AllRules();
    protected abstract virtual ControlFlowGraph CreateCfg(SemanticModel model, SyntaxNode node, CancellationToken cancel);
    protected abstract virtual void AnalyzeSonar(SonarSyntaxNodeReportingContext context, ISymbol symbol);
    protected abstract virtual SyntaxClassifierBase get_SyntaxClassifier();
    [CompilerGeneratedAttribute]
protected IAnalyzerConfiguration get_Configuration();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool get_EnableConcurrentExecution();
    protected static RuleFactory CreateFactory();
    protected static RuleFactory CreateFactory();
    protected void Analyze(SonarAnalysisContext analysisContext, SonarSyntaxNodeReportingContext nodeContext);
    protected void Analyze(SonarAnalysisContext analysisContext, SonarSyntaxNodeReportingContext nodeContext, ISymbol symbol);
    private void AnalyzeRoslyn(SonarAnalysisContext analysisContext, SonarSyntaxNodeReportingContext nodeContext, ISymbol symbol);
}
public abstract class SonarAnalyzer.Rules.SymbolReferenceAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, SymbolReferenceInfo> {
    private static string DiagnosticId;
    private static string Title;
    private static int TokenCountThreshold;
    protected string FileName { get; }
    protected sealed virtual string get_FileName();
    protected abstract virtual SyntaxNode GetBindableParent(SyntaxToken token);
    protected abstract virtual ReferenceInfo[] CreateDeclarationReferenceInfo(SyntaxNode node, SemanticModel model);
    protected abstract virtual IList`1<SyntaxNode> GetDeclarations(SyntaxNode node);
    protected sealed virtual SymbolReferenceInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
    protected sealed virtual bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    private Dictionary`2<ISymbol, List`1<ReferenceInfo<TSyntaxKind>>> GetReferences(SyntaxNode root, SemanticModel model);
    private static ISymbol GetReferenceSymbol(SyntaxNode node, SemanticModel model);
    private static SymbolReference GetSymbolReference(IReadOnlyList`1<ReferenceInfo<TSyntaxKind>> references, string filePath);
    private static Nullable`1<FileLinePositionSpan> GetDeclarationSpan(IReadOnlyList`1<ReferenceInfo<TSyntaxKind>> references, string filePath);
    private static bool HasTooManyTokens(SyntaxTree syntaxTree);
}
public abstract class SonarAnalyzer.Rules.TabCharacterBase : SonarDiagnosticAnalyzer {
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    [CompilerGeneratedAttribute]
private void <Initialize>b__0_0(SonarSyntaxTreeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.TestsShouldNotUseThreadSleepBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual SyntaxNode MethodDeclaration(TMethodSyntax method);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool IsInTestMethod(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ThreadResumeOrSuspendShouldNotBeCalledBase`2 : DoNotCallMethodsBase`2<TSyntaxKind, TInvocation> {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
}
public abstract class SonarAnalyzer.Rules.ThrowReservedExceptionsBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    private ImmutableArray`1<KnownType> reservedExceptions;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected void Process(SonarSyntaxNodeReportingContext context, SyntaxNode thrownExpression);
}
public abstract class SonarAnalyzer.Rules.TokenTypeAnalyzerBase`1 : UtilityAnalyzerBase`2<TSyntaxKind, TokenTypeInfo> {
    private static string DiagnosticId;
    private static string Title;
    private static int IdentifierTokenCountThreshold;
    protected string FileName { get; }
    protected sealed virtual string get_FileName();
    protected abstract virtual TokenClassifierBase<TSyntaxKind> GetTokenClassifier(SemanticModel semanticModel, bool skipIdentifierTokens);
    protected abstract virtual TriviaClassifierBase<TSyntaxKind> GetTriviaClassifier();
    protected sealed virtual bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    protected sealed virtual TokenTypeInfo CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static void <CreateMessage>g__IterateTrivia|9_1(TriviaClassifierBase<TSyntaxKind> triviaClassifier, List`1<TokenInfo> spans, SyntaxTriviaList triviaList);
}
public abstract class SonarAnalyzer.Rules.TooManyLabelsInSwitchBase`2 : ParametrizedDiagnosticAnalyzer {
    protected static string MessageFormat;
    protected static string DiagnosticId;
    private static int DefaultValueMaximum;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    protected DiagnosticDescriptor Rule { get; }
    protected TSyntaxKind[] SyntaxKinds { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    [RuleParameterAttribute("maximum", "3", "Maximum number of case", "30")]
public int Maximum { get; public set; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual DiagnosticDescriptor get_Rule();
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual SyntaxNode GetExpression(TSwitchStatementSyntax statement);
    protected abstract virtual int GetSectionsCount(TSwitchStatementSyntax statement);
    protected abstract virtual bool AllSectionsAreOneLiners(TSwitchStatementSyntax statement);
    protected abstract virtual Location GetKeywordLocation(TSwitchStatementSyntax statement);
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__19_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.TooManyParametersBase`2 : ParametrizedDiagnosticAnalyzer {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static int DefaultValueMaximum;
    private DiagnosticDescriptor rule;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [RuleParameterAttribute("max", "3", "Maximum authorized number of parameters", "7")]
public int Maximum { get; public set; }
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
public int get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(int value);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual string UserFriendlyNameForNode(SyntaxNode node);
    protected abstract virtual int CountParameters(TParameterListSyntax parameterList);
    protected abstract virtual int BaseParameterCount(SyntaxNode node);
    protected abstract virtual bool CanBeChanged(SyntaxNode node, SemanticModel semanticModel);
    protected virtual bool IsExtern(SyntaxNode node);
    protected virtual void Initialize(SonarParametrizedAnalysisContext context);
    protected static bool VerifyCanBeChangedBySymbol(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__18_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.ToStringShouldNotReturnNullBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected TSyntaxKind MethodKind { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual TSyntaxKind get_MethodKind();
    protected abstract virtual bool IsLocalOrLambda(SyntaxNode node);
    protected abstract virtual IEnumerable`1<SyntaxNode> Conditionals(SyntaxNode expression);
    protected virtual void Initialize(SonarAnalysisContext context);
    protected void ToStringReturnsNull(SonarSyntaxNodeReportingContext context, SyntaxNode node);
    private bool ReturnsNull(SyntaxNode node);
    private bool WithinToString(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <WithinToString>b__11_0(SyntaxNode x);
    [CompilerGeneratedAttribute]
private bool <WithinToString>b__11_1(SyntaxNode x);
}
public abstract class SonarAnalyzer.Rules.UnaryPrefixOperatorRepeatedBase`2 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected DiagnosticDescriptor Rule { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected ISet`1<TSyntaxKindEnum> SyntaxKinds { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected abstract virtual DiagnosticDescriptor get_Rule();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ISet`1<TSyntaxKindEnum> get_SyntaxKinds();
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool TopLevelUnaryInChain(TSyntaxNode unary);
    protected abstract virtual SyntaxNode GetOperand(TSyntaxNode unarySyntax);
    protected abstract virtual SyntaxToken GetOperatorToken(TSyntaxNode unarySyntax);
    protected abstract virtual bool SameOperators(TSyntaxNode expression1, TSyntaxNode expression2);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UnconditionalJumpStatementBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected ISet`1<TSyntaxKind> LoopStatements { get; }
    protected string MessageFormat { get; }
    protected abstract virtual ISet`1<TSyntaxKind> get_LoopStatements();
    protected abstract virtual LoopWalkerBase`2<TStatementSyntax, TSyntaxKind> GetWalker(SonarSyntaxNodeReportingContext context);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UnnecessaryBitwiseOperationBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string IsReportingOnLeftKey;
    private static string MessageFormat;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    protected ILanguageFacade Language { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticDescriptor Rule { get; }
    protected abstract virtual ILanguageFacade get_Language();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
protected DiagnosticDescriptor get_Rule();
    protected void CheckBinary(SonarSyntaxNodeReportingContext context, SyntaxNode left, SyntaxToken operator, SyntaxNode right, int constValueToLookFor);
    protected Nullable`1<int> FindIntConstant(SemanticModel semanticModel, SyntaxNode node);
    private static bool IsFieldOrPropertyOutsideSystemNamespace(ISymbol symbol);
}
public abstract class SonarAnalyzer.Rules.UnnecessaryBitwiseOperationCodeFixBase : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual Func`1<SyntaxNode> CreateNewRoot(SyntaxNode root, TextSpan diagnosticSpan, bool isReportingOnLeft);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
public abstract class SonarAnalyzer.Rules.UnusedStringBuilderBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private String[] stringBuilderAccessInvocations;
    private String[] stringBuilderAccessExpressions;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual SyntaxNode GetScope(TVariableDeclarator declarator);
    protected abstract virtual ILocalSymbol RetrieveStringBuilderObject(SemanticModel semanticModel, TVariableDeclarator declaration);
    protected abstract virtual bool IsStringBuilderRead(SemanticModel model, ILocalSymbol symbol, SyntaxNode node);
    protected abstract virtual bool DescendIntoChildren(SyntaxNode node);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    internal bool IsSameReference(SemanticModel semanticModel, ILocalSymbol symbol, SyntaxNode expression);
    private bool IsSameVariable(SemanticModel semanticModel, ILocalSymbol symbol, SyntaxNode identifier);
    private static IEnumerable`1<TIdentifierName> GetLocalReferences(SyntaxNode node);
    private bool IsStringBuilderAccessed(SemanticModel model, ILocalSymbol symbol, SyntaxNode scope);
    internal bool IsAccessInvocation(string invocation);
    internal bool IsAccessExpression(string expression);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UriShouldNotBeHardcodedBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    protected static string DiagnosticId;
    protected static string AbsoluteUriMessage;
    protected static string PathDelimiterMessage;
    private static string UriScheme;
    private static string AbsoluteDiskUri;
    private static string AbsoluteMappedDiskUri;
    protected static Regex UriRegex;
    protected static Regex PathDelimiterRegex;
    protected static ISet`1<string> CheckedVariableNames;
    protected string MessageFormat { get; }
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected TSyntaxKind[] StringConcatenateExpressions { get; }
    protected TSyntaxKind[] InvocationOrObjectCreationKind { get; }
    private static UriShouldNotBeHardcodedBase`3();
    protected virtual string get_MessageFormat();
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual TSyntaxKind[] get_StringConcatenateExpressions();
    protected abstract virtual TSyntaxKind[] get_InvocationOrObjectCreationKind();
    protected abstract virtual SyntaxNode GetRelevantAncestor(SyntaxNode node);
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsInCheckedContext(SyntaxNode expression, SemanticModel model);
    private bool IsPathDelimiter(SyntaxNode expression);
    [CompilerGeneratedAttribute]
private void <Initialize>b__19_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__19_1(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <IsInCheckedContext>b__20_0(SyntaxNode x);
}
public abstract class SonarAnalyzer.Rules.UseCharOverloadOfStringMethodsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual bool HasCorrectArguments(TInvocation invocation);
    protected virtual void Initialize(SonarAnalysisContext context);
    private static bool CompilationTargetsValidNetVersion(Compilation compilation);
    private bool HasCorrectName(string methodName);
    private static bool IsCorrectType(SyntaxNode left, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarCompilationStartAnalysisContext start);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseDateTimeOffsetInsteadOfDateTimeBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static ImmutableArray`1<string> TargetMemberAccess;
    protected string MessageFormat { get; }
    protected String[] ValidNames { get; }
    private static UseDateTimeOffsetInsteadOfDateTimeBase`1();
    protected virtual string get_MessageFormat();
    protected abstract virtual String[] get_ValidNames();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static bool IsDateTimeType(SyntaxNode node, SemanticModel model);
    private bool IsNamedDateTime(string name);
    private string GetTypeName(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_1(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseFindSystemTimeZoneByIdBase`2 : DoNotCallMethodsBase`2<TSyntaxKind, TInvocation> {
    private static string DiagnosticId;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberDescriptor> <CheckedMethods>k__BackingField;
    protected string MessageFormat { get; }
    protected IEnumerable`1<MemberDescriptor> CheckedMethods { get; }
    protected virtual string get_MessageFormat();
    [CompilerGeneratedAttribute]
protected virtual IEnumerable`1<MemberDescriptor> get_CheckedMethods();
    protected virtual bool ShouldRegisterAction(Compilation compilation);
}
public abstract class SonarAnalyzer.Rules.UseIFormatProviderForParsingDateAndTimeBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static String[] ParseMethodNames;
    private static KnownType[] TemporalTypes;
    protected string MessageFormat { get; }
    private static UseIFormatProviderForParsingDateAndTimeBase`1();
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool NotUsingFormatProvider(IMethodSymbol methodSymbol, SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseIndexingInsteadOfLinqMethodsBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static ImmutableArray`1<KnownType> TargetInterfaces;
    protected string MessageFormat { get; }
    private static UseIndexingInsteadOfLinqMethodsBase`2();
    protected virtual string get_MessageFormat();
    protected abstract virtual int GetArgumentCount(TInvocation invocation);
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool HasValidSignature(TInvocation invocation, String& methodName, String& indexDescriptor);
    protected static bool IsCorrectType(SyntaxNode left, SemanticModel model);
    protected static bool IsCorrectCall(SyntaxNode right, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseLambdaParameterInConcurrentDictionaryBase`3 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual SeparatedSyntaxList`1<TArgumentSyntax> GetArguments(TInvocationExpression invocation);
    protected abstract virtual bool TryGetKeyName(TArgumentSyntax argument, String& keyName);
    protected abstract virtual bool IsLambdaAndContainsIdentifier(TArgumentSyntax argument, string keyName);
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool HasCorrectName(string methodName);
    private static bool IsCorrectType(SyntaxNode left, SemanticModel model);
    private static bool IsCorrectCall(SyntaxNode right, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseShortCircuitingOperatorBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
    protected ImmutableArray`1<TSyntaxKind> SyntaxKindsOfInterest { get; }
    protected string MessageFormat { get; }
    protected abstract virtual string GetSuggestedOpName(TBinaryExpression node);
    protected abstract virtual string GetCurrentOpName(TBinaryExpression node);
    protected abstract virtual SyntaxToken GetOperator(TBinaryExpression expression);
    protected abstract virtual ImmutableArray`1<TSyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private static bool IsBool(SyntaxNode node, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseShortCircuitingOperatorCodeFixBase`2 : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
    internal abstract virtual bool IsCandidateExpression(TBinaryExpression expression);
    private Task`1<Document> ReplaceExpressionAsync(TBinaryExpression expression, SyntaxNode root, Document document);
    protected abstract virtual TBinaryExpression GetShortCircuitingExpressionNode(TBinaryExpression expression);
}
public abstract class SonarAnalyzer.Rules.UseTestableTimeProviderBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private ImmutableArray`1<KnownType> trackedTypes;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected abstract virtual bool Ignore(SyntaxNode ancestor, SemanticModel semanticModel);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    private bool IsDateTimeProviderProperty(string name);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseTrueForAllBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private static ImmutableArray`1<KnownType> TargetTypes;
    protected string MessageFormat { get; }
    private static UseTrueForAllBase`1();
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsCorrectType(SyntaxNode left, SemanticModel model);
    protected static bool IsCorrectCall(SyntaxNode right, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UseUnixEpochBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    internal static string DiagnosticId;
}
public abstract class SonarAnalyzer.Rules.UseUnixEpochBase`3 : UseUnixEpochBase`1<TSyntaxKind> {
    private static long EpochTicks;
    private static int EpochYear;
    private static int EpochMonth;
    private static int EpochDay;
    private static ImmutableArray`1<KnownType> TypesWithUnixEpochField;
    protected string MessageFormat { get; }
    private static UseUnixEpochBase`3();
    protected virtual string get_MessageFormat();
    protected abstract virtual bool IsDateTimeKindUtc(TMemberAccessExpression memberAccess);
    protected abstract virtual bool IsGregorianCalendar(SyntaxNode node);
    protected abstract virtual bool IsZeroTimeOffset(SyntaxNode node);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected static bool IsValueEqualTo(TLiteralExpression literal, long value);
    private bool IsEpochCtor(SyntaxNode node, SemanticModel model);
    private static bool IsParameterExistingAndLiteralEqualTo(string parameterName, int value, IMethodParameterLookup lookup);
    private static bool IsParameterNonExistingOrLiteralEqualTo(string parameterName, int value, IMethodParameterLookup lookup);
    private static bool IsLiteralAndEqualTo(SyntaxNode node, int value);
    private static string CheckAndGetTypeName(SyntaxNode node, SemanticModel model);
    private bool IsDateTimeKindNonExistingOrUtc(IMethodParameterLookup lookup);
    private bool IsCalendarNonExistingOrGregorian(IMethodParameterLookup lookup);
    private bool IsOffsetNonExistingOrZero(IMethodParameterLookup lookup);
    private static bool IsUnixEpochSupported(Compilation compilation);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(SonarCompilationStartAnalysisContext c);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_1(SonarSyntaxNodeReportingContext cc);
}
public abstract class SonarAnalyzer.Rules.UseUnixEpochCodeFixBase`1 : SonarCodeFix {
    internal static string Title;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual SyntaxNode ReplaceConstructorWithField(SyntaxNode root, SyntaxNode node, SonarCodeFixContext context);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task RegisterCodeFixesAsync(SyntaxNode root, SonarCodeFixContext context);
}
public abstract class SonarAnalyzer.Rules.UseWhereBeforeOrderByBase`2 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool LeftHasCorrectName(SyntaxNode left, String& methodName);
    private static bool MethodIsLinqExtension(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UsingNonstandardCryptographyBase`2 : HotspotDiagnosticAnalyzer {
    private static string DiagnosticId;
    private static string MessageFormat;
    private ImmutableArray`1<KnownType> nonInheritableClassesAndInterfaces;
    private DiagnosticDescriptor rule;
    protected ILanguageFacade Language { get; }
    protected TSyntaxKind[] SyntaxKinds { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected UsingNonstandardCryptographyBase`2(IAnalyzerConfiguration analyzerConfiguration);
    protected abstract virtual ILanguageFacade get_Language();
    protected abstract virtual TSyntaxKind[] get_SyntaxKinds();
    protected abstract virtual Location Location(TTypeDeclarationSyntax typeDeclarationSyntax);
    protected abstract virtual bool DerivesOrImplementsAny(TTypeDeclarationSyntax typeDeclarationSyntax);
    protected abstract virtual INamedTypeSymbol DeclaredSymbol(TTypeDeclarationSyntax typeDeclarationSyntax, SemanticModel semanticModel);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__14_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.UtilityAnalyzerBase : SonarDiagnosticAnalyzer {
    protected static ISet`1<string> FileExtensionWhitelist;
    private DiagnosticDescriptor rule;
    protected bool EnableConcurrentExecution { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected UtilityAnalyzerBase(string diagnosticId, string title);
    private static UtilityAnalyzerBase();
    protected virtual bool get_EnableConcurrentExecution();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    internal static TextRange GetTextRange(FileLinePositionSpan lineSpan);
    protected virtual UtilityAnalyzerParameters ReadParameters(SonarAnalysisContextBase`1<T> context);
}
public abstract class SonarAnalyzer.Rules.UtilityAnalyzerBase`2 : UtilityAnalyzerBase {
    protected ILanguageFacade`1<TSyntaxKind> Language { get; }
    protected string FileName { get; }
    protected bool AnalyzeUnchangedFiles { get; }
    protected UtilityAnalyzerBase`2(string diagnosticId, string title);
    protected abstract virtual ILanguageFacade`1<TSyntaxKind> get_Language();
    protected abstract virtual string get_FileName();
    protected abstract virtual TMessage CreateMessage(UtilityAnalyzerParameters parameters, SyntaxTree tree, SemanticModel model);
    protected virtual bool get_AnalyzeUnchangedFiles();
    protected virtual IEnumerable`1<TMessage> CreateAnalysisMessages(SonarCompilationReportingContext c);
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected virtual bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    protected static string GetFilePath(SyntaxTree tree);
    private bool ShouldGenerateMetrics(UtilityAnalyzerParameters parameters, SonarSemanticModelReportingContext context);
    private bool ShouldGenerateMetricsByType(UtilityAnalyzerParameters parameters, SyntaxTree tree);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(SonarCompilationStartAnalysisContext startContext);
}
[IsReadOnlyAttribute]
public class SonarAnalyzer.Rules.UtilityAnalyzerParameters : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsAnalyzerEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreHeaderComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnalyzeGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnalyzeTestProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTestProject>k__BackingField;
    public static UtilityAnalyzerParameters Default;
    public bool IsAnalyzerEnabled { get; public set; }
    public bool IgnoreHeaderComments { get; public set; }
    public bool AnalyzeGeneratedCode { get; public set; }
    public bool AnalyzeTestProjects { get; public set; }
    public string OutPath { get; public set; }
    public bool IsTestProject { get; public set; }
    public UtilityAnalyzerParameters(bool IsAnalyzerEnabled, bool IgnoreHeaderComments, bool AnalyzeGeneratedCode, bool AnalyzeTestProjects, string OutPath, bool IsTestProject);
    private static UtilityAnalyzerParameters();
    [CompilerGeneratedAttribute]
public bool get_IsAnalyzerEnabled();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsAnalyzerEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreHeaderComments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreHeaderComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_AnalyzeGeneratedCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AnalyzeGeneratedCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_AnalyzeTestProjects();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AnalyzeTestProjects(bool value);
    [CompilerGeneratedAttribute]
public string get_OutPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OutPath(string value);
    [CompilerGeneratedAttribute]
public bool get_IsTestProject();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsTestProject(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UtilityAnalyzerParameters left, UtilityAnalyzerParameters right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UtilityAnalyzerParameters left, UtilityAnalyzerParameters right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UtilityAnalyzerParameters other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsAnalyzerEnabled, Boolean& IgnoreHeaderComments, Boolean& AnalyzeGeneratedCode, Boolean& AnalyzeTestProjects, String& OutPath, Boolean& IsTestProject);
}
public abstract class SonarAnalyzer.Rules.ValueTypeShouldImplementIEquatableBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    protected string MessageFormat { get; }
    protected virtual string get_MessageFormat();
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__4_0(SonarSyntaxNodeReportingContext c);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__4_1(TSyntaxKind x);
}
public abstract class SonarAnalyzer.Rules.VariableUnusedBase : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    [IteratorStateMachineAttribute("SonarAnalyzer.Rules.VariableUnusedBase/<GetUsedSymbols>d__3")]
internal static IEnumerable`1<ISymbol> GetUsedSymbols(SyntaxNode node, SemanticModel semanticModel);
}
public abstract class SonarAnalyzer.Rules.WcfNonVoidOneWayBase`2 : SonarDiagnosticAnalyzer {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    protected GeneratedCodeRecognizer GeneratedCodeRecognizer { get; }
    protected TLanguageKind MethodDeclarationKind { get; }
    protected sealed virtual void Initialize(SonarAnalysisContext context);
    protected abstract virtual GeneratedCodeRecognizer get_GeneratedCodeRecognizer();
    protected abstract virtual TLanguageKind get_MethodDeclarationKind();
    protected abstract virtual Location GetReturnTypeLocation(TMethodSyntax method);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_0(SonarSyntaxNodeReportingContext c);
}
public abstract class SonarAnalyzer.Rules.WeakSslTlsProtocolsBase`1 : SonarDiagnosticAnalyzer`1<TSyntaxKind> {
    private static string DiagnosticId;
    private HashSet`1<string> weakProtocols;
    protected string MessageFormat { get; }
    protected abstract virtual bool IsPartOfBinaryNegationOrCondition(SyntaxNode node);
    protected virtual string get_MessageFormat();
    protected virtual void Initialize(SonarAnalysisContext context);
    private bool IsWeakProtocol(SyntaxNode identifierName, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(SonarSyntaxNodeReportingContext c);
}
internal static class SonarAnalyzer.Signing : object {
    private static string PublicKey;
    internal static string InternalsVisibleToPublicKey;
}
public class SonarAnalyzer.SymbolicExecution.Constraints.BoolConstraint : SymbolicConstraint {
    public static BoolConstraint True;
    public static BoolConstraint False;
    public SymbolicConstraint Opposite { get; }
    private BoolConstraint(ConstraintKind kind);
    private static BoolConstraint();
    public virtual SymbolicConstraint get_Opposite();
    public static BoolConstraint From(bool value);
    public bool Equals(bool value);
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.ByteCollectionConstraint : SymbolicConstraint {
    public static ByteCollectionConstraint CryptographicallyStrong;
    public static ByteCollectionConstraint CryptographicallyWeak;
    public SymbolicConstraint Opposite { get; }
    private ByteCollectionConstraint(ConstraintKind kind);
    private static ByteCollectionConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.CollectionConstraint : SymbolicConstraint {
    public static CollectionConstraint Empty;
    public static CollectionConstraint NotEmpty;
    public SymbolicConstraint Opposite { get; }
    private CollectionConstraint(ConstraintKind kind);
    private static CollectionConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
public enum SonarAnalyzer.SymbolicExecution.Constraints.ConstraintKind : Enum {
    public int value__;
    public static ConstraintKind False;
    public static ConstraintKind True;
    public static ConstraintKind Null;
    public static ConstraintKind NotNull;
    public static ConstraintKind CollectionEmpty;
    public static ConstraintKind CollectionNotEmpty;
    public static ConstraintKind CryptographicallyStrong;
    public static ConstraintKind CryptographicallyWeak;
    public static ConstraintKind CryptographicallyPredictable;
    public static ConstraintKind CryptographicallyUnpredictable;
    public static ConstraintKind CryptographicKeyStoredSafe;
    public static ConstraintKind CryptographicKeyStoredUnsafe;
    public static ConstraintKind DisposableDisposed;
    public static ConstraintKind InitializationVectorInitialized;
    public static ConstraintKind InitializationVectorNotInitialized;
    public static ConstraintKind LockHeld;
    public static ConstraintKind LockReleased;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind NullableHasValue;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind NullableNoValue;
    public static ConstraintKind Number;
    public static ConstraintKind ParameterReassigned;
    public static ConstraintKind SaltSizeSafe;
    public static ConstraintKind SaltSizeShort;
    public static ConstraintKind SerializationSafe;
    public static ConstraintKind SerializationUnsafe;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringEmpty;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringFullNotWhiteSpace;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringFullOrNull;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringFull;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringNotWhiteSpace;
    [ObsoleteAttribute("Old SE engine only")]
public static ConstraintKind StringWhiteSpace;
}
public class SonarAnalyzer.SymbolicExecution.Constraints.CryptographicKeyConstraint : SymbolicConstraint {
    public static CryptographicKeyConstraint StoredSafe;
    public static CryptographicKeyConstraint StoredUnsafe;
    public SymbolicConstraint Opposite { get; }
    private CryptographicKeyConstraint(ConstraintKind kind);
    private static CryptographicKeyConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.CryptographicSeedConstraint : SymbolicConstraint {
    public static CryptographicSeedConstraint Predictable;
    public static CryptographicSeedConstraint Unpredictable;
    public SymbolicConstraint Opposite { get; }
    private CryptographicSeedConstraint(ConstraintKind kind);
    private static CryptographicSeedConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.DisposableConstraint : SymbolicConstraint {
    public static DisposableConstraint Disposed;
    public SymbolicConstraint Opposite { get; }
    private DisposableConstraint(ConstraintKind kind);
    private static DisposableConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
public class SonarAnalyzer.SymbolicExecution.Constraints.LockConstraint : SymbolicConstraint {
    public static LockConstraint Held;
    public static LockConstraint Released;
    public SymbolicConstraint Opposite { get; }
    public bool PreserveOnFieldReset { get; }
    private LockConstraint(ConstraintKind kind);
    private static LockConstraint();
    public virtual SymbolicConstraint get_Opposite();
    public virtual bool get_PreserveOnFieldReset();
}
public class SonarAnalyzer.SymbolicExecution.Constraints.NumberConstraint : SymbolicConstraint {
    private static int CacheLimit;
    private static ConcurrentDictionary`2<CacheKey, NumberConstraint> cache;
    [CompilerGeneratedAttribute]
private Nullable`1<BigInteger> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BigInteger> <Max>k__BackingField;
    public Nullable`1<BigInteger> Min { get; }
    public Nullable`1<BigInteger> Max { get; }
    public bool IsSingleValue { get; }
    public bool IsPositive { get; }
    public bool IsNegative { get; }
    public bool CanBePositive { get; }
    public bool CanBeNegative { get; }
    public bool CacheEnabled { get; }
    public SymbolicConstraint Opposite { get; }
    private NumberConstraint(Nullable`1<BigInteger> min, Nullable`1<BigInteger> max);
    private static NumberConstraint();
    [CompilerGeneratedAttribute]
public Nullable`1<BigInteger> get_Min();
    [CompilerGeneratedAttribute]
public Nullable`1<BigInteger> get_Max();
    public bool get_IsSingleValue();
    public bool get_IsPositive();
    public bool get_IsNegative();
    public bool get_CanBePositive();
    public bool get_CanBeNegative();
    public virtual bool get_CacheEnabled();
    public virtual SymbolicConstraint get_Opposite();
    public static NumberConstraint From(BigInteger value);
    public static NumberConstraint From(object value);
    public static NumberConstraint From(Nullable`1<BigInteger> min, Nullable`1<BigInteger> max);
    public bool CanContain(BigInteger value);
    public bool Overlaps(NumberConstraint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static void ResetCache();
    private static string Serialize(Nullable`1<BigInteger> value);
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.ObjectConstraint : SymbolicConstraint {
    public static ObjectConstraint Null;
    public static ObjectConstraint NotNull;
    public SymbolicConstraint Opposite { get; }
    private ObjectConstraint(ConstraintKind kind);
    private static ObjectConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.ParameterReassignedConstraint : SymbolicConstraint {
    public static ParameterReassignedConstraint Instance;
    public SymbolicConstraint Opposite { get; }
    private ParameterReassignedConstraint(ConstraintKind kind);
    private static ParameterReassignedConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.SaltSizeConstraint : SymbolicConstraint {
    public static SaltSizeConstraint Short;
    public SymbolicConstraint Opposite { get; }
    private SaltSizeConstraint(ConstraintKind kind);
    private static SaltSizeConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
internal class SonarAnalyzer.SymbolicExecution.Constraints.SerializationConstraint : SymbolicConstraint {
    public static SerializationConstraint Unsafe;
    public static SerializationConstraint Safe;
    public SymbolicConstraint Opposite { get; }
    private SerializationConstraint(ConstraintKind kind);
    private static SerializationConstraint();
    public virtual SymbolicConstraint get_Opposite();
}
[ExtensionAttribute]
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.BinaryOperatorKindExtensions : object {
    [ExtensionAttribute]
public static BoolConstraint BoolConstraintFromNumberConstraints(BinaryOperatorKind kind, NumberConstraint left, NumberConstraint right);
    [ExtensionAttribute]
public static NumberConstraint NumberConstraintFromRelationalOperator(BinaryOperatorKind kind, NumberConstraint existingNumber, NumberConstraint comparedNumber);
    private static NumberConstraint From(Nullable`1<BigInteger> newMin, Nullable`1<BigInteger> newMax, NumberConstraint existingNumber);
    [ExtensionAttribute]
public static BinaryOperatorKind ApplyOpposite(BinaryOperatorKind kind, bool useOpposite);
    [ExtensionAttribute]
public static BinaryOperatorKind Opposite(BinaryOperatorKind kind);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.Checks.ConstantCheck : SymbolicCheck {
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    public static SymbolicConstraint ConstraintFromType(ITypeSymbol type);
    private static SymbolicValue ConstraintFromConstantValue(IOperationWrapperSonar operation);
    private static ITypeSymbol ConvertedType(IOperation operation);
    private static bool CanBeNull(IOperationWrapperSonar operation);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.Checks.NonNullableValueTypeCheck : SymbolicCheck {
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
}
[ExcludeFromCodeCoverageAttribute]
internal class SonarAnalyzer.SymbolicExecution.Roslyn.DebugLogger : object {
    private static string DebugSymbol;
    private static string Separator;
    private bool isActive;
    [ConditionalAttribute("DEBUG")]
public void Log(ControlFlowGraph cfg);
    [ConditionalAttribute("DEBUG")]
public void Log(object value, string title, bool withIndent);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.ExceptionCandidate : object {
    private TypeCatalog typeCatalog;
    public ExceptionCandidate(Compilation compilation);
    public ExceptionState FromOperation(ProgramState state, IOperationWrapperSonar operation);
    private ExceptionState FromConversion(IOperationWrapperSonar operation);
    private ExceptionState FromOperation(IArrayElementReferenceOperationWrapper reference);
    private ExceptionState FromOperation(ProgramState state, IMemberReferenceOperationWrapper reference);
    private static ExceptionState FromOperation(IInvocationOperationWrapper invocation);
    private ExceptionState FromOperation(IBinaryOperationWrapper binary);
    private ExceptionState FromOperation(ICompoundAssignmentOperationWrapper compoundAssignment);
    private static bool IsDivision(BinaryOperatorKind operatorKind);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.ExceptionState : object {
    public static ExceptionState UnknownException;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public ITypeSymbol Type { get; }
    public ExceptionState(ITypeSymbol type);
    [CompilerGeneratedAttribute]
private ExceptionState(ExceptionState original);
    private static ExceptionState();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExceptionState left, ExceptionState right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExceptionState left, ExceptionState right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExceptionState other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ExceptionState <Clone>$();
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.ExplodedNode : object {
    private IOperationWrapperSonar[] operations;
    private int index;
    private int programPointHash;
    [CompilerGeneratedAttribute]
private ProgramState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicBlock <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private FinallyPoint <FinallyPoint>k__BackingField;
    public ProgramState State { get; private set; }
    public BasicBlock Block { get; }
    public FinallyPoint FinallyPoint { get; }
    public IOperationWrapperSonar Operation { get; }
    public int VisitCount { get; }
    public ExplodedNode(BasicBlock block, ProgramState state, FinallyPoint finallyPoint);
    private ExplodedNode(BasicBlock block, IOperationWrapperSonar[] operations, int index, ProgramState state, FinallyPoint finallyPoint);
    [CompilerGeneratedAttribute]
public ProgramState get_State();
    [CompilerGeneratedAttribute]
private void set_State(ProgramState value);
    [CompilerGeneratedAttribute]
public BasicBlock get_Block();
    [CompilerGeneratedAttribute]
public FinallyPoint get_FinallyPoint();
    public IOperationWrapperSonar get_Operation();
    public int get_VisitCount();
    public ExplodedNode CreateNext(ProgramState state);
    public int AddVisit();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExplodedNode other);
    public virtual string ToString();
    private bool HasSameFinallyPointChain(FinallyPoint other);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.FinallyPoint : object {
    private ControlFlowBranch branch;
    private int finallyIndex;
    [CompilerGeneratedAttribute]
private FinallyPoint <Previous>k__BackingField;
    public bool IsFinallyBlock { get; }
    public int BlockIndex { get; }
    public int BranchDestination { get; }
    public FinallyPoint Previous { get; }
    public FinallyPoint(FinallyPoint previous, ControlFlowBranch branch, int finallyIndex);
    public bool get_IsFinallyBlock();
    public int get_BlockIndex();
    public int get_BranchDestination();
    [CompilerGeneratedAttribute]
public FinallyPoint get_Previous();
    public FinallyPoint CreateNext();
}
[ExtensionAttribute]
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.IInvocationOperationExtensions : object {
    [ExtensionAttribute]
public static bool IsMonitorExit(IInvocationOperationWrapper invocation);
    [ExtensionAttribute]
public static bool IsMonitorIsEntered(IInvocationOperationWrapper invocation);
    [ExtensionAttribute]
public static bool IsLockRelease(IInvocationOperationWrapper invocation);
    [ExtensionAttribute]
public static bool HasThisReceiver(IInvocationOperationWrapper invocation, ProgramState state);
    [ExtensionAttribute]
public static IOperation Target(IInvocationOperationWrapper invocation, ProgramState state);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.IMemberReferenceOperationExtensions : object {
    [ExtensionAttribute]
public static bool IsOnReaderWriterLockOrSlim(IMemberReferenceOperationWrapper reference);
}
[ExtensionAttribute]
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.IOperationExtensions : object {
    [ExtensionAttribute]
public static bool IsStaticOrThis(IMemberReferenceOperationWrapper reference, ProgramState state);
    [ExtensionAttribute]
public static bool IsUpcast(IConversionOperationWrapper conversion);
    [ExtensionAttribute]
internal static ISymbol TrackedSymbol(IOperation operation, ProgramState state);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.LoopDetector : object {
    private HashSet`1<int> loopBlocks;
    public LoopDetector(ControlFlowGraph cfg);
    public bool IsInLoop(BasicBlock block);
    private static IEnumerable`1<int> DetectLoopBlockOrdinals(ControlFlowGraph cfg);
    private static IEnumerable`1<int> Successors(ControlFlowGraph cfg, int index);
    [CompilerGeneratedAttribute]
internal static void <DetectLoopBlockOrdinals>g__MergeWithIntersectingLoops|3_1(Int32[] path, int last, <>c__DisplayClass3_0& );
}
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.OperationDispatcher : object {
    private static Dictionary`2<OperationKind, IMultiProcessor> Branching;
    private static Dictionary`2<OperationKind, ISimpleProcessor> Simple;
    private static OperationDispatcher();
    public static IEnumerable`1<SymbolicContext> Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Argument : SimpleProcessor`1<IArgumentOperationWrapper> {
    protected virtual IArgumentOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IArgumentOperationWrapper argument);
    private static ProgramState ProcessArgument(ProgramState state, IArgumentOperationWrapper argument);
}
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ArithmeticCalculator : object {
    public static NumberConstraint Calculate(BinaryOperatorKind kind, NumberConstraint left, NumberConstraint right, bool isInLoop);
    public static Nullable`1<BigInteger> BiggestMinimum(NumberConstraint left, NumberConstraint right);
    public static Nullable`1<BigInteger> SmallestMaximum(NumberConstraint left, NumberConstraint right);
    private static NumberConstraint CalculateMultiply(NumberConstraint left, NumberConstraint right);
    private static NumberConstraint CalculateDivide(NumberConstraint left, NumberConstraint right);
    private static NumberConstraint CalculateRemainder(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateRemainderMin(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateRemainderMax(NumberConstraint left, NumberConstraint right);
    private static NumberConstraint AccountForZero(NumberConstraint constraint);
    private static BigInteger MaxOfAbsoluteValues(NumberConstraint constraint);
    private static BigInteger MinOfAbsoluteValues(NumberConstraint constraint);
    private static Nullable`1<BigInteger> CalculateAndMin(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateAndMax(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateOrMin(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateOrMax(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateXorMin(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> CalculateXorMax(NumberConstraint left, NumberConstraint right);
    private static BigInteger Max(BigInteger[] values);
    private static Nullable`1<BigInteger> NegativeMagnitude(BigInteger value);
    private static Nullable`1<BigInteger> PositiveMagnitude(BigInteger value);
    private static Nullable`1<BigInteger> BiggestMaximum(NumberConstraint left, NumberConstraint right);
    private static Nullable`1<BigInteger> SmallestMinimum(NumberConstraint left, NumberConstraint right);
    [CompilerGeneratedAttribute]
internal static Nullable`1<BigInteger> <CalculateXorMin>g__SameSign|15_0(NumberConstraint range1, NumberConstraint range2);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ArrayCreation : SimpleProcessor`1<IArrayCreationOperationWrapper> {
    protected virtual IArrayCreationOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IArrayCreationOperationWrapper operation);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ArrayElementReference : SimpleProcessor`1<IArrayElementReferenceOperationWrapper> {
    protected virtual IArrayElementReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IArrayElementReferenceOperationWrapper arrayElementReference);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Assignment : SimpleProcessor`1<ISimpleAssignmentOperationWrapper> {
    protected virtual ISimpleAssignmentOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, ISimpleAssignmentOperationWrapper assignment);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Await : object {
    public sealed virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Binary : BinaryBase`1<IBinaryOperationWrapper> {
    protected virtual IBinaryOperationWrapper Convert(IOperation operation);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, IBinaryOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, IBinaryOperationWrapper operation, bool falseBranch);
    protected virtual ProgramState PreProcess(ProgramState state, IBinaryOperationWrapper operation, bool isInLoop);
    private static ProgramState LearnBranchingRelationalObjectConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand, bool falseBranch);
}
internal abstract class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.BinaryBase`1 : BranchingProcessor`1<TOperation> {
    protected static BoolConstraint BoolConstraintFromBinaryOperation(BinaryOperatorKind kind, SymbolicValue left, SymbolicValue right);
    protected static ProgramState LearnBranchingEqualityConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand, BinaryOperatorKind operatorKind, bool falseBranch);
    protected static ProgramState LearnBranchingNumberConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand, BinaryOperatorKind operatorKind, bool falseBranch);
    protected static ProgramState LearnBranchingCollectionConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand, BinaryOperatorKind binaryOperatorKind, bool falseBranch);
    protected static ISymbol BinaryOperandSymbolWithoutConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand);
    protected static SymbolicConstraint BinaryOperandConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand);
    private static ProgramState LearnBranchingEqualityConstraint(ProgramState state, IOperation leftOperand, IOperation rightOperand, BinaryOperatorKind operatorKind, bool falseBranch);
    private static SymbolicConstraint CollectionConstraintFromOperator(BinaryOperatorKind operatorKind, NumberConstraint number);
    private static BoolConstraint BoolConstraintFromBoolConstraints(BinaryOperatorKind kind, bool left, bool right);
    private static BoolConstraint BoolConstraintFromNullConstraints(BinaryOperatorKind kind, bool isNullLeft, bool isNullRight);
    private static BoolConstraint BoolConstraintFromBoolAndNullConstraints(BinaryOperatorKind kind, BoolConstraint leftBool, BoolConstraint rightBool, bool leftIsNull, bool rightIsNull);
    private static ISymbol OperandSymbolWithoutConstraint(ProgramState state, IOperation candidate);
    private static BinaryOperatorKind Flip(BinaryOperatorKind kind);
    [CompilerGeneratedAttribute]
internal static ISymbol <LearnBranchingNumberConstraint>g__OperandSymbol|2_0(IOperation operand, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static ProgramState <LearnBranchingNumberConstraint>g__LearnBranching|2_1(ISymbol symbol, NumberConstraint existingNumber, BinaryOperatorKind kind, NumberConstraint comparedNumber, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static ISymbol <LearnBranchingCollectionConstraint>g__InstanceOfCountProperty|3_0(IOperation operation, <>c__DisplayClass3_0& );
}
internal abstract class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.BranchingProcessor`1 : MultiProcessor`1<T> {
    protected abstract virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, T operation);
    protected abstract virtual ProgramState LearnBranchingConstraint(ProgramState state, T operation, bool falseBranch);
    protected virtual ProgramState PreProcess(ProgramState state, T operation, bool isInLoop);
    protected virtual ProgramState[] Process(SymbolicContext context, T operation);
}
internal static class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.CollectionTracker : object {
    public static ImmutableArray`1<KnownType> CollectionTypes;
    private static HashSet`1<string> AddMethods;
    private static HashSet`1<string> RemoveMethods;
    private static HashSet`1<string> AddOrRemoveMethods;
    private static CollectionTracker();
    public static ProgramState LearnFrom(ProgramState state, IObjectCreationOperationWrapper operation);
    public static ProgramState LearnFrom(ProgramState state, IArrayCreationOperationWrapper operation);
    public static ProgramState LearnFrom(ProgramState state, IMethodReferenceOperationWrapper operation);
    public static ProgramState LearnFrom(ProgramState state, IPropertyReferenceOperationWrapper operation, ISymbol instanceSymbol);
    public static ProgramState LearnFrom(ProgramState state, IInvocationOperationWrapper invocation);
    private static NumberConstraint EnumerableCountConstraint(ProgramState state, IInvocationOperationWrapper invocation);
    [CompilerGeneratedAttribute]
internal static bool <LearnFrom>g__IsEnumerable|4_0(IOperation operation);
    [CompilerGeneratedAttribute]
internal static ProgramState <LearnFrom>g__SetOperationAndSymbolValue|8_0(SymbolicValue value, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <EnumerableCountConstraint>g__HasFilteringPredicate|9_0(<>c__DisplayClass9_0& );
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.CompoundAssignment : SimpleProcessor`1<ICompoundAssignmentOperationWrapper> {
    protected virtual ICompoundAssignmentOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, ICompoundAssignmentOperationWrapper assignment);
    private static ProgramState ProcessNumericalCompoundAssignment(ProgramState state, ICompoundAssignmentOperationWrapper assignment, bool isInLoop);
    private static ProgramState ProcessDelegateCompoundAssignment(ProgramState state, ICompoundAssignmentOperationWrapper assignment);
    private static ProgramState ProcessCompoundAssignment(ProgramState state, ICompoundAssignmentOperationWrapper assignment);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Conversion : SimpleProcessor`1<IConversionOperationWrapper> {
    protected virtual IConversionOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IConversionOperationWrapper conversion);
    private static bool IsBuildIn(ISymbol symbol);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.DeclarationPattern : SimpleProcessor`1<IDeclarationPatternOperationWrapper> {
    protected virtual IDeclarationPatternOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IDeclarationPatternOperationWrapper declaration);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.DeconstructionAssignment : SimpleProcessor`1<IDeconstructionAssignmentOperationWrapper> {
    protected virtual IDeconstructionAssignmentOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IDeconstructionAssignmentOperationWrapper assignment);
    private static IEnumerable`1<OperationValue> TupleElementValues(ProgramState state, IOperation target, IOperation value);
    private static IOperation[] TupleElements(ITupleOperationWrapper operation, ProgramState state);
    private static IOperation Unwrap(IOperation operation, ProgramState state);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.DefaultValue : object {
    public sealed virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.EventReference : SimpleProcessor`1<IEventReferenceOperationWrapper> {
    protected virtual IEventReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IEventReferenceOperationWrapper eventReference);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.FieldReference : SimpleProcessor`1<IFieldReferenceOperationWrapper> {
    protected virtual IFieldReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IFieldReferenceOperationWrapper fieldReference);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.FlowCapture : SimpleProcessor`1<IFlowCaptureOperationWrapper> {
    protected virtual IFlowCaptureOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IFlowCaptureOperationWrapper capture);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.FlowCaptureReference : SimpleProcessor`1<IFlowCaptureReferenceOperationWrapper> {
    protected virtual IFlowCaptureReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IFlowCaptureReferenceOperationWrapper capture);
}
internal interface SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.IMultiProcessor {
    public abstract virtual ProgramState[] Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.IncrementOrDecrement : SimpleProcessor`1<IIncrementOrDecrementOperationWrapper> {
    protected virtual IIncrementOrDecrementOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IIncrementOrDecrementOperationWrapper incrementOrDecrement);
    private static SymbolicValue NewValue(SymbolicValue oldValue, NumberConstraint newNumber);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.InstanceReference : object {
    public sealed virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Invocation : MultiProcessor`1<IInvocationOperationWrapper> {
    private static String[] LinqMethodsNullCheckingSource;
    private static ImmutableArray`1<KnownType> CollectionTypes;
    private static HashSet`1<string> ReturningNotNull;
    private static HashSet`1<string> ElementExistsCheckMethods;
    private static HashSet`1<string> StringMethodReturningNotNull;
    private static Invocation();
    protected virtual IInvocationOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState[] Process(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static IOperation LearnNotNullCandidate(IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessArgumentAttributes(ProgramState state, IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessArgumentAttribute(ProgramState[] states, IInvocationOperationWrapper invocation, IArgumentOperationWrapper argument, AttributeData attribute);
    private static ProgramState[] ProcessIsNotNullWhen(ProgramState state, IOperation invocation, IArgumentOperationWrapper argument, bool when, bool learnNull);
    private static ProgramState[] ProcessDoesNotReturnIf(ProgramState state, IArgumentOperationWrapper argument, bool when);
    private static ProgramState[] ProcessDebugAssert(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static ProgramState ProcessAssertedBoolSymbol(ProgramState state, IOperation operation, bool isNegated);
    private static ProgramState[] ProcessReferenceEquals(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessEquals(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessEquals(SymbolicContext context, IOperation leftOperation, IOperation rightOperation);
    private static ProgramState[] ProcessEqualsObject(SymbolicContext context, IOperation leftOperation, IOperation rightOperation);
    private static ProgramState ProcessNullableGetValueOrDefault(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessNullableHasValue(ProgramState state, IInvocationOperationWrapper invocation);
    private static bool IsThrowHelper(IMethodSymbol method);
    private static ProgramState[] ProcessInformationIsNothing(SymbolicContext context, IInvocationOperationWrapper invocation);
    private static bool IsNullableGetValueOrDefault(IInvocationOperationWrapper invocation);
    private static bool IsSupportedEqualsType(ITypeSymbol type);
    private static ProgramState[] ProcessLinqEnumerableAndQueryable(ProgramState state, IInvocationOperationWrapper invocation);
    private static ProgramState[] ProcessElementExistsCheckMethods(ProgramState state, IInvocationOperationWrapper invocation);
    private static bool HasParameters(IMethodSymbol symbol);
    private static ITypeSymbol GetElementType(ISymbol instance);
    private static ProgramState[] ProcessSystemStringInvocation(ProgramState state, IInvocationOperationWrapper invocation);
    [CompilerGeneratedAttribute]
internal static ProgramState <ProcessIsNotNullWhen>g__DefineConstraintsFromKnownResult|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static ProgramState[] <ProcessIsNotNullWhen>g__DefineAllConstraints|7_1(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static ProgramState[] <ProcessIsNotNullWhen>g__ExplodeStates|7_2(ISymbol argumentSymbol, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static ProgramState <ProcessEquals>g__ProcessNumberConstraints|13_0(NumberConstraint left, NumberConstraint right, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static ProgramState <ProcessNullableGetValueOrDefault>g__NullableDefaultState|15_0(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ProgramState> <ProcessLinqEnumerableAndQueryable>g__ProcessElementOrDefaultMethods|23_2(ProgramState state, IInvocationOperationWrapper invocation);
}
internal interface SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ISimpleProcessor {
    public abstract virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.IsNull : BranchingProcessor`1<IIsNullOperationWrapper> {
    protected virtual IIsNullOperationWrapper Convert(IOperation operation);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, IIsNullOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, IIsNullOperationWrapper operation, bool falseBranch);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.IsPattern : BranchingProcessor`1<IIsPatternOperationWrapper> {
    protected virtual IIsPatternOperationWrapper Convert(IOperation operation);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, IIsPatternOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, IIsPatternOperationWrapper operation, bool falseBranch);
    private static SymbolicConstraint LearnBranchingConstraint(ProgramState state, IPatternOperationWrapper pattern, bool falseBranch, bool hasObjectConstraint, NumberConstraint numberConstraint);
    private static NumberConstraint NumberConstraintFromRelationalPattern(ProgramState state, IRelationalPatternOperationWrapper relational, bool falseBranch, NumberConstraint existingNumber);
    private static SymbolicConstraint ConstraintFromConstantPattern(ProgramState state, IConstantPatternOperationWrapper constant, bool falseBranch, bool isReferenceType);
    private static ObjectConstraint ConstraintFromRecursivePattern(IRecursivePatternOperationWrapper recursive, bool falseBranch, bool hasObjectConstraint);
    private static SymbolicConstraint ConstraintFromDeclarationPattern(IDeclarationPatternOperationWrapper declaration, bool falseBranch, bool hasObjectConstraint);
    private static BoolConstraint BoolConstraintFromConstant(ProgramState state, IIsPatternOperationWrapper isPattern);
    private static SymbolicConstraint BoolConstraintFromPattern(ProgramState state, SymbolicValue value, IPatternOperationWrapper pattern);
    private static BoolConstraint BoolConstraintFromDeclarationPattern(ObjectConstraint valueConstraint, IDeclarationPatternOperationWrapper declaration);
    private static BoolConstraint BoolConstraintFromTypePattern(ObjectConstraint valueConstraint, ITypePatternOperationWrapper type);
    private static BoolConstraint BoolConstraintFromRecursivePattern(ObjectConstraint valueConstraint, IRecursivePatternOperationWrapper recursive);
    private static bool RecursivePatternAlwaysMatchesAnyNotNull(IRecursivePatternOperationWrapper recursive);
    private static bool SubPatternsAlwaysMatches(IRecursivePatternOperationWrapper recursivePattern);
    private static BoolConstraint BoolConstraintFromBinaryPattern(ProgramState state, SymbolicValue value, IBinaryPatternOperationWrapper binaryPattern);
    private static SymbolicConstraint BoolConstraintFromRelationalPattern(SymbolicValue value, IRelationalPatternOperationWrapper pattern);
    [CompilerGeneratedAttribute]
internal static T <LearnBranchingConstraint>g__As|3_0(Func`2<IOperation, T> fromOperation, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static BoolConstraint <BoolConstraintFromBinaryPattern>g__CombineAnd|15_0(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static BoolConstraint <BoolConstraintFromBinaryPattern>g__CombineOr|15_1(<>c__DisplayClass15_0& );
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.IsType : BranchingProcessor`1<IIsTypeOperationWrapper> {
    protected virtual IIsTypeOperationWrapper Convert(IOperation operation);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, IIsTypeOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, IIsTypeOperationWrapper operation, bool falseBranch);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.LocalReference : SimpleProcessor`1<ILocalReferenceOperationWrapper> {
    protected virtual ILocalReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, ILocalReferenceOperationWrapper localReference);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.MethodReference : SimpleProcessor`1<IMethodReferenceOperationWrapper> {
    protected virtual IMethodReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IMethodReferenceOperationWrapper operation);
}
internal abstract class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.MultiProcessor`1 : Processor`1<T> {
    protected abstract virtual ProgramState[] Process(SymbolicContext context, T operation);
    public sealed virtual ProgramState[] Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.NotNullOperation : object {
    public sealed virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ObjectCreation : SimpleProcessor`1<IObjectCreationOperationWrapper> {
    protected virtual IObjectCreationOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IObjectCreationOperationWrapper operation);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ParameterReference : SimpleProcessor`1<IParameterReferenceOperationWrapper> {
    protected virtual IParameterReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IParameterReferenceOperationWrapper parameterReference);
}
internal abstract class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Processor`1 : object {
    protected static ProgramState[] EmptyStates;
    private static Processor`1();
    protected abstract virtual T Convert(IOperation operation);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.PropertyReference : BranchingProcessor`1<IPropertyReferenceOperationWrapper> {
    protected virtual IPropertyReferenceOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState PreProcess(ProgramState state, IPropertyReferenceOperationWrapper operation, bool isInLoop);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, IPropertyReferenceOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, IPropertyReferenceOperationWrapper operation, bool falseBranch);
    private static bool IsNullableProperty(IPropertyReferenceOperationWrapper operation, string name);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.RecursivePattern : SimpleProcessor`1<IRecursivePatternOperationWrapper> {
    protected virtual IRecursivePatternOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IRecursivePatternOperationWrapper recursive);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.ReDimClause : SimpleProcessor`1<IReDimClauseOperationWrapper> {
    protected virtual IReDimClauseOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IReDimClauseOperationWrapper reDimClause);
}
internal abstract class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.SimpleProcessor`1 : Processor`1<T> {
    protected abstract virtual ProgramState Process(SymbolicContext context, T operation);
    public sealed virtual ProgramState Process(SymbolicContext context);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.StaticLocalInitializationSemaphore : SimpleProcessor`1<IStaticLocalInitializationSemaphoreOperationWrapper> {
    protected virtual IStaticLocalInitializationSemaphoreOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IStaticLocalInitializationSemaphoreOperationWrapper semaphore);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.TupleBinary : BinaryBase`1<ITupleBinaryOperationWrapper> {
    protected virtual ITupleBinaryOperationWrapper Convert(IOperation operation);
    protected virtual SymbolicConstraint BoolConstraintFromOperation(ProgramState state, ITupleBinaryOperationWrapper operation);
    protected virtual ProgramState LearnBranchingConstraint(ProgramState state, ITupleBinaryOperationWrapper operation, bool falseBranch);
    private static IEnumerable`1<Operands> TupleElements(IOperation leftSide, IOperation rightSide);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.OperationProcessors.Unary : SimpleProcessor`1<IUnaryOperationWrapper> {
    protected virtual IUnaryOperationWrapper Convert(IOperation operation);
    protected virtual ProgramState Process(SymbolicContext context, IUnaryOperationWrapper unary);
    private static ProgramState ProcessNot(ProgramState state, IUnaryOperationWrapper unary, SymbolicValue operandValue);
}
public static class SonarAnalyzer.SymbolicExecution.Roslyn.ProgramPoint : object {
    private static int BlockIndexBits;
    private static int BlockCountMax;
    private static int BitShift;
    public static bool HasSupportedSize(ControlFlowGraph cfg);
    public static int Hash(BasicBlock block, int instructionIndex);
}
[DefaultMemberAttribute("Item")]
public class SonarAnalyzer.SymbolicExecution.Roslyn.ProgramState : object {
    public static ProgramState Empty;
    private ProgramState[] toArray;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IOperation, SymbolicValue> <OperationValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SymbolicValue> <SymbolValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<int, int> <VisitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<CaptureId, IOperation> <CaptureOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ISymbol> <PreservedSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<ExceptionState> <Exceptions>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    private ImmutableDictionary`2<IOperation, SymbolicValue> OperationValue { get; private set; }
    private ImmutableDictionary`2<ISymbol, SymbolicValue> SymbolValue { get; private set; }
    private ImmutableDictionary`2<int, int> VisitCount { get; private set; }
    private ImmutableDictionary`2<CaptureId, IOperation> CaptureOperation { get; private set; }
    private ImmutableHashSet`1<ISymbol> PreservedSymbols { get; private set; }
    private ImmutableStack`1<ExceptionState> Exceptions { get; private set; }
    public ExceptionState Exception { get; }
    public SymbolicValue Item { get; }
    public SymbolicValue Item { get; }
    public SymbolicValue Item { get; }
    public SymbolicValue Item { get; }
    public IOperation Item { get; }
    protected ProgramState(ProgramState original);
    private static ProgramState();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IOperation, SymbolicValue> get_OperationValue();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OperationValue(ImmutableDictionary`2<IOperation, SymbolicValue> value);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SymbolicValue> get_SymbolValue();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolValue(ImmutableDictionary`2<ISymbol, SymbolicValue> value);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<int, int> get_VisitCount();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisitCount(ImmutableDictionary`2<int, int> value);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<CaptureId, IOperation> get_CaptureOperation();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CaptureOperation(ImmutableDictionary`2<CaptureId, IOperation> value);
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ISymbol> get_PreservedSymbols();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreservedSymbols(ImmutableHashSet`1<ISymbol> value);
    [CompilerGeneratedAttribute]
private ImmutableStack`1<ExceptionState> get_Exceptions();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Exceptions(ImmutableStack`1<ExceptionState> value);
    public ExceptionState get_Exception();
    public SymbolicValue get_Item(IOperationWrapperSonar operation);
    public SymbolicValue get_Item(IOperationWrapper operation);
    public SymbolicValue get_Item(IOperation operation);
    public SymbolicValue get_Item(ISymbol symbol);
    public IOperation get_Item(CaptureId capture);
    public ProgramState SetOperationAndSymbolValue(IOperation operation, SymbolicValue value);
    public ProgramState SetOperationValue(IOperationWrapper operation, SymbolicValue value);
    public ProgramState SetOperationValue(IOperationWrapperSonar operation, SymbolicValue value);
    public ProgramState SetOperationValue(IOperation operation, SymbolicValue value);
    public ProgramState SetOperationValue(IFlowCaptureReferenceOperationWrapper capture, SymbolicValue value);
    public ProgramState SetOperationConstraint(IOperationWrapper operation, SymbolicConstraint constraint);
    public ProgramState SetOperationConstraint(IOperationWrapperSonar operation, SymbolicConstraint constraint);
    public ProgramState SetOperationConstraint(IOperation operation, SymbolicConstraint constraint);
    public ProgramState SetSymbolValue(ISymbol symbol, SymbolicValue value);
    public ProgramState SetSymbolConstraint(ISymbol symbol, SymbolicConstraint constraint);
    public bool HasConstraint(IOperation operation, SymbolicConstraint constraint);
    public bool HasConstraint(ISymbol symbol, SymbolicConstraint constraint);
    public T Constraint(IOperation operation);
    public T Constraint(ISymbol symbol);
    public ProgramState SetCapture(CaptureId capture, IOperation operation);
    public ProgramState SetException(ExceptionState exception);
    public ProgramState PushException(ExceptionState exception);
    public ProgramState PopException();
    public IEnumerable`1<ISymbol> SymbolsWith(SymbolicConstraint constraint);
    public ProgramState ResetOperations();
    public ProgramState RemoveCapture(CaptureId capture);
    public IOperation ResolveCapture(IOperation operation);
    public IOperation ResolveCaptureAndUnwrapConversion(IOperation operation);
    public ProgramState RemoveSymbols(Func`2<ISymbol, bool> remove);
    public ProgramState ResetFieldConstraints();
    public ProgramState ResetStaticFieldConstraints(INamedTypeSymbol containingType);
    public ProgramState AddVisit(int programPointHash);
    public ProgramState Preserve(ISymbol symbol);
    public int GetVisitCount(int programPointHash);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ProgramState other);
    public ProgramState[] ToArray();
    public virtual string ToString();
    private ProgramState SetOperationValueCore(IOperation operation, SymbolicValue value);
    private string SerializeExceptions();
    private string SerializeSymbols();
    private string SerializeOperations();
    private string SerializeCaptures();
    private static string Serialize(ImmutableDictionary`2<TKey, TValue> dictionary, string title, Func`2<TKey, string> serializeKey, Func`2<TValue, string> serializeValue);
    private ProgramState ResetFieldConstraints(Func`2<IFieldSymbol, bool> predicate);
    [ConditionalAttribute("DEBUG_TurnedOff")]
[ExcludeFromCodeCoverageAttribute]
public void CheckConsistency();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProgramState left, ProgramState right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProgramState left, ProgramState right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ProgramState <Clone>$();
    [CompilerGeneratedAttribute]
internal static void <CheckConsistency>g__AssertCommonConditions|82_0(IEnumerable`1<SymbolicValue> values);
    [CompilerGeneratedAttribute]
internal static bool <CheckConsistency>g__CheckConstraintAlsoHasNotNull|82_1(SymbolicValue value);
    [CompilerGeneratedAttribute]
internal static bool <CheckConsistency>g__CheckOnlyConstraint|82_2(SymbolicValue value, SymbolicConstraint single);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.RoslynSymbolicExecution : object {
    internal static int MaxStepCount;
    private static int MaxOperationVisits;
    private ControlFlowGraph cfg;
    private SyntaxClassifierBase syntaxClassifier;
    private SymbolicCheckList checks;
    private CancellationToken cancel;
    private Queue`1<ExplodedNode> queue;
    private HashSet`1<ExplodedNode> visited;
    private RoslynLiveVariableAnalysis lva;
    private DebugLogger logger;
    private ExceptionCandidate exceptionCandidate;
    private LoopDetector loopDetector;
    public RoslynSymbolicExecution(ControlFlowGraph cfg, SyntaxClassifierBase syntaxClassifier, SymbolicCheck[] checks, CancellationToken cancel);
    public void Execute();
    private bool CheckVisitCount(ExplodedNode node, int visitCount);
    [IteratorStateMachineAttribute("SonarAnalyzer.SymbolicExecution.Roslyn.RoslynSymbolicExecution/<ProcessBranching>d__15")]
private IEnumerable`1<ExplodedNode> ProcessBranching(ExplodedNode node);
    private ExplodedNode ProcessBranch(ExplodedNode node, ControlFlowBranch branch);
    private ProgramState ProcessBranchState(BasicBlock block, ControlFlowBranch branch, ProgramState state);
    [IteratorStateMachineAttribute("SonarAnalyzer.SymbolicExecution.Roslyn.RoslynSymbolicExecution/<ProcessOperation>d__18")]
private IEnumerable`1<ExplodedNode> ProcessOperation(ExplodedNode node);
    [IteratorStateMachineAttribute("SonarAnalyzer.SymbolicExecution.Roslyn.RoslynSymbolicExecution/<ExceptionSuccessors>d__19")]
private IEnumerable`1<ExplodedNode> ExceptionSuccessors(ExplodedNode node, ExceptionState exception, ControlFlowRegion nearestTryRegion);
    private static ExceptionState ThrownException(ExplodedNode node, ControlFlowBranchSemantics semantics);
    private static ProgramState SetBranchingConstraints(ControlFlowBranch branch, ProgramState state, IOperation branchValue);
    private static ProgramState InitLocals(ControlFlowBranch branch, ProgramState state);
    private static bool IsReachable(ExplodedNode node, ControlFlowBranch branch);
    private static bool IsReachable(ControlFlowBranch branch, bool condition, bool constraint);
    private static bool IsReachable(ControlFlowRegion region, ExceptionState thrown);
    [CompilerGeneratedAttribute]
private bool <CheckVisitCount>g__IsLoopCondition|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
private bool <CheckVisitCount>g__IsInBranchValue|14_1(IOperation current, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
private ExplodedNode <ProcessBranch>g__FromFinally|16_0(FinallyPoint finallyPoint, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
private ExplodedNode <ProcessBranch>g__CreateNode|16_1(BasicBlock block, FinallyPoint finallyPoint, <>c__DisplayClass16_0& );
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CalculationsShouldNotOverflowBase : SymbolicRuleCheck {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static string MessageLikely;
    private static string MessageGuaranteed;
    private static string MessageUnderflow;
    private static string MessageOverflow;
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
    private static SymbolicValue OverflowCandidateValue(ProgramState state, IOperation operation);
    private static bool CanOverflow(BinaryOperatorKind kind);
    private static NumberConstraint Bounds(ITypeSymbol type);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.ConditionEvaluatesToConstantBase : SymbolicRuleCheck {
    protected static string DiagnosticId2583;
    protected static string DiagnosticId2589;
    protected static string MessageFormat;
    private static string MessageBool;
    private static string S2583MessageSuffix;
    private Dictionary`2<IOperation, BasicBlock> trueOperations;
    private Dictionary`2<IOperation, BasicBlock> falseOperations;
    private Dictionary`2<IOperation, BasicBlock> unknownOperations;
    private List`1<IOperation> reachedOperations;
    protected DiagnosticDescriptor Rule2583 { get; }
    protected DiagnosticDescriptor Rule2589 { get; }
    protected string NullName { get; }
    private string MessageNull { get; }
    protected abstract virtual DiagnosticDescriptor get_Rule2583();
    protected abstract virtual DiagnosticDescriptor get_Rule2589();
    protected abstract virtual string get_NullName();
    private string get_MessageNull();
    protected abstract virtual bool IsInsideUsingDeclaration(SyntaxNode node);
    protected abstract virtual bool IsLockStatement(SyntaxNode syntax);
    public virtual ProgramState[] PreProcess(SymbolicContext context);
    public virtual ProgramState ConditionEvaluated(SymbolicContext context);
    private bool IsIgnored(ProgramState state, IOperation operation);
    private static bool IsVarPattern(IOperation operation);
    private static bool IsDiscardPattern(ProgramState state, IOperation operation);
    public virtual void ExecutionCompleted();
    private void ReportIssue(IOperation operation, BasicBlock block, bool conditionValue);
    private List`1<SecondaryLocation> SecondaryLocations(BasicBlock block, bool conditionValue, int spanStart);
    private List`1<SyntaxNode> UnreachableOperations(BasicBlock block, bool conditionValue);
    [CompilerGeneratedAttribute]
private bool <IsIgnored>b__21_0(SyntaxNode x);
    [CompilerGeneratedAttribute]
internal static void <UnreachableOperations>g__Traverse|27_2(ControlFlowBranch branch, HashSet`1<BasicBlock> result, ICollection`1<BasicBlock> excluded);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.CryptographyRuleBase : SymbolicRuleCheck {
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    protected virtual ProgramState ProcessArrayCreation(ProgramState state, IArrayCreationOperationWrapper arrayCreation);
    protected virtual ProgramState ProcessInvocation(ProgramState state, IInvocationOperationWrapper invocation);
    protected static IOperation FindInvocationArgument(ProgramState state, ImmutableArray`1<IOperation> arguments, KnownType argumentType, String[] nameCandidates);
    private static bool IsArgumentMatch(ProgramState state, IOperation operation, KnownType argumentType, String[] nameCandidates);
    private static bool IsCryptographicallyStrongRandomNumberGenerator(IInvocationOperationWrapper invocation);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.EmptyCollectionsShouldNotBeEnumeratedBase : SymbolicRuleCheck {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected static HashSet`1<string> RaisingMethods;
    private HashSet`1<IOperation> emptyAccess;
    private HashSet`1<IOperation> nonEmptyAccess;
    private static EmptyCollectionsShouldNotBeEnumeratedBase();
    public virtual void ExecutionCompleted();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.EmptyNullableValueAccessBase : SymbolicRuleCheck {
    internal static string DiagnosticId;
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    [CompilerGeneratedAttribute]
private NullableFlowState <PreProcessSimple>g__FlowState|1_0(IOperation reference);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.EmptyRuleCheck : SymbolicRuleCheck {
    protected DiagnosticDescriptor Rule { get; }
    protected virtual DiagnosticDescriptor get_Rule();
    public virtual bool ShouldExecute();
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.HashesShouldHaveUnpredictableSaltBase : CryptographyRuleBase {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static string MakeSaltUnpredictableMessage;
    private static string MakeThisSaltLongerMessage;
    private static BigInteger SafeSaltSize;
    private static String[] DeriveBytesSaltParameterNames;
    private static HashesShouldHaveUnpredictableSaltBase();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    protected virtual ProgramState ProcessArrayCreation(ProgramState state, IArrayCreationOperationWrapper arrayCreation);
    private ProgramState ProcessObjectCreation(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    protected virtual ProgramState ProcessInvocation(ProgramState state, IInvocationOperationWrapper invocation);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.InitializationVectorShouldBeRandomBase : CryptographyRuleBase {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    private static ProgramState ProcessProperyReference(ProgramState state, IPropertyReferenceOperationWrapper property);
    private static ProgramState ProcessAssignmentToIVProperty(ProgramState state, IAssignmentOperationWrapper assignment);
    private static ProgramState ProcessGenerateIV(ProgramState state, IInvocationOperationWrapper invocation);
    private ProgramState ProcessCreateEncryptorMethodInvocation(ProgramState state, IInvocationOperationWrapper invocation);
    private static bool IsCreateEncryptorMethod(IInvocationOperationWrapper invocation);
    private static bool IsIVProperty(IPropertyReferenceOperationWrapper property, ISymbol propertyInstance);
    [CompilerGeneratedAttribute]
internal static bool <ProcessCreateEncryptorMethodInvocation>g__ArgumentIsCryptographicallyWeak|6_0(ProgramState state, IInvocationOperationWrapper invocation);
    [CompilerGeneratedAttribute]
internal static bool <ProcessCreateEncryptorMethodInvocation>g__UsesCryptographicallyWeakIVProperty|6_1(ProgramState state, IInvocationOperationWrapper invocation);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.LocksReleasedAllPathsBase : SymbolicRuleCheck {
    internal static string DiagnosticId;
    protected static string MessageFormat;
    private HashSet`1<ISymbol> releasedSymbols;
    private HashSet`1<ISymbol> exitHeldSymbols;
    private Dictionary`2<ISymbol, IOperationWrapperSonar> lastSymbolLock;
    private static String[] ReaderWriterLockSlimLockMethods;
    private static String[] IsLockHeldProperties;
    private static LocksReleasedAllPathsBase();
    protected abstract virtual ISafeSyntaxWalker CreateSyntaxWalker(LockAcquireReleaseCollector collector);
    public virtual void ExitReached(SymbolicContext context);
    public virtual void ExecutionCompleted();
    public virtual bool ShouldExecute();
    public virtual ProgramState[] PostProcess(SymbolicContext context);
    public virtual ProgramState ConditionEvaluated(SymbolicContext context);
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
    private ProgramState ProcessMonitorEnter(SymbolicContext context, IInvocationOperationWrapper invocation);
    private ProgramState ProcessMonitorExit(SymbolicContext context, IInvocationOperationWrapper invocation);
    private ProgramState ProcessInvocationInstanceAcquireLock(SymbolicContext context, IInvocationOperationWrapper invocation);
    private ProgramState ProcessInvocationInstanceReleaseLock(SymbolicContext context, IInvocationOperationWrapper invocation);
    private ProgramState AddLock(SymbolicContext context, ISymbol symbol);
    private ProgramState RemoveLock(SymbolicContext context, ISymbol symbol);
    private static ProgramState AddLock(SymbolicContext context, IOperation operation);
    private static ISymbol ArgumentSymbol(ProgramState state, IInvocationOperationWrapper invocation, int parameterIndex);
    private static ISymbol FindLockSymbolWithConditionalReturnValue(SymbolicContext context);
    private static RefParamContext FindRefParam(SymbolicContext context);
    private static RefParamContext BoolRefParamFromArgument(SymbolicContext context, KnownType type, String[] methodNames);
    private static RefParamContext BoolRefParamFromInstance(SymbolicContext context, KnownType type, String[] methodNames);
    private static ISymbol InvocationBoolRefSymbol(ProgramState state, IInvocationOperationWrapper invocation, KnownType type, String[] methodNames);
    [CompilerGeneratedAttribute]
private bool <ExecutionCompleted>b__9_0(ISymbol x);
    [CompilerGeneratedAttribute]
private ProgramState <ConditionEvaluated>g__ProcessCondition|12_0(ISymbol lockSymbol, <>c__DisplayClass12_0& );
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.NullPointerDereferenceBase : SymbolicRuleCheck {
    internal static string DiagnosticId;
    protected virtual bool IsSupressed(SyntaxNode node);
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    private static IOperation NullDereferenceCandidate(IOperation operation);
    private static IOperation NullInstanceCandidate(IInvocationOperationWrapper operation);
    private static IOperation NullInstanceCandidate(IPropertyReferenceOperationWrapper operation);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.ObjectsShouldNotBeDisposedMoreThanOnceBase : SymbolicRuleCheck {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected abstract virtual bool IsDispose(IMethodSymbol method);
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.PublicMethodArgumentsShouldBeCheckedForNullBase : SymbolicRuleCheck {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    protected string NullName { get; }
    protected abstract virtual bool IsInConstructorInitializer(SyntaxNode node);
    protected abstract virtual string get_NullName();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
    protected bool IsAccessibleFromOtherAssemblies();
    private static IOperation NullDereferenceCandidate(IOperation operation);
    private static IOperation AssignmentTarget(IOperation operation);
    private static bool IsInsideRazorGeneratedCode(IOperation candidate);
    [CompilerGeneratedAttribute]
internal static bool <PreProcessSimple>g__MissesObjectConstraint|5_0(SymbolicValue symbolState);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.RuleChecks.RestrictDeserializedTypesBase : SymbolicRuleCheck {
    protected static string DiagnosticId;
    protected static string MessageFormat;
    private static string RestrictTypesMessage;
    private static string VerifyMacMessage;
    private static string SecondaryMessage;
    private static KnownType[] FormattersWithBinderProperty;
    private static KnownType JavaScriptSerializer;
    private static KnownType LosFormatter;
    private static KnownType[] TypesWithDeserializeMethod;
    private Dictionary`2<ISymbol, SyntaxNode> unsafeMethodsForSymbols;
    private Dictionary`2<IOperation, SyntaxNode> unsafeMethodsForOperations;
    private static RestrictDeserializedTypesBase();
    protected abstract virtual SyntaxNode FindBindToTypeMethodDeclaration(IOperation operation);
    protected abstract virtual SyntaxNode FindResolveTypeMethodDeclaration(IOperation operation);
    protected abstract virtual bool ThrowsOrReturnsNull(SyntaxNode methodDeclaration);
    protected abstract virtual SyntaxToken GetIdentifier(SyntaxNode methodDeclaration);
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    private ProgramState ProcessOtherSerializerCreations(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    private bool UnsafeJavaScriptSerializer(ProgramState state, IObjectCreationOperationWrapper objectCreation, SyntaxNode& resolveTypeDeclaration);
    private bool UnsafeResolver(ProgramState state, IOperation operation, SyntaxNode& resolveTypeDeclaration);
    private static bool EnableMacIsTrue(ProgramState state, IObjectCreationOperationWrapper objectCreation);
    private ProgramState ProcessBinderAssignment(ProgramState state, IAssignmentOperationWrapper assignment);
    private static IOperation BinderAssignmentInstance(ProgramState state, IAssignmentOperationWrapper assignment);
    private bool BinderIsSafe(ProgramState state, IAssignmentOperationWrapper assignment, SyntaxNode& bindToTypeDeclaration);
    private SyntaxNode UnsafeMethodDeclaration(ProgramState state, IOperation operation);
    private static Nullable`1<IInvocationOperationWrapper> UnsafeDeserialization(ProgramState state, IOperation operation);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.SymbolicCheck : object {
    protected static ProgramState[] EmptyStates;
    private static SymbolicCheck();
    public virtual ProgramState ConditionEvaluated(SymbolicContext context);
    public virtual ProgramState[] PreProcess(SymbolicContext context);
    public virtual ProgramState[] PostProcess(SymbolicContext context);
    public virtual void ExitReached(SymbolicContext context);
    public virtual void ExecutionCompleted();
    protected virtual ProgramState PreProcessSimple(SymbolicContext context);
    protected virtual ProgramState PostProcessSimple(SymbolicContext context);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.SymbolicCheckList : object {
    private SymbolicCheck[] checks;
    public SymbolicCheckList(SymbolicCheck[] checks);
    public ProgramState ConditionEvaluated(SymbolicContext context);
    public void ExitReached(SymbolicContext context);
    public void ExecutionCompleted();
    public SymbolicContext[] PreProcess(SymbolicContext context);
    public SymbolicContext[] PostProcess(SymbolicContext context);
    private SymbolicContext[] InvokeChecks(SymbolicContext context, bool preProcess);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.SymbolicContext : object {
    [CompilerGeneratedAttribute]
private BasicBlock <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationWrapperSonar <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInLoop>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ISymbol> <CapturedVariables>k__BackingField;
    public BasicBlock Block { get; }
    public IOperationWrapperSonar Operation { get; }
    public ProgramState State { get; }
    public bool IsInLoop { get; }
    public IReadOnlyCollection`1<ISymbol> CapturedVariables { get; }
    public SymbolicContext(ExplodedNode node, IReadOnlyCollection`1<ISymbol> capturedVariables, bool isInLoop);
    public SymbolicContext(BasicBlock block, IOperationWrapperSonar operation, ProgramState state, bool isInLoop, IReadOnlyCollection`1<ISymbol> capturedVariables);
    [CompilerGeneratedAttribute]
public BasicBlock get_Block();
    [CompilerGeneratedAttribute]
public IOperationWrapperSonar get_Operation();
    [CompilerGeneratedAttribute]
public ProgramState get_State();
    [CompilerGeneratedAttribute]
public bool get_IsInLoop();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ISymbol> get_CapturedVariables();
    public ProgramState SetOperationConstraint(SymbolicConstraint constraint);
    public ProgramState SetSymbolConstraint(ISymbol symbol, SymbolicConstraint constraint);
    public ProgramState SetOperationValue(SymbolicValue value);
    public SymbolicContext WithState(ProgramState newState);
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.SymbolicRuleCheck : SymbolicCheck {
    private HashSet`1<Location> reportedDiagnostics;
    private SonarSyntaxNodeReportingContext context;
    [CompilerGeneratedAttribute]
private SonarAnalysisContext <SonarContext>k__BackingField;
    protected DiagnosticDescriptor Rule { get; }
    protected SonarAnalysisContext SonarContext { get; private set; }
    protected SyntaxNode Node { get; }
    protected SemanticModel SemanticModel { get; }
    protected ISymbol ContainingSymbol { get; }
    public abstract virtual bool ShouldExecute();
    protected abstract virtual DiagnosticDescriptor get_Rule();
    [CompilerGeneratedAttribute]
protected SonarAnalysisContext get_SonarContext();
    [CompilerGeneratedAttribute]
private void set_SonarContext(SonarAnalysisContext value);
    protected SyntaxNode get_Node();
    protected SemanticModel get_SemanticModel();
    protected ISymbol get_ContainingSymbol();
    public void Init(SonarAnalysisContext sonarContext, SonarSyntaxNodeReportingContext nodeContext);
    protected void ReportIssue(IOperationWrapperSonar operation, String[] messageArgs);
    protected void ReportIssue(IOperation operation, String[] messageArgs);
    protected void ReportIssue(IOperation operation, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    private void ReportIssue(DiagnosticDescriptor rule, IOperation operation, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
    protected void ReportIssue(DiagnosticDescriptor rule, SyntaxNode syntax, IEnumerable`1<SecondaryLocation> secondaryLocations, String[] messageArgs);
}
public class SonarAnalyzer.SymbolicExecution.Roslyn.SymbolicValue : object {
    private static ConcurrentDictionary`2<CacheKey, SymbolicValue> cache;
    public static SymbolicValue Empty;
    public static SymbolicValue Null;
    public static SymbolicValue NotNull;
    public static SymbolicValue True;
    public static SymbolicValue False;
    private ImmutableDictionary`2<Type, SymbolicConstraint> constraints;
    private Nullable`1<int> hashCode;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    private ImmutableDictionary`2<Type, SymbolicConstraint> Constraints { get; private set; }
    public IEnumerable`1<SymbolicConstraint> AllConstraints { get; }
    [CompilerGeneratedAttribute]
private SymbolicValue(SymbolicValue original);
    private static SymbolicValue();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    private ImmutableDictionary`2<Type, SymbolicConstraint> get_Constraints();
    private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Constraints(ImmutableDictionary`2<Type, SymbolicConstraint> value);
    public IEnumerable`1<SymbolicConstraint> get_AllConstraints();
    public virtual string ToString();
    public SymbolicValue WithConstraint(SymbolicConstraint constraint);
    public SymbolicValue WithoutConstraint(SymbolicConstraint constraint);
    public SymbolicValue WithoutConstraint();
    public bool HasConstraint();
    public bool HasConstraint(SymbolicConstraint constraint);
    public T Constraint();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SymbolicValue other);
    private string SerializeConstraints();
    private SymbolicValue RemoveConstraint(Type type);
    private SymbolicValue OtherSingle(Type except);
    private SymbolicConstraint OtherSingleConstraint(Type except);
    private SymbolicValue OtherPair(Type except);
    private static SymbolicValue CachedSymbolicValue(SymbolicConstraint first, SymbolicConstraint second);
    private static SymbolicValue CreateSymbolicValue(SymbolicConstraint first, SymbolicConstraint second);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SymbolicValue left, SymbolicValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SymbolicValue left, SymbolicValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SymbolicValue <Clone>$();
}
public abstract class SonarAnalyzer.SymbolicExecution.Roslyn.SyntaxClassifierBase : object {
    protected abstract virtual bool IsCfgBoundary(SyntaxNode node);
    protected abstract virtual bool IsStatement(SyntaxNode node);
    protected abstract virtual SyntaxNode ParentLoopCondition(SyntaxNode node);
    public bool IsInLoopCondition(SyntaxNode node);
}
internal class SonarAnalyzer.SymbolicExecution.Roslyn.TypeCatalog : object {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemIndexOutOfRangeException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemNullReferenceException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemInvalidCastException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemArgumentOutOfRangeException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemDivideByZeroException>k__BackingField;
    public INamedTypeSymbol SystemIndexOutOfRangeException { get; }
    public INamedTypeSymbol SystemNullReferenceException { get; }
    public INamedTypeSymbol SystemInvalidCastException { get; }
    public INamedTypeSymbol SystemArgumentOutOfRangeException { get; }
    public INamedTypeSymbol SystemDivideByZeroException { get; }
    public TypeCatalog(Compilation compilation);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemIndexOutOfRangeException();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemNullReferenceException();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemInvalidCastException();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemArgumentOutOfRangeException();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemDivideByZeroException();
}
public abstract class SonarAnalyzer.SymbolicExecution.SymbolicConstraint : object {
    [CompilerGeneratedAttribute]
private ConstraintKind <Kind>k__BackingField;
    public ConstraintKind Kind { get; }
    public SymbolicConstraint Opposite { get; }
    public bool PreserveOnFieldReset { get; }
    public bool CacheEnabled { get; }
    protected SymbolicConstraint(ConstraintKind kind);
    [CompilerGeneratedAttribute]
public ConstraintKind get_Kind();
    public abstract virtual SymbolicConstraint get_Opposite();
    public virtual bool get_PreserveOnFieldReset();
    public virtual bool get_CacheEnabled();
    public virtual string ToString();
    public SymbolicConstraint ApplyOpposite(bool useOpposite);
}
public class SonarAnalyzer.SymbolicExecution.SymbolicExecutionException : Exception {
    public SymbolicExecutionException(string message);
    public SymbolicExecutionException(string message, Exception innerException);
    public SymbolicExecutionException(Exception ex, ISymbol symbol, Location location);
    [ExcludeFromCodeCoverageAttribute]
private SymbolicExecutionException(SerializationInfo info, StreamingContext context);
    private static string Serialize(Exception ex, ISymbol symbol, Location location);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
