[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
public class TechTalk.SpecFlow.AfterAttribute : AfterScenarioAttribute {
    public AfterAttribute(String[] tags);
}
public class TechTalk.SpecFlow.AfterFeatureAttribute : HookAttribute {
    public AfterFeatureAttribute(String[] tags);
}
public class TechTalk.SpecFlow.AfterScenarioAttribute : HookAttribute {
    public AfterScenarioAttribute(String[] tags);
}
public class TechTalk.SpecFlow.AfterScenarioBlockAttribute : HookAttribute {
    public AfterScenarioBlockAttribute(String[] tags);
}
public class TechTalk.SpecFlow.AfterStepAttribute : HookAttribute {
    public AfterStepAttribute(String[] tags);
}
public class TechTalk.SpecFlow.AfterTestRunAttribute : HookAttribute {
}
public class TechTalk.SpecFlow.Analytics.AnalyticsEventProvider : object {
    private IUserUniqueIdStore _userUniqueIdStore;
    private IEnvironmentWrapper _environmentWrapper;
    private string _unitTestProvider;
    private Dictionary`2<string, string> buildServerTypes;
    public AnalyticsEventProvider(IUserUniqueIdStore userUniqueIdStore, UnitTestProviderConfiguration unitTestProviderConfiguration, IEnvironmentWrapper environmentWrapper);
    public sealed virtual SpecFlowProjectCompilingEvent CreateProjectCompilingEvent(string msbuildVersion, string assemblyName, string targetFrameworks, string targetFramework, string projectGuid);
    public sealed virtual SpecFlowProjectRunningEvent CreateProjectRunningEvent(string testAssemblyName);
    private string GetOSPlatform();
    private string GetBuildServerName();
    private bool IsRunningInDockerContainer();
    private string GetSpecFlowVersion();
    private string ToSha256(string inputString);
    private string GetNetCoreVersion();
}
public class TechTalk.SpecFlow.Analytics.AnalyticsTransmitter : object {
    private IAnalyticsTransmitterSink _analyticsTransmitterSink;
    private IEnvironmentSpecFlowTelemetryChecker _environmentSpecFlowTelemetryChecker;
    public bool IsEnabled { get; }
    public AnalyticsTransmitter(IAnalyticsTransmitterSink analyticsTransmitterSink, IEnvironmentSpecFlowTelemetryChecker environmentSpecFlowTelemetryChecker);
    public sealed virtual bool get_IsEnabled();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Analytics.AnalyticsTransmitter/<TransmitSpecFlowProjectCompilingEventAsync>d__5")]
public sealed virtual Task`1<IResult> TransmitSpecFlowProjectCompilingEventAsync(SpecFlowProjectCompilingEvent projectCompilingEvent);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Analytics.AnalyticsTransmitter/<TransmitSpecFlowProjectRunningEventAsync>d__6")]
public sealed virtual Task`1<IResult> TransmitSpecFlowProjectRunningEventAsync(SpecFlowProjectRunningEvent projectRunningEvent);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Analytics.AnalyticsTransmitter/<TransmitEventAsync>d__7")]
public Task`1<IResult> TransmitEventAsync(IAnalyticsEvent analyticsEvent);
}
public class TechTalk.SpecFlow.Analytics.AppInsights.AppInsightsEventSerializer : object {
    public sealed virtual Byte[] SerializeAnalyticsEvent(IAnalyticsEvent analyticsEvent, string instrumentationKey);
}
public class TechTalk.SpecFlow.Analytics.AppInsights.AppInsightsEventTelemetry : object {
    [CompilerGeneratedAttribute]
private string <DataTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryData <TelemetryData>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <TelemetryTags>k__BackingField;
    private static string DefaultValue;
    [DataMemberAttribute]
public string DataTypeName { get; public set; }
    [DataMemberAttribute]
public string EventDateTime { get; public set; }
    [DataMemberAttribute]
public string InstrumentationKey { get; public set; }
    [DataMemberAttribute]
public TelemetryData TelemetryData { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> TelemetryTags { get; public set; }
    public AppInsightsEventTelemetry(IAnalyticsEvent analyticsEvent, string instrumentationKey);
    [CompilerGeneratedAttribute]
public string get_DataTypeName();
    [CompilerGeneratedAttribute]
public void set_DataTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_EventDateTime();
    [CompilerGeneratedAttribute]
public void set_EventDateTime(string value);
    [CompilerGeneratedAttribute]
public string get_InstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_InstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public TelemetryData get_TelemetryData();
    [CompilerGeneratedAttribute]
public void set_TelemetryData(TelemetryData value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_TelemetryTags();
    [CompilerGeneratedAttribute]
public void set_TelemetryTags(Dictionary`2<string, string> value);
}
public static class TechTalk.SpecFlow.Analytics.AppInsights.AppInsightsInstrumentationKey : object {
    public static string Key;
}
public interface TechTalk.SpecFlow.Analytics.AppInsights.IAppInsightsEventSerializer {
    public abstract virtual Byte[] SerializeAnalyticsEvent(IAnalyticsEvent analyticsEvent, string instrumentationKey);
}
public class TechTalk.SpecFlow.Analytics.AppInsights.TelemetryData : object {
    [CompilerGeneratedAttribute]
private string <ItemTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryDataItem <TelemetryDataItem>k__BackingField;
    [DataMemberAttribute]
public string ItemTypeName { get; public set; }
    [DataMemberAttribute]
public TelemetryDataItem TelemetryDataItem { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ItemTypeName();
    [CompilerGeneratedAttribute]
public void set_ItemTypeName(string value);
    [CompilerGeneratedAttribute]
public TelemetryDataItem get_TelemetryDataItem();
    [CompilerGeneratedAttribute]
public void set_TelemetryDataItem(TelemetryDataItem value);
}
public class TechTalk.SpecFlow.Analytics.AppInsights.TelemetryDataItem : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [DataMemberAttribute]
public string EndPointSchemaVersion { get; }
    [DataMemberAttribute]
public string EventName { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    public string get_EndPointSchemaVersion();
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
}
public class TechTalk.SpecFlow.Analytics.EnvironmentSpecFlowTelemetryChecker : object {
    public static string SpecFlowTelemetryEnvironmentVariable;
    public sealed virtual bool IsSpecFlowTelemetryEnabled();
}
public class TechTalk.SpecFlow.Analytics.HttpClientAnalyticsTransmitterSink : object {
    private IAppInsightsEventSerializer _appInsightsEventSerializer;
    private HttpClientWrapper _httpClientWrapper;
    private Uri _appInsightsDataCollectionEndPoint;
    private Uri EndPoint { get; }
    public HttpClientAnalyticsTransmitterSink(IAppInsightsEventSerializer appInsightsEventSerializer, HttpClientWrapper httpClientWrapper);
    private Uri get_EndPoint();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Analytics.HttpClientAnalyticsTransmitterSink/<TransmitEventAsync>d__6")]
public sealed virtual Task`1<IResult> TransmitEventAsync(IAnalyticsEvent analyticsEvent, string instrumentationKey);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Analytics.HttpClientAnalyticsTransmitterSink/<TransmitEventInternalAsync>d__7")]
private Task TransmitEventInternalAsync(IAnalyticsEvent analyticsEvent, string instrumentationKey);
}
public class TechTalk.SpecFlow.Analytics.HttpClientWrapper : object {
    private HttpClient httpClient;
    public HttpClient HttpClient { get; }
    public HttpClient get_HttpClient();
}
public interface TechTalk.SpecFlow.Analytics.IAnalyticsEvent {
    public string EventName { get; }
    public DateTime UtcDate { get; }
    public string UserId { get; }
    public string Platform { get; }
    public string PlatformDescription { get; }
    public string SpecFlowVersion { get; }
    public string UnitTestProvider { get; }
    public bool IsBuildServer { get; }
    public string BuildServerName { get; }
    public bool IsDockerContainer { get; }
    public string HashedAssemblyName { get; }
    public string TargetFrameworks { get; }
    public string TargetFramework { get; }
    public abstract virtual string get_EventName();
    public abstract virtual DateTime get_UtcDate();
    public abstract virtual string get_UserId();
    public abstract virtual string get_Platform();
    public abstract virtual string get_PlatformDescription();
    public abstract virtual string get_SpecFlowVersion();
    public abstract virtual string get_UnitTestProvider();
    public abstract virtual bool get_IsBuildServer();
    public abstract virtual string get_BuildServerName();
    public abstract virtual bool get_IsDockerContainer();
    public abstract virtual string get_HashedAssemblyName();
    public abstract virtual string get_TargetFrameworks();
    public abstract virtual string get_TargetFramework();
}
public interface TechTalk.SpecFlow.Analytics.IAnalyticsEventProvider {
    public abstract virtual SpecFlowProjectCompilingEvent CreateProjectCompilingEvent(string msbuildVersion, string assemblyName, string targetFrameworks, string targetFramework, string projectGuid);
    public abstract virtual SpecFlowProjectRunningEvent CreateProjectRunningEvent(string testAssemblyName);
}
public interface TechTalk.SpecFlow.Analytics.IAnalyticsTransmitter {
    public bool IsEnabled { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual Task`1<IResult> TransmitSpecFlowProjectCompilingEventAsync(SpecFlowProjectCompilingEvent projectCompilingEvent);
    public abstract virtual Task`1<IResult> TransmitSpecFlowProjectRunningEventAsync(SpecFlowProjectRunningEvent projectRunningEvent);
}
public interface TechTalk.SpecFlow.Analytics.IAnalyticsTransmitterSink {
    public abstract virtual Task`1<IResult> TransmitEventAsync(IAnalyticsEvent analyticsEvent, string instrumentationKey);
}
public interface TechTalk.SpecFlow.Analytics.IEnvironmentSpecFlowTelemetryChecker {
    public abstract virtual bool IsSpecFlowTelemetryEnabled();
}
public abstract class TechTalk.SpecFlow.Analytics.SpecFlowAnalyticsEventBase : object {
    [CompilerGeneratedAttribute]
private DateTime <UtcDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpecFlowVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnitTestProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuildServer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashedAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDockerContainer>k__BackingField;
    public string EventName { get; }
    public DateTime UtcDate { get; }
    public string UserId { get; }
    public string Platform { get; }
    public string PlatformDescription { get; }
    public string SpecFlowVersion { get; }
    public string UnitTestProvider { get; }
    public bool IsBuildServer { get; }
    public string BuildServerName { get; }
    public string HashedAssemblyName { get; }
    public string TargetFrameworks { get; }
    public string TargetFramework { get; }
    public bool IsDockerContainer { get; }
    protected SpecFlowAnalyticsEventBase(DateTime utcDate, string userId, string platform, string platformDescription, string specFlowVersion, string unitTestProvider, string buildServerName, string hashedAssemblyName, string targetFrameworks, string targetFramework, bool isDockerContainer);
    public abstract virtual string get_EventName();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_UtcDate();
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PlatformDescription();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SpecFlowVersion();
    [CompilerGeneratedAttribute]
public sealed virtual string get_UnitTestProvider();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBuildServer();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BuildServerName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HashedAssemblyName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDockerContainer();
}
public class TechTalk.SpecFlow.Analytics.SpecFlowProjectCompilingEvent : SpecFlowAnalyticsEventBase {
    [CompilerGeneratedAttribute]
private string <MSBuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectGuid>k__BackingField;
    public string MSBuildVersion { get; }
    public string ProjectGuid { get; public set; }
    public string EventName { get; }
    public SpecFlowProjectCompilingEvent(DateTime utcDate, string userId, string platform, string platformDescription, string specFlowVersion, string unitTestProvider, string buildServerName, string hashedAssemblyName, string targetFrameworks, string targetFramework, string msBuildVersion, string projectGuid, bool isDockerContainer);
    [CompilerGeneratedAttribute]
public string get_MSBuildVersion();
    [CompilerGeneratedAttribute]
public string get_ProjectGuid();
    [CompilerGeneratedAttribute]
public void set_ProjectGuid(string value);
    public virtual string get_EventName();
}
public class TechTalk.SpecFlow.Analytics.SpecFlowProjectRunningEvent : SpecFlowAnalyticsEventBase {
    public string EventName { get; }
    public SpecFlowProjectRunningEvent(DateTime utcDate, string userId, string platform, string platformDescription, string specFlowVersion, string unitTestProvider, string buildServerName, string hashedAssemblyName, string targetFrameworks, string targetFramework, bool isDockerContainer);
    public virtual string get_EventName();
}
public class TechTalk.SpecFlow.Analytics.UserId.DirectoryService : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual void CreateDirectory(string path);
}
public class TechTalk.SpecFlow.Analytics.UserId.FileService : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual void WriteAllText(string path, string contents);
}
public class TechTalk.SpecFlow.Analytics.UserId.FileUserIdStore : object {
    private static string appDataFolder;
    public static string UserIdFilePath;
    private Lazy`1<string> _lazyUniqueUserId;
    private IFileService _fileService;
    private IDirectoryService _directoryService;
    public FileUserIdStore(IFileService fileService, IDirectoryService directoryService);
    private static FileUserIdStore();
    public sealed virtual string GetUserId();
    private string FetchAndPersistUserId();
    private void PersistUserId(string userId);
    private bool IsValidGuid(string guid);
    private string GenerateAndPersistUserId();
}
public interface TechTalk.SpecFlow.Analytics.UserId.IDirectoryService {
    public abstract virtual bool Exists(string path);
    public abstract virtual void CreateDirectory(string path);
}
public interface TechTalk.SpecFlow.Analytics.UserId.IFileService {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual void WriteAllText(string path, string contents);
}
public interface TechTalk.SpecFlow.Analytics.UserId.IUserUniqueIdStore {
    public abstract virtual string GetUserId();
}
[AttributeUsageAttribute("384")]
public class TechTalk.SpecFlow.Assist.Attributes.TableAliasesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    public String[] Aliases { get; }
    public TableAliasesAttribute(String[] aliases);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
}
public class TechTalk.SpecFlow.Assist.ComparisonException : Exception {
    public ComparisonException(string message);
}
public class TechTalk.SpecFlow.Assist.EnumerableProjection`1 : object {
    private IEnumerable`1<T> collection;
    private IEnumerable`1<string> properties;
    public EnumerableProjection`1(Table table, IEnumerable`1<T> collection);
    public sealed virtual IEnumerator`1<Projection`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.FindInSetExtensionMethods : object {
    [ExtensionAttribute]
public static T FindInSet(Table table, IEnumerable`1<T> set);
    [ExtensionAttribute]
public static IEnumerable`1<T> FindAllInSet(Table table, IEnumerable`1<T> set);
    private static bool InstanceMatchesTable(T instance, Table table);
}
internal class TechTalk.SpecFlow.Assist.FormattingTableDiffExceptionBuilder`1 : object {
    private ITableDiffExceptionBuilder`1<T> parent;
    public FormattingTableDiffExceptionBuilder`1(ITableDiffExceptionBuilder`1<T> parent);
    public sealed virtual string GetTheTableDiffExceptionMessage(TableDifferenceResults`1<T> tableDifferenceResults);
    private Dictionary`2<int, int> GetTheMaximumLengthsOfEachColumn(string message);
    private static void SetMaximumLengthForThisColumn(IDictionary`2<int, int> dictionary, int index, int length);
    private static IEnumerable`1<IndexedColumn<T>> GetIndexedColumns(IEnumerable`1<string> lines);
    private static string ReformatLineUsingTheseColumnLengths(IDictionary`2<int, int> dictionary, string line);
    private static IEnumerable`1<string> GetLines(string message);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.InstanceComparisonExtensionMethods : object {
    [ExtensionAttribute]
public static void CompareToInstance(Table table, T instance);
    [ExtensionAttribute]
public static bool IsEquivalentToInstance(Table table, T instance);
    private static void AssertThatTheInstanceExists(T instance);
    private static void ThrowAnExceptionThatDescribesThoseDifferences(IEnumerable`1<Difference> differences);
    private static string CreateDescriptiveErrorMessage(IEnumerable`1<Difference> differences);
    private static Difference[] FindAnyDifferences(Table table, T instance);
    private static bool HasDifference(Table table, T instance);
    private static bool ThereAreAnyDifferences(IEnumerable`1<Difference> differences);
    internal static bool ThePropertyDoesNotExist(T instance, TableRow row);
    internal static bool ThereIsADifference(T instance, TableRow row);
    private static bool TheValuesDoNotMatch(T instance, TableRow row);
    private static string GetTheExpectedValue(TableRow row);
    private static Difference CreateDifferenceForThisRow(T instance, TableRow row);
    private static IValueComparer FindValueComparerForProperty(T instance, string propertyName);
    private static IValueComparer FindValueComparerForValue(object propertyValue);
}
public class TechTalk.SpecFlow.Assist.InstanceCreationOptions : object {
    [CompilerGeneratedAttribute]
private bool <VerifyAllColumnsBound>k__BackingField;
    public bool VerifyAllColumnsBound { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_VerifyAllColumnsBound();
    [CompilerGeneratedAttribute]
public void set_VerifyAllColumnsBound(bool value);
}
public interface TechTalk.SpecFlow.Assist.ITableDiffExceptionBuilder`1 {
    public abstract virtual string GetTheTableDiffExceptionMessage(TableDifferenceResults`1<T> tableDifferenceResults);
}
public interface TechTalk.SpecFlow.Assist.IValueComparer {
    public abstract virtual bool CanCompare(object actualValue);
    public abstract virtual bool Compare(string expectedValue, object actualValue);
}
public interface TechTalk.SpecFlow.Assist.IValueRetriever {
    public abstract virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public abstract virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
}
internal class TechTalk.SpecFlow.Assist.PivotTable : object {
    private Table table;
    public PivotTable(Table table);
    public Table GetInstanceTable(int index);
    private Table CreateAnInstanceTableForThisItemInTheSet(int index);
    private void AssertThatThisItemExistsInTheSet(int index);
}
public class TechTalk.SpecFlow.Assist.Projection`1 : object {
    private T item;
    private IEnumerable`1<string> properties;
    public Projection`1(T item, IEnumerable`1<string> properties);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool Compare(T t1, T t2, IEnumerable`1<string> properties);
}
public class TechTalk.SpecFlow.Assist.ProjectionEnumerator`1 : object {
    private IEnumerator`1<T> collectionEnumerator;
    private IEnumerable`1<string> properties;
    public Projection`1<T> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ProjectionEnumerator`1(IEnumerable`1<T> collection, IEnumerable`1<string> properties);
    public sealed virtual Projection`1<T> get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.ProjectionExtensionMethods : object {
    [ExtensionAttribute]
public static IEnumerable`1<Projection`1<T>> ToProjection(IEnumerable`1<T> collection, Table table);
    [ExtensionAttribute]
public static IEnumerable`1<Projection`1<T>> ToProjection(Table table);
    [ExtensionAttribute]
public static IEnumerable`1<Projection`1<T>> ToProjectionOfSet(Table table, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static IEnumerable`1<Projection`1<T>> ToProjectionOfInstance(Table table, T instance);
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Assist.PropertyExtensionMethods : object {
    [ExtensionAttribute]
public static object GetPropertyValue(object object, string propertyName);
    [ExtensionAttribute]
public static void SetPropertyValue(object object, string propertyName, object value);
    [ExtensionAttribute]
public static PropertyInfo GetThePropertyOnThisObject(object object, string propertyName);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.RowExtensionMethods : object {
    [ExtensionAttribute]
public static string GetString(TableRow row, string id);
    [ExtensionAttribute]
public static int GetInt32(TableRow row, string id);
    [ExtensionAttribute]
public static long GetInt64(TableRow row, string id);
    [ExtensionAttribute]
public static decimal GetDecimal(TableRow row, string id);
    [ExtensionAttribute]
public static DateTime GetDateTime(TableRow row, string id);
    [ExtensionAttribute]
public static bool GetBoolean(TableRow row, string id);
    [ExtensionAttribute]
public static double GetDouble(TableRow row, string id);
    [ExtensionAttribute]
public static float GetSingle(TableRow row, string id);
    [ExtensionAttribute]
public static char GetChar(TableRow row, string id);
    [ExtensionAttribute]
public static T GetDiscreteEnum(TableRow row, string id);
    [ExtensionAttribute]
public static T GetDiscreteEnum(TableRow row, string id, T defaultValue);
    [ExtensionAttribute]
public static TEnum GetEnumValue(TableRow row, string id);
    [ExtensionAttribute]
public static Enum GetEnum(TableRow row, string id);
    private static Enum GetTheEnumValue(string rowValue, string propertyName);
    private static Type GetTheEnumType(string propertyName, string value);
    private static bool EnumValueIsDefinedCaseInsensitve(Type enum, string value);
    [ExtensionAttribute]
public static Guid GetGuid(TableRow row, string id);
    private static bool TheBooleanValueIsEmpty(TableRow row, string id);
    private static bool TheValueIsNotEmpty(TableRow row, string id);
    private static void AssertThatTheRequestIsValid(TableRow row, string id);
    private static void AssertThatThisIsAnAcceptableBoolValue(TableRow row, string id);
    private static void AssertThatAValueWithThisIdExistsInThisRow(TableRow row, string id);
    private static bool AValueWithThisIdExists(IEnumerable`1<KeyValuePair`2<string, string>> row, string id);
    [ExtensionAttribute]
public static T CreateInstance(TableRow row);
    [ExtensionAttribute]
public static T CreateInstance(TableRow row, Func`1<T> methodToCreateTheInstance);
    [ExtensionAttribute]
private static Table ToTable(TableRow row);
}
internal class TechTalk.SpecFlow.Assist.SafetyTableDiffExceptionBuilder`1 : object {
    private ITableDiffExceptionBuilder`1<T> tableDiffExceptionBuilder;
    public SafetyTableDiffExceptionBuilder`1(ITableDiffExceptionBuilder`1<T> tableDiffExceptionBuilder);
    public sealed virtual string GetTheTableDiffExceptionMessage(TableDifferenceResults`1<T> tableDifferenceResults);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class TechTalk.SpecFlow.Assist.Service : object {
    [CompilerGeneratedAttribute]
private ServiceComponentList`1<IValueComparer> <ValueComparers>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceComponentList`1<IValueRetriever> <ValueRetrievers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Service <Instance>k__BackingField;
    public ServiceComponentList`1<IValueComparer> ValueComparers { get; private set; }
    public ServiceComponentList`1<IValueRetriever> ValueRetrievers { get; private set; }
    public static Service Instance { get; }
    private static Service();
    [CompilerGeneratedAttribute]
public ServiceComponentList`1<IValueComparer> get_ValueComparers();
    [CompilerGeneratedAttribute]
private void set_ValueComparers(ServiceComponentList`1<IValueComparer> value);
    [CompilerGeneratedAttribute]
public ServiceComponentList`1<IValueRetriever> get_ValueRetrievers();
    [CompilerGeneratedAttribute]
private void set_ValueRetrievers(ServiceComponentList`1<IValueRetriever> value);
    [CompilerGeneratedAttribute]
public static Service get_Instance();
    public void RestoreDefaults();
    [ObsoleteAttribute("Use ValueComparers.Register")]
public void RegisterValueComparer(IValueComparer valueComparer);
    [ObsoleteAttribute("Use ValueComparers.Unregister")]
public void UnregisterValueComparer(IValueComparer valueComparer);
    [ObsoleteAttribute("Use ValueRetrievers.Register")]
public void RegisterValueRetriever(IValueRetriever valueRetriever);
    [ObsoleteAttribute("Use ValueRetrievers.Unregister")]
public void UnregisterValueRetriever(IValueRetriever valueRetriever);
    public IValueRetriever GetValueRetrieverFor(TableRow row, Type targetType, Type propertyType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class TechTalk.SpecFlow.Assist.ServiceComponentList`1 : object {
    private List`1<T> components;
    [NullableAttribute("2")]
private T defaultComponent;
    internal ServiceComponentList`1(List`1<T> initialList, bool isLastOneTheDefault);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Register(T component);
    [NullableContextAttribute("0")]
public void Register();
    public void Unregister(T component);
    [NullableContextAttribute("0")]
public void Unregister();
    public void Replace(T oldComponent, T newComponent);
    [NullableContextAttribute("0")]
public void Replace();
    public void SetDefault(T newComponent);
    [NullableContextAttribute("0")]
public void SetDefault();
    public void ClearDefault();
    public void Clear();
}
public class TechTalk.SpecFlow.Assist.SetComparer`1 : object {
    private static int MatchNotFound;
    private Table table;
    private List`1<TableDifferenceItem`1<T>> extraOrNonMatchingActualItems;
    private ITableDiffExceptionBuilder`1<T> tableDiffExceptionBuilder;
    public SetComparer`1(Table table);
    private SafetyTableDiffExceptionBuilder`1<T> BuildTheTableDiffExceptionBuilder();
    private IEnumerable`1<int> GetExpectedItemsNotFoundInTheData(IEnumerable`1<T> set, bool sequentialEquality);
    public void CompareToSet(IEnumerable`1<T> set, bool sequentialEquality);
    private void AssertThatNoExtraRowsExist(IEnumerable`1<T> set, IEnumerable`1<int> listOfMissingItems);
    private bool ThereAreNoResultsAndNoExpectedResults(IEnumerable`1<T> set);
    private void AssertThatTheItemsMatchTheExpectedResults(IEnumerable`1<int> listOfMissingItems);
    private IEnumerable`1<int> GetListOfExpectedItemsThatCouldNotBeFoundOrderInsensitive(IEnumerable`1<T> set);
    private IEnumerable`1<int> GetListOfExpectedItemsThatCouldNotBeFoundOrderSensitive(IEnumerable`1<T> set);
    private void ThrowAnErrorDetailingWhichItemsAreMissing(IEnumerable`1<int> listOfMissingItems);
    private static bool ExpectedItemsCouldNotBeFound(IEnumerable`1<int> listOfMissingItems);
    private static void RemoveFromActualItemsSoItWillNotBeCheckedAgain(List`1<T> actualItems, int matchIndex);
    private static int GetTheIndexOfTheMatchingItem(Table expectedItem, IList`1<T> actualItems);
    private static bool ThisItemIsAMatch(Table expectedItem, T actualItem);
    private static List`1<T> GetTheActualItems(IEnumerable`1<T> set);
    private void AssertThatAllColumnsInTheTableMatchToPropertiesOnTheType();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.SetComparisonExtensionMethods : object {
    [ExtensionAttribute]
public static void CompareToSet(Table table, IEnumerable`1<T> set, bool sequentialEquality);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class TechTalk.SpecFlow.Assist.SpecFlowDefaultValueComparerList : ServiceComponentList`1<IValueComparer> {
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class TechTalk.SpecFlow.Assist.SpecFlowDefaultValueRetrieverList : ServiceComponentList`1<IValueRetriever> {
}
public class TechTalk.SpecFlow.Assist.TableDifferenceItem`1 : object {
    [CompilerGeneratedAttribute]
private TT <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public TT Item { get; private set; }
    public Nullable`1<int> Index { get; private set; }
    public bool IsIndexSpecific { get; }
    public TableDifferenceItem`1(TT item, Nullable`1<int> index);
    [CompilerGeneratedAttribute]
public TT get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(TT value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(Nullable`1<int> value);
    public bool get_IsIndexSpecific();
}
public class TechTalk.SpecFlow.Assist.TableDifferenceResults`1 : object {
    [CompilerGeneratedAttribute]
private Table <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> <IndexesOfTableRowsThatWereNotMatched>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TableDifferenceItem`1<TT>> <ItemsInTheDataThatWereNotFoundInTheTable>k__BackingField;
    public Table Table { get; }
    public IEnumerable`1<int> IndexesOfTableRowsThatWereNotMatched { get; }
    public IEnumerable`1<TableDifferenceItem`1<TT>> ItemsInTheDataThatWereNotFoundInTheTable { get; }
    public TableDifferenceResults`1(Table table, IEnumerable`1<int> indexesOfTableRowsThatWereNotMatched, IEnumerable`1<TableDifferenceItem`1<TT>> itemsInTheDataThatWereNotFoundInTheTable);
    [CompilerGeneratedAttribute]
public Table get_Table();
    [CompilerGeneratedAttribute]
public IEnumerable`1<int> get_IndexesOfTableRowsThatWereNotMatched();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TableDifferenceItem`1<TT>> get_ItemsInTheDataThatWereNotFoundInTheTable();
}
internal class TechTalk.SpecFlow.Assist.TableDiffExceptionBuilder`1 : object {
    public sealed virtual string GetTheTableDiffExceptionMessage(TableDifferenceResults`1<T> tableDifferenceResults);
    private void AppendExtraLineText(TableDifferenceResults`1<T> tableDifferenceResults, TableDifferenceItem`1<T> item, StringBuilder realData);
    private static object GetTheValue(T item, string header);
    private static string ConvertThisEnumerableToACommaDelimitedString(object propertyValue);
    private static bool ThisIsAnEnumerable(object propertyValue);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.TableHelperExtensionMethods : object {
    [ExtensionAttribute]
public static T CreateInstance(Table table);
    [ExtensionAttribute]
public static T CreateInstance(Table table, InstanceCreationOptions creationOptions);
    [ExtensionAttribute]
public static T CreateInstance(Table table, Func`1<T> methodToCreateTheInstance);
    [ExtensionAttribute]
public static T CreateInstance(Table table, Func`1<T> methodToCreateTheInstance, InstanceCreationOptions creationOptions);
    [ExtensionAttribute]
public static void FillInstance(Table table, object instance);
    [ExtensionAttribute]
public static void FillInstance(Table table, object instance, InstanceCreationOptions creationOptions);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table, InstanceCreationOptions creationOptions);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table, Func`1<T> methodToCreateEachInstance);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table, Func`1<T> methodToCreateEachInstance, InstanceCreationOptions creationOptions);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table, Func`2<TableRow, T> methodToCreateEachInstance);
    [ExtensionAttribute]
public static IEnumerable`1<T> CreateSet(Table table, Func`2<TableRow, T> methodToCreateEachInstance, InstanceCreationOptions creationOptions);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Assist.TableHelpers : object {
    [ExtensionAttribute]
public static string Id(TableRow row);
    [ExtensionAttribute]
public static string Value(TableRow row);
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Assist.TEHelpers : object {
    private static Regex invalidPropertyNameRegex;
    private static string InvalidPropertyNamePattern;
    private static TEHelpers();
    internal static T CreateTheInstanceWithTheDefaultConstructor(Table table, InstanceCreationOptions creationOptions);
    internal static T CreateTheInstanceWithTheValuesFromTheTable(Table table, InstanceCreationOptions creationOptions);
    internal static bool ThisTypeHasADefaultConstructor();
    internal static ConstructorInfo GetConstructorMatchingToColumnNames(Table table);
    internal static bool IsMemberMatchingToColumnName(MemberInfo member, string columnName);
    [ExtensionAttribute]
internal static bool MatchesThisColumnName(string propertyName, string columnName);
    internal static string RemoveAllCharactersThatAreNotValidInAPropertyName(string name);
    internal static string NormalizePropertyNameToMatchAgainstAColumnName(string name);
    internal static void LoadInstanceWithKeyValuePairs(Table table, object instance, InstanceCreationOptions creationOptions);
    private static void VerifyAllColumn(Table table, InstanceCreationOptions creationOptions, IEnumerable`1<string> memberNames);
    internal static List`1<MemberHandler> GetMembersThatNeedToBeSet(Table table, Type type);
    private static bool IsMatchingAlias(MemberInfo field, string id);
    private static bool TheseTypesMatch(Type targetType, Type memberType, TableRow row);
    internal static Table GetTheProperInstanceTable(Table table, Type type);
    private static Table FlipThisHorizontalTableToAVerticalTable(Table table);
    private static bool ThisIsAVerticalTable(Table table, Type type);
    private static bool TheHeaderIsTheOldFieldValuePair(Table table);
    private static bool TheFirstRowValueIsTheNameOfAProperty(Table table, Type type);
    public static bool IsValueTupleType(Type type, bool checkBaseTypes);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.BoolValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.DateTimeValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.DecimalValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.DefaultValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.DoubleValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.FloatValueComparer : object {
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueComparers.GuidValueComparer : object {
    private GuidValueRetriever guidValueRetriever;
    public GuidValueComparer(GuidValueRetriever guidValueRetriever);
    public sealed virtual bool CanCompare(object actualValue);
    public sealed virtual bool Compare(string expectedValue, object actualValue);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.ArrayValueRetriever : EnumerableValueRetriever {
    public virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    protected virtual Type GetActualValueType(Type propertyType);
    protected virtual object BuildInstance(int count, IEnumerable values, Type valueType);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.BoolValueRetriever : StructRetriever`1<bool> {
    private static List`1<string> MultiLingualTrueValues;
    private static BoolValueRetriever();
    protected virtual bool GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.ByteValueRetriever : StructRetriever`1<byte> {
    protected virtual byte GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.CharValueRetriever : StructRetriever`1<char> {
    protected virtual char GetNonEmptyValue(string value);
}
public abstract class TechTalk.SpecFlow.Assist.ValueRetrievers.ClassRetriever`1 : object {
    public sealed virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public sealed virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    protected abstract virtual T GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.DateTimeOffsetValueRetriever : StructRetriever`1<DateTimeOffset> {
    [CompilerGeneratedAttribute]
private static DateTimeStyles <DateTimeStyles>k__BackingField;
    public static DateTimeStyles DateTimeStyles { get; public set; }
    [CompilerGeneratedAttribute]
public static DateTimeStyles get_DateTimeStyles();
    [CompilerGeneratedAttribute]
public static void set_DateTimeStyles(DateTimeStyles value);
    protected virtual DateTimeOffset GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.DateTimeValueRetriever : StructRetriever`1<DateTime> {
    [CompilerGeneratedAttribute]
private static DateTimeStyles <DateTimeStyles>k__BackingField;
    public static DateTimeStyles DateTimeStyles { get; public set; }
    [CompilerGeneratedAttribute]
public static DateTimeStyles get_DateTimeStyles();
    [CompilerGeneratedAttribute]
public static void set_DateTimeStyles(DateTimeStyles value);
    protected virtual DateTime GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.DecimalValueRetriever : StructRetriever`1<decimal> {
    protected virtual decimal GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.DoubleValueRetriever : StructRetriever`1<double> {
    protected virtual double GetNonEmptyValue(string value);
}
public abstract class TechTalk.SpecFlow.Assist.ValueRetrievers.EnumerableValueRetriever : object {
    private static Char[] Separators;
    private static EnumerableValueRetriever();
    public abstract virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public sealed virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Assist.ValueRetrievers.EnumerableValueRetriever/<GetItems>d__3")]
private IEnumerable GetItems(String[] strings, KeyValuePair`2<string, string> keyValuePair, Type targetType, Type itemType);
    protected abstract virtual Type GetActualValueType(Type propertyType);
    protected abstract virtual object BuildInstance(int count, IEnumerable values, Type valueType);
    private static IValueRetriever GetValueRetriever(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type valueType);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.EnumValueRetriever : object {
    public sealed virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public sealed virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.FloatValueRetriever : StructRetriever`1<float> {
    protected virtual float GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.GuidValueRetriever : StructRetriever`1<Guid> {
    protected virtual Guid GetNonEmptyValue(string value);
    public Guid GetValue(string value);
    private static bool AttemptToBuildAGuidByAddingTrailingZeroes(string value, Guid& result);
    public bool IsAValidGuid(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.IntValueRetriever : StructRetriever`1<int> {
    protected virtual int GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.ListValueRetriever : EnumerableValueRetriever {
    private MethodInfo toListMethodInfo;
    public virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    protected virtual Type GetActualValueType(Type propertyType);
    protected virtual object BuildInstance(int count, IEnumerable values, Type valueType);
    private MethodInfo GetMethod();
    private static List`1<T> ToList(IEnumerable values);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.LongValueRetriever : StructRetriever`1<long> {
    protected virtual long GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.NullValueRetriever : object {
    private string _nullText;
    public NullValueRetriever(string nullText);
    public sealed virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public sealed virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    private static bool IsNullableType(Type type);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.SByteValueRetriever : StructRetriever`1<sbyte> {
    protected virtual sbyte GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.ShortValueRetriever : StructRetriever`1<short> {
    protected virtual short GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.StringValueRetriever : ClassRetriever`1<string> {
    protected virtual string GetNonEmptyValue(string value);
}
public abstract class TechTalk.SpecFlow.Assist.ValueRetrievers.StructRetriever`1 : object {
    public sealed virtual bool CanRetrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    public sealed virtual object Retrieve(KeyValuePair`2<string, string> keyValuePair, Type targetType, Type propertyType);
    protected abstract virtual T GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.TimeSpanValueRetriever : StructRetriever`1<TimeSpan> {
    protected virtual TimeSpan GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.UIntValueRetriever : StructRetriever`1<UInt32> {
    protected virtual UInt32 GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.ULongValueRetriever : StructRetriever`1<ulong> {
    protected virtual ulong GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.UriValueRetriever : ClassRetriever`1<Uri> {
    protected virtual Uri GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.Assist.ValueRetrievers.UShortValueRetriever : StructRetriever`1<ushort> {
    protected virtual ushort GetNonEmptyValue(string value);
}
public class TechTalk.SpecFlow.BeforeAttribute : BeforeScenarioAttribute {
    public BeforeAttribute(String[] tags);
}
public class TechTalk.SpecFlow.BeforeFeatureAttribute : HookAttribute {
    public BeforeFeatureAttribute(String[] tags);
}
public class TechTalk.SpecFlow.BeforeScenarioAttribute : HookAttribute {
    public BeforeScenarioAttribute(String[] tags);
}
public class TechTalk.SpecFlow.BeforeScenarioBlockAttribute : HookAttribute {
    public BeforeScenarioBlockAttribute(String[] tags);
}
public class TechTalk.SpecFlow.BeforeStepAttribute : HookAttribute {
    public BeforeStepAttribute(String[] tags);
}
public class TechTalk.SpecFlow.BeforeTestRunAttribute : HookAttribute {
}
[AttributeUsageAttribute("4")]
public class TechTalk.SpecFlow.BindingAttribute : Attribute {
}
public class TechTalk.SpecFlow.BindingException : SpecFlowException {
    public BindingException(string message);
    public BindingException(string message, Exception inner);
    protected BindingException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Bindings.AsyncMethodHelper : object {
    private static bool IsTask(Type type);
    private static bool IsTaskOfT(Type type, Type& typeArg);
    private static bool IsValueTask(Type type);
    private static bool IsValueTaskOfT(Type type, Type& typeArg);
    private static bool IsAwaitableOfT(Type type, Type& typeArg);
    public static bool IsAwaitable(Type type);
    public static bool IsAwaitableAsTask(object obj, Task& task);
    [ExtensionAttribute]
public static IBindingType GetAwaitableReturnType(IBindingMethod bindingMethod);
    public static bool IsAsyncVoid(MethodInfo methodInfo);
    public static bool IsAsyncVoid(IBindingMethod bindingMethod);
    public static Task`1<object> ConvertToTaskOfObject(Task task);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.AsyncMethodHelper/<ConvertTaskOfT>d__11")]
private static Task`1<object> ConvertTaskOfT(Task task, bool getValue);
}
public class TechTalk.SpecFlow.Bindings.BindingDelegateInvoker : object {
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.BindingDelegateInvoker/<InvokeDelegateAsync>d__0")]
public virtual Task`1<object> InvokeDelegateAsync(Delegate bindingDelegate, Object[] invokeArgs, ExecutionContextHolder executionContext);
    private Task`1<object> InvokeInExecutionContext(ExecutionContext executionContext, Func`1<Task`1<object>> callback);
    private Task`1<object> CreateDelegateInvocationTask(Delegate bindingDelegate, Object[] invokeArgs);
    protected virtual object InvokeBindingDelegateSync(Delegate bindingDelegate, Object[] invokeArgs);
    private Task`1<object> InvokeBindingDelegateAsync(Delegate bindingDelegate, Object[] invokeArgs);
}
public class TechTalk.SpecFlow.Bindings.BindingError : object {
    [CompilerGeneratedAttribute]
private BindingErrorType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public BindingErrorType Type { get; }
    public string Message { get; }
    public BindingError(BindingErrorType type, string message);
    [CompilerGeneratedAttribute]
public BindingErrorType get_Type();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public enum TechTalk.SpecFlow.Bindings.BindingErrorType : Enum {
    public int value__;
    public static BindingErrorType TypeLoadError;
    public static BindingErrorType BindingError;
    public static BindingErrorType StepDefinitionError;
}
public class TechTalk.SpecFlow.Bindings.BindingFactory : object {
    private IStepDefinitionRegexCalculator stepDefinitionRegexCalculator;
    private ICucumberExpressionStepDefinitionBindingBuilderFactory _cucumberExpressionStepDefinitionBindingBuilderFactory;
    public BindingFactory(IStepDefinitionRegexCalculator stepDefinitionRegexCalculator, ICucumberExpressionStepDefinitionBindingBuilderFactory cucumberExpressionStepDefinitionBindingBuilderFactory);
    public sealed virtual IHookBinding CreateHookBinding(IBindingMethod bindingMethod, HookType hookType, BindingScope bindingScope, int hookOrder);
    public sealed virtual IStepDefinitionBindingBuilder CreateStepDefinitionBindingBuilder(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string expressionString);
    public sealed virtual IStepArgumentTransformationBinding CreateStepArgumentTransformation(string regexString, IBindingMethod bindingMethod, string parameterTypeName);
}
public class TechTalk.SpecFlow.Bindings.BindingInvoker : object {
    protected SpecFlowConfiguration specFlowConfiguration;
    protected IErrorProvider errorProvider;
    protected IBindingDelegateInvoker bindingDelegateInvoker;
    private static Type[] actionTypes;
    private static Type[] funcTypes;
    public BindingInvoker(SpecFlowConfiguration specFlowConfiguration, IErrorProvider errorProvider, IBindingDelegateInvoker bindingDelegateInvoker);
    private static BindingInvoker();
    [ObsoleteAttribute("Use async version of the method instead")]
public virtual object InvokeBinding(IBinding binding, IContextManager contextManager, Object[] arguments, ITestTracer testTracer, TimeSpan& duration);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.BindingInvoker/<InvokeBindingAsync>d__5")]
public virtual Task`1<object> InvokeBindingAsync(IBinding binding, IContextManager contextManager, Object[] arguments, ITestTracer testTracer, DurationHolder durationHolder);
    private ExecutionContextHolder GetExecutionContextHolder(IContextManager contextManager);
    protected virtual CultureInfoScope CreateCultureInfoScope(IContextManager contextManager);
    protected void EnsureReflectionInfo(IBinding binding, MethodInfo& methodInfo, Delegate& bindingAction);
    protected virtual Delegate CreateMethodDelegate(MethodInfo method);
    protected virtual Expression GetBindingMethodCallExpression(Expression instance, MethodInfo method, Expression[] argumentsExpressions);
    protected Type GetActionType(Type[] typeArgs);
    protected Type GetFuncType(Type[] typeArgs, Type resultType);
    protected Type GetDelegateType(Type[] typeArgs, Type resultType);
}
public class TechTalk.SpecFlow.Bindings.BindingMatch : object {
    public static BindingMatch NonMatching;
    [CompilerGeneratedAttribute]
private IStepDefinitionBinding <StepBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingObsoletion <BindingObsoletion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScopeMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private StepContext <StepContext>k__BackingField;
    public IStepDefinitionBinding StepBinding { get; private set; }
    public bool Success { get; }
    public BindingObsoletion BindingObsoletion { get; private set; }
    public bool IsObsolete { get; }
    public int ScopeMatches { get; private set; }
    public bool IsScoped { get; }
    public Object[] Arguments { get; private set; }
    public StepContext StepContext { get; private set; }
    public BindingMatch(IStepDefinitionBinding stepBinding, int scopeMatches, Object[] arguments, StepContext stepContext);
    private static BindingMatch();
    [CompilerGeneratedAttribute]
public IStepDefinitionBinding get_StepBinding();
    [CompilerGeneratedAttribute]
private void set_StepBinding(IStepDefinitionBinding value);
    public bool get_Success();
    [CompilerGeneratedAttribute]
public BindingObsoletion get_BindingObsoletion();
    [CompilerGeneratedAttribute]
private void set_BindingObsoletion(BindingObsoletion value);
    public bool get_IsObsolete();
    [CompilerGeneratedAttribute]
public int get_ScopeMatches();
    [CompilerGeneratedAttribute]
private void set_ScopeMatches(int value);
    public bool get_IsScoped();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(Object[] value);
    [CompilerGeneratedAttribute]
public StepContext get_StepContext();
    [CompilerGeneratedAttribute]
private void set_StepContext(StepContext value);
}
public class TechTalk.SpecFlow.Bindings.BindingObsoletion : object {
    private static string defaultObsoletionMessage;
    private string message;
    private string methodName;
    [CompilerGeneratedAttribute]
private bool <IsObsolete>k__BackingField;
    public bool IsObsolete { get; private set; }
    public string Message { get; }
    public BindingObsoletion(IStepDefinitionBinding stepBinding);
    [CompilerGeneratedAttribute]
public bool get_IsObsolete();
    [CompilerGeneratedAttribute]
private void set_IsObsolete(bool value);
    public string get_Message();
}
public class TechTalk.SpecFlow.Bindings.BindingRegistry : object {
    private List`1<IStepDefinitionBinding> _stepDefinitions;
    private List`1<IStepArgumentTransformationBinding> _stepArgumentTransformations;
    private Dictionary`2<HookType, List`1<IHookBinding>> _hooks;
    private List`1<BindingError> _genericBindingErrors;
    [CompilerGeneratedAttribute]
private bool <Ready>k__BackingField;
    public bool Ready { get; public set; }
    public bool IsValid { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Ready();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Ready(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual IEnumerable`1<IStepDefinitionBinding> GetStepDefinitions();
    public sealed virtual IEnumerable`1<IStepDefinitionBinding> GetConsideredStepDefinitions(StepDefinitionType stepDefinitionType, string stepText);
    public virtual IEnumerable`1<IHookBinding> GetHooks();
    public virtual IEnumerable`1<IHookBinding> GetHooks(HookType bindingEvent);
    private IEnumerable`1<IHookBinding> GetHookList(HookType bindingEvent);
    public virtual IEnumerable`1<IStepArgumentTransformationBinding> GetStepTransformations();
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.BindingRegistry/<GetErrorMessages>d__16")]
public sealed virtual IEnumerable`1<BindingError> GetErrorMessages();
    public virtual void RegisterStepDefinitionBinding(IStepDefinitionBinding stepDefinitionBinding);
    private List`1<IHookBinding> GetHookListForRegister(HookType bindingEvent);
    public virtual void RegisterHookBinding(IHookBinding hookBinding);
    public virtual void RegisterStepArgumentTransformationBinding(IStepArgumentTransformationBinding stepArgumentTransformationBinding);
    public sealed virtual void RegisterGenericBindingError(BindingError error);
}
public class TechTalk.SpecFlow.Bindings.BindingScope : object {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScenarioTitle>k__BackingField;
    public string Tag { get; private set; }
    public string FeatureTitle { get; private set; }
    public string ScenarioTitle { get; private set; }
    public BindingScope(string tag, string featureTitle, string scenarioTitle);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
private void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_FeatureTitle();
    [CompilerGeneratedAttribute]
private void set_FeatureTitle(string value);
    [CompilerGeneratedAttribute]
public string get_ScenarioTitle();
    [CompilerGeneratedAttribute]
private void set_ScenarioTitle(string value);
    private string RemoveLeadingAt(string tag);
    public bool Match(StepContext stepContext, Int32& scopeMatches);
    protected bool Equals(BindingScope other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Bindings.BindingTypeHelper : object {
    [ExtensionAttribute]
public static StepDefinitionType ToBindingType(ScenarioBlock block);
    [ExtensionAttribute]
public static ScenarioBlock ToScenarioBlock(StepDefinitionType stepDefinitionType);
    [ExtensionAttribute]
public static StepDefinitionKeyword ToStepDefinitionKeyword(StepDefinitionType stepDefinitionType);
    [ExtensionAttribute]
public static bool Equals(ScenarioBlock block, StepDefinitionType stepDefinitionType);
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.BuiltInCucumberExpressionParameterTypeTransformation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindingType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseForSnippets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    public string Name { get; }
    public string Regex { get; }
    public IBindingType TargetType { get; }
    public bool UseForSnippets { get; }
    public int Weight { get; }
    public BuiltInCucumberExpressionParameterTypeTransformation(string regex, IBindingType targetType, string name, bool useForSnippets, int weight);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Regex();
    [CompilerGeneratedAttribute]
public sealed virtual IBindingType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseForSnippets();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Weight();
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionParameterType : object {
    internal static string MatchAllRegex;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindingType <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICucumberExpressionParameterTypeTransformation[] <Transformations>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RegexStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseForSnippets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    public string Name { get; }
    public IBindingType TargetType { get; }
    public ICucumberExpressionParameterTypeTransformation[] Transformations { get; }
    public String[] RegexStrings { get; }
    public bool UseForSnippets { get; }
    public int Weight { get; }
    public Type ParameterType { get; }
    public CucumberExpressionParameterType(string name, IBindingType targetType, IEnumerable`1<ICucumberExpressionParameterTypeTransformation> transformations);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IBindingType get_TargetType();
    [CompilerGeneratedAttribute]
public sealed virtual ICucumberExpressionParameterTypeTransformation[] get_Transformations();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_RegexStrings();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseForSnippets();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Weight();
    public sealed virtual Type get_ParameterType();
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionParameterTypeRegistry : object {
    private IBindingRegistry _bindingRegistry;
    private Lazy`1<Dictionary`2<string, ISpecFlowCucumberExpressionParameterType>> _parameterTypesByName;
    private HashSet`1<IBindingType> _consideredParameterTypes;
    public CucumberExpressionParameterTypeRegistry(IBindingRegistry bindingRegistry);
    public static string ConvertQuotedString(string message);
    private Dictionary`2<string, ISpecFlowCucumberExpressionParameterType> InitializeRegistry();
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionParameterTypeRegistry/<GetUserTransformations>d__6")]
private IEnumerable`1<UserDefinedCucumberExpressionParameterTypeTransformation> GetUserTransformations(IStepArgumentTransformationBinding t, Dictionary`2<IBindingType, string> aliases);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionParameterTypeRegistry/<GetEnumTypesUsedInParameters>d__7")]
private IEnumerable`1<ICucumberExpressionParameterTypeTransformation> GetEnumTypesUsedInParameters();
    public sealed virtual IParameterType LookupByTypeName(string name);
    public sealed virtual IEnumerable`1<IParameterType> GetParameterTypes();
    public void OnBindingMethodProcessed(IBindingMethod bindingMethod);
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionStepDefinitionBindingBuilder : StepDefinitionBindingBuilderBase {
    private static Regex ParameterPlaceholder;
    private static Regex CommonRegexStepDefPatterns;
    private static Regex ExtendedRegexStepDefPatterns;
    private CucumberExpressionParameterTypeRegistry _cucumberExpressionParameterTypeRegistry;
    public CucumberExpressionStepDefinitionBindingBuilder(CucumberExpressionParameterTypeRegistry cucumberExpressionParameterTypeRegistry, StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression);
    private static CucumberExpressionStepDefinitionBindingBuilder();
    public static bool IsCucumberExpression(string cucumberExpressionCandidate);
    protected virtual IExpression CreateExpression(String& expressionType);
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.CucumberExpressionStepDefinitionBindingBuilderFactory : object {
    private CucumberExpressionParameterTypeRegistry _cucumberExpressionParameterTypeRegistry;
    public CucumberExpressionStepDefinitionBindingBuilderFactory(CucumberExpressionParameterTypeRegistry cucumberExpressionParameterTypeRegistry);
    public sealed virtual CucumberExpressionStepDefinitionBindingBuilder Create(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression);
}
public interface TechTalk.SpecFlow.Bindings.CucumberExpressions.ICucumberExpressionParameterTypeTransformation {
    public string Name { get; }
    public string Regex { get; }
    public IBindingType TargetType { get; }
    public bool UseForSnippets { get; }
    public int Weight { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Regex();
    public abstract virtual IBindingType get_TargetType();
    public abstract virtual bool get_UseForSnippets();
    public abstract virtual int get_Weight();
}
public interface TechTalk.SpecFlow.Bindings.CucumberExpressions.ICucumberExpressionStepDefinitionBindingBuilderFactory {
    public abstract virtual CucumberExpressionStepDefinitionBindingBuilder Create(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression);
}
public interface TechTalk.SpecFlow.Bindings.CucumberExpressions.ISpecFlowCucumberExpressionParameterType {
    public IBindingType TargetType { get; }
    public ICucumberExpressionParameterTypeTransformation[] Transformations { get; }
    public abstract virtual IBindingType get_TargetType();
    public abstract virtual ICucumberExpressionParameterTypeTransformation[] get_Transformations();
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.SpecFlowCucumberExpression : CucumberExpression {
    public SpecFlowCucumberExpression(string expression, IParameterTypeRegistry parameterTypeRegistry);
    protected virtual bool HandleStringType(string name, IParameterType parameterType, String[]& regexps, Boolean& shouldWrapWithCaptureGroup);
}
public class TechTalk.SpecFlow.Bindings.CucumberExpressions.UserDefinedCucumberExpressionParameterTypeTransformation : object {
    private IStepArgumentTransformationBinding _stepArgumentTransformationBinding;
    private string _customName;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    public string Name { get; }
    public string Regex { get; }
    public IBindingType TargetType { get; }
    public bool UseForSnippets { get; }
    public int Weight { get; }
    public UserDefinedCucumberExpressionParameterTypeTransformation(IStepArgumentTransformationBinding stepArgumentTransformationBinding, string customName);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Regex();
    public sealed virtual IBindingType get_TargetType();
    public sealed virtual bool get_UseForSnippets();
    public sealed virtual int get_Weight();
    private string GetCucumberExpressionRegex(IStepArgumentTransformationBinding stepArgumentTransformationBinding);
    private bool IsValidRegex(string regexString);
}
public class TechTalk.SpecFlow.Bindings.Discovery.BindingSourceAttribute : object {
    [CompilerGeneratedAttribute]
private IBindingType <AttributeType>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindingSourceAttributeValueProvider[] <AttributeValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IBindingSourceAttributeValueProvider> <NamedAttributeValues>k__BackingField;
    public IBindingType AttributeType { get; public set; }
    public IBindingSourceAttributeValueProvider[] AttributeValues { get; public set; }
    public IDictionary`2<string, IBindingSourceAttributeValueProvider> NamedAttributeValues { get; public set; }
    [CompilerGeneratedAttribute]
public IBindingType get_AttributeType();
    [CompilerGeneratedAttribute]
public void set_AttributeType(IBindingType value);
    [CompilerGeneratedAttribute]
public IBindingSourceAttributeValueProvider[] get_AttributeValues();
    [CompilerGeneratedAttribute]
public void set_AttributeValues(IBindingSourceAttributeValueProvider[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IBindingSourceAttributeValueProvider> get_NamedAttributeValues();
    [CompilerGeneratedAttribute]
public void set_NamedAttributeValues(IDictionary`2<string, IBindingSourceAttributeValueProvider> value);
    public TValue TryGetAttributeValue(int index, TValue defaultValue);
    public TValue[] TryGetParamsAttributeValue(int index, TValue[] defaultValue);
    public TValue TryGetAttributeValue(string name, TValue defaultValue);
}
public class TechTalk.SpecFlow.Bindings.Discovery.BindingSourceAttributeValueProvider : object {
    private object value;
    public BindingSourceAttributeValueProvider(object value);
    public sealed virtual TValue GetValue();
}
public class TechTalk.SpecFlow.Bindings.Discovery.BindingSourceMethod : object {
    [CompilerGeneratedAttribute]
private IBindingMethod <BindingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingSourceAttribute[] <Attributes>k__BackingField;
    public IBindingMethod BindingMethod { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public BindingSourceAttribute[] Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public IBindingMethod get_BindingMethod();
    [CompilerGeneratedAttribute]
public void set_BindingMethod(IBindingMethod value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public BindingSourceAttribute[] get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(BindingSourceAttribute[] value);
    public virtual string ToString();
}
public abstract class TechTalk.SpecFlow.Bindings.Discovery.BindingSourceProcessor : object {
    public static string BindingAttributeFullName;
    private IBindingFactory _bindingFactory;
    private BindingSourceType _currentBindingSourceType;
    private BindingScope[] _typeScopes;
    private List`1<IStepDefinitionBindingBuilder> _stepDefinitionBindingBuilders;
    private static String[] hookNames;
    protected BindingSourceProcessor(IBindingFactory bindingFactory);
    private static BindingSourceProcessor();
    public sealed virtual bool CanProcessTypeAttribute(string attributeTypeName);
    public sealed virtual bool CanProcessMethodAttribute(string attributeTypeName);
    private static bool IsPotentialBindingClass(IEnumerable`1<string> attributeTypeNames);
    public sealed virtual bool PreFilterType(IEnumerable`1<string> attributeTypeNames);
    public sealed virtual bool ProcessType(BindingSourceType bindingSourceType);
    public sealed virtual void ProcessTypeDone();
    public virtual void BuildingCompleted();
    private IEnumerable`1<BindingScope> GetScopes(IEnumerable`1<BindingSourceAttribute> attributes);
    private bool IsBindingType(BindingSourceType bindingSourceType);
    private bool IsStepDefinitionAttribute(BindingSourceAttribute attribute);
    private bool IsHookAttribute(BindingSourceAttribute attribute);
    private bool IsStepArgumentTransformationAttribute(BindingSourceAttribute attribute);
    public sealed virtual void ProcessMethod(BindingSourceMethod bindingSourceMethod);
    protected virtual void ProcessStepDefinitions(BindingSourceMethod bindingSourceMethod, BindingScope[] methodScopes);
    protected virtual void ProcessHooks(BindingSourceMethod bindingSourceMethod, BindingScope[] methodScopes);
    protected virtual void ProcessStepArgumentTransformations(BindingSourceMethod bindingSourceMethod, BindingScope[] methodScopes);
    private void ProcessStepDefinitionAttribute(BindingSourceMethod bindingSourceMethod, BindingScope[] methodScopes, BindingSourceAttribute stepDefinitionAttribute);
    private void ProcessHookAttribute(BindingSourceMethod bindingSourceMethod, BindingScope[] methodScopes, BindingSourceAttribute hookAttribute);
    private static String[] GetTagsDefinedOnBindingAttribute(BindingSourceAttribute hookAttribute);
    private static String[] TagsFromConstructor(BindingSourceAttribute hookAttribute);
    private void ProcessHookAttribute(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute hookAttribute, BindingScope scope);
    private int GetHookOrder(BindingSourceAttribute hookAttribute);
    private void ProcessStepArgumentTransformationAttribute(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute stepArgumentTransformationAttribute);
    private HookType GetHookType(BindingSourceAttribute hookAttribute);
    private Nullable`1<HookType> TryGetHookType(BindingSourceAttribute hookAttribute);
    private void ProcessStepDefinitionAttribute(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute stepDefinitionAttribute, BindingScope scope);
    protected virtual void OnValidationError(BindingValidationResult validationResult, bool genericBindingError);
    protected virtual BindingValidationResult ValidateType(BindingSourceType bindingSourceType);
    protected virtual BindingValidationResult ValidateMethod(BindingSourceMethod bindingSourceMethod);
    protected virtual BindingValidationResult ValidateStepDefinition(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute stepDefinitionAttribute);
    protected virtual BindingValidationResult ValidateHook(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute hookAttribute, HookType hookType);
    protected bool IsScenarioSpecificHook(HookType hookType);
    protected virtual BindingValidationResult ValidateStepArgumentTransformation(BindingSourceMethod bindingSourceMethod, BindingSourceAttribute stepArgumentTransformationAttribute);
    protected abstract virtual void ProcessStepDefinitionBinding(IStepDefinitionBinding stepDefinitionBinding);
    protected abstract virtual void ProcessHookBinding(IHookBinding hookBinding);
    protected abstract virtual void ProcessStepArgumentTransformationBinding(IStepArgumentTransformationBinding stepArgumentTransformationBinding);
    private IEnumerable`1<StepDefinitionType> GetStepDefinitionTypes(BindingSourceAttribute stepDefinitionAttribute);
    private void ApplyForScope(BindingScope[] scopes, Action`1<BindingScope> action);
}
public class TechTalk.SpecFlow.Bindings.Discovery.BindingSourceType : object {
    [CompilerGeneratedAttribute]
private IBindingType <BindingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbstract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenericTypeDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingSourceAttribute[] <Attributes>k__BackingField;
    public IBindingType BindingType { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsGenericTypeDefinition { get; public set; }
    public bool IsNested { get; public set; }
    public BindingSourceAttribute[] Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public IBindingType get_BindingType();
    [CompilerGeneratedAttribute]
public void set_BindingType(IBindingType value);
    [CompilerGeneratedAttribute]
public bool get_IsClass();
    [CompilerGeneratedAttribute]
public void set_IsClass(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAbstract();
    [CompilerGeneratedAttribute]
public void set_IsAbstract(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGenericTypeDefinition();
    [CompilerGeneratedAttribute]
public void set_IsGenericTypeDefinition(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNested();
    [CompilerGeneratedAttribute]
public void set_IsNested(bool value);
    [CompilerGeneratedAttribute]
public BindingSourceAttribute[] get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(BindingSourceAttribute[] value);
    public virtual string ToString();
}
public interface TechTalk.SpecFlow.Bindings.Discovery.IBindingSourceAttributeValueProvider {
    public abstract virtual TValue GetValue();
}
public interface TechTalk.SpecFlow.Bindings.Discovery.IBindingSourceProcessor {
    public abstract virtual bool CanProcessTypeAttribute(string attributeTypeName);
    public abstract virtual bool CanProcessMethodAttribute(string attributeTypeName);
    public abstract virtual bool PreFilterType(IEnumerable`1<string> attributeTypeNames);
    public abstract virtual bool ProcessType(BindingSourceType bindingSourceType);
    public abstract virtual void ProcessMethod(BindingSourceMethod bindingSourceMethod);
    public abstract virtual void ProcessTypeDone();
    public abstract virtual void BuildingCompleted();
}
public interface TechTalk.SpecFlow.Bindings.Discovery.IRuntimeBindingRegistryBuilder {
    public abstract virtual void BuildBindingsFromAssembly(Assembly assembly);
    public abstract virtual void BuildingCompleted();
}
public interface TechTalk.SpecFlow.Bindings.Discovery.IRuntimeBindingSourceProcessor {
    public abstract virtual void RegisterTypeLoadError(string errorMessage);
}
public interface TechTalk.SpecFlow.Bindings.Discovery.ISpecFlowAttributesFilter {
    public abstract virtual IEnumerable`1<Attribute> FilterForSpecFlowAttributes(IEnumerable`1<Attribute> customAttributes);
}
public class TechTalk.SpecFlow.Bindings.Discovery.RuntimeBindingRegistryBuilder : object {
    private IRuntimeBindingSourceProcessor _bindingSourceProcessor;
    private ISpecFlowAttributesFilter _specFlowAttributesFilter;
    public RuntimeBindingRegistryBuilder(IRuntimeBindingSourceProcessor bindingSourceProcessor, ISpecFlowAttributesFilter specFlowAttributesFilter);
    public sealed virtual void BuildBindingsFromAssembly(Assembly assembly);
    protected virtual Type[] GetAssemblyTypes(Assembly assembly, String[]& typeLoadErrors);
    public sealed virtual void BuildingCompleted();
    internal bool BuildBindingsFromType(Type type);
    private BindingSourceMethod CreateBindingSourceMethod(MethodInfo methodDefinition);
    private IBindingType CreateBindingType(Type type);
    private BindingSourceType CreateBindingSourceType(Type type, IEnumerable`1<Attribute> filteredAttributes);
    private BindingSourceAttribute CreateAttribute(Attribute attribute);
    private IBindingSourceAttributeValueProvider FindAttributeConstructorArg(ParameterInfo parameterInfo, Dictionary`2<string, IBindingSourceAttributeValueProvider> namedAttributeValues);
    private BindingSourceAttribute[] GetAttributes(IEnumerable`1<Attribute> customAttributes);
    [CompilerGeneratedAttribute]
private bool <BuildBindingsFromType>b__6_0(Attribute attr);
    [CompilerGeneratedAttribute]
private bool <CreateBindingSourceMethod>b__7_0(Attribute attr);
}
public class TechTalk.SpecFlow.Bindings.Discovery.RuntimeBindingSourceProcessor : BindingSourceProcessor {
    private IBindingRegistry _bindingRegistry;
    private ITestTracer _testTracer;
    public RuntimeBindingSourceProcessor(IBindingFactory bindingFactory, IBindingRegistry bindingRegistry, ITestTracer testTracer);
    protected virtual void ProcessStepDefinitionBinding(IStepDefinitionBinding stepDefinitionBinding);
    protected virtual void ProcessHookBinding(IHookBinding hookBinding);
    protected virtual void ProcessStepArgumentTransformationBinding(IStepArgumentTransformationBinding stepArgumentTransformationBinding);
    protected virtual void OnValidationError(BindingValidationResult validationResult, bool genericBindingError);
    public virtual void BuildingCompleted();
    public sealed virtual void RegisterTypeLoadError(string errorMessage);
}
public class TechTalk.SpecFlow.Bindings.Discovery.SpecFlowAttributesFilter : object {
    private IReadOnlyCollection`1<Type> _validAttributeTypes;
    public sealed virtual IEnumerable`1<Attribute> FilterForSpecFlowAttributes(IEnumerable`1<Attribute> customAttributes);
    [CompilerGeneratedAttribute]
private bool <FilterForSpecFlowAttributes>b__1_0(Attribute a);
}
public class TechTalk.SpecFlow.Bindings.DurationHolder : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public TimeSpan Duration { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
}
public class TechTalk.SpecFlow.Bindings.ExecutionContextHolder : StrongBox`1<ExecutionContext> {
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Bindings.ExpressionMemberAccessor : object {
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TResult>> expression);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, TResult>> expression);
    [ExtensionAttribute]
public static MemberInfo GetMemberInfo(Expression expression);
}
public class TechTalk.SpecFlow.Bindings.HookBinding : MethodBinding {
    [CompilerGeneratedAttribute]
private HookType <HookType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HookOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingScope <BindingScope>k__BackingField;
    public HookType HookType { get; public set; }
    public int HookOrder { get; private set; }
    public BindingScope BindingScope { get; private set; }
    public bool IsScoped { get; }
    public HookBinding(IBindingMethod bindingMethod, HookType hookType, BindingScope bindingScope, int hookOrder);
    [CompilerGeneratedAttribute]
public sealed virtual HookType get_HookType();
    [CompilerGeneratedAttribute]
public void set_HookType(HookType value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_HookOrder();
    [CompilerGeneratedAttribute]
private void set_HookOrder(int value);
    [CompilerGeneratedAttribute]
public sealed virtual BindingScope get_BindingScope();
    [CompilerGeneratedAttribute]
private void set_BindingScope(BindingScope value);
    public sealed virtual bool get_IsScoped();
    protected bool Equals(HookBinding other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum TechTalk.SpecFlow.Bindings.HookType : Enum {
    public int value__;
    public static HookType BeforeTestRun;
    public static HookType AfterTestRun;
    public static HookType BeforeFeature;
    public static HookType AfterFeature;
    public static HookType BeforeScenario;
    public static HookType AfterScenario;
    public static HookType BeforeScenarioBlock;
    public static HookType AfterScenarioBlock;
    public static HookType BeforeStep;
    public static HookType AfterStep;
}
public interface TechTalk.SpecFlow.Bindings.IAsyncBindingInvoker {
    public abstract virtual Task`1<object> InvokeBindingAsync(IBinding binding, IContextManager contextManager, Object[] arguments, ITestTracer testTracer, DurationHolder durationHolder);
}
public interface TechTalk.SpecFlow.Bindings.IBinding {
    public IBindingMethod Method { get; }
    public abstract virtual IBindingMethod get_Method();
}
public interface TechTalk.SpecFlow.Bindings.IBindingDelegateInvoker {
    public abstract virtual Task`1<object> InvokeDelegateAsync(Delegate bindingDelegate, Object[] invokeArgs, ExecutionContextHolder executionContext);
}
public interface TechTalk.SpecFlow.Bindings.IBindingFactory {
    public abstract virtual IHookBinding CreateHookBinding(IBindingMethod bindingMethod, HookType hookType, BindingScope bindingScope, int hookOrder);
    public abstract virtual IStepDefinitionBindingBuilder CreateStepDefinitionBindingBuilder(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string expressionString);
    public abstract virtual IStepArgumentTransformationBinding CreateStepArgumentTransformation(string regexString, IBindingMethod bindingMethod, string parameterTypeName);
}
[ObsoleteAttribute("Use async version of the interface (IAsyncBindingInvoker) whenever you can")]
public interface TechTalk.SpecFlow.Bindings.IBindingInvoker {
    [ObsoleteAttribute("Use async version of the method of IAsyncBindingInvoker instead")]
public abstract virtual object InvokeBinding(IBinding binding, IContextManager contextManager, Object[] arguments, ITestTracer testTracer, TimeSpan& duration);
}
public interface TechTalk.SpecFlow.Bindings.IBindingRegistry {
    public bool Ready { get; public set; }
    public bool IsValid { get; }
    public abstract virtual bool get_Ready();
    public abstract virtual void set_Ready(bool value);
    public abstract virtual bool get_IsValid();
    public abstract virtual IEnumerable`1<IStepDefinitionBinding> GetStepDefinitions();
    public abstract virtual IEnumerable`1<IHookBinding> GetHooks();
    public abstract virtual IEnumerable`1<IStepDefinitionBinding> GetConsideredStepDefinitions(StepDefinitionType stepDefinitionType, string stepText);
    public abstract virtual IEnumerable`1<IHookBinding> GetHooks(HookType bindingEvent);
    public abstract virtual IEnumerable`1<IStepArgumentTransformationBinding> GetStepTransformations();
    public abstract virtual IEnumerable`1<BindingError> GetErrorMessages();
    public abstract virtual void RegisterStepDefinitionBinding(IStepDefinitionBinding stepDefinitionBinding);
    public abstract virtual void RegisterHookBinding(IHookBinding hookBinding);
    public abstract virtual void RegisterStepArgumentTransformationBinding(IStepArgumentTransformationBinding stepArgumentTransformationBinding);
    public abstract virtual void RegisterGenericBindingError(BindingError error);
}
public interface TechTalk.SpecFlow.Bindings.IHookBinding {
    public HookType HookType { get; }
    public int HookOrder { get; }
    public abstract virtual HookType get_HookType();
    public abstract virtual int get_HookOrder();
}
public class TechTalk.SpecFlow.Bindings.InvalidStepDefinitionBindingBuilder : object {
    private StepDefinitionType _stepDefinitionType;
    private IBindingMethod _bindingMethod;
    private BindingScope _bindingScope;
    private string _sourceExpression;
    private string _errorMessage;
    public InvalidStepDefinitionBindingBuilder(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression, string errorMessage);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.InvalidStepDefinitionBindingBuilder/<Build>d__6")]
public sealed virtual IEnumerable`1<IStepDefinitionBinding> Build();
}
public interface TechTalk.SpecFlow.Bindings.IScopedBinding {
    public bool IsScoped { get; }
    public BindingScope BindingScope { get; }
    public abstract virtual bool get_IsScoped();
    public abstract virtual BindingScope get_BindingScope();
}
public interface TechTalk.SpecFlow.Bindings.IStepArgumentTransformationBinding {
    public string Name { get; }
    public Regex Regex { get; }
    public abstract virtual string get_Name();
    public abstract virtual Regex get_Regex();
}
public interface TechTalk.SpecFlow.Bindings.IStepArgumentTypeConverter {
    public abstract virtual Task`1<object> ConvertAsync(object value, IBindingType typeToConvertTo, CultureInfo cultureInfo);
    public abstract virtual bool CanConvert(object value, IBindingType typeToConvertTo, CultureInfo cultureInfo);
}
public interface TechTalk.SpecFlow.Bindings.IStepDefinitionBinding {
    public StepDefinitionType StepDefinitionType { get; }
    public string SourceExpression { get; }
    public string ExpressionType { get; }
    public bool IsValid { get; }
    public string ErrorMessage { get; }
    public Regex Regex { get; }
    public IExpression Expression { get; }
    public abstract virtual StepDefinitionType get_StepDefinitionType();
    public abstract virtual string get_SourceExpression();
    public abstract virtual string get_ExpressionType();
    public abstract virtual bool get_IsValid();
    public abstract virtual string get_ErrorMessage();
    public abstract virtual Regex get_Regex();
    public abstract virtual IExpression get_Expression();
}
public interface TechTalk.SpecFlow.Bindings.IStepDefinitionBindingBuilder {
    public abstract virtual IEnumerable`1<IStepDefinitionBinding> Build();
}
public interface TechTalk.SpecFlow.Bindings.IStepDefinitionRegexCalculator {
    public abstract virtual string CalculateRegexFromMethod(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod);
}
public abstract class TechTalk.SpecFlow.Bindings.MethodBinding : object {
    [CompilerGeneratedAttribute]
private IBindingMethod <Method>k__BackingField;
    internal Delegate cachedBindingDelegate;
    public IBindingMethod Method { get; private set; }
    protected MethodBinding(IBindingMethod bindingMethod);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingMethod get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(IBindingMethod value);
    protected bool Equals(MethodBinding other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class TechTalk.SpecFlow.Bindings.MethodNameStepDefinitionBindingBuilder : RegexStepDefinitionBindingBuilder {
    private IStepDefinitionRegexCalculator _stepDefinitionRegexCalculator;
    public MethodNameStepDefinitionBindingBuilder(IStepDefinitionRegexCalculator stepDefinitionRegexCalculator, StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope);
    protected virtual string GetRegexSource(String& expressionType);
}
public class TechTalk.SpecFlow.Bindings.Reflection.BindingMethod : object {
    [CompilerGeneratedAttribute]
private IBindingType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IBindingParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindingType <ReturnType>k__BackingField;
    public IBindingType Type { get; private set; }
    public string Name { get; private set; }
    public IEnumerable`1<IBindingParameter> Parameters { get; private set; }
    public IBindingType ReturnType { get; private set; }
    public BindingMethod(IBindingType type, string name, IEnumerable`1<IBindingParameter> parameters, IBindingType returnType);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IBindingType value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IBindingParameter> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(IEnumerable`1<IBindingParameter> value);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingType get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(IBindingType value);
    public virtual string ToString();
    protected bool Equals(BindingMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class TechTalk.SpecFlow.Bindings.Reflection.BindingMethodComparer : object {
    public static BindingMethodComparer Instance;
    private static BindingMethodComparer();
    public sealed virtual bool Equals(IBindingMethod x, IBindingMethod y);
    public sealed virtual int GetHashCode(IBindingMethod obj);
}
public class TechTalk.SpecFlow.Bindings.Reflection.BindingParameter : object {
    [CompilerGeneratedAttribute]
private IBindingType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public IBindingType Type { get; private set; }
    public string ParameterName { get; private set; }
    public BindingParameter(IBindingType type, string parameterName);
    [CompilerGeneratedAttribute]
public sealed virtual IBindingType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(IBindingType value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
    public virtual string ToString();
    protected bool Equals(BindingParameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Bindings.Reflection.BindingReflectionExtensions : object {
    [ExtensionAttribute]
public static string GetShortDisplayText(IBindingMethod bindingMethod);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type type, IBindingType baseType);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type baseType, IBindingType type);
    [ExtensionAttribute]
public static bool MethodEquals(IBindingMethod method1, IBindingMethod method2);
    [ExtensionAttribute]
public static bool TypeEquals(IBindingType type1, Type type2);
    [ExtensionAttribute]
public static bool TypeEquals(IBindingType type1, IBindingType type2);
    [ExtensionAttribute]
public static bool ParamEquals(IBindingParameter param1, IBindingParameter param2);
    [ExtensionAttribute]
private static bool ParamsEquals(IEnumerable`1<IBindingParameter> params1, IEnumerable`1<IBindingParameter> params2);
    [ExtensionAttribute]
internal static MethodInfo AssertMethodInfo(IBindingMethod bindingMethod);
}
public class TechTalk.SpecFlow.Bindings.Reflection.BindingType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyName { get; }
    public BindingType(string name, string fullName, string assemblyName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyName();
    public virtual string ToString();
    protected bool Equals(BindingType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface TechTalk.SpecFlow.Bindings.Reflection.IBindingMethod {
    public IBindingType Type { get; }
    public string Name { get; }
    public IEnumerable`1<IBindingParameter> Parameters { get; }
    public IBindingType ReturnType { get; }
    public abstract virtual IBindingType get_Type();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<IBindingParameter> get_Parameters();
    public abstract virtual IBindingType get_ReturnType();
}
public interface TechTalk.SpecFlow.Bindings.Reflection.IBindingParameter {
    public IBindingType Type { get; }
    public string ParameterName { get; }
    public abstract virtual IBindingType get_Type();
    public abstract virtual string get_ParameterName();
}
public interface TechTalk.SpecFlow.Bindings.Reflection.IBindingType {
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyName { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual string get_AssemblyName();
}
public interface TechTalk.SpecFlow.Bindings.Reflection.IPolymorphicBindingType {
    public abstract virtual bool IsAssignableTo(IBindingType baseType);
}
public class TechTalk.SpecFlow.Bindings.Reflection.RuntimeBindingMethod : object {
    public MethodInfo MethodInfo;
    public IBindingType Type { get; }
    public IBindingType ReturnType { get; }
    public string Name { get; }
    public IEnumerable`1<IBindingParameter> Parameters { get; }
    public RuntimeBindingMethod(MethodInfo methodInfo);
    public sealed virtual IBindingType get_Type();
    public sealed virtual IBindingType get_ReturnType();
    public sealed virtual string get_Name();
    public sealed virtual IEnumerable`1<IBindingParameter> get_Parameters();
    public virtual string ToString();
    protected bool Equals(RuntimeBindingMethod other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class TechTalk.SpecFlow.Bindings.Reflection.RuntimeBindingParameter : object {
    private ParameterInfo parameterInfo;
    public IBindingType Type { get; }
    public string ParameterName { get; }
    public RuntimeBindingParameter(ParameterInfo parameterInfo);
    public sealed virtual IBindingType get_Type();
    public sealed virtual string get_ParameterName();
    public virtual string ToString();
    protected bool Equals(RuntimeBindingParameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class TechTalk.SpecFlow.Bindings.Reflection.RuntimeBindingType : object {
    public Type Type;
    public static RuntimeBindingType Void;
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyName { get; }
    public RuntimeBindingType(Type type);
    private static RuntimeBindingType();
    public sealed virtual string get_Name();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyName();
    public sealed virtual bool IsAssignableTo(IBindingType baseType);
    public virtual string ToString();
    protected bool Equals(RuntimeBindingType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class TechTalk.SpecFlow.Bindings.RegexFactory : object {
    private static RegexOptions RegexOptions;
    private static RegexFactory();
    public static Regex CreateWholeTextRegexForBindings(string regexString);
    public static string GetWholeTextMatchRegexSource(string regexString);
    public static Regex CreateRegexForBindings(string regexString);
}
public class TechTalk.SpecFlow.Bindings.RegexStepDefinitionBindingBuilder : StepDefinitionBindingBuilderBase {
    public RegexStepDefinitionBindingBuilder(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression);
    protected virtual IExpression CreateExpression(String& expressionType);
    protected virtual string GetRegexSource(String& expressionType);
}
public class TechTalk.SpecFlow.Bindings.StepArgumentTransformationBinding : MethodBinding {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    public string Name { get; }
    public Regex Regex { get; }
    public StepArgumentTransformationBinding(Regex regex, IBindingMethod bindingMethod, string name);
    public StepArgumentTransformationBinding(string regexString, IBindingMethod bindingMethod, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Regex get_Regex();
    private static Regex CreateRegexOrNull(string regexString);
}
public class TechTalk.SpecFlow.Bindings.StepArgumentTypeConverter : object {
    private ITestTracer testTracer;
    private IBindingRegistry bindingRegistry;
    private IContextManager contextManager;
    private IAsyncBindingInvoker bindingInvoker;
    public StepArgumentTypeConverter(ITestTracer testTracer, IBindingRegistry bindingRegistry, IContextManager contextManager, IAsyncBindingInvoker bindingInvoker);
    protected virtual IStepArgumentTransformationBinding GetMatchingStepTransformation(object value, IBindingType typeToConvertTo, bool traceWarning);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.StepArgumentTypeConverter/<ConvertAsync>d__6")]
public sealed virtual Task`1<object> ConvertAsync(object value, IBindingType typeToConvertTo, CultureInfo cultureInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.StepArgumentTypeConverter/<DoTransformAsync>d__7")]
private Task`1<object> DoTransformAsync(IStepArgumentTransformationBinding stepTransformation, object value, CultureInfo cultureInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Bindings.StepArgumentTypeConverter/<GetStepTransformationArgumentsFromRegexAsync>d__8")]
private Task`1<Object[]> GetStepTransformationArgumentsFromRegexAsync(IStepArgumentTransformationBinding stepTransformation, string stepSnippet, CultureInfo cultureInfo);
    public sealed virtual bool CanConvert(object value, IBindingType typeToConvertTo, CultureInfo cultureInfo);
    private bool CanConvert(IStepArgumentTransformationBinding stepTransformationBinding, object valueToConvert, IBindingType typeToConvertTo);
    private static object ConvertSimple(IBindingType typeToConvertTo, object value, CultureInfo cultureInfo);
    private static object ConvertSimple(Type typeToConvertTo, object value, CultureInfo cultureInfo);
    private static bool TryConvertWithTypeConverter(Type typeToConvertTo, object value, CultureInfo cultureInfo, Object& result);
    public static object ConvertToAnEnum(Type enumType, string value);
    private static string RemoveWhitespace(string value);
    public static bool CanConvertSimple(IBindingType typeToConvertTo, object value, CultureInfo cultureInfo);
}
public class TechTalk.SpecFlow.Bindings.StepContext : object {
    [CompilerGeneratedAttribute]
private string <FeatureTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScenarioTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Tags>k__BackingField;
    public string FeatureTitle { get; private set; }
    public string ScenarioTitle { get; private set; }
    public CultureInfo Language { get; private set; }
    public IEnumerable`1<string> Tags { get; private set; }
    public StepContext(string featureTitle, string scenarioTitle, IEnumerable`1<string> tags, CultureInfo language);
    public StepContext(FeatureInfo featureInfo, ScenarioInfo scenarioInfo);
    [CompilerGeneratedAttribute]
public string get_FeatureTitle();
    [CompilerGeneratedAttribute]
private void set_FeatureTitle(string value);
    [CompilerGeneratedAttribute]
public string get_ScenarioTitle();
    [CompilerGeneratedAttribute]
private void set_ScenarioTitle(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(CultureInfo value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(IEnumerable`1<string> value);
}
public class TechTalk.SpecFlow.Bindings.StepDefinitionBinding : MethodBinding {
    [CompilerGeneratedAttribute]
private StepDefinitionType <StepDefinitionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingScope <BindingScope>k__BackingField;
    public StepDefinitionType StepDefinitionType { get; }
    public string SourceExpression { get; }
    public string ExpressionType { get; }
    public bool IsValid { get; }
    public string ErrorMessage { get; }
    public Regex Regex { get; }
    public IExpression Expression { get; }
    public BindingScope BindingScope { get; }
    public bool IsScoped { get; }
    public StepDefinitionBinding(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string expressionType, string sourceExpression, IExpression expression);
    private StepDefinitionBinding(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string expressionType, string sourceExpression, string errorMessage);
    [CompilerGeneratedAttribute]
public sealed virtual StepDefinitionType get_StepDefinitionType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceExpression();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpressionType();
    public sealed virtual bool get_IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ErrorMessage();
    public sealed virtual Regex get_Regex();
    [CompilerGeneratedAttribute]
public sealed virtual IExpression get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual BindingScope get_BindingScope();
    public sealed virtual bool get_IsScoped();
    public static StepDefinitionBinding CreateInvalid(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string expressionType, string sourceExpression, string errorMessage);
}
public abstract class TechTalk.SpecFlow.Bindings.StepDefinitionBindingBuilderBase : object {
    protected StepDefinitionType _stepDefinitionType;
    protected IBindingMethod _bindingMethod;
    protected BindingScope _bindingScope;
    protected string _sourceExpression;
    protected StepDefinitionBindingBuilderBase(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod, BindingScope bindingScope, string sourceExpression);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.StepDefinitionBindingBuilderBase/<Build>d__5")]
public virtual IEnumerable`1<IStepDefinitionBinding> Build();
    protected abstract virtual IExpression CreateExpression(String& expressionType);
    public virtual IStepDefinitionBinding BuildSingle();
}
public static class TechTalk.SpecFlow.Bindings.StepDefinitionExpressionTypes : object {
    public static string RegularExpression;
    public static string CucumberExpression;
    public static string MethodName;
    public static string Unknown;
}
public enum TechTalk.SpecFlow.Bindings.StepDefinitionKeyword : Enum {
    public int value__;
    public static StepDefinitionKeyword Given;
    public static StepDefinitionKeyword When;
    public static StepDefinitionKeyword Then;
    public static StepDefinitionKeyword And;
    public static StepDefinitionKeyword But;
}
public class TechTalk.SpecFlow.Bindings.StepDefinitionRegexCalculator : object {
    private static string WordConnectorRe;
    private static Regex nonIdentifierRe;
    private static Regex wordBoundaryRe;
    private SpecFlowConfiguration specFlowConfiguration;
    public StepDefinitionRegexCalculator(SpecFlowConfiguration specFlowConfiguration);
    private static StepDefinitionRegexCalculator();
    public sealed virtual string CalculateRegexFromMethod(StepDefinitionType stepDefinitionType, IBindingMethod bindingMethod);
    private string RemoveStepPrefix(StepDefinitionType stepDefinitionType, string stepText);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Bindings.StepDefinitionRegexCalculator/<GetPrefixesToRemove>d__5")]
private IEnumerable`1<string> GetPrefixesToRemove(StepDefinitionType stepDefinitionType);
    private string CalculateParamRegex(IBindingParameter parameterInfo);
    private string CalculateWordRegex(string methodNamePart);
    private ParamSearchResult CalculateParamPosition(string methodNamePart, IBindingParameter bindingParameter, int paramIndex);
}
public enum TechTalk.SpecFlow.Bindings.StepDefinitionType : Enum {
    public int value__;
    public static StepDefinitionType Given;
    public static StepDefinitionType When;
    public static StepDefinitionType Then;
}
public class TechTalk.SpecFlow.Bindings.StepInstance : object {
    [CompilerGeneratedAttribute]
private StepDefinitionType <StepDefinitionType>k__BackingField;
    [CompilerGeneratedAttribute]
private StepDefinitionKeyword <StepDefinitionKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MultilineTextArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <TableArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private StepContext <StepContext>k__BackingField;
    public StepDefinitionType StepDefinitionType { get; private set; }
    public StepDefinitionKeyword StepDefinitionKeyword { get; private set; }
    public string Keyword { get; private set; }
    public string Text { get; private set; }
    public string MultilineTextArgument { get; public set; }
    public Table TableArgument { get; public set; }
    public StepContext StepContext { get; private set; }
    public StepInstance(StepDefinitionType stepDefinitionType, StepDefinitionKeyword stepDefinitionKeyword, string keywordWithTrailingSpaces, string text, StepContext stepContext);
    public StepInstance(StepDefinitionType type, StepDefinitionKeyword stepDefinitionKeyword, string keyword, string text, string multilineTextArgument, Table tableArgument, StepContext stepContext);
    [CompilerGeneratedAttribute]
public StepDefinitionType get_StepDefinitionType();
    [CompilerGeneratedAttribute]
private void set_StepDefinitionType(StepDefinitionType value);
    [CompilerGeneratedAttribute]
public StepDefinitionKeyword get_StepDefinitionKeyword();
    [CompilerGeneratedAttribute]
private void set_StepDefinitionKeyword(StepDefinitionKeyword value);
    [CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
private void set_Keyword(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_MultilineTextArgument();
    [CompilerGeneratedAttribute]
public void set_MultilineTextArgument(string value);
    [CompilerGeneratedAttribute]
public Table get_TableArgument();
    [CompilerGeneratedAttribute]
public void set_TableArgument(Table value);
    [CompilerGeneratedAttribute]
public StepContext get_StepContext();
    [CompilerGeneratedAttribute]
private void set_StepContext(StepContext value);
}
public class TechTalk.SpecFlow.BindingSkeletons.AnalyzedStepParameter : object {
    public string Type;
    public string Name;
    public string RegexPattern;
    public string WrapText;
    public string CucumberExpressionTypeName;
    public AnalyzedStepParameter(string type, string name, string regexPattern, string cucumberExpressionTypeName, string wrapText);
}
public class TechTalk.SpecFlow.BindingSkeletons.AnalyzedStepText : object {
    public List`1<string> TextParts;
    public List`1<AnalyzedStepParameter> Parameters;
}
internal class TechTalk.SpecFlow.BindingSkeletons.CaptureWithContext : object {
    [CompilerGeneratedAttribute]
private Capture <Capture>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterType <ParameterType>k__BackingField;
    public Capture Capture { get; }
    public ParameterType ParameterType { get; }
    public CaptureWithContext(Capture capture, ParameterType parameterType);
    [CompilerGeneratedAttribute]
public Capture get_Capture();
    [CompilerGeneratedAttribute]
public ParameterType get_ParameterType();
}
public class TechTalk.SpecFlow.BindingSkeletons.DefaultSkeletonTemplateProvider : FileBasedSkeletonTemplateProvider {
    private ResourceSkeletonTemplateProvider resourceSkeletonTemplateProvider;
    public DefaultSkeletonTemplateProvider(ResourceSkeletonTemplateProvider resourceSkeletonTemplateProvider);
    protected virtual string GetTemplateFileContent();
    protected internal virtual string GetTemplate(string key);
}
public abstract class TechTalk.SpecFlow.BindingSkeletons.FileBasedSkeletonTemplateProvider : object {
    private static string templateSeparator;
    private Dictionary`2<string, string> templates;
    private Dictionary`2<string, string> GetTemplates();
    protected abstract virtual string GetTemplateFileContent();
    protected virtual string MissingTemplate(string key);
    protected internal virtual string GetTemplate(string key);
    public sealed virtual string GetStepDefinitionTemplate(ProgrammingLanguage language, bool withExpression);
    public sealed virtual string GetStepDefinitionClassTemplate(ProgrammingLanguage language);
}
public interface TechTalk.SpecFlow.BindingSkeletons.ISkeletonTemplateProvider {
    public abstract virtual string GetStepDefinitionTemplate(ProgrammingLanguage language, bool withExpression);
    public abstract virtual string GetStepDefinitionClassTemplate(ProgrammingLanguage language);
}
public interface TechTalk.SpecFlow.BindingSkeletons.IStepDefinitionSkeletonProvider {
    public abstract virtual string GetBindingClassSkeleton(ProgrammingLanguage language, StepInstance[] stepInstances, string namespaceName, string className, StepDefinitionSkeletonStyle style, CultureInfo bindingCulture);
    public abstract virtual string GetStepDefinitionSkeleton(ProgrammingLanguage language, StepInstance stepInstance, StepDefinitionSkeletonStyle style, CultureInfo bindingCulture);
}
public interface TechTalk.SpecFlow.BindingSkeletons.IStepTextAnalyzer {
    public abstract virtual AnalyzedStepText Analyze(string stepText, CultureInfo bindingCulture);
}
public static class TechTalk.SpecFlow.BindingSkeletons.Keywords : object {
    [CompilerGeneratedAttribute]
private static List`1<string> <FSharp>k__BackingField;
    [CompilerGeneratedAttribute]
private static List`1<string> <VB>k__BackingField;
    [CompilerGeneratedAttribute]
private static List`1<string> <CSharp>k__BackingField;
    private static List`1<string> FSharp { get; }
    private static List`1<string> VB { get; }
    private static List`1<string> CSharp { get; }
    private static Keywords();
    [CompilerGeneratedAttribute]
private static List`1<string> get_FSharp();
    [CompilerGeneratedAttribute]
private static List`1<string> get_VB();
    [CompilerGeneratedAttribute]
private static List`1<string> get_CSharp();
    public static string EscapeCSharpKeyword(string argumentName);
    public static string EscapeVBKeyword(string argumentName);
    public static string EscapeFSharpKeyword(string argumentName);
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.BindingSkeletons.MatchCollectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<CaptureWithContext> ToCaptureWithContext(MatchCollection collection, ParameterType parameterType);
    [ExtensionAttribute]
public static IEnumerable`1<CaptureWithContext> ToCaptureWithContext(IEnumerable`1<Capture> collection, ParameterType parameterType);
}
public static class TechTalk.SpecFlow.BindingSkeletons.ParameterNameExtensions : object {
}
internal enum TechTalk.SpecFlow.BindingSkeletons.ParameterType : Enum {
    public int value__;
    public static ParameterType Text;
    public static ParameterType Int;
    public static ParameterType Decimal;
    public static ParameterType Date;
}
public class TechTalk.SpecFlow.BindingSkeletons.ResourceSkeletonTemplateProvider : FileBasedSkeletonTemplateProvider {
    protected virtual string GetTemplateFileContent();
}
public class TechTalk.SpecFlow.BindingSkeletons.StepDefinitionSkeletonProvider : object {
    public static string METHOD_INDENT;
    private ISkeletonTemplateProvider templateProvider;
    private IStepTextAnalyzer stepTextAnalyzer;
    private static Regex wordRe;
    public StepDefinitionSkeletonProvider(ISkeletonTemplateProvider templateProvider, IStepTextAnalyzer stepTextAnalyzer);
    private static StepDefinitionSkeletonProvider();
    public sealed virtual string GetBindingClassSkeleton(ProgrammingLanguage language, StepInstance[] stepInstances, string namespaceName, string className, StepDefinitionSkeletonStyle style, CultureInfo bindingCulture);
    private static IEnumerable`1<StepInstance> GetOrderedSteps(StepInstance[] stepInstances);
    public virtual string GetStepDefinitionSkeleton(ProgrammingLanguage language, StepInstance stepInstance, StepDefinitionSkeletonStyle style, CultureInfo bindingCulture);
    private string GetExpression(AnalyzedStepText analyzedStepText, StepDefinitionSkeletonStyle style, ProgrammingLanguage programmingLanguage);
    private string GetCucumberExpression(AnalyzedStepText stepText);
    private AnalyzedStepText Analyze(StepInstance stepInstance, CultureInfo bindingCulture);
    private IEnumerable`1<string> GetWords(string text);
    private string GetMethodName(StepInstance stepInstance, AnalyzedStepText analyzedStepText, StepDefinitionSkeletonStyle style, ProgrammingLanguage language);
    private string GetMatchingMethodName(string keyword, AnalyzedStepText analyzedStepText, CultureInfo language, Action`3<string, CultureInfo, StringBuilder> appendWords, string paramFormat);
    private void AppendWordsUnderscored(string text, CultureInfo language, StringBuilder result);
    private void AppendWordsPascalCase(string text, CultureInfo language, StringBuilder result);
    private string GetRegex(AnalyzedStepText stepText);
    protected static string EscapeRegex(string text);
    private string ApplyTemplate(string template, object args);
    private string ToDeclaration(ProgrammingLanguage language, AnalyzedStepParameter parameter);
    private string GetCSharpTypeName(string type);
    private string GetFSharpTypeName(string type);
}
public enum TechTalk.SpecFlow.BindingSkeletons.StepDefinitionSkeletonStyle : Enum {
    public int value__;
    [DescriptionAttribute("Regular expressions in attributes")]
public static StepDefinitionSkeletonStyle RegexAttribute;
    [DescriptionAttribute("Method name - underscores")]
public static StepDefinitionSkeletonStyle MethodNameUnderscores;
    [DescriptionAttribute("Method name - pascal case")]
public static StepDefinitionSkeletonStyle MethodNamePascalCase;
    [DescriptionAttribute("Method name as regulare expression (F#)")]
public static StepDefinitionSkeletonStyle MethodNameRegex;
    [DescriptionAttribute("Cucumber expressions in attributes")]
public static StepDefinitionSkeletonStyle CucumberExpressionAttribute;
}
public class TechTalk.SpecFlow.BindingSkeletons.StepParameterNameGenerator : object {
    public static string GenerateParameterName(string value, int paramIndex, List`1<string> usedParameterNames);
    public static bool IsSingleWordWithNoNumbers(string value);
    public static bool IsSingleWordSurroundedByAngleBrackets(string value);
    public static string RemoveSurroundingAngleBrackets(string value);
    public static string LowerCaseFirstLetter(string value);
    public static string UniquelyIdentified(string value, List`1<string> usedParameterNames, int parmIndex);
}
public class TechTalk.SpecFlow.BindingSkeletons.StepTextAnalyzer : object {
    private List`1<string> usedParameterNames;
    private static Regex quotesRe;
    private static Regex intRe;
    private static Regex dateRe;
    private static StepTextAnalyzer();
    public sealed virtual AnalyzedStepText Analyze(string stepText, CultureInfo bindingCulture);
    private AnalyzedStepParameter AnalyzeParameter(string value, CultureInfo bindingCulture, int paramIndex, string regexPattern, ParameterType parameterType, string wrapText);
    private IEnumerable`1<CaptureWithContext> RecognizeQuotedTexts(string stepText);
    private IEnumerable`1<CaptureWithContext> RecognizeIntegers(string stepText);
    private IEnumerable`1<CaptureWithContext> RecognizeDecimals(string stepText, CultureInfo bindingCulture);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.BindingSkeletons.StepTextAnalyzer/<GetDateFormats>d__9")]
private static IEnumerable`1<string> GetDateFormats();
    private static string GetDateFormat(string separator);
    private IEnumerable`1<CaptureWithContext> RecognizeDates(string stepText);
}
public class TechTalk.SpecFlow.ColumnCouldNotBeBoundException : Exception {
    [CompilerGeneratedAttribute]
private IList`1<string> <Columns>k__BackingField;
    public IList`1<string> Columns { get; }
    public ColumnCouldNotBeBoundException(IList`1<string> columns);
    public ColumnCouldNotBeBoundException(string message, IList`1<string> columns);
    public ColumnCouldNotBeBoundException(string message, Exception innerException, IList`1<string> columns);
    protected ColumnCouldNotBeBoundException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Columns();
    private static string CreateMessage(IList`1<string> columns);
}
public class TechTalk.SpecFlow.CommonModels.ExceptionFailure : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionFailure(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    public virtual string ToString();
}
public class TechTalk.SpecFlow.CommonModels.ExceptionFailure`1 : ExceptionFailure {
    public ExceptionFailure`1(Exception exception);
}
public class TechTalk.SpecFlow.CommonModels.Failure : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public Failure(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    public virtual string ToString();
}
public class TechTalk.SpecFlow.CommonModels.Failure`1 : Failure {
    public Failure`1(string description);
}
public interface TechTalk.SpecFlow.CommonModels.IFailure {
}
public interface TechTalk.SpecFlow.CommonModels.IFailure`1 {
}
public interface TechTalk.SpecFlow.CommonModels.IResult {
}
public interface TechTalk.SpecFlow.CommonModels.IResult`1 {
}
public interface TechTalk.SpecFlow.CommonModels.ISuccess {
}
public interface TechTalk.SpecFlow.CommonModels.ISuccess`1 {
    public T Result { get; }
    public abstract virtual T get_Result();
}
public static class TechTalk.SpecFlow.CommonModels.Result : object {
    public static IResult Success();
    public static IResult`1<T> Success(T result);
    public static IResult Failure(string description);
    public static IResult Failure(Exception exception);
    public static IResult Failure(string description, IFailure innerFailure);
}
public static class TechTalk.SpecFlow.CommonModels.Result`1 : object {
    public static IResult`1<T> Success(T value);
    public static IResult`1<T> Failure(string description);
    public static IResult`1<T> Failure(Exception exception);
    public static IResult`1<T> Failure(string description, IFailure innerFailure);
}
public class TechTalk.SpecFlow.CommonModels.Success : object {
}
public class TechTalk.SpecFlow.CommonModels.Success`1 : Success {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public T Result { get; }
    public Success`1(T result);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Result();
}
public class TechTalk.SpecFlow.CommonModels.WrappedFailure : Failure {
    [CompilerGeneratedAttribute]
private IFailure <InnerFailure>k__BackingField;
    public IFailure InnerFailure { get; }
    public WrappedFailure(string description, IFailure innerFailure);
    [CompilerGeneratedAttribute]
public IFailure get_InnerFailure();
    public string GetStringOfInnerFailure();
    public virtual string ToString();
}
public class TechTalk.SpecFlow.CommonModels.WrappedFailure`1 : WrappedFailure {
    public WrappedFailure`1(string description, IFailure innerFailure);
}
internal static class TechTalk.SpecFlow.Compatibility.CultureInfoHelper : object {
    public static CultureInfo GetCultureInfo(string cultureName);
}
internal static class TechTalk.SpecFlow.Compatibility.EnumHelper : object {
    public static Array GetValues(Type type);
    public static String[] GetNames(Type type);
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Compatibility.ExceptionHelper : object {
    [ExtensionAttribute]
public static Exception PreserveStackTrace(Exception ex, string methodInfo);
}
internal class TechTalk.SpecFlow.Compatibility.MonoHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsMono>k__BackingField;
    internal static bool IsMono { get; private set; }
    private static MonoHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsMono();
    [CompilerGeneratedAttribute]
private static void set_IsMono(bool value);
    internal static void PreserveStackTrace(Exception ex);
    internal static Assembly GetLoadedAssembly(string assemblyName);
}
internal static class TechTalk.SpecFlow.Compatibility.TypeHelper : object {
    public static bool IsNested(Type type);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.AppConfigConfigurationLoader : object {
    public SpecFlowConfiguration LoadAppConfig(SpecFlowConfiguration specFlowConfiguration, ConfigurationSectionHandler configSection);
    private bool IsSpecified(ConfigurationElement configurationElement);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.BindingCultureConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
[RegexStringValidatorAttribute("\w{2}(-\w{2})?")]
public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.GeneratorConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute]
[ConfigurationCollectionAttribute("BoDi.ContainerRegistrationCollection")]
public ContainerRegistrationCollection Dependencies { get; public set; }
    [ConfigurationPropertyAttribute("allowDebugGeneratedFiles")]
public bool AllowDebugGeneratedFiles { get; public set; }
    [ConfigurationPropertyAttribute("allowRowTests")]
public bool AllowRowTests { get; public set; }
    [ObsoleteAttribute("Async tests are not part of the core library from v2")]
[ConfigurationPropertyAttribute("generateAsyncTests")]
public bool GenerateAsyncTests { get; public set; }
    [ConfigurationPropertyAttribute("path")]
public string GeneratorPath { get; public set; }
    [ConfigurationPropertyAttribute]
[ConfigurationCollectionAttribute("TechTalk.SpecFlow.Configuration.AppConfig.GeneratorConfigElement/TagCollection")]
public TagCollection AddNonParallelizableMarkerForTags { get; public set; }
    public ContainerRegistrationCollection get_Dependencies();
    public void set_Dependencies(ContainerRegistrationCollection value);
    public bool get_AllowDebugGeneratedFiles();
    public void set_AllowDebugGeneratedFiles(bool value);
    public bool get_AllowRowTests();
    public void set_AllowRowTests(bool value);
    public bool get_GenerateAsyncTests();
    public void set_GenerateAsyncTests(bool value);
    public string get_GeneratorPath();
    public void set_GeneratorPath(string value);
    public TagCollection get_AddNonParallelizableMarkerForTags();
    public void set_AddNonParallelizableMarkerForTags(TagCollection value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.LanguageConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("feature")]
[RegexStringValidatorAttribute("\w{2}(-\w{2})?")]
public string Feature { get; public set; }
    [ConfigurationPropertyAttribute("tool")]
[RegexStringValidatorAttribute("\w{2}(-\w{2})?|")]
public string Tool { get; public set; }
    public string get_Feature();
    public void set_Feature(string value);
    public string get_Tool();
    public void set_Tool(string value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.PluginCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Configuration.AppConfig.PluginCollection/<System-Collections-Generic-IEnumerable<TechTalk-SpecFlow-Configuration-AppConfig-PluginConfigElement>-GetEnumerator>d__2")]
private sealed virtual override IEnumerator`1<PluginConfigElement> System.Collections.Generic.IEnumerable<TechTalk.SpecFlow.Configuration.AppConfig.PluginConfigElement>.GetEnumerator();
}
public class TechTalk.SpecFlow.Configuration.AppConfig.PluginConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("path")]
public string Path { get; public set; }
    [ConfigurationPropertyAttribute("type")]
public PluginType Type { get; public set; }
    [ConfigurationPropertyAttribute("parameters")]
public string Parameters { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Path();
    public void set_Path(string value);
    public PluginType get_Type();
    public void set_Type(PluginType value);
    public string get_Parameters();
    public void set_Parameters(string value);
    public PluginDescriptor ToPluginDescriptor();
}
public class TechTalk.SpecFlow.Configuration.AppConfig.RuntimeConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute]
[ConfigurationCollectionAttribute("BoDi.ContainerRegistrationCollection")]
public ContainerRegistrationCollection Dependencies { get; public set; }
    [ConfigurationPropertyAttribute("stopAtFirstError")]
public bool StopAtFirstError { get; public set; }
    [ConfigurationPropertyAttribute("missingOrPendingStepsOutcome")]
public MissingOrPendingStepsOutcome MissingOrPendingStepsOutcome { get; public set; }
    [ConfigurationPropertyAttribute("obsoleteBehavior")]
public ObsoleteBehavior ObsoleteBehavior { get; public set; }
    public ContainerRegistrationCollection get_Dependencies();
    public void set_Dependencies(ContainerRegistrationCollection value);
    public bool get_StopAtFirstError();
    public void set_StopAtFirstError(bool value);
    public MissingOrPendingStepsOutcome get_MissingOrPendingStepsOutcome();
    public void set_MissingOrPendingStepsOutcome(MissingOrPendingStepsOutcome value);
    public ObsoleteBehavior get_ObsoleteBehavior();
    public void set_ObsoleteBehavior(ObsoleteBehavior value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.StepAssemblyCollection : ConfigurationElementCollection {
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.StepAssemblyConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("assembly")]
public string Assembly { get; public set; }
    public string get_Assembly();
    public void set_Assembly(string value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.TraceConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("traceSuccessfulSteps")]
public bool TraceSuccessfulSteps { get; public set; }
    [ConfigurationPropertyAttribute("traceTimings")]
public bool TraceTimings { get; public set; }
    [ConfigurationPropertyAttribute("minTracedDuration")]
public TimeSpan MinTracedDuration { get; public set; }
    [ConfigurationPropertyAttribute("listener")]
public string Listener { get; public set; }
    [ConfigurationPropertyAttribute("stepDefinitionSkeletonStyle")]
public StepDefinitionSkeletonStyle StepDefinitionSkeletonStyle { get; public set; }
    [ConfigurationPropertyAttribute("coloredOutput")]
public bool ColoredOutput { get; public set; }
    public bool get_TraceSuccessfulSteps();
    public void set_TraceSuccessfulSteps(bool value);
    public bool get_TraceTimings();
    public void set_TraceTimings(bool value);
    public TimeSpan get_MinTracedDuration();
    public void set_MinTracedDuration(TimeSpan value);
    public string get_Listener();
    public void set_Listener(string value);
    public StepDefinitionSkeletonStyle get_StepDefinitionSkeletonStyle();
    public void set_StepDefinitionSkeletonStyle(StepDefinitionSkeletonStyle value);
    public bool get_ColoredOutput();
    public void set_ColoredOutput(bool value);
}
public class TechTalk.SpecFlow.Configuration.AppConfig.UnitTestProviderConfigElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("generatorProvider")]
public string GeneratorProvider { get; public set; }
    [ConfigurationPropertyAttribute("runtimeProvider")]
public string RuntimeProvider { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_GeneratorProvider();
    public void set_GeneratorProvider(string value);
    public string get_RuntimeProvider();
    public void set_RuntimeProvider(string value);
}
public static class TechTalk.SpecFlow.Configuration.ConfigDefaults : object {
    public static string FeatureLanguage;
    public static string ToolLanguage;
    public static string UnitTestProviderName;
    public static bool DetectAmbiguousMatches;
    public static bool StopAtFirstError;
    public static MissingOrPendingStepsOutcome MissingOrPendingStepsOutcome;
    public static bool TraceSuccessfulSteps;
    public static bool TraceTimings;
    public static string MinTracedDuration;
    public static StepDefinitionSkeletonStyle StepDefinitionSkeletonStyle;
    public static ObsoleteBehavior ObsoleteBehavior;
    public static bool ColoredOutput;
    public static bool AllowDebugGeneratedFiles;
    public static bool AllowRowTests;
    public static string GeneratorPath;
    public static String[] AddNonParallelizableMarkerForTags;
    private static ConfigDefaults();
}
public enum TechTalk.SpecFlow.Configuration.ConfigSource : Enum {
    public int value__;
    public static ConfigSource AppConfig;
    public static ConfigSource Json;
    public static ConfigSource Default;
}
public class TechTalk.SpecFlow.Configuration.ConfigurationLoader : object {
    private AppConfigConfigurationLoader _appConfigConfigurationLoader;
    private JsonConfigurationLoader _jsonConfigurationLoader;
    private ISpecFlowJsonLocator _specFlowJsonLocator;
    private static CultureInfo DefaultFeatureLanguage { get; }
    private static CultureInfo DefaultToolLanguage { get; }
    private static CultureInfo DefaultBindingCulture { get; }
    private static string DefaultUnitTestProvider { get; }
    private static bool DefaultDetectAmbiguousMatches { get; }
    private static bool DefaultStopAtFirstError { get; }
    private static MissingOrPendingStepsOutcome DefaultMissingOrPendingStepsOutcome { get; }
    private static bool DefaultTraceSuccessfulSteps { get; }
    private static bool DefaultTraceTimings { get; }
    private static TimeSpan DefaultMinTracedDuration { get; }
    private static StepDefinitionSkeletonStyle DefaultStepDefinitionSkeletonStyle { get; }
    private static List`1<string> DefaultAdditionalStepAssemblies { get; }
    private static bool DefaultAllowDebugGeneratedFiles { get; }
    private static bool DefaultAllowRowTests { get; }
    public static string DefaultGeneratorPath { get; }
    public static String[] DefaultAddNonParallelizableMarkerForTags { get; }
    public static ObsoleteBehavior DefaultObsoleteBehavior { get; }
    public static bool DefaultColoredOutput { get; }
    public bool HasAppConfig { get; }
    public bool HasJsonConfig { get; }
    public ConfigurationLoader(ISpecFlowJsonLocator specFlowJsonLocator);
    private static CultureInfo get_DefaultFeatureLanguage();
    private static CultureInfo get_DefaultToolLanguage();
    private static CultureInfo get_DefaultBindingCulture();
    private static string get_DefaultUnitTestProvider();
    private static bool get_DefaultDetectAmbiguousMatches();
    private static bool get_DefaultStopAtFirstError();
    private static MissingOrPendingStepsOutcome get_DefaultMissingOrPendingStepsOutcome();
    private static bool get_DefaultTraceSuccessfulSteps();
    private static bool get_DefaultTraceTimings();
    private static TimeSpan get_DefaultMinTracedDuration();
    private static StepDefinitionSkeletonStyle get_DefaultStepDefinitionSkeletonStyle();
    private static List`1<string> get_DefaultAdditionalStepAssemblies();
    private static bool get_DefaultAllowDebugGeneratedFiles();
    private static bool get_DefaultAllowRowTests();
    public static string get_DefaultGeneratorPath();
    public static String[] get_DefaultAddNonParallelizableMarkerForTags();
    public static ObsoleteBehavior get_DefaultObsoleteBehavior();
    public static bool get_DefaultColoredOutput();
    public bool get_HasAppConfig();
    public bool get_HasJsonConfig();
    public sealed virtual SpecFlowConfiguration Load(SpecFlowConfiguration specFlowConfiguration, ISpecFlowConfigurationHolder specFlowConfigurationHolder);
    public sealed virtual SpecFlowConfiguration Load(SpecFlowConfiguration specFlowConfiguration);
    public sealed virtual SpecFlowConfiguration Update(SpecFlowConfiguration specFlowConfiguration, ConfigurationSectionHandler specFlowConfigSection);
    public sealed virtual void TraceConfigSource(ITraceListener traceListener, SpecFlowConfiguration specFlowConfiguration);
    public static SpecFlowConfiguration GetDefault();
    private SpecFlowConfiguration LoadAppConfig(SpecFlowConfiguration specFlowConfiguration);
    private SpecFlowConfiguration LoadAppConfig(SpecFlowConfiguration specFlowConfiguration, ConfigurationSectionHandler specFlowConfigSection);
    private SpecFlowConfiguration LoadJson(SpecFlowConfiguration specFlowConfiguration);
    private SpecFlowConfiguration LoadJson(SpecFlowConfiguration specFlowConfiguration, string jsonContent);
}
public class TechTalk.SpecFlow.Configuration.ConfigurationSectionHandler : ConfigurationSection {
    [ConfigurationPropertyAttribute("language")]
public LanguageConfigElement Language { get; public set; }
    [ConfigurationPropertyAttribute("bindingCulture")]
public BindingCultureConfigElement BindingCulture { get; public set; }
    [ConfigurationPropertyAttribute("generator")]
public GeneratorConfigElement Generator { get; public set; }
    [ConfigurationPropertyAttribute("runtime")]
public RuntimeConfigElement Runtime { get; public set; }
    [ConfigurationPropertyAttribute("trace")]
public TraceConfigElement Trace { get; public set; }
    [ConfigurationPropertyAttribute("stepAssemblies")]
[ConfigurationCollectionAttribute("TechTalk.SpecFlow.Configuration.AppConfig.StepAssemblyCollection")]
public StepAssemblyCollection StepAssemblies { get; public set; }
    public LanguageConfigElement get_Language();
    public void set_Language(LanguageConfigElement value);
    public BindingCultureConfigElement get_BindingCulture();
    public void set_BindingCulture(BindingCultureConfigElement value);
    public GeneratorConfigElement get_Generator();
    public void set_Generator(GeneratorConfigElement value);
    public RuntimeConfigElement get_Runtime();
    public void set_Runtime(RuntimeConfigElement value);
    public TraceConfigElement get_Trace();
    public void set_Trace(TraceConfigElement value);
    public StepAssemblyCollection get_StepAssemblies();
    public void set_StepAssemblies(StepAssemblyCollection value);
    public static ConfigurationSectionHandler CreateFromXml(string xmlContent);
    public static ConfigurationSectionHandler CreateFromXml(XmlNode xmlContent);
}
public class TechTalk.SpecFlow.Configuration.DefaultRuntimeConfigurationProvider : object {
    private IConfigurationLoader _configurationLoader;
    public DefaultRuntimeConfigurationProvider(IConfigurationLoader configurationLoader);
    public sealed virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration);
}
public interface TechTalk.SpecFlow.Configuration.IConfigurationLoader {
    public abstract virtual SpecFlowConfiguration Load(SpecFlowConfiguration specFlowConfiguration, ISpecFlowConfigurationHolder specFlowConfigurationHolder);
    public abstract virtual SpecFlowConfiguration Load(SpecFlowConfiguration specFlowConfiguration);
    public abstract virtual SpecFlowConfiguration Update(SpecFlowConfiguration specFlowConfiguration, ConfigurationSectionHandler specFlowConfigSection);
    public abstract virtual void TraceConfigSource(ITraceListener traceListener, SpecFlowConfiguration specFlowConfiguration);
}
public interface TechTalk.SpecFlow.Configuration.IRuntimeConfigurationProvider {
    public abstract virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration);
}
public interface TechTalk.SpecFlow.Configuration.ISpecFlowConfigurationHolder {
    public ConfigSource ConfigSource { get; }
    public string Content { get; }
    public bool HasConfiguration { get; }
    public abstract virtual ConfigSource get_ConfigSource();
    public abstract virtual string get_Content();
    public abstract virtual bool get_HasConfiguration();
}
public interface TechTalk.SpecFlow.Configuration.ISpecFlowJsonLocator {
    public abstract virtual string GetSpecFlowJsonFilePath();
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.BindingCultureElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DataMemberAttribute]
public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.Dependency : object {
    [CompilerGeneratedAttribute]
private string <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InterfaceType>k__BackingField;
    [DataMemberAttribute]
public string ImplementationType { get; public set; }
    [DataMemberAttribute]
public string InterfaceType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ImplementationType();
    [CompilerGeneratedAttribute]
public void set_ImplementationType(string value);
    [CompilerGeneratedAttribute]
public string get_InterfaceType();
    [CompilerGeneratedAttribute]
public void set_InterfaceType(string value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.GeneratorElement : object {
    [CompilerGeneratedAttribute]
private bool <AllowDebugGeneratedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowRowTests>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AddNonParallelizableMarkerForTags>k__BackingField;
    [DataMemberAttribute]
[DefaultValueAttribute("False")]
public bool AllowDebugGeneratedFiles { get; public set; }
    [DefaultValueAttribute("True")]
[DataMemberAttribute]
public bool AllowRowTests { get; public set; }
    [DataMemberAttribute]
public List`1<string> AddNonParallelizableMarkerForTags { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowDebugGeneratedFiles();
    [CompilerGeneratedAttribute]
public void set_AllowDebugGeneratedFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowRowTests();
    [CompilerGeneratedAttribute]
public void set_AllowRowTests(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AddNonParallelizableMarkerForTags();
    [CompilerGeneratedAttribute]
public void set_AddNonParallelizableMarkerForTags(List`1<string> value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.JsonConfig : object {
    [CompilerGeneratedAttribute]
private LanguageElement <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingCultureElement <BindingCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeElement <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratorElement <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceElement <Trace>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<StepAssemblyElement> <StepAssemblies>k__BackingField;
    [DataMemberAttribute]
public LanguageElement Language { get; public set; }
    [DataMemberAttribute]
public BindingCultureElement BindingCulture { get; public set; }
    [DataMemberAttribute]
public RuntimeElement Runtime { get; public set; }
    [DataMemberAttribute]
public GeneratorElement Generator { get; public set; }
    [DataMemberAttribute]
public TraceElement Trace { get; public set; }
    [DataMemberAttribute]
public List`1<StepAssemblyElement> StepAssemblies { get; public set; }
    [CompilerGeneratedAttribute]
public LanguageElement get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(LanguageElement value);
    [CompilerGeneratedAttribute]
public BindingCultureElement get_BindingCulture();
    [CompilerGeneratedAttribute]
public void set_BindingCulture(BindingCultureElement value);
    [CompilerGeneratedAttribute]
public RuntimeElement get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(RuntimeElement value);
    [CompilerGeneratedAttribute]
public GeneratorElement get_Generator();
    [CompilerGeneratedAttribute]
public void set_Generator(GeneratorElement value);
    [CompilerGeneratedAttribute]
public TraceElement get_Trace();
    [CompilerGeneratedAttribute]
public void set_Trace(TraceElement value);
    [CompilerGeneratedAttribute]
public List`1<StepAssemblyElement> get_StepAssemblies();
    [CompilerGeneratedAttribute]
public void set_StepAssemblies(List`1<StepAssemblyElement> value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.JsonConfigurationLoader : object {
    public SpecFlowConfiguration LoadJson(SpecFlowConfiguration specFlowConfiguration, string jsonContent);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.LanguageElement : object {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [DefaultValueAttribute("en-US")]
[DataMemberAttribute]
public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.PluginElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private PluginType <Type>k__BackingField;
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string Path { get; public set; }
    [DataMemberAttribute]
public string Parameters { get; public set; }
    [DataMemberAttribute]
public PluginType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(string value);
    [CompilerGeneratedAttribute]
public PluginType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PluginType value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.RuntimeElement : object {
    [CompilerGeneratedAttribute]
private bool <StopAtFirstError>k__BackingField;
    [CompilerGeneratedAttribute]
private MissingOrPendingStepsOutcome <MissingOrPendingStepsOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private ObsoleteBehavior <ObsoleteBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Dependency> <Dependencies>k__BackingField;
    [DataMemberAttribute]
[DefaultValueAttribute("False")]
public bool StopAtFirstError { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MissingOrPendingStepsOutcome MissingOrPendingStepsOutcome { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ObsoleteBehavior ObsoleteBehavior { get; public set; }
    [DataMemberAttribute]
public List`1<Dependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StopAtFirstError();
    [CompilerGeneratedAttribute]
public void set_StopAtFirstError(bool value);
    [CompilerGeneratedAttribute]
public MissingOrPendingStepsOutcome get_MissingOrPendingStepsOutcome();
    [CompilerGeneratedAttribute]
public void set_MissingOrPendingStepsOutcome(MissingOrPendingStepsOutcome value);
    [CompilerGeneratedAttribute]
public ObsoleteBehavior get_ObsoleteBehavior();
    [CompilerGeneratedAttribute]
public void set_ObsoleteBehavior(ObsoleteBehavior value);
    [CompilerGeneratedAttribute]
public List`1<Dependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(List`1<Dependency> value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.StepAssemblyElement : object {
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [DataMemberAttribute]
public string Assembly { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.TraceElement : object {
    [CompilerGeneratedAttribute]
private bool <TraceTimings>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinTracedDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private StepDefinitionSkeletonStyle <StepDefinitionSkeletonStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ColoredOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceSuccessfulSteps>k__BackingField;
    [DataMemberAttribute]
[DefaultValueAttribute("False")]
public bool TraceTimings { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("0:0:0.1")]
public TimeSpan MinTracedDuration { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public StepDefinitionSkeletonStyle StepDefinitionSkeletonStyle { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("False")]
public bool ColoredOutput { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("True")]
public bool TraceSuccessfulSteps { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TraceTimings();
    [CompilerGeneratedAttribute]
public void set_TraceTimings(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MinTracedDuration();
    [CompilerGeneratedAttribute]
public void set_MinTracedDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public StepDefinitionSkeletonStyle get_StepDefinitionSkeletonStyle();
    [CompilerGeneratedAttribute]
public void set_StepDefinitionSkeletonStyle(StepDefinitionSkeletonStyle value);
    [CompilerGeneratedAttribute]
public bool get_ColoredOutput();
    [CompilerGeneratedAttribute]
public void set_ColoredOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceSuccessfulSteps();
    [CompilerGeneratedAttribute]
public void set_TraceSuccessfulSteps(bool value);
}
public class TechTalk.SpecFlow.Configuration.JsonConfig.UnitTestProviderElement : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("NUnit")]
[DataMemberAttribute]
public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public enum TechTalk.SpecFlow.Configuration.MissingOrPendingStepsOutcome : Enum {
    public int value__;
    public static MissingOrPendingStepsOutcome Pending;
    public static MissingOrPendingStepsOutcome Inconclusive;
    public static MissingOrPendingStepsOutcome Ignore;
    public static MissingOrPendingStepsOutcome Error;
}
public enum TechTalk.SpecFlow.Configuration.ObsoleteBehavior : Enum {
    public int value__;
    public static ObsoleteBehavior None;
    public static ObsoleteBehavior Warn;
    public static ObsoleteBehavior Pending;
    public static ObsoleteBehavior Error;
}
public class TechTalk.SpecFlow.Configuration.SpecFlowConfiguration : object {
    [CompilerGeneratedAttribute]
private ConfigSource <ConfigSource>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerRegistrationCollection <CustomDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerRegistrationCollection <GeneratorCustomDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <FeatureLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <BindingCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopAtFirstError>k__BackingField;
    [CompilerGeneratedAttribute]
private MissingOrPendingStepsOutcome <MissingOrPendingStepsOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private ObsoleteBehavior <ObsoleteBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDebugGeneratedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowRowTests>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AddNonParallelizableMarkerForTags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ColoredOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceSuccessfulSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceTimings>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinTracedDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private StepDefinitionSkeletonStyle <StepDefinitionSkeletonStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AdditionalStepAssemblies>k__BackingField;
    public ConfigSource ConfigSource { get; public set; }
    public ContainerRegistrationCollection CustomDependencies { get; public set; }
    public ContainerRegistrationCollection GeneratorCustomDependencies { get; public set; }
    public CultureInfo FeatureLanguage { get; public set; }
    public CultureInfo BindingCulture { get; public set; }
    public bool StopAtFirstError { get; public set; }
    public MissingOrPendingStepsOutcome MissingOrPendingStepsOutcome { get; public set; }
    public ObsoleteBehavior ObsoleteBehavior { get; public set; }
    public bool AllowDebugGeneratedFiles { get; public set; }
    public bool AllowRowTests { get; public set; }
    public String[] AddNonParallelizableMarkerForTags { get; public set; }
    public bool ColoredOutput { get; public set; }
    public bool TraceSuccessfulSteps { get; public set; }
    public bool TraceTimings { get; public set; }
    public TimeSpan MinTracedDuration { get; public set; }
    public StepDefinitionSkeletonStyle StepDefinitionSkeletonStyle { get; public set; }
    public List`1<string> AdditionalStepAssemblies { get; public set; }
    public SpecFlowConfiguration(ConfigSource configSource, ContainerRegistrationCollection customDependencies, ContainerRegistrationCollection generatorCustomDependencies, CultureInfo featureLanguage, CultureInfo bindingCulture, bool stopAtFirstError, MissingOrPendingStepsOutcome missingOrPendingStepsOutcome, bool traceSuccessfulSteps, bool traceTimings, TimeSpan minTracedDuration, StepDefinitionSkeletonStyle stepDefinitionSkeletonStyle, List`1<string> additionalStepAssemblies, bool allowDebugGeneratedFiles, bool allowRowTests, String[] addNonParallelizableMarkerForTags, ObsoleteBehavior obsoleteBehavior, bool coloredOutput);
    [CompilerGeneratedAttribute]
public ConfigSource get_ConfigSource();
    [CompilerGeneratedAttribute]
public void set_ConfigSource(ConfigSource value);
    [CompilerGeneratedAttribute]
public ContainerRegistrationCollection get_CustomDependencies();
    [CompilerGeneratedAttribute]
public void set_CustomDependencies(ContainerRegistrationCollection value);
    [CompilerGeneratedAttribute]
public ContainerRegistrationCollection get_GeneratorCustomDependencies();
    [CompilerGeneratedAttribute]
public void set_GeneratorCustomDependencies(ContainerRegistrationCollection value);
    [CompilerGeneratedAttribute]
public CultureInfo get_FeatureLanguage();
    [CompilerGeneratedAttribute]
public void set_FeatureLanguage(CultureInfo value);
    [CompilerGeneratedAttribute]
public CultureInfo get_BindingCulture();
    [CompilerGeneratedAttribute]
public void set_BindingCulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public bool get_StopAtFirstError();
    [CompilerGeneratedAttribute]
public void set_StopAtFirstError(bool value);
    [CompilerGeneratedAttribute]
public MissingOrPendingStepsOutcome get_MissingOrPendingStepsOutcome();
    [CompilerGeneratedAttribute]
public void set_MissingOrPendingStepsOutcome(MissingOrPendingStepsOutcome value);
    [CompilerGeneratedAttribute]
public ObsoleteBehavior get_ObsoleteBehavior();
    [CompilerGeneratedAttribute]
public void set_ObsoleteBehavior(ObsoleteBehavior value);
    [CompilerGeneratedAttribute]
public bool get_AllowDebugGeneratedFiles();
    [CompilerGeneratedAttribute]
public void set_AllowDebugGeneratedFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowRowTests();
    [CompilerGeneratedAttribute]
public void set_AllowRowTests(bool value);
    [CompilerGeneratedAttribute]
public String[] get_AddNonParallelizableMarkerForTags();
    [CompilerGeneratedAttribute]
public void set_AddNonParallelizableMarkerForTags(String[] value);
    [CompilerGeneratedAttribute]
public bool get_ColoredOutput();
    [CompilerGeneratedAttribute]
public void set_ColoredOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceSuccessfulSteps();
    [CompilerGeneratedAttribute]
public void set_TraceSuccessfulSteps(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceTimings();
    [CompilerGeneratedAttribute]
public void set_TraceTimings(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MinTracedDuration();
    [CompilerGeneratedAttribute]
public void set_MinTracedDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public StepDefinitionSkeletonStyle get_StepDefinitionSkeletonStyle();
    [CompilerGeneratedAttribute]
public void set_StepDefinitionSkeletonStyle(StepDefinitionSkeletonStyle value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AdditionalStepAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalStepAssemblies(List`1<string> value);
    protected bool Equals(SpecFlowConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class TechTalk.SpecFlow.Configuration.SpecFlowJsonLocator : object {
    public static string JsonConfigurationFileName;
    public sealed virtual string GetSpecFlowJsonFilePath();
}
[IsReadOnlyAttribute]
public class TechTalk.SpecFlow.CultureInfoScope : ValueType {
    private CultureInfo originalCultureInfo;
    public CultureInfoScope(FeatureContext featureContext);
    public sealed virtual void Dispose();
}
public class TechTalk.SpecFlow.EnvironmentAccess.EnvironmentWrapper : object {
    public sealed virtual IResult`1<string> ResolveEnvironmentVariables(string source);
    public sealed virtual bool IsEnvironmentVariableSet(string name);
    public sealed virtual IResult`1<string> GetEnvironmentVariable(string name);
    public sealed virtual void SetEnvironmentVariable(string name, string value);
    public sealed virtual string GetCurrentDirectory();
}
public interface TechTalk.SpecFlow.EnvironmentAccess.IEnvironmentWrapper {
    public abstract virtual IResult`1<string> ResolveEnvironmentVariables(string source);
    public abstract virtual bool IsEnvironmentVariableSet(string name);
    public abstract virtual IResult`1<string> GetEnvironmentVariable(string name);
    public abstract virtual void SetEnvironmentVariable(string name, string value);
    public abstract virtual string GetCurrentDirectory();
}
public class TechTalk.SpecFlow.EnvironmentVariableNames : object {
    public static string NCrunch;
    public static string SpecflowDisableParallelExecution;
}
internal class TechTalk.SpecFlow.ErrorHandling.ErrorProvider : object {
    private IStepFormatter stepFormatter;
    private IUnitTestRuntimeProvider unitTestRuntimeProvider;
    private SpecFlowConfiguration specFlowConfiguration;
    public ErrorProvider(IStepFormatter stepFormatter, SpecFlowConfiguration specFlowConfiguration, IUnitTestRuntimeProvider unitTestRuntimeProvider);
    public sealed virtual string GetMethodText(IBindingMethod method);
    public sealed virtual Exception GetCallError(IBindingMethod method, Exception ex);
    public sealed virtual Exception GetParameterCountError(BindingMatch match, int expectedParameterCount);
    public sealed virtual Exception GetAmbiguousMatchError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public sealed virtual Exception GetAmbiguousBecauseParamCheckMatchError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public sealed virtual Exception GetNoMatchBecauseOfScopeFilterError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public sealed virtual MissingStepDefinitionException GetMissingStepDefinitionError();
    public sealed virtual PendingStepException GetPendingStepDefinitionError();
    public sealed virtual void ThrowPendingError(ScenarioExecutionStatus testStatus, string message);
    public sealed virtual Exception GetTooManyBindingParamError(int maxParam);
    public sealed virtual Exception GetObsoleteStepError(BindingObsoletion bindingObsoletion);
    public sealed virtual Exception GetInvalidStepDefinitionError(IStepDefinitionBinding stepDefinitionBinding);
    public sealed virtual Exception GetInvalidBindingRegistryError(IEnumerable`1<BindingError> errors);
    [CompilerGeneratedAttribute]
private string <GetAmbiguousMatchError>b__7_0(BindingMatch m);
    [CompilerGeneratedAttribute]
private string <GetAmbiguousBecauseParamCheckMatchError>b__8_0(BindingMatch m);
    [CompilerGeneratedAttribute]
private string <GetNoMatchBecauseOfScopeFilterError>b__9_0(BindingMatch m);
}
public interface TechTalk.SpecFlow.ErrorHandling.IErrorProvider {
    public abstract virtual string GetMethodText(IBindingMethod method);
    public abstract virtual Exception GetCallError(IBindingMethod method, Exception ex);
    public abstract virtual Exception GetParameterCountError(BindingMatch match, int expectedParameterCount);
    public abstract virtual Exception GetAmbiguousMatchError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public abstract virtual Exception GetAmbiguousBecauseParamCheckMatchError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public abstract virtual Exception GetNoMatchBecauseOfScopeFilterError(List`1<BindingMatch> matches, StepInstance stepInstance);
    public abstract virtual MissingStepDefinitionException GetMissingStepDefinitionError();
    public abstract virtual PendingStepException GetPendingStepDefinitionError();
    public abstract virtual void ThrowPendingError(ScenarioExecutionStatus testStatus, string message);
    public abstract virtual Exception GetTooManyBindingParamError(int maxParam);
    public abstract virtual Exception GetObsoleteStepError(BindingObsoletion bindingObsoletion);
    public abstract virtual Exception GetInvalidStepDefinitionError(IStepDefinitionBinding stepDefinitionBinding);
    public abstract virtual Exception GetInvalidBindingRegistryError(IEnumerable`1<BindingError> errors);
}
public class TechTalk.SpecFlow.Events.AttachmentAddedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; }
    public AttachmentAddedEvent(string filePath);
    [CompilerGeneratedAttribute]
public string get_FilePath();
}
public class TechTalk.SpecFlow.Events.ExecutionEvent : object {
}
public class TechTalk.SpecFlow.Events.FeatureFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public FeatureFinishedEvent(IFeatureContext featureContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
}
public class TechTalk.SpecFlow.Events.FeatureStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public FeatureStartedEvent(IFeatureContext featureContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
}
public class TechTalk.SpecFlow.Events.HookBindingFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IHookBinding <HookBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public IHookBinding HookBinding { get; }
    public TimeSpan Duration { get; }
    public HookBindingFinishedEvent(IHookBinding hookBinding, TimeSpan duration);
    [CompilerGeneratedAttribute]
public IHookBinding get_HookBinding();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
}
public class TechTalk.SpecFlow.Events.HookBindingStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IHookBinding <HookBinding>k__BackingField;
    public IHookBinding HookBinding { get; }
    public HookBindingStartedEvent(IHookBinding hookBinding);
    [CompilerGeneratedAttribute]
public IHookBinding get_HookBinding();
}
public class TechTalk.SpecFlow.Events.HookFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private HookType <HookType>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioStepContext <StepContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <HookException>k__BackingField;
    public HookType HookType { get; }
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public IScenarioStepContext StepContext { get; }
    public Exception HookException { get; }
    public HookFinishedEvent(HookType hookType, IFeatureContext featureContext, IScenarioContext scenarioContext, IScenarioStepContext stepContext, Exception hookException);
    [CompilerGeneratedAttribute]
public HookType get_HookType();
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
    [CompilerGeneratedAttribute]
public IScenarioStepContext get_StepContext();
    [CompilerGeneratedAttribute]
public Exception get_HookException();
}
public class TechTalk.SpecFlow.Events.HookStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private HookType <HookType>k__BackingField;
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioStepContext <StepContext>k__BackingField;
    public HookType HookType { get; }
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public IScenarioStepContext StepContext { get; }
    public HookStartedEvent(HookType hookType, IFeatureContext featureContext, IScenarioContext scenarioContext, IScenarioStepContext stepContext);
    [CompilerGeneratedAttribute]
public HookType get_HookType();
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
    [CompilerGeneratedAttribute]
public IScenarioStepContext get_StepContext();
}
public interface TechTalk.SpecFlow.Events.IExecutionEvent {
}
public interface TechTalk.SpecFlow.Events.IExecutionEventListener {
    public abstract virtual void OnEvent(IExecutionEvent executionEvent);
}
public interface TechTalk.SpecFlow.Events.IExecutionOutputEvent {
}
public interface TechTalk.SpecFlow.Events.ITestThreadExecutionEventPublisher {
    public abstract virtual void PublishEvent(IExecutionEvent executionEvent);
    public abstract virtual void AddListener(IExecutionEventListener listener);
    public abstract virtual void AddHandler(Action`1<TEvent> handler);
}
public class TechTalk.SpecFlow.Events.OutputAddedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public OutputAddedEvent(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
}
public class TechTalk.SpecFlow.Events.ScenarioFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public ScenarioFinishedEvent(IFeatureContext featureContext, IScenarioContext scenarioContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
}
public class TechTalk.SpecFlow.Events.ScenarioSkippedEvent : ExecutionEvent {
}
public class TechTalk.SpecFlow.Events.ScenarioStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public ScenarioStartedEvent(IFeatureContext featureContext, IScenarioContext scenarioContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
}
public class TechTalk.SpecFlow.Events.StepBindingFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IStepDefinitionBinding <StepDefinitionBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public IStepDefinitionBinding StepDefinitionBinding { get; }
    public TimeSpan Duration { get; }
    public StepBindingFinishedEvent(IStepDefinitionBinding stepDefinitionBinding, TimeSpan duration);
    [CompilerGeneratedAttribute]
public IStepDefinitionBinding get_StepDefinitionBinding();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
}
public class TechTalk.SpecFlow.Events.StepBindingStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IStepDefinitionBinding <StepDefinitionBinding>k__BackingField;
    public IStepDefinitionBinding StepDefinitionBinding { get; }
    public StepBindingStartedEvent(IStepDefinitionBinding stepDefinitionBinding);
    [CompilerGeneratedAttribute]
public IStepDefinitionBinding get_StepDefinitionBinding();
}
public class TechTalk.SpecFlow.Events.StepFinishedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioStepContext <StepContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public IScenarioStepContext StepContext { get; }
    public StepFinishedEvent(IFeatureContext featureContext, IScenarioContext scenarioContext, IScenarioStepContext stepContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
    [CompilerGeneratedAttribute]
public IScenarioStepContext get_StepContext();
}
public class TechTalk.SpecFlow.Events.StepSkippedEvent : ExecutionEvent {
}
public class TechTalk.SpecFlow.Events.StepStartedEvent : ExecutionEvent {
    [CompilerGeneratedAttribute]
private IFeatureContext <FeatureContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioContext <ScenarioContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IScenarioStepContext <StepContext>k__BackingField;
    public IFeatureContext FeatureContext { get; }
    public IScenarioContext ScenarioContext { get; }
    public IScenarioStepContext StepContext { get; }
    public StepStartedEvent(IFeatureContext featureContext, IScenarioContext scenarioContext, IScenarioStepContext stepContext);
    [CompilerGeneratedAttribute]
public IFeatureContext get_FeatureContext();
    [CompilerGeneratedAttribute]
public IScenarioContext get_ScenarioContext();
    [CompilerGeneratedAttribute]
public IScenarioStepContext get_StepContext();
}
public class TechTalk.SpecFlow.Events.TestRunFinishedEvent : ExecutionEvent {
}
public class TechTalk.SpecFlow.Events.TestRunStartedEvent : ExecutionEvent {
}
public class TechTalk.SpecFlow.Events.TestThreadExecutionEventPublisher : object {
    private List`1<IExecutionEventListener> _listeners;
    private Dictionary`2<Type, List`1<Delegate>> _handlersDictionary;
    public sealed virtual void PublishEvent(IExecutionEvent executionEvent);
    public sealed virtual void AddListener(IExecutionEventListener listener);
    public sealed virtual void AddHandler(Action`1<TEvent> handler);
}
public class TechTalk.SpecFlow.FeatureContext : SpecFlowContext {
    private static bool isCurrentDisabled;
    private static FeatureContext current;
    [CompilerGeneratedAttribute]
private FeatureInfo <FeatureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <BindingCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectContainer <FeatureContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    [ObsoleteAttribute("Please get the FeatureContext via Context Injection - https://go.specflow.org/Migrate-FeatureContext-Current")]
public static FeatureContext Current { get; internal set; }
    public FeatureInfo FeatureInfo { get; }
    public CultureInfo BindingCulture { get; }
    public IObjectContainer FeatureContainer { get; }
    internal Stopwatch Stopwatch { get; }
    internal FeatureContext(IObjectContainer featureContainer, FeatureInfo featureInfo, SpecFlowConfiguration specFlowConfiguration);
    public static FeatureContext get_Current();
    internal static void set_Current(FeatureContext value);
    internal static void DisableSingletonInstance();
    [CompilerGeneratedAttribute]
public sealed virtual FeatureInfo get_FeatureInfo();
    [CompilerGeneratedAttribute]
public sealed virtual CultureInfo get_BindingCulture();
    [CompilerGeneratedAttribute]
public sealed virtual IObjectContainer get_FeatureContainer();
    [CompilerGeneratedAttribute]
internal Stopwatch get_Stopwatch();
}
public class TechTalk.SpecFlow.FeatureInfo : object {
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgrammingLanguage <GenerationTargetLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Language>k__BackingField;
    public String[] Tags { get; private set; }
    public ProgrammingLanguage GenerationTargetLanguage { get; private set; }
    public string FolderPath { get; private set; }
    public string Title { get; private set; }
    public string Description { get; private set; }
    public CultureInfo Language { get; private set; }
    public FeatureInfo(CultureInfo language, string folderPath, string title, string description, String[] tags);
    public FeatureInfo(CultureInfo language, string folderPath, string title, string description, ProgrammingLanguage programmingLanguage, String[] tags);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public ProgrammingLanguage get_GenerationTargetLanguage();
    [CompilerGeneratedAttribute]
private void set_GenerationTargetLanguage(ProgrammingLanguage value);
    [CompilerGeneratedAttribute]
public string get_FolderPath();
    [CompilerGeneratedAttribute]
private void set_FolderPath(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(CultureInfo value);
}
public class TechTalk.SpecFlow.FileAccess.BinaryFileAccessor : object {
    public sealed virtual IResult`1<Stream> OpenAppendOrCreateFile(string filePath);
}
public interface TechTalk.SpecFlow.FileAccess.IBinaryFileAccessor {
    public abstract virtual IResult`1<Stream> OpenAppendOrCreateFile(string filePath);
}
public class TechTalk.SpecFlow.GivenAttribute : StepDefinitionBaseAttribute {
    public GivenAttribute(string regex);
    public GivenAttribute(string regex, string culture);
}
[AttributeUsageAttribute("64")]
public abstract class TechTalk.SpecFlow.HookAttribute : Attribute {
    [CompilerGeneratedAttribute]
private HookType <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public static int DefaultOrder;
    internal HookType Event { get; private set; }
    public String[] Tags { get; private set; }
    public int Order { get; public set; }
    internal HookAttribute(HookType bindingEvent, String[] tags);
    [CompilerGeneratedAttribute]
internal HookType get_Event();
    [CompilerGeneratedAttribute]
private void set_Event(HookType value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
}
public interface TechTalk.SpecFlow.IFeatureContext {
    public FeatureInfo FeatureInfo { get; }
    public CultureInfo BindingCulture { get; }
    public IObjectContainer FeatureContainer { get; }
    public abstract virtual FeatureInfo get_FeatureInfo();
    public abstract virtual CultureInfo get_BindingCulture();
    public abstract virtual IObjectContainer get_FeatureContainer();
}
public class TechTalk.SpecFlow.Infrastructure.BindingAssemblyLoader : object {
    public sealed virtual Assembly Load(string assemblyName);
}
public class TechTalk.SpecFlow.Infrastructure.BlockingSyncTestRunner : object {
    private ITestRunner _testRunner;
    public string TestWorkerId { get; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public BlockingSyncTestRunner(ITestRunner testRunner);
    private void SyncWrapper(Func`1<Task> asyncCall);
    public sealed virtual string get_TestWorkerId();
    public sealed virtual FeatureContext get_FeatureContext();
    public sealed virtual ScenarioContext get_ScenarioContext();
    public sealed virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    public sealed virtual void SkipScenario();
    public sealed virtual void Pending();
    public sealed virtual void OnTestRunStart();
    public sealed virtual void OnTestRunEnd();
    public sealed virtual void OnFeatureStart(FeatureInfo featureInfo);
    public sealed virtual void OnFeatureEnd();
    public sealed virtual void OnScenarioStart();
    public sealed virtual void CollectScenarioErrors();
    public sealed virtual void OnScenarioEnd();
    public sealed virtual void Given(string text, string multilineTextArg, Table tableArg, string keyword);
    public sealed virtual void When(string text, string multilineTextArg, Table tableArg, string keyword);
    public sealed virtual void Then(string text, string multilineTextArg, Table tableArg, string keyword);
    public sealed virtual void And(string text, string multilineTextArg, Table tableArg, string keyword);
    public sealed virtual void But(string text, string multilineTextArg, Table tableArg, string keyword);
    [CompilerGeneratedAttribute]
private Task <OnTestRunStart>b__12_0();
    [CompilerGeneratedAttribute]
private Task <OnTestRunEnd>b__13_0();
    [CompilerGeneratedAttribute]
private Task <OnFeatureEnd>b__15_0();
    [CompilerGeneratedAttribute]
private Task <OnScenarioStart>b__16_0();
    [CompilerGeneratedAttribute]
private Task <CollectScenarioErrors>b__17_0();
    [CompilerGeneratedAttribute]
private Task <OnScenarioEnd>b__18_0();
}
public class TechTalk.SpecFlow.Infrastructure.ContainerBuilder : object {
    public static IDefaultDependencyProvider DefaultDependencyProvider;
    private IDefaultDependencyProvider _defaultDependencyProvider;
    public ContainerBuilder(IDefaultDependencyProvider defaultDependencyProvider);
    private static ContainerBuilder();
    public virtual IObjectContainer CreateGlobalContainer(Assembly testAssembly, IRuntimeConfigurationProvider configurationProvider);
    public virtual IObjectContainer CreateTestThreadContainer(IObjectContainer globalContainer);
    public virtual IObjectContainer CreateScenarioContainer(IObjectContainer testThreadContainer, ScenarioInfo scenarioInfo);
    public sealed virtual IObjectContainer CreateFeatureContainer(IObjectContainer testThreadContainer, FeatureInfo featureInfo);
    protected virtual void LoadPlugins(IRuntimeConfigurationProvider configurationProvider, ObjectContainer container, RuntimePluginEvents runtimePluginEvents, SpecFlowConfiguration specFlowConfiguration, UnitTestProviderConfiguration unitTestProviderConfigration, Assembly testAssembly);
    protected virtual void LoadPlugin(string pluginPath, IRuntimePluginLoader pluginLoader, RuntimePluginEvents runtimePluginEvents, UnitTestProviderConfiguration unitTestProviderConfigration, ITraceListener traceListener, bool traceMissingPluginAttribute);
    protected virtual void RegisterDefaults(ObjectContainer container);
}
public class TechTalk.SpecFlow.Infrastructure.ContextManager : object {
    private IObjectContainer testThreadContainer;
    private InternalContextManager`1<ScenarioContext> scenarioContextManager;
    private InternalContextManager`1<FeatureContext> featureContextManager;
    private StackedInternalContextManager`1<ScenarioStepContext> stepContextManager;
    private IContainerBuilder containerBuilder;
    [CompilerGeneratedAttribute]
private Nullable`1<StepDefinitionType> <CurrentTopLevelStepDefinitionType>k__BackingField;
    [CompilerGeneratedAttribute]
private TestThreadContext <TestThreadContext>k__BackingField;
    public Nullable`1<StepDefinitionType> CurrentTopLevelStepDefinitionType { get; private set; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public ScenarioStepContext StepContext { get; }
    public TestThreadContext TestThreadContext { get; private set; }
    public ContextManager(ITestTracer testTracer, IObjectContainer testThreadContainer, IContainerBuilder containerBuilder);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<StepDefinitionType> get_CurrentTopLevelStepDefinitionType();
    [CompilerGeneratedAttribute]
private void set_CurrentTopLevelStepDefinitionType(Nullable`1<StepDefinitionType> value);
    public sealed virtual FeatureContext get_FeatureContext();
    public sealed virtual ScenarioContext get_ScenarioContext();
    public sealed virtual ScenarioStepContext get_StepContext();
    [CompilerGeneratedAttribute]
public sealed virtual TestThreadContext get_TestThreadContext();
    [CompilerGeneratedAttribute]
private void set_TestThreadContext(TestThreadContext value);
    private void InitializeTestThreadContext();
    public sealed virtual void InitializeFeatureContext(FeatureInfo featureInfo);
    public sealed virtual void CleanupFeatureContext();
    public sealed virtual void InitializeScenarioContext(ScenarioInfo scenarioInfo);
    private void ResetCurrentStepStack();
    public sealed virtual void CleanupScenarioContext();
    public sealed virtual void InitializeStepContext(StepInfo stepInfo);
    public sealed virtual void CleanupStepContext();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.Infrastructure.ContextManagerExtensions : object {
    [ExtensionAttribute]
public static StepContext GetStepContext(IContextManager contextManager);
}
public class TechTalk.SpecFlow.Infrastructure.DefaultDependencyProvider : object {
    public virtual void RegisterGlobalContainerDefaults(ObjectContainer container);
    public virtual void RegisterTestThreadContainerDefaults(ObjectContainer testThreadContainer);
    public sealed virtual void RegisterScenarioContainerDefaults(ObjectContainer scenarioContainer);
}
[AttributeUsageAttribute("1")]
public class TechTalk.SpecFlow.Infrastructure.GeneratorPluginAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <PluginType>k__BackingField;
    public Type PluginType { get; }
    public GeneratorPluginAttribute(Type pluginType);
    [CompilerGeneratedAttribute]
public Type get_PluginType();
}
public interface TechTalk.SpecFlow.Infrastructure.IBindingAssemblyLoader {
    public abstract virtual Assembly Load(string assemblyName);
}
public interface TechTalk.SpecFlow.Infrastructure.IContainerBuilder {
    public abstract virtual IObjectContainer CreateGlobalContainer(Assembly testAssembly, IRuntimeConfigurationProvider configurationProvider);
    public abstract virtual IObjectContainer CreateTestThreadContainer(IObjectContainer globalContainer);
    public abstract virtual IObjectContainer CreateScenarioContainer(IObjectContainer testThreadContainer, ScenarioInfo scenarioInfo);
    public abstract virtual IObjectContainer CreateFeatureContainer(IObjectContainer testThreadContainer, FeatureInfo featureInfo);
}
public interface TechTalk.SpecFlow.Infrastructure.IContainerDependentObject {
    public abstract virtual void SetObjectContainer(IObjectContainer container);
}
public interface TechTalk.SpecFlow.Infrastructure.IContextManager {
    public TestThreadContext TestThreadContext { get; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public ScenarioStepContext StepContext { get; }
    public Nullable`1<StepDefinitionType> CurrentTopLevelStepDefinitionType { get; }
    public abstract virtual TestThreadContext get_TestThreadContext();
    public abstract virtual FeatureContext get_FeatureContext();
    public abstract virtual ScenarioContext get_ScenarioContext();
    public abstract virtual ScenarioStepContext get_StepContext();
    public abstract virtual Nullable`1<StepDefinitionType> get_CurrentTopLevelStepDefinitionType();
    public abstract virtual void InitializeFeatureContext(FeatureInfo featureInfo);
    public abstract virtual void CleanupFeatureContext();
    public abstract virtual void InitializeScenarioContext(ScenarioInfo scenarioInfo);
    public abstract virtual void CleanupScenarioContext();
    public abstract virtual void InitializeStepContext(StepInfo stepInfo);
    public abstract virtual void CleanupStepContext();
}
public interface TechTalk.SpecFlow.Infrastructure.IDefaultDependencyProvider {
    public abstract virtual void RegisterGlobalContainerDefaults(ObjectContainer container);
    public abstract virtual void RegisterTestThreadContainerDefaults(ObjectContainer testThreadContainer);
    public abstract virtual void RegisterScenarioContainerDefaults(ObjectContainer scenarioContainer);
}
public interface TechTalk.SpecFlow.Infrastructure.IObsoleteStepHandler {
    public abstract virtual void Handle(BindingMatch bindingMatch);
}
public interface TechTalk.SpecFlow.Infrastructure.ISkippedStepHandler {
    public abstract virtual void Handle(ScenarioContext scenarioContext);
}
public interface TechTalk.SpecFlow.Infrastructure.ISpecFlowAttachmentHandler {
    public abstract virtual void AddAttachment(string filePath);
}
public interface TechTalk.SpecFlow.Infrastructure.IStepDefinitionMatchService {
    public bool Ready { get; }
    public abstract virtual bool get_Ready();
    public abstract virtual BindingMatch GetBestMatch(StepInstance stepInstance, CultureInfo bindingCulture, StepDefinitionAmbiguityReason& ambiguityReason, List`1& candidatingMatches);
    public abstract virtual BindingMatch Match(IStepDefinitionBinding stepDefinitionBinding, StepInstance stepInstance, CultureInfo bindingCulture, bool useRegexMatching, bool useParamMatching, bool useScopeMatching);
}
public interface TechTalk.SpecFlow.Infrastructure.ITestAssemblyProvider {
    public Assembly TestAssembly { get; }
    public abstract virtual Assembly get_TestAssembly();
    public abstract virtual void RegisterTestAssembly(Assembly testAssembly);
}
public interface TechTalk.SpecFlow.Infrastructure.ITestExecutionEngine {
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public abstract virtual FeatureContext get_FeatureContext();
    public abstract virtual ScenarioContext get_ScenarioContext();
    public abstract virtual Task OnTestRunStartAsync();
    public abstract virtual Task OnTestRunEndAsync();
    public abstract virtual Task OnFeatureStartAsync(FeatureInfo featureInfo);
    public abstract virtual Task OnFeatureEndAsync();
    public abstract virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    public abstract virtual Task OnScenarioStartAsync();
    public abstract virtual Task OnAfterLastStepAsync();
    public abstract virtual Task OnScenarioEndAsync();
    public abstract virtual void OnScenarioSkipped();
    public abstract virtual Task StepAsync(StepDefinitionKeyword stepDefinitionKeyword, string keyword, string text, string multilineTextArg, Table tableArg);
    public abstract virtual void Pending();
}
public interface TechTalk.SpecFlow.Infrastructure.ITestObjectResolver {
    public abstract virtual object ResolveBindingInstance(Type bindingType, IObjectContainer container);
}
public interface TechTalk.SpecFlow.Infrastructure.ITestPendingMessageFactory {
    public abstract virtual string BuildFromScenarioContext(ScenarioContext scenarioContext);
}
public interface TechTalk.SpecFlow.Infrastructure.ITestRunnerFactory {
    public abstract virtual ITestRunner Create(Assembly testAssembly);
}
public interface TechTalk.SpecFlow.Infrastructure.ITestUndefinedMessageFactory {
    public abstract virtual string BuildFromContext(ScenarioContext scenarioContext, FeatureContext featureContext);
}
public class TechTalk.SpecFlow.Infrastructure.ObsoleteStepHandler : object {
    private IErrorProvider errorProvider;
    private ITestTracer testTracer;
    protected SpecFlowConfiguration specFlowConfiguration;
    public ObsoleteStepHandler(IErrorProvider errorProvider, ITestTracer testTracer, SpecFlowConfiguration specFlowConfiguration);
    public sealed virtual void Handle(BindingMatch bindingMatch);
}
public class TechTalk.SpecFlow.Infrastructure.SpecFlowAttachmentHandler : object {
    private ITraceListener _traceListener;
    protected SpecFlowAttachmentHandler(ITraceListener traceListener);
    public virtual void AddAttachment(string filePath);
}
public class TechTalk.SpecFlow.Infrastructure.SpecFlowOutputHelper : object {
    private ITestThreadExecutionEventPublisher _testThreadExecutionEventPublisher;
    private ITraceListener _traceListener;
    private ISpecFlowAttachmentHandler _specFlowAttachmentHandler;
    public SpecFlowOutputHelper(ITestThreadExecutionEventPublisher testThreadExecutionEventPublisher, ITraceListener traceListener, ISpecFlowAttachmentHandler specFlowAttachmentHandler);
    public sealed virtual void WriteLine(string message);
    public sealed virtual void WriteLine(string format, Object[] args);
    public sealed virtual void AddAttachment(string filePath);
}
public enum TechTalk.SpecFlow.Infrastructure.StepDefinitionAmbiguityReason : Enum {
    public int value__;
    public static StepDefinitionAmbiguityReason None;
    public static StepDefinitionAmbiguityReason AmbiguousSteps;
    public static StepDefinitionAmbiguityReason AmbiguousScopes;
    public static StepDefinitionAmbiguityReason ParameterErrors;
}
public class TechTalk.SpecFlow.Infrastructure.StepDefinitionMatchService : object {
    private IBindingRegistry _bindingRegistry;
    private IStepArgumentTypeConverter _stepArgumentTypeConverter;
    private IErrorProvider _errorProvider;
    public bool Ready { get; }
    public StepDefinitionMatchService(IBindingRegistry bindingRegistry, IStepArgumentTypeConverter stepArgumentTypeConverter, IErrorProvider errorProvider);
    private Object[] CalculateArguments(Match match, StepInstance stepInstance);
    private bool CanConvertArg(object value, IBindingType typeToConvertTo, CultureInfo bindingCulture);
    public sealed virtual bool get_Ready();
    public sealed virtual BindingMatch Match(IStepDefinitionBinding stepDefinitionBinding, StepInstance stepInstance, CultureInfo bindingCulture, bool useRegexMatching, bool useParamMatching, bool useScopeMatching);
    public sealed virtual BindingMatch GetBestMatch(StepInstance stepInstance, CultureInfo bindingCulture, StepDefinitionAmbiguityReason& ambiguityReason, List`1& candidatingMatches);
    protected virtual IEnumerable`1<BindingMatch> GetCandidatingBindingsForBestMatch(StepInstance stepInstance, CultureInfo bindingCulture);
    private static void KeepMaxScopeMatches(List`1<BindingMatch> matches);
    protected virtual StepDefinitionAmbiguityReason OnNoMatch(StepInstance stepInstance, CultureInfo bindingCulture, List`1& matches);
    protected IEnumerable`1<BindingMatch> GetCandidatingBindings(StepInstance stepInstance, CultureInfo bindingCulture, bool useRegexMatching, bool useParamMatching, bool useScopeMatching);
}
public class TechTalk.SpecFlow.Infrastructure.TestAssemblyProvider : object {
    [CompilerGeneratedAttribute]
private Assembly <TestAssembly>k__BackingField;
    public Assembly TestAssembly { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Assembly get_TestAssembly();
    [CompilerGeneratedAttribute]
private void set_TestAssembly(Assembly value);
    public sealed virtual void RegisterTestAssembly(Assembly testAssembly);
}
public class TechTalk.SpecFlow.Infrastructure.TestExecutionEngine : object {
    private IAsyncBindingInvoker _bindingInvoker;
    private IBindingRegistry _bindingRegistry;
    private IContextManager _contextManager;
    private IErrorProvider _errorProvider;
    private IObsoleteStepHandler _obsoleteStepHandler;
    private SpecFlowConfiguration _specFlowConfiguration;
    private IStepArgumentTypeConverter _stepArgumentTypeConverter;
    private IStepDefinitionMatchService _stepDefinitionMatchService;
    private IStepFormatter _stepFormatter;
    private ITestObjectResolver _testObjectResolver;
    private ITestTracer _testTracer;
    private IUnitTestRuntimeProvider _unitTestRuntimeProvider;
    private IAnalyticsEventProvider _analyticsEventProvider;
    private IAnalyticsTransmitter _analyticsTransmitter;
    private ITestRunnerManager _testRunnerManager;
    private IRuntimePluginTestExecutionLifecycleEventEmitter _runtimePluginTestExecutionLifecycleEventEmitter;
    private ITestThreadExecutionEventPublisher _testThreadExecutionEventPublisher;
    private ITestPendingMessageFactory _testPendingMessageFactory;
    private ITestUndefinedMessageFactory _testUndefinedMessageFactory;
    private object _testRunnerEndExecutedLock;
    private bool _testRunnerEndExecuted;
    private bool _testRunnerStartExecuted;
    [CompilerGeneratedAttribute]
private IObjectContainer <TestThreadContainer>k__BackingField;
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    protected IObjectContainer TestThreadContainer { get; }
    public TestExecutionEngine(IStepFormatter stepFormatter, ITestTracer testTracer, IErrorProvider errorProvider, IStepArgumentTypeConverter stepArgumentTypeConverter, SpecFlowConfiguration specFlowConfiguration, IBindingRegistry bindingRegistry, IUnitTestRuntimeProvider unitTestRuntimeProvider, IContextManager contextManager, IStepDefinitionMatchService stepDefinitionMatchService, IAsyncBindingInvoker bindingInvoker, IObsoleteStepHandler obsoleteStepHandler, IAnalyticsEventProvider analyticsEventProvider, IAnalyticsTransmitter analyticsTransmitter, ITestRunnerManager testRunnerManager, IRuntimePluginTestExecutionLifecycleEventEmitter runtimePluginTestExecutionLifecycleEventEmitter, ITestThreadExecutionEventPublisher testThreadExecutionEventPublisher, ITestPendingMessageFactory testPendingMessageFactory, ITestUndefinedMessageFactory testUndefinedMessageFactory, ITestObjectResolver testObjectResolver, IObjectContainer testThreadContainer);
    public sealed virtual FeatureContext get_FeatureContext();
    public sealed virtual ScenarioContext get_ScenarioContext();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnTestRunStartAsync>d__27")]
public virtual Task OnTestRunStartAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnTestRunEndAsync>d__28")]
public virtual Task OnTestRunEndAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnFeatureStartAsync>d__29")]
public virtual Task OnFeatureStartAsync(FeatureInfo featureInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnFeatureEndAsync>d__30")]
public virtual Task OnFeatureEndAsync();
    public virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnScenarioStartAsync>d__32")]
public virtual Task OnScenarioStartAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnAfterLastStepAsync>d__33")]
public virtual Task OnAfterLastStepAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnScenarioEndAsync>d__34")]
public virtual Task OnScenarioEndAsync();
    public virtual void OnScenarioSkipped();
    public virtual void Pending();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnBlockStartAsync>d__37")]
protected virtual Task OnBlockStartAsync(ScenarioBlock block);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnBlockEndAsync>d__38")]
protected virtual Task OnBlockEndAsync(ScenarioBlock block);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnStepStartAsync>d__39")]
protected virtual Task OnStepStartAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<OnStepEndAsync>d__40")]
protected virtual Task OnStepEndAsync();
    protected virtual void OnSkipStep();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<FireScenarioEventsAsync>d__42")]
protected virtual Task FireScenarioEventsAsync(HookType bindingEvent);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<FireEventsAsync>d__43")]
private Task FireEventsAsync(HookType hookType);
    private void FireRuntimePluginTestExecutionLifecycleEvents(HookType hookType);
    [CompilerGeneratedAttribute]
protected IObjectContainer get_TestThreadContainer();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<InvokeHookAsync>d__48")]
public virtual Task InvokeHookAsync(IAsyncBindingInvoker invoker, IHookBinding hookBinding, HookType hookType);
    private IObjectContainer GetHookContainer(HookType hookType);
    private SpecFlowContext GetHookContext(HookType hookType);
    private void SetHookError(HookType hookType, Exception hookException);
    private Object[] ResolveArguments(IHookBinding hookBinding, IObjectContainer currentContainer);
    private object ResolveArgument(IObjectContainer container, IBindingParameter parameter);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<ExecuteStepAsync>d__54")]
private Task ExecuteStepAsync(IContextManager contextManager, StepInstance stepInstance);
    private void UpdateStatusOnStepFailure(ScenarioExecutionStatus stepStatus, Exception exception);
    protected virtual BindingMatch GetStepMatch(StepInstance stepInstance);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<ExecuteStepMatchAsync>d__57")]
protected virtual Task ExecuteStepMatchAsync(BindingMatch match, Object[] arguments, DurationHolder durationHolder);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<HandleBlockSwitchAsync>d__58")]
private Task HandleBlockSwitchAsync(ScenarioBlock block);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<GetExecuteArgumentsAsync>d__59")]
private Task`1<Object[]> GetExecuteArgumentsAsync(BindingMatch match);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<ConvertArg>d__60")]
private Task`1<object> ConvertArg(object value, IBindingType typeToConvertTo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.Infrastructure.TestExecutionEngine/<StepAsync>d__61")]
public virtual Task StepAsync(StepDefinitionKeyword stepDefinitionKeyword, string keyword, string text, string multilineTextArg, Table tableArg);
    private StepDefinitionType GetCurrentBindingType();
}
public class TechTalk.SpecFlow.Infrastructure.TestObjectResolver : object {
    public sealed virtual object ResolveBindingInstance(Type bindingType, IObjectContainer container);
}
public class TechTalk.SpecFlow.Infrastructure.TestPendingMessageFactory : object {
    private IErrorProvider _errorProvider;
    public TestPendingMessageFactory(IErrorProvider errorProvider);
    public sealed virtual string BuildFromScenarioContext(ScenarioContext scenarioContext);
}
public class TechTalk.SpecFlow.Infrastructure.TestUndefinedMessageFactory : object {
    private IStepDefinitionSkeletonProvider _stepDefinitionSkeletonProvider;
    private IErrorProvider _errorProvider;
    private SpecFlowConfiguration _specFlowConfiguration;
    public TestUndefinedMessageFactory(IStepDefinitionSkeletonProvider stepDefinitionSkeletonProvider, IErrorProvider errorProvider, SpecFlowConfiguration specFlowConfiguration);
    public sealed virtual string BuildFromContext(ScenarioContext scenarioContext, FeatureContext featureContext);
}
public interface TechTalk.SpecFlow.IScenarioContext {
    public ScenarioInfo ScenarioInfo { get; }
    public ScenarioBlock CurrentScenarioBlock { get; }
    public IObjectContainer ScenarioContainer { get; }
    public ScenarioExecutionStatus ScenarioExecutionStatus { get; }
    public abstract virtual ScenarioInfo get_ScenarioInfo();
    public abstract virtual ScenarioBlock get_CurrentScenarioBlock();
    public abstract virtual IObjectContainer get_ScenarioContainer();
    public abstract virtual ScenarioExecutionStatus get_ScenarioExecutionStatus();
}
public interface TechTalk.SpecFlow.IScenarioStepContext {
    public StepInfo StepInfo { get; }
    public ScenarioExecutionStatus Status { get; public set; }
    public abstract virtual StepInfo get_StepInfo();
    public abstract virtual ScenarioExecutionStatus get_Status();
    public abstract virtual void set_Status(ScenarioExecutionStatus value);
}
public interface TechTalk.SpecFlow.ISpecFlowContext {
    public Exception TestError { get; }
    public abstract virtual Exception get_TestError();
}
public interface TechTalk.SpecFlow.ISpecFlowOutputHelper {
    public abstract virtual void WriteLine(string message);
    public abstract virtual void WriteLine(string format, Object[] args);
    public abstract virtual void AddAttachment(string filePath);
}
public interface TechTalk.SpecFlow.ISyncTestRunner {
    public string TestWorkerId { get; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public abstract virtual string get_TestWorkerId();
    public abstract virtual FeatureContext get_FeatureContext();
    public abstract virtual ScenarioContext get_ScenarioContext();
    public abstract virtual void OnTestRunStart();
    public abstract virtual void OnTestRunEnd();
    public abstract virtual void OnFeatureStart(FeatureInfo featureInfo);
    public abstract virtual void OnFeatureEnd();
    public abstract virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    public abstract virtual void OnScenarioStart();
    public abstract virtual void CollectScenarioErrors();
    public abstract virtual void OnScenarioEnd();
    public abstract virtual void SkipScenario();
    public abstract virtual void Given(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void When(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void Then(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void And(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void But(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void Pending();
}
public interface TechTalk.SpecFlow.ITestRunner {
    public string TestWorkerId { get; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public abstract virtual string get_TestWorkerId();
    public abstract virtual FeatureContext get_FeatureContext();
    public abstract virtual ScenarioContext get_ScenarioContext();
    public abstract virtual void InitializeTestRunner(string testWorkerId);
    public abstract virtual Task OnTestRunStartAsync();
    public abstract virtual Task OnTestRunEndAsync();
    public abstract virtual Task OnFeatureStartAsync(FeatureInfo featureInfo);
    public abstract virtual Task OnFeatureEndAsync();
    public abstract virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    public abstract virtual Task OnScenarioStartAsync();
    public abstract virtual Task CollectScenarioErrorsAsync();
    public abstract virtual Task OnScenarioEndAsync();
    public abstract virtual void SkipScenario();
    public abstract virtual Task GivenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual Task WhenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual Task ThenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual Task AndAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual Task ButAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public abstract virtual void Pending();
}
public interface TechTalk.SpecFlow.ITestRunnerManager {
    public Assembly TestAssembly { get; }
    public Assembly[] BindingAssemblies { get; }
    public bool IsMultiThreaded { get; }
    public abstract virtual Assembly get_TestAssembly();
    public abstract virtual Assembly[] get_BindingAssemblies();
    public abstract virtual bool get_IsMultiThreaded();
    public abstract virtual ITestRunner GetTestRunner(string workerId);
    public abstract virtual void Initialize(Assembly testAssembly);
    public abstract virtual Task FireTestRunEndAsync();
    public abstract virtual Task FireTestRunStartAsync();
    public abstract virtual Task DisposeAsync();
}
public interface TechTalk.SpecFlow.ITestThreadContext {
    public IObjectContainer TestThreadContainer { get; }
    public abstract virtual IObjectContainer get_TestThreadContainer();
}
public class TechTalk.SpecFlow.MissingStepDefinitionException : SpecFlowException {
    protected MissingStepDefinitionException(SerializationInfo info, StreamingContext context);
}
public class TechTalk.SpecFlow.Parser.SpecFlowGherkinDialectProvider : GherkinDialectProvider {
    public SpecFlowGherkinDialectProvider(string defaultLanguage);
    public virtual GherkinDialect GetDialect(string language, Location location);
}
public class TechTalk.SpecFlow.PendingStepException : SpecFlowException {
    public PendingStepException(string message);
    protected PendingStepException(SerializationInfo info, StreamingContext context);
}
public class TechTalk.SpecFlow.Plugins.ConfigurationDefaultsEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SpecFlowConfiguration <SpecFlowConfiguration>k__BackingField;
    public SpecFlowConfiguration SpecFlowConfiguration { get; private set; }
    public ConfigurationDefaultsEventArgs(SpecFlowConfiguration specFlowConfiguration);
    [CompilerGeneratedAttribute]
public SpecFlowConfiguration get_SpecFlowConfiguration();
    [CompilerGeneratedAttribute]
private void set_SpecFlowConfiguration(SpecFlowConfiguration value);
}
public class TechTalk.SpecFlow.Plugins.CustomizeFeatureDependenciesEventArgs : ObjectContainerEventArgs {
    public CustomizeFeatureDependenciesEventArgs(ObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.CustomizeGlobalDependenciesEventArgs : ObjectContainerEventArgs {
    [CompilerGeneratedAttribute]
private SpecFlowConfiguration <SpecFlowConfiguration>k__BackingField;
    public SpecFlowConfiguration SpecFlowConfiguration { get; private set; }
    public CustomizeGlobalDependenciesEventArgs(ObjectContainer objectContainer, SpecFlowConfiguration specFlowConfiguration);
    [CompilerGeneratedAttribute]
public SpecFlowConfiguration get_SpecFlowConfiguration();
    [CompilerGeneratedAttribute]
private void set_SpecFlowConfiguration(SpecFlowConfiguration value);
}
public class TechTalk.SpecFlow.Plugins.CustomizeScenarioDependenciesEventArgs : ObjectContainerEventArgs {
    public CustomizeScenarioDependenciesEventArgs(ObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.CustomizeTestThreadDependenciesEventArgs : ObjectContainerEventArgs {
    public CustomizeTestThreadDependenciesEventArgs(ObjectContainer objectContainer);
}
public interface TechTalk.SpecFlow.Plugins.IRuntimePlugin {
    public abstract virtual void Initialize(RuntimePluginEvents runtimePluginEvents, RuntimePluginParameters runtimePluginParameters, UnitTestProviderConfiguration unitTestProviderConfiguration);
}
public interface TechTalk.SpecFlow.Plugins.IRuntimePluginLoader {
    public abstract virtual IRuntimePlugin LoadPlugin(string pluginAssemblyName, ITraceListener traceListener, bool traceMissingPluginAttribute);
}
public interface TechTalk.SpecFlow.Plugins.IRuntimePluginLocationMerger {
    public abstract virtual IReadOnlyList`1<string> Merge(IReadOnlyList`1<string> pluginPaths);
}
public interface TechTalk.SpecFlow.Plugins.IRuntimePluginLocator {
    public abstract virtual IReadOnlyList`1<string> GetAllRuntimePlugins();
}
public interface TechTalk.SpecFlow.Plugins.IRuntimePluginTestExecutionLifecycleEventEmitter {
    public abstract virtual void RaiseExecutionLifecycleEvent(HookType hookType, IObjectContainer container);
}
public interface TechTalk.SpecFlow.Plugins.ISpecFlowPath {
    public abstract virtual string GetPathToSpecFlowDll();
}
public abstract class TechTalk.SpecFlow.Plugins.ObjectContainerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ObjectContainer <ObjectContainer>k__BackingField;
    public ObjectContainer ObjectContainer { get; private set; }
    protected ObjectContainerEventArgs(ObjectContainer objectContainer);
    [CompilerGeneratedAttribute]
public ObjectContainer get_ObjectContainer();
    [CompilerGeneratedAttribute]
private void set_ObjectContainer(ObjectContainer value);
}
public class TechTalk.SpecFlow.Plugins.PluginDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private PluginType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string Name { get; private set; }
    public string Path { get; private set; }
    public PluginType Type { get; private set; }
    public string Parameters { get; private set; }
    public PluginDescriptor(string name, string path, PluginType type, string parameters);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public PluginType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(PluginType value);
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(string value);
}
[FlagsAttribute]
public enum TechTalk.SpecFlow.Plugins.PluginType : Enum {
    public int value__;
    public static PluginType Generator;
    public static PluginType Runtime;
    public static PluginType GeneratorAndRuntime;
}
public class TechTalk.SpecFlow.Plugins.RegisterGlobalDependenciesEventArgs : ObjectContainerEventArgs {
    public RegisterGlobalDependenciesEventArgs(ObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginAfterFeatureEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginAfterFeatureEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginAfterScenarioEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginAfterScenarioEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginAfterStepEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginAfterStepEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginAfterTestRunEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginAfterTestRunEventArgs(IObjectContainer objectContainer);
}
[AttributeUsageAttribute("1")]
public class TechTalk.SpecFlow.Plugins.RuntimePluginAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <PluginType>k__BackingField;
    public Type PluginType { get; }
    public RuntimePluginAttribute(Type pluginType);
    [CompilerGeneratedAttribute]
public Type get_PluginType();
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginBeforeFeatureEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginBeforeFeatureEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginBeforeScenarioEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginBeforeScenarioEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginBeforeStepEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginBeforeStepEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginBeforeTestRunEventArgs : RuntimePluginTestExecutionLifecycleEventArgs {
    public RuntimePluginBeforeTestRunEventArgs(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<RegisterGlobalDependenciesEventArgs> RegisterGlobalDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomizeGlobalDependenciesEventArgs> CustomizeGlobalDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConfigurationDefaultsEventArgs> ConfigurationDefaults;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomizeTestThreadDependenciesEventArgs> CustomizeTestThreadDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomizeFeatureDependenciesEventArgs> CustomizeFeatureDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomizeScenarioDependenciesEventArgs> CustomizeScenarioDependencies;
    [CompilerGeneratedAttribute]
public void add_RegisterGlobalDependencies(EventHandler`1<RegisterGlobalDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RegisterGlobalDependencies(EventHandler`1<RegisterGlobalDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomizeGlobalDependencies(EventHandler`1<CustomizeGlobalDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomizeGlobalDependencies(EventHandler`1<CustomizeGlobalDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ConfigurationDefaults(EventHandler`1<ConfigurationDefaultsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConfigurationDefaults(EventHandler`1<ConfigurationDefaultsEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomizeTestThreadDependencies(EventHandler`1<CustomizeTestThreadDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomizeTestThreadDependencies(EventHandler`1<CustomizeTestThreadDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomizeFeatureDependencies(EventHandler`1<CustomizeFeatureDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomizeFeatureDependencies(EventHandler`1<CustomizeFeatureDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomizeScenarioDependencies(EventHandler`1<CustomizeScenarioDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomizeScenarioDependencies(EventHandler`1<CustomizeScenarioDependenciesEventArgs> value);
    public void RaiseRegisterGlobalDependencies(ObjectContainer objectContainer);
    public void RaiseConfigurationDefaults(SpecFlowConfiguration specFlowConfiguration);
    public void RaiseCustomizeGlobalDependencies(ObjectContainer container, SpecFlowConfiguration specFlowConfiguration);
    public void RaiseCustomizeTestThreadDependencies(ObjectContainer testThreadContainer);
    public void RaiseCustomizeFeatureDependencies(ObjectContainer featureContainer);
    public void RaiseCustomizeScenarioDependencies(ObjectContainer scenarioContainer);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginLoader : object {
    public sealed virtual IRuntimePlugin LoadPlugin(string pluginAssemblyName, ITraceListener traceListener, bool traceMissingPluginAttribute);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginLocationMerger : object {
    public sealed virtual IReadOnlyList`1<string> Merge(IReadOnlyList`1<string> pluginPaths);
    private static List`1<string> CopyUntilIndex(IReadOnlyList`1<string> pluginPaths, int index);
}
internal class TechTalk.SpecFlow.Plugins.RuntimePluginLocator : object {
    private IRuntimePluginLocationMerger _runtimePluginLocationMerger;
    private ISpecFlowPath _specFlowPath;
    private Assembly _testAssembly;
    public RuntimePluginLocator(IRuntimePluginLocationMerger runtimePluginLocationMerger, ISpecFlowPath specFlowPath, ITestAssemblyProvider testAssemblyProvider);
    public sealed virtual IReadOnlyList`1<string> GetAllRuntimePlugins();
    private static IEnumerable`1<string> SearchPluginsInFolder(string folder);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginParameters : object {
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(string value);
}
public abstract class TechTalk.SpecFlow.Plugins.RuntimePluginTestExecutionLifecycleEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IObjectContainer <ObjectContainer>k__BackingField;
    public IObjectContainer ObjectContainer { get; private set; }
    protected RuntimePluginTestExecutionLifecycleEventArgs(IObjectContainer objectContainer);
    [CompilerGeneratedAttribute]
public IObjectContainer get_ObjectContainer();
    [CompilerGeneratedAttribute]
private void set_ObjectContainer(IObjectContainer value);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginTestExecutionLifecycleEventEmitter : object {
    private RuntimePluginTestExecutionLifecycleEvents _events;
    public RuntimePluginTestExecutionLifecycleEventEmitter(RuntimePluginTestExecutionLifecycleEvents events);
    public sealed virtual void RaiseExecutionLifecycleEvent(HookType hookType, IObjectContainer container);
}
public class TechTalk.SpecFlow.Plugins.RuntimePluginTestExecutionLifecycleEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginBeforeTestRunEventArgs> BeforeTestRun;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginAfterTestRunEventArgs> AfterTestRun;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginBeforeFeatureEventArgs> BeforeFeature;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginAfterFeatureEventArgs> AfterFeature;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginBeforeScenarioEventArgs> BeforeScenario;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginAfterScenarioEventArgs> AfterScenario;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginBeforeStepEventArgs> BeforeStep;
    [CompilerGeneratedAttribute]
private EventHandler`1<RuntimePluginAfterStepEventArgs> AfterStep;
    [CompilerGeneratedAttribute]
public void add_BeforeTestRun(EventHandler`1<RuntimePluginBeforeTestRunEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeTestRun(EventHandler`1<RuntimePluginBeforeTestRunEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterTestRun(EventHandler`1<RuntimePluginAfterTestRunEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterTestRun(EventHandler`1<RuntimePluginAfterTestRunEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BeforeFeature(EventHandler`1<RuntimePluginBeforeFeatureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeFeature(EventHandler`1<RuntimePluginBeforeFeatureEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterFeature(EventHandler`1<RuntimePluginAfterFeatureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterFeature(EventHandler`1<RuntimePluginAfterFeatureEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BeforeScenario(EventHandler`1<RuntimePluginBeforeScenarioEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeScenario(EventHandler`1<RuntimePluginBeforeScenarioEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterScenario(EventHandler`1<RuntimePluginAfterScenarioEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterScenario(EventHandler`1<RuntimePluginAfterScenarioEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BeforeStep(EventHandler`1<RuntimePluginBeforeStepEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeStep(EventHandler`1<RuntimePluginBeforeStepEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterStep(EventHandler`1<RuntimePluginAfterStepEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterStep(EventHandler`1<RuntimePluginAfterStepEventArgs> value);
    public void RaiseBeforeTestRun(IObjectContainer objectContainer);
    public void RaiseAfterTestRun(IObjectContainer objectContainer);
    public void RaiseBeforeFeature(IObjectContainer objectContainer);
    public void RaiseAfterFeature(IObjectContainer objectContainer);
    public void RaiseBeforeScenario(IObjectContainer objectContainer);
    public void RaiseAfterScenario(IObjectContainer objectContainer);
    public void RaiseBeforeStep(IObjectContainer objectContainer);
    public void RaiseAfterStep(IObjectContainer objectContainer);
}
public class TechTalk.SpecFlow.Plugins.SpecFlowPath : object {
    public sealed virtual string GetPathToSpecFlowDll();
}
public enum TechTalk.SpecFlow.ProgrammingLanguage : Enum {
    public int value__;
    public static ProgrammingLanguage Other;
    public static ProgrammingLanguage CSharp;
    public static ProgrammingLanguage VB;
    public static ProgrammingLanguage FSharp;
}
public enum TechTalk.SpecFlow.ScenarioBlock : Enum {
    public int value__;
    public static ScenarioBlock None;
    public static ScenarioBlock Given;
    public static ScenarioBlock When;
    public static ScenarioBlock Then;
}
public class TechTalk.SpecFlow.ScenarioContext : SpecFlowContext {
    private static bool isCurrentDisabled;
    private static ScenarioContext current;
    [CompilerGeneratedAttribute]
private ScenarioInfo <ScenarioInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ScenarioBlock <CurrentScenarioBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectContainer <ScenarioContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ScenarioExecutionStatus <ScenarioExecutionStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PendingSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<StepInstance> <MissingSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    private ITestObjectResolver testObjectResolver;
    [ObsoleteAttribute("Please get the ScenarioContext via Context Injection - https://go.specflow.org/Migrate-ScenarioContext-Current")]
public static ScenarioContext Current { get; internal set; }
    public ScenarioInfo ScenarioInfo { get; }
    public ScenarioBlock CurrentScenarioBlock { get; internal set; }
    public IObjectContainer ScenarioContainer { get; }
    public ScenarioExecutionStatus ScenarioExecutionStatus { get; internal set; }
    internal List`1<string> PendingSteps { get; }
    internal List`1<StepInstance> MissingSteps { get; }
    internal Stopwatch Stopwatch { get; }
    public ScenarioStepContext StepContext { get; }
    internal ScenarioContext(IObjectContainer scenarioContainer, ScenarioInfo scenarioInfo, ITestObjectResolver testObjectResolver);
    public static ScenarioContext get_Current();
    internal static void set_Current(ScenarioContext value);
    internal static void DisableSingletonInstance();
    [CompilerGeneratedAttribute]
public sealed virtual ScenarioInfo get_ScenarioInfo();
    [CompilerGeneratedAttribute]
public sealed virtual ScenarioBlock get_CurrentScenarioBlock();
    [CompilerGeneratedAttribute]
internal void set_CurrentScenarioBlock(ScenarioBlock value);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectContainer get_ScenarioContainer();
    [CompilerGeneratedAttribute]
public sealed virtual ScenarioExecutionStatus get_ScenarioExecutionStatus();
    [CompilerGeneratedAttribute]
internal void set_ScenarioExecutionStatus(ScenarioExecutionStatus value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_PendingSteps();
    [CompilerGeneratedAttribute]
internal List`1<StepInstance> get_MissingSteps();
    [CompilerGeneratedAttribute]
internal Stopwatch get_Stopwatch();
    public ScenarioStepContext get_StepContext();
    public void Pending();
    public static void StepIsPending();
    public object GetBindingInstance(Type bindingType);
}
public enum TechTalk.SpecFlow.ScenarioExecutionStatus : Enum {
    public int value__;
    public static ScenarioExecutionStatus OK;
    public static ScenarioExecutionStatus StepDefinitionPending;
    public static ScenarioExecutionStatus UndefinedStep;
    public static ScenarioExecutionStatus BindingError;
    public static ScenarioExecutionStatus TestError;
    public static ScenarioExecutionStatus Skipped;
}
public class TechTalk.SpecFlow.ScenarioInfo : object {
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CombinedTags>k__BackingField;
    [CompilerGeneratedAttribute]
private IOrderedDictionary <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public String[] Tags { get; }
    public String[] CombinedTags { get; private set; }
    [ObsoleteAttribute("Deprecated. Use 'CombinedTags' instead.", "False")]
public String[] ScenarioAndFeatureTags { get; }
    public IOrderedDictionary Arguments { get; }
    public string Title { get; }
    public string Description { get; }
    public ScenarioInfo(string title, string description, String[] tags, IOrderedDictionary arguments, String[] inheritedTags);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public String[] get_CombinedTags();
    [CompilerGeneratedAttribute]
private void set_CombinedTags(String[] value);
    public String[] get_ScenarioAndFeatureTags();
    [CompilerGeneratedAttribute]
public IOrderedDictionary get_Arguments();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_Description();
}
public class TechTalk.SpecFlow.ScenarioStepContext : SpecFlowContext {
    private static bool isCurrentDisabled;
    private static ScenarioStepContext current;
    [CompilerGeneratedAttribute]
private StepInfo <StepInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ScenarioExecutionStatus <Status>k__BackingField;
    public static ScenarioStepContext Current { get; internal set; }
    public StepInfo StepInfo { get; private set; }
    public ScenarioExecutionStatus Status { get; public set; }
    internal ScenarioStepContext(StepInfo stepInfo);
    public static ScenarioStepContext get_Current();
    internal static void set_Current(ScenarioStepContext value);
    internal static void DisableSingletonInstance();
    [CompilerGeneratedAttribute]
public sealed virtual StepInfo get_StepInfo();
    [CompilerGeneratedAttribute]
private void set_StepInfo(StepInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual ScenarioExecutionStatus get_Status();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Status(ScenarioExecutionStatus value);
}
[AttributeUsageAttribute("68")]
public class TechTalk.SpecFlow.ScopeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scenario>k__BackingField;
    public string Tag { get; public set; }
    public string Feature { get; public set; }
    public string Scenario { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
    [CompilerGeneratedAttribute]
public string get_Scenario();
    [CompilerGeneratedAttribute]
public void set_Scenario(string value);
}
public abstract class TechTalk.SpecFlow.SpecFlowContext : Dictionary`2<string, object> {
    [CompilerGeneratedAttribute]
private Exception <TestError>k__BackingField;
    public Exception TestError { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_TestError();
    [CompilerGeneratedAttribute]
internal void set_TestError(Exception value);
    protected virtual void Dispose();
    private sealed virtual override void System.IDisposable.Dispose();
    public bool TryGetValue(TValue& value);
    public bool TryGetValue(string key, TValue& value);
    private string GetDefaultKey();
    public void Set(T data);
    public void Set(T data, string key);
    public void Set(Func`1<T> func);
    public T Get();
    public T Get(string key);
    private static T CallTheFactoryMethodToGetTheValue(object value);
    private static bool TheValueIsAFactoryMethod(object value);
}
public class TechTalk.SpecFlow.SpecFlowException : Exception {
    public SpecFlowException(string message);
    public SpecFlowException(string message, Exception inner);
    protected SpecFlowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class TechTalk.SpecFlow.StepArgumentTransformationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Regex { get; public set; }
    public string Name { get; public set; }
    public StepArgumentTransformationAttribute(string regex);
    [CompilerGeneratedAttribute]
public string get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class TechTalk.SpecFlow.StepDefinitionAttribute : StepDefinitionBaseAttribute {
    public StepDefinitionAttribute(string regex);
    public StepDefinitionAttribute(string regex, string culture);
}
[AttributeUsageAttribute("64")]
public abstract class TechTalk.SpecFlow.StepDefinitionBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private StepDefinitionType[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public StepDefinitionType[] Types { get; }
    public string Regex { get; public set; }
    public string Culture { get; public set; }
    internal StepDefinitionBaseAttribute(string regex, StepDefinitionType type);
    protected StepDefinitionBaseAttribute(string regex, StepDefinitionType[] types);
    [CompilerGeneratedAttribute]
public StepDefinitionType[] get_Types();
    [CompilerGeneratedAttribute]
public string get_Regex();
    [CompilerGeneratedAttribute]
public void set_Regex(string value);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(string value);
}
public class TechTalk.SpecFlow.StepInfo : object {
    [CompilerGeneratedAttribute]
private StepDefinitionType <StepDefinitionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MultilineText>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingMatch <BindingMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private StepInstance <StepInstance>k__BackingField;
    public StepDefinitionType StepDefinitionType { get; private set; }
    public string Text { get; private set; }
    public Table Table { get; private set; }
    public string MultilineText { get; private set; }
    public BindingMatch BindingMatch { get; public set; }
    public StepInstance StepInstance { get; public set; }
    public StepInfo(StepDefinitionType stepDefinitionType, string text, Table table, string multilineText);
    [CompilerGeneratedAttribute]
public StepDefinitionType get_StepDefinitionType();
    [CompilerGeneratedAttribute]
private void set_StepDefinitionType(StepDefinitionType value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public Table get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(Table value);
    [CompilerGeneratedAttribute]
public string get_MultilineText();
    [CompilerGeneratedAttribute]
private void set_MultilineText(string value);
    [CompilerGeneratedAttribute]
public BindingMatch get_BindingMatch();
    [CompilerGeneratedAttribute]
public void set_BindingMatch(BindingMatch value);
    [CompilerGeneratedAttribute]
public StepInstance get_StepInstance();
    [CompilerGeneratedAttribute]
public void set_StepInstance(StepInstance value);
}
public abstract class TechTalk.SpecFlow.Steps : object {
    private IObjectContainer objectContainer;
    protected ITestRunner TestRunner { get; }
    protected ISyncTestRunner SyncTestRunner { get; }
    public ScenarioContext ScenarioContext { get; }
    public FeatureContext FeatureContext { get; }
    public TestThreadContext TestThreadContext { get; }
    public ScenarioStepContext StepContext { get; }
    private sealed virtual override void TechTalk.SpecFlow.Infrastructure.IContainerDependentObject.SetObjectContainer(IObjectContainer container);
    protected ITestRunner get_TestRunner();
    protected ISyncTestRunner get_SyncTestRunner();
    public ScenarioContext get_ScenarioContext();
    public FeatureContext get_FeatureContext();
    public TestThreadContext get_TestThreadContext();
    public ScenarioStepContext get_StepContext();
    protected void AssertInitialized();
}
[ExtensionAttribute]
internal static class TechTalk.SpecFlow.StringExtensions : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
internal static bool IsNotNullOrEmpty(string value);
    [ExtensionAttribute]
internal static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
internal static bool IsNotNullOrWhiteSpace(string value);
    [ExtensionAttribute]
internal static string StripWhitespaces(string value);
}
public class TechTalk.SpecFlow.Table : object {
    internal static string ERROR_NO_CELLS_TO_ADD;
    internal static string ERROR_NO_HEADER_TO_ADD;
    internal static string ERROR_COLUMN_NAME_NOT_FOUND;
    internal static string ERROR_CELLS_NOT_MATCHING_HEADERS;
    private String[] header;
    private TableRows rows;
    public ICollection`1<string> Header { get; }
    public TableRows Rows { get; }
    public int RowCount { get; }
    public Table(String[] header);
    public ICollection`1<string> get_Header();
    public TableRows get_Rows();
    public int get_RowCount();
    public bool ContainsColumn(string column);
    internal int GetHeaderIndex(string column, bool throwIfNotFound);
    public void AddRow(IDictionary`2<string, string> values);
    public void AddRow(String[] cells);
    public void RenameColumn(string oldColumn, string newColumn);
    public virtual string ToString();
    public string ToString(bool headersOnly, bool withNewline);
    private void AddTableRow(StringBuilder builder, IEnumerable`1<string> cells, Int32[] widths);
}
[DefaultMemberAttribute("Item")]
public class TechTalk.SpecFlow.TableRow : object {
    private Table table;
    private String[] items;
    public string Item { get; public set; }
    public string Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    internal TableRow(Table table, String[] items);
    public sealed virtual string get_Item(string header);
    public sealed virtual void set_Item(string header, string value);
    public string get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.TableRow/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private SpecFlowException ThrowTableStructureCannotBeModified();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.String>.Add(string key, string value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.String>.Remove(string key);
    public sealed virtual bool TryGetValue(string key, String& value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
}
[DefaultMemberAttribute("Item")]
public class TechTalk.SpecFlow.TableRows : object {
    private List`1<TableRow> innerList;
    public int Count { get; }
    public TableRow Item { get; }
    public int get_Count();
    public TableRow get_Item(int index);
    public sealed virtual IEnumerator`1<TableRow> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Add(TableRow row);
}
public static class TechTalk.SpecFlow.TagHelper : object {
    public static bool ContainsIgnoreTag(String[] tags);
    public static String[] CombineTags(String[] featureTags, String[] ruleTags);
}
public class TechTalk.SpecFlow.TestFramework.DefaultTestRunContext : object {
    private IEnvironmentWrapper _environmentWrapper;
    public DefaultTestRunContext(IEnvironmentWrapper environmentWrapper);
    public sealed virtual string GetTestDirectory();
}
public interface TechTalk.SpecFlow.TestFramework.ITestRunContext {
    public abstract virtual string GetTestDirectory();
}
public class TechTalk.SpecFlow.TestRunner : object {
    private ITestExecutionEngine _executionEngine;
    [CompilerGeneratedAttribute]
private string <TestWorkerId>k__BackingField;
    public string TestWorkerId { get; private set; }
    public FeatureContext FeatureContext { get; }
    public ScenarioContext ScenarioContext { get; }
    public TestRunner(ITestExecutionEngine executionEngine);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TestWorkerId();
    [CompilerGeneratedAttribute]
private void set_TestWorkerId(string value);
    public sealed virtual FeatureContext get_FeatureContext();
    public sealed virtual ScenarioContext get_ScenarioContext();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnTestRunStartAsync>d__10")]
public sealed virtual Task OnTestRunStartAsync();
    public sealed virtual void InitializeTestRunner(string testWorkerId);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnFeatureStartAsync>d__12")]
public sealed virtual Task OnFeatureStartAsync(FeatureInfo featureInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnFeatureEndAsync>d__13")]
public sealed virtual Task OnFeatureEndAsync();
    public sealed virtual void OnScenarioInitialize(ScenarioInfo scenarioInfo);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnScenarioStartAsync>d__15")]
public sealed virtual Task OnScenarioStartAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<CollectScenarioErrorsAsync>d__16")]
public sealed virtual Task CollectScenarioErrorsAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnScenarioEndAsync>d__17")]
public sealed virtual Task OnScenarioEndAsync();
    public sealed virtual void SkipScenario();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<OnTestRunEndAsync>d__19")]
public sealed virtual Task OnTestRunEndAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<GivenAsync>d__20")]
public sealed virtual Task GivenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<WhenAsync>d__21")]
public sealed virtual Task WhenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<ThenAsync>d__22")]
public sealed virtual Task ThenAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<AndAsync>d__23")]
public sealed virtual Task AndAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunner/<ButAsync>d__24")]
public sealed virtual Task ButAsync(string text, string multilineTextArg, Table tableArg, string keyword);
    public sealed virtual void Pending();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.TestRunnerDefaultArguments : object {
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerDefaultArguments/<GivenAsync>d__0")]
[ExtensionAttribute]
public static Task GivenAsync(ITestRunner testRunner, string text);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerDefaultArguments/<WhenAsync>d__1")]
[ExtensionAttribute]
public static Task WhenAsync(ITestRunner testRunner, string text);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerDefaultArguments/<ThenAsync>d__2")]
[ExtensionAttribute]
public static Task ThenAsync(ITestRunner testRunner, string text);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerDefaultArguments/<AndAsync>d__3")]
[ExtensionAttribute]
public static Task AndAsync(ITestRunner testRunner, string text);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerDefaultArguments/<ButAsync>d__4")]
[ExtensionAttribute]
public static Task ButAsync(ITestRunner testRunner, string text);
}
public class TechTalk.SpecFlow.TestRunnerManager : object {
    public static string TestRunStartWorkerId;
    protected IObjectContainer _globalContainer;
    protected IContainerBuilder _containerBuilder;
    protected SpecFlowConfiguration _specFlowConfiguration;
    protected IRuntimeBindingRegistryBuilder _bindingRegistryBuilder;
    protected ITestTracer _testTracer;
    private ConcurrentDictionary`2<string, ITestRunner> _testRunnerRegistry;
    [CompilerGeneratedAttribute]
private bool <IsTestRunInitialized>k__BackingField;
    private int _wasDisposed;
    private int _wasSingletonInstanceDisabled;
    private object createTestRunnerLockObject;
    [CompilerGeneratedAttribute]
private Assembly <TestAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly[] <BindingAssemblies>k__BackingField;
    private static ConcurrentDictionary`2<Assembly, ITestRunnerManager> _testRunnerManagerRegistry;
    public bool IsTestRunInitialized { get; private set; }
    public Assembly TestAssembly { get; private set; }
    public Assembly[] BindingAssemblies { get; private set; }
    public bool IsMultiThreaded { get; }
    public TestRunnerManager(IObjectContainer globalContainer, IContainerBuilder containerBuilder, SpecFlowConfiguration specFlowConfiguration, IRuntimeBindingRegistryBuilder bindingRegistryBuilder, ITestTracer testTracer);
    private static TestRunnerManager();
    [CompilerGeneratedAttribute]
public bool get_IsTestRunInitialized();
    [CompilerGeneratedAttribute]
private void set_IsTestRunInitialized(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Assembly get_TestAssembly();
    [CompilerGeneratedAttribute]
private void set_TestAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public sealed virtual Assembly[] get_BindingAssemblies();
    [CompilerGeneratedAttribute]
private void set_BindingAssemblies(Assembly[] value);
    public sealed virtual bool get_IsMultiThreaded();
    private int GetWorkerTestRunnerCount();
    public virtual ITestRunner CreateTestRunner(string testWorkerId);
    protected virtual void InitializeBindingRegistry(ITestRunner testRunner);
    protected virtual Assembly[] GetBindingAssemblies();
    protected virtual void BuildBindingRegistry(IEnumerable`1<Assembly> bindingAssemblies);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<OnDomainUnloadAsync>d__30")]
protected internal virtual Task OnDomainUnloadAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<FireTestRunEndAsync>d__31")]
public sealed virtual Task FireTestRunEndAsync();
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<FireTestRunStartAsync>d__32")]
public sealed virtual Task FireTestRunStartAsync();
    protected virtual ITestRunner CreateTestRunnerInstance();
    public sealed virtual void Initialize(Assembly assignedTestAssembly);
    public virtual ITestRunner GetTestRunner(string testWorkerId);
    private ITestRunner GetTestRunnerWithoutExceptionHandling(string testWorkerId);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<DisposeAsync>d__37")]
public virtual Task DisposeAsync();
    public static ITestRunnerManager GetTestRunnerManager(Assembly testAssembly, IContainerBuilder containerBuilder, bool createIfMissing);
    private static Assembly GetCallingAssembly(string callingMethodName);
    private static ITestRunnerManager CreateTestRunnerManager(Assembly testAssembly, IContainerBuilder containerBuilder);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<OnTestRunEndAsync>d__42")]
public static Task OnTestRunEndAsync(Assembly testAssembly, IContainerBuilder containerBuilder);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<OnTestRunStartAsync>d__43")]
public static Task OnTestRunStartAsync(Assembly testAssembly, string testWorkerId, IContainerBuilder containerBuilder);
    public static ITestRunner GetTestRunnerForAssembly(Assembly testAssembly, string testWorkerId, IContainerBuilder containerBuilder);
    [AsyncStateMachineAttribute("TechTalk.SpecFlow.TestRunnerManager/<ResetAsync>d__45")]
internal static Task ResetAsync();
    private static void OnTestRunnerManagerDisposed(TestRunnerManager testRunnerManager);
    [CompilerGeneratedAttribute]
private void <InitializeBindingRegistry>g__DomainUnload|27_0(object sender, EventArgs e);
}
public class TechTalk.SpecFlow.TestThreadContext : SpecFlowContext {
    [CompilerGeneratedAttribute]
private Action`1<TestThreadContext> Disposing;
    [CompilerGeneratedAttribute]
private IObjectContainer <TestThreadContainer>k__BackingField;
    public IObjectContainer TestThreadContainer { get; }
    public TestThreadContext(IObjectContainer testThreadContainer);
    [CompilerGeneratedAttribute]
public void add_Disposing(Action`1<TestThreadContext> value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(Action`1<TestThreadContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual IObjectContainer get_TestThreadContainer();
    protected virtual void Dispose();
}
public class TechTalk.SpecFlow.ThenAttribute : StepDefinitionBaseAttribute {
    public ThenAttribute(string regex);
    public ThenAttribute(string regex, string culture);
}
public interface TechTalk.SpecFlow.Time.IClock {
    public abstract virtual DateTime GetToday();
    public abstract virtual DateTime GetNowDateAndTime();
}
public class TechTalk.SpecFlow.Time.UtcDateTimeClock : object {
    public sealed virtual DateTime GetToday();
    public sealed virtual DateTime GetNowDateAndTime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class TechTalk.SpecFlow.Tracing.AnsiColor.AnsiColor : ValueType {
    private static char EscapeCode;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnsiColor[] <Codes>k__BackingField;
    public static AnsiColor Reset;
    public static AnsiColor Bold;
    public static AnsiColor Italic;
    public static AnsiColor Underline;
    public static AnsiColor Strike;
    public TerminalControlSequences ControlSequence;
    public TerminalControlSequences ResetSequence;
    public Terminal256ColorCodes ColorCode256;
    public TerminalRgbColor RgbColorCode;
    [NullableAttribute("2")]
public AnsiColor[] Codes { get; }
    public AnsiColor(TerminalControlSequences controlSequence);
    public AnsiColor(TerminalControlSequences controlSequence, Terminal256ColorCodes colorCode256);
    public AnsiColor(TerminalControlSequences controlSequence, TerminalRgbColor rgbColor);
    public AnsiColor(AnsiColor[] codes);
    private static AnsiColor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnsiColor[] get_Codes();
    public static AnsiColor Foreground(Terminal256ColorCodes color);
    public static AnsiColor Foreground(TerminalRgbColor color);
    public static AnsiColor Foreground(int r, int g, int b);
    public static AnsiColor Background(Terminal256ColorCodes color);
    public static AnsiColor Background(TerminalRgbColor color);
    public static AnsiColor Background(int r, int g, int b);
    public static AnsiColor Composite(AnsiColor[] codes);
    [NullableContextAttribute("2")]
public static string ColorizeText(string text, AnsiColor code);
    private TerminalControlSequences GetResetSequence(TerminalControlSequences controlSequence);
    public string Colorize(string text);
    public virtual string ToString();
    public string ToResetSequence();
    public void ToString(StringBuilder sb);
    public string ToEscapeSequence();
    public void ToResetSequence(StringBuilder sb);
    public void ToEscapeSequence(StringBuilder sb);
    public void ToEscapeParameters(StringBuilder sb);
}
public class TechTalk.SpecFlow.Tracing.AnsiColor.InvalidColorException : Exception {
    [NullableContextAttribute("2")]
public InvalidColorException(string message);
}
public enum TechTalk.SpecFlow.Tracing.AnsiColor.Terminal256ColorCodes : Enum {
    public int value__;
    public static Terminal256ColorCodes None;
    public static Terminal256ColorCodes BlackC0;
    public static Terminal256ColorCodes MaroonC1;
    public static Terminal256ColorCodes GreenC2;
    public static Terminal256ColorCodes OliveC3;
    public static Terminal256ColorCodes NavyC4;
    public static Terminal256ColorCodes PurpleC5;
    public static Terminal256ColorCodes TealC6;
    public static Terminal256ColorCodes SilverC7;
    public static Terminal256ColorCodes GreyC8;
    public static Terminal256ColorCodes RedC9;
    public static Terminal256ColorCodes LimeC10;
    public static Terminal256ColorCodes YellowC11;
    public static Terminal256ColorCodes BlueC12;
    public static Terminal256ColorCodes FuchsiaC13;
    public static Terminal256ColorCodes AquaC14;
    public static Terminal256ColorCodes WhiteC15;
    public static Terminal256ColorCodes Grey0C16;
    public static Terminal256ColorCodes NavyBlueC17;
    public static Terminal256ColorCodes DarkBlueC18;
    public static Terminal256ColorCodes Blue3C19;
    public static Terminal256ColorCodes Blue3C20;
    public static Terminal256ColorCodes Blue1C21;
    public static Terminal256ColorCodes DarkGreenC22;
    public static Terminal256ColorCodes DeepSkyBlue4C23;
    public static Terminal256ColorCodes DeepSkyBlue4C24;
    public static Terminal256ColorCodes DeepSkyBlue4C25;
    public static Terminal256ColorCodes DodgerBlue3C26;
    public static Terminal256ColorCodes DodgerBlue2C27;
    public static Terminal256ColorCodes Green4C28;
    public static Terminal256ColorCodes SpringGreen4C29;
    public static Terminal256ColorCodes Turquoise4C30;
    public static Terminal256ColorCodes DeepSkyBlue3C31;
    public static Terminal256ColorCodes DeepSkyBlue3C32;
    public static Terminal256ColorCodes DodgerBlue1C33;
    public static Terminal256ColorCodes Green3C34;
    public static Terminal256ColorCodes SpringGreen3C35;
    public static Terminal256ColorCodes DarkCyanC36;
    public static Terminal256ColorCodes LightSeaGreenC37;
    public static Terminal256ColorCodes DeepSkyBlue2C38;
    public static Terminal256ColorCodes DeepSkyBlue1C39;
    public static Terminal256ColorCodes Green3C40;
    public static Terminal256ColorCodes SpringGreen3C41;
    public static Terminal256ColorCodes SpringGreen2C42;
    public static Terminal256ColorCodes Cyan3C43;
    public static Terminal256ColorCodes DarkTurquoiseC44;
    public static Terminal256ColorCodes Turquoise2C45;
    public static Terminal256ColorCodes Green1C46;
    public static Terminal256ColorCodes SpringGreen2C47;
    public static Terminal256ColorCodes SpringGreen1C48;
    public static Terminal256ColorCodes MediumSpringGreenC49;
    public static Terminal256ColorCodes Cyan2C50;
    public static Terminal256ColorCodes Cyan1C51;
    public static Terminal256ColorCodes DarkRedC52;
    public static Terminal256ColorCodes DeepPink4C53;
    public static Terminal256ColorCodes Purple4C54;
    public static Terminal256ColorCodes Purple4C55;
    public static Terminal256ColorCodes Purple3C56;
    public static Terminal256ColorCodes BlueVioletC57;
    public static Terminal256ColorCodes Orange4C58;
    public static Terminal256ColorCodes Grey37C59;
    public static Terminal256ColorCodes MediumPurple4C60;
    public static Terminal256ColorCodes SlateBlue3C61;
    public static Terminal256ColorCodes SlateBlue3C62;
    public static Terminal256ColorCodes RoyalBlue1C63;
    public static Terminal256ColorCodes Chartreuse4C64;
    public static Terminal256ColorCodes DarkSeaGreen4C65;
    public static Terminal256ColorCodes PaleTurquoise4C66;
    public static Terminal256ColorCodes SteelBlueC67;
    public static Terminal256ColorCodes SteelBlue3C68;
    public static Terminal256ColorCodes CornflowerBlueC69;
    public static Terminal256ColorCodes Chartreuse3C70;
    public static Terminal256ColorCodes DarkSeaGreen4C71;
    public static Terminal256ColorCodes CadetBlueC72;
    public static Terminal256ColorCodes CadetBlueC73;
    public static Terminal256ColorCodes SkyBlue3C74;
    public static Terminal256ColorCodes SteelBlue1C75;
    public static Terminal256ColorCodes Chartreuse3C76;
    public static Terminal256ColorCodes PaleGreen3C77;
    public static Terminal256ColorCodes SeaGreen3C78;
    public static Terminal256ColorCodes Aquamarine3C79;
    public static Terminal256ColorCodes MediumTurquoiseC80;
    public static Terminal256ColorCodes SteelBlue1C81;
    public static Terminal256ColorCodes Chartreuse2C82;
    public static Terminal256ColorCodes SeaGreen2C83;
    public static Terminal256ColorCodes SeaGreen1C84;
    public static Terminal256ColorCodes SeaGreen1C85;
    public static Terminal256ColorCodes Aquamarine1C86;
    public static Terminal256ColorCodes DarkSlateGray2C87;
    public static Terminal256ColorCodes DarkRedC88;
    public static Terminal256ColorCodes DeepPink4C89;
    public static Terminal256ColorCodes DarkMagentaC90;
    public static Terminal256ColorCodes DarkMagentaC91;
    public static Terminal256ColorCodes DarkVioletC92;
    public static Terminal256ColorCodes PurpleC93;
    public static Terminal256ColorCodes Orange4C94;
    public static Terminal256ColorCodes LightPink4C95;
    public static Terminal256ColorCodes Plum4C96;
    public static Terminal256ColorCodes MediumPurple3C97;
    public static Terminal256ColorCodes MediumPurple3C98;
    public static Terminal256ColorCodes SlateBlue1C99;
    public static Terminal256ColorCodes Yellow4C100;
    public static Terminal256ColorCodes Wheat4C101;
    public static Terminal256ColorCodes Grey53C102;
    public static Terminal256ColorCodes LightSlateGreyC103;
    public static Terminal256ColorCodes MediumPurpleC104;
    public static Terminal256ColorCodes LightSlateBlueC105;
    public static Terminal256ColorCodes Yellow4C106;
    public static Terminal256ColorCodes DarkOliveGreen3C107;
    public static Terminal256ColorCodes DarkSeaGreenC108;
    public static Terminal256ColorCodes LightSkyBlue3C109;
    public static Terminal256ColorCodes LightSkyBlue3C110;
    public static Terminal256ColorCodes SkyBlue2C111;
    public static Terminal256ColorCodes Chartreuse2C112;
    public static Terminal256ColorCodes DarkOliveGreen3C113;
    public static Terminal256ColorCodes PaleGreen3C114;
    public static Terminal256ColorCodes DarkSeaGreen3C115;
    public static Terminal256ColorCodes DarkSlateGray3C116;
    public static Terminal256ColorCodes SkyBlue1C117;
    public static Terminal256ColorCodes Chartreuse1C118;
    public static Terminal256ColorCodes LightGreenC119;
    public static Terminal256ColorCodes LightGreenC120;
    public static Terminal256ColorCodes PaleGreen1C121;
    public static Terminal256ColorCodes Aquamarine1C122;
    public static Terminal256ColorCodes DarkSlateGray1C123;
    public static Terminal256ColorCodes Red3C124;
    public static Terminal256ColorCodes DeepPink4C125;
    public static Terminal256ColorCodes MediumVioletRedC126;
    public static Terminal256ColorCodes Magenta3C127;
    public static Terminal256ColorCodes DarkVioletC128;
    public static Terminal256ColorCodes PurpleC129;
    public static Terminal256ColorCodes DarkOrange3C130;
    public static Terminal256ColorCodes IndianRedC131;
    public static Terminal256ColorCodes HotPink3C132;
    public static Terminal256ColorCodes MediumOrchid3C133;
    public static Terminal256ColorCodes MediumOrchidC134;
    public static Terminal256ColorCodes MediumPurple2C135;
    public static Terminal256ColorCodes DarkGoldenrodC136;
    public static Terminal256ColorCodes LightSalmon3C137;
    public static Terminal256ColorCodes RosyBrownC138;
    public static Terminal256ColorCodes Grey63C139;
    public static Terminal256ColorCodes MediumPurple2C140;
    public static Terminal256ColorCodes MediumPurple1C141;
    public static Terminal256ColorCodes Gold3C142;
    public static Terminal256ColorCodes DarkKhakiC143;
    public static Terminal256ColorCodes NavajoWhite3C144;
    public static Terminal256ColorCodes Grey69C145;
    public static Terminal256ColorCodes LightSteelBlue3C146;
    public static Terminal256ColorCodes LightSteelBlueC147;
    public static Terminal256ColorCodes Yellow3C148;
    public static Terminal256ColorCodes DarkOliveGreen3C149;
    public static Terminal256ColorCodes DarkSeaGreen3C150;
    public static Terminal256ColorCodes DarkSeaGreen2C151;
    public static Terminal256ColorCodes LightCyan3C152;
    public static Terminal256ColorCodes LightSkyBlue1C153;
    public static Terminal256ColorCodes GreenYellowC154;
    public static Terminal256ColorCodes DarkOliveGreen2C155;
    public static Terminal256ColorCodes PaleGreen1C156;
    public static Terminal256ColorCodes DarkSeaGreen2C157;
    public static Terminal256ColorCodes DarkSeaGreen1C158;
    public static Terminal256ColorCodes PaleTurquoise1C159;
    public static Terminal256ColorCodes Red3C160;
    public static Terminal256ColorCodes DeepPink3C161;
    public static Terminal256ColorCodes DeepPink3C162;
    public static Terminal256ColorCodes Magenta3C163;
    public static Terminal256ColorCodes Magenta3C164;
    public static Terminal256ColorCodes Magenta2C165;
    public static Terminal256ColorCodes DarkOrange3C166;
    public static Terminal256ColorCodes IndianRedC167;
    public static Terminal256ColorCodes HotPink3C168;
    public static Terminal256ColorCodes HotPink2C169;
    public static Terminal256ColorCodes OrchidC170;
    public static Terminal256ColorCodes MediumOrchid1C171;
    public static Terminal256ColorCodes Orange3C172;
    public static Terminal256ColorCodes LightSalmon3C173;
    public static Terminal256ColorCodes LightPink3C174;
    public static Terminal256ColorCodes Pink3C175;
    public static Terminal256ColorCodes Plum3C176;
    public static Terminal256ColorCodes VioletC177;
    public static Terminal256ColorCodes Gold3C178;
    public static Terminal256ColorCodes LightGoldenrod3C179;
    public static Terminal256ColorCodes TanC180;
    public static Terminal256ColorCodes MistyRose3C181;
    public static Terminal256ColorCodes Thistle3C182;
    public static Terminal256ColorCodes Plum2C183;
    public static Terminal256ColorCodes Yellow3C184;
    public static Terminal256ColorCodes Khaki3C185;
    public static Terminal256ColorCodes LightGoldenrod2C186;
    public static Terminal256ColorCodes LightYellow3C187;
    public static Terminal256ColorCodes Grey84C188;
    public static Terminal256ColorCodes LightSteelBlue1C189;
    public static Terminal256ColorCodes Yellow2C190;
    public static Terminal256ColorCodes DarkOliveGreen1C191;
    public static Terminal256ColorCodes DarkOliveGreen1C192;
    public static Terminal256ColorCodes DarkSeaGreen1C193;
    public static Terminal256ColorCodes Honeydew2C194;
    public static Terminal256ColorCodes LightCyan1C195;
    public static Terminal256ColorCodes Red1C196;
    public static Terminal256ColorCodes DeepPink2C197;
    public static Terminal256ColorCodes DeepPink1C198;
    public static Terminal256ColorCodes DeepPink1C199;
    public static Terminal256ColorCodes Magenta2C200;
    public static Terminal256ColorCodes Magenta1C201;
    public static Terminal256ColorCodes OrangeRed1C202;
    public static Terminal256ColorCodes IndianRed1C203;
    public static Terminal256ColorCodes IndianRed1C204;
    public static Terminal256ColorCodes HotPinkC205;
    public static Terminal256ColorCodes HotPinkC206;
    public static Terminal256ColorCodes MediumOrchid1C207;
    public static Terminal256ColorCodes DarkOrangeC208;
    public static Terminal256ColorCodes Salmon1C209;
    public static Terminal256ColorCodes LightCoralC210;
    public static Terminal256ColorCodes PaleVioletRed1C211;
    public static Terminal256ColorCodes Orchid2C212;
    public static Terminal256ColorCodes Orchid1C213;
    public static Terminal256ColorCodes Orange1C214;
    public static Terminal256ColorCodes SandyBrownC215;
    public static Terminal256ColorCodes LightSalmon1C216;
    public static Terminal256ColorCodes LightPink1C217;
    public static Terminal256ColorCodes Pink1C218;
    public static Terminal256ColorCodes Plum1C219;
    public static Terminal256ColorCodes Gold1C220;
    public static Terminal256ColorCodes LightGoldenrod2C221;
    public static Terminal256ColorCodes LightGoldenrod2C222;
    public static Terminal256ColorCodes NavajoWhite1C223;
    public static Terminal256ColorCodes MistyRose1C224;
    public static Terminal256ColorCodes Thistle1C225;
    public static Terminal256ColorCodes Yellow1C226;
    public static Terminal256ColorCodes LightGoldenrod1C227;
    public static Terminal256ColorCodes Khaki1C228;
    public static Terminal256ColorCodes Wheat1C229;
    public static Terminal256ColorCodes Cornsilk1C230;
    public static Terminal256ColorCodes Grey100C231;
    public static Terminal256ColorCodes Grey3C232;
    public static Terminal256ColorCodes Grey7C233;
    public static Terminal256ColorCodes Grey11C234;
    public static Terminal256ColorCodes Grey15C235;
    public static Terminal256ColorCodes Grey19C236;
    public static Terminal256ColorCodes Grey23C237;
    public static Terminal256ColorCodes Grey27C238;
    public static Terminal256ColorCodes Grey30C239;
    public static Terminal256ColorCodes Grey35C240;
    public static Terminal256ColorCodes Grey39C241;
    public static Terminal256ColorCodes Grey42C242;
    public static Terminal256ColorCodes Grey46C243;
    public static Terminal256ColorCodes Grey50C244;
    public static Terminal256ColorCodes Grey54C245;
    public static Terminal256ColorCodes Grey58C246;
    public static Terminal256ColorCodes Grey62C247;
    public static Terminal256ColorCodes Grey66C248;
    public static Terminal256ColorCodes Grey70C249;
    public static Terminal256ColorCodes Grey74C250;
    public static Terminal256ColorCodes Grey78C251;
    public static Terminal256ColorCodes Grey82C252;
    public static Terminal256ColorCodes Grey85C253;
    public static Terminal256ColorCodes Grey89C254;
    public static Terminal256ColorCodes Grey93C255;
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Tracing.AnsiColor.Terminal256ColorCodesExtensions : object {
    [ExtensionAttribute]
public static string ToColorParameter(Terminal256ColorCodes code);
}
public enum TechTalk.SpecFlow.Tracing.AnsiColor.TerminalControlSequences : Enum {
    public int value__;
    public static TerminalControlSequences None;
    public static TerminalControlSequences Reset;
    public static TerminalControlSequences Bold;
    public static TerminalControlSequences Faint;
    public static TerminalControlSequences Italic;
    public static TerminalControlSequences Underline;
    public static TerminalControlSequences SlowBlink;
    public static TerminalControlSequences RapidBlink;
    public static TerminalControlSequences Invert;
    public static TerminalControlSequences Hide;
    public static TerminalControlSequences Strike;
    public static TerminalControlSequences PrimaryFont;
    public static TerminalControlSequences AlternativeFont1;
    public static TerminalControlSequences AlternativeFont2;
    public static TerminalControlSequences AlternativeFont3;
    public static TerminalControlSequences AlternativeFont4;
    public static TerminalControlSequences AlternativeFont5;
    public static TerminalControlSequences AlternativeFont6;
    public static TerminalControlSequences AlternativeFont7;
    public static TerminalControlSequences AlternativeFont8;
    public static TerminalControlSequences AlternativeFont9;
    public static TerminalControlSequences Fraktur;
    public static TerminalControlSequences DoublyUnderlined;
    public static TerminalControlSequences NormalIntensity;
    public static TerminalControlSequences NeitherItalicNorBlackletter;
    public static TerminalControlSequences NotUnderline;
    public static TerminalControlSequences NotBlinking;
    public static TerminalControlSequences NotReverse;
    public static TerminalControlSequences Reveal;
    public static TerminalControlSequences NotCrossedOut;
    public static TerminalControlSequences SetForegroundColor;
    public static TerminalControlSequences DefaultForegroundColor;
    public static TerminalControlSequences SetBackgroundColor;
    public static TerminalControlSequences DefaultBackgroundColor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class TechTalk.SpecFlow.Tracing.AnsiColor.TerminalRgbColor : ValueType {
    public static TerminalRgbColor None;
    [CompilerGeneratedAttribute]
private int <R>k__BackingField;
    [CompilerGeneratedAttribute]
private int <G>k__BackingField;
    [CompilerGeneratedAttribute]
private int <B>k__BackingField;
    public int R { get; }
    public int G { get; }
    public int B { get; }
    public TerminalRgbColor(int r, int g, int b);
    private static TerminalRgbColor();
    public static TerminalRgbColor From(int r, int g, int b);
    public static TerminalRgbColor FromHex(string hex);
    [CompilerGeneratedAttribute]
public int get_R();
    [CompilerGeneratedAttribute]
public int get_G();
    [CompilerGeneratedAttribute]
public int get_B();
    public string ToColorParameter();
    public bool Equals(TerminalRgbColor other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TerminalRgbColor left, TerminalRgbColor right);
    public static bool op_Inequality(TerminalRgbColor left, TerminalRgbColor right);
}
public class TechTalk.SpecFlow.Tracing.AsyncTraceListener : object {
    private Lazy`1<ITestRunner> _testRunner;
    private ITraceListenerQueue _traceListenerQueue;
    public AsyncTraceListener(ITraceListenerQueue traceListenerQueue, IObjectContainer container);
    public virtual void WriteTestOutput(string message);
    public virtual void WriteToolOutput(string message);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Tracing.CodeFormattingExtensions : object {
    private static Regex firstWordCharRe;
    private static Regex punctCharRe;
    private static Dictionary`2<string, string> accentReplacements;
    private static Regex nonIdentifierRe;
    private static Regex nonLatinRe;
    private static Regex singleAndDoubleQuotes;
    private static CodeFormattingExtensions();
    [ExtensionAttribute]
public static string Indent(string text, string indent);
    [ExtensionAttribute]
public static string ToIdentifier(string text);
    [ExtensionAttribute]
public static string ToIdentifierCamelCase(string text);
    [ExtensionAttribute]
public static string ToIdentifierPart(string text);
    [ExtensionAttribute]
public static string TrimEllipse(string text, int maxLength);
    public static string RemoveAccentAndPunctuationChars(string text);
    public static string RemoveQuotationCharacters(string text);
}
public class TechTalk.SpecFlow.Tracing.ColorOutputHelper : object {
    private SpecFlowConfiguration _specFlowConfiguration;
    private bool _forceNoColor;
    public bool EmitAnsiColorCodes { get; }
    public ColorOutputHelper(SpecFlowConfiguration specFlowConfiguration);
    public sealed virtual bool get_EmitAnsiColorCodes();
    public sealed virtual string Colorize(string text, AnsiColor color);
}
public class TechTalk.SpecFlow.Tracing.ColorOutputTheme : object {
    [CompilerGeneratedAttribute]
private AnsiColor <Warning>k__BackingField;
    [CompilerGeneratedAttribute]
private AnsiColor <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private AnsiColor <Done>k__BackingField;
    [CompilerGeneratedAttribute]
private AnsiColor <Keyword>k__BackingField;
    public AnsiColor Warning { get; public set; }
    public AnsiColor Error { get; public set; }
    public AnsiColor Done { get; public set; }
    public AnsiColor Keyword { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual AnsiColor get_Warning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Warning(AnsiColor value);
    [CompilerGeneratedAttribute]
public sealed virtual AnsiColor get_Error();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Error(AnsiColor value);
    [CompilerGeneratedAttribute]
public sealed virtual AnsiColor get_Done();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Done(AnsiColor value);
    [CompilerGeneratedAttribute]
public sealed virtual AnsiColor get_Keyword();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Keyword(AnsiColor value);
}
public class TechTalk.SpecFlow.Tracing.DefaultListener : object {
    public sealed virtual void WriteTestOutput(string message);
    public sealed virtual void WriteToolOutput(string message);
}
public interface TechTalk.SpecFlow.Tracing.IColorOutputHelper {
    public bool EmitAnsiColorCodes { get; }
    public abstract virtual bool get_EmitAnsiColorCodes();
    public abstract virtual string Colorize(string text, AnsiColor color);
}
public interface TechTalk.SpecFlow.Tracing.IColorOutputTheme {
    public AnsiColor Warning { get; public set; }
    public AnsiColor Error { get; public set; }
    public AnsiColor Done { get; public set; }
    public AnsiColor Keyword { get; public set; }
    public abstract virtual AnsiColor get_Warning();
    public abstract virtual void set_Warning(AnsiColor value);
    public abstract virtual AnsiColor get_Error();
    public abstract virtual void set_Error(AnsiColor value);
    public abstract virtual AnsiColor get_Done();
    public abstract virtual void set_Done(AnsiColor value);
    public abstract virtual AnsiColor get_Keyword();
    public abstract virtual void set_Keyword(AnsiColor value);
}
public interface TechTalk.SpecFlow.Tracing.IStepFormatter {
    public abstract virtual string GetStepDescription(StepInstance stepInstance);
    public abstract virtual string GetMatchText(BindingMatch match, Object[] arguments);
    public abstract virtual string GetMatchText(IBindingMethod method, Object[] arguments);
    public abstract virtual string GetStepText(StepInstance stepInstance);
}
public interface TechTalk.SpecFlow.Tracing.ITestTracer {
    public abstract virtual void TraceStep(StepInstance stepInstance, bool showAdditionalArguments);
    public abstract virtual void TraceWarning(string text);
    public abstract virtual void TraceStepDone(BindingMatch match, Object[] arguments, TimeSpan duration);
    public abstract virtual void TraceStepSkipped();
    public abstract virtual void TraceStepPending(BindingMatch match, Object[] arguments);
    public abstract virtual void TraceBindingError(BindingException ex);
    public abstract virtual void TraceError(Exception ex, TimeSpan duration);
    public abstract virtual void TraceNoMatchingStepDefinition(StepInstance stepInstance, ProgrammingLanguage targetLanguage, CultureInfo bindingCulture, List`1<BindingMatch> matchesWithoutScopeCheck);
    public abstract virtual void TraceDuration(TimeSpan elapsed, IBindingMethod method, Object[] arguments);
    public abstract virtual void TraceDuration(TimeSpan elapsed, string text);
}
public interface TechTalk.SpecFlow.Tracing.IThreadSafeTraceListener {
}
public interface TechTalk.SpecFlow.Tracing.ITraceListener {
    public abstract virtual void WriteTestOutput(string message);
    public abstract virtual void WriteToolOutput(string message);
}
public interface TechTalk.SpecFlow.Tracing.ITraceListenerQueue {
    public abstract virtual void Start();
    public abstract virtual void EnqueueMessage(ITestRunner sourceTestRunner, string message, bool isToolMessgae);
}
internal static class TechTalk.SpecFlow.Tracing.LanguageHelper : object {
    private static Dictionary`2<CultureInfo, KeywordTranslation> translationCache;
    private static LanguageHelper();
    public static string GetDefaultKeyword(CultureInfo language, StepDefinitionType stepDefinitionType);
    public static String[] GetKeywords(CultureInfo language, StepDefinitionType stepDefinitionType);
    public static String[] GetKeywords(CultureInfo language, StepDefinitionKeyword keyword);
    public static string GetDefaultKeyword(CultureInfo language, StepDefinitionKeyword keyword);
    private static KeywordTranslation GetTranslation(CultureInfo language);
    public static CultureInfo GetSpecificCultureInfo(CultureInfo language);
    private static KeywordTranslation LoadTranslation(CultureInfo language);
}
public class TechTalk.SpecFlow.Tracing.NullListener : object {
    public sealed virtual void WriteTestOutput(string message);
    public sealed virtual void WriteToolOutput(string message);
}
internal class TechTalk.SpecFlow.Tracing.StepFormatter : object {
    private IColorOutputHelper colorOutputHelper;
    private IColorOutputTheme colorOutputTheme;
    public static string INDENT;
    public StepFormatter(IColorOutputHelper colorOutputHelper, IColorOutputTheme colorOutputTheme);
    public sealed virtual string GetStepDescription(StepInstance stepInstance);
    public sealed virtual string GetMatchText(BindingMatch match, Object[] arguments);
    public sealed virtual string GetMatchText(IBindingMethod method, Object[] arguments);
    private string GetParamString(object arg);
    public sealed virtual string GetStepText(StepInstance stepInstance);
    [CompilerGeneratedAttribute]
private string <GetMatchText>b__6_0(object a);
}
public class TechTalk.SpecFlow.Tracing.TestTracer : object {
    private static TimeSpan MillisecondsThreshold;
    private ITraceListener traceListener;
    private IStepFormatter stepFormatter;
    private IStepDefinitionSkeletonProvider stepDefinitionSkeletonProvider;
    private SpecFlowConfiguration specFlowConfiguration;
    private IColorOutputTheme colorOutputTheme;
    private IColorOutputHelper colorOutputHelper;
    public TestTracer(ITraceListener traceListener, IStepFormatter stepFormatter, IStepDefinitionSkeletonProvider stepDefinitionSkeletonProvider, SpecFlowConfiguration specFlowConfiguration, IColorOutputTheme colorOutputTheme, IColorOutputHelper colorOutputHelper);
    private static TestTracer();
    public sealed virtual void TraceStep(StepInstance stepInstance, bool showAdditionalArguments);
    public sealed virtual void TraceWarning(string text);
    public sealed virtual void TraceStepDone(BindingMatch match, Object[] arguments, TimeSpan duration);
    public sealed virtual void TraceStepSkipped();
    public sealed virtual void TraceStepPending(BindingMatch match, Object[] arguments);
    public sealed virtual void TraceBindingError(BindingException ex);
    public sealed virtual void TraceError(Exception ex, TimeSpan duration);
    private void WriteLoaderExceptionsIfAny(Exception ex, TimeSpan duration);
    private void FormatLoaderExceptions(ReflectionTypeLoadException reflectionTypeLoadException, TimeSpan duration);
    private void WriteErrorMessage(string ex, TimeSpan duration);
    public sealed virtual void TraceNoMatchingStepDefinition(StepInstance stepInstance, ProgrammingLanguage targetLanguage, CultureInfo bindingCulture, List`1<BindingMatch> matchesWithoutScopeCheck);
    public sealed virtual void TraceDuration(TimeSpan elapsed, IBindingMethod method, Object[] arguments);
    public sealed virtual void TraceDuration(TimeSpan elapsed, string text);
    [CompilerGeneratedAttribute]
private string <TraceNoMatchingStepDefinition>b__18_0(BindingMatch m);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Tracing.TraceListenerHelper : object {
    [ExtensionAttribute]
public static void WriteTestOutput(ITraceListener traceListener, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void WriteToolOutput(ITraceListener traceListener, string messageFormat, Object[] args);
}
public class TechTalk.SpecFlow.Tracing.TraceListenerQueue : object {
    private ITestRunnerManager _testRunnerManager;
    private ITraceListener _traceListener;
    private bool _isThreadSafeTraceListener;
    private BlockingCollection`1<TraceMessage> _messages;
    private Task _consumerTask;
    private Exception _error;
    public TraceListenerQueue(ITraceListener traceListener, ITestRunnerManager testRunnerManager);
    public sealed virtual void Start();
    public sealed virtual void EnqueueMessage(ITestRunner sourceTestRunner, string message, bool isToolMessgae);
    public sealed virtual void Dispose();
    private void ForwardMessage(TraceMessage message);
    [CompilerGeneratedAttribute]
private void <Start>b__7_0();
}
public interface TechTalk.SpecFlow.UnitTestProvider.IUnitTestRuntimeProvider {
    public bool DelayedFixtureTearDown { get; }
    public abstract virtual void TestPending(string message);
    public abstract virtual void TestInconclusive(string message);
    public abstract virtual void TestIgnore(string message);
    public abstract virtual bool get_DelayedFixtureTearDown();
}
public class TechTalk.SpecFlow.UnitTestProvider.UnitTestProviderConfiguration : object {
    [CompilerGeneratedAttribute]
private string <UnitTestProvider>k__BackingField;
    public string UnitTestProvider { get; private set; }
    public void UseUnitTestProvider(string unitTestProviderName);
    [CompilerGeneratedAttribute]
public string get_UnitTestProvider();
    [CompilerGeneratedAttribute]
private void set_UnitTestProvider(string value);
}
internal class TechTalk.SpecFlow.VersionInfo : object {
    internal static string AssemblyVersion { get; }
    internal static string AssemblyFileVersion { get; }
    internal static string AssemblyInformationalVersion { get; }
    internal static string NuGetVersion { get; }
    internal static string get_AssemblyVersion();
    internal static string get_AssemblyFileVersion();
    internal static string get_AssemblyInformationalVersion();
    internal static string get_NuGetVersion();
}
public class TechTalk.SpecFlow.WhenAttribute : StepDefinitionBaseAttribute {
    public WhenAttribute(string regex);
    public WhenAttribute(string regex, string culture);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.107.25444")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
