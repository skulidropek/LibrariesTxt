internal static class Microsoft.Build.Shared.FileMatcher : object {
    private static string RecursiveDirectoryMatch;
    private static string DotDot;
    private static string DirectorySeparator;
    private static string AltDirectorySeparator;
    private static Char[] WildcardCharacters;
    private static Char[] WildcardAndSemicolonCharacters;
    internal static Char[] DirectorySeparatorCharacters;
    private static GetFileSystemEntries DefaultGetFileSystemEntries;
    private static Char[] InvalidPathChars;
    private static FileMatcher();
    internal static bool HasWildcards(string filespec);
    private static String[] GetAccessibleFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static String[] GetAccessibleFilesAndDirectories(string path, string pattern);
    private static String[] GetAccessibleFiles(string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static String[] GetAccessibleDirectories(string path, string pattern);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal static void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, GetFileSystemEntries getFileSystemEntries);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void RemoveInitialDotSlash(String[] paths);
    internal static bool IsDirectorySeparator(char c);
    internal static void RemoveProjectDirectory(String[] paths, string projectDirectory);
    private static void GetFilesRecursive(IList listOfFiles, string baseDirectory, string remainingWildcardDirectory, string filespec, int extensionLengthToEnforce, Regex regexFileMatch, bool needsRecursion, string projectDirectory, bool stripProjectDirectory, GetFileSystemEntries getFileSystemEntries);
    private static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, Boolean& isLegalFileSpec);
    internal static void GetFileSpecInfo(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    private static void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, String& matchFileExpression, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    internal static Result FileMatch(string filespec, string fileToMatch);
}
internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, UInt32 uintData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData, bool correlated);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    private static string AtomName;
    private static string TestDllName;
    private static string ProductDllName;
    private State state;
    private RegistryView registryView;
    private string regroot;
    private Nullable`1<bool> shouldUseTestDll;
    private static Byte[] CorrelationMarkBytes;
    public bool IsEnabled { get; }
    public bool ShouldUseTestDll { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool get_ShouldUseTestDll();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public void SetStateDLLException();
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    internal static Byte[] StringToBytesZeroTerminated(string stringData);
    public static Byte[] AttachCorrelationId(Byte[] buffer, Guid correlationId);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
    private static bool UsePrivateCodeMarkers(string regRoot, RegistryView registryView);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    private Byte[] _buffer;
    internal CodeMarkerStartEnd(int begin, int end, bool correlated);
    public sealed virtual void Dispose();
    private void CodeMarker(int id);
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("EC05985A-3DBD-49E4-B02A-8C111AD14285", "Microsoft.VisualStudio.Imaging.Interop.ImageMoniker")]
public class Microsoft.VisualStudio.Imaging.Interop.ImageMoniker : ValueType {
    public Guid Guid;
    public int Id;
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ActiveConfigurationChangedEventArgs : EventArgs {
    public ConfiguredProject PreviouslyActive { get; }
    public ConfiguredProject NowActive { get; }
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public int ActiveConfiguredProjectProviderDataSourceVersion { get; }
    public abstract virtual ConfiguredProject get_PreviouslyActive();
    public abstract virtual ConfiguredProject get_NowActive();
    public abstract virtual int get_ActiveConfiguredProjectProviderDataSourceVersion();
}
public interface Microsoft.VisualStudio.ProjectSystem.ActiveConfiguredProject`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
public class Microsoft.VisualStudio.ProjectSystem.ActiveProjectConfigurationChangedException : ProjectException {
    public ActiveProjectConfigurationChangedException(string message);
    public ActiveProjectConfigurationChangedException(string message, Exception inner);
    protected ActiveProjectConfigurationChangedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.ProjectSystem.AggregateCancellationTokenSource : object {
    private static Action`1<object> CancelHandlerDelegate;
    private CancellationTokenSource tokenSource;
    private DisposableBag notifyRegistrations;
    private int tokenCount;
    internal CancellationToken Token { get; }
    private AggregateCancellationTokenSource(int tokenCount);
    private static AggregateCancellationTokenSource();
    internal CancellationToken get_Token();
    public sealed virtual void Dispose();
    internal static AggregateCancellationTokenSource CreateUnionCancellationToken(IReadOnlyCollection`1<CancellationToken> tokens);
    protected virtual void Dispose(bool disposing);
    private static void CancelHandler(object value);
    private void Decrement();
}
[AttributeUsageAttribute("452")]
[MetadataAttributeAttribute]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.AppliesToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AppliesTo>k__BackingField;
    public string AppliesTo { get; private set; }
    public AppliesToAttribute(string appliesToExpression);
    [CompilerGeneratedAttribute]
public string get_AppliesTo();
    [CompilerGeneratedAttribute]
private void set_AppliesTo(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.AwaitExtensions : object {
    private static SendOrPostCallback StateInvokerDelegate;
    private static AwaitExtensions();
    [ExtensionAttribute]
public static T GetResultAssumeCompleted(Task`1<T> task);
    [ExtensionAttribute]
internal static Task`1<BuildResult> ExecuteAsync(BuildSubmission submission, IProjectThreadingService threadingService);
    [ExtensionAttribute]
internal static CancellationTokenRegistration RegisterNoThrowOnDispose(CancellationToken token, Action callback);
    [ExtensionAttribute]
internal static CancellationTokenRegistration RegisterNoThrowOnDispose(CancellationToken token, Action`1<object> callback, object state);
    [ExtensionAttribute]
internal static TaskResumeWithAwaitable ResumeWith(Task predecessorTask, TaskScheduler scheduler, TaskCreationOptions options);
    [ExtensionAttribute]
internal static TaskResumeWithAwaitable`1<TResult> ResumeWith(Task`1<TResult> predecessorTask, TaskScheduler scheduler, TaskCreationOptions options);
    internal static TaskScheduler GetContinuationScheduler(bool considerCurrentScheduler);
    private static void SetBuildComplete(BuildSubmission submission);
}
[DebuggerDisplayAttribute("BaseStandardProjectConfiguration: {Name}")]
public abstract class Microsoft.VisualStudio.ProjectSystem.BaseStandardProjectConfiguration : object {
    private string name;
    private IImmutableDictionary`2<string, string> dimensions;
    public string Name { get; }
    public IImmutableDictionary`2<string, string> Dimensions { get; }
    public BaseStandardProjectConfiguration(string name, IImmutableDictionary`2<string, string> dimensions);
    public sealed virtual string get_Name();
    public sealed virtual IImmutableDictionary`2<string, string> get_Dimensions();
    public virtual string ToString();
    public sealed virtual bool Equals(BaseStandardProjectConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.VisualStudio.ProjectSystem.Build.BuildAction : Enum {
    public int value__;
    public static BuildAction Build;
    public static BuildAction Rebuild;
    public static BuildAction Clean;
    public static BuildAction Compile;
    public static BuildAction Link;
    public static BuildAction Deploy;
    public static BuildAction Package;
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.BuildByRuleDataflowLinkOptions : DataflowLinkOptions {
    [CompilerGeneratedAttribute]
private IImmutableSet`1<Rule> <Rules>k__BackingField;
    public IImmutableSet`1<Rule> Rules { get; public set; }
    [CompilerGeneratedAttribute]
public IImmutableSet`1<Rule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(IImmutableSet`1<Rule> value);
    public sealed virtual object Clone();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Build.BuildDataflowLinkOptions : DataflowLinkOptions {
    public IImmutableSet`1<string> Targets { get; public set; }
    public abstract virtual IImmutableSet`1<string> get_Targets();
    public abstract virtual void set_Targets(IImmutableSet`1<string> value);
    public abstract virtual object Clone();
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.Build.BuildManagerHostBase : object {
    [CompilerGeneratedAttribute]
private ProjectCollection <ProjectCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectService <ProjectService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectThreadingService <ThreadingService>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskCollection <JoinableTaskCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskFactory <JoinableTaskFactory>k__BackingField;
    public bool IsCancelable { get; }
    [ImportAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCollection")]
protected ProjectCollection ProjectCollection { get; private set; }
    [ImportAttribute]
protected IProjectService ProjectService { get; private set; }
    protected IProjectThreadingService ThreadingService { get; private set; }
    protected JoinableTaskCollection JoinableTaskCollection { get; private set; }
    protected JoinableTaskFactory JoinableTaskFactory { get; private set; }
    protected BuildManagerHostBase(IProjectThreadingService threadingService);
    public abstract virtual bool get_IsCancelable();
    [CompilerGeneratedAttribute]
protected ProjectCollection get_ProjectCollection();
    [CompilerGeneratedAttribute]
private void set_ProjectCollection(ProjectCollection value);
    [CompilerGeneratedAttribute]
protected IProjectService get_ProjectService();
    [CompilerGeneratedAttribute]
private void set_ProjectService(IProjectService value);
    [CompilerGeneratedAttribute]
protected IProjectThreadingService get_ThreadingService();
    [CompilerGeneratedAttribute]
private void set_ThreadingService(IProjectThreadingService value);
    [CompilerGeneratedAttribute]
protected JoinableTaskCollection get_JoinableTaskCollection();
    [CompilerGeneratedAttribute]
private void set_JoinableTaskCollection(JoinableTaskCollection value);
    [CompilerGeneratedAttribute]
protected JoinableTaskFactory get_JoinableTaskFactory();
    [CompilerGeneratedAttribute]
private void set_JoinableTaskFactory(JoinableTaskFactory value);
    public abstract virtual Task`1<bool> IsApplicableAsync();
    public abstract virtual IImmutableDictionary`2<IBuildRequest, Task`1<BuildResult>> Build(IImmutableSet`1<IBuildRequest> buildRequests);
    protected static void AlignBuildRequestNodeAffinities(IImmutableSet`1<IBuildRequest> buildRequests, BuildParameters buildParameters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Build.BuildManagerHostBase/<ExecuteBuildAndNotifyRequestsAsync>d__26")]
protected Task ExecuteBuildAndNotifyRequestsAsync(IImmutableSet`1<IBuildRequest> buildRequests, Func`1<Task> buildExecutionAsync);
}
public enum Microsoft.VisualStudio.ProjectSystem.Build.BuildRequestPriority : Enum {
    public int value__;
    public static BuildRequestPriority High;
    public static BuildRequestPriority Medium;
    public static BuildRequestPriority Low;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.Build.BuildStatus : Enum {
    public int value__;
    public static BuildStatus Idle;
    public static BuildStatus Busy;
    public static BuildStatus SecurityDisabled;
    public static BuildStatus ConfigurationDisabled;
    public static BuildStatus DisabledMask;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.Build.BuildUtilities : object {
    internal static string DesignTimeBuildProperty;
    internal static string ContinueOnErrorProperty;
    internal static string ResolveAssemblyReferencesSilentProperty;
    internal static string DesignTimeSilentResolutionProperty;
    internal static string BuildingInsideVisualStudioProperty;
    internal static string DefineExplicitDefaultsProperty;
    internal static string TrueValue;
    internal static string FalseValue;
    [ExtensionAttribute]
internal static Task`1<IBuildResult> BuildAsync(IBuildProject buildProject, string target);
    [ExtensionAttribute]
internal static Task`1<IBuildResult> BuildAsync(IBuildProject buildProject, BuildAction buildAction);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Build.BuildUtilities/<RespondToCancellationRequests>d__10")]
internal static IEnumerable`1<Tuple`2<IBuildRequest, TaskCompletionSource`1<BuildResult>>> RespondToCancellationRequests(IEnumerable`1<Tuple`2<IBuildRequest, TaskCompletionSource`1<BuildResult>>> buildQueue);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Build.BuildUtilities/<RespondToCancellationRequests>d__11")]
internal static IEnumerable`1<IBuildRequest> RespondToCancellationRequests(IEnumerable`1<KeyValuePair`2<IBuildRequest, TaskCompletionSource`1<BuildResult>>> buildQueue);
    [ExtensionAttribute]
internal static IDisposable RegisterForAggregateBuildRequestCancellation(IImmutableSet`1<IBuildRequest> buildRequests, BuildManager buildManager);
    [ExtensionAttribute]
internal static Task`1<BuildResult> AppendUnregisterLoggersTask(Task`1<BuildResult> flushLoggersTask, IVsShellServices shellServices, int submissionId);
    [ExtensionAttribute]
internal static Task`1<BuildResult> AppendUnregisterLoggersTask(Task`1<BuildResult> flushLoggersTask, MuxLogger muxLogger, int submissionId);
    [ExtensionAttribute]
internal static Task`1<BuildResult> AppendFlushLoggersTask(Task`1<BuildResult> buildRequestTask, IBuildRequest buildRequest);
    [ExtensionAttribute]
internal static CancellationToken GetBatchBuildCancellationToken(IImmutableSet`1<IBuildRequest> buildRequests);
    [ExtensionAttribute]
internal static string ExtractProjectFile(BuildEventArgs eventArgs);
    internal static IEnumerable`1<string> GetBuildTargets(Rule rule);
}
internal enum Microsoft.VisualStudio.ProjectSystem.Build.DesignTimeBuildCacheState : Enum {
    public int value__;
    public static DesignTimeBuildCacheState NoCache;
    public static DesignTimeBuildCacheState CacheWithPartialData;
    public static DesignTimeBuildCacheState FullCache;
}
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.Build.ExportBuildGlobalPropertiesProviderAttribute : ExportAttribute {
    public ExportBuildGlobalPropertiesProviderAttribute(bool designTimeBuildProperties);
}
internal static class Microsoft.VisualStudio.ProjectSystem.Build.GlobalPropertiesHelper : object {
    internal static string CurrentSolutionConfigurationContents;
    private static ImmutableHashSet`1<string> GlobalProjectCollectionPropertiesToCopy;
    private static GlobalPropertiesHelper();
    internal static ImmutableDictionary`2<string, string> ConstructGlobalProperties(IReadOnlyDictionary`2<string, string> globalPropertiesFromGlobalProjectCollection, bool isSolutionBuildManagerPresent);
    internal static ImmutableDictionary`2<string, string> UpdateGlobalProperties(IReadOnlyDictionary`2<string, string> globalPropertiesFromGlobalProjectCollection, bool isSolutionBuildManagerPresent, ImmutableDictionary`2<string, string> originalValues);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBatchingBuildManagerHost {
    public abstract virtual IImmutableDictionary`2<IBuildRequest, Task`1<BuildResult>> BuildBatch(IImmutableSet`1<IBuildRequest> buildRequests);
    public abstract virtual void OnCancelledBuildRequests(IEnumerable`1<IBuildRequest> buildRequests);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildFiles {
    public abstract virtual Task`1<PrepareBuildFilesResult> PrepareBuildFilesAsync(IImmutableSet`1<string> files, bool predeterminedTarget);
    public abstract virtual Task`1<bool> CanBuildFileAsync(string file);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildLoggerProvider {
    public abstract virtual IImmutableSet`1<ILogger> GetLoggers(IReadOnlyList`1<string> targets, IImmutableDictionary`2<string, string> properties);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildLoggerProviderAsync {
    public abstract virtual Task`1<IImmutableSet`1<ILogger>> GetLoggersAsync(IReadOnlyList`1<string> targets, IImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("0", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildManagerHost {
    public bool IsCancelable { get; }
    public abstract virtual bool get_IsCancelable();
    public abstract virtual Task`1<bool> IsApplicableAsync();
    public abstract virtual IImmutableDictionary`2<IBuildRequest, Task`1<BuildResult>> Build(IImmutableSet`1<IBuildRequest> buildRequests);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildManagerHostBatchingService {
    public abstract virtual IImmutableDictionary`2<IBuildRequest, Task`1<BuildResult>> Enqueue(IBatchingBuildManagerHost buildManagerHost, IImmutableSet`1<IBuildRequest> buildRequests);
    public abstract virtual bool IsCompatibleProjectInstance(ProjectInstance candidateInstance, IImmutableSet`1<ProjectInstance> compatibleProjectInstances);
    public abstract virtual IReadOnlyCollection`1<IBuildRequest> Abort(IBatchingBuildManagerHost buildManagerHost, IImmutableDictionary`2<IBuildRequest, Exception> abortedReasons);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildProject {
    public IProjectValueDataSource`1<IImmutableDictionary`2<string, string>> DesignTimeBuildPropertiesSource { get; }
    public abstract virtual IProjectValueDataSource`1<IImmutableDictionary`2<string, string>> get_DesignTimeBuildPropertiesSource();
    public abstract virtual Task`1<IImmutableDictionary`2<string, string>> GetFullBuildPropertiesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IImmutableDictionary`2<string, string>> GetDesignTimeBuildPropertiesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IBuildResult> BuildAsync(IEnumerable`1<string> targets, CancellationToken cancellationToken, ProjectInstance projectInstance, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<IBuildResult> BuildAsync(IEnumerable`1<BuildAction> actions, CancellationToken cancellationToken, ProjectInstance projectInstance, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<IBuildResult> BuildAsync(IEnumerable`1<string> targets, CancellationToken cancellationToken, bool includeUnsavedChanges, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<IBuildResult> BuildAsync(IEnumerable`1<BuildAction> actions, CancellationToken cancellationToken, bool includeUnsavedChanges, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<bool> IsUpToDateCheckEnabledAsync(BuildAction buildAction, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsUpToDateAsync(BuildAction buildAction, TextWriter logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsUpToDateAsync(BuildAction buildAction, bool beforeDrainCriticalTasks, TextWriter logger, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "3")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildProjectInternal {
    public abstract virtual Task`1<IBuildResult> BuildWithSolutionAsync(IEnumerable`1<BuildAction> actions, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<IBuildResult> BuildWithSolutionAsync(IEnumerable`1<string> targets, IImmutableDictionary`2<string, string> properties, IImmutableSet`1<IHostObject> hostObjects, BuildRequestPriority priority, IImmutableSet`1<ILogger> loggers, IBuildManagerHost preferredBuildManagerHost);
    public abstract virtual Task`1<bool> IsUpToDateCheckEnabledAsync(BuildAction buildAction, bool beforeDrainCriticalTasks, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildRequest {
    public BuildRequestData BuildRequestData { get; }
    public CancellationToken CancellationToken { get; }
    public IImmutableSet`1<ILogger> Loggers { get; }
    public BuildRequestPriority Priority { get; }
    public bool IsMainThreadRequired { get; }
    public bool IsMainThreadBlocked { get; }
    public abstract virtual BuildRequestData get_BuildRequestData();
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual IImmutableSet`1<ILogger> get_Loggers();
    public abstract virtual BuildRequestPriority get_Priority();
    public abstract virtual bool get_IsMainThreadRequired();
    public abstract virtual bool get_IsMainThreadBlocked();
    public abstract virtual Task OnBeginBuildAsync(CancellationToken cancellationToken);
    public abstract virtual Task OnEndBuildAsync(CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildResult {
    public BuildResult MSBuildResult { get; }
    public BuildResultCode OverallResult { get; }
    public int Warnings { get; }
    public int Errors { get; }
    public abstract virtual BuildResult get_MSBuildResult();
    public abstract virtual BuildResultCode get_OverallResult();
    public abstract virtual int get_Warnings();
    public abstract virtual int get_Errors();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildSupport {
    public BuildStatus Status { get; }
    public abstract virtual BuildStatus get_Status();
    public abstract virtual Task`1<string> GetTargetForBuildAsync(BuildAction buildAction);
    public abstract virtual Task`1<bool> IsBuildActionSupportedAsync(BuildAction buildAction, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsBuildTargetSupportedAsync(string target, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IBuildUpToDateCheckProvider {
    public abstract virtual Task`1<bool> IsUpToDateCheckEnabledAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsUpToDateAsync(BuildAction buildAction, TextWriter logger, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "2")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.ICommandLinePreviewProvider {
    public abstract virtual Task`1<IEnumerable`1<string>> GetAdditionalCommandLineValuesAsync(string parameter, IProjectProperties contextProperties);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IDeployProvider {
    public bool IsDeploySupported { get; }
    public abstract virtual bool get_IsDeploySupported();
    public abstract virtual void Commit();
    public abstract virtual Task DeployAsync(CancellationToken cancellationToken, TextWriter outputPaneWriter);
    public abstract virtual void Rollback();
}
[ProjectSystemContractAttribute("2", "2")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IDesignTimeBuildCacheParticipant {
    public abstract virtual DesignTimeBuildCacheState GetDesignTimeBuildCacheStateToSave();
}
[ProjectSystemContractAttribute("2", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IDesignTimeBuildCacheUpToDateCheckProviderInternal {
    public abstract virtual Task`1<Tuple`2<bool, IReadOnlyDictionary`2<string, string>>> CanSaveToCacheAsync(CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "1")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IDesignTimeBuilderService {
    public abstract virtual int SetBuilderProperties(string projectFullPath, IImmutableDictionary`2<string, string> properties);
    public abstract virtual IImmutableDictionary`2<string, string> GetBuilderProperties();
    public abstract virtual Nullable`1<int> Reset();
    public abstract virtual Task`1<DesignTimeBuildResult> BuildAsync(IEnumerable`1<string> targets, IEnumerable`1<ILogger> loggers, IBuildResultMetadataFilter buildResultMetadataFilter, BuildOptions buildOptions, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IDesignTimeBuildManagerService {
    public abstract virtual Task`1<IProjectVersionedValue`1<ProjectDesignTimeBuildResult>> BuildAsync(IEnumerable`1<string> targets, IBuildResultMetadataFilter buildResultMetadataFilter, IEnumerable`1<ILogger> loggers, BuildOptions buildOptions, CancellationToken cancellationToken);
    public abstract virtual IProjectVersionedValue`1<Tuple`2<IProjectSnapshotWithCapabilities, IImmutableDictionary`2<string, string>>> GetBuildContext();
}
[ProjectSystemContractAttribute("2", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IDesignTimeBuildManagerServiceInternal {
    public abstract virtual Nullable`1<int> SetBuildContext(IProjectVersionedValue`1<Tuple`2<IProjectSnapshotWithCapabilities, IImmutableDictionary`2<string, string>>> buildContext);
    public abstract virtual Nullable`1<int> ResetBuild();
}
[ProjectSystemContractAttribute("1", "1")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IErrorListLoggerFactory {
    public abstract virtual ILogger CreateErrorListLogger(IProjectBuildTargetErrorList errorList);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IFileTimestampCache {
    public bool IsCacheApplicable { get; }
    public IDictionary`2<string, DateTime> TimestampCache { get; }
    public abstract virtual bool get_IsCacheApplicable();
    public abstract virtual IDictionary`2<string, DateTime> get_TimestampCache();
}
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IFlushableLogger {
    public abstract virtual Task FlushAsync();
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.IgnoredProjectImportEventArgs : BuildErrorEventArgs {
    public IgnoredProjectImportEventArgs(ProjectImportedEventArgs eventArgs);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IHostObject {
    public string TargetName { get; }
    public string TaskName { get; }
    public ITaskHost TaskHostObject { get; }
    public bool IsMainThreadRequired { get; }
    public abstract virtual string get_TargetName();
    public abstract virtual string get_TaskName();
    public abstract virtual ITaskHost get_TaskHostObject();
    public abstract virtual bool get_IsMainThreadRequired();
    public abstract virtual Task OnBeginBuildAsync(CancellationToken cancellationToken);
    public abstract virtual Task OnEndBuildAsync(CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("1", "1")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IHostObjectProvider {
    public abstract virtual Task`1<IImmutableSet`1<IHostObject>> CreateHostObjectsAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IOutputGroup {
    public string Name { get; }
    public string TargetName { get; }
    public string Description { get; }
    public string DisplayName { get; }
    public IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>> Outputs { get; }
    public bool IsSuccessful { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_TargetName();
    public abstract virtual string get_Description();
    public abstract virtual string get_DisplayName();
    public abstract virtual IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>> get_Outputs();
    public abstract virtual bool get_IsSuccessful();
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IOutputGroupProvider {
    public Task`1<IImmutableSet`1<IOutputGroup>> OutputGroups { get; }
    public abstract virtual Task`1<IImmutableSet`1<IOutputGroup>> get_OutputGroups();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IOutputGroupsService {
    public Task`1<IImmutableSet`1<string>> OutputGroupNames { get; }
    public abstract virtual Task`1<IImmutableSet`1<string>> get_OutputGroupNames();
    public abstract virtual Task`1<IImmutableSet`1<IOutputGroup>> GetOutputGroupsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IOutputGroup> GetOutputGroupAsync(string name, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IOutputGroupsService2 {
    public abstract virtual Task`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>> GetOutputGroupKeyOutputAsync(string name, CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IOutputGroupsServiceInternal {
    public abstract virtual Task`1<ImmutableHashSet`1<IOutputGroup>> GetOutputGroupMetadataAsync();
}
[ProjectSystemContractAttribute("1", "0")]
[ProjectSystemContractAttribute("2", "0")]
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildMessagesDataSource {
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildMessagesMerger {
    public abstract virtual ImmutableList`1<ProjectBuildMessage> Merge(ImmutableList`1<ProjectBuildMessage> originalMessages, ImmutableList`1<ProjectBuildMessage> newMessages, IProjectBuildMessagesMergerLogger logger);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildMessagesMergerLogger {
    public abstract virtual void ReportMessageMerged(int messagedIdMergedFrom, int messagedIdMergedTo);
}
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildSnapshot {
    public IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> TargetOutputs { get; }
    public IImmutableDictionary`2<string, bool> TargetSuccess { get; }
    public IImmutableSet`1<string> Targets { get; }
    public IProjectSnapshot BaseSnapshot { get; }
    public ProjectInstance BuiltProjectInstance { get; }
    public abstract virtual IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> get_TargetOutputs();
    public abstract virtual IImmutableDictionary`2<string, bool> get_TargetSuccess();
    public abstract virtual IImmutableSet`1<string> get_Targets();
    public abstract virtual IProjectSnapshot get_BaseSnapshot();
    public abstract virtual ProjectInstance get_BuiltProjectInstance();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildSnapshotService {
}
[ProjectSystemContractAttribute("2", "0")]
[ProjectSystemContractAttribute("1", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectBuildTargetErrorList {
    public abstract virtual void SubmitTargetResults(string target, ImmutableList`1<ProjectBuildMessage> messages);
    public abstract virtual Task ClearAllAsync();
    public abstract virtual void RemoveTargetResults(IEnumerable`1<string> targets);
}
[ProjectSystemContractAttribute("1", "2")]
[ProjectSystemContractAttribute("2", "2")]
[ProjectSystemContractAttribute("2", "2")]
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IProjectGlobalPropertiesProvider {
    public abstract virtual Task`1<IImmutableDictionary`2<string, string>> GetGlobalPropertiesAsync(CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IPublishProvider {
    public abstract virtual Task`1<bool> IsPublishSupportedAsync();
    public abstract virtual Task PublishAsync(CancellationToken cancellationToken, TextWriter outputPaneWriter);
    public abstract virtual Task`1<bool> ShowPublishPromptAsync();
}
[ObsoleteAttribute("Use IVsLoggerEventProcessor2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IVsLoggerEventProcessor {
    public abstract virtual bool HandleEvent(BuildEventArgs buildEventArgs, string message);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Build.IVsLoggerEventProcessor2 {
    public abstract virtual Task`1<bool> HandleEventAsync(BuildEventArgs buildEventArgs, string message, TextWriter outputWindowWriter);
    public abstract virtual Task FlushAsync();
}
public class Microsoft.VisualStudio.ProjectSystem.Build.OutputGroupDataflowLinkOptions : DataflowLinkOptions {
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <OutputGroupNames>k__BackingField;
    public IImmutableSet`1<string> OutputGroupNames { get; public set; }
    [CompilerGeneratedAttribute]
public IImmutableSet`1<string> get_OutputGroupNames();
    [CompilerGeneratedAttribute]
public void set_OutputGroupNames(IImmutableSet`1<string> value);
    public sealed virtual object Clone();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.Build.OutputGroupsTools : object {
    internal static string BuiltProject;
    private static string KeyOutputItemTypePostfix;
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Build.OutputGroupsTools/<GetKeyOutputAsync>d__2")]
[ExtensionAttribute]
public static Task`1<string> GetKeyOutputAsync(IOutputGroupsService provider, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool TryGetKeyOutputItemFromProject(Project project, string outputTargetName, ProjectItem& projectItem);
    [ExtensionAttribute]
internal static KeyValuePair`2<string, IImmutableDictionary`2<string, string>> GetKeyOutputItem(IOutputGroup outputGroup);
}
public class Microsoft.VisualStudio.ProjectSystem.Build.PrepareBuildFilesResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <BuildMayProceed>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <Targets>k__BackingField;
    public bool BuildMayProceed { get; public set; }
    public IImmutableDictionary`2<string, string> Properties { get; public set; }
    public IImmutableSet`1<string> Targets { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_BuildMayProceed();
    [CompilerGeneratedAttribute]
public void set_BuildMayProceed(bool value);
    [CompilerGeneratedAttribute]
public IImmutableDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IImmutableDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IImmutableSet`1<string> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IImmutableSet`1<string> value);
}
public class Microsoft.VisualStudio.ProjectSystem.Build.ProjectBuildMessage : object {
    private static int globalSequenceId;
    [CompilerGeneratedAttribute]
private BuildEventArgs <BuildEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SequenceId>k__BackingField;
    public BuildEventArgs BuildEventArgs { get; }
    public int SequenceId { get; }
    public ProjectBuildMessage(BuildEventArgs buildEventArgs);
    [CompilerGeneratedAttribute]
public BuildEventArgs get_BuildEventArgs();
    [CompilerGeneratedAttribute]
public int get_SequenceId();
}
public class Microsoft.VisualStudio.ProjectSystem.Build.ProjectBuildMessages : object {
    internal static ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> EmptyMessages;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> <Messages>k__BackingField;
    public string CollectionName { get; }
    public ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> Messages { get; }
    public ProjectBuildMessages(string collectionName, ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> messages);
    private static ProjectBuildMessages();
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> get_Messages();
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.ProjectBuildTargetErrorList : ProjectValueDataSourceBase`1<ProjectBuildMessages> {
    private object syncObject;
    private string listName;
    private ProjectBuildMessages empty;
    private BroadcastBlock`1<IProjectVersionedValue`1<ProjectBuildMessages>> submitMessageBlock;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<ProjectBuildMessages>> publicBlock;
    private ImmutableDictionary`2<string, ImmutableList`1<ProjectBuildMessage>> currentMessages;
    [CompilerGeneratedAttribute]
private IProjectBuildMessagesMerger <BuildMessagesMerger>k__BackingField;
    protected IProjectBuildMessagesMerger BuildMessagesMerger { get; }
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<ProjectBuildMessages>> SourceBlock { get; }
    internal ProjectBuildTargetErrorList(string listName, IProjectCommonServices commonService, bool mergeResults);
    protected ProjectBuildTargetErrorList(string listName, IProjectCommonServices commonService, IProjectBuildMessagesMerger messageMerger);
    [CompilerGeneratedAttribute]
protected virtual IProjectBuildMessagesMerger get_BuildMessagesMerger();
    public virtual NamedIdentity get_DataSourceKey();
    public virtual IComparable get_DataSourceVersion();
    public virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<ProjectBuildMessages>> get_SourceBlock();
    public sealed virtual void SubmitTargetResults(string target, ImmutableList`1<ProjectBuildMessage> messages);
    public sealed virtual void RemoveTargetResults(IEnumerable`1<string> targets);
    public sealed virtual Task ClearAllAsync();
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.ProjectDesignTimeBuildResult : object {
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> <ItemsByTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, bool> <SuccessByTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResultCode <OverallResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProjectFileBuildCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private DesignTimeBuildCacheState <LoadedFromCacheState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BuildResetId>k__BackingField;
    public IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> ItemsByTarget { get; }
    public IImmutableDictionary`2<string, bool> SuccessByTarget { get; }
    internal BuildResultCode OverallResult { get; }
    internal bool ProjectFileBuildCancelled { get; }
    internal DesignTimeBuildCacheState LoadedFromCacheState { get; }
    internal Nullable`1<int> BuildResetId { get; }
    internal ProjectDesignTimeBuildResult(IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> itemsByTarget, IImmutableDictionary`2<string, bool> successByTarget, bool projectFileBuildCancelled, DesignTimeBuildCacheState loadedFromCacheState, Nullable`1<int> buildResetId, BuildResultCode overallResult);
    [CompilerGeneratedAttribute]
public IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> get_ItemsByTarget();
    [CompilerGeneratedAttribute]
public IImmutableDictionary`2<string, bool> get_SuccessByTarget();
    [CompilerGeneratedAttribute]
internal BuildResultCode get_OverallResult();
    [CompilerGeneratedAttribute]
internal bool get_ProjectFileBuildCancelled();
    [CompilerGeneratedAttribute]
internal DesignTimeBuildCacheState get_LoadedFromCacheState();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_BuildResetId();
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.SimpleAppendMessageMerger : object {
    public static IProjectBuildMessagesMerger Instance;
    private static SimpleAppendMessageMerger();
    public sealed virtual ImmutableList`1<ProjectBuildMessage> Merge(ImmutableList`1<ProjectBuildMessage> originalMessages, ImmutableList`1<ProjectBuildMessage> newMessages, IProjectBuildMessagesMergerLogger logger);
}
internal class Microsoft.VisualStudio.ProjectSystem.Build.SimpleReplaceMessageMerger : object {
    public static IProjectBuildMessagesMerger Instance;
    private static SimpleReplaceMessageMerger();
    public sealed virtual ImmutableList`1<ProjectBuildMessage> Merge(ImmutableList`1<ProjectBuildMessage> originalMessages, ImmutableList`1<ProjectBuildMessage> newMessages, IProjectBuildMessagesMergerLogger logger);
}
public class Microsoft.VisualStudio.ProjectSystem.Build.StandardBuildDataflowLinkOptions : BuildDataflowLinkOptions {
    private IImmutableSet`1<string> targets;
    public IImmutableSet`1<string> Targets { get; public set; }
    public virtual IImmutableSet`1<string> get_Targets();
    public virtual void set_Targets(IImmutableSet`1<string> value);
    public virtual object Clone();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Build.StaticGlobalPropertiesProviderBase : ProjectValueDataSourceBase`1<IImmutableDictionary`2<string, string>> {
    private ITargetBlock`1<IProjectVersionedValue`1<IImmutableDictionary`2<string, string>>> targetBlock;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<IImmutableDictionary`2<string, string>>> publicBlock;
    [CompilerGeneratedAttribute]
private NamedIdentity <DataSourceKey>k__BackingField;
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IImmutableDictionary`2<string, string>>> SourceBlock { get; }
    protected StaticGlobalPropertiesProviderBase(IProjectCommonServices commonServices);
    [CompilerGeneratedAttribute]
public virtual NamedIdentity get_DataSourceKey();
    public virtual IComparable get_DataSourceVersion();
    public virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IImmutableDictionary`2<string, string>>> get_SourceBlock();
    public abstract virtual Task`1<IImmutableDictionary`2<string, string>> GetGlobalPropertiesAsync(CancellationToken cancellationToken);
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Build.StaticGlobalPropertiesProviderBase/<<Initialize>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task <Initialize>b__11_0();
}
internal enum Microsoft.VisualStudio.ProjectSystem.BulkFileOperationResumePriority : Enum {
    public int value__;
    public static BulkFileOperationResumePriority Low;
    public static BulkFileOperationResumePriority Meduim;
    public static BulkFileOperationResumePriority High;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.CapabilitiesExtensions : object {
    [ExtensionAttribute]
internal static IProjectCapabilitiesSnapshot GetEffectiveCapabilitiesSnapshot(IProjectCapabilitiesScope capabilitiesScope);
    [ExtensionAttribute]
public static bool Contains(IProjectCapabilitiesScope capabilitiesScope, string capability);
    [ExtensionAttribute]
public static bool CanSatisfy(IProjectCapabilitiesScope capabilitiesScope, IProjectCapabilitiesRequirements requirements);
    [ExtensionAttribute]
public static bool AppliesTo(IProjectCapabilitiesScope capabilitiesScope, string appliesToExpression);
    [ExtensionAttribute]
public static bool AppliesTo(IAppliesToMetadataView exportMetadata, IProjectCapabilitiesScope capabilitiesScope);
    [ExtensionAttribute]
public static bool AppliesTo(Lazy`2<T, TMetadata> lazyImport, IProjectCapabilitiesScope capabilitiesScope);
    [ExtensionAttribute]
internal static Lazy`1<T> FiltersWith(Lazy`2<T, IAppliesToMetadataView> value, IProjectCapabilitiesScope capabilitiesScope);
    [ExtensionAttribute]
internal static T FilteredValue(Lazy`2<T, IAppliesToMetadataView> value, IProjectCapabilitiesScope capabilitiesScope);
    [ExtensionAttribute]
internal static bool HasSameInheritedSnapshotsInstances(ProjectScopeCapabilitiesSnapshot snapshot1, ProjectScopeCapabilitiesSnapshot snapshot2);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CapabilitiesExtensions/<WaitConfiguredProjectCapabilitiesPublishedAsync>d__9")]
[ExtensionAttribute]
internal static Task WaitConfiguredProjectCapabilitiesPublishedAsync(UnconfiguredProject unconfiguredProject, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static string DumpRequirements(IProjectCapabilitiesRequirements requirements);
    [ExtensionAttribute]
internal static IImmutableSet`1<string> TryCollectAllCapabilities(IProjectCapabilitiesSnapshot snapshot);
    private static void ContributeCapabilities(IProjectCapabilitiesSnapshot snapshot, Builder<string> capabilitiesCollector);
    private static void ContributeCapabilities(IEnumerable`1<IProjectCapabilitiesSnapshot> snapshots, Builder<string> capabilitiesCollector);
    private static void ContributeCapabilities(IEnumerable`1<string> capabilities, Builder<string> capabilitiesCollector);
}
internal class Microsoft.VisualStudio.ProjectSystem.CapabilityExpressionParser : ValueType {
    private static string CapabilityExpressionParameterName;
    private Func`3<string, object, bool> symbolDefinedCheck;
    private object symbolDefinedCheckArgument;
    private Tokenizer tokenizer;
    private CapabilityExpressionParser(string expression, Func`3<string, object, bool> symbolDefinedCheck, object symbolDefinedCheckArgument);
    internal static bool Evaluate(string expression, Func`3<string, object, bool> symbolDefinedCheck, object symbolDefinedCheckArgument);
    private static bool IsSymbolCharacter(char ch);
    private bool OrTerm();
    private bool AndTerm();
    private bool Term();
    private bool Top();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ChainedProjectValueDataSourceBase`1 : ProjectValueDataSourceBase`1<T> {
    private IProjectLockService projectLockService;
    private IDisposable firstLink;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> publicBroadcastBlock;
    [CompilerGeneratedAttribute]
private NamedIdentity <DataSourceKey>k__BackingField;
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> SourceBlock { get; }
    protected UnconfiguredProject ContainingProject { get; }
    protected ChainedProjectValueDataSourceBase`1(IProjectCommonServices commonServices, bool synchronousDisposal, bool registerDataSource);
    [CompilerGeneratedAttribute]
public virtual NamedIdentity get_DataSourceKey();
    public virtual IComparable get_DataSourceVersion();
    public virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> get_SourceBlock();
    protected virtual UnconfiguredProject get_ContainingProject();
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual IDisposable LinkExternalInput(ITargetBlock`1<IProjectVersionedValue`1<T>> targetBlock);
}
public enum Microsoft.VisualStudio.ProjectSystem.ChangeEventStage : Enum {
    public int value__;
    public static ChangeEventStage Before;
    public static ChangeEventStage After;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.CollectionExtensions : object {
    [ExtensionAttribute]
public static bool AddRange(ISet`1<T> set, IEnumerable`1<T> elements);
    [ExtensionAttribute]
internal static T2 GetOrCreate(Dictionary`2<T1, T2> dictionary, T1 key, Func`1<T2> creator);
    [ExtensionAttribute]
internal static int IndexOf(IReadOnlyList`1<T> list, T item);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable`1<T> sequence, Int32& count);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable sequence, Int32& count);
    [ExtensionAttribute]
internal static Builder<TKey, TValue> AddTo(Builder<TKey, TValue> builder, TKey key, TValue value);
    [ExtensionAttribute]
internal static void SetAll(Dictionary`2<TKey, TValue> target, IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
internal static IEnumerable`1<TSource> Merge(IEnumerable`1<TSource> target, IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
internal static IEnumerable`1<TResult> Merge(IEnumerable`1<TSource> target, IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CollectionExtensions/<ReverseList>d__9`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> ReverseList(IList`1<T> list);
    [ExtensionAttribute]
internal static IReadOnlyDictionary`2<TKey, TValue> AsReadOnlyDictionary(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
internal static IReadOnlyCollection`1<T> AsReadOnly(ICollection`1<T> collection);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.CommandStatus : Enum {
    public int value__;
    public static CommandStatus NotSupported;
    public static CommandStatus Supported;
    public static CommandStatus Enabled;
    public static CommandStatus Latched;
    public static CommandStatus Ninched;
    public static CommandStatus Invisible;
}
public class Microsoft.VisualStudio.ProjectSystem.CommandStatusResult : ValueType {
    private static Task`1<CommandStatusResult> UnhandledTask;
    private bool handled;
    private string commandText;
    private CommandStatus status;
    private bool sharedInstance;
    public static CommandStatusResult Unhandled { get; }
    public bool Handled { get; public set; }
    public string CommandText { get; public set; }
    public CommandStatus Status { get; public set; }
    public CommandStatusResult(bool handled, string commandText, CommandStatus status);
    private static CommandStatusResult();
    public static CommandStatusResult get_Unhandled();
    public bool get_Handled();
    public void set_Handled(bool value);
    public string get_CommandText();
    public void set_CommandText(string value);
    public CommandStatus get_Status();
    public void set_Status(CommandStatus value);
    public Task`1<CommandStatusResult> AsTask();
    public sealed virtual bool Equals(CommandStatusResult other);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.CommonPlatformExtensionMethods : object {
    [ExtensionAttribute]
internal static ISet`1<T> AsReadOnly(ISet`1<T> set);
    [ExtensionAttribute]
internal static IReadOnlyCollection`1<T> AsReadOnlyCollection(ISet`1<T> set);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools : object {
    internal static string AppliesToIntentionallyInconsistent;
    internal static String[] EmptyStringArray;
    internal static ErrorReportSettings DefaultReportSettings;
    internal static Char[] SemicolonDelimiter;
    internal static Char[] CommaDelimiter;
    internal static string SynthesizedRuleIdentifier;
    private static Func`2<IProjectTree, bool> ProjectTreeChildrenFilter;
    private static Char[] DimensionNamesSeparator;
    private static string SynthesizedRuleBackupName;
    private static CommonProjectSystemTools();
    public static bool IsCapabilityMatch(string capabilityExpression, IImmutableSet`1<string> presentCapabilities);
    public static bool IsCapabilityMatch(string capabilityExpression, Func`3<string, object, bool> symbolDefinedCheck, object symbolDefinedCheckArgument);
    [ExtensionAttribute]
public static IDisposable LoadedProject(IProjectAsynchronousTasksService asyncTaskService);
    [ExtensionAttribute]
public static JoinableTask`1<T> LoadedProjectAsync(IProjectAsynchronousTasksService asyncTaskService, Func`1<Task`1<T>> action, bool registerFaultHandler);
    [ExtensionAttribute]
public static JoinableTask LoadedProjectAsync(IProjectAsynchronousTasksService asyncTaskService, Func`1<Task> action, bool registerFaultHandler);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<Lazy`2<T, IOrderPrecedenceMetadataView>> SortByImportPrecedence(IEnumerable`1<Lazy`2<T, IOrderPrecedenceMetadataView>> imports, PreferenceOrder orderingStyle);
    [ExtensionAttribute]
public static ProjectPropertiesContext ToContext(ProjectItem item, UnconfiguredProject unconfiguredProject);
    [ExtensionAttribute]
public static IProjectVersionedValue`1<TOut> Derive(IProjectVersionedValue`1<T> projectVersionedValue, Func`2<T, TOut> transform);
    [ExtensionAttribute]
internal static Rule GetSchema(IProjectCatalogSnapshot snapshot, string catalogName, string ruleName);
    [ExtensionAttribute]
internal static string GetEffectiveToolsVersion(IProjectService projectService, ProjectRootElement projectRootElement, ProjectCollection projectCollection);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<CreateHostObjectsAsync>d__19`1")]
[ExtensionAttribute]
internal static Task`1<IImmutableSet`1<IHostObject>> CreateHostObjectsAsync(IEnumerable`1<Lazy`2<IHostObjectProvider, TMetadata>> hostObjectProviders);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<ToListAsync>d__20`2")]
[ExtensionAttribute]
internal static Task`1<IReadOnlyList`1<TAfter>> ToListAsync(IReadOnlyCollection`1<TBefore> set, Func`3<TBefore, CancellationToken, Task`1<TAfter>> asyncTransform, CancellationToken cancellationToken);
    internal static IMinimalProjectConfiguration SynthesizeMinimalProjectConfiguration(string configuration, string platform);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<SynthesizeMinimalProjectConfigurationAsync>d__22")]
internal static Task`1<IMinimalProjectConfiguration> SynthesizeMinimalProjectConfigurationAsync(string hybridConfigName, IEnumerable`1<IProjectConfigurationDimensionsProvider> dimensionProviders, UnconfiguredProject unconfiguredProject);
    internal static ProjectConfiguration SynthesizeProjectConfiguration(string configuration, string platform);
    internal static ProjectConfiguration SynthesizeProjectConfiguration(string hybridConfigName);
    [ExtensionAttribute]
internal static string ComposeCanonicalName(ProjectConfiguration projectConfiguration);
    [ExtensionAttribute]
internal static string ComposeCanonicalName(IReadOnlyDictionary`2<string, string> configurationDimensions);
    internal static string ComposeConfigurationCanonicalName(string configuration, string platform);
    internal static void SplitCanonicalProjectConfigurationName(string projectConfigurationName, String& configurationName, String& platformName);
    [ExtensionAttribute]
internal static T FindHint(IImmutableDictionary`2<Guid, IImmutableSet`1<IProjectChangeHint>> hints, string file);
    [ExtensionAttribute]
internal static IProjectChangeFileHint FindHint(IImmutableDictionary`2<Guid, IImmutableSet`1<IProjectChangeHint>> hints, string file, Guid kind);
    [ExtensionAttribute]
internal static T Add(T hintMap, IProjectChangeHint hint);
    [ExtensionAttribute]
internal static Exception Rethrow(Exception ex);
    [ExtensionAttribute]
internal static void GetActiveConfigAndCancellationToken(IActiveConfiguredProjectProvider provider, ConfiguredProject& activeConfiguredProject, CancellationToken& cancellationToken);
    [ExtensionAttribute]
internal static bool IsAllowed(BuildStatus status);
    internal static bool IncrementCountOptimistically(TMap& refCountingMap, T value);
    internal static bool DecrementCountOptimistically(TMap& refCountingMap, T value);
    [ExtensionAttribute]
internal static void InvokeAllCollectingExceptions(EventHandler handlers, object sender, EventArgs args);
    [ExtensionAttribute]
internal static void InvokeAllCollectingExceptions(EventHandler`1<T> handlers, object sender, T args);
    [ExtensionAttribute]
internal static void InvokeAllCollectingExceptions(IEnumerable`1<EventHandler> handlers, object sender, EventArgs args);
    [ExtensionAttribute]
internal static T GetResultOrThrowFirstException(Task`1<T> task);
    [ExtensionAttribute]
internal static void InvokeAllCollectingExceptions(IEnumerable`1<EventHandler`1<T>> handlers, object sender, T args);
    [ExtensionAttribute]
internal static Task WhenAll(IEnumerable`1<T> data, Func`2<T, Task> asyncOperation);
    [ExtensionAttribute]
internal static Task WhenAll(IEnumerable`1<T> data, Func`3<T, TArg, Task> asyncOperation, TArg argument);
    [ExtensionAttribute]
internal static void DisposeIfNotNull(IDisposable value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<DisposeIfNotNullAsync>d__45")]
[ExtensionAttribute]
internal static Task DisposeIfNotNullAsync(IAsyncDisposable value);
    [ExtensionAttribute]
internal static void DisposeAllIfNotNull(IEnumerable`1<IDisposable> sequence, bool cacheSequence);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<DisposeAllIfNotNullAsync>d__47")]
[ExtensionAttribute]
internal static Task DisposeAllIfNotNullAsync(IEnumerable`1<IAsyncDisposable> sequence, bool cacheSequence);
    [ExtensionAttribute]
internal static bool WaitAllWithLooseStaSupport(WaitHandle[] handles, TimeSpan timeout);
    [ExtensionAttribute]
internal static int WaitAnyWithRetryLoop(WaitHandle[] handles);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<GetProjectConfigurationsWithDimensionAsync>d__50")]
[ExtensionAttribute]
internal static Task`1<IEnumerable`1<ProjectConfiguration>> GetProjectConfigurationsWithDimensionAsync(IProjectConfigurationsService projectConfigurationsService, string dimensionName, string dimensionValue);
    [ExtensionAttribute]
internal static IProjectPropertiesProvider GetProjectPropertiesProvider(IEnumerable`1<Lazy`2<IProjectPropertiesProvider, INamedExportMetadataView>> projectPropertiesProviders);
    [ExtensionAttribute]
internal static IProjectPropertiesProvider GetUserPropertiesProvider(IEnumerable`1<Lazy`2<IProjectPropertiesProvider, INamedExportMetadataView>> projectPropertiesProviders);
    [ExtensionAttribute]
internal static IProjectProperties GetProperties(IProjectPropertiesProvider provider, IProjectPropertiesContext context);
    [ExtensionAttribute]
internal static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    internal static T Cast(object valueToCast);
    internal static T FindFirstDuplicate(IEnumerable`1<T> sequence);
    internal static bool AreEquivalent(IReadOnlyDictionary`2<TKey, TValue> dictionary1, IReadOnlyDictionary`2<TKey, TValue> dictionary2, IEqualityComparer`1<TValue> valueComparer);
    internal static bool AreEquivalent(IDictionary`2<TKey, TValue> dictionary1, IDictionary`2<TKey, TValue> dictionary2, IEqualityComparer`1<TValue> valueComparer);
    internal static bool AreEquivalent(IImmutableDictionary`2<TKey, TValue> dictionary1, IImmutableDictionary`2<TKey, TValue> dictionary2);
    [ExtensionAttribute]
internal static T GetService(IServiceProvider serviceProvider);
    [ExtensionAttribute]
internal static int IndexOfSorted(IList`1<T> list, T element, IComparer`1<T> sort);
    [ExtensionAttribute]
internal static void ForEachAggregateExceptions(IEnumerable`1<T> sequence, Action`1<T> action);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CommonProjectSystemTools/<ForEachAggregateExceptionsAsync>d__63`1")]
[ExtensionAttribute]
internal static Task ForEachAggregateExceptionsAsync(IEnumerable`1<T> sequence, Func`2<T, Task> action);
    [ExtensionAttribute]
internal static int IndexOfSorted(IList`1<T> list, T element, Func`2<T, TKey> selector, IComparer`1<TKey> sort);
    internal static bool IsEnvironmentVariableSettingEnabled(string name, bool defaultValue);
    [ExtensionAttribute]
internal static string ExtractUserActionableMessage(Exception exception);
    [ExtensionAttribute]
internal static Exception ExtractInterestingException(AggregateException exception, bool preferNonInvalidOperationExceptions);
    internal static Rule SynthesizeEmptyRule(string itemType);
    internal static void WriteProjectTree(TextWriter writer, IProjectTree tree, bool includeItemIds, int indentation);
    internal static IImmutableDictionary`2<string, string> GetDefaultMetadata(IContentType contentType);
    [ExtensionAttribute]
internal static JoinableTaskCollection CreateCollection(JoinableTaskContextNode context, string displayName);
    [ExtensionAttribute]
internal static JoinableTaskCollection CreateCollection(JoinableTaskContextNode context, object owner);
    internal static bool IsPowerOfTwoOrZero(int i);
    internal static bool IsPowerOfTwo(int i);
    [ExtensionAttribute]
internal static bool IsIoRelatedException(Exception e);
    private static string GetString(ProjectImageMoniker imageMoniker);
    private static ImmutableDictionary`2<ErrorReportUIType, string> GetDefaultErrorReportSubmitUIOptions();
}
internal static class Microsoft.VisualStudio.ProjectSystem.CommonProperties : object {
    internal static string DebuggerSymbolsPathProperty;
    private static PropertySerializer CommonPropertySerializer;
    internal static PropertySerializer CommonTypeSerializer { get; }
    private static CommonProperties();
    internal static PropertySerializer get_CommonTypeSerializer();
    private static PropertySerializer InitializeCommonTypeSerializer();
}
internal static class Microsoft.VisualStudio.ProjectSystem.CommonSharedProjectFileCategoryName : object {
    public static string SharedItemsImports;
}
public enum Microsoft.VisualStudio.ProjectSystem.ConfigurationDimensionChange : Enum {
    public int value__;
    public static ConfigurationDimensionChange Add;
    public static ConfigurationDimensionChange Delete;
    public static ConfigurationDimensionChange Rename;
}
[AttributeUsageAttribute("452")]
[MetadataAttributeAttribute]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.ConfigurationDimensionDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DimensionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVariantDimension>k__BackingField;
    public string DimensionName { get; }
    public bool IsVariantDimension { get; }
    public ConfigurationDimensionDescriptionAttribute(string dimensionName, bool isVariantDimension);
    [CompilerGeneratedAttribute]
public string get_DimensionName();
    [CompilerGeneratedAttribute]
public bool get_IsVariantDimension();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.ConfiguredProject {
    public IComparable ProjectVersion { get; }
    public IReceivableSourceBlock`1<IComparable> ProjectVersionBlock { get; }
    public ProjectConfiguration ProjectConfiguration { get; }
    public IProjectCapabilitiesScope Capabilities { get; }
    public UnconfiguredProject UnconfiguredProject { get; }
    public IConfiguredProjectServices Services { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectUnloading(AsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectUnloading(AsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectChangedSynchronous(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectChangedSynchronous(EventHandler value);
    public abstract virtual IComparable get_ProjectVersion();
    public abstract virtual IReceivableSourceBlock`1<IComparable> get_ProjectVersionBlock();
    public abstract virtual ProjectConfiguration get_ProjectConfiguration();
    public abstract virtual IProjectCapabilitiesScope get_Capabilities();
    public abstract virtual UnconfiguredProject get_UnconfiguredProject();
    public abstract virtual IConfiguredProjectServices get_Services();
    public abstract virtual void NotifyProjectChange();
}
[AttributeUsageAttribute("64")]
[MetadataAttributeAttribute]
[ProjectSystemContractAttribute("2", "2")]
public class Microsoft.VisualStudio.ProjectSystem.ConfiguredProjectAutoLoadAttribute : ExportAttribute {
    internal static string ContractName;
    [CompilerGeneratedAttribute]
private bool <RequiresUIThread>k__BackingField;
    public bool RequiresUIThread { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RequiresUIThread();
    [CompilerGeneratedAttribute]
public void set_RequiresUIThread(bool value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ConfiguredProjectCacheOptions : Enum {
    public int value__;
    public static ConfiguredProjectCacheOptions None;
    public static ConfiguredProjectCacheOptions InvalidateOnAllGlobalPropertyChanges;
    public static ConfiguredProjectCacheOptions ValueFactoryRequiresUpgradeableRead;
    public static ConfiguredProjectCacheOptions DoNotHoldLockForValueFactoryCompletion;
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ConfiguredProjectCapabilitiesProviderBase : ProjectCapabilitiesProviderBase {
    [CompilerGeneratedAttribute]
private ConfiguredProject <ConfiguredProject>k__BackingField;
    [ImportAttribute]
protected ConfiguredProject ConfiguredProject { get; private set; }
    protected ConfiguredProjectCapabilitiesProviderBase(string name, ConfiguredProject configuredProject);
    [CompilerGeneratedAttribute]
protected ConfiguredProject get_ConfiguredProject();
    [CompilerGeneratedAttribute]
private void set_ConfiguredProject(ConfiguredProject value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ConfiguredProjectCapabilitiesProviderBase/<InitializeCoreAsync>d__5")]
protected virtual Task InitializeCoreAsync(CancellationToken cancellationToken);
    protected virtual Task DisposeCoreAsync(bool initialized);
    private void ConfiguredProject_ProjectChangedSynchronous(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.ProjectSystem.ConfiguredProjectInternal {
    public IComparable ConfiguredProjectIdentity { get; }
    public IReadOnlyCollection`1<BuildEventArgs> LatestEvaluationMessages { get; }
    public long ProjectEvaluationTime { get; }
    public abstract virtual IComparable get_ConfiguredProjectIdentity();
    public abstract virtual IReadOnlyCollection`1<BuildEventArgs> get_LatestEvaluationMessages();
    public abstract virtual long get_ProjectEvaluationTime();
    public abstract virtual void ReportEvaluationVersion(IComparable projectVersion, int evaluationVersion);
    public abstract virtual Task`1<Project> GetPrivateMSBuildProjectAsync();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.CopyPasteOperations : Enum {
    public int value__;
    public static CopyPasteOperations None;
    public static CopyPasteOperations Copy;
    public static CopyPasteOperations Cut;
    public static CopyPasteOperations Drag;
    public static CopyPasteOperations All;
}
[EditorBrowsableAttribute("1")]
public abstract class Microsoft.VisualStudio.ProjectSystem.CoreProjectTreeProviderBase : OnceInitializedOnceDisposed {
    public static string VirtualPathPrefix;
    private DisposableBag disposableBag;
    private ITargetBlock`1<TreeUpdateSubmission> treeUpdateSubmissionBlock;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> treeBlockPublic;
    private long treeGenerationNumber;
    private IImmutableDictionary`2<NamedIdentity, IComparable> lastSubmittedSourceVersions;
    private JoinableTaskCollection joinableTaskCollection;
    private JoinableTaskFactory joinableTaskFactory;
    [CompilerGeneratedAttribute]
private IProjectService <ProjectService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFaultHandlerService <ProjectFaultHandlerService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectLockService <ProjectLockService>k__BackingField;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectThreadingService <ThreadingService>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreConfiguredProjectExports <TreeUpdateCoreConfiguredProjectExports>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreConfiguredProjectExports <CurrentCoreConfiguredProjectExports>k__BackingField;
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> Tree { get; }
    protected NamedIdentity DataSourceKey { get; }
    private NamedIdentity Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.DataSourceKey { get; }
    private IComparable Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.DataSourceVersion { get; }
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource<Microsoft.VisualStudio.ProjectSystem.IProjectTreeSnapshot>.SourceBlock { get; }
    private ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.SourceBlock { get; }
    protected internal long TreeGeneration { get; }
    [ImportAttribute]
protected IProjectService ProjectService { get; private set; }
    [ImportAttribute]
protected IProjectFaultHandlerService ProjectFaultHandlerService { get; private set; }
    [ImportAttribute]
protected IProjectLockService ProjectLockService { get; private set; }
    protected UnconfiguredProject UnconfiguredProject { get; }
    protected IProjectTreeFactory TreeFactory { get; }
    [ImportAttribute]
protected IProjectThreadingService ThreadingService { get; private set; }
    protected JoinableTaskFactory JoinableTaskFactory { get; }
    [EditorBrowsableAttribute("2")]
protected CancellationToken DefaultCancellationToken { get; }
    protected bool OriginalTreeGenerated { get; }
    [EditorBrowsableAttribute("1")]
protected CoreConfiguredProjectExports TreeUpdateCoreConfiguredProjectExports { get; private set; }
    [EditorBrowsableAttribute("1")]
protected CoreConfiguredProjectExports CurrentCoreConfiguredProjectExports { get; }
    protected CoreProjectTreeProviderBase(IProjectThreadingService threadingService, UnconfiguredProject unconfiguredProject);
    public sealed virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> get_Tree();
    protected virtual NamedIdentity get_DataSourceKey();
    private sealed virtual override NamedIdentity Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.get_DataSourceKey();
    private sealed virtual override IComparable Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.get_DataSourceVersion();
    private sealed virtual override IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource<Microsoft.VisualStudio.ProjectSystem.IProjectTreeSnapshot>.get_SourceBlock();
    private sealed virtual override ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.get_SourceBlock();
    protected internal long get_TreeGeneration();
    [CompilerGeneratedAttribute]
protected IProjectService get_ProjectService();
    [CompilerGeneratedAttribute]
private void set_ProjectService(IProjectService value);
    [CompilerGeneratedAttribute]
protected IProjectFaultHandlerService get_ProjectFaultHandlerService();
    [CompilerGeneratedAttribute]
private void set_ProjectFaultHandlerService(IProjectFaultHandlerService value);
    [CompilerGeneratedAttribute]
protected IProjectLockService get_ProjectLockService();
    [CompilerGeneratedAttribute]
private void set_ProjectLockService(IProjectLockService value);
    [CompilerGeneratedAttribute]
protected UnconfiguredProject get_UnconfiguredProject();
    protected abstract virtual IProjectTreeFactory get_TreeFactory();
    [CompilerGeneratedAttribute]
protected IProjectThreadingService get_ThreadingService();
    [CompilerGeneratedAttribute]
private void set_ThreadingService(IProjectThreadingService value);
    protected JoinableTaskFactory get_JoinableTaskFactory();
    protected virtual CancellationToken get_DefaultCancellationToken();
    protected virtual bool get_OriginalTreeGenerated();
    [CompilerGeneratedAttribute]
protected CoreConfiguredProjectExports get_TreeUpdateCoreConfiguredProjectExports();
    [CompilerGeneratedAttribute]
private void set_TreeUpdateCoreConfiguredProjectExports(CoreConfiguredProjectExports value);
    [CompilerGeneratedAttribute]
protected virtual CoreConfiguredProjectExports get_CurrentCoreConfiguredProjectExports();
    public virtual IProjectTree FindByPath(IProjectTree root, string path);
    public virtual string GetPath(IProjectTree node);
    public virtual Task`1<bool> CanRenameAsync(IProjectTree node);
    public virtual Task RenameAsync(IProjectTree node, string value);
    public virtual bool CanCopy(IImmutableSet`1<IProjectTree> nodes, IProjectTree receiver, bool deleteOriginal);
    public virtual bool CanRemove(IImmutableSet`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public virtual Task RemoveAsync(IImmutableSet`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public virtual string GetAddNewItemDirectory(IProjectTree target);
    private sealed virtual override IDisposable Microsoft.VisualStudio.ProjectSystem.IJoinableProjectValueDataSource.Join();
    private string GetDiagnosticName();
    protected void JoinUpstreamDataSources(IJoinableProjectValueDataSource[] sources);
    [EditorBrowsableAttribute("1")]
protected virtual Task`1<CoreConfiguredProjectExports> RetrieveConfiguredProjectExportsIfRequiredAsync();
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    internal Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateCoreAsync(TreeUpdateAsyncDelegate treeTransformation, IImmutableDictionary`2<NamedIdentity, IComparable> updatedSources, TreeSubmissionOptions options, Int64& generationNumber, CancellationToken cancellationToken);
    protected void Fault(Exception exception);
    [EditorBrowsableAttribute("1")]
protected virtual Task`1<IProjectTree> PrepublishMutationAsync(IProjectVersionedValue`1<IProjectTreeSnapshot> priorTree, IProjectVersionedValue`1<IProjectTreeSnapshot> tree, CoreConfiguredProjectExports activeConfiguredProject, CancellationToken cancellationToken);
    protected IProjectTree NewTree(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags);
    protected IProjectTree2 NewTree(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, int displayOrder);
    protected IProjectTree NewTree(string caption, IEnumerable`1<IProjectTree> children, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags);
    protected IProjectTree2 NewTree(string caption, IEnumerable`1<IProjectTree> children, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, int displayOrder);
    protected IProjectItemTree NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked);
    protected IProjectItemTree2 NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked, int displayOrder);
    protected IProjectItemTree NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IEnumerable`1<IProjectTree> children, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked);
    protected IProjectItemTree2 NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IEnumerable`1<IProjectTree> children, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked, int displayOrder);
    [ConditionalAttribute("DEBUG")]
protected virtual void VerifyValidTree(IProjectTree tree, IProjectTree oldTree);
    private Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateHelperAsync(TreeUpdateAsyncDelegate treeTransformation, IImmutableDictionary`2<NamedIdentity, IComparable> updatedSources, TreeSubmissionOptions options, Int64& generationNumber, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("<{ItemType} Include={EvaluatedInclude} />")]
internal class Microsoft.VisualStudio.ProjectSystem.CpsProjectItem`1 : object {
    private ProjectItemProviderBase`1<TProjectItemInterface> provider;
    private string evaluatedIncludeAsFullPath;
    private IProjectProperties metadata;
    private bool fileSystemItem;
    private object syncObject;
    [CompilerGeneratedAttribute]
private string <UnevaluatedInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectPropertiesContext <PropertiesContext>k__BackingField;
    public string ItemType { get; }
    public string UnevaluatedInclude { get; private set; }
    public string EvaluatedInclude { get; }
    public string EvaluatedIncludeAsFullPath { get; }
    public string EvaluatedIncludeAsRelativePath { get; }
    public IProjectPropertiesContext PropertiesContext { get; private set; }
    public IProjectProperties Metadata { get; }
    internal CpsProjectItem`1(ProjectItemProviderBase`1<TProjectItemInterface> provider, ProjectItem item, bool fileSystemItem);
    internal CpsProjectItem`1(ProjectItemProviderBase`1<TProjectItemInterface> provider, ITaskItem item, bool fileSystemItem);
    public sealed virtual string get_ItemType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_UnevaluatedInclude();
    [CompilerGeneratedAttribute]
private void set_UnevaluatedInclude(string value);
    public sealed virtual string get_EvaluatedInclude();
    public sealed virtual string get_EvaluatedIncludeAsFullPath();
    public sealed virtual string get_EvaluatedIncludeAsRelativePath();
    [CompilerGeneratedAttribute]
public sealed virtual IProjectPropertiesContext get_PropertiesContext();
    [CompilerGeneratedAttribute]
private void set_PropertiesContext(IProjectPropertiesContext value);
    public sealed virtual IProjectProperties get_Metadata();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CpsProjectItem`1/<SetItemTypeAsync>d__25")]
public sealed virtual Task SetItemTypeAsync(string value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.CpsProjectItem`1/<SetUnevaluatedIncludeAsync>d__26")]
public sealed virtual Task SetUnevaluatedIncludeAsync(string value);
    public sealed virtual Task RemoveAsync(DeleteOptions deleteOptions);
    internal void ResetMsbuildProjectItem(ProjectItem projectItem);
    protected internal ProjectItem FindItem(Project project);
    private void InitializePropertiesContext(ProjectItem item);
    private void InitializePropertiesContext(ProjectItemElement itemElement);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.DataflowExtensions : object {
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<IProjectVersionedValue`1<IProjectBuildSnapshot>> snapshotBlock, ITargetBlock`1<IProjectVersionedValue`1<IProjectBuildSnapshot>> target, DataflowLinkOptions linkOptions, String[] buildTargets);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<IProjectVersionedValue`1<IProjectBuildSnapshot>> snapshotBlock, ITargetBlock`1<IProjectVersionedValue`1<IProjectBuildSnapshot>> target, DataflowLinkOptions linkOptions, IEnumerable`1<string> buildTargets);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> differencingSnapshotBlock, ITargetBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> target, DataflowLinkOptions linkOptions, bool initialDataAsNew, bool suppressVersionOnlyUpdates, String[] ruleNames);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> differencingSnapshotBlock, ITargetBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> target, DataflowLinkOptions linkOptions, bool initialDataAsNew, bool suppressVersionOnlyUpdates, IEnumerable`1<string> ruleNames);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> differencingSnapshotBlock, ITargetBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> target, ISourceBlock`1<IProjectVersionedValue`1<IImmutableSet`1<string>>> ruleNamesBlock, DataflowLinkOptions linkOptions, bool initialDataAsNew, bool suppressVersionOnlyUpdates);
    [ExtensionAttribute]
public static ITargetBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> AsBlock(Action`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> action, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
public static ITargetBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> AsAsyncBlock(Func`2<IProjectVersionedValue`1<IProjectSubscriptionUpdate>, Task> action, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
public static ExportLifetimeContext`1<BroadcastBlock`1<TTarget>> CreateProjectTransformBroadcastBlock(ISourceBlock`1<TSource> sourceBlock, Func`2<TSource, Task`1<TTarget>> production, ExecutionDataflowBlockOptions transformBlockOptions, Func`2<TTarget, TTarget> cloningFunction);
    [ExtensionAttribute]
public static IReceivableSourceBlock`1<T> SafePublicize(IReceivableSourceBlock`1<T> block);
    [ExtensionAttribute]
public static IReceivableSourceBlock`1<T> SafePublicize(IReceivableSourceBlock`1<T> block, string name);
    internal static Func`2<TInput, Task> CaptureAndApplyExecutionContext(Func`2<TInput, Task> function);
    internal static Func`2<TInput, Task`1<TOutput>> CaptureAndApplyExecutionContext(Func`2<TInput, Task`1<TOutput>> function);
    internal static Func`1<TOutput> CaptureAndApplyExecutionContext(Func`1<TOutput> function);
    [ExtensionAttribute]
internal static bool PostWithoutPropagatingContext(ITargetBlock`1<T> target, T message, IProjectLockService projectLockService);
    [ExtensionAttribute]
internal static ITargetBlock`1<T> AsBlock(Action`1<T> action, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
internal static IDisposable LinkTo(ISourceBlock`1<T> source, Action`1<T> action, DataflowLinkOptions linkOptions, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
internal static IDisposable LinkToPropagateFaults(ISourceBlock`1<T> sourceBlock, ITargetBlock`1<T> targetBlock);
    [ExtensionAttribute]
internal static IReceivableSourceBlock`1<T> SafePublicize(IReceivableSourceBlock`1<T> block, ISourceBlock`1<TForward> forwardLinksTo);
    internal static IProjectVersionedValue`1<IProjectSubscriptionUpdate> SmoothDisruptionDiff(IProjectVersionedValue`1<IProjectSubscriptionUpdate> input, IProjectVersionedValue`1<IProjectSubscriptionUpdate> mostRecentReceivedMessage);
    private static bool AreSameRuleSnapshots(IProjectRuleSnapshot ruleSnapshot1, IProjectRuleSnapshot ruleSnapshot2);
    internal static IPropagatorBlock`2<IProjectVersionedValue`1<IProjectSubscriptionUpdate>, IProjectVersionedValue`1<IProjectSubscriptionUpdate>> CreateDisruptionDiffSmoothingTransformBlock();
    [ExtensionAttribute]
internal static IDisposable LinkToChanges(ISourceBlock`1<T> source, Action`1<Tuple`2<T, T>> receiver, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
internal static void CompleteIfNotNull(ISourceBlock`1<T> block);
    internal static TransformManyBlock`2<TIn, TOut> CreateSelfFilteringTransformBlock(Func`2<TIn, KeyValuePair`2<TOut, bool>> transform, ExecutionDataflowBlockOptions blockOptions);
    internal static TransformManyBlock`2<TIn, TOut> CreateSelfFilteringTransformBlock(Func`2<TIn, Task`1<KeyValuePair`2<TOut, bool>>> transform, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
internal static DisposableValue`1<ISourceBlock`1<TOut>> Transform(ISourceBlock`1<TIn> source, Func`2<TIn, TOut> transform, ExecutionDataflowBlockOptions blockOptions);
    [ExtensionAttribute]
internal static DataflowLinkOptions Clone(DataflowLinkOptions linkOptions);
    [ExtensionAttribute]
internal static ExportLifetimeContext`1<IReceivableSourceBlock`1<T>> CreateLinkedRemoveVersionTransform(IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> sourceBlock);
    [ExtensionAttribute]
internal static Task HandleFaultedCompletionAsync(IDataflowBlock block, IProjectFaultHandlerService faultService, ProjectFaultSeverity severity, UnconfiguredProject project);
    internal static ImmutableHashSet`1<Exception> CollectTaskFaults(IEnumerable`1<Task> tasks);
    private static bool TryFindMinimum(T[] values, IComparer`1<T> comparer, Int32& minimumIndex);
    [ExtensionAttribute]
private static void ApplyLinkOptionsIfNotNullTo(DataflowLinkOptions template, DataflowLinkOptions receiver);
}
public static class Microsoft.VisualStudio.ProjectSystem.Debug.DebuggerEngines : object {
    public static Guid ManagedLegacyEngine;
    public static Guid SqlEngine;
    public static Guid NativeOnlyEngine;
    public static Guid ManagedOnlyEngine;
    public static Guid MixedNativeAndManagedEngine;
    public static Guid ScriptEngine;
    public static Guid GPUDebugEngine;
    public static Guid ManagedCoreEngine;
    private static DebuggerEngines();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Debug.DebuggerEngines/<GetDebugEngineAsync>d__8")]
public static Task`1<Guid> GetDebugEngineAsync(DebuggerType debuggerType, Lazy`1<IDebuggerImageTypeService> clrTypeService, string gpuDebuggerEngine);
}
public enum Microsoft.VisualStudio.ProjectSystem.Debug.DebuggerType : Enum {
    public int value__;
    public static DebuggerType NativeOnly;
    public static DebuggerType ManagedOnly;
    public static DebuggerType Mixed;
    public static DebuggerType Auto;
    public static DebuggerType Script;
    public static DebuggerType GPUOnly;
    public static DebuggerType NativeWithScript;
    public static DebuggerType ManagedCore;
    public static DebuggerType NativeWithManagedCore;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.Debug.DebugLaunchOptions : Enum {
    public int value__;
    public static DebugLaunchOptions Silent;
    public static DebugLaunchOptions LocalDeploy;
    public static DebugLaunchOptions NoDebug;
    public static DebugLaunchOptions DetachOnStop;
    public static DebugLaunchOptions Selected;
    public static DebugLaunchOptions StopDebuggingOnEnd;
    public static DebugLaunchOptions WaitForAttachComplete;
    public static DebugLaunchOptions MergeEnvironment;
    public static DebugLaunchOptions DesignTimeExpressionEvaluation;
    public static DebugLaunchOptions StopAtEntryPoint;
    public static DebugLaunchOptions CannotDebugAlone;
    public static DebugLaunchOptions WaitForEvent;
    public static DebugLaunchOptions UseDefaultBrowser;
    public static DebugLaunchOptions PrepForDebug;
    public static DebugLaunchOptions TerminateOnStop;
    public static DebugLaunchOptions BreakOneProcess;
    public static DebugLaunchOptions BlockCredentialsDialog;
    public static DebugLaunchOptions BlockWWSDialog;
    public static DebugLaunchOptions StartInSimulator;
    public static DebugLaunchOptions AllowEventsAfterStopped;
    public static DebugLaunchOptions Force32BitDebug;
    public static DebugLaunchOptions Force64BitDebug;
    public static DebugLaunchOptions ContainsStartupTask;
    public static DebugLaunchOptions Profiling;
    public static DebugLaunchOptions IntegratedConsole;
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.Debug.ExportDebuggerAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <DebuggerName>k__BackingField;
    public string DebuggerName { get; private set; }
    public ExportDebuggerAttribute(string debuggerName);
    [CompilerGeneratedAttribute]
public string get_DebuggerName();
    [CompilerGeneratedAttribute]
private void set_DebuggerName(string value);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDebuggerImageTypeService {
    public ImageClrType TargetImageClrType { get; }
    public string PackageMoniker { get; }
    public string AppUserModelID { get; }
    public abstract virtual ImageClrType get_TargetImageClrType();
    public abstract virtual string get_PackageMoniker();
    public abstract virtual string get_AppUserModelID();
    public abstract virtual Task`1<bool> GetIs64BitAsync();
    public abstract virtual Task`1<bool> GetIsConsoleAppAsync();
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDebugLaunchProvider {
    public abstract virtual Task`1<bool> CanLaunchAsync(DebugLaunchOptions launchOptions);
    public abstract virtual Task LaunchAsync(DebugLaunchOptions launchOptions);
}
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDebugLaunchProviderMetadataView {
    public string DebuggerName { get; }
    public abstract virtual string get_DebuggerName();
}
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDebugLaunchProviderValidation {
    public abstract virtual Task`1<bool> ValidatePropertiesAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDeployedProjectItemMappingProvider {
    public abstract virtual bool TryGetProjectItemPathFromDeployedPath(string deployedPath, String& localPath);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Debug.IDynamicDebugTargetsGenerator {
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Debug.ILocalDebuggerPathContributor {
    public ICollection`1<string> AdditionalDirectoriesForSearchPath { get; }
    public abstract virtual ICollection`1<string> get_AdditionalDirectoriesForSearchPath();
}
public enum Microsoft.VisualStudio.ProjectSystem.Debug.ImageClrType : Enum {
    public int value__;
    public static ImageClrType Native;
    public static ImageClrType Mixed;
    public static ImageClrType Managed;
}
public class Microsoft.VisualStudio.ProjectSystem.DefaultCommandStatusAggregator : object {
    private bool supported;
    private bool enabled;
    private bool invisible;
    private bool latched;
    public CommandStatus Result { get; }
    public CommandStatus get_Result();
    public void Reset();
    public void AggregateStatus(CommandStatus status);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.DeleteOptions : Enum {
    public int value__;
    public static DeleteOptions None;
    public static DeleteOptions DeleteFromStorage;
    public static DeleteOptions DeleteIsPartOfMoveOperation;
}
internal class Microsoft.VisualStudio.ProjectSystem.DictionaryEqualityComparer`2 : object {
    private static DictionaryEqualityComparer`2<TKey, TValue> defaultInstance;
    internal static IEqualityComparer`1<IImmutableDictionary`2<TKey, TValue>> Instance { get; }
    private static DictionaryEqualityComparer`2();
    internal static IEqualityComparer`1<IImmutableDictionary`2<TKey, TValue>> get_Instance();
    public sealed virtual bool Equals(IImmutableDictionary`2<TKey, TValue> x, IImmutableDictionary`2<TKey, TValue> y);
    public sealed virtual int GetHashCode(IImmutableDictionary`2<TKey, TValue> obj);
}
internal class Microsoft.VisualStudio.ProjectSystem.DisposableBag : object {
    private CancellationTokenSource cts;
    private CancellationTokenRegistration autoDisposeRegistration;
    private CancellationToken cancellationToken;
    private ImmutableHashSet`1<IDisposable> disposables;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public CancellationToken CancellationToken { get; }
    public DisposableBag(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddDisposable(IDisposable disposable);
    public void AddDisposables(IEnumerable`1<IDisposable> disposables);
    public void RemoveDisposable(IDisposable disposable);
}
public class Microsoft.VisualStudio.ProjectSystem.DisposableValue`1 : object {
    private IDisposable disposableValue;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; private set; }
    public DisposableValue`1(T value, IDisposable disposableValue);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.ProjectSystem.DisposeAction : object {
    private Action disposeAction;
    internal DisposeAction(Action disposeAction);
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.DropEffects : Enum {
    public int value__;
    public static DropEffects None;
    public static DropEffects Copy;
    public static DropEffects Move;
    public static DropEffects Link;
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.DualOrderPrecedenceImporter`1 : DualOrderPrecedenceImporter`2<IProjectValueDataSource`1<TValue>, TValue> {
    public DualOrderPrecedenceImporter`1(UnconfiguredProject unconfiguredProject, PreferenceOrder preferenceOrder);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.DualOrderPrecedenceImporter`2 : ChainedProjectValueDataSourceBase`1<IImmutableList`1<TValue>> {
    private DynamicOrderPrecedenceImporter`2<TValue, IOrderPrecedenceMetadataView> innerImporter;
    private DynamicOrderPrecedenceDataSourceImporter`3<T, TValue, IOrderPrecedenceMetadataView> innerDataSourceImporter;
    private PreferenceOrder preferenceOrder;
    private IImmutableList`1<TValue> latestData;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    protected UnconfiguredProject ContainingProject { get; }
    private UnconfiguredProject UnconfiguredProject { get; }
    protected ICollection`1<Lazy`2<T, IOrderPrecedenceMetadataView>> DataSourceImports { get; }
    protected ICollection`1<Lazy`2<TValue, IOrderPrecedenceMetadataView>> SimpleImports { get; }
    public DualOrderPrecedenceImporter`2(UnconfiguredProject unconfiguredProject, PreferenceOrder preferenceOrder);
    protected virtual UnconfiguredProject get_ContainingProject();
    [CompilerGeneratedAttribute]
private UnconfiguredProject get_UnconfiguredProject();
    protected abstract virtual ICollection`1<Lazy`2<T, IOrderPrecedenceMetadataView>> get_DataSourceImports();
    protected abstract virtual ICollection`1<Lazy`2<TValue, IOrderPrecedenceMetadataView>> get_SimpleImports();
    protected virtual IDisposable LinkExternalInput(ITargetBlock`1<IProjectVersionedValue`1<IImmutableList`1<TValue>>> targetBlock);
    private IImmutableList`1<TValue> Merge(IReadOnlyCollection`1<Lazy`2<TValue, IOrderPrecedenceMetadataView>> source1, IReadOnlyCollection`1<Tuple`2<TValue, IOrderPrecedenceMetadataView>> source2);
    private int CompareOrder(int item1Order, int item2Order);
    [CompilerGeneratedAttribute]
private ICollection`1<Lazy`2<TValue, IOrderPrecedenceMetadataView>> <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private ICollection`1<Lazy`2<T, IOrderPrecedenceMetadataView>> <.ctor>b__4_1();
    [CompilerGeneratedAttribute]
private IProjectVersionedValue`1<IImmutableList`1<TValue>> <LinkExternalInput>b__14_0(IProjectVersionedValue`1<Tuple`2<IReadOnlyCollection`1<Lazy`2<TValue, IOrderPrecedenceMetadataView>>, IReadOnlyCollection`1<Tuple`2<TValue, IOrderPrecedenceMetadataView>>>> data);
}
internal class Microsoft.VisualStudio.ProjectSystem.DynamicOrderPrecedenceDataSourceImporter`1 : DynamicOrderPrecedenceDataSourceImporter`2<TValue, IOrderPrecedenceMetadataView> {
    public DynamicOrderPrecedenceDataSourceImporter`1(UnconfiguredProject unconfiguredProject, Func`1<ICollection`1<Lazy`2<IProjectValueDataSource`1<TValue>, IOrderPrecedenceMetadataView>>> getImports);
    public DynamicOrderPrecedenceDataSourceImporter`1(ConfiguredProject configuredProject, Func`1<ICollection`1<Lazy`2<IProjectValueDataSource`1<TValue>, IOrderPrecedenceMetadataView>>> getImports);
}
internal class Microsoft.VisualStudio.ProjectSystem.DynamicOrderPrecedenceDataSourceImporter`2 : DynamicOrderPrecedenceDataSourceImporter`3<IProjectValueDataSource`1<TValue>, TValue, TMetadata> {
    public DynamicOrderPrecedenceDataSourceImporter`2(UnconfiguredProject unconfiguredProject, Func`1<ICollection`1<Lazy`2<IProjectValueDataSource`1<TValue>, TMetadata>>> getImports);
    public DynamicOrderPrecedenceDataSourceImporter`2(ConfiguredProject configuredProject, Func`1<ICollection`1<Lazy`2<IProjectValueDataSource`1<TValue>, TMetadata>>> getImports);
}
internal class Microsoft.VisualStudio.ProjectSystem.DynamicOrderPrecedenceDataSourceImporter`3 : ChainedProjectValueDataSourceBase`1<IReadOnlyCollection`1<Tuple`2<TValue, TMetadata>>> {
    private DynamicOrderPrecedenceImporter`2<T, TMetadata> innerImporter;
    private NamedIdentity dataSourceKey;
    private int dataSourceVersion;
    private List`1<TMetadata> importedMetadata;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <ContainingProject>k__BackingField;
    protected UnconfiguredProject ContainingProject { get; }
    public DynamicOrderPrecedenceDataSourceImporter`3(UnconfiguredProject unconfiguredProject, Func`1<ICollection`1<Lazy`2<T, TMetadata>>> getImports);
    public DynamicOrderPrecedenceDataSourceImporter`3(ConfiguredProject configuredProject, Func`1<ICollection`1<Lazy`2<T, TMetadata>>> getImports);
    [CompilerGeneratedAttribute]
protected virtual UnconfiguredProject get_ContainingProject();
    protected virtual IDisposable LinkExternalInput(ITargetBlock`1<IProjectVersionedValue`1<IReadOnlyCollection`1<Tuple`2<TValue, TMetadata>>>> targetBlock);
}
public class Microsoft.VisualStudio.ProjectSystem.DynamicOrderPrecedenceImporter`1 : DynamicOrderPrecedenceImporter`2<T, IOrderPrecedenceMetadataView> {
    public DynamicOrderPrecedenceImporter`1(UnconfiguredProject unconfiguredProject, Func`1<ICollection`1<Lazy`2<T, IOrderPrecedenceMetadataView>>> getImports);
    public DynamicOrderPrecedenceImporter`1(ConfiguredProject configuredProject, Func`1<ICollection`1<Lazy`2<T, IOrderPrecedenceMetadataView>>> getImports);
}
public class Microsoft.VisualStudio.ProjectSystem.DynamicOrderPrecedenceImporter`2 : ChainedProjectValueDataSourceBase`1<IReadOnlyCollection`1<Lazy`2<T, TMetadata>>> {
    private Func`1<ICollection`1<Lazy`2<T, TMetadata>>> getImports;
    private List`1<Lazy`2<T, TMetadata>> latestValues;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfiguredProject <ConfiguredProject>k__BackingField;
    private UnconfiguredProject UnconfiguredProject { get; private set; }
    private ConfiguredProject ConfiguredProject { get; private set; }
    protected UnconfiguredProject ContainingProject { get; }
    private IProjectCapabilitiesScope Capabilities { get; }
    public DynamicOrderPrecedenceImporter`2(UnconfiguredProject unconfiguredProject, Func`1<ICollection`1<Lazy`2<T, TMetadata>>> getImports);
    public DynamicOrderPrecedenceImporter`2(ConfiguredProject configuredProject, Func`1<ICollection`1<Lazy`2<T, TMetadata>>> getImports);
    [CompilerGeneratedAttribute]
private UnconfiguredProject get_UnconfiguredProject();
    [CompilerGeneratedAttribute]
private void set_UnconfiguredProject(UnconfiguredProject value);
    [CompilerGeneratedAttribute]
private ConfiguredProject get_ConfiguredProject();
    [CompilerGeneratedAttribute]
private void set_ConfiguredProject(ConfiguredProject value);
    protected virtual UnconfiguredProject get_ContainingProject();
    private IProjectCapabilitiesScope get_Capabilities();
    protected virtual ICollection`1<Lazy`2<T, TMetadata>> GetImports();
    protected virtual IDisposable LinkExternalInput(ITargetBlock`1<IProjectVersionedValue`1<IReadOnlyCollection`1<Lazy`2<T, TMetadata>>>> targetBlock);
    private ProjectCapabilitiesContext CreateIsolatedContext(IProjectCapabilitiesSnapshot capabilities);
    [CompilerGeneratedAttribute]
private IProjectVersionedValue`1<IReadOnlyCollection`1<Lazy`2<T, TMetadata>>> <LinkExternalInput>b__17_0(IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> capabilities);
}
public static class Microsoft.VisualStudio.ProjectSystem.Empty : object {
    public static ImmutableHashSet`1<string> OrdinalStringSet;
    public static ImmutableHashSet`1<string> OrdinalIgnoreCaseStringSet;
    public static ImmutableHashSet`1<string> FileSet;
    public static ImmutableDictionary`2<string, string> FileToFileMap;
    public static ImmutableDictionary`2<Rule, string> RuleToContextMap;
    public static ImmutableDictionary`2<string, string> PropertiesMap;
    public static ImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> ItemsMap;
    public static ImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> FileItemsMap;
    public static ImmutableList`1<string> TargetsList;
    public static ImmutableHashSet`1<Rule> RuleSet;
    public static ImmutableHashSet`1<string> TargetsSet;
    public static ImmutableHashSet`1<string> CapabilitiesSet;
    public static ImmutableDictionary`2<string, IProjectRuleSnapshot> RuleSnapshotMap;
    public static ImmutableDictionary`2<string, IProjectChangeDescription> RuleChangeMap;
    public static ImmutableDictionary`2<NamedIdentity, IComparable> ProjectValueVersions;
    public static IImmutableDictionary`2<string, IImmutableList`1<KeyValuePair`2<string, IImmutableDictionary`2<string, string>>>> BuildResultItemsByTarget;
    public static IImmutableDictionary`2<string, bool> BuildSuccessByTarget;
    internal static String[] StringArray;
    internal static ImmutableDictionary`2<string, DateTime> FileTimes;
    private static Empty();
}
public enum Microsoft.VisualStudio.ProjectSystem.ErrorDumpType : Enum {
    public int value__;
    public static ErrorDumpType MicroDump;
    public static ErrorDumpType MiniDump;
    public static ErrorDumpType HeapDump;
    public static ErrorDumpType Max;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ErrorFileFlags : Enum {
    public int value__;
    public static ErrorFileFlags DeleteWhenDone;
    public static ErrorFileFlags AnonymousData;
}
public enum Microsoft.VisualStudio.ProjectSystem.ErrorFileType : Enum {
    public int value__;
    public static ErrorFileType Microdump;
    public static ErrorFileType Minidump;
    public static ErrorFileType Heapdump;
    public static ErrorFileType UserDocument;
    public static ErrorFileType Other;
}
public enum Microsoft.VisualStudio.ProjectSystem.ErrorReportConsent : Enum {
    public int value__;
    public static ErrorReportConsent NotAsked;
    public static ErrorReportConsent Approved;
    public static ErrorReportConsent Denied;
    public static ErrorReportConsent AlwaysPrompt;
    public static ErrorReportConsent Max;
}
public class Microsoft.VisualStudio.ProjectSystem.ErrorReportSettings : object {
    [CompilerGeneratedAttribute]
private ErrorDumpType <DumpType>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorReportType <ReportType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ErrorFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorReportSubmitFlags <SubmitFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<KeyValuePair`2<ErrorReportUIType, string>> <SubmitUIOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private BucketParameters <PreferredBucketParameters>k__BackingField;
    public ErrorDumpType DumpType { get; private set; }
    public ErrorReportType ReportType { get; private set; }
    public string Component { get; private set; }
    public string EventName { get; private set; }
    public IReadOnlyCollection`1<ErrorFile> Files { get; private set; }
    public ErrorReportSubmitFlags SubmitFlags { get; private set; }
    public IReadOnlyCollection`1<KeyValuePair`2<ErrorReportUIType, string>> SubmitUIOptions { get; private set; }
    public BucketParameters PreferredBucketParameters { get; private set; }
    public ErrorReportSettings(ErrorDumpType dumpType, ErrorReportType reportType, string component, string eventName, IReadOnlyCollection`1<ErrorFile> files, ErrorReportSubmitFlags submitFlags, IReadOnlyCollection`1<KeyValuePair`2<ErrorReportUIType, string>> submitUIOptions, BucketParameters preferredBucketParameters);
    [CompilerGeneratedAttribute]
public ErrorDumpType get_DumpType();
    [CompilerGeneratedAttribute]
private void set_DumpType(ErrorDumpType value);
    [CompilerGeneratedAttribute]
public ErrorReportType get_ReportType();
    [CompilerGeneratedAttribute]
private void set_ReportType(ErrorReportType value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
private void set_Component(string value);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
private void set_EventName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ErrorFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(IReadOnlyCollection`1<ErrorFile> value);
    [CompilerGeneratedAttribute]
public ErrorReportSubmitFlags get_SubmitFlags();
    [CompilerGeneratedAttribute]
private void set_SubmitFlags(ErrorReportSubmitFlags value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<KeyValuePair`2<ErrorReportUIType, string>> get_SubmitUIOptions();
    [CompilerGeneratedAttribute]
private void set_SubmitUIOptions(IReadOnlyCollection`1<KeyValuePair`2<ErrorReportUIType, string>> value);
    [CompilerGeneratedAttribute]
public BucketParameters get_PreferredBucketParameters();
    [CompilerGeneratedAttribute]
private void set_PreferredBucketParameters(BucketParameters value);
    public ErrorReportSettings AddErrorFile(ErrorFile errorFile);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ErrorReportSubmitFlags : Enum {
    public int value__;
    public static ErrorReportSubmitFlags HonorRecovery;
    public static ErrorReportSubmitFlags HonorRestart;
    public static ErrorReportSubmitFlags Queue;
    public static ErrorReportSubmitFlags ShowDebug;
    public static ErrorReportSubmitFlags AddRegisteredData;
    public static ErrorReportSubmitFlags OutOfProcess;
    public static ErrorReportSubmitFlags NoCloseUI;
    public static ErrorReportSubmitFlags NoQueue;
    public static ErrorReportSubmitFlags NoArchive;
    public static ErrorReportSubmitFlags StartMinimized;
    public static ErrorReportSubmitFlags OutOfProcessAsync;
    public static ErrorReportSubmitFlags ByPassDataThrottling;
    public static ErrorReportSubmitFlags ArchiveParameters_Only;
    public static ErrorReportSubmitFlags ReportMachineID;
}
public enum Microsoft.VisualStudio.ProjectSystem.ErrorReportType : Enum {
    public int value__;
    public static ErrorReportType Noncritical;
    public static ErrorReportType Critical;
    public static ErrorReportType ApplicationCrash;
    public static ErrorReportType ApplicationHang;
    public static ErrorReportType Kernel;
    public static ErrorReportType Invalid;
}
public enum Microsoft.VisualStudio.ProjectSystem.ErrorReportUIType : Enum {
    public int value__;
    public static ErrorReportUIType AdditionalDataDialogHeader;
    public static ErrorReportUIType IconFilePath;
    public static ErrorReportUIType ConsentDialogHeader;
    public static ErrorReportUIType ConsentDialogBody;
    public static ErrorReportUIType OnlineSolutionCheckText;
    public static ErrorReportUIType OfflineSolutionCheckText;
    public static ErrorReportUIType CloseText;
    public static ErrorReportUIType CloseDialogHeader;
    public static ErrorReportUIType CloseDialogBody;
    public static ErrorReportUIType CloseDialogButtonText;
    public static ErrorReportUIType CustomActionButtonText;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.ErrorUtilities : object {
    internal static object ReportDeprecatedMethod(string fullMethodName);
    internal static void ReportDeprecatedMethodNoThrow(string fullMethodName);
    internal static object ReportNotYetImplementedMethod(string fullMethodName);
    internal static void ReportNotYetImplementedMethodNoThrow(string fullMethodName);
    internal static bool VerifyReportWarning(bool condition, string unformattedMessage, Object[] args);
    [EditorBrowsableAttribute("1")]
internal static void VerifyThrow(bool condition, string unformattedMessage);
    [EditorBrowsableAttribute("1")]
internal static void VerifyThrow(bool condition, string unformattedMessage, Object[] args);
    internal static bool IsCriticalException(Exception e);
    [ExtensionAttribute]
internal static void RethrowIfCritical(Exception ex);
    internal static string GetCurrentStackTraces();
    private static string AddStackTrace(IList`1<StackFrame> frames);
    private static string AddStackTrace(StringBuilder stringBuilder, IEnumerable`1<StackFrame> frames);
}
internal static class Microsoft.VisualStudio.ProjectSystem.ExecutionContextUtilities : object {
    internal static IDisposable TrySuppressExecutionContextFlow();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.ExportCommandGroupAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private Guid <Group>k__BackingField;
    public Guid Group { get; public set; }
    public ExportCommandGroupAttribute(string group);
    public ExportCommandGroupAttribute(Guid group);
    [CompilerGeneratedAttribute]
public Guid get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(Guid value);
}
public static class Microsoft.VisualStudio.ProjectSystem.ExportContractNames : object {
    private static string Prefix;
    public static string PropertyXamlRuleDefinition;
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.ExportSpecialFileProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private SpecialFiles <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecialFiles <Maximum>k__BackingField;
    public SpecialFiles Minimum { get; public set; }
    public SpecialFiles Maximum { get; public set; }
    public ExportSpecialFileProviderAttribute(SpecialFiles specialFile);
    public ExportSpecialFileProviderAttribute(SpecialFiles minimum, SpecialFiles maximum);
    [CompilerGeneratedAttribute]
public SpecialFiles get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(SpecialFiles value);
    [CompilerGeneratedAttribute]
public SpecialFiles get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(SpecialFiles value);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.ExportVsProfferedProjectServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceGuid>k__BackingField;
    public string ServiceGuid { get; private set; }
    public ExportVsProfferedProjectServiceAttribute(string serviceGuid);
    public ExportVsProfferedProjectServiceAttribute(Type serviceType);
    [CompilerGeneratedAttribute]
public string get_ServiceGuid();
    [CompilerGeneratedAttribute]
private void set_ServiceGuid(string value);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.FaultChangedEventArgs : EventArgs {
    public bool IsFaulted { get; }
    public abstract virtual bool get_IsFaulted();
}
internal class Microsoft.VisualStudio.ProjectSystem.FileSystemEventCollection : object {
    private static WatcherChangeTypes WatcherChangeTypesNone;
    private Dictionary`2<string, FileSystemChange> map;
    private int nextFileSystemChangeOrder;
    private string baseDirectory;
    public sealed virtual IEnumerator`1<FileSystemEventArgs> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void AddEvent(FileSystemEventArgs fileEvent);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ForkOptions : Enum {
    public int value__;
    public static ForkOptions None;
    public static ForkOptions SuppressRelevance;
    public static ForkOptions HideLocks;
    public static ForkOptions NoAssistanceMask;
    public static ForkOptions StartOnMainThread;
    public static ForkOptions StartOnThreadPool;
    public static ForkOptions CancelOnUnload;
    public static ForkOptions IsCriticalTask;
    public static ForkOptions Default;
}
internal class Microsoft.VisualStudio.ProjectSystem.GlobInfo : object {
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildGlob <MsBuildGlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <IncludeGlobs>k__BackingField;
    public string ItemType { get; }
    public IMSBuildGlob MsBuildGlob { get; }
    public IReadOnlyCollection`1<string> IncludeGlobs { get; }
    internal GlobInfo(GlobResult globResult);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_MsBuildGlob();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_IncludeGlobs();
}
internal class Microsoft.VisualStudio.ProjectSystem.Hasher : object {
    private static int BufferCharacterSize;
    private static int BufferByteSize;
    private Byte[] buffer;
    private List`1<string> diagnostics;
    private HashAlgorithm hashAlgorithm;
    public Hasher(List`1<string> diagnostics);
    private static Hasher();
    public void Reset();
    public void Add(string value);
    public void Add(DateTime dateTime);
    public Byte[] Calculate();
    public sealed virtual void Dispose();
    public static string HashToHex(Byte[] hash);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.HierarchicalProjectItemProviderBase`1 : ProjectItemProviderBase`1<TProjectItemInterface> {
    protected HierarchicalProjectItemProviderBase`1(ConfiguredProject configuredProject);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.HierarchicalProjectItemProviderBase`1/<AddAsync>d__2")]
public virtual Task`1<TProjectItemInterface> AddAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.HierarchicalProjectItemProviderBase`1/<RemoveAsync>d__3")]
public virtual Task RemoveAsync(string itemType, string evaluatedInclude, DeleteOptions deleteOptions);
    public virtual Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsAsync(string itemType, string evaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.HierarchicalProjectItemProviderBase`1/<GetItemsAsync>d__5")]
public virtual Task`1<IReadOnlyCollection`1<TProjectItemInterface>> GetItemsAsync(IReadOnlyCollection`1<IProjectPropertiesContext> context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<TProjectItemInterface> <>n__0(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(string itemType, string evaluatedInclude, DeleteOptions deleteOptions);
}
public class Microsoft.VisualStudio.ProjectSystem.HintedTreeResult : ValueType {
    [CompilerGeneratedAttribute]
private IComparable <DataSourceVersionIncludingChange>k__BackingField;
    public IComparable DataSourceVersionIncludingChange { get; private set; }
    public HintedTreeResult(IComparable dataSourceVersionIncludingChange);
    [CompilerGeneratedAttribute]
public IComparable get_DataSourceVersionIncludingChange();
    [CompilerGeneratedAttribute]
private void set_DataSourceVersionIncludingChange(IComparable value);
    public static bool op_Equality(HintedTreeResult result1, HintedTreeResult result2);
    public static bool op_Inequality(HintedTreeResult result1, HintedTreeResult result2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ProjectSystem.HybridImmutableDictionary`2 : object {
    private IImmutableDictionary`2<TKey, TValue> innerDictionary;
    private ImmutableDictionary`2<TKey, TValue> overridenDictionary;
    private int keyOverlappingCount;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public int Count { get; }
    public TValue Item { get; }
    public HybridImmutableDictionary`2(IImmutableDictionary`2<TKey, TValue> innerDictionary, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private HybridImmutableDictionary`2(IImmutableDictionary`2<TKey, TValue> innerDictionary, ImmutableDictionary`2<TKey, TValue> overridenDictionary, int keyOverlappingCount);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual IImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public sealed virtual IImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private ImmutableDictionary`2<TKey, TValue> Copy();
    [CompilerGeneratedAttribute]
private bool <get_Values>b__8_0(KeyValuePair`2<TKey, TValue> pair);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__14_0(KeyValuePair`2<TKey, TValue> p);
    [CompilerGeneratedAttribute]
private bool <GetEnumerator>b__18_0(KeyValuePair`2<TKey, TValue> pair);
    [CompilerGeneratedAttribute]
private bool <RemoveRange>b__20_0(TKey key);
    [CompilerGeneratedAttribute]
private bool <SetItems>b__22_0(KeyValuePair`2<TKey, TValue> item);
    [CompilerGeneratedAttribute]
private bool <Copy>b__26_0(KeyValuePair`2<TKey, TValue> pair);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveConfigurationGroupService {
    public IProjectValueDataSource`1<IConfigurationGroup`1<ProjectConfiguration>> ActiveConfigurationGroupSource { get; }
    public IProjectValueDataSource`1<IConfigurationGroup`1<ConfiguredProject>> ActiveConfiguredProjectGroupSource { get; }
    public abstract virtual IProjectValueDataSource`1<IConfigurationGroup`1<ProjectConfiguration>> get_ActiveConfigurationGroupSource();
    public abstract virtual IProjectValueDataSource`1<IConfigurationGroup`1<ConfiguredProject>> get_ActiveConfiguredProjectGroupSource();
}
public interface Microsoft.VisualStudio.ProjectSystem.IActiveConfigurationGroupService2 {
    public abstract virtual Task`1<IConfigurationGroup`1<ProjectConfiguration>> GetActiveConfigurationGroupAsync();
    public abstract virtual Task`1<IConfigurationGroup`1<ConfiguredProject>> GetActiveLoadedConfiguredProjectGroupAsync();
    public abstract virtual Task`1<IConfigurationGroup`1<ProjectConfiguration>> GetConfigurationGroupAsync(ProjectConfiguration configuration);
    public abstract virtual Task`1<IConfigurationGroup`1<ConfiguredProject>> GetLoadedConfiguredProjectGroupAsync(ConfiguredProject configuredProject);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveConfiguredProjectProvider {
    public ConfiguredProject ActiveConfiguredProject { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<ConfiguredProject>> ActiveConfiguredProjectBlock { get; }
    public ProjectConfiguration ActiveProjectConfiguration { get; }
    public CancellationToken ConfigurationActiveCancellationToken { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<ActiveConfigurationChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<ActiveConfigurationChangedEventArgs> value);
    public abstract virtual ConfiguredProject get_ActiveConfiguredProject();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<ConfiguredProject>> get_ActiveConfiguredProjectBlock();
    public abstract virtual ProjectConfiguration get_ActiveProjectConfiguration();
    public abstract virtual CancellationToken get_ConfigurationActiveCancellationToken();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveConfiguredProjectSnapshotService {
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveConfiguredProjectSubscriptionService {
}
[ProjectSystemContractAttribute("1", "1")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveProjectConfigurationRefreshService {
    public abstract virtual Task RefreshActiveProjectConfigurationAsync();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IActiveProjectTreeProvider {
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> Tree { get; }
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> get_Tree();
    public abstract virtual Task SetActiveTreeProviderAsync(IProjectTreeProvider treeProvider);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IAddItemTemplatesGuidProvider {
    public Guid AddItemTemplatesGuid { get; }
    public abstract virtual Guid get_AddItemTemplatesGuid();
}
public interface Microsoft.VisualStudio.ProjectSystem.IAppliesToMetadataView {
    public string AppliesTo { get; }
    public abstract virtual string get_AppliesTo();
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IAsyncCommandGroupHandler {
    public abstract virtual Task`1<CommandStatusResult> GetCommandStatusAsync(IImmutableSet`1<IProjectTree> nodes, long commandId, bool focused, string commandText, CommandStatus progressiveStatus);
    public abstract virtual Task`1<bool> TryHandleCommandAsync(IImmutableSet`1<IProjectTree> nodes, long commandId, bool focused, long commandExecuteOptions, IntPtr variantArgIn, IntPtr variantArgOut);
}
[ProjectSystemContractAttribute("0", "1")]
internal interface Microsoft.VisualStudio.ProjectSystem.IBulkFileOperationCoordinatorService {
    public abstract virtual Task ExecuteWithThrottlingAsync(Func`2<bool, Task> asyncFunc, BulkFileOperationResumePriority priority);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.ICommandGroupHandler {
    public abstract virtual CommandStatusResult GetCommandStatus(IImmutableSet`1<IProjectTree> nodes, long commandId, bool focused, string commandText, CommandStatus progressiveStatus);
    public abstract virtual bool TryHandleCommand(IImmutableSet`1<IProjectTree> nodes, long commandId, bool focused, long commandExecuteOptions, IntPtr variantArgIn, IntPtr variantArgOut);
}
public interface Microsoft.VisualStudio.ProjectSystem.IConfigurationGroup`1 {
    public IReadOnlyCollection`1<string> VariantDimensionNames { get; }
    public abstract virtual IReadOnlyCollection`1<string> get_VariantDimensionNames();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectActivationTracking {
    public bool IsActive { get; }
    public Task ActivationTask { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deactivated(EventHandler value);
    public abstract virtual bool get_IsActive();
    public abstract virtual Task get_ActivationTask();
}
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectCache`1 {
    public abstract virtual Task`1<T> GetValueAsync();
    public abstract virtual void Invalidate();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectCacheFactory {
    public abstract virtual IConfiguredProjectCache`1<T> Create(Func`1<Task`1<T>> cacheUpdateDelegate, ConfiguredProjectCacheOptions options);
    public abstract virtual IConfiguredProjectCacheTable`2<TKey, TValue> Create(Func`2<TKey, Task`1<TValue>> valueProvider, ConfiguredProjectCacheOptions options);
}
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectCacheTable`2 {
    public abstract virtual Task`1<TValue> GetValueAsync(TKey key);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectReadyToBuild {
    public bool IsValidToBuild { get; }
    public abstract virtual bool get_IsValidToBuild();
    public abstract virtual Task WaitReadyToBuildAsync();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IConfiguredProjectServices {
    public IOutputGroupsService OutputGroups { get; }
    public IBuildProject Build { get; }
    public IBuildSupport BuildSupport { get; }
    public IAssemblyReferencesService AssemblyReferences { get; }
    public IComReferencesService ComReferences { get; }
    public ISdkReferencesService SdkReferences { get; }
    public IPackageReferencesService PackageReferences { get; }
    public IWinRTReferencesService WinRTReferences { get; }
    public IBuildDependencyProjectReferencesService ProjectReferences { get; }
    public IProjectItemProvider SourceItems { get; }
    public IProjectPropertiesProvider ProjectPropertiesProvider { get; }
    public IProjectPropertiesProvider UserPropertiesProvider { get; }
    public IProjectAsynchronousTasksService ProjectAsynchronousTasks { get; }
    public IAdditionalRuleDefinitionsService AdditionalRuleDefinitions { get; }
    public IPropertyPagesCatalogProvider PropertyPagesCatalog { get; }
    public IProjectSubscriptionService ProjectSubscription { get; }
    public IProjectSnapshotService ProjectSnapshotService { get; }
    public object HostObject { get; }
    public abstract virtual IOutputGroupsService get_OutputGroups();
    public abstract virtual IBuildProject get_Build();
    public abstract virtual IBuildSupport get_BuildSupport();
    public abstract virtual IAssemblyReferencesService get_AssemblyReferences();
    public abstract virtual IComReferencesService get_ComReferences();
    public abstract virtual ISdkReferencesService get_SdkReferences();
    public abstract virtual IPackageReferencesService get_PackageReferences();
    public abstract virtual IWinRTReferencesService get_WinRTReferences();
    public abstract virtual IBuildDependencyProjectReferencesService get_ProjectReferences();
    public abstract virtual IProjectItemProvider get_SourceItems();
    public abstract virtual IProjectPropertiesProvider get_ProjectPropertiesProvider();
    public abstract virtual IProjectPropertiesProvider get_UserPropertiesProvider();
    public abstract virtual IProjectAsynchronousTasksService get_ProjectAsynchronousTasks();
    public abstract virtual IAdditionalRuleDefinitionsService get_AdditionalRuleDefinitions();
    public abstract virtual IPropertyPagesCatalogProvider get_PropertyPagesCatalog();
    public abstract virtual IProjectSubscriptionService get_ProjectSubscription();
    public abstract virtual IProjectSnapshotService get_ProjectSnapshotService();
    public abstract virtual object get_HostObject();
}
public interface Microsoft.VisualStudio.ProjectSystem.IContentType {
    public string Name { get; }
    public string DisplayName { get; }
    public string ItemType { get; }
    public bool DefaultContentTypeForItemType { get; }
    public IReadOnlyList`1<NameValuePair> Metadata { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_ItemType();
    public abstract virtual bool get_DefaultContentTypeForItemType();
    public abstract virtual IReadOnlyList`1<NameValuePair> get_Metadata();
    public abstract virtual string GetMetadata(string metadataName);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.ICopyPackager {
    public IImmutableSet`1<int> ClipboardDataFormats { get; }
    public abstract virtual IImmutableSet`1<int> get_ClipboardDataFormats();
    public abstract virtual CopyPasteOperations GetAllowedOperations(IEnumerable`1<IProjectTree> selectedNodes, IProjectTreeProvider currentProvider);
    public abstract virtual Task`1<IEnumerable`1<Tuple`2<int, IntPtr>>> GetPointerToDataAsync(IReadOnlyCollection`1<int> types, IEnumerable`1<IProjectTree> selectedNodes, IProjectTreeProvider currentProvider);
}
public interface Microsoft.VisualStudio.ProjectSystem.ICopyPasteItem {
    public bool Cancelled { get; public set; }
    public Exception Exception { get; public set; }
    public IImmutableList`1<ICopyPasteItem> Children { get; }
    public abstract virtual bool get_Cancelled();
    public abstract virtual void set_Cancelled(bool value);
    public abstract virtual Exception get_Exception();
    public abstract virtual void set_Exception(Exception value);
    public abstract virtual IImmutableList`1<ICopyPasteItem> get_Children();
}
[ProjectSystemContractAttribute("0", "2")]
internal interface Microsoft.VisualStudio.ProjectSystem.ICriticalPackageService {
    public abstract virtual void Initialize();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IDefaultProjectProvider {
    public ProjectConfiguration DefaultProjectConfiguration { get; }
    public string DefaultProjectTemplate { get; }
    public abstract virtual ProjectConfiguration get_DefaultProjectConfiguration();
    public abstract virtual string get_DefaultProjectTemplate();
    public abstract virtual Task`1<UnconfiguredProject> GetDefaultUnconfiguredProjectAsync();
    public abstract virtual Task`1<ConfiguredProject> GetDefaultConfiguredProjectAsync();
    public abstract virtual Task`1<string> GetTargetsPathAsync();
    public abstract virtual Task`1<string> GetToolsVersionAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.IDefaultProjectProviderMetadataView {
    public string ProjectType { get; }
    public String[] ProjectFileExtensions { get; }
    public abstract virtual string get_ProjectType();
    public abstract virtual String[] get_ProjectFileExtensions();
}
[ProjectSystemContractAttribute("2", "2")]
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IDependentFilesProvider {
    public abstract virtual Task`1<T> FindParentAsync(IDependentFilesScope`1<T> scope, string fileName);
    public abstract virtual Task`1<IReadOnlyCollection`1<T>> FindDependentFilesAsync(IDependentFilesScope`1<T> scope, string fileName);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IDependentFilesProviderDataSource {
}
public interface Microsoft.VisualStudio.ProjectSystem.IDependentFilesScope`1 {
    public abstract virtual Task`1<T> TryGetItemAsync(string fileName);
    public abstract virtual Task`1<IReadOnlyCollection`1<KeyValuePair`2<string, T>>> GetAllItemsAsync();
}
[ProjectSystemContractAttribute("2", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IDependentFilesService {
    public abstract virtual Task`1<IReadOnlyCollection`1<string>> GetDependentFilePathsAsync(IEnumerable`1<string> files);
}
[ProjectSystemContractAttribute("0", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IEnvironmentConfigProvider {
    public bool IsEnvironmentActive { get; }
    public ProjectConfiguration ActiveProjectConfiguration { get; }
    public abstract virtual bool get_IsEnvironmentActive();
    public abstract virtual ProjectConfiguration get_ActiveProjectConfiguration();
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IEventDispatcherService {
    public abstract virtual Task FireProjectChangeEventsAsync(object sender, EventArgs eventArgs, AsyncEventHandler changingHandlers, AsyncEventHandler changedWritingHandlers, AsyncEventHandler changedHandlers);
    public abstract virtual Task FireProjectChangeEventsAsync(object sender, T eventArgs, AsyncEventHandler`1<T> changingHandlers, AsyncEventHandler`1<T> changedWritingHandlers, AsyncEventHandler`1<T> changedHandlers);
    public abstract virtual void CancelPendingChangedEvents();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IFileActionHandler {
    public abstract virtual Task`1<bool> TryHandleFileSavedAsync(IProjectTree tree, string newFilePath, bool saveAs);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IFileSaveListener {
    public abstract virtual Task`1<IAsyncDisposable> OnFileWriteAsync(string fullPath);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IFileSystemErrorMessageProvider {
    public abstract virtual bool CanProvideCustomErrorMessage(IProjectChangeFileHint hint, int nativeErrorCode, String& formattedMessage);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IFolderChildProjectItemProvider {
    public abstract virtual Task`1<bool> AnyProjectItemsUnderFolderAsync(string projectRelativePath);
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> GetProjectItemsUnderFolderAsync(string projectRelativePath);
    public abstract virtual Task NotifyBeforeRenamingFolderAsync(IEnumerable`1<IProjectItem> projectItems, string oldRelativePath, string newRelativePath);
    public abstract virtual Task UpdateProjectItemsAfterRenamingFolderAsync(IEnumerable`1<IProjectItem> projectItems, string oldFullPathEscaped, string oldRelativePathEscaped, string newRelativePathEscaped);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IFolderManager {
    public abstract virtual Task IncludeFolderInProjectAsync(string path, bool recursive);
    public abstract virtual Task IncludeFolderInProjectAsync(IEnumerable`1<string> paths, bool recursive);
    public abstract virtual Task RemoveFolderFromProjectAsync(string path, DeleteOptions deleteOptions);
    public abstract virtual Task RemoveFolderFromProjectAsync(IEnumerable`1<string> paths, DeleteOptions deleteOptions);
    public abstract virtual Task RenameFolderAsync(string oldPath, string newPath);
    public abstract virtual Task RenameFolderInProjectAsync(string oldPath, string newPath);
    public abstract virtual Task PrepareToAddFoldersAsync(IEnumerable`1<string> includedPaths, IEnumerable`1<string> excludedPaths);
}
public interface Microsoft.VisualStudio.ProjectSystem.IFolderManager2 {
    public abstract virtual Task RemoveLinkedFileFolderFromProjectAsync(string path);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IGlobbingWatchingService {
    public abstract virtual Task RefreshAsync(CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IHandsOffService {
    public abstract virtual Task HandsOnFilesAsync(IEnumerable`1<string> files);
    public abstract virtual Task HandsOffFilesAsync(IEnumerable`1<string> files);
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IInMemoryProjectsService {
    public abstract virtual bool IsProjectInMemoryOnly(string projectFile);
    public abstract virtual void AddProjectInMemoryOnly(string projectFile);
    public abstract virtual void RemoveProjectInMemoryOnly(string projectFile);
}
public interface Microsoft.VisualStudio.ProjectSystem.IItemType {
    public string Name { get; }
    public string DisplayName { get; }
    public bool UpToDateCheckInput { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual bool get_UpToDateCheckInput();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IItemTypeGuidProvider {
    public Guid ProjectTypeGuid { get; }
    public abstract virtual Guid get_ProjectTypeGuid();
}
public interface Microsoft.VisualStudio.ProjectSystem.IJoinableProjectValueDataSource {
    public abstract virtual IDisposable Join();
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class Microsoft.VisualStudio.ProjectSystem.ImageMonikerExtensions : object {
    private static object SyncObject;
    private static Dictionary`2<ImageMoniker, ProjectImageMoniker> InteropToProjectMap;
    private static ImageMonikerExtensions();
    [ExtensionAttribute]
public static ImageMoniker ToInteropType(ProjectImageMoniker moniker);
    [ExtensionAttribute]
public static ProjectImageMoniker ToProjectSystemType(ImageMoniker interopMoniker);
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IMainThreadPublisher {
    public Thread MainThread { get; }
    public JoinableTaskContextNode JoinableTaskContext { get; }
    public abstract virtual Thread get_MainThread();
    public abstract virtual JoinableTaskContextNode get_JoinableTaskContext();
}
public interface Microsoft.VisualStudio.ProjectSystem.IMinimalProjectConfiguration {
    public string Name { get; }
    public string Platform { get; }
    public string Configuration { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Platform();
    public abstract virtual string get_Configuration();
}
internal class Microsoft.VisualStudio.ProjectSystem.ImmutableSetFromDictionary`2 : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<TItem, TOther> <InnerDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private TOther <DefaultOtherValue>k__BackingField;
    protected ImmutableDictionary`2<TItem, TOther> InnerDictionary { get; }
    private int System.Collections.Generic.IReadOnlyCollection<TItem>.Count { get; }
    protected TOther DefaultOtherValue { get; }
    protected ImmutableSetFromDictionary`2(ImmutableDictionary`2<TItem, TOther> innerDictionary);
    [CompilerGeneratedAttribute]
protected ImmutableDictionary`2<TItem, TOther> get_InnerDictionary();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<TItem>.get_Count();
    [CompilerGeneratedAttribute]
protected virtual TOther get_DefaultOtherValue();
    internal static ImmutableSetFromDictionary`2<TItem, TOther> Create(ImmutableDictionary`2<TItem, TOther> innerDictionary);
    protected virtual ImmutableSetFromDictionary`2<TItem, TOther> CreateInstance(ImmutableDictionary`2<TItem, TOther> innerDictionary);
    protected virtual IEnumerable`1<TItem> GetSortedItems();
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Add(TItem value);
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Clear();
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.Contains(TItem value);
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Except(IEnumerable`1<TItem> other);
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Intersect(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.IsProperSubsetOf(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.IsProperSupersetOf(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.IsSubsetOf(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.IsSupersetOf(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.Overlaps(IEnumerable`1<TItem> other);
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Remove(TItem value);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.SetEquals(IEnumerable`1<TItem> other);
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.SymmetricExcept(IEnumerable`1<TItem> other);
    private sealed virtual override bool System.Collections.Immutable.IImmutableSet<TItem>.TryGetValue(TItem equalValue, TItem& actualValue);
    private sealed virtual override IImmutableSet`1<TItem> System.Collections.Immutable.IImmutableSet<TItem>.Union(IEnumerable`1<TItem> other);
    [CompilerGeneratedAttribute]
private bool <System.Collections.Immutable.IImmutableSet<TItem>.SymmetricExcept>b__26_0(TItem t);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TItem, TOther> <System.Collections.Immutable.IImmutableSet<TItem>.SymmetricExcept>b__26_1(TItem t);
    [CompilerGeneratedAttribute]
private bool <System.Collections.Immutable.IImmutableSet<TItem>.Union>b__28_0(TItem t);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<TItem, TOther> <System.Collections.Immutable.IImmutableSet<TItem>.Union>b__28_1(TItem t);
}
public class Microsoft.VisualStudio.ProjectSystem.ImportOrderPrecedenceComparer : object {
    private PreferenceOrder order;
    private static ImportOrderPrecedenceComparer preferredComesFirstInstance;
    private static ImportOrderPrecedenceComparer preferredComesLastInstance;
    public static IComparer`1<int> PreferredComesFirst { get; }
    public static IComparer`1<int> PreferredComesLast { get; }
    private ImportOrderPrecedenceComparer(PreferenceOrder preferenceOrder);
    private static ImportOrderPrecedenceComparer();
    public static IComparer`1<int> get_PreferredComesFirst();
    public static IComparer`1<int> get_PreferredComesLast();
    public static IComparer`1<int> GetComparer(PreferenceOrder orderingStyle);
    public sealed virtual int Compare(int x, int y);
}
public interface Microsoft.VisualStudio.ProjectSystem.IMultipleNamedExportMetadataView {
    public String[] Name { get; }
    public abstract virtual String[] get_Name();
}
public interface Microsoft.VisualStudio.ProjectSystem.INamedExportMetadataView {
    public string Name { get; }
    public abstract virtual string get_Name();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.INewProjectAsyncInitializationProvider {
    public abstract virtual Task InitializeNewProjectAsync();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.INewProjectInitializationProvider {
    public abstract virtual void InitializeNewProject();
}
internal class Microsoft.VisualStudio.ProjectSystem.InlineResumable : object {
    private Action continuation;
    private SynchronizationContext capturedSynchronizationContext;
    private bool resumed;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public InlineResumable GetAwaiter();
    public void Resume();
}
[ProjectSystemContractAttribute("2", "0")]
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IOrderedSourceItemsDataSourceService {
}
public interface Microsoft.VisualStudio.ProjectSystem.IOrderPrecedenceMetadataView {
    [DefaultValueAttribute("0")]
public int OrderPrecedence { get; }
    public abstract virtual int get_OrderPrecedence();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IPasteDataObjectProcessor {
    public abstract virtual bool CanHandleDataObject(object dataObject, IProjectTree dropTarget, IProjectTreeProvider currentProvider);
    public abstract virtual Nullable`1<DropEffects> QueryDropEffect(object dataObject, int grfKeyState, bool draggedFromThisProject);
    public abstract virtual Task`1<IEnumerable`1<ICopyPasteItem>> ProcessDataObjectAsync(object dataObject, IProjectTree dropTarget, IProjectTreeProvider currentProvider, DropEffects effect);
    public abstract virtual Task ProcessPostFilterAsync(IEnumerable`1<ICopyPasteItem> items);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IPasteHandler {
    public abstract virtual bool CanHandleItem(Type itemType);
    public abstract virtual void FilterItemList(IEnumerable`1<ICopyPasteItem> items, DropEffects effect);
    public abstract virtual Task`1<IEnumerable`1<string>> ValidateItemListAsync(IEnumerable`1<ICopyPasteItem> items, DropEffects effect);
    public abstract virtual bool PromptForAnyOverwrites(IEnumerable`1<ICopyPasteItem> items, DropEffects& effect);
    public abstract virtual Task`1<PasteItemsResult> PasteItemsAsync(IEnumerable`1<ICopyPasteItem> items, DropEffects effect);
}
[ProjectSystemContractAttribute("1", "0")]
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectAsynchronousTasksService {
    public CancellationToken UnloadCancellationToken { get; }
    public abstract virtual CancellationToken get_UnloadCancellationToken();
    public abstract virtual void RegisterAsyncTask(JoinableTask joinableTask, bool registerFaultHandler);
    public abstract virtual void RegisterAsyncTask(Task task, bool registerFaultHandler);
    public abstract virtual void RegisterAsyncTask(JoinableTask joinableTask, ProjectCriticalOperation operationFlags, bool registerFaultHandler);
    public abstract virtual void RegisterCriticalAsyncTask(JoinableTask joinableTask, bool registerFaultHandler);
    public abstract virtual Task DrainTaskQueueAsync(bool drainCurrentQueueOnly, bool throwExceptions, CancellationToken cancellationToken);
    public abstract virtual Task DrainCriticalTaskQueueAsync(bool drainCurrentQueueOnly, bool throwExceptions, CancellationToken cancellationToken);
    public abstract virtual Task DrainTaskQueueAsync(ProjectCriticalOperation operation, bool drainCurrentQueueOnly, bool throwExceptions, CancellationToken cancellationToken);
    public abstract virtual bool IsTaskQueueEmpty(ProjectCriticalOperation projectCriticalOperation);
}
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectAsynchronousTasksServiceInternal {
    public abstract virtual void SignalUnloadPending();
}
[ProjectSystemContractAttribute("0", "2")]
[ProjectSystemContractAttribute("1", "2")]
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesProvider {
    public IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> Current { get; }
    public abstract virtual IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> get_Current();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesRequirementContext {
    public NamedIdentity ScopeIdentity { get; }
    public abstract virtual NamedIdentity get_ScopeIdentity();
    public abstract virtual void RegisterCapabilitiesRequirements(IProjectCapabilitiesRequirements requirements);
    public abstract virtual void RegisterCapabilitiesRequirement(string capability, bool expectedPresence);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesRequirements {
    public IImmutableDictionary`2<string, bool> CapabilitiesRequirements { get; }
    public bool IsEmpty { get; }
    public abstract virtual IImmutableDictionary`2<string, bool> get_CapabilitiesRequirements();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool IsSatisfiedBy(IProjectCapabilitiesSnapshot capabilitiesSnapshot);
    public abstract virtual bool ConflictsWith(IProjectCapabilitiesRequirements other);
    public abstract virtual IProjectCapabilitiesRequirements Add(string capability, bool expectedPresence);
    public abstract virtual IProjectCapabilitiesRequirements Add(IProjectCapabilitiesRequirements projectCapabilitiesRequirements);
    public abstract virtual IProjectCapabilitiesRequirements Remove(String[] capabilities);
    public abstract virtual IProjectCapabilitiesRequirements Remove(IProjectCapabilitiesRequirements capabilitiesRequirements);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesRequirementsService {
    public abstract virtual bool RegisterCapabilitiesRequirements(NamedIdentity scopeIdentity, long version, IProjectCapabilitiesRequirements requirements);
    public abstract virtual bool RegisterCapabilitiesRequirement(NamedIdentity scopeIdentity, long version, string capability, bool expectedPresence);
    public abstract virtual Task`1<bool> IsIncompatibleChangeAsync(IProjectCapabilitiesScope capabilitiesScope, IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> newCapabilities);
    public abstract virtual Task RequestReloadForIncompatibleCapabilitiesAsync(IImmutableSet`1<string> capabilities);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesRequirementsService2 {
    public abstract virtual void GetIncompatibleCapabilities(IProjectCapabilitiesScope capabilitiesScope, IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> newCapabilities, ICollection`1<string> incompatibleAddedCapabilities, ICollection`1<string> incompatibleRemovedCapabilities);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesScope {
    public NamedIdentity Identity { get; }
    public abstract virtual NamedIdentity get_Identity();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCapabilitiesSnapshot {
    public abstract virtual bool IsProjectCapabilityPresent(string projectCapability);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeDescription {
    public IProjectRuleSnapshot Before { get; }
    public IProjectChangeDiff Difference { get; }
    public IProjectRuleSnapshot After { get; }
    public abstract virtual IProjectRuleSnapshot get_Before();
    public abstract virtual IProjectChangeDiff get_Difference();
    public abstract virtual IProjectRuleSnapshot get_After();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeDiff {
    public IImmutableSet`1<string> AddedItems { get; }
    public IImmutableSet`1<string> RemovedItems { get; }
    public IImmutableSet`1<string> ChangedItems { get; }
    public IImmutableDictionary`2<string, string> RenamedItems { get; }
    public IImmutableSet`1<string> ChangedProperties { get; }
    public bool AnyChanges { get; }
    public abstract virtual IImmutableSet`1<string> get_AddedItems();
    public abstract virtual IImmutableSet`1<string> get_RemovedItems();
    public abstract virtual IImmutableSet`1<string> get_ChangedItems();
    public abstract virtual IImmutableDictionary`2<string, string> get_RenamedItems();
    public abstract virtual IImmutableSet`1<string> get_ChangedProperties();
    public abstract virtual bool get_AnyChanges();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeFileHint {
    public IImmutableSet`1<string> Files { get; }
    public abstract virtual IImmutableSet`1<string> get_Files();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeFileRenameHint {
    public IImmutableDictionary`2<string, string> RenamedFiles { get; }
    public abstract virtual IImmutableDictionary`2<string, string> get_RenamedFiles();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeHint {
    public Guid Kind { get; }
    public bool ChangeAlreadyOccurred { get; }
    public UnconfiguredProject UnconfiguredProject { get; }
    public abstract virtual Guid get_Kind();
    public abstract virtual bool get_ChangeAlreadyOccurred();
    public abstract virtual UnconfiguredProject get_UnconfiguredProject();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeHintReceiver {
    public abstract virtual Task HintingAsync(IProjectChangeHint hint);
    public abstract virtual Task HintedAsync(IImmutableDictionary`2<Guid, IImmutableSet`1<IProjectChangeHint>> hints);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeHintService {
    public abstract virtual IDisposable Subscribe(UnconfiguredProject unconfiguredProject, IProjectChangeHintReceiver receiver, IEnumerable`1<Guid> interestedEventKinds);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectChangeHintSubmissionService {
    public abstract virtual Task HintAsync(IProjectChangeHint changeHint);
    public abstract virtual Task ProcessHintsAsync();
    public abstract virtual void CancelHints(IImmutableSet`1<IProjectChangeHint> hints);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectCommonServices {
    public ExportProvider ExportProvider { get; }
    public IProjectDataSourceRegistry DataSourceRegistry { get; }
    public IProjectService ProjectService { get; }
    public IProjectCapabilitiesScope Capabilities { get; }
    public abstract virtual ExportProvider get_ExportProvider();
    public abstract virtual IProjectDataSourceRegistry get_DataSourceRegistry();
    public abstract virtual IProjectService get_ProjectService();
    public abstract virtual IProjectCapabilitiesScope get_Capabilities();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationDimensionsProvider {
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>>> GetProjectConfigurationDimensionsAsync(UnconfiguredProject project);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, string>>> GetDefaultValuesForDimensionsAsync(UnconfiguredProject project);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationDimensionsProvider2 {
    public abstract virtual Task OnDimensionValueChangedAsync(ProjectConfigurationDimensionValueChangedEventArgs args);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationDimensionsProvider3 {
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, string>>> GetBestGuessDefaultValuesForDimensionsAsync(UnconfiguredProject project);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationsService {
    public ProjectConfiguration SuggestedProjectConfiguration { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Added(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Added(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Removed(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Removed(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(AsyncEventHandler`1<ProjectConfigurationChangeEventArgs> value);
    public abstract virtual ProjectConfiguration get_SuggestedProjectConfiguration();
    public abstract virtual Task`1<IImmutableSet`1<ProjectConfiguration>> GetKnownProjectConfigurationsAsync();
    public abstract virtual Task`1<ProjectConfiguration> GetProjectConfigurationAsync(string name);
    public abstract virtual Task AddKnownProjectConfigurationAsync(string name, IImmutableDictionary`2<string, string> dimensionNameValuePairs);
    public abstract virtual Task AddProjectConfigurationsByExistingDimensionAsync(string dimensionName, string dimensionValue, Func`2<IImmutableDictionary`2<string, string>, string> getConfigurationName);
    public abstract virtual Task RemoveKnownProjectConfigurationAsync(string name, bool removeConditionedElements);
    public abstract virtual Task RemoveProjectConfigurationDimensionAsync(string dimensionName, string dimensionValue, bool removeConditionedElements);
    public abstract virtual Task RenameProjectConfigurationDimensionAsync(string dimensionName, string oldValue, string newValue, bool renameConditionedElements);
    public abstract virtual Task CloneKnownProjectConfigurationAsync(string templateName, string cloneName);
    public abstract virtual Task CloneKnownProjectConfigurationAsync(string templateName, string cloneName, IImmutableDictionary`2<string, string> cloneMetadata);
    public abstract virtual Task CloneProjectConfigurationDimensionAsync(string dimensionName, string oldValue, string newValue);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationsService2 {
    public abstract virtual Task`1<ProjectConfiguration> GetSuggestedProjectConfigurationAsync(bool doNotQueryActiveConfiguration);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectConfigurationsServiceInternal {
    public abstract virtual ProjectConfiguration GetSuggestedProjectConfiguration(bool queryActiveConfiguration);
    public abstract virtual Task`1<ProjectConfiguration> ConvertMinimalConfigurationToProjectConfigurationAsync(IMinimalProjectConfiguration minimalConfiguration);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectContext {
    public IProjectService ProjectService { get; }
    public UnconfiguredProject UnconfiguredProject { get; }
    public ConfiguredProject ConfiguredProject { get; }
    public abstract virtual IProjectService get_ProjectService();
    public abstract virtual UnconfiguredProject get_UnconfiguredProject();
    public abstract virtual ConfiguredProject get_ConfiguredProject();
}
[ProjectSystemContractAttribute("0", "0")]
[ProjectSystemContractAttribute("1", "0")]
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDataSourceRegistry {
    public abstract virtual IDisposable RegisterDataSource(IProjectValueDataSource dataSource);
    public abstract virtual bool TryGetDataSource(NamedIdentity dataSourceKey, IProjectValueDataSource& dataSource);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDataWithConfiguredProjectCapabilities {
    public IProjectCapabilitiesSnapshot ProjectCapabilities { get; }
    public abstract virtual IProjectCapabilitiesSnapshot get_ProjectCapabilities();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDefaultConfigurationProvider {
    public abstract virtual Task`1<ProjectConfiguration> GetDefaultConfigurationAsync(IMinimalProjectConfiguration projectConfiguration);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDirectoryBasedTreeProvider {
    public IProjectVersionedValue`1<IProjectTreeSnapshot> CurrentDirectoryTree { get; }
    public abstract virtual IProjectVersionedValue`1<IProjectTreeSnapshot> get_CurrentDirectoryTree();
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDirectoryTreeSubscriptionService {
    public abstract virtual IRefreshableHintableProjectTreeProvider SubscribeDirectoryTreeProvider(string absolutePath);
    public abstract virtual void UnsubscribeDirectoryTreeProvider(string absolutePath);
    public abstract virtual IRefreshableHintableProjectTreeProvider QueryDirectoryTreeProvider(string absolutePath);
}
[ProjectSystemContractAttribute("1", "2")]
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectDynamicLoadComponent {
    public abstract virtual Task LoadAsync();
    public abstract virtual Task UnloadAsync();
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectErrorReporting {
    public abstract virtual void SubmitReportOnFailure(Action action, Func`2<Exception, ErrorReportSettings> reportExceptionCheck);
    public abstract virtual void SubmitErrorReport(Exception exception, ErrorReportSettings settings, ErrorReportConsent consentGiven);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectExtensionDataService {
    public abstract virtual Task`1<bool> ContainsKeyAsync(string key);
    public abstract virtual Task`1<string> GetDataAsync(string key);
    public abstract virtual Task`1<XElement[]> GetXmlAsync(string key);
    public abstract virtual Task SetXmlAsync(string key, IEnumerable`1<XElement> elements);
    public abstract virtual Task SetDataAsync(string key, string value);
    public abstract virtual Task`1<bool> DeleteAsync(string key);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectFaultHandlerService {
    public abstract virtual void RegisterFaultHandler(Task task, ErrorReportSettings watsonReportSettings, ProjectFaultSeverity severity, UnconfiguredProject project);
    public abstract virtual void RegisterFaultHandler(Task`1<TResult> task, ErrorReportSettings watsonReportSettings, ProjectFaultSeverity severity, UnconfiguredProject project);
    public abstract virtual Task HandleFaultAsync(Exception ex, ErrorReportSettings watsonReportSettings, ProjectFaultSeverity severity, UnconfiguredProject project);
    public abstract virtual Task ReportUserFaultAsync(Exception ex, ProjectFaultSeverity severity, UnconfiguredProject project);
}
[ProjectSystemContractAttribute("0", "3")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectFaultHandlerServiceInternal {
    public bool IsWatsonReportEnabled { get; public set; }
    public TimeSpan MinimumWatsonReportSubmissionInterval { get; public set; }
    public abstract virtual bool get_IsWatsonReportEnabled();
    public abstract virtual void set_IsWatsonReportEnabled(bool value);
    public abstract virtual TimeSpan get_MinimumWatsonReportSubmissionInterval();
    public abstract virtual void set_MinimumWatsonReportSubmissionInterval(TimeSpan value);
}
[ProjectSystemContractAttribute("0", "1")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectFaultHostHandler {
    public abstract virtual Task HandleFaultAsync(Exception failure, ProjectFaultSeverity severity, UnconfiguredProject project);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectFaultProvider {
    public string FaultMessage { get; }
    public bool IsFaulted { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_FaultChanged(EventHandler`1<FaultChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FaultChanged(EventHandler`1<FaultChangedEventArgs> value);
    public abstract virtual string get_FaultMessage();
    public abstract virtual bool get_IsFaulted();
    public abstract virtual void ResolveFault(Boolean& reload);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectFaultTreeProvider {
    public Exception FaultException { get; public set; }
    public abstract virtual Exception get_FaultException();
    public abstract virtual void set_FaultException(Exception value);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectFolderItemProviderExtension {
    public abstract virtual Task`1<bool> CheckFolderItemOwnershipAsync(string evaluatedInclude);
    public abstract virtual Task`1<IReadOnlyDictionary`2<string, IEnumerable`1<KeyValuePair`2<string, string>>>> AddOwnedFolderItemsAsync(IReadOnlyDictionary`2<string, IEnumerable`1<KeyValuePair`2<string, string>>> items);
    public abstract virtual Task`1<IReadOnlyCollection`1<IProjectItem>> RemoveOwnedFolderItemsAsync(IReadOnlyCollection`1<IProjectItem> projectItems, DeleteOptions deleteOptions);
    public abstract virtual Task`1<ProjectItem> RenameOwnedFolderItemAsync(IProjectItem projectItem, string newValue);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectImportSnapshot {
    public string ProjectPath { get; }
    public string Label { get; }
    public string GroupLabel { get; }
    public IReadOnlyList`1<IProjectImportSnapshot> Imports { get; }
    public abstract virtual string get_ProjectPath();
    public abstract virtual string get_Label();
    public abstract virtual string get_GroupLabel();
    public abstract virtual IReadOnlyList`1<IProjectImportSnapshot> get_Imports();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectImportTreeSnapshot {
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectImportTreeSnapshotService {
    public abstract virtual Task`1<IProjectImportTreeSnapshot> GetCurrentImportTreeAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItem {
    public string ItemType { get; }
    public string UnevaluatedInclude { get; }
    public string EvaluatedInclude { get; }
    public string EvaluatedIncludeAsFullPath { get; }
    public string EvaluatedIncludeAsRelativePath { get; }
    public IProjectPropertiesContext PropertiesContext { get; }
    public IProjectProperties Metadata { get; }
    public abstract virtual string get_ItemType();
    public abstract virtual string get_UnevaluatedInclude();
    public abstract virtual string get_EvaluatedInclude();
    public abstract virtual string get_EvaluatedIncludeAsFullPath();
    public abstract virtual string get_EvaluatedIncludeAsRelativePath();
    public abstract virtual IProjectPropertiesContext get_PropertiesContext();
    public abstract virtual IProjectProperties get_Metadata();
    public abstract virtual Task SetItemTypeAsync(string value);
    public abstract virtual Task SetUnevaluatedIncludeAsync(string value);
    public abstract virtual Task RemoveAsync(DeleteOptions deleteOptions);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemByFileProvider {
    public abstract virtual Task`1<IProjectItem> AddAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata, string projectFileToChange);
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> AddAsync(IEnumerable`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items, string projectFileToChange);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemGeneratorProvider {
    public abstract virtual Task`1<string> GetDefaultGeneratorByFileExtensionAsync(string fileExtension);
}
[ProjectSystemContractAttribute("2", "2")]
[ProjectSystemContractAttribute("2", "0")]
[ProjectSystemContractAttribute("2", "0")]
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemIdentityChanging(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemIdentityChanging(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemIdentityChangedOnWriter(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemIdentityChangedOnWriter(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ItemIdentityChanged(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ItemIdentityChanged(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    public abstract virtual Task`1<IImmutableSet`1<string>> GetItemTypesAsync();
    public abstract virtual Task`1<IImmutableSet`1<string>> GetExistingItemTypesAsync();
    public abstract virtual Task`1<IProjectItem> AddAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> AddAsync(IEnumerable`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items);
    public abstract virtual Task`1<IProjectItem> AddAsync(string path);
    public abstract virtual Task`1<IReadOnlyList`1<IProjectItem>> AddAsync(IEnumerable`1<string> paths);
    public abstract virtual Task RemoveAsync(string itemType, string include, DeleteOptions deleteOptions);
    public abstract virtual Task RemoveAsync(IProjectItem item, DeleteOptions deleteOptions);
    public abstract virtual Task RemoveAsync(IEnumerable`1<IProjectItem> items, DeleteOptions deleteOptions);
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> GetItemsAsync();
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> GetItemsAsync(string itemType);
    public abstract virtual Task`1<IEnumerable`1<IProjectItem>> GetItemsAsync(string itemType, string evaluatedInclude);
    public abstract virtual Task`1<IProjectItem> FindItemByNameAsync(string evaluatedInclude);
    public abstract virtual Task`1<IProjectItem> GetItemAsync(IProjectPropertiesContext context);
    public abstract virtual Task SetUnevaluatedIncludesAsync(IReadOnlyCollection`1<KeyValuePair`2<IProjectItem, string>> renames);
    public abstract virtual Task`1<IReadOnlyCollection`1<IProjectItem>> GetItemsAsync(IReadOnlyCollection`1<IProjectPropertiesContext> context);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemRuleProvider {
    public bool IsFolder { get; }
    public abstract virtual bool get_IsFolder();
    public abstract virtual IImmutableSet`1<string> GetItemsRules(IProjectCatalogSnapshot projectCatalogSnapshot);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemSchema {
    public IContentType FallbackContentType { get; }
    public abstract virtual IContentType get_FallbackContentType();
    public abstract virtual Task`1<IContentType> GetContentTypeAsync(IProjectItem item);
    public abstract virtual IContentType GetContentType(string contentTypeName);
    public abstract virtual IContentType GetDefaultContentTypeForFile(string fileName, bool allowFallback);
    public abstract virtual IContentType GetDefaultContentTypeForItemType(string itemType);
    public abstract virtual IItemType GetItemType(string itemType);
    public abstract virtual IItemType GetItemType(IProjectItem item);
    public abstract virtual IEnumerable`1<string> GetKnownContentTypes();
    public abstract virtual IEnumerable`1<string> GetKnownFileExtensions();
    public abstract virtual IImmutableSet`1<string> GetKnownItemTypes();
    public abstract virtual IImmutableSet`1<string> GetKnownFolderTypes();
    public abstract virtual IContentType GetDefaultContentTypeForExtension(string extension);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemSchemaService {
    public abstract virtual Task`1<IProjectVersionedValue`1<IProjectItemSchema>> GetSchemaAsync(CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemTree {
    public bool IsLinked { get; }
    public IProjectPropertiesContext Item { get; }
    public IPropertySheet PropertySheet { get; }
    public abstract virtual bool get_IsLinked();
    public abstract virtual IProjectPropertiesContext get_Item();
    public abstract virtual IPropertySheet get_PropertySheet();
    public abstract virtual IProjectItemTree SetProperties(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, Nullable`1<bool> visible, Nullable`1<ProjectTreeFlags> flags, IProjectPropertiesContext context, IPropertySheet propertySheet, Nullable`1<bool> isLinked, bool resetFilePath, bool resetBrowseObjectProperties, bool resetIcon, bool resetExpandedIcon);
    public abstract virtual IProjectItemTree SetCaption(string caption);
    public abstract virtual IProjectItemTree SetIcon(ProjectImageMoniker icon);
    public abstract virtual IProjectItemTree SetExpandedIcon(ProjectImageMoniker expandedIcon);
    public abstract virtual IProjectItemTree SetVisible(bool visible);
    public abstract virtual IProjectItemTree SetBrowseObjectProperties(IRule browseObjectProperties);
    public abstract virtual IProjectItemTree SetFlags(ProjectTreeFlags flags);
    public abstract virtual IProjectItemTree SetIsLinked(bool isLinked);
    public abstract virtual IProjectItemTree SetItem(IProjectPropertiesContext projectPropertiesContext);
    public abstract virtual IProjectItemTree SetPropertySheet(IPropertySheet propertySheet);
    public abstract virtual IProjectTree ClearItem();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectItemTree2 {
    public abstract virtual IProjectItemTree2 SetProperties(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, Nullable`1<bool> visible, Nullable`1<ProjectTreeFlags> flags, IProjectPropertiesContext context, IPropertySheet propertySheet, Nullable`1<bool> isLinked, bool resetFilePath, bool resetBrowseObjectProperties, bool resetIcon, bool resetExpandedIcon, Nullable`1<int> displayOrder);
    public abstract virtual IProjectTree2 SetDisplayOrder(int displayOrder);
}
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectLockReleaser {
    public ProjectCollection ProjectCollection { get; }
    public IImmutableSet`1<string> WritableFiles { get; }
    public abstract virtual ProjectCollection get_ProjectCollection();
    public abstract virtual IImmutableSet`1<string> get_WritableFiles();
    public abstract virtual ProjectLockAwaiter GetAwaiter(ProjectLockAwaitable awaitable, ResourceAwaitable<ConfiguredProject, Project> resourceAwaitable);
    public abstract virtual ProjectLockAwaiter GetAwaiter(ProjectWriteLockAwaitable awaitable, ResourceAwaitable<ConfiguredProject, Project> resourceAwaitable);
    public abstract virtual bool IsCompleted(ResourceAwaiter<ConfiguredProject, Project> awaiter);
    public abstract virtual void OnCompleted(ResourceAwaiter<ConfiguredProject, Project> awaiter, Action action);
    public abstract virtual Task`1<Project> GetProjectAsync(ResourceReleaser<ConfiguredProject, Project> releaser, ConfiguredProject configuredProject, CancellationToken cancellationToken);
    public abstract virtual Task`1<ProjectRootElement> GetProjectXmlAsync(string projectFile, CancellationToken cancellationToken);
    public abstract virtual Task CheckoutAsync(string file);
    public abstract virtual Task CheckoutAsync(IEnumerable`1<string> files);
    public abstract virtual Task RenameAsync(ProjectWriteLockReleaser releaser, string oldFullPath, string newFullPath);
    public abstract virtual void OnDispose(ProjectLockReleaser releaser);
    public abstract virtual void OnDispose(ProjectWriteLockReleaser releaser);
    public abstract virtual Task OnReleaseAsync(ProjectLockReleaser releaser);
    public abstract virtual Task OnReleaseAsync(ProjectWriteLockReleaser releaser);
    public abstract virtual void SetAllResourcesToUnknownState();
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectLockService {
    public bool IsAnyLockHeld { get; }
    public bool IsAnyPassiveLockHeld { get; }
    public bool IsReadLockHeld { get; }
    public bool IsPassiveReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsPassiveUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public bool IsPassiveWriteLockHeld { get; }
    public abstract virtual bool get_IsAnyLockHeld();
    public abstract virtual bool get_IsAnyPassiveLockHeld();
    public abstract virtual bool get_IsReadLockHeld();
    public abstract virtual bool get_IsPassiveReadLockHeld();
    public abstract virtual bool get_IsUpgradeableReadLockHeld();
    public abstract virtual bool get_IsPassiveUpgradeableReadLockHeld();
    public abstract virtual bool get_IsWriteLockHeld();
    public abstract virtual bool get_IsPassiveWriteLockHeld();
    public abstract virtual ProjectLockAwaitable ReadLockAsync(CancellationToken cancellationToken);
    public abstract virtual ProjectLockAwaitable UpgradeableReadLockAsync(CancellationToken cancellationToken);
    public abstract virtual ProjectLockAwaitable UpgradeableReadLockAsync(ProjectLockFlags options, CancellationToken cancellationToken);
    public abstract virtual ProjectWriteLockAwaitable WriteLockAsync(CancellationToken cancellationToken);
    public abstract virtual ProjectWriteLockAwaitable WriteLockAsync(ProjectLockFlags options, CancellationToken cancellationToken);
    public abstract virtual ProjectLockSuppression HideLocks();
}
[ProjectSystemContractAttribute("0", "3")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectLockServiceInternal {
    public Task CurrentWriteLockTask { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReleasedWriteLock(AsyncEventHandler`1<ReleasingWriteLockEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReleasedWriteLock(AsyncEventHandler`1<ReleasingWriteLockEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReleasingWriteLock(AsyncEventHandler`1<ReleasingWriteLockEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReleasingWriteLock(AsyncEventHandler`1<ReleasingWriteLockEventArgs> value);
    public abstract virtual Task get_CurrentWriteLockTask();
    public abstract virtual IDisposable SuppressWriteLockCheck(string projectRootElementFullPath);
    public abstract virtual void OnBeforeWriteLockReleased(Func`1<Task> action);
    public abstract virtual void RegisterLockHoldingMainThreadJoinableIfApplicable(JoinableTask joinable);
    public abstract virtual void UnregisterLockHoldingMainThreadJoinable(JoinableTask joinable);
    public abstract virtual void PrepareReload(string filePath);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectReloader {
    public abstract virtual Task`1<bool> ReloadIfNecessaryAsync(UnconfiguredProject unconfiguredProject, bool promptUserBeforeReload);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectReloadInterceptor {
    public abstract virtual ProjectReloadResult InterceptProjectReload(ImmutableArray`1<ProjectPropertyElement> oldProperties, ImmutableArray`1<ProjectPropertyElement> newProperties);
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectSchemaUsageTelemetryService {
    public abstract virtual Task CollectTelemetryAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectScopeCapabilitiesSnapshot {
    public NamedIdentity ScopeIdentity { get; }
    public IImmutableDictionary`2<NamedIdentity, IProjectScopeCapabilitiesSnapshot> InheritedProjectScopeCapabilitiesSnapshots { get; }
    public abstract virtual NamedIdentity get_ScopeIdentity();
    public abstract virtual IImmutableDictionary`2<NamedIdentity, IProjectScopeCapabilitiesSnapshot> get_InheritedProjectScopeCapabilitiesSnapshots();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSecurityService {
    public bool IsBuildEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsDeployEnabled { get; }
    public bool IsPublishEnabled { get; }
    public abstract virtual bool get_IsBuildEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsDeployEnabled();
    public abstract virtual bool get_IsPublishEnabled();
    public abstract virtual Task ResolveSecurityIssues();
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectService {
    public IEnumerable`1<UnconfiguredProject> LoadedUnconfiguredProjects { get; }
    public IProjectServices Services { get; }
    public IProjectCapabilitiesScope Capabilities { get; }
    public abstract virtual IEnumerable`1<UnconfiguredProject> get_LoadedUnconfiguredProjects();
    public abstract virtual IProjectServices get_Services();
    public abstract virtual IProjectCapabilitiesScope get_Capabilities();
    public abstract virtual Task`1<UnconfiguredProject> LoadProjectAsync(string projectLocation, IImmutableSet`1<string> projectCapabilities);
    public abstract virtual Task`1<UnconfiguredProject> LoadProjectAsync(XmlReader reader, IImmutableSet`1<string> projectCapabilities);
    public abstract virtual Task`1<UnconfiguredProject> LoadProjectAsync(string projectLocation, bool delayAutoLoad, IImmutableSet`1<string> projectCapabilities);
    public abstract virtual Task UnloadProjectAsync(UnconfiguredProject project);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectServiceAccessor {
    public abstract virtual IProjectService GetProjectService(ProjectServiceThreadingModel threadingModel);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectServices {
    public IProjectLockService ProjectLockService { get; }
    public IProjectThreadingService ThreadingPolicy { get; }
    public IProjectFaultHandlerService FaultHandler { get; }
    public IProjectReloader ProjectReloader { get; }
    public abstract virtual IProjectLockService get_ProjectLockService();
    public abstract virtual IProjectThreadingService get_ThreadingPolicy();
    public abstract virtual IProjectFaultHandlerService get_FaultHandler();
    public abstract virtual IProjectReloader get_ProjectReloader();
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectSetting`2 {
    public TValue DefaultValue { get; }
    public TValue Value { get; }
    public abstract virtual TValue get_DefaultValue();
    public abstract virtual TValue get_Value();
    public abstract virtual Task`1<TValue> GetValueAsync(CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("0", "1")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectSettingsService {
    public abstract virtual Task`1<int> GetSettingInt32Async(string name, int defaultValue);
    public abstract virtual Task`1<long> GetSettingInt64Async(string name, long defaultValue);
    public abstract virtual Task`1<UInt32> GetSettingUInt32Async(string name, UInt32 defaultValue);
    public abstract virtual Task`1<ulong> GetSettingUInt64Async(string name, ulong defaultValue);
    public abstract virtual Task`1<string> GetSettingStringAsync(string name, string defaultValue);
    public abstract virtual Task`1<bool> GetSettingBooleanAsync(string name, bool defaultValue);
    public abstract virtual Task`1<T> GetSettingAsync(string name, T defaultValue);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSharedFolder {
    public string FolderPath { get; }
    public string ProjectPath { get; }
    public abstract virtual string get_FolderPath();
    public abstract virtual string get_ProjectPath();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSharedFoldersService {
    public abstract virtual Task`1<string> CreateSharedFolderAsync(string folderPath);
    public abstract virtual Task`1<bool> AddSharedFolderAsync(string sharedItemsPath);
    public abstract virtual Task RenameSharedFolderAsync(string sharedItemsPath, string newFolderName);
    public abstract virtual Task RemoveSharedFolderAsync(string sharedItemsPath);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSharedFoldersSnapshot {
    public string ProjectDirectory { get; }
    public abstract virtual string get_ProjectDirectory();
    public abstract virtual bool ContainsSharedFolder(string folderPath);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSharedFoldersSnapshotService {
    public abstract virtual Task`1<IProjectSharedFoldersSnapshot> GetSharedFoldersAsync();
}
[ProjectSystemContractAttribute("1", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectSharedImportRegister {
    public ImmutableHashSet`1<string> RegisteredSharedProjectFiles { get; }
    public abstract virtual ImmutableHashSet`1<string> get_RegisteredSharedProjectFiles();
    public abstract virtual Task RegisterInitialSharedProjectFilesAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSnapshot {
    public ProjectInstance ProjectInstance { get; }
    public Encoding ProjectFileEncoding { get; }
    public string FullPath { get; }
    public IImmutableDictionary`2<string, DateTime> DependentFileTimes { get; }
    public int EvaluationVersion { get; }
    public abstract virtual ProjectInstance get_ProjectInstance();
    public abstract virtual Encoding get_ProjectFileEncoding();
    public abstract virtual string get_FullPath();
    public abstract virtual IImmutableDictionary`2<string, DateTime> get_DependentFileTimes();
    public abstract virtual int get_EvaluationVersion();
}
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectSnapshotInternal {
    public IImmutableSet`1<string> ProjectFileExclusiveItemTypes { get; }
    public IReadOnlyCollection`1<GlobInfo> Globs { get; }
    public IReadOnlyCollection`1<string> IgnoredImports { get; }
    public bool IsProjectFileDirty { get; }
    public IImmutableDictionary`2<string, DateTime> AdditionalDependentFileTimes { get; }
    public abstract virtual IImmutableSet`1<string> get_ProjectFileExclusiveItemTypes();
    public abstract virtual IReadOnlyCollection`1<GlobInfo> get_Globs();
    public abstract virtual IReadOnlyCollection`1<string> get_IgnoredImports();
    public abstract virtual bool get_IsProjectFileDirty();
    public abstract virtual IImmutableDictionary`2<string, DateTime> get_AdditionalDependentFileTimes();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSnapshotService {
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSnapshotWithCapabilities {
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSnapshotWithCapabilitiesService {
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSourceItem {
    public abstract virtual Task RenameAsync(string newLeafName);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSourceItemProvider {
    public abstract virtual Task`1<string> GetDefaultItemTypeAsync(string fileName);
    public abstract virtual Task EnsureItemExcludedAsync(IEnumerable`1<string> items);
    public abstract virtual Task`1<ICollection`1<KeyValuePair`2<string, IProjectItem>>> GetAllLinkedItemsAsync();
    public abstract virtual Task`1<IProjectSourceItem> AddAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata, bool ensureUnique);
    public abstract virtual Task`1<IEnumerable`1<IProjectSourceItem>> AddAsync(IEnumerable`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items, bool ensureUnique);
    public abstract virtual Task`1<IEnumerable`1<IProjectSourceItem>> GetItemsByNameAsync(string evaluatedInclude);
    public abstract virtual Task RenameFileAsync(string evaluatedInclude, string newPath);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSourceItemProviderExtension {
    public abstract virtual Task`1<bool> CheckSourceItemOwnershipAsync(string itemType, string evaluatedInclude);
    public abstract virtual Task`1<bool> CheckProjectFileOwnershipAsync(string projectFilePath);
    public abstract virtual Task`1<IReadOnlyCollection`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>>> AddOwnedSourceItemsAsync(IReadOnlyCollection`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items);
    public abstract virtual Task`1<bool> TryAddSourceItemsToOwnedProjectFileAsync(IReadOnlyCollection`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items, string projectFilePath);
    public abstract virtual Task`1<IReadOnlyCollection`1<IProjectSourceItem>> RemoveOwnedSourceItemsAsync(IReadOnlyCollection`1<IProjectSourceItem> projectItems, DeleteOptions deleteOptions);
    public abstract virtual Task`1<ProjectItem> RenameOwnedSourceItemAsync(IProjectItem projectItem, string newValue);
    public abstract virtual Task`1<ProjectItem> SetItemTypeOfOwnedSourceItemAsync(IProjectItem projectItem, string newItemType);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSourceItemProviderExtension2 {
    public abstract virtual Task`1<IReadOnlyCollection`1<KeyValuePair`2<IProjectItem, ProjectItem>>> RenameOwnedSourceItemsAsync(IReadOnlyCollection`1<KeyValuePair`2<IProjectItem, string>> renames);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSubscriptionService {
    [ObsoleteAttribute("Use ProjectSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSnapshot>> ProjectBlock { get; }
    public IProjectValueDataSource`1<IProjectSnapshot> ProjectSource { get; }
    public IProjectValueDataSource`1<IProjectImportTreeSnapshot> ImportTreeSource { get; }
    public IProjectValueDataSource`1<IProjectSharedFoldersSnapshot> SharedFoldersSource { get; }
    public IProjectValueDataSource`1<IImmutableDictionary`2<string, IOutputGroup>> OutputGroupsSource { get; }
    [ObsoleteAttribute("Use ProjectCatalogSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCatalogSnapshot>> ProjectCatalogBlock { get; }
    public IProjectValueDataSource`1<IProjectCatalogSnapshot> ProjectCatalogSource { get; }
    [ObsoleteAttribute("Use ProjectRuleSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> ProjectRuleBlock { get; }
    public IProjectValueDataSource`1<IProjectSubscriptionUpdate> ProjectRuleSource { get; }
    [ObsoleteAttribute("Use ProjectBuildRuleSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> ProjectBuildRuleBlock { get; }
    public IProjectValueDataSource`1<IProjectSubscriptionUpdate> ProjectBuildRuleSource { get; }
    [ObsoleteAttribute("Use JointRuleSource.SourceBlock")]
public ISourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> JointRuleBlock { get; }
    public IProjectValueDataSource`1<IProjectSubscriptionUpdate> JointRuleSource { get; }
    [ObsoleteAttribute("Use SourceItemsRuleSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> SourceItemsRuleBlock { get; }
    public IProjectValueDataSource`1<IProjectSubscriptionUpdate> SourceItemsRuleSource { get; }
    [ObsoleteAttribute("Use SourceItemRuleNamesSource.SourceBlock")]
public IReceivableSourceBlock`1<IProjectVersionedValue`1<IImmutableSet`1<string>>> SourceItemRuleNamesBlock { get; }
    public IProjectValueDataSource`1<IImmutableSet`1<string>> SourceItemRuleNamesSource { get; }
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSnapshot>> get_ProjectBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectSnapshot> get_ProjectSource();
    public abstract virtual IProjectValueDataSource`1<IProjectImportTreeSnapshot> get_ImportTreeSource();
    public abstract virtual IProjectValueDataSource`1<IProjectSharedFoldersSnapshot> get_SharedFoldersSource();
    public abstract virtual IProjectValueDataSource`1<IImmutableDictionary`2<string, IOutputGroup>> get_OutputGroupsSource();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCatalogSnapshot>> get_ProjectCatalogBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectCatalogSnapshot> get_ProjectCatalogSource();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> get_ProjectRuleBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectSubscriptionUpdate> get_ProjectRuleSource();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> get_ProjectBuildRuleBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectSubscriptionUpdate> get_ProjectBuildRuleSource();
    public abstract virtual ISourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> get_JointRuleBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectSubscriptionUpdate> get_JointRuleSource();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectSubscriptionUpdate>> get_SourceItemsRuleBlock();
    public abstract virtual IProjectValueDataSource`1<IProjectSubscriptionUpdate> get_SourceItemsRuleSource();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IImmutableSet`1<string>>> get_SourceItemRuleNamesBlock();
    public abstract virtual IProjectValueDataSource`1<IImmutableSet`1<string>> get_SourceItemRuleNamesSource();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectSubscriptionUpdate {
    public IImmutableDictionary`2<string, IProjectChangeDescription> ProjectChanges { get; }
    public IImmutableDictionary`2<string, IProjectRuleSnapshot> CurrentState { get; }
    public ProjectConfiguration ProjectConfiguration { get; }
    public abstract virtual IImmutableDictionary`2<string, IProjectChangeDescription> get_ProjectChanges();
    public abstract virtual IImmutableDictionary`2<string, IProjectRuleSnapshot> get_CurrentState();
    public abstract virtual ProjectConfiguration get_ProjectConfiguration();
}
[ProjectSystemContractAttribute("0", "1")]
internal interface Microsoft.VisualStudio.ProjectSystem.IProjectTelemetryService {
    public abstract virtual Task PostEventAsync(string eventName, UnconfiguredProject unconfiguredProject, IEnumerable`1<KeyValuePair`2<string, object>> properties);
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectThreadingService {
    public JoinableTaskContextNode JoinableTaskContext { get; }
    public JoinableTaskFactory JoinableTaskFactory { get; }
    public bool IsOnMainThread { get; }
    public abstract virtual JoinableTaskContextNode get_JoinableTaskContext();
    public abstract virtual JoinableTaskFactory get_JoinableTaskFactory();
    public abstract virtual bool get_IsOnMainThread();
    public abstract virtual void ExecuteSynchronously(Func`1<Task> asyncAction);
    public abstract virtual T ExecuteSynchronously(Func`1<Task`1<T>> asyncAction);
    public abstract virtual void VerifyOnUIThread();
    public abstract virtual void Fork(Func`1<Task> asyncAction, JoinableTaskFactory factory, UnconfiguredProject unconfiguredProject, ConfiguredProject configuredProject, ErrorReportSettings watsonReportSettings, ProjectFaultSeverity faultSeverity, ForkOptions options);
    public abstract virtual IDisposable SuppressProjectExecutionContext();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTree {
    public IProjectTree Parent { get; }
    public IProjectTree Root { get; }
    public IReadOnlyList`1<IProjectTree> Children { get; }
    public string Caption { get; }
    public string FilePath { get; }
    public ProjectImageMoniker Icon { get; }
    public ProjectImageMoniker ExpandedIcon { get; }
    public bool Visible { get; }
    public bool IsFolder { get; }
    public ProjectTreeFlags Flags { get; }
    public IRule BrowseObjectProperties { get; }
    public IntPtr Identity { get; }
    public int Size { get; }
    public abstract virtual IProjectTree get_Parent();
    public abstract virtual IProjectTree get_Root();
    public abstract virtual IReadOnlyList`1<IProjectTree> get_Children();
    public abstract virtual string get_Caption();
    public abstract virtual string get_FilePath();
    public abstract virtual ProjectImageMoniker get_Icon();
    public abstract virtual ProjectImageMoniker get_ExpandedIcon();
    public abstract virtual bool get_Visible();
    public abstract virtual bool get_IsFolder();
    public abstract virtual ProjectTreeFlags get_Flags();
    public abstract virtual IRule get_BrowseObjectProperties();
    public abstract virtual IntPtr get_Identity();
    public abstract virtual int get_Size();
    public abstract virtual IProjectTree Add(IProjectTree subtree);
    public abstract virtual IProjectItemTree Add(IProjectItemTree subtree);
    public abstract virtual IProjectTree Remove(IProjectTree subtree);
    public abstract virtual IProjectTree Remove();
    public abstract virtual IProjectTree Replace(IProjectTree subtree);
    public abstract virtual IProjectItemTree Replace(IProjectItemTree subtree);
    public abstract virtual IProjectTree SetProperties(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, Nullable`1<bool> visible, Nullable`1<ProjectTreeFlags> flags, IProjectPropertiesContext context, IPropertySheet propertySheet, Nullable`1<bool> isLinked, bool resetFilePath, bool resetBrowseObjectProperties, bool resetIcon, bool resetExpandedIcon);
    public abstract virtual IProjectTree SetCaption(string caption);
    public abstract virtual IProjectTree SetIcon(ProjectImageMoniker icon);
    public abstract virtual IProjectTree SetExpandedIcon(ProjectImageMoniker expandedIcon);
    public abstract virtual IProjectTree SetVisible(bool visible);
    public abstract virtual IProjectTree SetBrowseObjectProperties(IRule browseObjectProperties);
    public abstract virtual IProjectTree SetFlags(ProjectTreeFlags flags);
    public abstract virtual IProjectItemTree SetItem(IProjectPropertiesContext context, IPropertySheet propertySheet, bool isLinked);
    public abstract virtual bool Contains(IntPtr nodeId);
    public abstract virtual IProjectTree Find(IntPtr nodeId);
    public abstract virtual bool TryFind(IntPtr nodeId, IProjectTree& subtree);
    public abstract virtual bool TryFindImmediateChild(string caption, IProjectTree& subtree);
    public abstract virtual IEnumerable`1<IProjectTreeDiff> ChangesSince(IProjectTree priorVersion);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTree2 {
    public int DisplayOrder { get; }
    public abstract virtual int get_DisplayOrder();
    public abstract virtual IProjectTree2 SetProperties(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, Nullable`1<bool> visible, Nullable`1<ProjectTreeFlags> flags, IProjectPropertiesContext context, IPropertySheet propertySheet, Nullable`1<bool> isLinked, bool resetFilePath, bool resetBrowseObjectProperties, bool resetIcon, bool resetExpandedIcon, Nullable`1<int> displayOrder);
    public abstract virtual IProjectTree2 SetDisplayOrder(int displayOrder);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeActionHandler {
    public abstract virtual bool CanRemove(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public abstract virtual Task RemoveAsync(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public abstract virtual bool CanCopy(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, IProjectTree receiver, bool deleteOriginal);
    public abstract virtual Task`1<bool> CanRenameAsync(IProjectTreeActionHandlerContext context, IProjectTree node);
    public abstract virtual Task RenameAsync(IProjectTreeActionHandlerContext context, IProjectTree node, string value);
    public abstract virtual string GetAddNewItemDirectory(IProjectTreeActionHandlerContext context, IProjectTree target);
    public abstract virtual bool CanIncludeItems(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual Task IncludeItemsAsync(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual bool CanExcludeItems(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual Task ExcludeItemsAsync(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeActionHandlerContext {
    public IProjectTreeProvider TreeProvider { get; }
    public IProjectTreeActionHandler SuccessorHandlerDelegator { get; }
    public abstract virtual IProjectTreeProvider get_TreeProvider();
    public abstract virtual IProjectTreeActionHandler get_SuccessorHandlerDelegator();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeCustomizablePropertyContext {
    public string ItemType { get; }
    public string ItemName { get; }
    public IImmutableDictionary`2<string, string> Metadata { get; }
    public ProjectTreeFlags ParentNodeFlags { get; }
    public bool ExistsOnDisk { get; }
    public IImmutableDictionary`2<string, string> ProjectTreeSettings { get; }
    public bool IsFolder { get; }
    public bool IsNonFileSystemProjectItem { get; }
    public abstract virtual string get_ItemType();
    public abstract virtual string get_ItemName();
    public abstract virtual IImmutableDictionary`2<string, string> get_Metadata();
    public abstract virtual ProjectTreeFlags get_ParentNodeFlags();
    public abstract virtual bool get_ExistsOnDisk();
    public abstract virtual IImmutableDictionary`2<string, string> get_ProjectTreeSettings();
    public abstract virtual bool get_IsFolder();
    public abstract virtual bool get_IsNonFileSystemProjectItem();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeCustomizablePropertyContext2 {
    public bool MultipleIncludedItem { get; }
    public abstract virtual bool get_MultipleIncludedItem();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeCustomizablePropertyContext3 {
    public bool IsLinkedFilesOnlyFolder { get; }
    public bool IsDuplicateItem { get; }
    public abstract virtual bool get_IsLinkedFilesOnlyFolder();
    public abstract virtual bool get_IsDuplicateItem();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeCustomizablePropertyValues {
    public ProjectTreeFlags Flags { get; public set; }
    public ProjectImageMoniker Icon { get; public set; }
    public ProjectImageMoniker ExpandedIcon { get; public set; }
    public abstract virtual ProjectTreeFlags get_Flags();
    public abstract virtual void set_Flags(ProjectTreeFlags value);
    public abstract virtual ProjectImageMoniker get_Icon();
    public abstract virtual void set_Icon(ProjectImageMoniker value);
    public abstract virtual ProjectImageMoniker get_ExpandedIcon();
    public abstract virtual void set_ExpandedIcon(ProjectImageMoniker value);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeCustomizablePropertyValues2 {
    public int DisplayOrder { get; public set; }
    public abstract virtual int get_DisplayOrder();
    public abstract virtual void set_DisplayOrder(int value);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeDiff {
    public ProjectTreeChangeKind Change { get; }
    public IntPtr NodeIdentity { get; }
    public ProjectTreeChangedProperty NodeChange { get; }
    public abstract virtual ProjectTreeChangeKind get_Change();
    public abstract virtual IntPtr get_NodeIdentity();
    public abstract virtual ProjectTreeChangedProperty get_NodeChange();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeFactory {
    public abstract virtual IProjectTree NewTree(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, IEnumerable`1<IProjectTree> children);
    public abstract virtual IProjectItemTree NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked, IEnumerable`1<IProjectTree> children);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeFactory2 {
    public abstract virtual IProjectTree2 NewTree(string caption, string filePath, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, IEnumerable`1<IProjectTree> children, int displayOrder);
    public abstract virtual IProjectItemTree2 NewTree(string caption, IProjectPropertiesContext item, IPropertySheet propertySheet, IRule browseObjectProperties, ProjectImageMoniker icon, ProjectImageMoniker expandedIcon, bool visible, Nullable`1<ProjectTreeFlags> flags, bool isLinked, IEnumerable`1<IProjectTree> children, int displayOrder);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreePropertiesProvider {
    public abstract virtual void CalculatePropertyValues(IProjectTreeCustomizablePropertyContext propertyContext, IProjectTreeCustomizablePropertyValues propertyValues);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreePropertiesProviderDataSource {
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeProvider {
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> Tree { get; }
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> get_Tree();
    public abstract virtual IProjectTree FindByPath(IProjectTree root, string path);
    public abstract virtual string GetPath(IProjectTree node);
    public abstract virtual Task`1<bool> CanRenameAsync(IProjectTree node);
    public abstract virtual Task RenameAsync(IProjectTree node, string value);
    public abstract virtual bool CanCopy(IImmutableSet`1<IProjectTree> nodes, IProjectTree receiver, bool deleteOriginal);
    public abstract virtual bool CanRemove(IImmutableSet`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public abstract virtual Task RemoveAsync(IImmutableSet`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public abstract virtual string GetAddNewItemDirectory(IProjectTree target);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeService {
    public IProjectTreeServiceState CurrentTree { get; }
    public abstract virtual IProjectTreeServiceState get_CurrentTree();
    public abstract virtual Task`1<IProjectTreeServiceState> PublishLatestTreeAsync(bool blockDuringLoadingTree, bool waitForFileSystemUpdates, CancellationToken cancellationToken);
    public abstract virtual Task`1<IProjectTreeServiceState> PublishTreeAsync(IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> minimumRequiredDataSourceVersions, CancellationToken cancellationToken);
    public abstract virtual Task`1<IProjectTreeServiceState> PublishAnyNonLoadingTreeAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IProjectTreeServiceState> PublishAnyNonNullTreeAsync(CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeServiceState {
    public IProjectTree Tree { get; }
    public IProjectVersionedValue`1<IProjectTreeSnapshot> TreeSnapshot { get; }
    public IProjectVersionedValue`1<IProjectSnapshot> ProjectSnapshot { get; }
    public IProjectVersionedValue`1<IProjectSubscriptionUpdate> SourceItems { get; }
    public IProjectTreeProvider TreeProvider { get; }
    public abstract virtual IProjectTree get_Tree();
    public abstract virtual IProjectVersionedValue`1<IProjectTreeSnapshot> get_TreeSnapshot();
    public abstract virtual IProjectVersionedValue`1<IProjectSnapshot> get_ProjectSnapshot();
    public abstract virtual IProjectVersionedValue`1<IProjectSubscriptionUpdate> get_SourceItems();
    public abstract virtual IProjectTreeProvider get_TreeProvider();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeSettingsProvider {
    public ICollection`1<string> ProjectPropertiesRules { get; }
    public abstract virtual ICollection`1<string> get_ProjectPropertiesRules();
    public abstract virtual void UpdateProjectTreeSettings(IImmutableDictionary`2<string, IProjectRuleSnapshot> ruleSnapshots, IImmutableDictionary`2& projectTreeSettings);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeSnapshot {
    public IProjectTree Tree { get; }
    public IProjectTreeProvider TreeProvider { get; }
    public ConfiguredProject PopulatingConfiguredProject { get; }
    public bool LazyFill { get; }
    public abstract virtual IProjectTree get_Tree();
    public abstract virtual IProjectTreeProvider get_TreeProvider();
    public abstract virtual ConfiguredProject get_PopulatingConfiguredProject();
    public abstract virtual bool get_LazyFill();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectTreeUniqueItemNameProvider {
    public abstract virtual Task`1<string> GenerateUniqueItemNameAsync(IProjectTreeProvider treeProvider, IProjectTree parentItem, string baseName, string extension, Nullable`1<bool> alwaysUseSuffix);
}
[ProjectSystemContractAttribute("0", "1")]
public interface Microsoft.VisualStudio.ProjectSystem.IProjectUserFaultHostHandler {
    public abstract virtual Task HandleUserFaultAsync(Exception failure, ProjectFaultSeverity severity, UnconfiguredProject project);
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource {
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public ISourceBlock`1<IProjectVersionedValue`1<object>> SourceBlock { get; }
    public abstract virtual NamedIdentity get_DataSourceKey();
    public abstract virtual IComparable get_DataSourceVersion();
    public abstract virtual ISourceBlock`1<IProjectVersionedValue`1<object>> get_SourceBlock();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource`1 {
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> SourceBlock { get; }
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> get_SourceBlock();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectValueVersions {
    public IImmutableDictionary`2<NamedIdentity, IComparable> DataSourceVersions { get; }
    public abstract virtual IImmutableDictionary`2<NamedIdentity, IComparable> get_DataSourceVersions();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectVersionedValue`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
public interface Microsoft.VisualStudio.ProjectSystem.IProjectVersionRequirement {
    public IComparable Version { get; }
    public bool AllowMissingData { get; }
    public abstract virtual IComparable get_Version();
    public abstract virtual bool get_AllowMissingData();
}
internal interface Microsoft.VisualStudio.ProjectSystem.IReadOnlySet`1 {
    public abstract virtual bool Contains(T t);
}
public interface Microsoft.VisualStudio.ProjectSystem.IRefreshableHintableProjectTreeProvider {
    public IComparable MostRecentHintVersion { get; }
    public abstract virtual IComparable get_MostRecentHintVersion();
    public abstract virtual HintedTreeResult HintFileChanged(string path);
    public abstract virtual HintedTreeResult HintFileCreated(string path);
    public abstract virtual HintedTreeResult HintFileDeleted(string path);
    public abstract virtual HintedTreeResult HintFileRenamed(string oldPath, string newFileName);
}
public interface Microsoft.VisualStudio.ProjectSystem.IRefreshableProjectTreeProvider {
    public abstract virtual Task`1<bool> GetAutoRefreshAsync();
    public abstract virtual Task SetAutoRefreshAsync(bool value);
    public abstract virtual Task`1<bool> CanAutoRefreshAsync();
    public abstract virtual Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> RefreshAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.VisualStudio.ProjectSystem.IRemoteSetting`1 {
    public T Default { get; }
    public string SettingName { get; }
    public abstract virtual T get_Default();
    public abstract virtual string get_SettingName();
}
[ProjectSystemContractAttribute("1", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.ISharedImportSnapshotService {
}
[ProjectSystemContractAttribute("0", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.ISharedProjectFileRegistrationService {
    public abstract virtual void RegisterSharedProjectFiles(IReadOnlyCollection`1<string> sharedFileFullPaths, string sharedFileUserFullPath, RegistrationOption options, string categoryName);
    public abstract virtual Task UnregisterAnySharedProjectFilesAsync(string sharedFileUserFullPath);
    public abstract virtual void RegisterSharedProjectFileCategories(string sharedFileUserFullPath, IReadOnlyCollection`1<string> allPossibleProjectFileCategories);
    public abstract virtual Task`1<bool> ReloadSharedProjectFileAsync(string sharedFileFullPath);
    public abstract virtual IReadOnlyCollection`1<string> GetUserFullPathsOfSharedProjectFile(string sharedFileFullPath);
    public abstract virtual IReadOnlyCollection`1<Guid> GetUsersOfSharedProjectFile(string sharedFileFullPath);
    public abstract virtual string GetOwnerProjectForSharedProjectFile(string sharedFileFullPath);
    public abstract virtual void EnsureUsersOfSharedProjectFileAreLoaded(string sharedFileFullPath);
    public abstract virtual void EnsureActiveUserOfSharedProjectFileIsLoaded(string sharedFileFullPath);
    public abstract virtual Task`1<bool> IsSharedProjectFilesManagerHierarchyLoadedAsync();
    public abstract virtual bool QueryRenameSharedProjectFile(string oldSharedFileFullPath, string newSharedFileFullPath);
    public abstract virtual void OnAfterRenameSharedProjectFile(string oldSharedFileFullPath, string newSharedFileFullPath);
}
public interface Microsoft.VisualStudio.ProjectSystem.IShowAllFilesProjectTreeProvider {
    public bool ShowAllFiles { get; public set; }
    public abstract virtual bool get_ShowAllFiles();
    public abstract virtual void set_ShowAllFiles(bool value);
    public abstract virtual bool CanIncludeItems(IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual Task IncludeItemsAsync(IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual bool CanExcludeItems(IImmutableSet`1<IProjectTree> nodes);
    public abstract virtual Task ExcludeItemsAsync(IImmutableSet`1<IProjectTree> nodes);
}
[ProjectSystemContractAttribute("0", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.ISourceCodeControlIntegration {
    public abstract virtual Task`1<bool> CanChangeProjectFilesAsync(IReadOnlyCollection`1<string> projectFullPaths);
}
internal interface Microsoft.VisualStudio.ProjectSystem.ISourceItemsServiceInternal {
    public ImmutableHashSet`1<string> UnitTestingInitialization { get; public set; }
    public abstract virtual ImmutableHashSet`1<string> get_UnitTestingInitialization();
    public abstract virtual void set_UnitTestingInitialization(ImmutableHashSet`1<string> value);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.ISpecialFileProvider {
    public abstract virtual Task`1<string> GetFileAsync(SpecialFiles fileId, SpecialFileFlags flags, CancellationToken cancellationToken);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ItemEventArgs`1 : EventArgs {
    public T Item { get; }
    public abstract virtual T get_Item();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ItemIdentityChangedEventArgs : EventArgs {
    public IProjectItem Item { get; }
    public string PropertySheet { get; }
    public string OldItemType { get; }
    public string NewItemType { get; }
    public string OldUnevaluatedInclude { get; }
    public string NewUnevaluatedInclude { get; }
    public string OldEvaluatedInclude { get; }
    public string NewEvaluatedInclude { get; }
    public bool HasItemTypeChanged { get; }
    public bool HasUnevaluatedIncludeChanged { get; }
    public abstract virtual IProjectItem get_Item();
    public abstract virtual string get_PropertySheet();
    public abstract virtual string get_OldItemType();
    public abstract virtual string get_NewItemType();
    public abstract virtual string get_OldUnevaluatedInclude();
    public abstract virtual string get_NewUnevaluatedInclude();
    public abstract virtual string get_OldEvaluatedInclude();
    public abstract virtual string get_NewEvaluatedInclude();
    public abstract virtual bool get_HasItemTypeChanged();
    public abstract virtual bool get_HasUnevaluatedIncludeChanged();
}
internal interface Microsoft.VisualStudio.ProjectSystem.IUnconfiguredProjectInternalServices {
    public IVsUnconfiguredProjectIntegrationService VsUnconfiguredProjectIntegrationService { get; }
    public abstract virtual IVsUnconfiguredProjectIntegrationService get_VsUnconfiguredProjectIntegrationService();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IUnconfiguredProjectServices {
    public IActiveConfiguredProjectSubscriptionService ActiveConfiguredProjectSubscription { get; }
    public IActiveConfiguredProjectProvider ActiveConfiguredProjectProvider { get; }
    public IProjectAsynchronousTasksService ProjectAsynchronousTasks { get; }
    public IProjectConfigurationsService ProjectConfigurationsService { get; }
    public object HostObject { get; }
    public IProjectCapabilitiesRequirementsService ProjectCapabilitiesRequirementsService { get; }
    public abstract virtual IActiveConfiguredProjectSubscriptionService get_ActiveConfiguredProjectSubscription();
    public abstract virtual IActiveConfiguredProjectProvider get_ActiveConfiguredProjectProvider();
    public abstract virtual IProjectAsynchronousTasksService get_ProjectAsynchronousTasks();
    public abstract virtual IProjectConfigurationsService get_ProjectConfigurationsService();
    public abstract virtual object get_HostObject();
    public abstract virtual IProjectCapabilitiesRequirementsService get_ProjectCapabilitiesRequirementsService();
}
public interface Microsoft.VisualStudio.ProjectSystem.IVersionedProjectCapabilitiesSnapshot {
    public Nullable`1<long> Version { get; }
    public abstract virtual Nullable`1<long> get_Version();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IVetoProjectLoad {
    public abstract virtual Task`1<bool> AllowProjectLoadAsync(bool isNewProject, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.IVetoProjectPreLoad {
    public abstract virtual Task`1<bool> AllowProjectLoadAsync(bool isNewProject, ProjectConfiguration activeConfiguration, CancellationToken cancellationToken);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.IVsProjectExtensions {
    public abstract virtual Task`1<IImmutableDictionary`2<string, string>> GetUserPropertiesAsync();
    public abstract virtual Task SetUserPropertiesAsync(IImmutableDictionary`2<string, string> properties);
}
[ProjectSystemContractAttribute("0", "0")]
internal interface Microsoft.VisualStudio.ProjectSystem.IVsShellServices {
    public bool OnUIThread { get; }
    public string InstallDirectory { get; }
    public string SolutionFilePath { get; }
    public string RegistryRoot { get; }
    public object VSHelpService { get; }
    public object BuildOutputWindowPane { get; }
    public int ProductSku { get; }
    public bool IsSolutionBuildManagerPresent { get; }
    public bool IsSynchronousSolutionOperationInProgress { get; }
    public bool IsBuildInProgress { get; }
    public bool IsSolutionBuildInProgress { get; }
    public int BuildMaxNodeCount { get; }
    public bool IsLaunchInProgress { get; }
    public bool IsSolutionBuildManagerBusy { get; }
    public bool IsInCommandLineMode { get; }
    public bool IsInExperimentalMode { get; }
    public bool UseEnvironment { get; }
    public abstract virtual bool get_OnUIThread();
    public abstract virtual string get_InstallDirectory();
    public abstract virtual string get_SolutionFilePath();
    public abstract virtual string get_RegistryRoot();
    public abstract virtual object get_VSHelpService();
    public abstract virtual object get_BuildOutputWindowPane();
    public abstract virtual int get_ProductSku();
    public abstract virtual bool get_IsSolutionBuildManagerPresent();
    public abstract virtual bool get_IsSynchronousSolutionOperationInProgress();
    public abstract virtual bool get_IsBuildInProgress();
    public abstract virtual bool get_IsSolutionBuildInProgress();
    public abstract virtual int get_BuildMaxNodeCount();
    public abstract virtual bool get_IsLaunchInProgress();
    public abstract virtual bool get_IsSolutionBuildManagerBusy();
    public abstract virtual bool get_IsInCommandLineMode();
    public abstract virtual bool get_IsInExperimentalMode();
    public abstract virtual bool get_UseEnvironment();
    public abstract virtual void LogProjectLoadMessage(string message);
    public abstract virtual void LogProjectLoadWarning(string message, string file, int line, int column);
    public abstract virtual void LogProjectLoadError(string message, string file, int line, int column);
    public abstract virtual void EnsureBuildManagerAccessorIsLoaded();
    public abstract virtual Font GetDialogFont(bool bold);
    public abstract virtual void ShowHelpFromF1Keyword(string f1Keyword);
    public abstract virtual void ShowHelpFromUrl(string helpUrl);
    public abstract virtual void ShowHelpFromId(string helpFile, int helpContext);
    public abstract virtual IntPtr GetDialogParentHandle();
    public abstract virtual void EnableModeless(bool enable);
    public abstract virtual PropertyGrid CreatePropertyGrid();
    public abstract virtual void UpdatePropertyGrid();
    public abstract virtual void RegisterLogger(int submissionId, ILogger logger);
    public abstract virtual void UnregisterLoggers(int submissionId);
    public abstract virtual void UpdateCommandUI(bool immediate);
    public abstract virtual void UpdateDebugTargets();
    public abstract virtual IAsyncDisposable StartIgnoringFiles(string file, bool notifyChangeAtEnd);
    public abstract virtual IAsyncDisposable StartIgnoringFiles(IEnumerable`1<string> files, bool notifyChangeAtEnd);
    public abstract virtual Task`1<bool> IsSolutionBuildManagerPresentAsync();
}
[ProjectSystemContractAttribute("1", "1")]
public interface Microsoft.VisualStudio.ProjectSystem.IVsUnconfiguredProjectIntegrationService {
    public Guid ProjectTypeGuid { get; }
    public ProjectConfiguration SuggestedInitialActiveConfiguration { get; public set; }
    public ProjectConfiguration ActiveProjectConfiguration { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActiveProjectConfigurationChanged(AsyncEventHandler`1<UnconfiguredProjectActiveConfigurationChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActiveProjectConfigurationChanged(AsyncEventHandler`1<UnconfiguredProjectActiveConfigurationChangedEventArgs> value);
    public abstract virtual Guid get_ProjectTypeGuid();
    public abstract virtual ProjectConfiguration get_SuggestedInitialActiveConfiguration();
    public abstract virtual void set_SuggestedInitialActiveConfiguration(ProjectConfiguration value);
    public abstract virtual ProjectConfiguration get_ActiveProjectConfiguration();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.LazyExtensions : object {
    [ExtensionAttribute]
internal static void EvaluateNow(Lazy`1<T> lazyValue);
    [ExtensionAttribute]
internal static void DisposeIfCreated(Lazy`1<T> lazyInitializedField);
    [ExtensionAttribute]
internal static void DisposeIfCreated(IEnumerable`1<Lazy`1<T>> lazyInitializedField);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.MefExtensions : object {
    [ExtensionAttribute]
public static T GetExportedValueOrDefault(ExportProvider exportProvider);
    [ExtensionAttribute]
public static T GetExportedValueOrDefault(ExportProvider exportProvider, string contractName);
    [ExtensionAttribute]
public static T GetService(ExportProvider exportProvider, bool allowDefault);
    [ExtensionAttribute]
public static Lazy`1<T> GetServiceLazy(ExportProvider exportProvider, bool allowDefault);
    [ExtensionAttribute]
internal static T FindByMetadata(IEnumerable`1<Lazy`2<T, IDictionary`2<string, object>>> exports, string metadataName, string metadataValue);
    [ExtensionAttribute]
internal static Lazy`2<T, IDictionary`2<string, object>> FindExportByMetadata(IEnumerable`1<Lazy`2<T, IDictionary`2<string, object>>> exports, string metadataName, string metadataValue);
    [ExtensionAttribute]
internal static T FindByMetadata(IEnumerable`1<Lazy`2<T, TMetadata>> exports, Predicate`1<TMetadata> metadataCheck);
    [ExtensionAttribute]
internal static Lazy`2<T, TMetadata> FindExportByMetadata(IEnumerable`1<Lazy`2<T, TMetadata>> exports, Predicate`1<TMetadata> metadataCheck);
    [ExtensionAttribute]
internal static T FindNamedExport(IEnumerable`1<Lazy`2<T, INamedExportMetadataView>> exports, string name);
    [ExtensionAttribute]
internal static T FindByMetadata(IEnumerable`1<ExportFactory`2<T, IDictionary`2<string, object>>> exportFactories, string metadataName, string metadataValue);
    [ExtensionAttribute]
internal static ExportFactory`2<T, IDictionary`2<string, object>> FindExportFactoryByMetadata(IEnumerable`1<ExportFactory`2<T, IDictionary`2<string, object>>> exportFactories, string metadataName, string metadataValue);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.MefExtensions/<ExtensionValuesWithMetadata>d__11`2")]
[ExtensionAttribute]
internal static IEnumerable`1<Lazy`2<T, TMetadata>> ExtensionValuesWithMetadata(IEnumerable`1<Lazy`2<T, TMetadata>> extensions);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.MefExtensions/<ExtensionValues>d__12`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> ExtensionValues(IEnumerable`1<Lazy`1<T>> extensions, bool onlyCreatedValues);
    [ExtensionAttribute]
internal static IEnumerable`1<T> ExtensionValues(IEnumerable`1<Lazy`2<T, TMetadata>> extensions, bool onlyCreatedValues);
    [ExtensionAttribute]
internal static bool TryGetValue(IReadOnlyDictionary`2<string, object> metadata, string key, TValue& value);
}
[DebuggerDisplayAttribute("MinimalProjectConfiguration: {Name}")]
public class Microsoft.VisualStudio.ProjectSystem.MinimalProjectConfiguration : BaseStandardProjectConfiguration {
    public string Configuration { get; }
    public string Platform { get; }
    public MinimalProjectConfiguration(string name, string configuration, string platform);
    public sealed virtual string get_Configuration();
    public sealed virtual string get_Platform();
    private static ImmutableDictionary`2<string, string> CreateDimensions(string configuration, string platform);
    public sealed virtual bool Equals(IMinimalProjectConfiguration other);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.MSBuildUtilities : object {
    public static char ValueSeparatorChar;
    internal static Char[] ValueSeparatorCharArray;
    internal static Char[] WildCardCharArray;
    internal static string DefiningProjectFullPath;
    internal static string ValueSeparatorCharString;
    internal static string SharedImportLabel;
    internal static string FileTimeFormat;
    private static String[] SkippedBuiltInMetadata;
    internal static String[] FileItemOnlyMetadata;
    private static Regex DimensionNameInConditionRegex;
    private static Lazy`1<ICollection`1<string>> builtInMetadataNames;
    internal static IEnumerable`1<string> BuiltInItemMetadataNames { get; }
    private static MSBuildUtilities();
    internal static IEnumerable`1<string> get_BuiltInItemMetadataNames();
    [ExtensionAttribute]
internal static ProjectBuildMessage ToBuildErrorMessage(InvalidProjectFileException exception, string messageFormat, string projectFile);
    [ExtensionAttribute]
internal static void RemoveSelf(ProjectElement element);
    internal static bool UsesWildCards(string value);
    internal static IEnumerable`1<ProjectItem> GetProjectItems(Project project, string itemType, string unevaluatedInclude);
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetNonImportedItemTypes(Project project);
    internal static bool IsBuiltInItemMetadataName(string metadataName);
    [ExtensionAttribute]
internal static IEnumerable`1<ProjectItem> GetProjectItemsByUnevaluatedInclude(Project project, string itemType, string unevaluatedInclude);
    [ExtensionAttribute]
internal static ProjectItem GetFirstProjectItemByInclude(Project project, string itemType, string unevaluatedInclude, string evaluatedInclude);
    [ExtensionAttribute]
internal static IEnumerable`1<ProjectItem> GetProjectItemsByEvaluatedInclude(Project project, string itemType, string evaluatedInclude);
    [ExtensionAttribute]
internal static ProjectItem GetFirstProjectItemByEvaluatedInclude(Project project, string itemType, string evaluatedInclude);
    [ExtensionAttribute]
internal static ProjectItem GetFirstProjectItemByEvaluatedIncludePathComparison(Project project, string itemType, string evaluatedInclude);
    internal static string DimensionalValuePairsToCondition(IReadOnlyDictionary`2<string, string> dimensionalValues);
    internal static bool ConditionToDimensionValues(string condition, IReadOnlyDictionary`2& dimensionalValues);
    internal static bool AreDimensionalVectorsEqual(IReadOnlyDictionary`2<string, string> left, IReadOnlyDictionary`2<string, string> right);
    internal static bool AreConditionsEqual(string left, string right);
    internal static string ComposeExistsCondition(string path);
    internal static bool HasEffectiveCondition(ProjectElement element, string condition);
    [ExtensionAttribute]
internal static ProjectMetadataElement SetMetadata(ProjectItemElement itemXml, string name, string value, bool asAttribute);
    [ExtensionAttribute]
internal static bool DeleteMetadata(ProjectItemElement itemXml, string name);
    [ExtensionAttribute]
internal static string GetMetadataValue(ProjectItemElement itemXml, string name);
    [ExtensionAttribute]
internal static KeyValuePair`2<string, IImmutableDictionary`2<string, string>> GetImmutableSnapshot(ITaskItem item);
    [ExtensionAttribute]
internal static KeyValuePair`2<string, IImmutableDictionary`2<string, string>> GetImmutableSnapshot(ProjectItem item);
    [ExtensionAttribute]
internal static Rule Extend(Rule baseRule, Rule extendingRule, XamlSchemaContext context);
    internal static string GetMetadataOrEmpty(ITaskItem item, string name);
    private static bool UnquoteString(String& s);
    private static ICollection`1<string> InitializeBuiltInMetadataNames();
    private static T DeepCloneWithXaml(T obj, XamlSchemaContext context);
}
internal class Microsoft.VisualStudio.ProjectSystem.NameCollisionException : IOException {
    public NameCollisionException(string message);
    public NameCollisionException(string message, Exception innerException);
    protected NameCollisionException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("{Id} ({Name})")]
public class Microsoft.VisualStudio.ProjectSystem.NamedIdentity : object {
    private static int lastGeneratedIdentity;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Id { get; private set; }
    public string Name { get; private set; }
    public NamedIdentity(string name);
    private static NamedIdentity();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamedIdentity other);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(NamedIdentity other);
    public virtual string ToString();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.OnceInitializedOnceDisposed : object {
    private object syncObject;
    private bool synchronousDisposal;
    private LifetimeState lifecycle;
    private bool wasInitialized;
    public bool IsDisposed { get; }
    protected bool IsInitializing { get; }
    protected bool IsInitialized { get; }
    protected bool IsDisposing { get; }
    protected object SyncObject { get; }
    protected OnceInitializedOnceDisposed(bool synchronousDisposal);
    public sealed virtual bool get_IsDisposed();
    protected bool get_IsInitializing();
    protected bool get_IsInitialized();
    protected bool get_IsDisposing();
    protected object get_SyncObject();
    public sealed virtual void Dispose();
    public Task DisposeAsync();
    protected void EnsureInitialized(bool allowInitializing);
    protected abstract virtual void Initialize();
    protected abstract virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <DisposeAsync>b__17_0();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.OnceInitializedOnceDisposedAsync : object {
    private AsyncLazy`1<object> initializeTrigger;
    private AsyncManualResetEvent initializationCompletionEvent;
    private AsyncLazy`1<object> disposeTrigger;
    private CancellationTokenSource disposingToken;
    [CompilerGeneratedAttribute]
private JoinableTaskCollection <JoinableCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskFactory <JoinableFactory>k__BackingField;
    public bool IsDisposing { get; }
    public bool IsDisposed { get; }
    protected bool IsInitializing { get; }
    protected bool IsInitialized { get; }
    protected JoinableTaskCollection JoinableCollection { get; protected set; }
    protected JoinableTaskFactory JoinableFactory { get; protected set; }
    protected Task InitializationCompletion { get; }
    protected CancellationToken DisposalToken { get; }
    protected OnceInitializedOnceDisposedAsync(JoinableTaskContextNode joinableTaskContextNode);
    public bool get_IsDisposing();
    public sealed virtual bool get_IsDisposed();
    protected bool get_IsInitializing();
    protected bool get_IsInitialized();
    [CompilerGeneratedAttribute]
protected JoinableTaskCollection get_JoinableCollection();
    [CompilerGeneratedAttribute]
protected void set_JoinableCollection(JoinableTaskCollection value);
    [CompilerGeneratedAttribute]
protected JoinableTaskFactory get_JoinableFactory();
    [CompilerGeneratedAttribute]
protected void set_JoinableFactory(JoinableTaskFactory value);
    protected Task get_InitializationCompletion();
    protected CancellationToken get_DisposalToken();
    public sealed virtual void Dispose();
    public Task DisposeAsync();
    protected Task InitializeAsync(CancellationToken cancellationToken);
    protected abstract virtual Task InitializeCoreAsync(CancellationToken cancellationToken);
    protected abstract virtual Task DisposeCoreAsync(bool initialized);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.OnceInitializedOnceDisposedAsync/<<-ctor>b__4_0>d")]
[CompilerGeneratedAttribute]
private Task`1<object> <.ctor>b__4_0();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.OnceInitializedOnceDisposedAsync/<<-ctor>b__4_1>d")]
[CompilerGeneratedAttribute]
private Task`1<object> <.ctor>b__4_1();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.OnceInitializedOnceDisposedAsync/<<InitializeAsync>b__27_0>d")]
[CompilerGeneratedAttribute]
private Task <InitializeAsync>b__27_0();
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.OnOffComponent : OnceInitializedOnceDisposed {
    protected object syncObject;
    [CompilerGeneratedAttribute]
private LifetimeHelper <CurrentLifetime>k__BackingField;
    protected LifetimeHelper CurrentLifetime { get; private set; }
    [CompilerGeneratedAttribute]
protected LifetimeHelper get_CurrentLifetime();
    [CompilerGeneratedAttribute]
private void set_CurrentLifetime(LifetimeHelper value);
    protected void TurnOn(Object[] parameters);
    protected void TurnOff();
    protected virtual void Dispose(bool disposing);
    protected virtual void Initialize();
    protected abstract virtual LifetimeHelper CreateSingleLifetime(Object[] parameters);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.OnOffComponentAsync : OnceInitializedOnceDisposedAsync {
    private object syncObject;
    [CompilerGeneratedAttribute]
private AsyncLifetimeHelper <CurrentLifetime>k__BackingField;
    protected AsyncLifetimeHelper CurrentLifetime { get; private set; }
    protected OnOffComponentAsync(JoinableTaskContextNode joinableTaskContextNode);
    [CompilerGeneratedAttribute]
protected AsyncLifetimeHelper get_CurrentLifetime();
    [CompilerGeneratedAttribute]
private void set_CurrentLifetime(AsyncLifetimeHelper value);
    protected Task TurnOnAsync(Object[] parameters);
    protected Task TurnOffAsync();
    protected virtual Task DisposeCoreAsync(bool initialized);
    protected virtual Task InitializeCoreAsync(CancellationToken cancellationToken);
    protected abstract virtual AsyncLifetimeHelper CreateSingleLifetime(Object[] parameters);
}
public class Microsoft.VisualStudio.ProjectSystem.OperationCanceledBySourceControlException : OperationCanceledException {
    private IImmutableSet`1<string> rejectedFiles;
    public IImmutableSet`1<string> RejectedFiles { get; public set; }
    public OperationCanceledBySourceControlException(string message);
    public OperationCanceledBySourceControlException(string message, IImmutableSet`1<string> files);
    public OperationCanceledBySourceControlException(string message, Exception inner);
    protected OperationCanceledBySourceControlException(SerializationInfo info, StreamingContext context);
    public IImmutableSet`1<string> get_RejectedFiles();
    public void set_RejectedFiles(IImmutableSet`1<string> value);
}
[AttributeUsageAttribute("1476")]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.OrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <OrderPrecedence>k__BackingField;
    public int OrderPrecedence { get; private set; }
    public OrderAttribute(int orderPrecedence);
    [CompilerGeneratedAttribute]
public int get_OrderPrecedence();
    [CompilerGeneratedAttribute]
private void set_OrderPrecedence(int value);
}
public class Microsoft.VisualStudio.ProjectSystem.OrderPrecedenceExportFactoryCollection`1 : OrderPrecedenceExportFactoryCollection`2<T, IOrderPrecedenceMetadataView> {
    public OrderPrecedenceExportFactoryCollection`1(PreferenceOrder orderingStyle);
}
public class Microsoft.VisualStudio.ProjectSystem.OrderPrecedenceExportFactoryCollection`2 : object {
    private List`1<ExportFactory`2<T, TMetadata>> list;
    private IComparer`1<int> comparer;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderPrecedenceExportFactoryCollection`2(PreferenceOrder orderingStyle);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(ExportFactory`2<T, TMetadata> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ExportFactory`2<T, TMetadata> item);
    public sealed virtual void CopyTo(ExportFactory`2[] array, int arrayIndex);
    public sealed virtual bool Remove(ExportFactory`2<T, TMetadata> item);
    public sealed virtual IEnumerator`1<ExportFactory`2<T, TMetadata>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.VisualStudio.ProjectSystem.OrderPrecedenceImportCollection`1 : OrderPrecedenceImportCollection`2<T, IOrderPrecedenceMetadataView> {
    public OrderPrecedenceImportCollection`1(PreferenceOrder orderingStyle);
    public OrderPrecedenceImportCollection`1(PreferenceOrder orderingStyle, IProjectCapabilitiesScope projectCapabilityCheckScope);
    public OrderPrecedenceImportCollection`1(PreferenceOrder orderingStyle, IProjectService projectCapabilityCheckProvider);
    public OrderPrecedenceImportCollection`1(PreferenceOrder orderingStyle, UnconfiguredProject projectCapabilityCheckProvider);
    public OrderPrecedenceImportCollection`1(PreferenceOrder orderingStyle, ConfiguredProject projectCapabilityCheckProvider);
}
public class Microsoft.VisualStudio.ProjectSystem.OrderPrecedenceImportCollection`2 : object {
    private object syncObject;
    private List`1<Lazy`2<T, TMetadata>> list;
    private IComparer`1<int> comparer;
    private IProjectCapabilitiesScope projectCapabiliesScope;
    private bool isListSorted;
    private Nullable`1<long> filterVersion;
    private ImmutableArray`1<Lazy`2<T, TMetadata>> filteredSnapshot;
    private IProjectCapabilitiesRequirements filteredSnapshotDependencies;
    private WeakReference lastestSnapshot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderPrecedenceImportCollection`2(PreferenceOrder orderingStyle, IProjectCapabilitiesScope projectCapabilityCheckScope);
    public OrderPrecedenceImportCollection`2(PreferenceOrder orderingStyle, IProjectService projectCapabilityCheckProvider);
    public OrderPrecedenceImportCollection`2(PreferenceOrder orderingStyle, UnconfiguredProject projectCapabilityCheckProvider);
    public OrderPrecedenceImportCollection`2(PreferenceOrder orderingStyle, ConfiguredProject projectCapabilityCheckProvider);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(Lazy`2<T, TMetadata> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Lazy`2<T, TMetadata> item);
    public sealed virtual void CopyTo(Lazy`2[] array, int arrayIndex);
    public sealed virtual bool Remove(Lazy`2<T, TMetadata> item);
    public Enumerator<Lazy`2<T, TMetadata>> GetEnumerator();
    private sealed virtual override IEnumerator`1<Lazy`2<T, TMetadata>> System.Collections.Generic.IEnumerable<System.Lazy<T,TMetadata>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Lazy`2<T, TMetadata> Single();
    public Lazy`2<T, TMetadata> SingleOrDefault();
    public Lazy`2<T, TMetadata> FirstOrDefault();
    public Lazy`2<T, TMetadata> First();
    protected ImmutableArray`1<Lazy`2<T, TMetadata>> GetFilteredSnapshot();
    private static IEnumerable`1<Lazy`2<T, TMetadata>> WhereAppliesTo(IEnumerable`1<Lazy`2<T, TMetadata>> exports, IProjectCapabilitiesSnapshot projectCapabilityHitTester, Builder<string, bool> dependenciesBuilder);
    private void InvalidateFilteredSnapshot();
    [CompilerGeneratedAttribute]
private int <GetFilteredSnapshot>b__29_0(Lazy`2<T, TMetadata> v1, Lazy`2<T, TMetadata> v2);
}
public class Microsoft.VisualStudio.ProjectSystem.PasteItemsResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private DropEffects <ActualEffect>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TotalDropItems>k__BackingField;
    public bool Success { get; private set; }
    public DropEffects ActualEffect { get; private set; }
    public Nullable`1<int> TotalDropItems { get; private set; }
    public PasteItemsResult(bool success, DropEffects actualEffect);
    public PasteItemsResult(bool success, DropEffects actualEffect, Nullable`1<int> totalDropItems);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    [CompilerGeneratedAttribute]
public DropEffects get_ActualEffect();
    [CompilerGeneratedAttribute]
private void set_ActualEffect(DropEffects value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TotalDropItems();
    [CompilerGeneratedAttribute]
private void set_TotalDropItems(Nullable`1<int> value);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.PathComparer : StringComparer {
    private static int SeparatorHashCode;
    [CompilerGeneratedAttribute]
private static PathComparer <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private static PathComparer <OrdinalIgnoreCase>k__BackingField;
    public static PathComparer Ordinal { get; }
    public static PathComparer OrdinalIgnoreCase { get; }
    private static PathComparer();
    [CompilerGeneratedAttribute]
public static PathComparer get_Ordinal();
    [CompilerGeneratedAttribute]
public static PathComparer get_OrdinalIgnoreCase();
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    protected abstract virtual int CompareChar(char x, char y);
    protected abstract virtual int GetCharHashcodeCore(char c);
    protected int GetCharHashcode(char c);
    private static bool IsPathSeparator(char c);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.PathHelper : object {
    private static Char[] NonFastPathCharacters;
    private static Char[] PathAndVolumeSeperators;
    private static Char[] InvalidPathChars;
    private static string InvalidFileNameCharsString;
    private static string ExtendedPathPrefix;
    private static PathHelper();
    public static string Combine(string basePath, string path);
    public static string MakeRooted(string basePath, string path);
    public static string MakeRelative(string basePath, string path);
    public static void MakeRootedAndRelative(string path, string basePath, String& relativePath, String& rootedPath);
    [ExtensionAttribute]
public static void ClassifyProjectPath(UnconfiguredProject unconfiguredProject, string path, String& projectRelativePath, String& rootedPath);
    [ExtensionAttribute]
public static bool IsOutsideProjectDirectory(UnconfiguredProject unconfiguredProject, string path);
    public static bool IsOutsideProjectDirectory(string projectRootDirectory, string path);
    [ExtensionAttribute]
public static bool TryMakeRelativeToProjectDirectory(UnconfiguredProject unconfiguredProject, string path, String& relativePath);
    [ExtensionAttribute]
public static string MakeRelative(UnconfiguredProject unconfiguredProject, string path);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.PathHelper/<MakeRelative>d__14")]
[ExtensionAttribute]
public static IEnumerable`1<string> MakeRelative(UnconfiguredProject unconfiguredProject, IEnumerable`1<string> files);
    [ExtensionAttribute]
public static IImmutableSet`1<string> MakeRelative(UnconfiguredProject unconfiguredProject, IImmutableSet`1<string> files);
    [ExtensionAttribute]
public static string MakeRooted(UnconfiguredProject unconfiguredProject, string path);
    public static string EnsureTrailingSlash(string path);
    public static string CanonicalizeItemInFolder(string directoryName, string itemName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.PathHelper/<GetValueAsPathAsync>d__19")]
[ExtensionAttribute]
public static Task`1<string> GetValueAsPathAsync(IEvaluatedProperty property, bool shouldBeQuoted, bool required);
    public static bool IsFileNameValid(string fileName, bool useVsInvalidCharacters);
    public static bool IsSamePath(string file1, string file2, bool caseSensitive);
    internal static void EnsureDirectoryForFileExists(string pathToFile);
    internal static bool EndsWithTrailingSlash(string path);
    internal static string RemoveTrailingSlashes(string path);
    internal static string MakeRootedIfNoMacros(string baseDirectory, string relativeOrFullPath);
    internal static string MakeRelativeIfNoMacros(string baseDirectory, string relativeOrFullPath);
    internal static bool IsRooted(string path);
    internal static void VerifyThrowArgumentPathMustBeRooted(string path, string parameterName);
    internal static string GetExtensionWithoutPeriod(string path);
    internal static string ChangeFileName(string path, string newFileName);
    internal static string ChangeExtension(string path, string newExtension);
    internal static bool TryGetWildcardPattern(string wildcardPattern, FileMatchPattern& pattern);
    internal static bool ContainsMacros(string path);
    internal static Uri CreateUriFromPath(string path);
    internal static string CleanupLocalFilePath(string path);
    internal static bool IsFilePartInvalid(string filePart, bool useVsInvalidCharacters);
    internal static bool IsStringAllGivenCharacter(char c, string fileName);
    internal static bool PathNeedsNormalization(string path);
    internal static string NormalizePathSeparators(string path);
    internal static bool IsInvalidPath(string path);
    internal static bool IsNormalizedRelativePath(string path);
    internal static int IndexOfLastPathSeperator(string path);
    private static bool IsExtended(string path);
    private static bool IsValidDriveChar(char value);
    private static bool IsDirectorySeperator(char c);
    private static int IndexOfLastNonSlash(string path);
    private static void FindLastMismatchingCharIndex(string file1, string file2, bool caseSensitive, Int32& index1, Int32& index2, Boolean& passedAnyPathSeperator);
    private static bool ArePathCharactersMatchingEachOther(char char1, char char2, bool caseSensitive);
    internal static bool IsDirectorySeparator(char c);
}
internal class Microsoft.VisualStudio.ProjectSystem.PersistentDictionarySettings : PersistentSettings {
    private Dictionary`2<string, object> fakeRegistryHive;
    internal virtual void SetSetting(string subPath, string valueName, T value);
    internal virtual void DeleteSetting(string subPath, string valueName);
    internal virtual T GetSetting(string subPath, string valueName, T defaultValue);
}
internal class Microsoft.VisualStudio.ProjectSystem.PersistentRegistrySettings : PersistentSettings {
    private string registryRoot;
    internal PersistentRegistrySettings(IVsShellServices shell);
    internal PersistentRegistrySettings(string registryRoot);
    internal virtual void SetSetting(string subPath, string valueName, T value);
    internal virtual void DeleteSetting(string subPath, string valueName);
    internal virtual T GetSetting(string subPath, string valueName, T defaultValue);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.PersistentSettings : object {
    private static string VCSubPath;
    private static string CpsSubPath;
    private static string GeneralSubPath;
    internal LoggerVerbosity OutputWindowLogVerbosity { get; internal set; }
    internal LoggerVerbosity LogFileVerbosity { get; internal set; }
    internal bool IsDesignTimeOutputPaneEnabled { get; internal set; }
    internal bool LogFileEnabled { get; internal set; }
    internal bool LogTimingsEnabled { get; internal set; }
    internal bool LogEnvironmentVariablesEnabled { get; internal set; }
    internal string BuildCustomizationsSearchPath { get; internal set; }
    internal bool ShowAllFilesDefault { get; internal set; }
    internal bool AutoRefreshEnabled { get; internal set; }
    internal Nullable`1<int> MaximumConcurrentFileCompiles { get; internal set; }
    internal LoggerVerbosity get_OutputWindowLogVerbosity();
    internal void set_OutputWindowLogVerbosity(LoggerVerbosity value);
    internal LoggerVerbosity get_LogFileVerbosity();
    internal void set_LogFileVerbosity(LoggerVerbosity value);
    internal bool get_IsDesignTimeOutputPaneEnabled();
    internal void set_IsDesignTimeOutputPaneEnabled(bool value);
    internal bool get_LogFileEnabled();
    internal void set_LogFileEnabled(bool value);
    internal bool get_LogTimingsEnabled();
    internal void set_LogTimingsEnabled(bool value);
    internal bool get_LogEnvironmentVariablesEnabled();
    internal void set_LogEnvironmentVariablesEnabled(bool value);
    internal string get_BuildCustomizationsSearchPath();
    internal void set_BuildCustomizationsSearchPath(string value);
    internal bool get_ShowAllFilesDefault();
    internal void set_ShowAllFilesDefault(bool value);
    internal bool get_AutoRefreshEnabled();
    internal void set_AutoRefreshEnabled(bool value);
    internal Nullable`1<int> get_MaximumConcurrentFileCompiles();
    internal void set_MaximumConcurrentFileCompiles(Nullable`1<int> value);
    internal abstract virtual void SetSetting(string subPath, string valueName, T value);
    internal void SetSetting(string subPath, string valueName, bool value);
    internal abstract virtual void DeleteSetting(string subPath, string valueName);
    internal abstract virtual T GetSetting(string subPath, string valueName, T defaultValue);
    internal bool GetSetting(string subPath, string valueName, bool defaultValue);
}
public class Microsoft.VisualStudio.ProjectSystem.ProcessedOrderPrecedenceImportCollection`3 : OrderPrecedenceImportCollection`2<T, TMetadata> {
    private object syncObject;
    private Func`2<IReadOnlyList`1<Lazy`2<T, TMetadata>>, TProcessed> processor;
    private TProcessed processedValue;
    private ImmutableArray`1<Lazy`2<T, TMetadata>> filteredSnapshot;
    public TProcessed ProcessedValue { get; }
    public ProcessedOrderPrecedenceImportCollection`3(Func`2<IReadOnlyList`1<Lazy`2<T, TMetadata>>, TProcessed> processor, PreferenceOrder orderingStyle, IProjectCapabilitiesScope projectCapabilityCheckScope);
    public ProcessedOrderPrecedenceImportCollection`3(Func`2<IReadOnlyList`1<Lazy`2<T, TMetadata>>, TProcessed> processor, PreferenceOrder orderingStyle, UnconfiguredProject projectCapabilityCheckProvider);
    public ProcessedOrderPrecedenceImportCollection`3(Func`2<IReadOnlyList`1<Lazy`2<T, TMetadata>>, TProcessed> processor, PreferenceOrder orderingStyle, ConfiguredProject projectCapabilityCheckProvider);
    public TProcessed get_ProcessedValue();
}
internal class Microsoft.VisualStudio.ProjectSystem.ProductionBroadcastBlock`1 : object {
    private object syncObject;
    private Func`1<T> syncProduction;
    private Func`1<Task`1<T>> asyncProduction;
    private BroadcastBlock`1<T> broadcastBlock;
    private bool initialNotificationRaised;
    private T lastValue;
    private IEqualityComparer`1<T> equalityComparer;
    private long requestVersion;
    private bool inProcessing;
    private bool isCompleted;
    private IProjectThreadingService threadingService;
    private TaskScheduler scheduler;
    private IReceivableSourceBlock`1<T> PublicBlock { get; }
    public Task Completion { get; }
    internal ProductionBroadcastBlock`1(Func`1<T> production, IEqualityComparer`1<T> equalityComparer, bool initialRefresh, IProjectThreadingService threadingService, TaskScheduler scheduler, string name);
    internal ProductionBroadcastBlock`1(Func`1<Task`1<T>> productionAsync, IEqualityComparer`1<T> equalityComparer, bool initialRefresh, IProjectThreadingService threadingService, TaskScheduler scheduler, string name);
    private IReceivableSourceBlock`1<T> get_PublicBlock();
    public sealed virtual Task get_Completion();
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public sealed virtual T ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    public sealed virtual bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    public sealed virtual void Complete();
    public sealed virtual void Fault(Exception exception);
    public void Refresh();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProductionBroadcastBlock`1/<Process>d__27")]
private Task Process();
    private void PublishValue(T newValue);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ProjectAccess : Enum {
    public int value__;
    public static ProjectAccess None;
    public static ProjectAccess Read;
    public static ProjectAccess Write;
    public static ProjectAccess UpgradeableRead;
    public static ProjectAccess SkipInitialEvaluation;
    public static ProjectAccess SuppressReevaluation;
    public static ProjectAccess StickyWrite;
    public static ProjectAccess LockMask;
    public static ProjectAccess OptionMask;
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("64")]
[ProjectSystemContractAttribute("1", "2")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectAutoLoadAttribute : ExportAttribute {
    internal static string ContractName;
    [CompilerGeneratedAttribute]
private bool <RequiresUIThread>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectLoadCheckpoint <CompleteBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectLoadCheckpoint <StartAfter>k__BackingField;
    public bool RequiresUIThread { get; public set; }
    public ProjectLoadCheckpoint CompleteBy { get; private set; }
    public ProjectLoadCheckpoint StartAfter { get; private set; }
    public ProjectAutoLoadAttribute(ProjectLoadCheckpoint startAfter, ProjectLoadCheckpoint completeBy);
    [CompilerGeneratedAttribute]
public bool get_RequiresUIThread();
    [CompilerGeneratedAttribute]
public void set_RequiresUIThread(bool value);
    [CompilerGeneratedAttribute]
public ProjectLoadCheckpoint get_CompleteBy();
    [CompilerGeneratedAttribute]
private void set_CompleteBy(ProjectLoadCheckpoint value);
    [CompilerGeneratedAttribute]
public ProjectLoadCheckpoint get_StartAfter();
    [CompilerGeneratedAttribute]
private void set_StartAfter(ProjectLoadCheckpoint value);
}
[AttributeUsageAttribute("388")]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.ProjectBuildTargetToCapabilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TargetFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Capability>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string TargetFile { get; }
    public string Capability { get; }
    public string Extension { get; }
    public ProjectBuildTargetToCapabilityAttribute(string targetFile, string capability, string fileExtension);
    [CompilerGeneratedAttribute]
public string get_TargetFile();
    [CompilerGeneratedAttribute]
public string get_Capability();
    [CompilerGeneratedAttribute]
public string get_Extension();
}
public static class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilities : object {
    public static string VisualC;
    public static string CSharp;
    public static string VB;
    public static string AlwaysApplicable;
    public static string Cps;
    internal static string UseFileGlobs;
    public static string DynamicDependentFile;
    public static string HostSetActiveProjectConfiguration;
    public static string ProjectConfigurationsInferredFromUsage;
    public static string ProjectConfigurationsDeclaredAsItems;
    public static string ProjectConfigurationsDeclaredDimensions;
    public static string RunningInVisualStudio;
    public static string NotLoadedWithIDEIntegration;
    public static string RenameNearbySimilarlyNamedImportsWithProject;
    public static string ShowMissingItemTypes;
    public static string PreserveFormatting;
    public static string DisableFileBasedDesignTimeBuildOptimization;
    public static string SortByDisplayOrder;
    public static string AvoidAddingProjectGuid;
    public static string IntegratedConsoleDebugging;
    public static string Managed;
    public static string ReferencesFolder;
    public static string SharedAssetsProject;
    public static string NestedProjects;
    public static string SourceItemsFromImports;
    public static string SharedImports;
    public static string LanguageService;
    public static string SingleFileGenerators;
    public static string ParentVCProject;
    public static string RelativePathDerivedDefaultNamespace;
    public static string WindowsXaml;
    public static string WindowsXamlPage;
    public static string WindowsXamlCodeBehind;
    public static string WindowsXamlResourceDictionary;
    public static string WindowsXamlUserControl;
    public static string DiagnoseCapabilities;
    public static string HandlesOwnReload;
    public static string OpenProjectFile;
    public static string NoGeneralDependentFileIcon;
    public static string WinRTReferences;
    public static string AssemblyReferences;
    public static string ComReferences;
    public static string ProjectReferences;
    public static string SharedProjectReferences;
    public static string SdkReferences;
    public static string PackageReferences;
    public static string OutputGroups;
    public static string AllTargetOutputGroups;
    public static string VisualStudioWellKnownOutputGroups;
    public static string BuildWindowsDesktopTarget;
    internal static string FallbackProjectConfigurationService;
    internal static string RequiresSharedAssetsProjectLoadForOpenDocuments;
    internal static Char[] DisallowedCharacters;
    private static ProjectCapabilities();
    public static bool IsValidProjectCapabilityName(string projectCapability);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesContext : object {
    private static AsyncLocal`1<ImmutableStack`1<ProjectCapabilitiesContext>> Context;
    private WeakReference`1<UnconfiguredProject> projectContext;
    private DependencyManagementType dependencyManagementType;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> <Capabilities>k__BackingField;
    public static ProjectCapabilitiesContext CurrentContext { get; }
    private static ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> CurrentCapabilitiesByScopes { get; }
    private ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> Capabilities { get; }
    public IImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> CapabilitiesByScopes { get; }
    public CapabilitiesDependencies Dependencies { get; }
    private IProjectCapabilitiesRequirementsService DependencyRegister { get; }
    private ProjectCapabilitiesContext(UnconfiguredProject project, IEnumerable`1<IProjectScopeCapabilitiesSnapshot> snapshots, DependencyManagementType dependencyManagementType, bool forceToUpdate, bool needIsolation, ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> inheritedSnapshots, IEnumerable`1<KeyValuePair`2<NamedIdentity, NamedIdentity>> inferredScopes);
    private static ProjectCapabilitiesContext();
    public static ProjectCapabilitiesContext get_CurrentContext();
    private static ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> get_CurrentCapabilitiesByScopes();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> get_Capabilities();
    public IImmutableDictionary`2<NamedIdentity, IProjectCapabilitiesSnapshot> get_CapabilitiesByScopes();
    public CapabilitiesDependencies get_Dependencies();
    private IProjectCapabilitiesRequirementsService get_DependencyRegister();
    private static void Push(ProjectCapabilitiesContext context);
    private static void Pop(ProjectCapabilitiesContext context);
    public sealed virtual void Dispose();
    public static RevertRelevance SuppressRelevance();
    public static ProjectCapabilitiesContext CreateContext(UnconfiguredProject project, DependencyManagementType dependencyManagement);
    public static ProjectCapabilitiesContext CreateContext(ConfiguredProject project, DependencyManagementType dependencyManagement);
    public static ProjectCapabilitiesContext CreateIsolatedContext(UnconfiguredProject project, bool forceToUpdate, DependencyManagementType dependencyManagement);
    public static ProjectCapabilitiesContext CreateIsolatedContext(ConfiguredProject project, bool forceToUpdate, DependencyManagementType dependencyManagement);
    public static ProjectCapabilitiesContext CreateIsolatedContext(UnconfiguredProject project, IProjectCapabilitiesSnapshot capabilities, DependencyManagementType dependencyManagement);
    internal static ProjectCapabilitiesContext CreateIsolatedSubScopeContext(UnconfiguredProject project, IProjectCapabilitiesSnapshot capabilities, DependencyManagementType dependencyManagement);
    private static ProjectCapabilitiesContext CreateIsolatedContext(UnconfiguredProject project, IProjectCapabilitiesSnapshot capabilities, DependencyManagementType dependencyManagement, bool acceptSubScope);
    public static ProjectCapabilitiesContext CreateIsolatedContext(ConfiguredProject project, IProjectCapabilitiesSnapshot capabilities, DependencyManagementType dependencyManagement);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesContext/<GetSelfAndInheritedSnapshots>d__30")]
private static IEnumerable`1<IProjectScopeCapabilitiesSnapshot> GetSelfAndInheritedSnapshots(IProjectScopeCapabilitiesSnapshot snapshot);
    private IProjectCapabilitiesSnapshot WrapProjectCapabilitiesCheckerIfNecessary(IProjectCapabilitiesSnapshot innerChecker, bool needIsolation);
    [EditorBrowsableAttribute("2")]
public static bool IsInsideCapabilitiesContext();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportEvaluationProvider : ConfiguredProjectCapabilitiesProviderBase {
    private ImmutableHashSet`1<string> capabilities;
    [CompilerGeneratedAttribute]
private string <TriggerTarget>k__BackingField;
    protected string TriggerTarget { get; private set; }
    protected ProjectCapabilitiesFromImportEvaluationProvider(string name, ConfiguredProject configuredProject, string triggerTargets, String[] capabilities);
    [CompilerGeneratedAttribute]
protected string get_TriggerTarget();
    [CompilerGeneratedAttribute]
private void set_TriggerTarget(string value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportEvaluationProvider/<GetCapabilitiesAsync>d__6")]
protected virtual Task`1<ImmutableHashSet`1<string>> GetCapabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportEvaluationProvider/<GetIsApplicableAsync>d__7")]
protected virtual Task`1<bool> GetIsApplicableAsync();
    [CompilerGeneratedAttribute]
private bool <GetIsApplicableAsync>b__7_0(ResolvedImport i);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportXmlProvider : UnconfiguredProjectCapabilitiesProviderBase {
    private ImmutableHashSet`1<string> capabilities;
    [CompilerGeneratedAttribute]
private string <TriggerTarget>k__BackingField;
    protected string TriggerTarget { get; private set; }
    protected ProjectCapabilitiesFromImportXmlProvider(string name, UnconfiguredProject unconfiguredProject, string triggerTargets, String[] capabilities);
    [CompilerGeneratedAttribute]
protected string get_TriggerTarget();
    [CompilerGeneratedAttribute]
private void set_TriggerTarget(string value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportXmlProvider/<GetCapabilitiesAsync>d__6")]
protected virtual Task`1<ImmutableHashSet`1<string>> GetCapabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesFromImportXmlProvider/<GetIsApplicableAsync>d__7")]
protected virtual Task`1<bool> GetIsApplicableAsync();
    [CompilerGeneratedAttribute]
private bool <GetIsApplicableAsync>b__7_0(ProjectImportElement i);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesProviderBase : OnceInitializedOnceDisposedAsync {
    private long version;
    private IProjectDataSourceRegistry dataSourceRegistry;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> publicBlock;
    private ProductionBroadcastBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> productionBlock;
    private IDisposable dataSourceRegistryCancellation;
    private ProjectCapabilitiesSnapshot capabilities;
    [CompilerGeneratedAttribute]
private NamedIdentity <DataSourceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectLockService <ProjectLockService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectThreadingService <ThreadingService>k__BackingField;
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> SourceBlock { get; }
    private ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.SourceBlock { get; }
    public IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> Current { get; }
    [ImportAttribute]
protected IProjectLockService ProjectLockService { get; private set; }
    [ImportAttribute]
private IProjectThreadingService ThreadingService { get; private set; }
    protected ProjectCapabilitiesProviderBase(string name, JoinableTaskContextNode joinableTaskContextNode, IProjectDataSourceRegistry dataSourceRegistry, bool configuredProjectLevel);
    [CompilerGeneratedAttribute]
public sealed virtual NamedIdentity get_DataSourceKey();
    public sealed virtual IComparable get_DataSourceVersion();
    public sealed virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> get_SourceBlock();
    private sealed virtual override ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.get_SourceBlock();
    public sealed virtual IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> get_Current();
    [CompilerGeneratedAttribute]
protected IProjectLockService get_ProjectLockService();
    [CompilerGeneratedAttribute]
private void set_ProjectLockService(IProjectLockService value);
    [CompilerGeneratedAttribute]
private IProjectThreadingService get_ThreadingService();
    [CompilerGeneratedAttribute]
private void set_ThreadingService(IProjectThreadingService value);
    private sealed virtual override IDisposable Microsoft.VisualStudio.ProjectSystem.IJoinableProjectValueDataSource.Join();
    protected abstract virtual Task`1<ImmutableHashSet`1<string>> GetCapabilitiesAsync(CancellationToken cancellationToken);
    protected virtual Task InitializeCoreAsync(CancellationToken cancellationToken);
    protected virtual Task DisposeCoreAsync(bool initialized);
    protected void Refresh();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesProviderBase/<<-ctor>b__6_0>d")]
[CompilerGeneratedAttribute]
private Task`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> <.ctor>b__6_0();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesProviderBase/<<-ctor>b__6_1>d")]
[CompilerGeneratedAttribute]
private Task`1<ProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> <.ctor>b__6_1();
    [CompilerGeneratedAttribute]
private Task`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> <get_Current>b__17_0();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesRequirements : object {
    private IImmutableDictionary`2<string, bool> capabilitiesRequirements;
    private static IImmutableDictionary`2<string, bool> EmptyCapabilitiesRequirements;
    [CompilerGeneratedAttribute]
private static ProjectCapabilitiesRequirements <Empty>k__BackingField;
    public IImmutableDictionary`2<string, bool> CapabilitiesRequirements { get; }
    public static ProjectCapabilitiesRequirements Empty { get; }
    public bool IsEmpty { get; }
    public ProjectCapabilitiesRequirements(IImmutableDictionary`2<string, bool> requirements);
    private static ProjectCapabilitiesRequirements();
    public sealed virtual IImmutableDictionary`2<string, bool> get_CapabilitiesRequirements();
    [CompilerGeneratedAttribute]
public static ProjectCapabilitiesRequirements get_Empty();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IProjectCapabilitiesRequirements Add(IProjectCapabilitiesRequirements projectCapabilitiesRequirements);
    public sealed virtual IProjectCapabilitiesRequirements Add(string capability, bool expectedPresence);
    public sealed virtual bool ConflictsWith(IProjectCapabilitiesRequirements other);
    public sealed virtual bool IsSatisfiedBy(IProjectCapabilitiesSnapshot capabilitiesSnapshot);
    public sealed virtual IProjectCapabilitiesRequirements Remove(String[] capabilities);
    public sealed virtual IProjectCapabilitiesRequirements Remove(IProjectCapabilitiesRequirements capabilitiesRequirements);
}
internal class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesScopeBase : ProjectValueDataSourceBase`1<IProjectCapabilitiesSnapshot> {
    private bool configuredProjectLevel;
    private bool simpleAggregationScope;
    private BroadcastBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> localCapabilitiesBroadcastBlock;
    private BufferBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> inheritedProvidersBufferBlock;
    private long localCapabilitiesVersion;
    private long nextCapabilitiesVersion;
    private TransformBlock`2<Tuple`2<ImmutableList`1<IProjectValueVersions>, IImmutableDictionary`2<NamedIdentity, IComparable>>, IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> aggregatingTransformBlock;
    private IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> publicBlock;
    private IDisposable inheritedCapabilitiesSubscriptions;
    private ProjectCapabilitiesSnapshot lastProducedLocalCapabilities;
    private IImmutableSet`1<string> initialCapabilities;
    private ImmutableArray`1<IProjectCapabilitiesProvider> initialInheritedProviders;
    private Nullable`1<KeyValuePair`2<NamedIdentity, IComparable>> inheritedProvidersDataSourceVersion;
    private IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> current;
    private bool initialized;
    [CompilerGeneratedAttribute]
private NamedIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedIdentity <DataSourceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IProjectCapabilitiesProvider> <InheritedProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <Project>k__BackingField;
    public NamedIdentity Identity { get; }
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> SourceBlock { get; }
    public IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> Current { get; }
    protected string Name { get; }
    private ImmutableArray`1<IProjectCapabilitiesProvider> InheritedProviders { get; private set; }
    internal UnconfiguredProject Project { get; internal set; }
    public ProjectCapabilitiesScopeBase(string name, IProjectCommonServices commonServices, IImmutableSet`1<string> initialCapabilities, IProjectCapabilitiesProvider[] inheritedProviders);
    protected ProjectCapabilitiesScopeBase(string name, IProjectFaultHandlerService faultHandlerService, IProjectThreadingService projectThreadingService, IProjectDataSourceRegistry dataSourceRegistry, bool configuredProjectLevel, bool simpleAggregation, IImmutableSet`1<string> initialCapabilities, UnconfiguredProject project, IProjectCapabilitiesProvider[] inheritedProviders);
    [CompilerGeneratedAttribute]
public sealed virtual NamedIdentity get_Identity();
    [CompilerGeneratedAttribute]
public virtual NamedIdentity get_DataSourceKey();
    public virtual IComparable get_DataSourceVersion();
    public virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> get_SourceBlock();
    public sealed virtual IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> get_Current();
    protected string get_Name();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IProjectCapabilitiesProvider> get_InheritedProviders();
    [CompilerGeneratedAttribute]
private void set_InheritedProviders(ImmutableArray`1<IProjectCapabilitiesProvider> value);
    [CompilerGeneratedAttribute]
internal UnconfiguredProject get_Project();
    [CompilerGeneratedAttribute]
internal void set_Project(UnconfiguredProject value);
    public void UpdateCapabilities(IImmutableSet`1<string> capabilities);
    public void UpdateInheritedProviders(ImmutableArray`1<IProjectCapabilitiesProvider> inheritedProviders, Nullable`1<KeyValuePair`2<NamedIdentity, IComparable>> inheritedProvidersDataSourceVersion);
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    private void PublishLocalCapabilities(IProjectVersionedValue`1<IProjectCapabilitiesSnapshot> value);
    private void UpdateInheritedProvidersVersion(Nullable`1<KeyValuePair`2<NamedIdentity, IComparable>> inheritedProvidersVersion);
    private void UpdateCapabilities(IImmutableSet`1<string> capabilities, bool insideInitialization);
    private void UpdateInheritedProviders(ImmutableArray`1<IProjectCapabilitiesProvider> inheritedProviders, Nullable`1<KeyValuePair`2<NamedIdentity, IComparable>> inheritedProvidersDataSourceVersion, bool insideInitialization);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesScopeBase/<ProcessNewCapabilitiesAsync>d__47")]
private Task`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> ProcessNewCapabilitiesAsync(Tuple`2<ImmutableList`1<IProjectValueVersions>, IImmutableDictionary`2<NamedIdentity, IComparable>> data);
    protected virtual Task`1<bool> PrepareNewCapabilitiesSnapshotAsync(ProjectVersionedValue`1<ProjectScopeCapabilitiesSnapshot> futureVersionedCapabilitiesSnapshot);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesScopeBase/<<Initialize>b__41_0>d")]
[CompilerGeneratedAttribute]
private Task`1<IProjectVersionedValue`1<IProjectCapabilitiesSnapshot>> <Initialize>b__41_0(Tuple`2<ImmutableList`1<IProjectValueVersions>, IImmutableDictionary`2<NamedIdentity, IComparable>> v);
}
[DebuggerDisplayAttribute("Capabilities: {CapabilitiesString}")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectCapabilitiesSnapshot : object {
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <Capabilities>k__BackingField;
    public IImmutableSet`1<string> Capabilities { get; }
    private string CapabilitiesString { get; }
    public ProjectCapabilitiesSnapshot(IImmutableSet`1<string> initialCapabilities);
    [CompilerGeneratedAttribute]
public IImmutableSet`1<string> get_Capabilities();
    private string get_CapabilitiesString();
    public sealed virtual bool IsProjectCapabilityPresent(string projectCapability);
    public ProjectCapabilitiesSnapshot Update(IImmutableSet`1<string> capabilities);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("Changes to rule {After.RuleName}")]
internal class Microsoft.VisualStudio.ProjectSystem.ProjectChangeDescription : object {
    [CompilerGeneratedAttribute]
private IProjectRuleSnapshot <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectChangeDiff <Difference>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectRuleSnapshot <After>k__BackingField;
    public IProjectRuleSnapshot Before { get; private set; }
    public IProjectChangeDiff Difference { get; private set; }
    public IProjectRuleSnapshot After { get; private set; }
    internal ProjectChangeDescription(IProjectRuleSnapshot before, IProjectChangeDiff diff, IProjectRuleSnapshot after);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectRuleSnapshot get_Before();
    [CompilerGeneratedAttribute]
private void set_Before(IProjectRuleSnapshot value);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectChangeDiff get_Difference();
    [CompilerGeneratedAttribute]
private void set_Difference(IProjectChangeDiff value);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectRuleSnapshot get_After();
    [CompilerGeneratedAttribute]
private void set_After(IProjectRuleSnapshot value);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectChangeFileSystemEntityHint : ProjectChangeHintBase {
    public static string AddedFileAsString;
    public static string EditedFileAsString;
    public static string RemovedFileFromProjectOnlyAsString;
    public static string RemovedFileFromProjectAndStorageAsString;
    public static string AddedFolderAsString;
    public static string RemovedFolderFromProjectOnlyAsString;
    public static string RemovedFolderFromProjectAndStorageAsString;
    public static Guid AddedFile;
    public static Guid EditedFile;
    public static Guid RemovedFileFromProjectOnly;
    public static Guid RemovedFileFromProjectAndStorage;
    public static Guid AddedFolder;
    public static Guid RemovedFolderFromProjectOnly;
    public static Guid RemovedFolderFromProjectAndStorage;
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <Files>k__BackingField;
    public IImmutableSet`1<string> Files { get; private set; }
    public ProjectChangeFileSystemEntityHint(UnconfiguredProject project, Guid changeKind, IEnumerable`1<string> files);
    public ProjectChangeFileSystemEntityHint(UnconfiguredProject project, Guid changeKind, bool changeAlreadyOccurred, IEnumerable`1<string> files);
    private static ProjectChangeFileSystemEntityHint();
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableSet`1<string> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(IImmutableSet`1<string> value);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectChangeFileSystemEntityRenameHint : ProjectChangeHintBase {
    public static string RenamedFolderAsString;
    public static string RenamedFileAsString;
    public static Guid RenamedFolder;
    public static Guid RenamedFile;
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, string> <RenamedFiles>k__BackingField;
    public IImmutableDictionary`2<string, string> RenamedFiles { get; private set; }
    public ProjectChangeFileSystemEntityRenameHint(UnconfiguredProject project, Guid changeKind, IEnumerable`1<KeyValuePair`2<string, string>> beforeAndAfterFiles);
    public ProjectChangeFileSystemEntityRenameHint(UnconfiguredProject project, Guid changeKind, bool changeAlreadyOccurred, IEnumerable`1<KeyValuePair`2<string, string>> beforeAndAfterFiles);
    private static ProjectChangeFileSystemEntityRenameHint();
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableDictionary`2<string, string> get_RenamedFiles();
    [CompilerGeneratedAttribute]
private void set_RenamedFiles(IImmutableDictionary`2<string, string> value);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectChangeHintBase : object {
    [CompilerGeneratedAttribute]
private Guid <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChangeAlreadyOccurred>k__BackingField;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    public Guid Kind { get; private set; }
    public bool ChangeAlreadyOccurred { get; private set; }
    public UnconfiguredProject UnconfiguredProject { get; private set; }
    protected ProjectChangeHintBase(Guid kind, UnconfiguredProject project);
    protected ProjectChangeHintBase(Guid kind, bool changeAlreadyOccurred, UnconfiguredProject project);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ChangeAlreadyOccurred();
    [CompilerGeneratedAttribute]
private void set_ChangeAlreadyOccurred(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual UnconfiguredProject get_UnconfiguredProject();
    [CompilerGeneratedAttribute]
private void set_UnconfiguredProject(UnconfiguredProject value);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectChangeHintKindAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ProjectChangeHintKind>k__BackingField;
    public string ProjectChangeHintKind { get; private set; }
    public ProjectChangeHintKindAttribute(string hintKindGuid);
    [CompilerGeneratedAttribute]
public string get_ProjectChangeHintKind();
    [CompilerGeneratedAttribute]
private void set_ProjectChangeHintKind(string value);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectChangeNotificationEventArgs : EventArgs {
    public IImmutableDictionary`2<string, IProjectChangeDescription> ProjectChanges { get; }
    public abstract virtual IImmutableDictionary`2<string, IProjectChangeDescription> get_ProjectChanges();
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectCompatibilityCheckLevel : Enum {
    public int value__;
    public static ProjectCompatibilityCheckLevel None;
    public static ProjectCompatibilityCheckLevel UnconfiguredProject;
    public static ProjectCompatibilityCheckLevel ConfiguredProject;
}
public interface Microsoft.VisualStudio.ProjectSystem.ProjectConfiguration {
    public string Name { get; }
    public IImmutableDictionary`2<string, string> Dimensions { get; }
    public abstract virtual string get_Name();
    public abstract virtual IImmutableDictionary`2<string, string> get_Dimensions();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectConfigurationChangeEventArgs : EventArgs {
    public ProjectConfiguration OldProjectConfiguration { get; }
    public ProjectConfiguration NewProjectConfiguration { get; }
    public abstract virtual ProjectConfiguration get_OldProjectConfiguration();
    public abstract virtual ProjectConfiguration get_NewProjectConfiguration();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectConfigurationDimensionValueChangedEventArgs : object {
    [CompilerGeneratedAttribute]
private UnconfiguredProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DimensionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DimensionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldDimensionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationDimensionChange <Change>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeEventStage <Stage>k__BackingField;
    public UnconfiguredProject Project { get; }
    public string DimensionName { get; }
    public string DimensionValue { get; }
    public string OldDimensionValue { get; }
    public ConfigurationDimensionChange Change { get; }
    public ChangeEventStage Stage { get; internal set; }
    public ProjectConfigurationDimensionValueChangedEventArgs(UnconfiguredProject project, ConfigurationDimensionChange change, ChangeEventStage stage, string dimensionName, string dimensionValue, string oldDimensionValue);
    [CompilerGeneratedAttribute]
public UnconfiguredProject get_Project();
    [CompilerGeneratedAttribute]
public string get_DimensionName();
    [CompilerGeneratedAttribute]
public string get_DimensionValue();
    [CompilerGeneratedAttribute]
public string get_OldDimensionValue();
    [CompilerGeneratedAttribute]
public ConfigurationDimensionChange get_Change();
    [CompilerGeneratedAttribute]
public ChangeEventStage get_Stage();
    [CompilerGeneratedAttribute]
internal void set_Stage(ChangeEventStage value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.ProjectConfigurationsServiceUtilities : object {
    [ExtensionAttribute]
internal static Task`1<ProjectConfiguration> GetSuggestedProjectConfigurationAsync(IProjectConfigurationsService configurationsService);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ProjectCriticalOperation : Enum {
    public int value__;
    public static ProjectCriticalOperation None;
    public static ProjectCriticalOperation Build;
    public static ProjectCriticalOperation Save;
    public static ProjectCriticalOperation Rename;
    public static ProjectCriticalOperation Unload;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.ProjectDataSources : object {
    private static int DefaultThresholdToReportLongDataflowWaiting;
    private static string ThresholdToReportLongDataflowWaiting;
    private static string DataflowWaitingTelemetry;
    private static string DataflowWaitingTelemetryBlockName;
    private static string DataflowWaitingTelemetryTotalTime;
    public static NamedIdentity ActiveProjectConfiguration;
    public static NamedIdentity ConfiguredProjectVersion;
    public static NamedIdentity ConfiguredProjectIdentity;
    public static NamedIdentity AdditionalRuleDefinitionsVersion;
    public static NamedIdentity SharedImportSnapshotsVersion;
    public static NamedIdentity InconsistentDataVersion;
    public static NamedIdentity GlobalProjectCollectionGlobalProperties;
    public static NamedIdentity SolutionGlobalProperties;
    public static ImmutableDictionary`2<NamedIdentity, IComparable> EmptyVersions;
    private static int thresholdToReportLongDataflowWaiting;
    internal static IEqualityComparer`1<IImmutableDictionary`2<NamedIdentity, IComparable>> VersionEqualityComparer { get; }
    private static ProjectDataSources();
    internal static IEqualityComparer`1<IImmutableDictionary`2<NamedIdentity, IComparable>> get_VersionEqualityComparer();
    [ExtensionAttribute]
public static bool IsSatisfiedBy(IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> versionRequirements, IProjectValueVersions value);
    [ExtensionAttribute]
public static IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> ToRequirements(IProjectValueVersions value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> CreateVersionRequirement(ConfiguredProject configuredProject, bool allowMissingData);
    [ExtensionAttribute]
public static ImmutableDictionary`2<NamedIdentity, IComparable> GetDataSourceVersion(ConfiguredProject configuredProject);
    [ExtensionAttribute]
public static Task`1<T> GetSpecificVersionAsync(ISourceBlock`1<T> valueSource, NamedIdentity dataSourceKey, IComparable dataSourceVersion, bool allowMissingData, Func`3<ISourceBlock`1<T>, ITargetBlock`1<T>, IDisposable> linkCreator, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> GetSpecificVersionAsync(ISourceBlock`1<T> valueSource, IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> versionRequirements, Func`3<ISourceBlock`1<T>, ITargetBlock`1<T>, IDisposable> linkCreator, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static Task`1<T> GetSpecificVersionAsync(ISourceBlock`1<T> valueSource, IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> versionRequirements, Func`3<ISourceBlock`1<T>, ITargetBlock`1<T>, IDisposable> linkCreator, IProjectCommonServices services, CancellationToken cancellationToken);
    private static void ReportLongWaitingIfNecessary(object valueSource, IProjectCommonServices services, int elapsedMilliseconds);
    [ExtensionAttribute]
public static Task`1<IProjectVersionedValue`1<T>> GetLatestVersionAsync(ISourceBlock`1<IProjectVersionedValue`1<T>> valueSource, ConfiguredProject configuredProject, Func`3<ISourceBlock`1<IProjectVersionedValue`1<T>>, ITargetBlock`1<IProjectVersionedValue`1<T>>, IDisposable> linkCreator, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IProjectVersionedValue`1<T>> GetLatestVersionAsync(IProjectValueDataSource`1<T> valueSource, ConfiguredProject configuredProject, Func`3<ISourceBlock`1<IProjectVersionedValue`1<T>>, ITargetBlock`1<IProjectVersionedValue`1<T>>, IDisposable> linkCreator, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IProjectVersionedValue`1<T>> GetLatestVersionAsync(IProjectValueDataSource`1<T> valueSource, IProjectDataSourceRegistry dataSourceRegistry, Func`3<ISourceBlock`1<IProjectVersionedValue`1<T>>, ITargetBlock`1<IProjectVersionedValue`1<T>>, IDisposable> linkCreator, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectDataSources/<GetLatestVersionAsync>d__28`1")]
[ExtensionAttribute]
private static Task`1<IProjectVersionedValue`1<T>> GetLatestVersionAsync(IProjectValueDataSource`1<T> valueSource, IProjectDataSourceRegistry dataSourceRegistry, Func`3<ISourceBlock`1<IProjectVersionedValue`1<T>>, ITargetBlock`1<IProjectVersionedValue`1<T>>, IDisposable> linkCreator, IProjectCommonServices services, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectDataSources/<GetLatestVersionAsync>d__29")]
[ExtensionAttribute]
public static Task`1<IImmutableDictionary`2<string, IProjectRuleSnapshot>> GetLatestVersionAsync(IProjectValueDataSource`1<IProjectSubscriptionUpdate> valueSource, ConfiguredProject configuredProject, IEnumerable`1<string> ruleNames, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(ImmutableList`1<SourceBlockAndLink`1<IProjectValueVersions>> sourceBlocks, ITargetBlock`1<Tuple`2<ImmutableList`1<IProjectValueVersions>, IImmutableDictionary`2<NamedIdentity, IComparable>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(SourceBlockAndLink`1<IProjectVersionedValue`1<T1>> source1, SourceBlockAndLink`1<IProjectVersionedValue`1<T2>> source2, SourceBlockAndLink`1<IProjectVersionedValue`1<T3>> source3, SourceBlockAndLink`1<IProjectVersionedValue`1<T4>> source4, SourceBlockAndLink`1<IProjectVersionedValue`1<T5>> source5, SourceBlockAndLink`1<IProjectVersionedValue`1<T6>> source6, ITargetBlock`1<IProjectVersionedValue`1<Tuple`6<T1, T2, T3, T4, T5, T6>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(SourceBlockAndLink`1<IProjectVersionedValue`1<T1>> source1, SourceBlockAndLink`1<IProjectVersionedValue`1<T2>> source2, SourceBlockAndLink`1<IProjectVersionedValue`1<T3>> source3, SourceBlockAndLink`1<IProjectVersionedValue`1<T4>> source4, SourceBlockAndLink`1<IProjectVersionedValue`1<T5>> source5, ITargetBlock`1<IProjectVersionedValue`1<Tuple`5<T1, T2, T3, T4, T5>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(SourceBlockAndLink`1<IProjectVersionedValue`1<T1>> source1, SourceBlockAndLink`1<IProjectVersionedValue`1<T2>> source2, SourceBlockAndLink`1<IProjectVersionedValue`1<T3>> source3, SourceBlockAndLink`1<IProjectVersionedValue`1<T4>> source4, ITargetBlock`1<IProjectVersionedValue`1<Tuple`4<T1, T2, T3, T4>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(SourceBlockAndLink`1<IProjectVersionedValue`1<T1>> source1, SourceBlockAndLink`1<IProjectVersionedValue`1<T2>> source2, SourceBlockAndLink`1<IProjectVersionedValue`1<T3>> source3, ITargetBlock`1<IProjectVersionedValue`1<Tuple`3<T1, T2, T3>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    public static IDisposable SyncLinkTo(SourceBlockAndLink`1<IProjectVersionedValue`1<T1>> source1, SourceBlockAndLink`1<IProjectVersionedValue`1<T2>> source2, ITargetBlock`1<IProjectVersionedValue`1<Tuple`2<T1, T2>>> target, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SourceBlockAndLink`1<T> SyncLinkOptions(ISourceBlock`1<T> sourceBlock, DataflowLinkOptions linkOptions, bool initialDataAsNewForProjectSubscriptionUpdate);
    public static IDisposable JoinUpstreamDataSources(JoinableTaskFactory factory, IProjectFaultHandlerService faultHandlerService, IJoinableProjectValueDataSource[] sources);
    public static IDisposable JoinUpstreamDataSources(JoinableTaskFactory factory, IProjectFaultHandlerService faultHandlerService, IEnumerable`1<IJoinableProjectValueDataSource> sources);
    public static IImmutableDictionary`2<NamedIdentity, IComparable> MergeDataSourceVersions(IEnumerable`1<IImmutableDictionary`2<NamedIdentity, IComparable>> sourceVersions);
    internal static ImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> GetLatestVersionRequirements(IProjectDataSourceRegistry dataSourceRegistry, IProjectValueVersions dataSample);
    internal static bool IsNewerThan(IImmutableDictionary`2<NamedIdentity, IComparable> this, IImmutableDictionary`2<NamedIdentity, IComparable> that);
    [ExtensionAttribute]
internal static Task`1<T> GetSpecificVersionAsync(ISourceBlock`1<T> valueSource, Func`2<T, bool> matchTest, IProjectCommonServices services, CancellationToken cancellationToken);
    internal static void PostProcessProjectSubscriptionUpdate(IProjectValueVersions[] values, ImmutableList`1<SourceBlockAndLink`1<IProjectValueVersions>> sourceBlocks, IReadOnlyList`1<IProjectValueVersions> lastSubmittedValues);
    internal static void CheckValidVersionProgression(Func`1<string> getDataSourceName, IImmutableDictionary`2<NamedIdentity, IComparable> oldDataSourceVersions, IImmutableDictionary`2<NamedIdentity, IComparable> dataSourceVersions, bool unconfiguredProjectLevel);
    internal static bool AreAllDataSourcesAtLeastAsNew(IImmutableDictionary`2<NamedIdentity, IComparable> oldDataSourceVersions, IImmutableDictionary`2<NamedIdentity, IComparable> dataSourceVersions);
    internal static IPropagatorBlock`2<IProjectVersionedValue`1<T>, IProjectVersionedValue`1<T>> CreateDataSourceVersionForwardOnlyFilteringBlock();
    [ExtensionAttribute]
internal static void AddVersionVerifierBlock(ISourceBlock`1<IProjectVersionedValue`1<T>> sourceBlock, bool unconfiguredProjectLevel);
    [ExtensionAttribute]
internal static ISourceBlock`1<IProjectVersionedValue`1<T>> AddVersionVerifierPropagatorBlock(ISourceBlock`1<IProjectVersionedValue`1<T>> sourceBlock, bool configuredProjectLevel);
    internal static IPropagatorBlock`2<IProjectVersionedValue`1<T>, IProjectVersionedValue`1<T>> CreateVersionVerifierPropagatorBlock(string name, bool unconfiguredProjectLevel);
    [ExtensionAttribute]
internal static IReceivableSourceBlock`1<T> AsBroadcastBlock(ISourceBlock`1<T> sourceBlock, string name, Func`2<T, T> cloningFunction);
    private static IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> ToRequirements(IImmutableDictionary`2<NamedIdentity, IComparable> dataSourceVersions);
    private static bool IsSatisfiedBy(IImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> versionRequirements, IImmutableDictionary`2<NamedIdentity, IComparable> dataSourceVersions);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectDataSources/<GetLatestVersionAsync>d__53`1")]
private static Task`1<IProjectVersionedValue`1<T>> GetLatestVersionAsync(ISourceBlock`1<IProjectVersionedValue`1<T>> sourceBlock, ImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> versionMap, IProjectDataSourceRegistry dataSourceRegistry, Func`3<ISourceBlock`1<IProjectVersionedValue`1<T>>, ITargetBlock`1<IProjectVersionedValue`1<T>>, IDisposable> linkCreator, IProjectCommonServices services, CancellationToken cancellationToken);
}
internal static class Microsoft.VisualStudio.ProjectSystem.ProjectElementOrder : object {
    private static string VCManifestOrderTemplate;
    private static string VCPropertySheetOrderTemplate;
    private static ImmutableDictionary`2<TemplateType, ImmutableList`1<ProjectElement>> projectOrderTemplateElementsCache;
    private static ProjectElementOrder();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectElementOrder/<GetTemplateAddLocationOfTopLevelElementAsync>d__4")]
internal static Task`1<GetTemplateAddLocationOfTopLevelElementResult> GetTemplateAddLocationOfTopLevelElementAsync(ProjectElement unconnectedElement, ProjectRootElement projectXml, ProjectCollection projectCollection, TemplateType templateType, IProjectLockService projectLockService);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectElementOrder/<GetProjectOrderTemplateElementsAsync>d__5")]
private static Task`1<ImmutableList`1<ProjectElement>> GetProjectOrderTemplateElementsAsync(ProjectCollection projectCollection, TemplateType templateType, IProjectLockService projectLockService);
    private static XmlReader CreateXmlReaderHelper(string content);
    private static ProjectElement GetLastTopLevelElementOfType(Type elementType, ProjectRootElement projectXml);
    private static void GetTemplateSectionBeginAndEndMarkers(ProjectElement projectOrderTemplateElement, ProjectRootElement projectXml, ProjectElement& startMarker, ProjectElement& endMarker);
    private static bool MatchesWithProjectOrderTemplateElement(ProjectElement element, ProjectElement projectOrderTemplateSectionElement);
    private static string GetLabelOfProjectElement(ProjectElement projectElement);
}
internal static class Microsoft.VisualStudio.ProjectSystem.ProjectErrorUtilities : object {
    internal static IEvaluatedProperty ThrowRulePropertyMissing(ConfiguredProject configuredProject, string ruleName, string propertyName, string fileName, string itemType, string itemName);
    internal static IEvaluatedProperty ThrowRuleMissing(ConfiguredProject configuredProject, string ruleName, string propertyName, string fileName, string itemType, string itemName);
    internal static void VerifyThrowProjectException(bool condition, string message);
    internal static void VerifyThrowProjectException(bool condition, string message, object arg0);
    internal static void VerifyThrowProjectException(bool condition, string unformattedMessage, Object[] args);
    internal static Exception ThrowProjectException(string message);
    internal static Exception ThrowProjectException(string message, object arg0);
    internal static Exception ThrowProjectException(string message, object arg0, object arg1);
    internal static Exception ThrowProjectException(Exception innerException, string message);
    internal static Exception ThrowProjectException(Exception innerException, string message, object arg0);
    internal static Exception ThrowProjectException(Exception innerException, string message, object arg0, object arg1);
    private static Exception ThrowProjectExceptionHelper(Exception innerException, string unformattedMessage, Object[] args);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectException : Exception {
    public ProjectException(string message);
    public ProjectException(string message, Exception inner);
    protected ProjectException(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectFaultSeverity : Enum {
    public int value__;
    public static ProjectFaultSeverity Recoverable;
    public static ProjectFaultSeverity LimitedFunctionality;
    public static ProjectFaultSeverity NotRecoverable;
    [ObsoleteAttribute]
public static ProjectFaultSeverity Crippling;
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectImageMoniker : object {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public Guid Guid { get; private set; }
    public int Id { get; private set; }
    public ProjectImageMoniker(Guid guid, int id);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
private void set_Guid(Guid value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
    public static bool op_Equality(ProjectImageMoniker moniker1, ProjectImageMoniker moniker2);
    public static bool op_Inequality(ProjectImageMoniker moniker1, ProjectImageMoniker moniker2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectImageMoniker other);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.ProjectImportTreeExtensions : object {
    [ExtensionAttribute]
public static IProjectImportTreeSnapshot FilterByLabel(IProjectImportTreeSnapshot snapshot, string label);
    [ExtensionAttribute]
public static IEnumerable`1<IProjectImportSnapshot> Flatten(IProjectImportTreeSnapshot snapshot);
    private static void RecursivelyProcessImports(IProjectImportSnapshot importSnapshot, Action`1<IProjectImportSnapshot> action);
    private static IProjectImportSnapshot Filter(IProjectImportSnapshot import, Func`2<IProjectImportSnapshot, bool> filter);
}
[DebuggerDisplayAttribute("{ItemType} '{EvaluatedInclude}'")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectItemIdentity : object {
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluatedInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LinkPath>k__BackingField;
    public string ItemType { get; }
    public string EvaluatedInclude { get; }
    public string LinkPath { get; }
    public ProjectItemIdentity(string itemType, string evaluatedInclude, string linkPath);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public string get_EvaluatedInclude();
    [CompilerGeneratedAttribute]
public string get_LinkPath();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectItemIdentityEqualityComparer : object {
    private static ProjectItemIdentityEqualityComparer DefaultInstance;
    public static IEqualityComparer`1<IProjectItem> Default { get; }
    private static ProjectItemIdentityEqualityComparer();
    public static IEqualityComparer`1<IProjectItem> get_Default();
    public sealed virtual bool Equals(IProjectItem x, IProjectItem y);
    public sealed virtual int GetHashCode(IProjectItem obj);
}
internal abstract class Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1 : object {
    private IImmutableSet`1<string> supportedItemTypes;
    private IImmutableSet`1<string> readOnlyItemTypes;
    private object supportedItemTypesLock;
    private string projectDirectory;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ItemIdentityChangedEventArgs> ItemIdentityChanging;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ItemIdentityChangedEventArgs> ItemIdentityChangedOnWriter;
    [CompilerGeneratedAttribute]
private AsyncEventHandler`1<ItemIdentityChangedEventArgs> ItemIdentityChanged;
    [CompilerGeneratedAttribute]
private IEventDispatcherService <EventDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfiguredProject <ConfiguredProject>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfiguredProjectCacheFactory <ConfiguredProjectCacheFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectPropertiesProvider <PropertiesProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectLockService <ProjectLockService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectThreadingService <ThreadingService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFaultHandlerService <ProjectFaultHandlerService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectService <ProjectService>k__BackingField;
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    [ImportAttribute]
protected internal IEventDispatcherService EventDispatcher { get; protected internal set; }
    [ImportAttribute]
protected internal ConfiguredProject ConfiguredProject { get; private set; }
    [ImportAttribute]
protected internal IConfiguredProjectCacheFactory ConfiguredProjectCacheFactory { get; private set; }
    protected internal string ProjectDirectory { get; }
    [ImportAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectFileWithCatalog", "Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesProvider")]
protected internal IProjectPropertiesProvider PropertiesProvider { get; private set; }
    [ImportAttribute]
protected internal IProjectLockService ProjectLockService { get; private set; }
    [ImportAttribute]
protected internal IProjectThreadingService ThreadingService { get; private set; }
    [ImportAttribute]
protected internal IProjectFaultHandlerService ProjectFaultHandlerService { get; private set; }
    [ImportAttribute]
protected internal IProjectService ProjectService { get; protected internal set; }
    [ImportAttribute]
protected internal UnconfiguredProject UnconfiguredProject { get; protected internal set; }
    protected IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, bool, Task>>> ItemAddingListeners { get; }
    protected IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, DeleteOptions, Task>>> ItemRemovingListeners { get; }
    protected IEnumerable`1<Lazy`1<Func`2<IImmutableDictionary`2<string, string>, Task>>> ItemRenamingListeners { get; }
    protected IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, bool, Task>>> ItemAddedListeners { get; }
    protected IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, DeleteOptions, Task>>> ItemRemovedListeners { get; }
    protected IEnumerable`1<Lazy`1<Func`2<IImmutableDictionary`2<string, string>, Task>>> ItemRenamedListeners { get; }
    [CompilerGeneratedAttribute]
public void add_ItemIdentityChanging(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ItemIdentityChanging(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ItemIdentityChangedOnWriter(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ItemIdentityChangedOnWriter(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ItemIdentityChanged(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ItemIdentityChanged(AsyncEventHandler`1<ItemIdentityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
protected internal IEventDispatcherService get_EventDispatcher();
    [CompilerGeneratedAttribute]
protected internal void set_EventDispatcher(IEventDispatcherService value);
    [CompilerGeneratedAttribute]
protected internal ConfiguredProject get_ConfiguredProject();
    [CompilerGeneratedAttribute]
private void set_ConfiguredProject(ConfiguredProject value);
    [CompilerGeneratedAttribute]
protected internal IConfiguredProjectCacheFactory get_ConfiguredProjectCacheFactory();
    [CompilerGeneratedAttribute]
private void set_ConfiguredProjectCacheFactory(IConfiguredProjectCacheFactory value);
    protected internal string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
protected internal IProjectPropertiesProvider get_PropertiesProvider();
    [CompilerGeneratedAttribute]
private void set_PropertiesProvider(IProjectPropertiesProvider value);
    [CompilerGeneratedAttribute]
protected internal IProjectLockService get_ProjectLockService();
    [CompilerGeneratedAttribute]
private void set_ProjectLockService(IProjectLockService value);
    [CompilerGeneratedAttribute]
protected internal IProjectThreadingService get_ThreadingService();
    [CompilerGeneratedAttribute]
private void set_ThreadingService(IProjectThreadingService value);
    [CompilerGeneratedAttribute]
protected internal IProjectFaultHandlerService get_ProjectFaultHandlerService();
    [CompilerGeneratedAttribute]
private void set_ProjectFaultHandlerService(IProjectFaultHandlerService value);
    [CompilerGeneratedAttribute]
protected internal IProjectService get_ProjectService();
    [CompilerGeneratedAttribute]
protected internal void set_ProjectService(IProjectService value);
    [CompilerGeneratedAttribute]
protected internal UnconfiguredProject get_UnconfiguredProject();
    [CompilerGeneratedAttribute]
protected internal void set_UnconfiguredProject(UnconfiguredProject value);
    protected virtual IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, bool, Task>>> get_ItemAddingListeners();
    protected virtual IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, DeleteOptions, Task>>> get_ItemRemovingListeners();
    protected virtual IEnumerable`1<Lazy`1<Func`2<IImmutableDictionary`2<string, string>, Task>>> get_ItemRenamingListeners();
    protected virtual IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, bool, Task>>> get_ItemAddedListeners();
    protected virtual IEnumerable`1<Lazy`1<Func`3<ICollection`1<IProjectPropertiesContext>, DeleteOptions, Task>>> get_ItemRemovedListeners();
    protected virtual IEnumerable`1<Lazy`1<Func`2<IImmutableDictionary`2<string, string>, Task>>> get_ItemRenamedListeners();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetExistingItemTypesAsync>d__63")]
public Task`1<IImmutableSet`1<string>> GetExistingItemTypesAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsAsync>d__64")]
public virtual Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsAsync>d__65")]
public Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsAsync(string itemType);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsAsync>d__66")]
public virtual Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsAsync(string itemType, string evaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<FindItemByNameAsync>d__67")]
public Task`1<IProjectItem> FindItemByNameAsync(string evaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemAsync>d__68")]
public Task`1<TProjectItemInterface> GetItemAsync(IProjectPropertiesContext context);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsAsync>d__69")]
public virtual Task`1<IReadOnlyCollection`1<TProjectItemInterface>> GetItemsAsync(IReadOnlyCollection`1<IProjectPropertiesContext> context);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<AddAsync>d__70")]
public virtual Task`1<TProjectItemInterface> AddAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<AddAsync>d__71")]
public virtual Task`1<IEnumerable`1<TProjectItemInterface>> AddAsync(IEnumerable`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items);
    public Task`1<TProjectItemInterface> AddAsync(string path);
    public Task`1<IReadOnlyList`1<TProjectItemInterface>> AddAsync(IEnumerable`1<string> paths);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<RemoveAsync>d__74")]
public virtual Task RemoveAsync(string itemType, string evaluatedInclude, DeleteOptions deleteOptions);
    public virtual Task RemoveAsync(TProjectItemInterface item, DeleteOptions deleteOptions);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<RemoveAsync>d__76")]
public virtual Task RemoveAsync(IEnumerable`1<TProjectItemInterface> items, DeleteOptions deleteOptions);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemTypesAsync>d__77")]
public virtual Task`1<IImmutableSet`1<string>> GetItemTypesAsync();
    public abstract virtual Task`1<ProjectItem> SetUnevaluatedIncludeAsync(CpsProjectItem`1<TProjectItemInterface> cpsProjectItem, string newValue);
    public abstract virtual Task`1<ProjectItem> SetItemTypeAsync(CpsProjectItem`1<TProjectItemInterface> cpsProjectItem, string newValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<SetUnevaluatedIncludesAsync>d__80")]
public virtual Task SetUnevaluatedIncludesAsync(IReadOnlyCollection`1<KeyValuePair`2<IProjectItem, string>> renames);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<OnItemsIdentityChangingAsync>d__81")]
internal Task OnItemsIdentityChangingAsync(IEnumerable`1<KeyValuePair`2<IProjectItem, string>> renames);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<OnItemIdentityChangingAsync>d__82")]
internal Task OnItemIdentityChangingAsync(IProjectItem projectItem, string propertySheet, string oldItemType, string newItemType, string oldUnevaluatedInclude, string newUnevaluatedInclude, string oldEvaluatedInclude, string newEvaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<OnItemsIdentityChangedAsync>d__83")]
internal Task OnItemsIdentityChangedAsync(IEnumerable`1<KeyValuePair`2<IProjectItem, Tuple`2<string, string>>> renamedItems);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<OnItemIdentityChangedAsync>d__84")]
internal Task OnItemIdentityChangedAsync(IProjectItem projectItem, string propertySheet, string oldItemType, string newItemType, string oldUnevaluatedInclude, string newUnevaluatedInclude, string oldEvaluatedInclude, string newEvaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<AddFastAsync>d__85")]
internal virtual Task`1<TProjectItemInterface> AddFastAsync(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    protected virtual Task`1<IImmutableSet`1<string>> GetSupportedItemTypesAsync();
    protected virtual Task`1<TProjectItemInterface> AddCoreAsync(string path);
    protected virtual Task`1<IReadOnlyList`1<TProjectItemInterface>> AddCoreAsync(IEnumerable`1<string> paths);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsByPathAsync>d__89")]
protected Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsByPathAsync(string evaluatedInclude);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsByPathAsync>d__90")]
protected Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsByPathAsync(string itemType, string path);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsByPathAsync>d__91")]
protected Task`1<IEnumerable`1<TProjectItemInterface>> GetItemsByPathAsync(IEnumerable`1<string> itemTypes, string path);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetFirstItemByPathsAsync>d__92")]
protected Task`1<ILookup`2<string, TProjectItemInterface>> GetFirstItemByPathsAsync(ILookup`2<string, string> pathsByItemType);
    protected string CalculateUnevaluatedIncludePathAfterRenaming(IProjectItem projectItem, string oldFullPathEscaped, string oldRelativePathEscaped, string newRelativePathEscaped);
    protected abstract virtual TProjectItemInterface Create(ProjectItem item);
    protected abstract virtual IEnumerable`1<string> GetInitialItemTypes();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<AddItemsToProjectAsync>d__96")]
protected virtual Task`1<ICollection`1<TProjectItemInterface>> AddItemsToProjectAsync(ProjectWriteLockReleaser access, Project project, IEnumerable`1<Tuple`3<string, string, IEnumerable`1<KeyValuePair`2<string, string>>>> items);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<RemoveItemsFromProjectAsync>d__97")]
protected virtual Task RemoveItemsFromProjectAsync(ProjectWriteLockReleaser access, Project project, List`1<ProjectItem> items, DeleteOptions deleteOptions);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<AddAllMetadataAsync>d__98")]
protected virtual Task AddAllMetadataAsync(IProjectItem item, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectItemProviderBase`1/<GetItemsByPathHelperAsync>d__99")]
private Task`1<List`1<TProjectItemInterface>> GetItemsByPathHelperAsync(IEnumerable`1<string> itemTypes, string path, Project project);
    private static bool NeedToAddItemToProject(ProjectItem<TProjectItemInterface> item, Project project, string itemType, string evaluatedInclude, bool globbingEnabled);
    [CompilerGeneratedAttribute]
private IProjectPropertiesContext <RemoveAsync>b__76_2(TProjectItemInterface item);
    [CompilerGeneratedAttribute]
private TProjectItemInterface <GetItemsByPathAsync>b__89_1(ProjectItem item);
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectLoadCheckpoint : Enum {
    public int value__;
    public static ProjectLoadCheckpoint NotSpecified;
    public static ProjectLoadCheckpoint UnconfiguredProjectLocalCapabilitiesEstablished;
    public static ProjectLoadCheckpoint InitialActiveConfigurationKnown;
    public static ProjectLoadCheckpoint BeforeLoadInitialConfiguration;
    public static ProjectLoadCheckpoint AfterLoadInitialConfiguration;
    public static ProjectLoadCheckpoint ProjectInitialCapabilitiesEstablished;
    public static ProjectLoadCheckpoint ProjectFactoryCompleted;
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectLockAwaitable : ValueType {
    private ResourceAwaitable<ConfiguredProject, Project> awaitable;
    private IProjectLockReleaser helper;
    internal ProjectLockAwaitable(ResourceAwaitable<ConfiguredProject, Project> awaitable, IProjectLockReleaser helper);
    public ProjectLockAwaiter GetAwaiter();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectLockAwaiter : ValueType {
    private ResourceAwaiter<ConfiguredProject, Project> awaiter;
    private IProjectLockReleaser helper;
    public bool IsCompleted { get; }
    internal ProjectLockAwaiter(ResourceAwaiter<ConfiguredProject, Project> awaiter, IProjectLockReleaser helper);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public ProjectLockReleaser GetResult();
    private void ThrowIfNotInitialized();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectLockAwareJoinableTaskFactory : JoinableTaskFactory {
    [CompilerGeneratedAttribute]
private Lazy`1<IProjectLockServiceInternal> <ProjectLockService>k__BackingField;
    internal Lazy`1<IProjectLockServiceInternal> ProjectLockService { get; private set; }
    public ProjectLockAwareJoinableTaskFactory(Lazy`1<IProjectLockService> projectLockService, JoinableTaskContext context);
    public ProjectLockAwareJoinableTaskFactory(Lazy`1<IProjectLockService> projectLockService, JoinableTaskCollection collection);
    [CompilerGeneratedAttribute]
internal Lazy`1<IProjectLockServiceInternal> get_ProjectLockService();
    [CompilerGeneratedAttribute]
private void set_ProjectLockService(Lazy`1<IProjectLockServiceInternal> value);
    protected virtual void OnTransitioningToMainThread(JoinableTask joinableTask);
    protected virtual void OnTransitionedToMainThread(JoinableTask joinableTask, bool canceled);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ProjectLockFlags : Enum {
    public int value__;
    public static ProjectLockFlags None;
    public static ProjectLockFlags StickyWrite;
    public static ProjectLockFlags SkipInitialEvaluation;
    public static ProjectLockFlags SuppressReevaluation;
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectLockReleaser : ValueType {
    private ResourceReleaser<ConfiguredProject, Project> releaser;
    private IProjectLockReleaser helper;
    public ProjectCollection ProjectCollection { get; }
    internal ResourceReleaser<ConfiguredProject, Project> LockReleaser { get; }
    internal ProjectLockReleaser(ResourceReleaser<ConfiguredProject, Project> releaser, IProjectLockReleaser helper);
    public ProjectCollection get_ProjectCollection();
    internal ResourceReleaser<ConfiguredProject, Project> get_LockReleaser();
    public Task`1<Project> GetProjectAsync(ConfiguredProject configuredProject, CancellationToken cancellationToken);
    public Task`1<ProjectRootElement> GetProjectXmlAsync(string projectFile, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public Task ReleaseAsync();
    private void ThrowIfNotInitialized();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectLockSuppression : ValueType {
    private Suppression suppression;
    internal ProjectLockSuppression(Suppression suppression);
    public sealed virtual void Dispose();
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectReloadResult : Enum {
    public int value__;
    public static ProjectReloadResult NoAction;
    public static ProjectReloadResult ReloadCompleted;
    public static ProjectReloadResult ReloadFailedProjectDirty;
    public static ProjectReloadResult ReloadFailed;
    public static ProjectReloadResult NeedsForceReload;
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectRenamedEventArgs : EventArgs {
    public string OldFullPath { get; }
    public string NewFullPath { get; }
    public IReadOnlyDictionary`2<string, string> OtherRenamedFiles { get; }
    public abstract virtual string get_OldFullPath();
    public abstract virtual string get_NewFullPath();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_OtherRenamedFiles();
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectRenameType : Enum {
    public int value__;
    public static ProjectRenameType Unknown;
    public static ProjectRenameType Rename;
    public static ProjectRenameType SaveAs;
    public static ProjectRenameType CaseOnly;
}
[DebuggerDisplayAttribute("{ScopeIdentity} : {CapabilitiesString}")]
internal class Microsoft.VisualStudio.ProjectSystem.ProjectScopeCapabilitiesSnapshot : object {
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<NamedIdentity, IProjectScopeCapabilitiesSnapshot> <InheritedProjectScopeCapabilitiesSnapshots>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedIdentity <ScopeIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IProjectCapabilitiesSnapshot> <InnerCheckers>k__BackingField;
    public IImmutableDictionary`2<NamedIdentity, IProjectScopeCapabilitiesSnapshot> InheritedProjectScopeCapabilitiesSnapshots { get; }
    public NamedIdentity ScopeIdentity { get; }
    public Nullable`1<long> Version { get; }
    internal ImmutableArray`1<IProjectCapabilitiesSnapshot> InnerCheckers { get; }
    private string CapabilitiesString { get; }
    public ProjectScopeCapabilitiesSnapshot(NamedIdentity scopeIdentity, ImmutableArray`1<IProjectCapabilitiesSnapshot> innerCheckers, Nullable`1<long> version);
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableDictionary`2<NamedIdentity, IProjectScopeCapabilitiesSnapshot> get_InheritedProjectScopeCapabilitiesSnapshots();
    [CompilerGeneratedAttribute]
public sealed virtual NamedIdentity get_ScopeIdentity();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_Version();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<IProjectCapabilitiesSnapshot> get_InnerCheckers();
    private string get_CapabilitiesString();
    public sealed virtual bool IsProjectCapabilityPresent(string projectCapability);
    public sealed virtual IEnumerator`1<IProjectCapabilitiesSnapshot> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.VisualStudio.ProjectSystem.ProjectServiceSelfHost : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectServiceSelfHost/<CreateSelfHostAsync>d__0")]
internal static Task`1<IProjectService> CreateSelfHostAsync(IReadOnlyCollection`1<Assembly> assemblies, ProjectServiceThreadingModel threadingModel, IImmutableSet`1<string> serviceCapabilities, bool throwCompositionErrors);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectServiceSelfHost/<CreateSelfHostContainerAsync>d__1")]
internal static Task`1<ExportProvider> CreateSelfHostContainerAsync(IReadOnlyCollection`1<Assembly> assemblies, bool throwCompositionErrors);
    internal static ExportProvider CreateSelfHostContainer(ComposableCatalog catalog, bool throwCompositionErrors);
    internal static IProjectService GetProjectService(ProjectServiceThreadingModel threadingModel, IImmutableSet`1<string> serviceCapabilities, Nullable`1<bool> diagnosticRuntime, ExportProvider container);
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectServiceThreadingModel : Enum {
    public int value__;
    public static ProjectServiceThreadingModel Multithreaded;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.ProjectSharedFoldersExtensions : object {
    [ExtensionAttribute]
public static bool TryGetSharedFolderForPath(IProjectSharedFoldersSnapshot sharedFolders, string path, String& sharedFolderPath, String& pathRelativeToSharedFolder);
    [ExtensionAttribute]
public static bool IsPathWithinAnySharedFolder(IProjectSharedFoldersSnapshot sharedFolders, string path);
    [ExtensionAttribute]
public static bool IsProjectItemDefinedInASharedImport(IProjectSharedFoldersSnapshot sharedFolders, IProjectItem projectItem);
    [ExtensionAttribute]
public static string GetImportedProjectForSharedItemPath(IProjectSharedFoldersSnapshot sharedFolders, string sharedItemPath);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectSubscriptionUpdate : object {
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, IProjectChangeDescription> <ProjectChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<string, IProjectRuleSnapshot> <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectConfiguration <ProjectConfiguration>k__BackingField;
    public IImmutableDictionary`2<string, IProjectChangeDescription> ProjectChanges { get; private set; }
    public IImmutableDictionary`2<string, IProjectRuleSnapshot> CurrentState { get; private set; }
    public ProjectConfiguration ProjectConfiguration { get; private set; }
    public ProjectSubscriptionUpdate(IImmutableDictionary`2<string, IProjectChangeDescription> projectChanges, ProjectConfiguration projectConfiguration);
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableDictionary`2<string, IProjectChangeDescription> get_ProjectChanges();
    [CompilerGeneratedAttribute]
private void set_ProjectChanges(IImmutableDictionary`2<string, IProjectChangeDescription> value);
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableDictionary`2<string, IProjectRuleSnapshot> get_CurrentState();
    [CompilerGeneratedAttribute]
private void set_CurrentState(IImmutableDictionary`2<string, IProjectRuleSnapshot> value);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectConfiguration get_ProjectConfiguration();
    [CompilerGeneratedAttribute]
private void set_ProjectConfiguration(ProjectConfiguration value);
}
[AttributeUsageAttribute("5125")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectSystemContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ContractType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectSystemContractProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectSystemContractScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportCardinality <Cardinality>k__BackingField;
    public Type ContractType { get; public set; }
    public string ContractName { get; public set; }
    public ProjectSystemContractProvider Provider { get; public set; }
    public ProjectSystemContractScope Scope { get; public set; }
    public ImportCardinality Cardinality { get; public set; }
    public ProjectSystemContractAttribute(ProjectSystemContractScope scope, ProjectSystemContractProvider provider);
    [CompilerGeneratedAttribute]
public Type get_ContractType();
    [CompilerGeneratedAttribute]
public void set_ContractType(Type value);
    [CompilerGeneratedAttribute]
public string get_ContractName();
    [CompilerGeneratedAttribute]
public void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public ProjectSystemContractProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(ProjectSystemContractProvider value);
    [CompilerGeneratedAttribute]
public ProjectSystemContractScope get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(ProjectSystemContractScope value);
    [CompilerGeneratedAttribute]
public ImportCardinality get_Cardinality();
    [CompilerGeneratedAttribute]
public void set_Cardinality(ImportCardinality value);
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectSystemContractProvider : Enum {
    public int value__;
    public static ProjectSystemContractProvider System;
    public static ProjectSystemContractProvider Host;
    public static ProjectSystemContractProvider Extension;
    public static ProjectSystemContractProvider Private;
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectSystemContractScope : Enum {
    public int value__;
    public static ProjectSystemContractScope ProjectService;
    public static ProjectSystemContractScope UnconfiguredProject;
    public static ProjectSystemContractScope ConfiguredProject;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.ProjectThreadingServiceExtensions : object {
    [ExtensionAttribute]
public static MainThreadAwaitable SwitchToUIThread(IProjectThreadingService threading, StrongBox`1<bool> yielded);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectTreeActionHandlerBase : object {
    public virtual bool CanCopy(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, IProjectTree receiver, bool deleteOriginal);
    public virtual bool CanExcludeItems(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public virtual bool CanIncludeItems(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public virtual bool CanRemove(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public virtual Task`1<bool> CanRenameAsync(IProjectTreeActionHandlerContext context, IProjectTree node);
    public virtual Task ExcludeItemsAsync(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public virtual string GetAddNewItemDirectory(IProjectTreeActionHandlerContext context, IProjectTree target);
    public virtual Task IncludeItemsAsync(IProjectTreeActionHandlerContext context, IImmutableSet`1<IProjectTree> nodes);
    public virtual Task RemoveAsync(IProjectTreeActionHandlerContext context, IEnumerable`1<IProjectTree> nodes, DeleteOptions deleteOptions);
    public virtual Task RenameAsync(IProjectTreeActionHandlerContext context, IProjectTree node, string value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.ProjectTreeChangedProperty : Enum {
    public int value__;
    public static ProjectTreeChangedProperty None;
    public static ProjectTreeChangedProperty PositionUnderParent;
    public static ProjectTreeChangedProperty Caption;
    public static ProjectTreeChangedProperty Icon;
    public static ProjectTreeChangedProperty ExpandedIcon;
    public static ProjectTreeChangedProperty Visible;
    public static ProjectTreeChangedProperty Flags;
    public static ProjectTreeChangedProperty All;
}
public enum Microsoft.VisualStudio.ProjectSystem.ProjectTreeChangeKind : Enum {
    public int value__;
    public static ProjectTreeChangeKind Added;
    public static ProjectTreeChangeKind Replaced;
    public static ProjectTreeChangeKind Removed;
}
internal class Microsoft.VisualStudio.ProjectSystem.ProjectTreeCorruptionException : ProjectException {
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTree <PriorTree>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTree <FreshTree>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTree <MutatedTree>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTreeProvider <FaultedProvider>k__BackingField;
    internal string ProjectPath { get; private set; }
    internal IProjectTree PriorTree { get; private set; }
    internal IProjectTree FreshTree { get; private set; }
    internal IProjectTree MutatedTree { get; private set; }
    internal IProjectTreeProvider FaultedProvider { get; private set; }
    public ProjectTreeCorruptionException(string message, string projectPath, IProjectTreeProvider faultedProvider, IProjectTree priorTree, IProjectTree freshTree, IProjectTree mutatedTree, Exception innerException);
    protected ProjectTreeCorruptionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal string get_ProjectPath();
    [CompilerGeneratedAttribute]
private void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
internal IProjectTree get_PriorTree();
    [CompilerGeneratedAttribute]
private void set_PriorTree(IProjectTree value);
    [CompilerGeneratedAttribute]
internal IProjectTree get_FreshTree();
    [CompilerGeneratedAttribute]
private void set_FreshTree(IProjectTree value);
    [CompilerGeneratedAttribute]
internal IProjectTree get_MutatedTree();
    [CompilerGeneratedAttribute]
private void set_MutatedTree(IProjectTree value);
    [CompilerGeneratedAttribute]
internal IProjectTreeProvider get_FaultedProvider();
    [CompilerGeneratedAttribute]
private void set_FaultedProvider(IProjectTreeProvider value);
    public virtual string ToString();
}
public static class Microsoft.VisualStudio.ProjectSystem.ProjectTreeDataSources : object {
    public static NamedIdentity BaseTreeGeneration;
    public static NamedIdentity ReferencesFolderProjectSnapshotVersion;
    public static NamedIdentity DirectoryTreeGeneration;
    public static ImmutableHashSet`1<NamedIdentity> ProjectSnapshotBasedDataSources;
    private static ProjectTreeDataSources();
    public static ImmutableDictionary`2<NamedIdentity, IProjectVersionRequirement> GetGenerationRequirement(IProjectVersionedValue`1<IProjectTreeSnapshot> treeGeneration);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions : object {
    [ExtensionAttribute]
public static bool IsRoot(IProjectTree node);
    [ExtensionAttribute]
public static T ClearChildren(T tree);
    [ExtensionAttribute]
public static T CopyChildrenFrom(T tree, IProjectTree source);
    [ExtensionAttribute]
public static IProjectPropertiesContext GetProjectPropertiesContext(IProjectItemTree node);
    [ExtensionAttribute]
public static IEnumerable`1<IProjectTree> GetSelfAndDescendentsBreadthFirst(IProjectTree root);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<GetSelfAndDescendentsBreadthFirst>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTree> GetSelfAndDescendentsBreadthFirst(IProjectTree root, Func`2<IProjectTree, bool> canSkipNodeAndChildren);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<GetSelfAndDescendentsDepthFirst>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTree> GetSelfAndDescendentsDepthFirst(IProjectTree root);
    [ExtensionAttribute]
public static IProjectTree UpdateSelfAndAllDescendents(IProjectTree tree, Func`2<IProjectTree, IProjectTree> updateAction);
    [ExtensionAttribute]
public static IImmutableSet`1<IProjectTree> WithFollowingChildren(IEnumerable`1<IProjectTree> collection);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<GetAncestry>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTree> GetAncestry(IProjectTree leaf);
    [ExtensionAttribute]
public static bool DescendsFrom(IProjectTree leaf, IProjectTree candidateAncestor);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<SplitRepositionedToDeleteAdd>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTreeDiff> SplitRepositionedToDeleteAdd(IEnumerable`1<IProjectTreeDiff> deltas);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<SplitChangeToDeleteAdd>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTreeDiff> SplitChangeToDeleteAdd(IEnumerable`1<IProjectTreeDiff> deltas, bool onlySplitRenames);
    [ExtensionAttribute]
public static IEnumerable`1<IProjectTreeDiff> SortRootToLeaf(IEnumerable`1<IProjectTreeDiff> deltas, IProjectTree referenceTree);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<FilterOutChangesBelowVisibilityChanges>d__14")]
[ExtensionAttribute]
public static IEnumerable`1<IProjectTreeDiff> FilterOutChangesBelowVisibilityChanges(IEnumerable`1<IProjectTreeDiff> deltas, IProjectTree oldTree, IProjectTree newTree);
    [ExtensionAttribute]
public static bool IsVisible(IProjectTree tree);
    [ExtensionAttribute]
internal static IProjectTree GetPreviousVisibleSibling(IProjectTree node);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeExtensions/<WithDuplicates>d__17")]
[ExtensionAttribute]
internal static IEnumerable`1<IProjectTree> WithDuplicates(IProjectTree tree);
    [ExtensionAttribute]
internal static bool TryGetBrowseObjectPropertiesSnapshot(IProjectTree tree, ConfiguredProject configuredProject, bool requiredToMatchProjectVersion, IRule& browseObjectSnapshotProperties);
    private static ImmutableHashSet`1<IProjectTree> WithFollowingChildren(ImmutableHashSet`1<IProjectTree> basis, IProjectTree candidate);
}
[DebuggerDisplayAttribute("({DisplayValue})")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectTreeFlags : ValueType {
    private static Dictionary`2<string, CommonExtended> CommonFlagMapping;
    private static ImmutableHashSet`1<string> EmptyExtendedFlags;
    private CommonExtended commonFlags;
    private ImmutableHashSet`1<string> extendedFlags;
    [CompilerGeneratedAttribute]
private static ProjectTreeFlags <Empty>k__BackingField;
    public static ProjectTreeFlags AlwaysCopyable;
    public static ProjectTreeFlags AlwaysInvisible;
    public static ProjectTreeFlags AppDesignerFolder;
    public static ProjectTreeFlags BrokenReference;
    public static ProjectTreeFlags BubbleUp;
    public static ProjectTreeFlags DisableAddItemFolder;
    public static ProjectTreeFlags DisableAddItemRecursiveFolder;
    public static ProjectTreeFlags FileOnDisk;
    public static ProjectTreeFlags FileSystemEntity;
    public static ProjectTreeFlags Folder;
    public static ProjectTreeFlags HasDependentUponMetadata;
    public static ProjectTreeFlags HiddenFileSystemEntity;
    public static ProjectTreeFlags HiddenIncludeInProjectCandidate;
    public static ProjectTreeFlags HiddenProjectSettingsFile;
    public static ProjectTreeFlags HiddenProjectItem;
    public static ProjectTreeFlags IncludeInProjectCandidate;
    public static ProjectTreeFlags MultipleIncludedItem;
    public static ProjectTreeFlags NestedProject;
    public static ProjectTreeFlags NonMemberItem;
    public static ProjectTreeFlags ProjectRoot;
    public static ProjectTreeFlags Reference;
    public static ProjectTreeFlags ReferencesFolder;
    public static ProjectTreeFlags ResolvedReference;
    public static ProjectTreeFlags SaveSharedFolderWithSharedItemsImportFile;
    public static ProjectTreeFlags SharedFolder;
    public static ProjectTreeFlags SharedItemsImportFile;
    public static ProjectTreeFlags SharedProjectImportReference;
    public static ProjectTreeFlags SourceFile;
    public static ProjectTreeFlags VirtualFolder;
    public static ProjectTreeFlags VisibleOnlyInShowAllFiles;
    public static ProjectTreeFlags ImportedSharedItem;
    public static ProjectTreeFlags NonFileSystemProjectItem;
    public static ProjectTreeFlags LinkedFilesOnlyFolder;
    public static ProjectTreeFlags DuplicateItem;
    public static ProjectTreeFlags FaultTree;
    public static ProjectTreeFlags LoadingTree;
    public static ProjectTreeFlags Empty { get; }
    public int Count { get; }
    internal string DisplayValue { get; }
    private static ProjectTreeFlags();
    private ProjectTreeFlags(Common commonFlags, ImmutableHashSet`1<string> extendedFlags);
    private ProjectTreeFlags(CommonExtended commonFlags, ImmutableHashSet`1<string> extendedFlags);
    [CompilerGeneratedAttribute]
public static ProjectTreeFlags get_Empty();
    public int get_Count();
    internal string get_DisplayValue();
    public static bool op_Equality(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static bool op_Inequality(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static bool op_GreaterThanOrEqual(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static bool op_LessThanOrEqual(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static bool op_GreaterThan(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static bool op_LessThan(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static ProjectTreeFlags op_BitwiseOr(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static ProjectTreeFlags op_Addition(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static ProjectTreeFlags op_Subtraction(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static ProjectTreeFlags op_BitwiseAnd(ProjectTreeFlags flags1, ProjectTreeFlags flags2);
    public static ProjectTreeFlags Create();
    public static ProjectTreeFlags Create(String[] flags);
    public static ProjectTreeFlags Create(Common flags);
    private static ProjectTreeFlags Create(CommonExtended flags);
    public bool Contains(ProjectTreeFlags flags);
    public bool Contains(string flag);
    public bool Contains(Common flags);
    private bool Contains(CommonExtended flags);
    public bool ContainsAny(Common flags);
    private bool ContainsAny(CommonExtended flags);
    public ProjectTreeFlags Add(string flag);
    public ProjectTreeFlags Add(Common flags);
    private ProjectTreeFlags Add(CommonExtended flags);
    public ProjectTreeFlags Union(ProjectTreeFlags flags);
    public ProjectTreeFlags Union(IEnumerable`1<string> flags);
    public ProjectTreeFlags Remove(Common flags);
    private ProjectTreeFlags Remove(CommonExtended flags);
    public ProjectTreeFlags Remove(string flag);
    public ProjectTreeFlags Except(ProjectTreeFlags flags);
    public ProjectTreeFlags Except(IEnumerable`1<string> flags);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(ProjectTreeFlags other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectTreeProviderBase : CoreProjectTreeProviderBase {
    private bool configuredProjectExportsRequired;
    private TaskCompletionSource`1<ConfiguredProjectExports> initialActiveConfiguredProjectExports;
    private ConfiguredProjectExports configuredProjectExports;
    private IDisposable activeConfiguredProjectLink;
    [CompilerGeneratedAttribute]
private Lazy`2<IProjectErrorReporting, IAppliesToMetadataView> <ImportingProjectErrorReporting>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectAsynchronousTasksService <UnconfiguredProjectAsynchronousTasksService>k__BackingField;
    [CompilerGeneratedAttribute]
private IActiveConfiguredProjectSubscriptionService <ProjectSubscriptionService>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTreeFactory <TreeFactoryImports>k__BackingField;
    [CompilerGeneratedAttribute]
private IActiveConfiguredProjectProvider <ActiveConfiguredProjectProvider>k__BackingField;
    [ImportAttribute]
private Lazy`2<IProjectErrorReporting, IAppliesToMetadataView> ImportingProjectErrorReporting { get; private set; }
    protected IProjectErrorReporting ProjectErrorReporting { get; }
    [ImportAttribute("Microsoft.VisualStudio.ProjectSystem.UnconfiguredProject")]
protected IProjectAsynchronousTasksService UnconfiguredProjectAsynchronousTasksService { get; private set; }
    [ImportAttribute]
protected IActiveConfiguredProjectSubscriptionService ProjectSubscriptionService { get; private set; }
    protected IProjectTreeFactory TreeFactory { get; }
    [ImportAttribute]
private IProjectTreeFactory TreeFactoryImports { get; private set; }
    [ImportAttribute]
protected IActiveConfiguredProjectProvider ActiveConfiguredProjectProvider { get; private set; }
    protected ConfiguredProject ActiveConfiguredProject { get; }
    protected Task InitialActiveConfiguredProjectAvailable { get; }
    [EditorBrowsableAttribute("2")]
protected CancellationToken DefaultCancellationToken { get; }
    protected ConfiguredProjectExports TreeUpdateConfiguredProjectExports { get; }
    protected CoreConfiguredProjectExports CurrentCoreConfiguredProjectExports { get; }
    protected ConfiguredProjectExports CurrentConfiguredProjectExports { get; }
    protected ProjectTreeProviderBase(IProjectThreadingService threadingService, UnconfiguredProject unconfiguredProject, bool configuredProjectExportsRequired);
    [CompilerGeneratedAttribute]
private Lazy`2<IProjectErrorReporting, IAppliesToMetadataView> get_ImportingProjectErrorReporting();
    [CompilerGeneratedAttribute]
private void set_ImportingProjectErrorReporting(Lazy`2<IProjectErrorReporting, IAppliesToMetadataView> value);
    protected IProjectErrorReporting get_ProjectErrorReporting();
    [CompilerGeneratedAttribute]
protected IProjectAsynchronousTasksService get_UnconfiguredProjectAsynchronousTasksService();
    [CompilerGeneratedAttribute]
private void set_UnconfiguredProjectAsynchronousTasksService(IProjectAsynchronousTasksService value);
    [CompilerGeneratedAttribute]
protected IActiveConfiguredProjectSubscriptionService get_ProjectSubscriptionService();
    [CompilerGeneratedAttribute]
private void set_ProjectSubscriptionService(IActiveConfiguredProjectSubscriptionService value);
    protected sealed virtual IProjectTreeFactory get_TreeFactory();
    [CompilerGeneratedAttribute]
private IProjectTreeFactory get_TreeFactoryImports();
    [CompilerGeneratedAttribute]
private void set_TreeFactoryImports(IProjectTreeFactory value);
    [CompilerGeneratedAttribute]
protected IActiveConfiguredProjectProvider get_ActiveConfiguredProjectProvider();
    [CompilerGeneratedAttribute]
private void set_ActiveConfiguredProjectProvider(IActiveConfiguredProjectProvider value);
    protected ConfiguredProject get_ActiveConfiguredProject();
    protected Task get_InitialActiveConfiguredProjectAvailable();
    protected sealed virtual CancellationToken get_DefaultCancellationToken();
    protected ConfiguredProjectExports get_TreeUpdateConfiguredProjectExports();
    protected sealed virtual CoreConfiguredProjectExports get_CurrentCoreConfiguredProjectExports();
    protected ConfiguredProjectExports get_CurrentConfiguredProjectExports();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.ProjectTreeProviderBase/<RetrieveConfiguredProjectExportsIfRequiredAsync>d__43")]
protected sealed virtual Task`1<CoreConfiguredProjectExports> RetrieveConfiguredProjectExportsIfRequiredAsync();
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    protected virtual void ActiveConfiguredProjectProviderChanged(IProjectVersionedValue`1<ConfiguredProject> newActiveConfiguredProject);
    protected virtual TreeUpdateResult UpdateTreeForActiveConfigurationChange(IProjectTree projectTree, IProjectCatalogSnapshot catalogs, ConfiguredProjectExports configuredProjectExports, CancellationToken cancellationToken);
    protected virtual IProjectTree RenewBrowseObjectPropertiesPerConfiguration(IProjectTree projectTree, IPropertyPagesCatalog browseObjectCatalog, ConfiguredProjectExports configuredProjectExports);
    protected Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateOnlyAsync(TreeUpdateAsyncDelegate treeTransformation, CancellationToken cancellationToken);
    protected Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateAsync(TreeUpdateAsyncDelegate treeTransformation, Int64& generationNumber, CancellationToken cancellationToken);
    protected Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateAsync(TreeUpdateAsyncDelegate treeTransformation, CancellationToken cancellationToken);
    protected Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateAsync(TreeUpdateAsyncDelegate treeTransformation, NamedIdentity updatedSource, IComparable updatedSourceVersion, CancellationToken cancellationToken);
    protected Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateAsync(TreeUpdateAsyncDelegate treeTransformation, IImmutableDictionary`2<NamedIdentity, IComparable> updatedSources, TreeSubmissionOptions options, CancellationToken cancellationToken);
    internal Task`1<IProjectVersionedValue`1<IProjectTreeSnapshot>> SubmitTreeUpdateAsync(TreeUpdateAsyncDelegate treeTransformation, IImmutableDictionary`2<NamedIdentity, IComparable> updatedSources, TreeSubmissionOptions options, Int64& generationNumber, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
protected sealed virtual Task`1<IProjectTree> PrepublishMutationAsync(IProjectVersionedValue`1<IProjectTreeSnapshot> priorTree, IProjectVersionedValue`1<IProjectTreeSnapshot> tree, CoreConfiguredProjectExports activeConfiguredProject, CancellationToken cancellationToken);
    protected virtual Task`1<IProjectTree> PrepublishMutationAsync(IProjectVersionedValue`1<IProjectTreeSnapshot> priorTree, IProjectVersionedValue`1<IProjectTreeSnapshot> tree, ConfiguredProjectExports activeConfiguredProject, CancellationToken cancellationToken);
    protected abstract virtual ConfiguredProjectExports GetActiveConfiguredProjectExports(ConfiguredProject newActiveConfiguredProject);
    protected T GetActiveConfiguredProjectExports(ConfiguredProject newActiveConfiguredProject);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectTreeSnapshot : object {
    [CompilerGeneratedAttribute]
private IProjectTree <Tree>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectTreeProvider <TreeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfiguredProject <PopulatingConfiguredProject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LazyFill>k__BackingField;
    public IProjectTree Tree { get; private set; }
    public IProjectTreeProvider TreeProvider { get; private set; }
    public ConfiguredProject PopulatingConfiguredProject { get; private set; }
    public bool LazyFill { get; private set; }
    public ProjectTreeSnapshot(IProjectTreeProvider treeProvider, IProjectTree tree, ConfiguredProject populatingConfiguredProject, bool lazyFill);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectTree get_Tree();
    [CompilerGeneratedAttribute]
private void set_Tree(IProjectTree value);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectTreeProvider get_TreeProvider();
    [CompilerGeneratedAttribute]
private void set_TreeProvider(IProjectTreeProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual ConfiguredProject get_PopulatingConfiguredProject();
    [CompilerGeneratedAttribute]
private void set_PopulatingConfiguredProject(ConfiguredProject value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LazyFill();
    [CompilerGeneratedAttribute]
private void set_LazyFill(bool value);
}
[AttributeUsageAttribute("4")]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.ProjectTypeGuidFilterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Guid <ProjectType>k__BackingField;
    public Guid ProjectType { get; private set; }
    public ProjectTypeGuidFilterAttribute(Guid projectType);
    public ProjectTypeGuidFilterAttribute(string projectType);
    [CompilerGeneratedAttribute]
public Guid get_ProjectType();
    [CompilerGeneratedAttribute]
private void set_ProjectType(Guid value);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ProjectValueDataSourceBase`1 : OnceInitializedOnceDisposed {
    private DisposableBag disposableBag;
    private IProjectDataSourceRegistry dataSourceRegistry;
    [CompilerGeneratedAttribute]
private IProjectFaultHandlerService <ProjectFaultHandlerService>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskCollection <JoinableCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskFactory <JoinableFactory>k__BackingField;
    public NamedIdentity DataSourceKey { get; }
    public IComparable DataSourceVersion { get; }
    public IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> SourceBlock { get; }
    private ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.SourceBlock { get; }
    protected IProjectFaultHandlerService ProjectFaultHandlerService { get; private set; }
    protected JoinableTaskCollection JoinableCollection { get; private set; }
    protected JoinableTaskFactory JoinableFactory { get; private set; }
    protected ProjectFaultSeverity FaultSeverity { get; }
    protected ProjectValueDataSourceBase`1(IProjectCommonServices commonServices, bool synchronousDisposal, bool registerDataSource);
    internal ProjectValueDataSourceBase`1(JoinableTaskContextNode joinableTaskContextNode, IProjectFaultHandlerService faultHandlerService, IProjectDataSourceRegistry dataSourceRegistry, bool synchronousDisposal);
    public abstract virtual NamedIdentity get_DataSourceKey();
    public abstract virtual IComparable get_DataSourceVersion();
    public abstract virtual IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> get_SourceBlock();
    private sealed virtual override ISourceBlock`1<IProjectVersionedValue`1<object>> Microsoft.VisualStudio.ProjectSystem.IProjectValueDataSource.get_SourceBlock();
    [CompilerGeneratedAttribute]
protected IProjectFaultHandlerService get_ProjectFaultHandlerService();
    [CompilerGeneratedAttribute]
private void set_ProjectFaultHandlerService(IProjectFaultHandlerService value);
    [CompilerGeneratedAttribute]
protected JoinableTaskCollection get_JoinableCollection();
    [CompilerGeneratedAttribute]
private void set_JoinableCollection(JoinableTaskCollection value);
    [CompilerGeneratedAttribute]
protected JoinableTaskFactory get_JoinableFactory();
    [CompilerGeneratedAttribute]
private void set_JoinableFactory(JoinableTaskFactory value);
    protected ProjectFaultSeverity get_FaultSeverity();
    private sealed virtual override IDisposable Microsoft.VisualStudio.ProjectSystem.IJoinableProjectValueDataSource.Join();
    protected IDisposable JoinUpstreamDataSources(IJoinableProjectValueDataSource[] dataSources);
    protected IDisposable JoinUpstreamDataSources(IEnumerable`1<IJoinableProjectValueDataSource> dataSources);
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    protected void MonitorDataSourceFault(IReceivableSourceBlock`1<IProjectVersionedValue`1<T>> sourceBlock, UnconfiguredProject project);
    protected void ReportDataSourceUserFault(Exception exception, ProjectFaultSeverity severity, UnconfiguredProject project);
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectVersionedValue`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<NamedIdentity, IComparable> <DataSourceVersions>k__BackingField;
    public T Value { get; }
    public IImmutableDictionary`2<NamedIdentity, IComparable> DataSourceVersions { get; }
    public ProjectVersionedValue`1(T value, IImmutableDictionary`2<NamedIdentity, IComparable> dataSourceVersions);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableDictionary`2<NamedIdentity, IComparable> get_DataSourceVersions();
}
[DebuggerDisplayAttribute("Version: {Version} AllowMissingData: {AllowMissingData}")]
public class Microsoft.VisualStudio.ProjectSystem.ProjectVersionRequirement : object {
    [CompilerGeneratedAttribute]
private IComparable <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMissingData>k__BackingField;
    public IComparable Version { get; private set; }
    public bool AllowMissingData { get; private set; }
    public ProjectVersionRequirement(IComparable version, bool allowMissingData);
    [CompilerGeneratedAttribute]
public sealed virtual IComparable get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(IComparable value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowMissingData();
    [CompilerGeneratedAttribute]
private void set_AllowMissingData(bool value);
    public static bool op_Equality(ProjectVersionRequirement version1, ProjectVersionRequirement version2);
    public static bool op_Inequality(ProjectVersionRequirement version1, ProjectVersionRequirement version2);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectWriteLockAwaitable : ValueType {
    private ResourceAwaitable<ConfiguredProject, Project> awaitable;
    private IProjectLockReleaser helper;
    internal ProjectWriteLockAwaitable(ResourceAwaitable<ConfiguredProject, Project> awaitable, IProjectLockReleaser helper);
    public ProjectWriteLockAwaiter GetAwaiter();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectWriteLockAwaiter : ValueType {
    private ResourceAwaiter<ConfiguredProject, Project> awaiter;
    private IProjectLockReleaser helper;
    public bool IsCompleted { get; }
    internal ProjectWriteLockAwaiter(ResourceAwaiter<ConfiguredProject, Project> awaiter, IProjectLockReleaser helper);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public ProjectWriteLockReleaser GetResult();
    private void ThrowIfNotInitialized();
}
public class Microsoft.VisualStudio.ProjectSystem.ProjectWriteLockReleaser : ValueType {
    private ResourceReleaser<ConfiguredProject, Project> releaser;
    private IProjectLockReleaser helper;
    public ProjectCollection ProjectCollection { get; }
    public IImmutableSet`1<string> WritableFiles { get; }
    internal ResourceReleaser<ConfiguredProject, Project> LockReleaser { get; }
    internal ProjectWriteLockReleaser(ResourceReleaser<ConfiguredProject, Project> releaser, IProjectLockReleaser helper);
    public ProjectCollection get_ProjectCollection();
    public IImmutableSet`1<string> get_WritableFiles();
    internal ResourceReleaser<ConfiguredProject, Project> get_LockReleaser();
    public Task`1<Project> GetProjectAsync(ConfiguredProject configuredProject, CancellationToken cancellationToken);
    public Task`1<ProjectRootElement> GetProjectXmlAsync(string projectFile, CancellationToken cancellationToken);
    public Task CheckoutAsync(string file);
    public Task CheckoutAsync(IEnumerable`1<string> files);
    public Task RenameAsync(string oldFullPath, string newFullPath);
    public sealed virtual void Dispose();
    public Task ReleaseAsync();
    internal void SetAllResourcesToUnknownState();
    private void ThrowIfNotInitialized();
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor : object {
    private static string AdditionalOptionsPropertyName;
    private static string CommandLineTemplatePropertyName;
    private bool readPropertyValueInContext;
    private Dictionary`2<string, IProperty> props;
    private List`1<string> args;
    private IRule rule;
    private IProjectLockService projectLockService;
    public CommandLineConstructor(IRule rule, IProjectLockService projectLockService, bool readPropertyValueInContext);
    public static string GetStringsCommonPart(IList`1<string> stringList, string separator, Boolean& stringsDifferent);
    public IEvaluatedProperty GetAdditionalOptionsProperty();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<ConstructCommandLineAsync>d__10")]
public Task`1<string> ConstructCommandLineAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<GetAdditionalOptionsValueAsync>d__11")]
internal Task`1<string> GetAdditionalOptionsValueAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<GetPropertyValueInAppropriateFormAsync>d__12")]
private Task`1<object> GetPropertyValueInAppropriateFormAsync(IProperty property);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<AutoGenerateCommandLineAsync>d__13")]
private Task`1<string> AutoGenerateCommandLineAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<EmitArgumentSwitchAsync>d__14")]
private Task`1<string> EmitArgumentSwitchAsync(IList`1<IArgument> arguments);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<EmitPropertySwitchAsync>d__15")]
private Task`1<string> EmitPropertySwitchAsync(IProperty prop);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.CommandLineConstructor/<GetEvaluatedValueAsync>d__16")]
private Task`1<string> GetEvaluatedValueAsync(IEvaluatedProperty property);
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.DictionaryPropertyReader : PropertyReader {
    private IDictionary`2<string, string> evaluatedProperties;
    internal DictionaryPropertyReader(IDictionary`2<string, string> evaluatedProperties, PropertySerializer serializer);
    protected virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.ExpandStringPropertyReader : PropertyReader {
    private ConfiguredProject configuredProject;
    [CompilerGeneratedAttribute]
private IProjectLockService <ProjectLockService>k__BackingField;
    internal IProjectLockService ProjectLockService { get; private set; }
    internal ExpandStringPropertyReader(ConfiguredProject configuredProject, PropertySerializer serializer);
    [CompilerGeneratedAttribute]
internal IProjectLockService get_ProjectLockService();
    [CompilerGeneratedAttribute]
private void set_ProjectLockService(IProjectLockService value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.ExpandStringPropertyReader/<GetEvaluatedPropertyValueAsync>d__6")]
protected virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.Properties.ExportDynamicEnumValuesProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public string Category { get; private set; }
    public ExportDynamicEnumValuesProviderAttribute(string category);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(string value);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.Properties.ExportPropertyPageUIFactoryProviderAttribute : ExportAttribute {
    private static Char[] PageTemplatesSeparator;
    [CompilerGeneratedAttribute]
private bool <SupportsItemSpecificView>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsProjectSpecificView>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsPropertySheetSpecificView>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PageTemplates>k__BackingField;
    public bool SupportsItemSpecificView { get; public set; }
    public bool SupportsProjectSpecificView { get; public set; }
    public bool SupportsPropertySheetSpecificView { get; public set; }
    public String[] PageTemplates { get; public set; }
    public ExportPropertyPageUIFactoryProviderAttribute(string pageTemplates);
    private static ExportPropertyPageUIFactoryProviderAttribute();
    [CompilerGeneratedAttribute]
public bool get_SupportsItemSpecificView();
    [CompilerGeneratedAttribute]
public void set_SupportsItemSpecificView(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsProjectSpecificView();
    [CompilerGeneratedAttribute]
public void set_SupportsProjectSpecificView(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsPropertySheetSpecificView();
    [CompilerGeneratedAttribute]
public void set_SupportsPropertySheetSpecificView(bool value);
    [CompilerGeneratedAttribute]
public String[] get_PageTemplates();
    [CompilerGeneratedAttribute]
public void set_PageTemplates(String[] value);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("384")]
public class Microsoft.VisualStudio.ProjectSystem.Properties.ExportPropertyXamlRuleDefinitionAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <XamlResourceAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XamlResourceStreamName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    public string XamlResourceAssemblyName { get; private set; }
    public string XamlResourceStreamName { get; private set; }
    public string Context { get; private set; }
    public ExportPropertyXamlRuleDefinitionAttribute(string xamlResourceAssemblyName, string xamlResourceStreamName, string context);
    [CompilerGeneratedAttribute]
public string get_XamlResourceAssemblyName();
    [CompilerGeneratedAttribute]
private void set_XamlResourceAssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_XamlResourceStreamName();
    [CompilerGeneratedAttribute]
private void set_XamlResourceStreamName(string value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(string value);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.HelpInfo : object {
    [CompilerGeneratedAttribute]
private string <F1Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HelpContext>k__BackingField;
    public string F1Keyword { get; private set; }
    public string HelpUrl { get; private set; }
    public string HelpFile { get; private set; }
    public int HelpContext { get; private set; }
    public HelpInfo(string f1Keyword, string helpUrl, string helpFile, int helpContext);
    [CompilerGeneratedAttribute]
public string get_F1Keyword();
    [CompilerGeneratedAttribute]
private void set_F1Keyword(string value);
    [CompilerGeneratedAttribute]
public string get_HelpUrl();
    [CompilerGeneratedAttribute]
private void set_HelpUrl(string value);
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
private void set_HelpFile(string value);
    [CompilerGeneratedAttribute]
public int get_HelpContext();
    [CompilerGeneratedAttribute]
private void set_HelpContext(int value);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IAdditionalRuleDefinitions {
    public IImmutableDictionary`2<string, string> AdditionalRuleDefinitionsFromFiles { get; }
    public IImmutableDictionary`2<Rule, string> AdditionalRuleDefinitions { get; }
    public abstract virtual IImmutableDictionary`2<string, string> get_AdditionalRuleDefinitionsFromFiles();
    public abstract virtual IImmutableDictionary`2<Rule, string> get_AdditionalRuleDefinitions();
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IAdditionalRuleDefinitionsService {
    public IProjectVersionedValue`1<IAdditionalRuleDefinitions> AdditionalRuleDefinitions { get; }
    public abstract virtual IProjectVersionedValue`1<IAdditionalRuleDefinitions> get_AdditionalRuleDefinitions();
    public abstract virtual bool AddRuleDefinition(string path, string context);
    public abstract virtual bool AddRuleDefinition(Rule rule, string context);
    public abstract virtual bool RemoveRuleDefinition(string path);
    public abstract virtual bool RemoveRuleDefinition(Rule rule);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IArgument {
    public string PropertyName { get; }
    public bool IsRequired { get; }
    public string Separator { get; }
    public abstract virtual string get_PropertyName();
    public abstract virtual bool get_IsRequired();
    public abstract virtual string get_Separator();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IBoolProperty {
    public string ReverseSwitch { get; }
    public abstract virtual string get_ReverseSwitch();
    public abstract virtual Task`1<Nullable`1<bool>> GetValueAsBoolAsync();
    public abstract virtual Task SetValueAsBoolAsync(Nullable`1<bool> value);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.ICategory {
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string Subtype { get; }
    public string HelpString { get; }
    public object Schema { get; }
    public int Order { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Description();
    public abstract virtual string get_Subtype();
    public abstract virtual string get_HelpString();
    public abstract virtual object get_Schema();
    public abstract virtual int get_Order();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IClonePlatformFixup {
    public abstract virtual bool ShouldElementBeCloned(ProjectPropertyElement propertyElement, String& alternativeValue);
    public abstract virtual bool ShouldElementBeCloned(ProjectMetadataElement metadataElement, String& alternativeValue);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IClonePlatformFixupFactory {
    public abstract virtual IClonePlatformFixup CreateCloneFixup(string templatePlatform, string newPlatform);
}
internal interface Microsoft.VisualStudio.ProjectSystem.Properties.IContextSpecificProjectProperties {
    public abstract virtual Task`1<bool> IsDefinedInContextAsync(string propertyName);
    public abstract virtual Task`1<IProjectPropertySnapshot> GetPropertyValueInContextAsync(string propertyName, string groupLabel);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, string>>> ComputeAllPrecedingEvaluatedDefinitionValuesAsync(string propertyName, string groupName);
    public abstract virtual Task`1<IDictionary`2<string, KeyValuePair`2<string, string>>> ComputeBuildMacrosAsync(string propertyName, string groupName);
    public abstract virtual Task SetPropertyValueInContextAsync(string propertyName, string groupLabel, string unevaluatedPropertyValue, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    public abstract virtual Task DeletePropertyInContextAsync(string propertyName, IReadOnlyDictionary`2<string, string> dimensionalConditions);
}
internal interface Microsoft.VisualStudio.ProjectSystem.Properties.IContextUpdatingRule {
    public abstract virtual void OnItemIdentityChanged(string oldItemType, string oldItemName, string newItemType, string newItemName);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IDataSource {
    public string Persistence { get; }
    public string PersistedName { get; }
    public string SourceType { get; }
    public DefaultValueSourceLocation SourceOfDefaultValue { get; }
    public string Label { get; }
    public string ItemType { get; }
    public bool HasConfigurationCondition { get; }
    public abstract virtual string get_Persistence();
    public abstract virtual string get_PersistedName();
    public abstract virtual string get_SourceType();
    public abstract virtual DefaultValueSourceLocation get_SourceOfDefaultValue();
    public abstract virtual string get_Label();
    public abstract virtual string get_ItemType();
    public abstract virtual bool get_HasConfigurationCondition();
    public abstract virtual Task`1<string> GetPersistedFileAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IDynamicEnumValuesGenerator {
    [ObsoleteAttribute]
public bool AllowCustomValues { get; }
    public abstract virtual bool get_AllowCustomValues();
    public abstract virtual Task`1<ICollection`1<IEnumValue>> GetListedValuesAsync();
    public abstract virtual Task`1<IEnumValue> TryCreateEnumValueAsync(string userSuppliedValue);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IDynamicEnumValuesProvider {
    public abstract virtual Task`1<IDynamicEnumValuesGenerator> GetProviderAsync(IList`1<NameValuePair> options);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IEnumProperty {
    public abstract virtual Task`1<ReadOnlyCollection`1<IEnumValue>> GetAdmissibleValuesAsync();
    public abstract virtual Task`1<IEnumValue> GetValueAsIEnumValueAsync();
    public abstract virtual Task SetValueAsIEnumValueAsync(IEnumValue value);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IEnumValue {
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string HelpString { get; }
    public string Switch { get; }
    public string SwitchPrefix { get; }
    public bool IsDefault { get; }
    public IList`1<NameValuePair> Metadata { get; }
    public IList`1<IArgument> Arguments { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Description();
    public abstract virtual string get_HelpString();
    public abstract virtual string get_Switch();
    public abstract virtual string get_SwitchPrefix();
    public abstract virtual bool get_IsDefault();
    public abstract virtual IList`1<NameValuePair> get_Metadata();
    public abstract virtual IList`1<IArgument> get_Arguments();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IEvaluatedProperty {
    public string InheritingToken { get; }
    public abstract virtual string get_InheritingToken();
    public abstract virtual Task`1<string> GetUnevaluatedValueAtEndAsync();
    public abstract virtual Task`1<string> GetEvaluatedValueAtEndAsync();
    public abstract virtual Task`1<string> GetUnevaluatedValueAsync();
    public abstract virtual Task`1<string> GetEvaluatedValueAsync();
    public abstract virtual Task SetUnevaluatedValueAsync(string value);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, string>>> ComputeAllPrecedingEvaluatedDefinitionValuesAsync();
    public abstract virtual Task`1<IDictionary`2<string, KeyValuePair`2<string, string>>> ComputeBuildMacrosAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IIntProperty {
    public Nullable`1<int> MinValue { get; }
    public Nullable`1<int> MaxValue { get; }
    public abstract virtual Nullable`1<int> get_MinValue();
    public abstract virtual Nullable`1<int> get_MaxValue();
    public abstract virtual Task`1<Nullable`1<int>> GetValueAsIntAsync();
    public abstract virtual Task SetValueAsIntAsync(Nullable`1<int> value);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectCatalogSnapshot {
    public IProjectSnapshot Project { get; }
    public IImmutableDictionary`2<string, IPropertyPagesCatalog> NamedCatalogs { get; }
    public IProjectItemSchema ItemSchema { get; }
    public abstract virtual IProjectSnapshot get_Project();
    public abstract virtual IImmutableDictionary`2<string, IPropertyPagesCatalog> get_NamedCatalogs();
    public abstract virtual IProjectItemSchema get_ItemSchema();
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectInstancePropertiesProvider {
    public abstract virtual IProjectProperties GetCommonProperties(ProjectInstance projectInstance);
    public abstract virtual IProjectProperties GetItemTypeProperties(ProjectInstance projectInstance, string itemType);
    public abstract virtual IProjectProperties GetItemProperties(ProjectInstance projectInstance, string itemType, string itemName);
    public abstract virtual IProjectProperties GetItemProperties(ITaskItem taskItem);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectInstancePropertiesProvider2 {
    public abstract virtual string GetEvaluatedPropertyValue(ITaskItem taskItem, string propertyName, Rule rule);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties {
    public IProjectPropertiesContext Context { get; }
    public string FileFullPath { get; }
    public PropertyKind PropertyKind { get; }
    public abstract virtual IProjectPropertiesContext get_Context();
    public abstract virtual string get_FileFullPath();
    public abstract virtual PropertyKind get_PropertyKind();
    public abstract virtual Task`1<IEnumerable`1<string>> GetPropertyNamesAsync();
    public abstract virtual Task`1<IEnumerable`1<string>> GetDirectPropertyNamesAsync();
    public abstract virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
    public abstract virtual Task`1<string> GetUnevaluatedPropertyValueAsync(string propertyName);
    public abstract virtual Task SetPropertyValueAsync(string propertyName, string unevaluatedPropertyValue, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    public abstract virtual Task DeletePropertyAsync(string propertyName, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    public abstract virtual Task`1<bool> IsValueInheritedAsync(string propertyName);
    public abstract virtual Task DeleteDirectPropertiesAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesContext {
    public bool IsProjectFile { get; }
    public string File { get; }
    public string ItemType { get; }
    public string ItemName { get; }
    public abstract virtual bool get_IsProjectFile();
    public abstract virtual string get_File();
    public abstract virtual string get_ItemType();
    public abstract virtual string get_ItemName();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesPersistenceInformationProvider {
    public abstract virtual bool TryGetPersistenceProperties(string propertyName, String& persistencePropertyName, IEnumerable`1& additionalPersistencePropertyNames);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertiesProvider {
    public string DefaultProjectPath { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectPropertyChanging(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectPropertyChanging(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectPropertyChangedOnWriter(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectPropertyChangedOnWriter(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectPropertyChanged(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectPropertyChanged(AsyncEventHandler`1<ProjectPropertyChangedEventArgs> value);
    public abstract virtual string get_DefaultProjectPath();
    public abstract virtual IProjectProperties GetCommonProperties();
    public abstract virtual IProjectProperties GetItemTypeProperties(string itemType);
    public abstract virtual IProjectProperties GetItemProperties(string itemType, string item);
    public abstract virtual IProjectProperties GetProperties(string file, string itemType, string item);
}
internal interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectPropertySnapshot {
    public string PropertyName { get; }
    public string EvaluatedValue { get; }
    public string UnevaluatedValue { get; }
    public bool IsDefinedInContext { get; }
    public abstract virtual string get_PropertyName();
    public abstract virtual string get_EvaluatedValue();
    public abstract virtual string get_UnevaluatedValue();
    public abstract virtual bool get_IsDefinedInContext();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectRuleSnapshot {
    public string RuleName { get; }
    public IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> Items { get; }
    public IImmutableDictionary`2<string, string> Properties { get; }
    public abstract virtual string get_RuleName();
    public abstract virtual IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> get_Items();
    public abstract virtual IImmutableDictionary`2<string, string> get_Properties();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProjectRuleSnapshotEvaluationStatus {
    public bool EvaluationSucceeded { get; }
    public abstract virtual bool get_EvaluationSucceeded();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProperty {
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string F1Keyword { get; }
    public string HelpUrl { get; }
    public string HelpFile { get; }
    public int HelpContext { get; }
    public string Category { get; }
    public string Subcategory { get; }
    public bool IsReadOnly { get; }
    public string Switch { get; }
    public string SwitchPrefix { get; }
    public string Separator { get; }
    public bool Visible { get; }
    public bool IncludeInCommandLine { get; }
    public string DefaultValue { get; }
    public IList`1<NameValuePair> Metadata { get; }
    public IList`1<IArgument> Arguments { get; }
    public ReadOnlyCollection`1<IValueEditor> ValueEditors { get; }
    public IRule ContainingRule { get; }
    public IDataSource DataSource { get; }
    public IProjectPropertiesContext Context { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Description();
    public abstract virtual string get_F1Keyword();
    public abstract virtual string get_HelpUrl();
    public abstract virtual string get_HelpFile();
    public abstract virtual int get_HelpContext();
    public abstract virtual string get_Category();
    public abstract virtual string get_Subcategory();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual string get_Switch();
    public abstract virtual string get_SwitchPrefix();
    public abstract virtual string get_Separator();
    public abstract virtual bool get_Visible();
    public abstract virtual bool get_IncludeInCommandLine();
    public abstract virtual string get_DefaultValue();
    public abstract virtual IList`1<NameValuePair> get_Metadata();
    public abstract virtual IList`1<IArgument> get_Arguments();
    public abstract virtual ReadOnlyCollection`1<IValueEditor> get_ValueEditors();
    public abstract virtual IRule get_ContainingRule();
    public abstract virtual IDataSource get_DataSource();
    public abstract virtual IProjectPropertiesContext get_Context();
    public abstract virtual Task`1<object> GetValueAsync();
    public abstract virtual Task SetValueAsync(object value);
    public abstract virtual Task`1<string> GetDisplayValueAsync();
    public abstract virtual Task`1<bool> IsDefinedInContextAsync();
    public abstract virtual Task`1<IsValidValueResult> IsValidValueAsync(object userSuppliedValue);
    public abstract virtual Task DeleteAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IProperty2 {
    public Type PropertyType { get; }
    public abstract virtual Type get_PropertyType();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyGroup {
    public ICategory Category { get; }
    public IList`1<IProperty> Properties { get; }
    public abstract virtual ICategory get_Category();
    public abstract virtual IList`1<IProperty> get_Properties();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyInternal {
    public bool CanRetrieveValueFromProjectInstance { get; }
    public abstract virtual bool get_CanRetrieveValueFromProjectInstance();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalog {
    public abstract virtual IReadOnlyCollection`1<string> GetPropertyPagesSchemas();
    public abstract virtual IReadOnlyCollection`1<string> GetProjectLevelPropertyPagesSchemas();
    public abstract virtual IReadOnlyCollection`1<string> GetPropertyPagesSchemas(string itemType);
    public abstract virtual IReadOnlyCollection`1<string> GetPropertyPagesSchemas(IEnumerable`1<string> paths);
    public abstract virtual Rule GetSchema(string schemaName);
    public abstract virtual IRule BindToContext(string schemaName, string file, string itemType, string itemName);
    public abstract virtual IRule BindToContext(string schemaName, IProjectPropertiesContext context);
    public abstract virtual IRule BindToContext(string schemaName, ProjectInstance projectInstance, string itemType, string itemName);
    public abstract virtual IRule BindToContext(string schemaName, ProjectInstance projectInstance, ITaskItem taskItem);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesCatalogProvider {
    public abstract virtual Task`1<IPropertyPagesCatalog> GetCatalogAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> GetCatalogsAsync(CancellationToken cancellationToken);
    public abstract virtual IPropertyPagesCatalog GetMemoryOnlyCatalog(string context);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesDataModelProvider {
    public abstract virtual IRule GetRule(Rule schema, string file, string itemType, string itemName);
    public abstract virtual IRule GetRule(Rule schema, ProjectInstance projectInstance, string itemType, string itemName);
    public abstract virtual IRule GetRule(Rule schema, ProjectInstance projectInstance, ITaskItem taskItem);
}
internal interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPagesDataModelProviderInternal {
    public abstract virtual Lazy`2<IProjectInstancePropertiesProvider, IMultipleNamedExportMetadataView> GetProjectInstanceDataSourceProvider(string name);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIFactory {
    public Guid PageId { get; }
    public int GroupOrder { get; }
    public int PageOrder { get; }
    public string Name { get; }
    public string GroupName { get; }
    public string DisplayName { get; }
    public string DisplayGroupName { get; }
    public abstract virtual Guid get_PageId();
    public abstract virtual int get_GroupOrder();
    public abstract virtual int get_PageOrder();
    public abstract virtual string get_Name();
    public abstract virtual string get_GroupName();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_DisplayGroupName();
    public abstract virtual object CreateControl(IPropertyPageUIWindow hostWindow);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIFactoryProvider {
    public abstract virtual ICollection`1<Guid> GetPropertyPageUIFactories(ICollection`1<IRule> rules, ICollection`1<string> itemTypes);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIFactoryProviderMetadataView {
    [DefaultValueAttribute("False")]
public bool SupportsItemSpecificView { get; }
    [DefaultValueAttribute("False")]
public bool SupportsProjectSpecificView { get; }
    [DefaultValueAttribute("False")]
public bool SupportsPropertySheetSpecificView { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public String[] PageTemplates { get; }
    public abstract virtual bool get_SupportsItemSpecificView();
    public abstract virtual bool get_SupportsProjectSpecificView();
    public abstract virtual bool get_SupportsPropertySheetSpecificView();
    public abstract virtual String[] get_PageTemplates();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIFactoryService {
    public abstract virtual void AddFactory(IPropertyPageUIFactory factory);
    public abstract virtual IPropertyPageUIFactory GetFactoryFromId(Guid id);
    public abstract virtual Lazy`1<IPropertyPageUIValueEditor> GetPropertyEditor(string editorName);
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIValueEditor {
    public abstract virtual Task`1<object> EditValueAsync(IServiceProvider serviceProvider, IProperty ruleProperty, object currentValue);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertyPageUIWindow {
    public abstract virtual void MarkDirty();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertySheet {
    public string UnevaluatedPath { get; }
    public bool IsSystemPropertySheet { get; }
    public abstract virtual string get_UnevaluatedPath();
    public abstract virtual bool get_IsSystemPropertySheet();
    public abstract virtual Task`1<bool> HasUnsavedChangesAsync();
    public abstract virtual Task`1<string> GetEvaluatedFullPathAsync();
    public abstract virtual Task`1<IEnumerable`1<IPropertySheet>> GetImportedSystemPropertySheetsAsync();
    public abstract virtual Task`1<IEnumerable`1<IPropertySheet>> GetImportedUserPropertySheetsAsync();
    public abstract virtual Task`1<IEnumerable`1<IPropertySheet>> GetImportedPropertySheetsAsync();
    public abstract virtual Task AddPropertySheetAsync(string relativeOrFullPath);
    public abstract virtual Task AddPropertySheetAsync(string relativeOrFullPath, string condition);
    public abstract virtual Task AddPropertySheetAsync(string relativeOrFullPath, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs);
    public abstract virtual Task AddPropertySheetAsync(string relativeOrFullPath, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs, string condition);
    public abstract virtual Task MoveBeforePropertySheetAsync(string relativeOrFullPath, string relativeOrFullPathOfReferenceImport);
    public abstract virtual Task MoveBeforePropertySheetAsync(string relativeOrFullPath, string relativeOrFullPathOfReferenceImport, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs);
    public abstract virtual Task MoveAfterPropertySheetAsync(string relativeOrFullPath, string relativeOrFullPathOfReferenceImport);
    public abstract virtual Task MoveAfterPropertySheetAsync(string relativeOrFullPath, string relativeOrFullPathOfReferenceImport, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs);
    public abstract virtual Task`1<bool> RemovePropertySheetAsync(string relativeOrFullPath);
    public abstract virtual Task`1<bool> RemovePropertySheetAsync(string relativeOrFullPath, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs);
    public abstract virtual Task SaveAsync();
}
[ProjectSystemContractAttribute("2", "3")]
internal interface Microsoft.VisualStudio.ProjectSystem.Properties.IPropertySheetService {
    public abstract virtual IPropertySheet GetPropertySheet(string unevaluatedFullPath);
    public abstract virtual Task`1<IPropertySheet> GetPropertySheetByLabelAsync(string projectToSearch, string label, IReadOnlyDictionary`2<string, string> dimensionNameValuePairs);
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IRule {
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string HelpString { get; }
    public string PageTemplate { get; }
    public string SwitchPrefix { get; }
    public string Separator { get; }
    public IReadOnlyList`1<ICategory> Categories { get; }
    public Rule Schema { get; }
    public int Order { get; }
    public string File { get; }
    public string ItemType { get; }
    public string ItemName { get; }
    public IReadOnlyList`1<IPropertyGroup> PropertyGroups { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IProjectPropertiesContext Context { get; }
    public bool PropertyPagesHidden { get; }
    public IPropertyGroup Item { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Description();
    public abstract virtual string get_HelpString();
    public abstract virtual string get_PageTemplate();
    public abstract virtual string get_SwitchPrefix();
    public abstract virtual string get_Separator();
    public abstract virtual IReadOnlyList`1<ICategory> get_Categories();
    public abstract virtual Rule get_Schema();
    public abstract virtual int get_Order();
    public abstract virtual string get_File();
    public abstract virtual string get_ItemType();
    public abstract virtual string get_ItemName();
    public abstract virtual IReadOnlyList`1<IPropertyGroup> get_PropertyGroups();
    public abstract virtual IEnumerable`1<IProperty> get_Properties();
    public abstract virtual IProjectPropertiesContext get_Context();
    public abstract virtual bool get_PropertyPagesHidden();
    public abstract virtual IPropertyGroup get_Item(string categoryName);
    public abstract virtual IProperty GetProperty(string propertyName);
    public abstract virtual Task`1<string> GetPropertyValueAsync(string propertyName);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IRuleAwareProjectProperties {
    public abstract virtual void SetRuleContext(Rule rule);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IRuleFactory {
    public abstract virtual IRule CreateResolvedReferencePageRule(Rule schema, IProjectPropertiesContext unresolvedContext, string resolvedItemName, IImmutableDictionary`2<string, string> resolvedItemMetadata);
    public abstract virtual IRule ReplicateRule(IRule ruleToReplicate, IPropertyPagesCatalog catalog);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IStringListProperty {
    public string Subtype { get; }
    public string CommandLineValueSeparator { get; }
    public string RendererValueSeparator { get; }
    public abstract virtual string get_Subtype();
    public abstract virtual string get_CommandLineValueSeparator();
    public abstract virtual string get_RendererValueSeparator();
    public abstract virtual Task`1<ReadOnlyCollection`1<string>> GetValueAsStringCollectionAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IStringProperty {
    public string Subtype { get; }
    public abstract virtual string get_Subtype();
    public abstract virtual Task`1<string> GetValueAsStringAsync();
    public abstract virtual Task SetValueAsStringAsync(string value);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.IsValidValueResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public bool IsValid { get; public set; }
    public string ErrorMessage { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
}
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IValueEditor {
    public string EditorType { get; }
    public string DisplayName { get; }
    public IList`1<NameValuePair> Metadata { get; }
    public abstract virtual string get_EditorType();
    public abstract virtual string get_DisplayName();
    public abstract virtual IList`1<NameValuePair> get_Metadata();
}
[GuidAttribute("19893E06-22DA-4A7D-AD25-DFED1040903B")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IVsBrowseObjectContext {
    public UnconfiguredProject UnconfiguredProject { get; }
    public ConfiguredProject ConfiguredProject { get; }
    public IPropertySheet PropertySheet { get; }
    public IProjectPropertiesContext ProjectPropertiesContext { get; }
    public abstract virtual UnconfiguredProject get_UnconfiguredProject();
    public abstract virtual ConfiguredProject get_ConfiguredProject();
    public abstract virtual IPropertySheet get_PropertySheet();
    public abstract virtual IProjectPropertiesContext get_ProjectPropertiesContext();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.Properties.IVsBrowseObjectContextProvider {
    public abstract virtual IVsBrowseObjectContext GetContextObject(object value);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.PageArgument : object {
    private Argument argument;
    public string PropertyName { get; }
    public bool IsRequired { get; }
    public string Separator { get; }
    public PageArgument(Argument argument);
    public sealed virtual string get_PropertyName();
    public sealed virtual bool get_IsRequired();
    public sealed virtual string get_Separator();
    internal static List`1<IArgument> ConvertToIArgument(IList`1<Argument> arguments);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.PageEnumValue : object {
    private EnumValue enumValue;
    private Lazy`1<List`1<IArgument>> pageArguments;
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string HelpString { get; }
    public string Switch { get; }
    public string SwitchPrefix { get; }
    public bool IsDefault { get; }
    public IList`1<NameValuePair> Metadata { get; }
    public IList`1<IArgument> Arguments { get; }
    public PageEnumValue(EnumValue enumValue);
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_Description();
    public sealed virtual string get_HelpString();
    public sealed virtual string get_Switch();
    public sealed virtual string get_SwitchPrefix();
    public sealed virtual bool get_IsDefault();
    public sealed virtual IList`1<NameValuePair> get_Metadata();
    public sealed virtual IList`1<IArgument> get_Arguments();
    public virtual string ToString();
    internal static List`1<IEnumValue> ConvertToIEnumValue(IList`1<EnumValue> enumValues);
    [CompilerGeneratedAttribute]
private List`1<IArgument> <.ctor>b__2_0();
}
[DebuggerDisplayAttribute("<{ItemType} Include={ItemName} /> ({File})")]
public abstract class Microsoft.VisualStudio.ProjectSystem.Properties.ProjectPropertiesContext : object {
    private Nullable`1<int> hashCode;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemName>k__BackingField;
    public bool IsProjectFile { get; }
    public string File { get; }
    public string ItemType { get; }
    public string ItemName { get; }
    protected ProjectPropertiesContext(string itemType, string itemName);
    public abstract virtual bool get_IsProjectFile();
    public abstract virtual string get_File();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ItemType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ItemName();
    public static ProjectPropertiesContext GetContext(UnconfiguredProject project, string itemType, string itemName);
    public static ProjectPropertiesContext GetContext(UnconfiguredProject project, string file, string itemType, string itemName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.ProjectPropertiesContextEqualityComparer : object {
    private static IEqualityComparer`1<IProjectPropertiesContext> DefaultInstance;
    private static IEqualityComparer`1<IProjectPropertiesContext> IgnorePropertySheetInstance;
    private static IEqualityComparer`1<IProjectPropertiesContext> CaseSensitiveInstance;
    private bool ignoreFile;
    private StringComparer itemNameComparer;
    public static IEqualityComparer`1<IProjectPropertiesContext> Default { get; }
    public static IEqualityComparer`1<IProjectPropertiesContext> IgnorePropertySheet { get; }
    public static IEqualityComparer`1<IProjectPropertiesContext> CaseSensitiveItemNames { get; }
    private ProjectPropertiesContextEqualityComparer(bool ignoreFile, bool caseSensitive);
    private static ProjectPropertiesContextEqualityComparer();
    public static IEqualityComparer`1<IProjectPropertiesContext> get_Default();
    public static IEqualityComparer`1<IProjectPropertiesContext> get_IgnorePropertySheet();
    public static IEqualityComparer`1<IProjectPropertiesContext> get_CaseSensitiveItemNames();
    public sealed virtual bool Equals(IProjectPropertiesContext x, IProjectPropertiesContext y);
    public sealed virtual int GetHashCode(IProjectPropertiesContext value);
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.ProjectPropertiesReader : PropertyReader {
    private IProjectProperties properties;
    internal ProjectPropertiesReader(IProjectProperties properties, PropertySerializer serializer);
    protected virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.ProjectPropertyChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertySheet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    public string PropertyName { get; private set; }
    public string PropertySheet { get; private set; }
    public string ItemInclude { get; private set; }
    public string ItemType { get; private set; }
    public bool PropertySheetEvent { get; }
    public bool ProjectPropertyEvent { get; }
    public bool ItemPropertyEvent { get; }
    public bool ItemDefinitionPropertyEvent { get; }
    public ProjectPropertyChangedEventArgs(string propertySheet, string propertyName);
    public ProjectPropertyChangedEventArgs(string propertySheet, string propertyName, string itemType);
    public ProjectPropertyChangedEventArgs(string propertySheet, string propertyName, string itemInclude, string itemType);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
private void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_PropertySheet();
    [CompilerGeneratedAttribute]
private void set_PropertySheet(string value);
    [CompilerGeneratedAttribute]
public string get_ItemInclude();
    [CompilerGeneratedAttribute]
private void set_ItemInclude(string value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
private void set_ItemType(string value);
    public bool get_PropertySheetEvent();
    public bool get_ProjectPropertyEvent();
    public bool get_ItemPropertyEvent();
    public bool get_ItemDefinitionPropertyEvent();
}
public enum Microsoft.VisualStudio.ProjectSystem.Properties.PropertyKind : Enum {
    public int value__;
    public static PropertyKind PropertyGroup;
    public static PropertyKind ItemDefinitionGroup;
    public static PropertyKind ItemGroup;
}
public static class Microsoft.VisualStudio.ProjectSystem.Properties.PropertyPageContexts : object {
    public static string File;
    public static string Project;
    public static string PropertySheet;
    public static string ProjectSubscriptionService;
    public static string Invisible;
    public static string BrowseObject;
    public static string ConfiguredBrowseObject;
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Properties.PropertyPageUIFactoryBase : object {
    private Guid pageId;
    private string pageName;
    private string displayPageName;
    private int pageOrder;
    private string groupName;
    private string displayGroupName;
    private int groupOrder;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectService <ProjectService>k__BackingField;
    [CompilerGeneratedAttribute]
private IVsShellServices <ShellServices>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectThreadingService <ThreadingService>k__BackingField;
    public Guid PageId { get; }
    public int PageOrder { get; }
    public int GroupOrder { get; }
    public string Name { get; }
    public string GroupName { get; }
    public string DisplayName { get; }
    public string DisplayGroupName { get; }
    public IServiceProvider ServiceProvider { get; public set; }
    public IProjectService ProjectService { get; public set; }
    internal IVsShellServices ShellServices { get; internal set; }
    internal IProjectThreadingService ThreadingService { get; internal set; }
    protected PropertyPageUIFactoryBase(Guid pageId, string pageName, string displayPageName, int pageOrder);
    protected PropertyPageUIFactoryBase(Guid pageId, string pageName, string displayPageName, int pageOrder, string groupName, string displayGroupName, int groupOrder);
    public sealed virtual Guid get_PageId();
    public sealed virtual int get_PageOrder();
    public sealed virtual int get_GroupOrder();
    public sealed virtual string get_Name();
    public sealed virtual string get_GroupName();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_DisplayGroupName();
    [CompilerGeneratedAttribute]
public IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceProvider(IServiceProvider value);
    [CompilerGeneratedAttribute]
public IProjectService get_ProjectService();
    [CompilerGeneratedAttribute]
public void set_ProjectService(IProjectService value);
    [CompilerGeneratedAttribute]
internal IVsShellServices get_ShellServices();
    [CompilerGeneratedAttribute]
internal void set_ShellServices(IVsShellServices value);
    [CompilerGeneratedAttribute]
internal IProjectThreadingService get_ThreadingService();
    [CompilerGeneratedAttribute]
internal void set_ThreadingService(IProjectThreadingService value);
    public abstract virtual object CreateControl(IPropertyPageUIWindow hostWindow);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Properties.PropertyReader : object {
    private PropertySerializer serializer;
    protected PropertyReader(PropertySerializer serializer);
    public static PropertyReader Create(IDictionary`2<string, string> evaluatedProperties, PropertySerializer serializer);
    public static PropertyReader Create(IProjectProperties properties, PropertySerializer serializer);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.PropertyReader/<GetValueAsync>d__4`1")]
public virtual Task`1<T> GetValueAsync(string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.PropertyReader/<GetValueAsync>d__5`1")]
public virtual Task`1<T> GetValueAsync(string propertyName, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.PropertyReader/<GetRequiredValueAsync>d__6`1")]
public virtual Task`1<T> GetRequiredValueAsync(string propertyName);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.Properties.PropertyReader/<GetValueAsPathAsync>d__7")]
public virtual Task`1<string> GetValueAsPathAsync(string propertyName, bool shouldBeQuoted, bool required);
    internal static PropertyReader Create(ConfiguredProject configuredProject, PropertySerializer serializer);
    protected abstract virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.PropertySerializer : object {
    private Dictionary`2<Type, object> converters;
    private bool disallowNewMappings;
    [CompilerGeneratedAttribute]
private static PropertySerializer <SimpleTypes>k__BackingField;
    public static PropertySerializer SimpleTypes { get; }
    public PropertySerializer(PropertySerializer copyFrom);
    private static PropertySerializer();
    [CompilerGeneratedAttribute]
public static PropertySerializer get_SimpleTypes();
    public PropertySerializer AsReadOnly();
    public string ToString(T value);
    public T ToValue(string value);
    public T ToValue(string value, T defaultValue);
    public void AddMapping(IStrongTypeAndStringMapping`1<T> values);
    private static PropertySerializer InitializeSimpleTypes();
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.ReadOnlyProjectPropertiesWrapper : object {
    [DebuggerBrowsableAttribute("3")]
private IProjectProperties properties;
    public PropertyKind PropertyKind { get; }
    public string FileFullPath { get; }
    public IProjectPropertiesContext Context { get; }
    public ReadOnlyProjectPropertiesWrapper(IProjectProperties properties);
    public sealed virtual PropertyKind get_PropertyKind();
    public sealed virtual string get_FileFullPath();
    public sealed virtual IProjectPropertiesContext get_Context();
    public Task`1<string> GetPropertyValueAsync(string propertyName);
    public sealed virtual Task`1<IEnumerable`1<string>> GetPropertyNamesAsync();
    public sealed virtual Task`1<IEnumerable`1<string>> GetDirectPropertyNamesAsync();
    [DebuggerStepThroughAttribute]
private sealed virtual override Task`1<string> Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.GetEvaluatedPropertyValueAsync(string propertyName);
    [DebuggerStepThroughAttribute]
private sealed virtual override Task`1<string> Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.GetUnevaluatedPropertyValueAsync(string propertyName);
    private sealed virtual override Task Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.SetPropertyValueAsync(string propertyName, string unevaluatedPropertyValue, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    private sealed virtual override Task Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.DeletePropertyAsync(string propertyName, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    [DebuggerStepThroughAttribute]
private sealed virtual override Task`1<bool> Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.IsValueInheritedAsync(string propertyName);
    private sealed virtual override Task Microsoft.VisualStudio.ProjectSystem.Properties.IProjectProperties.DeleteDirectPropertiesAsync();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Properties.RuleDataflowLinkOptions : DataflowLinkOptions {
    public IImmutableSet`1<string> RuleNames { get; public set; }
    public abstract virtual IImmutableSet`1<string> get_RuleNames();
    public abstract virtual void set_RuleNames(IImmutableSet`1<string> value);
    public abstract virtual object Clone();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.Properties.RuleExtensions : object {
    [ExtensionAttribute]
internal static bool TryGetBrowseObjectPropertiesSnapshot(IRule browseObject, ConfiguredProject configuredProject, bool requiredToMatchProjectVersion, IRule& browseObjectSnapshotProperties, IComparable& projectVersion);
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.RuleNameComparer : object {
    private static RuleNameComparer ruleComparer;
    internal static RuleNameComparer Default { get; }
    private static RuleNameComparer();
    internal static RuleNameComparer get_Default();
    public sealed virtual bool Equals(Rule x, Rule y);
    public sealed virtual int GetHashCode(Rule obj);
}
public class Microsoft.VisualStudio.ProjectSystem.Properties.StandardRuleDataflowLinkOptions : RuleDataflowLinkOptions {
    private IImmutableSet`1<string> ruleNames;
    public IImmutableSet`1<string> RuleNames { get; public set; }
    public virtual IImmutableSet`1<string> get_RuleNames();
    public virtual void set_RuleNames(IImmutableSet`1<string> value);
    public virtual object Clone();
}
public abstract class Microsoft.VisualStudio.ProjectSystem.Properties.StronglyTypedPropertyAccess : object {
    private AsyncLazy`1 modreq(System.Runtime.CompilerServices.IsVolatile) namedCatalogs;
    [CompilerGeneratedAttribute]
private ConfiguredProject <ConfiguredProject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemName>k__BackingField;
    protected ConfiguredProject ConfiguredProject { get; private set; }
    protected string File { get; private set; }
    protected string ItemType { get; private set; }
    protected string ItemName { get; private set; }
    protected StronglyTypedPropertyAccess(ConfiguredProject configuredProject);
    protected StronglyTypedPropertyAccess(ConfiguredProject configuredProject, string file, string itemType, string itemName);
    protected StronglyTypedPropertyAccess(ConfiguredProject configuredProject, IProjectPropertiesContext projectPropertiesContext);
    protected StronglyTypedPropertyAccess(ConfiguredProject configuredProject, UnconfiguredProject unconfiguredProject);
    [CompilerGeneratedAttribute]
protected ConfiguredProject get_ConfiguredProject();
    [CompilerGeneratedAttribute]
private void set_ConfiguredProject(ConfiguredProject value);
    [CompilerGeneratedAttribute]
protected string get_File();
    [CompilerGeneratedAttribute]
private void set_File(string value);
    [CompilerGeneratedAttribute]
protected string get_ItemType();
    [CompilerGeneratedAttribute]
private void set_ItemType(string value);
    [CompilerGeneratedAttribute]
protected string get_ItemName();
    [CompilerGeneratedAttribute]
private void set_ItemName(string value);
    protected Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> GetNamedCatalogsAsync();
    protected bool TryGetCurrentCatalogSnapshot(IProjectVersionedValue`1& snapshot);
    protected IRule GetSnapshotRule(IProjectCatalogSnapshot projectCatalog, string context, string schemaName);
}
internal class Microsoft.VisualStudio.ProjectSystem.Properties.TaskItemProperties : object {
    private bool isReadOnly;
    [CompilerGeneratedAttribute]
private ITaskItem <TaskItem>k__BackingField;
    public PropertyKind PropertyKind { get; }
    public IProjectPropertiesContext Context { get; }
    public string FileFullPath { get; }
    protected ITaskItem TaskItem { get; private set; }
    internal TaskItemProperties(ITaskItem taskItem, bool isReadOnly);
    public sealed virtual PropertyKind get_PropertyKind();
    public sealed virtual IProjectPropertiesContext get_Context();
    public sealed virtual string get_FileFullPath();
    [CompilerGeneratedAttribute]
protected ITaskItem get_TaskItem();
    [CompilerGeneratedAttribute]
private void set_TaskItem(ITaskItem value);
    public sealed virtual Task`1<IEnumerable`1<string>> GetPropertyNamesAsync();
    public sealed virtual Task`1<IEnumerable`1<string>> GetDirectPropertyNamesAsync();
    public virtual Task`1<string> GetEvaluatedPropertyValueAsync(string propertyName);
    public sealed virtual Task`1<string> GetUnevaluatedPropertyValueAsync(string propertyName);
    public sealed virtual Task SetPropertyValueAsync(string propertyName, string unevaluatedPropertyValue, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    public sealed virtual Task DeletePropertyAsync(string propertyName, IReadOnlyDictionary`2<string, string> dimensionalConditions);
    public sealed virtual Task`1<bool> IsValueInheritedAsync(string propertyName);
    public sealed virtual Task DeleteDirectPropertiesAsync();
}
internal class Microsoft.VisualStudio.ProjectSystem.ReadOnlyRealCollection`1 : object {
    private ICollection`1<T> wrappedCollection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal ReadOnlyRealCollection`1(ICollection`1<T> wrappedCollection);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.VisualStudio.ProjectSystem.ReadOnlySet`1 : object {
    private ISet`1<T> set;
    public int Count { get; }
    public ReadOnlySet`1(ISet`1<T> set);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T t);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.VisualStudio.ProjectSystem.References.AddReferenceResult`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Added>k__BackingField;
    public T Reference { get; private set; }
    public bool Added { get; private set; }
    public AddReferenceResult`1(T reference, bool added);
    [CompilerGeneratedAttribute]
public T get_Reference();
    [CompilerGeneratedAttribute]
private void set_Reference(T value);
    [CompilerGeneratedAttribute]
public bool get_Added();
    [CompilerGeneratedAttribute]
private void set_Added(bool value);
    public static bool op_Equality(AddReferenceResult`1<T> result1, AddReferenceResult`1<T> result2);
    public static bool op_Inequality(AddReferenceResult`1<T> result1, AddReferenceResult`1<T> result2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.ProjectSystem.References.CanAddProjectReferencesResult : ValueType {
    [CompilerGeneratedAttribute]
private IImmutableDictionary`2<object, SupportedCheckResult> <IndividualResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public IImmutableDictionary`2<object, SupportedCheckResult> IndividualResults { get; private set; }
    public string ErrorMessage { get; private set; }
    public CanAddProjectReferencesResult(IImmutableDictionary`2<object, SupportedCheckResult> individualResults, string errorMessage);
    [CompilerGeneratedAttribute]
public IImmutableDictionary`2<object, SupportedCheckResult> get_IndividualResults();
    [CompilerGeneratedAttribute]
private void set_IndividualResults(IImmutableDictionary`2<object, SupportedCheckResult> value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ErrorMessage(string value);
}
public class Microsoft.VisualStudio.ProjectSystem.References.ComReferenceResolveResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ClassId>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocaleId>k__BackingField;
    public bool Success { get; private set; }
    public Guid ClassId { get; private set; }
    public Version Version { get; private set; }
    public int LocaleId { get; private set; }
    public ComReferenceResolveResult(bool success, Guid classId, Version version, int localeId);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    [CompilerGeneratedAttribute]
public Guid get_ClassId();
    [CompilerGeneratedAttribute]
private void set_ClassId(Guid value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public int get_LocaleId();
    [CompilerGeneratedAttribute]
private void set_LocaleId(int value);
    public static bool op_Equality(ComReferenceResolveResult result1, ComReferenceResolveResult result2);
    public static bool op_Inequality(ComReferenceResolveResult result1, ComReferenceResolveResult result2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IAssemblyReference {
    public abstract virtual Task`1<bool> GetSpecificVersionAsync();
    public abstract virtual Task`1<bool> IsWinMDFileAsync();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IAssemblyReferencesService {
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedAssemblyReference>> AddAsync(AssemblyName assemblyName, string assemblyPath);
    public abstract virtual Task`1<IUnresolvedAssemblyReference> GetUnresolvedReferenceAsync(AssemblyName assemblyName, string assemblyPath);
    public abstract virtual Task`1<IAssemblyReference> GetResolvedReferenceAsync(AssemblyName assemblyName, string assemblyPath);
    public abstract virtual Task`1<bool> CanResolveAsync(AssemblyName assemblyName, string assemblyPath);
    public abstract virtual Task`1<bool> ContainsAsync(AssemblyName assemblyName, string assemblyPath);
    public abstract virtual Task RemoveAsync(AssemblyName assemblyName, string assemblyPath);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IBuildDependencyCircularProjectReferenceDetectionService {
    public abstract virtual Task`1<bool> WouldReferenceToProjectCompleteCycleAsync(string projectPath);
    public abstract virtual Task`1<bool> WouldReferenceToProjectCompleteCycleAsync(Guid projectIdentifier);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IBuildDependencyProjectReference {
    public abstract virtual Task`1<bool> GetLinkLibraryDependencyAsync();
    public abstract virtual Task`1<bool> GetUseLibraryDependencyInputsAsync();
    public abstract virtual Task`1<Guid> GetSolutionIdentifierForReferencedProjectAsync();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IBuildDependencyProjectReferencesService {
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedBuildDependencyProjectReference>> AddAsync(string projectPath);
    public abstract virtual Task`1<IUnresolvedBuildDependencyProjectReference> GetUnresolvedReferenceAsync(string projectPath);
    public abstract virtual Task`1<IBuildDependencyProjectReference> GetResolvedReferenceAsync(string projectPath);
    public abstract virtual Task`1<bool> CanResolveAsync(string projectPath);
    public abstract virtual Task`1<bool> ContainsAsync(string projectPath);
    public abstract virtual Task RemoveAsync(string projectPath);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IComReference {
    public abstract virtual Task`1<int> GetLocaleAsync();
    public abstract virtual Task`1<Version> GetVersionAsync();
    public abstract virtual Task`1<Guid> GetGuidAsync();
    public abstract virtual Task`1<string> GetWrapperToolAsync();
    public abstract virtual Task`1<string> GetTypeLibraryNameAsync();
    public abstract virtual Task`1<bool> GetIsolatedAsync();
    public abstract virtual Task`1<string> GetControlFullPathAsync();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IComReferencesService {
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedComReference>> AddAsync(Guid classId, Version version, int localeId, string wrapperTool);
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedComReference>> AddAsync(string path);
    public abstract virtual Task`1<ComReferenceResolveResult> CanResolveAsync(string path);
    public abstract virtual Task`1<bool> CanResolveAsync(Guid classId, Version version, int localeId, string wrapperTool);
    public abstract virtual Task RemoveAsync(Guid classId);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IConditionalPackageReferencesService {
    public abstract virtual Task`1<PackageReference> AddAsync(string packageIdentity, string version, string conditionKey, string conditionValue);
    public abstract virtual Task RemoveAsync(string packageIdentity, string conditionKey, string conditionValue);
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IManifestReferenceResolver {
    public abstract virtual Task`1<string> ResolveReferenceAsync(string reference, string referenceToFile, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IPackageReference {
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IPackageReferencesService {
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedPackageReference>> AddAsync(string packageIdentity, string version);
    public abstract virtual Task RemoveAsync(string packageIdentity);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IReference {
    public IProjectProperties Metadata { get; }
    public abstract virtual IProjectProperties get_Metadata();
    public abstract virtual Task`1<AssemblyName> GetAssemblyNameAsync();
    public abstract virtual Task`1<bool> GetCopyLocalAsync();
    public abstract virtual Task`1<bool> GetCopyLocalSatelliteAssembliesAsync();
    public abstract virtual Task`1<string> GetNameAsync();
    public abstract virtual Task`1<bool> GetReferenceOutputAssemblyAsync();
    public abstract virtual Task`1<string> GetRequiredTargetFrameworkAsync();
    public abstract virtual Task`1<string> GetDescriptionAsync();
    public abstract virtual Task`1<string> GetFullPathAsync();
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IReferencesUI {
    public bool IsNonEmpty { get; }
    public abstract virtual bool get_IsNonEmpty();
    public abstract virtual void ShowReferenceManagerDialog();
}
[ProjectSystemContractAttribute("2", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IResolvableReferencesAddRemoveFileProvider {
    public IEnumerable`1<Tuple`2<string, string>> SuggestedFileFilters { get; }
    public abstract virtual IEnumerable`1<Tuple`2<string, string>> get_SuggestedFileFilters();
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedReference>> AddIfApplicableAsync(string path);
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedReference>> AddFileAsync(string path);
    public abstract virtual Task`1<RemoveFileReferenceResult> RemoveIfApplicableAsync(string path);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IResolvableReferencesService`2 {
    public abstract virtual Task`1<TUnresolvedReference> GetUnresolvedReferenceAsync(TResolvedReference resolvedReference);
    public abstract virtual Task`1<IImmutableSet`1<TUnresolvedReference>> GetUnresolvedReferencesAsync();
    public abstract virtual Task`1<IImmutableSet`1<TResolvedReference>> GetResolvedReferencesAsync();
    public abstract virtual Task`1<TResolvedReference> GetResolvedReferenceAsync(TUnresolvedReference unresolvedReference);
    public abstract virtual Task RemoveAsync(TUnresolvedReference reference);
    public abstract virtual Task RemoveAsync(IEnumerable`1<TUnresolvedReference> references);
}
internal interface Microsoft.VisualStudio.ProjectSystem.References.IResolvableReferencesService2`2 {
    public abstract virtual Task`1<IImmutableSet`1<TUnresolvedReference>> GetUnresolvedReferencesSnapshotAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.References.ISdkReference {
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.ISdkReferencesService {
    public abstract virtual Task`1<AddReferenceResult`1<IUnresolvedSdkReference>> AddAsync(string sdkIdentity);
    public abstract virtual Task`1<IUnresolvedSdkReference> GetUnresolvedReferenceAsync(string sdkIdentity);
    public abstract virtual Task`1<ISdkReference> GetResolvedReferenceAsync(string sdkIdentity);
    public abstract virtual Task`1<IImmutableSet`1<IReference>> ExpandReferenceAsync(IUnresolvedSdkReference sdkReference);
    public abstract virtual Task`1<IImmutableSet`1<IReference>> ExpandReferenceAsync(ISdkReference sdkReference);
    public abstract virtual Task`1<bool> CanResolveAsync(string sdkIdentity);
    public abstract virtual Task`1<bool> ContainsAsync(string sdkIdentity);
    public abstract virtual Task RemoveAsync(string sdkIdentity);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedAssemblyReference {
    public IProjectProperties Metadata { get; }
    public abstract virtual IProjectProperties get_Metadata();
    public abstract virtual Task`1<string> GetHintPathAsync();
    public abstract virtual Task`1<string> GetSDKIdentityAsync();
    public abstract virtual Task SetAssemblyNameAsync(AssemblyName value);
    public abstract virtual Task SetIsWinMDFileAsync(bool value);
    public abstract virtual Task SetHintPathAsync(string value);
    public abstract virtual Task SetSDKIdentityAsync(string value);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedBuildDependencyProjectReference {
    public IProjectProperties Metadata { get; }
    public abstract virtual IProjectProperties get_Metadata();
    public abstract virtual Task SetLinkLibraryDependencyAsync(bool value);
    public abstract virtual Task SetUseLibraryDependencyInputsAsync(bool value);
    public abstract virtual Task SetSolutionIdentifierForReferencedProjectAsync(Guid value);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedComReference {
    public abstract virtual Task SetLocaleAsync(int value);
    public abstract virtual Task SetWrapperToolAsync(string value);
    public abstract virtual Task SetIsolatedAsync(bool value);
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedPackageReference {
    public IProjectProperties Metadata { get; }
    public abstract virtual IProjectProperties get_Metadata();
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedReference {
    public abstract virtual Task SetCopyLocalAsync(bool value);
    public abstract virtual Task SetCopyLocalSatelliteAssembliesAsync(bool value);
    public abstract virtual Task SetNameAsync(string value);
    public abstract virtual Task SetReferenceOutputAssemblyAsync(bool value);
    public abstract virtual Task SetRequiredTargetFrameworkAsync(string value);
    public abstract virtual Task`1<bool> CanResolveAsync();
}
public interface Microsoft.VisualStudio.ProjectSystem.References.IUnresolvedSdkReference {
    public IProjectProperties Metadata { get; }
    public abstract virtual IProjectProperties get_Metadata();
}
[ProjectSystemContractAttribute("1", "2")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IValidProjectReferenceChecker {
    public abstract virtual Task`1<SupportedCheckResult> CanAddProjectReferenceAsync(object referencedProject);
    public abstract virtual Task`1<CanAddProjectReferencesResult> CanAddProjectReferencesAsync(IImmutableSet`1<object> referencedProjects);
    public abstract virtual Task`1<SupportedCheckResult> CanBeReferencedAsync(object referencingProject);
}
[ProjectSystemContractAttribute("2", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.References.IWinRTReferencesService {
}
public class Microsoft.VisualStudio.ProjectSystem.References.PackageReference : object {
    private ConfiguredProject configurationProject;
    private bool isAdded;
    private string projectItemType;
    private string projectEvaluatedInclude;
    private string projectUnevaluatedInclude;
    private ProjectPropertiesContext propertiesContext;
    private object syncObject;
    private IProjectProperties metadata;
    public IProjectProperties Metadata { get; }
    public string UnevaluatedInclude { get; }
    public bool IsAdded { get; }
    public PackageReference(ConfiguredProject configuredProject, ProjectItem projectItem, bool isAdded);
    public IProjectProperties get_Metadata();
    public string get_UnevaluatedInclude();
    public bool get_IsAdded();
}
[ProjectSystemContractAttribute("1", "2")]
public class Microsoft.VisualStudio.ProjectSystem.References.ReferencesProjectTreeCustomizablePropertyValues : object {
    public static string ContractName;
    [CompilerGeneratedAttribute]
private ProjectImageMoniker <ExpandedIcon>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectTreeFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectImageMoniker <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Caption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DisplayOrder>k__BackingField;
    public ProjectImageMoniker ExpandedIcon { get; public set; }
    public ProjectTreeFlags Flags { get; public set; }
    public ProjectImageMoniker Icon { get; public set; }
    public string Caption { get; public set; }
    public int DisplayOrder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ProjectImageMoniker get_ExpandedIcon();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExpandedIcon(ProjectImageMoniker value);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectTreeFlags get_Flags();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Flags(ProjectTreeFlags value);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectImageMoniker get_Icon();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Icon(ProjectImageMoniker value);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
public void set_Caption(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DisplayOrder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisplayOrder(int value);
}
public class Microsoft.VisualStudio.ProjectSystem.References.RemoveFileReferenceResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsReferenceApplicable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasReferencePresent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasReferenceRemoved>k__BackingField;
    public bool IsReferenceApplicable { get; private set; }
    public bool WasReferencePresent { get; private set; }
    public bool WasReferenceRemoved { get; private set; }
    public RemoveFileReferenceResult(bool isReferenceApplicable, bool wasReferencePresent, bool wasReferenceRemoved);
    [CompilerGeneratedAttribute]
public bool get_IsReferenceApplicable();
    [CompilerGeneratedAttribute]
private void set_IsReferenceApplicable(bool value);
    [CompilerGeneratedAttribute]
public bool get_WasReferencePresent();
    [CompilerGeneratedAttribute]
private void set_WasReferencePresent(bool value);
    [CompilerGeneratedAttribute]
public bool get_WasReferenceRemoved();
    [CompilerGeneratedAttribute]
private void set_WasReferenceRemoved(bool value);
}
public enum Microsoft.VisualStudio.ProjectSystem.References.SupportedCheckResult : Enum {
    public int value__;
    public static SupportedCheckResult Unknown;
    public static SupportedCheckResult NotSupported;
    public static SupportedCheckResult Supported;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.RegistrationOption : Enum {
    public int value__;
    public static RegistrationOption None;
    public static RegistrationOption ProjectAffinity;
    public static RegistrationOption InMemoryReload;
    public static RegistrationOption EnableSccSupport;
    public static RegistrationOption SharedProjectFileOwnerProject;
}
public abstract class Microsoft.VisualStudio.ProjectSystem.ReleasingWriteLockEventArgs : EventArgs {
    public IReadOnlyCollection`1<string> WrittenProjectXmlPaths { get; }
    public IReadOnlyDictionary`2<string, string> RenamedProjectXmlPaths { get; }
    public abstract virtual IReadOnlyCollection`1<string> get_WrittenProjectXmlPaths();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_RenamedProjectXmlPaths();
}
internal static class Microsoft.VisualStudio.ProjectSystem.ResourceUtilities : object {
    internal static string FormatString(string unformatted, Object[] args);
    private static string GetHelpKeyword(string resourceName);
}
internal class Microsoft.VisualStudio.ProjectSystem.RollingLog`1 : object {
    private Queue`1<T> queue;
    private int capacity;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal bool IsEnabled { get; internal set; }
    internal RollingLog`1(int capacity);
    [CompilerGeneratedAttribute]
internal bool get_IsEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsEnabled(bool value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Clear();
    internal void Enqueue(T value);
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.AssemblyReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string AliasesProperty;
    internal static string CopyLocalProperty;
    internal static string EmbedInteropTypesProperty;
    internal static string SpecificVersionProperty;
    internal static string RequiredTargetFrameworkProperty;
    internal static string HintPathProperty;
    internal static string SDKNameProperty;
    internal static string IsWinMDFileProperty;
    internal static string ImageRuntimeProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Aliases { get; }
    internal IEvaluatedProperty CopyLocal { get; }
    internal IEvaluatedProperty EmbedInteropTypes { get; }
    internal IEvaluatedProperty SpecificVersion { get; }
    internal IEvaluatedProperty RequiredTargetFramework { get; }
    internal IEvaluatedProperty HintPath { get; }
    internal IEvaluatedProperty SDKName { get; }
    internal IEvaluatedProperty IsWinMDFile { get; }
    internal IEvaluatedProperty ImageRuntime { get; }
    private IRule GeneratedFallbackRule { get; }
    internal AssemblyReference(IRule rule);
    internal AssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal AssemblyReference(IRule rule, ConfiguredProject configuredProject);
    internal AssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal AssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Aliases();
    internal IEvaluatedProperty get_CopyLocal();
    internal IEvaluatedProperty get_EmbedInteropTypes();
    internal IEvaluatedProperty get_SpecificVersion();
    internal IEvaluatedProperty get_RequiredTargetFramework();
    internal IEvaluatedProperty get_HintPath();
    internal IEvaluatedProperty get_SDKName();
    internal IEvaluatedProperty get_IsWinMDFile();
    internal IEvaluatedProperty get_ImageRuntime();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ComReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string GuidProperty;
    internal static string LcidProperty;
    internal static string VersionMajorProperty;
    internal static string VersionMinorProperty;
    internal static string IsolatedProperty;
    internal static string WrapperToolProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Guid { get; }
    internal IEvaluatedProperty Lcid { get; }
    internal IEvaluatedProperty VersionMajor { get; }
    internal IEvaluatedProperty VersionMinor { get; }
    internal IEvaluatedProperty Isolated { get; }
    internal IEvaluatedProperty WrapperTool { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ComReference(IRule rule);
    internal ComReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ComReference(IRule rule, ConfiguredProject configuredProject);
    internal ComReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ComReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Guid();
    internal IEvaluatedProperty get_Lcid();
    internal IEvaluatedProperty get_VersionMajor();
    internal IEvaluatedProperty get_VersionMinor();
    internal IEvaluatedProperty get_Isolated();
    internal IEvaluatedProperty get_WrapperTool();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ConfigurationGeneral : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ApplicationIconProperty;
    internal static string ProjectTypeGuidsProperty;
    internal static string ProjectGuidProperty;
    internal static string TargetFrameworkMonikerProperty;
    internal static string TargetFrameworkIdentifierProperty;
    internal static string TargetFrameworkVersionProperty;
    internal static string TargetFrameworkProfileProperty;
    internal static string TargetPathProperty;
    internal static string DocumentationFileProperty;
    internal static string AssemblyNameProperty;
    internal static string NameProperty;
    internal static string RootNamespaceProperty;
    internal static string OutputNameProperty;
    internal static string OutputPathProperty;
    internal static string OutputTypeProperty;
    internal static string AvailablePlatformsProperty;
    internal static string OptimizeProperty;
    internal static string MSBuildProjectDirectoryProperty;
    internal static string DefaultPlatformProperty;
    internal static string PackageActionProperty;
    internal static string DefaultContentTypeProperty;
    internal static string VCInstallDirProperty;
    internal static string VSInstallDirProperty;
    internal static string PlatformProperty;
    internal static string ConfigurationProperty;
    internal static string DebuggerSymbolsPathProperty;
    internal static string IntDirProperty;
    internal static string TargetPlatformWinMDLocationProperty;
    internal static string SDKReferenceDirectoryRootProperty;
    internal static string SDKReferenceRegistryRootProperty;
    internal static string SDKExtensionDirectoryRootProperty;
    internal static string SDKIdentifierProperty;
    internal static string SDKVersionProperty;
    internal static string TargetPlatformIdentifierProperty;
    internal static string TargetPlatformVersionProperty;
    internal static string WindowsAppContainerProperty;
    internal static string WinMDAssemblyProperty;
    internal static string TargetRuntimeProperty;
    internal static string AssemblySearchPathsProperty;
    internal static string WinRTReferenceTabsProperty;
    internal static string AssemblyReferenceTabsProperty;
    internal static string MinimumVisualStudioVersionProperty;
    internal static string SuppressOutOfDateMessageOnBuildProperty;
    internal static string ShowAllFilesProperty;
    internal static string AutoRefreshProperty;
    internal static string CmdUIContextGuidProperty;
    internal static string GeneratorsTypeGuidProperty;
    internal static string AddItemTemplatesGuidProperty;
    internal static string LanguageServiceIdProperty;
    internal static string ProjectUISubcaptionProperty;
    internal static string SharedItemContextSubProjectGuidProperty;
    internal static string OneAppCapabilitiesProperty;
    internal static string SharedProjectAppliesToProperty;
    internal static string AlwaysUseNumericalSuffixInItemNamesProperty;
    internal static string SupportedOutputTypesProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ApplicationIcon { get; }
    internal IEvaluatedProperty ProjectTypeGuids { get; }
    internal IEvaluatedProperty ProjectGuid { get; }
    internal IEvaluatedProperty TargetFrameworkMoniker { get; }
    internal IEvaluatedProperty TargetFrameworkIdentifier { get; }
    internal IEvaluatedProperty TargetFrameworkVersion { get; }
    internal IEvaluatedProperty TargetFrameworkProfile { get; }
    internal IEvaluatedProperty TargetPath { get; }
    internal IEvaluatedProperty DocumentationFile { get; }
    internal IEvaluatedProperty AssemblyName { get; }
    internal IEvaluatedProperty Name { get; }
    internal IEvaluatedProperty RootNamespace { get; }
    internal IEvaluatedProperty OutputName { get; }
    internal IEvaluatedProperty OutputPath { get; }
    internal IEvaluatedProperty OutputType { get; }
    internal IEvaluatedProperty AvailablePlatforms { get; }
    internal IEvaluatedProperty Optimize { get; }
    internal IEvaluatedProperty MSBuildProjectDirectory { get; }
    internal IEvaluatedProperty DefaultPlatform { get; }
    internal IEvaluatedProperty PackageAction { get; }
    internal IEvaluatedProperty DefaultContentType { get; }
    internal IEvaluatedProperty VCInstallDir { get; }
    internal IEvaluatedProperty VSInstallDir { get; }
    internal IEvaluatedProperty Platform { get; }
    internal IEvaluatedProperty Configuration { get; }
    internal IEvaluatedProperty DebuggerSymbolsPath { get; }
    internal IEvaluatedProperty IntDir { get; }
    internal IEvaluatedProperty TargetPlatformWinMDLocation { get; }
    internal IEvaluatedProperty SDKReferenceDirectoryRoot { get; }
    internal IEvaluatedProperty SDKReferenceRegistryRoot { get; }
    internal IEvaluatedProperty SDKExtensionDirectoryRoot { get; }
    internal IEvaluatedProperty SDKIdentifier { get; }
    internal IEvaluatedProperty SDKVersion { get; }
    internal IEvaluatedProperty TargetPlatformIdentifier { get; }
    internal IEvaluatedProperty TargetPlatformVersion { get; }
    internal IEvaluatedProperty WindowsAppContainer { get; }
    internal IEvaluatedProperty WinMDAssembly { get; }
    internal IEvaluatedProperty TargetRuntime { get; }
    internal IEvaluatedProperty AssemblySearchPaths { get; }
    internal IEvaluatedProperty WinRTReferenceTabs { get; }
    internal IEvaluatedProperty AssemblyReferenceTabs { get; }
    internal IEvaluatedProperty MinimumVisualStudioVersion { get; }
    internal IEvaluatedProperty SuppressOutOfDateMessageOnBuild { get; }
    internal IEvaluatedProperty ShowAllFiles { get; }
    internal IEvaluatedProperty AutoRefresh { get; }
    internal IEvaluatedProperty CmdUIContextGuid { get; }
    internal IEvaluatedProperty GeneratorsTypeGuid { get; }
    internal IEvaluatedProperty AddItemTemplatesGuid { get; }
    internal IEvaluatedProperty LanguageServiceId { get; }
    internal IEvaluatedProperty ProjectUISubcaption { get; }
    internal IEvaluatedProperty SharedItemContextSubProjectGuid { get; }
    internal IEvaluatedProperty OneAppCapabilities { get; }
    internal IEvaluatedProperty SharedProjectAppliesTo { get; }
    internal IEvaluatedProperty AlwaysUseNumericalSuffixInItemNames { get; }
    internal IEvaluatedProperty SupportedOutputTypes { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ConfigurationGeneral(IRule rule);
    internal ConfigurationGeneral(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ConfigurationGeneral(IRule rule, ConfiguredProject configuredProject);
    internal ConfigurationGeneral(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ConfigurationGeneral(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ApplicationIcon();
    internal IEvaluatedProperty get_ProjectTypeGuids();
    internal IEvaluatedProperty get_ProjectGuid();
    internal IEvaluatedProperty get_TargetFrameworkMoniker();
    internal IEvaluatedProperty get_TargetFrameworkIdentifier();
    internal IEvaluatedProperty get_TargetFrameworkVersion();
    internal IEvaluatedProperty get_TargetFrameworkProfile();
    internal IEvaluatedProperty get_TargetPath();
    internal IEvaluatedProperty get_DocumentationFile();
    internal IEvaluatedProperty get_AssemblyName();
    internal IEvaluatedProperty get_Name();
    internal IEvaluatedProperty get_RootNamespace();
    internal IEvaluatedProperty get_OutputName();
    internal IEvaluatedProperty get_OutputPath();
    internal IEvaluatedProperty get_OutputType();
    internal IEvaluatedProperty get_AvailablePlatforms();
    internal IEvaluatedProperty get_Optimize();
    internal IEvaluatedProperty get_MSBuildProjectDirectory();
    internal IEvaluatedProperty get_DefaultPlatform();
    internal IEvaluatedProperty get_PackageAction();
    internal IEvaluatedProperty get_DefaultContentType();
    internal IEvaluatedProperty get_VCInstallDir();
    internal IEvaluatedProperty get_VSInstallDir();
    internal IEvaluatedProperty get_Platform();
    internal IEvaluatedProperty get_Configuration();
    internal IEvaluatedProperty get_DebuggerSymbolsPath();
    internal IEvaluatedProperty get_IntDir();
    internal IEvaluatedProperty get_TargetPlatformWinMDLocation();
    internal IEvaluatedProperty get_SDKReferenceDirectoryRoot();
    internal IEvaluatedProperty get_SDKReferenceRegistryRoot();
    internal IEvaluatedProperty get_SDKExtensionDirectoryRoot();
    internal IEvaluatedProperty get_SDKIdentifier();
    internal IEvaluatedProperty get_SDKVersion();
    internal IEvaluatedProperty get_TargetPlatformIdentifier();
    internal IEvaluatedProperty get_TargetPlatformVersion();
    internal IEvaluatedProperty get_WindowsAppContainer();
    internal IEvaluatedProperty get_WinMDAssembly();
    internal IEvaluatedProperty get_TargetRuntime();
    internal IEvaluatedProperty get_AssemblySearchPaths();
    internal IEvaluatedProperty get_WinRTReferenceTabs();
    internal IEvaluatedProperty get_AssemblyReferenceTabs();
    internal IEvaluatedProperty get_MinimumVisualStudioVersion();
    internal IEvaluatedProperty get_SuppressOutOfDateMessageOnBuild();
    internal IEvaluatedProperty get_ShowAllFiles();
    internal IEvaluatedProperty get_AutoRefresh();
    internal IEvaluatedProperty get_CmdUIContextGuid();
    internal IEvaluatedProperty get_GeneratorsTypeGuid();
    internal IEvaluatedProperty get_AddItemTemplatesGuid();
    internal IEvaluatedProperty get_LanguageServiceId();
    internal IEvaluatedProperty get_ProjectUISubcaption();
    internal IEvaluatedProperty get_SharedItemContextSubProjectGuid();
    internal IEvaluatedProperty get_OneAppCapabilities();
    internal IEvaluatedProperty get_SharedProjectAppliesTo();
    internal IEvaluatedProperty get_AlwaysUseNumericalSuffixInItemNames();
    internal IEvaluatedProperty get_SupportedOutputTypes();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ConfigurationGeneralFile : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ItemTypeProperty;
    internal static string CopyToOutputDirectoryProperty;
    internal static string GeneratorProperty;
    internal static string CustomToolNamespaceProperty;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FileNameAndExtensionProperty;
    internal static string URLProperty;
    internal static string DependentUponProperty;
    internal static string VisibleProperty;
    internal static string LinkProperty;
    internal static string ExtensionProperty;
    internal static string GeneratorTargetProperty;
    internal static string SubTypeProperty;
    internal static string LastGenOutputProperty;
    internal static string DesignTimeProperty;
    internal static string AutoGenProperty;
    internal static string DesignTimeSharedInputProperty;
    internal static string DefiningProjectDirectoryProperty;
    internal static string DefiningProjectFullPathProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ItemType { get; }
    internal IEvaluatedProperty CopyToOutputDirectory { get; }
    internal IEvaluatedProperty Generator { get; }
    internal IEvaluatedProperty CustomToolNamespace { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FileNameAndExtension { get; }
    internal IEvaluatedProperty URL { get; }
    internal IEvaluatedProperty DependentUpon { get; }
    internal IEvaluatedProperty Visible { get; }
    internal IEvaluatedProperty Link { get; }
    internal IEvaluatedProperty Extension { get; }
    internal IEvaluatedProperty GeneratorTarget { get; }
    internal IEvaluatedProperty SubType { get; }
    internal IEvaluatedProperty LastGenOutput { get; }
    internal IEvaluatedProperty DesignTime { get; }
    internal IEvaluatedProperty AutoGen { get; }
    internal IEvaluatedProperty DesignTimeSharedInput { get; }
    internal IEvaluatedProperty DefiningProjectDirectory { get; }
    internal IEvaluatedProperty DefiningProjectFullPath { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ConfigurationGeneralFile(IRule rule);
    internal ConfigurationGeneralFile(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ConfigurationGeneralFile(IRule rule, ConfiguredProject configuredProject);
    internal ConfigurationGeneralFile(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ConfigurationGeneralFile(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    internal IRule GetRule();
    public IRule get_Rule();
    internal IEvaluatedProperty get_ItemType();
    internal IEvaluatedProperty get_CopyToOutputDirectory();
    internal IEvaluatedProperty get_Generator();
    internal IEvaluatedProperty get_CustomToolNamespace();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FileNameAndExtension();
    internal IEvaluatedProperty get_URL();
    internal IEvaluatedProperty get_DependentUpon();
    internal IEvaluatedProperty get_Visible();
    internal IEvaluatedProperty get_Link();
    internal IEvaluatedProperty get_Extension();
    internal IEvaluatedProperty get_GeneratorTarget();
    internal IEvaluatedProperty get_SubType();
    internal IEvaluatedProperty get_LastGenOutput();
    internal IEvaluatedProperty get_DesignTime();
    internal IEvaluatedProperty get_AutoGen();
    internal IEvaluatedProperty get_DesignTimeSharedInput();
    internal IEvaluatedProperty get_DefiningProjectDirectory();
    internal IEvaluatedProperty get_DefiningProjectFullPath();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ConnectedService : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ConnectedService(IRule rule);
    internal ConnectedService(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ConnectedService(IRule rule, ConfiguredProject configuredProject);
    internal ConnectedService(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ConnectedService(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.Content : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ItemTypeProperty;
    internal static string CopyToOutputDirectoryProperty;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FileNameAndExtensionProperty;
    internal static string VisibleProperty;
    internal static string DependentUponProperty;
    internal static string LinkProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ItemType { get; }
    internal IEvaluatedProperty CopyToOutputDirectory { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FileNameAndExtension { get; }
    internal IEvaluatedProperty Visible { get; }
    internal IEvaluatedProperty DependentUpon { get; }
    internal IEvaluatedProperty Link { get; }
    private IRule GeneratedFallbackRule { get; }
    internal Content(IRule rule);
    internal Content(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal Content(IRule rule, ConfiguredProject configuredProject);
    internal Content(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal Content(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ItemType();
    internal IEvaluatedProperty get_CopyToOutputDirectory();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FileNameAndExtension();
    internal IEvaluatedProperty get_Visible();
    internal IEvaluatedProperty get_DependentUpon();
    internal IEvaluatedProperty get_Link();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.CSharp : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ItemTypeProperty;
    internal static string CopyToOutputDirectoryProperty;
    internal static string GeneratorProperty;
    internal static string CustomToolNamespaceProperty;
    internal static string ExcludedFromBuildProperty;
    internal static string VisibleProperty;
    internal static string DependentUponProperty;
    internal static string LinkProperty;
    internal static string SubTypeProperty;
    internal static string LastGenOutputProperty;
    internal static string DesignTimeProperty;
    internal static string AutoGenProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ItemType { get; }
    internal IEvaluatedProperty CopyToOutputDirectory { get; }
    internal IEvaluatedProperty Generator { get; }
    internal IEvaluatedProperty CustomToolNamespace { get; }
    internal IEvaluatedProperty ExcludedFromBuild { get; }
    internal IEvaluatedProperty Visible { get; }
    internal IEvaluatedProperty DependentUpon { get; }
    internal IEvaluatedProperty Link { get; }
    internal IEvaluatedProperty SubType { get; }
    internal IEvaluatedProperty LastGenOutput { get; }
    internal IEvaluatedProperty DesignTime { get; }
    internal IEvaluatedProperty AutoGen { get; }
    private IRule GeneratedFallbackRule { get; }
    internal CSharp(IRule rule);
    internal CSharp(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal CSharp(IRule rule, ConfiguredProject configuredProject);
    internal CSharp(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal CSharp(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ItemType();
    internal IEvaluatedProperty get_CopyToOutputDirectory();
    internal IEvaluatedProperty get_Generator();
    internal IEvaluatedProperty get_CustomToolNamespace();
    internal IEvaluatedProperty get_ExcludedFromBuild();
    internal IEvaluatedProperty get_Visible();
    internal IEvaluatedProperty get_DependentUpon();
    internal IEvaluatedProperty get_Link();
    internal IEvaluatedProperty get_SubType();
    internal IEvaluatedProperty get_LastGenOutput();
    internal IEvaluatedProperty get_DesignTime();
    internal IEvaluatedProperty get_AutoGen();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.DebuggerGeneralProperties : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string SymbolsPathProperty;
    internal static string DebuggerFlavorProperty;
    internal static string ImageClrTypeProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty SymbolsPath { get; }
    internal IEvaluatedProperty DebuggerFlavor { get; }
    internal IEvaluatedProperty ImageClrType { get; }
    private IRule GeneratedFallbackRule { get; }
    internal DebuggerGeneralProperties(IRule rule);
    internal DebuggerGeneralProperties(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal DebuggerGeneralProperties(IRule rule, ConfiguredProject configuredProject);
    internal DebuggerGeneralProperties(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal DebuggerGeneralProperties(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_SymbolsPath();
    internal IEvaluatedProperty get_DebuggerFlavor();
    internal IEvaluatedProperty get_ImageClrType();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.EmbeddedResource : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ItemTypeProperty;
    internal static string CopyToOutputDirectoryProperty;
    internal static string GeneratorProperty;
    internal static string CustomToolNamespaceProperty;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FileNameAndExtensionProperty;
    internal static string URLProperty;
    internal static string VisibleProperty;
    internal static string DependentUponProperty;
    internal static string LinkProperty;
    internal static string ExtensionProperty;
    internal static string LastGenOutputProperty;
    internal static string DesignTimeProperty;
    internal static string AutoGenProperty;
    internal static string CustomToolProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ItemType { get; }
    internal IEvaluatedProperty CopyToOutputDirectory { get; }
    internal IEvaluatedProperty Generator { get; }
    internal IEvaluatedProperty CustomToolNamespace { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FileNameAndExtension { get; }
    internal IEvaluatedProperty URL { get; }
    internal IEvaluatedProperty Visible { get; }
    internal IEvaluatedProperty DependentUpon { get; }
    internal IEvaluatedProperty Link { get; }
    internal IEvaluatedProperty Extension { get; }
    internal IEvaluatedProperty LastGenOutput { get; }
    internal IEvaluatedProperty DesignTime { get; }
    internal IEvaluatedProperty AutoGen { get; }
    internal IEvaluatedProperty CustomTool { get; }
    private IRule GeneratedFallbackRule { get; }
    internal EmbeddedResource(IRule rule);
    internal EmbeddedResource(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal EmbeddedResource(IRule rule, ConfiguredProject configuredProject);
    internal EmbeddedResource(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal EmbeddedResource(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ItemType();
    internal IEvaluatedProperty get_CopyToOutputDirectory();
    internal IEvaluatedProperty get_Generator();
    internal IEvaluatedProperty get_CustomToolNamespace();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FileNameAndExtension();
    internal IEvaluatedProperty get_URL();
    internal IEvaluatedProperty get_Visible();
    internal IEvaluatedProperty get_DependentUpon();
    internal IEvaluatedProperty get_Link();
    internal IEvaluatedProperty get_Extension();
    internal IEvaluatedProperty get_LastGenOutput();
    internal IEvaluatedProperty get_DesignTime();
    internal IEvaluatedProperty get_AutoGen();
    internal IEvaluatedProperty get_CustomTool();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.Folder : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FolderNameProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FolderName { get; }
    private IRule GeneratedFallbackRule { get; }
    internal Folder(IRule rule);
    internal Folder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal Folder(IRule rule, ConfiguredProject configuredProject);
    internal Folder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal Folder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FolderName();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.None : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ItemTypeProperty;
    internal static string CopyToOutputDirectoryProperty;
    internal static string GeneratorProperty;
    internal static string CustomToolNamespaceProperty;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FileNameAndExtensionProperty;
    internal static string URLProperty;
    internal static string VisibleProperty;
    internal static string DependentUponProperty;
    internal static string LinkProperty;
    internal static string ExtensionProperty;
    internal static string LastGenOutputProperty;
    internal static string DesignTimeProperty;
    internal static string AutoGenProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ItemType { get; }
    internal IEvaluatedProperty CopyToOutputDirectory { get; }
    internal IEvaluatedProperty Generator { get; }
    internal IEvaluatedProperty CustomToolNamespace { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FileNameAndExtension { get; }
    internal IEvaluatedProperty URL { get; }
    internal IEvaluatedProperty Visible { get; }
    internal IEvaluatedProperty DependentUpon { get; }
    internal IEvaluatedProperty Link { get; }
    internal IEvaluatedProperty Extension { get; }
    internal IEvaluatedProperty LastGenOutput { get; }
    internal IEvaluatedProperty DesignTime { get; }
    internal IEvaluatedProperty AutoGen { get; }
    private IRule GeneratedFallbackRule { get; }
    internal None(IRule rule);
    internal None(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal None(IRule rule, ConfiguredProject configuredProject);
    internal None(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal None(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ItemType();
    internal IEvaluatedProperty get_CopyToOutputDirectory();
    internal IEvaluatedProperty get_Generator();
    internal IEvaluatedProperty get_CustomToolNamespace();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FileNameAndExtension();
    internal IEvaluatedProperty get_URL();
    internal IEvaluatedProperty get_Visible();
    internal IEvaluatedProperty get_DependentUpon();
    internal IEvaluatedProperty get_Link();
    internal IEvaluatedProperty get_Extension();
    internal IEvaluatedProperty get_LastGenOutput();
    internal IEvaluatedProperty get_DesignTime();
    internal IEvaluatedProperty get_AutoGen();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ProjectReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string ReferenceOutputAssemblyProperty;
    internal static string PrivateProperty;
    internal static string CopyLocalSatelliteAssembliesProperty;
    internal static string LinkLibraryDependenciesProperty;
    internal static string UseLibraryDependencyInputsProperty;
    internal static string ProjectProperty;
    internal static string ReferencedProjectIdentifierProperty;
    internal static string CopyLocalProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty ReferenceOutputAssembly { get; }
    internal IEvaluatedProperty Private { get; }
    internal IEvaluatedProperty CopyLocalSatelliteAssemblies { get; }
    internal IEvaluatedProperty LinkLibraryDependencies { get; }
    internal IEvaluatedProperty UseLibraryDependencyInputs { get; }
    internal IEvaluatedProperty Project { get; }
    internal IEvaluatedProperty ReferencedProjectIdentifier { get; }
    internal IEvaluatedProperty CopyLocal { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ProjectReference(IRule rule);
    internal ProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ProjectReference(IRule rule, ConfiguredProject configuredProject);
    internal ProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_ReferenceOutputAssembly();
    internal IEvaluatedProperty get_Private();
    internal IEvaluatedProperty get_CopyLocalSatelliteAssemblies();
    internal IEvaluatedProperty get_LinkLibraryDependencies();
    internal IEvaluatedProperty get_UseLibraryDependencyInputs();
    internal IEvaluatedProperty get_Project();
    internal IEvaluatedProperty get_ReferencedProjectIdentifier();
    internal IEvaluatedProperty get_CopyLocal();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ResolvedAssemblyReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string AliasesProperty;
    internal static string CopyLocalProperty;
    internal static string CultureProperty;
    internal static string DescriptionProperty;
    internal static string EmbedInteropTypesProperty;
    internal static string FileTypeProperty;
    internal static string IdentityProperty;
    internal static string ResolvedPathProperty;
    internal static string RuntimeVersionProperty;
    internal static string SpecificVersionProperty;
    internal static string StrongNameProperty;
    internal static string VersionProperty;
    internal static string RequiredTargetFrameworkProperty;
    internal static string HintPathProperty;
    internal static string SDKIdentityProperty;
    internal static string IsWinMDFileProperty;
    internal static string WinMDFileProperty;
    internal static string NameProperty;
    internal static string OriginalItemSpecProperty;
    internal static string ReferenceFromSDKProperty;
    internal static string FusionNameProperty;
    internal static string ResolvedFromProperty;
    internal static string FrameworkFileProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Aliases { get; }
    internal IEvaluatedProperty CopyLocal { get; }
    internal IEvaluatedProperty Culture { get; }
    internal IEvaluatedProperty Description { get; }
    internal IEvaluatedProperty EmbedInteropTypes { get; }
    internal IEvaluatedProperty FileType { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty ResolvedPath { get; }
    internal IEvaluatedProperty RuntimeVersion { get; }
    internal IEvaluatedProperty SpecificVersion { get; }
    internal IEvaluatedProperty StrongName { get; }
    internal IEvaluatedProperty Version { get; }
    internal IEvaluatedProperty RequiredTargetFramework { get; }
    internal IEvaluatedProperty HintPath { get; }
    internal IEvaluatedProperty SDKIdentity { get; }
    internal IEvaluatedProperty IsWinMDFile { get; }
    internal IEvaluatedProperty WinMDFile { get; }
    internal IEvaluatedProperty Name { get; }
    internal IEvaluatedProperty OriginalItemSpec { get; }
    internal IEvaluatedProperty ReferenceFromSDK { get; }
    internal IEvaluatedProperty FusionName { get; }
    internal IEvaluatedProperty ResolvedFrom { get; }
    internal IEvaluatedProperty FrameworkFile { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ResolvedAssemblyReference(IRule rule);
    internal ResolvedAssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ResolvedAssemblyReference(IRule rule, ConfiguredProject configuredProject);
    internal ResolvedAssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ResolvedAssemblyReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Aliases();
    internal IEvaluatedProperty get_CopyLocal();
    internal IEvaluatedProperty get_Culture();
    internal IEvaluatedProperty get_Description();
    internal IEvaluatedProperty get_EmbedInteropTypes();
    internal IEvaluatedProperty get_FileType();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_ResolvedPath();
    internal IEvaluatedProperty get_RuntimeVersion();
    internal IEvaluatedProperty get_SpecificVersion();
    internal IEvaluatedProperty get_StrongName();
    internal IEvaluatedProperty get_Version();
    internal IEvaluatedProperty get_RequiredTargetFramework();
    internal IEvaluatedProperty get_HintPath();
    internal IEvaluatedProperty get_SDKIdentity();
    internal IEvaluatedProperty get_IsWinMDFile();
    internal IEvaluatedProperty get_WinMDFile();
    internal IEvaluatedProperty get_Name();
    internal IEvaluatedProperty get_OriginalItemSpec();
    internal IEvaluatedProperty get_ReferenceFromSDK();
    internal IEvaluatedProperty get_FusionName();
    internal IEvaluatedProperty get_ResolvedFrom();
    internal IEvaluatedProperty get_FrameworkFile();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ResolvedCOMReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string GuidProperty;
    internal static string VersionMajorProperty;
    internal static string VersionMinorProperty;
    internal static string WrapperToolProperty;
    internal static string AliasesProperty;
    internal static string CopyLocalProperty;
    internal static string CultureProperty;
    internal static string DescriptionProperty;
    internal static string EmbedInteropTypesProperty;
    internal static string FileTypeProperty;
    internal static string IdentityProperty;
    internal static string ResolvedPathProperty;
    internal static string RuntimeVersionProperty;
    internal static string SpecificVersionProperty;
    internal static string StrongNameProperty;
    internal static string VersionProperty;
    internal static string RequiredTargetFrameworkProperty;
    internal static string HintPathProperty;
    internal static string SDKIdentityProperty;
    internal static string IsWinMDFileProperty;
    internal static string WinMDFileProperty;
    internal static string OriginalItemSpecProperty;
    internal static string FusionNameProperty;
    internal static string NameProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Guid { get; }
    internal IEvaluatedProperty VersionMajor { get; }
    internal IEvaluatedProperty VersionMinor { get; }
    internal IEvaluatedProperty WrapperTool { get; }
    internal IEvaluatedProperty Aliases { get; }
    internal IEvaluatedProperty CopyLocal { get; }
    internal IEvaluatedProperty Culture { get; }
    internal IEvaluatedProperty Description { get; }
    internal IEvaluatedProperty EmbedInteropTypes { get; }
    internal IEvaluatedProperty FileType { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty ResolvedPath { get; }
    internal IEvaluatedProperty RuntimeVersion { get; }
    internal IEvaluatedProperty SpecificVersion { get; }
    internal IEvaluatedProperty StrongName { get; }
    internal IEvaluatedProperty Version { get; }
    internal IEvaluatedProperty RequiredTargetFramework { get; }
    internal IEvaluatedProperty HintPath { get; }
    internal IEvaluatedProperty SDKIdentity { get; }
    internal IEvaluatedProperty IsWinMDFile { get; }
    internal IEvaluatedProperty WinMDFile { get; }
    internal IEvaluatedProperty OriginalItemSpec { get; }
    internal IEvaluatedProperty FusionName { get; }
    internal IEvaluatedProperty Name { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ResolvedCOMReference(IRule rule);
    internal ResolvedCOMReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ResolvedCOMReference(IRule rule, ConfiguredProject configuredProject);
    internal ResolvedCOMReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ResolvedCOMReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Guid();
    internal IEvaluatedProperty get_VersionMajor();
    internal IEvaluatedProperty get_VersionMinor();
    internal IEvaluatedProperty get_WrapperTool();
    internal IEvaluatedProperty get_Aliases();
    internal IEvaluatedProperty get_CopyLocal();
    internal IEvaluatedProperty get_Culture();
    internal IEvaluatedProperty get_Description();
    internal IEvaluatedProperty get_EmbedInteropTypes();
    internal IEvaluatedProperty get_FileType();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_ResolvedPath();
    internal IEvaluatedProperty get_RuntimeVersion();
    internal IEvaluatedProperty get_SpecificVersion();
    internal IEvaluatedProperty get_StrongName();
    internal IEvaluatedProperty get_Version();
    internal IEvaluatedProperty get_RequiredTargetFramework();
    internal IEvaluatedProperty get_HintPath();
    internal IEvaluatedProperty get_SDKIdentity();
    internal IEvaluatedProperty get_IsWinMDFile();
    internal IEvaluatedProperty get_WinMDFile();
    internal IEvaluatedProperty get_OriginalItemSpec();
    internal IEvaluatedProperty get_FusionName();
    internal IEvaluatedProperty get_Name();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ResolvedProjectReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string AliasesProperty;
    internal static string CopyLocalProperty;
    internal static string CultureProperty;
    internal static string DescriptionProperty;
    internal static string EmbedInteropTypesProperty;
    internal static string FileTypeProperty;
    internal static string IdentityProperty;
    internal static string ResolvedPathProperty;
    internal static string RuntimeVersionProperty;
    internal static string SpecificVersionProperty;
    internal static string StrongNameProperty;
    internal static string VersionProperty;
    internal static string RequiredTargetFrameworkProperty;
    internal static string HintPathProperty;
    internal static string SDKIdentityProperty;
    internal static string IsWinMDFileProperty;
    internal static string ProjectProperty;
    internal static string WinMDFileProperty;
    internal static string OriginalItemSpecProperty;
    internal static string FusionNameProperty;
    internal static string NameProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Aliases { get; }
    internal IEvaluatedProperty CopyLocal { get; }
    internal IEvaluatedProperty Culture { get; }
    internal IEvaluatedProperty Description { get; }
    internal IEvaluatedProperty EmbedInteropTypes { get; }
    internal IEvaluatedProperty FileType { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty ResolvedPath { get; }
    internal IEvaluatedProperty RuntimeVersion { get; }
    internal IEvaluatedProperty SpecificVersion { get; }
    internal IEvaluatedProperty StrongName { get; }
    internal IEvaluatedProperty Version { get; }
    internal IEvaluatedProperty RequiredTargetFramework { get; }
    internal IEvaluatedProperty HintPath { get; }
    internal IEvaluatedProperty SDKIdentity { get; }
    internal IEvaluatedProperty IsWinMDFile { get; }
    internal IEvaluatedProperty Project { get; }
    internal IEvaluatedProperty WinMDFile { get; }
    internal IEvaluatedProperty OriginalItemSpec { get; }
    internal IEvaluatedProperty FusionName { get; }
    internal IEvaluatedProperty Name { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ResolvedProjectReference(IRule rule);
    internal ResolvedProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ResolvedProjectReference(IRule rule, ConfiguredProject configuredProject);
    internal ResolvedProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ResolvedProjectReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Aliases();
    internal IEvaluatedProperty get_CopyLocal();
    internal IEvaluatedProperty get_Culture();
    internal IEvaluatedProperty get_Description();
    internal IEvaluatedProperty get_EmbedInteropTypes();
    internal IEvaluatedProperty get_FileType();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_ResolvedPath();
    internal IEvaluatedProperty get_RuntimeVersion();
    internal IEvaluatedProperty get_SpecificVersion();
    internal IEvaluatedProperty get_StrongName();
    internal IEvaluatedProperty get_Version();
    internal IEvaluatedProperty get_RequiredTargetFramework();
    internal IEvaluatedProperty get_HintPath();
    internal IEvaluatedProperty get_SDKIdentity();
    internal IEvaluatedProperty get_IsWinMDFile();
    internal IEvaluatedProperty get_Project();
    internal IEvaluatedProperty get_WinMDFile();
    internal IEvaluatedProperty get_OriginalItemSpec();
    internal IEvaluatedProperty get_FusionName();
    internal IEvaluatedProperty get_Name();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.ResolvedSdkReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string AppXLocationProperty;
    internal static string OriginalItemSpecProperty;
    internal static string FrameworkIdentityProperty;
    internal static string DisplayNameProperty;
    internal static string CopyPayloadProperty;
    internal static string ExpandContentProperty;
    internal static string ExpandReferenceAssembliesProperty;
    internal static string CopyLocalExpandedReferenceAssembliesProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty AppXLocation { get; }
    internal IEvaluatedProperty OriginalItemSpec { get; }
    internal IEvaluatedProperty FrameworkIdentity { get; }
    internal IEvaluatedProperty DisplayName { get; }
    internal IEvaluatedProperty CopyPayload { get; }
    internal IEvaluatedProperty ExpandContent { get; }
    internal IEvaluatedProperty ExpandReferenceAssemblies { get; }
    internal IEvaluatedProperty CopyLocalExpandedReferenceAssemblies { get; }
    private IRule GeneratedFallbackRule { get; }
    internal ResolvedSdkReference(IRule rule);
    internal ResolvedSdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal ResolvedSdkReference(IRule rule, ConfiguredProject configuredProject);
    internal ResolvedSdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal ResolvedSdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_AppXLocation();
    internal IEvaluatedProperty get_OriginalItemSpec();
    internal IEvaluatedProperty get_FrameworkIdentity();
    internal IEvaluatedProperty get_DisplayName();
    internal IEvaluatedProperty get_CopyPayload();
    internal IEvaluatedProperty get_ExpandContent();
    internal IEvaluatedProperty get_ExpandReferenceAssemblies();
    internal IEvaluatedProperty get_CopyLocalExpandedReferenceAssemblies();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
[ProjectSystemContractAttribute("2", "3")]
internal class Microsoft.VisualStudio.ProjectSystem.Rules.RuleProperties : StronglyTypedPropertyAccess {
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, WindowsLocalDebugger> CreateWindowsLocalDebuggerPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, WindowsRemoteDebugger> CreateWindowsRemoteDebuggerPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, WebBrowserDebugger> CreateWebBrowserDebuggerPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, WebServiceDebugger> CreateWebServiceDebuggerPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ConfigurationGeneral> CreateConfigurationGeneralPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ConnectedService> CreateConnectedServicePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, DebuggerGeneralProperties> CreateDebuggerGeneralPropertiesPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, AssemblyReference> CreateAssemblyReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ComReference> CreateComReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ProjectReference> CreateProjectReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, SdkReference> CreateSdkReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ResolvedAssemblyReference> CreateResolvedAssemblyReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ResolvedCOMReference> CreateResolvedCOMReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ResolvedProjectReference> CreateResolvedProjectReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, ResolvedSdkReference> CreateResolvedSdkReferencePropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, SourceControl> CreateSourceControlPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, CSharp> CreateCSharpPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, Content> CreateContentPropertiesDelegate;
    private static Func`3<Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>>, object, EmbeddedResource> CreateEmbeddedResourcePropertiesDelegate;
    public RuleProperties(ConfiguredProject configuredProject);
    public RuleProperties(ConfiguredProject configuredProject, string file, string itemType, string itemName);
    public RuleProperties(ConfiguredProject configuredProject, IProjectPropertiesContext projectPropertiesContext);
    public RuleProperties(ConfiguredProject configuredProject, UnconfiguredProject unconfiguredProject);
    private static RuleProperties();
    internal bool TryGetCurrentConfigurationGeneralPropertiesSnapshot(ConfigurationGeneral& snapshot, bool requiredToMatchProjectVersion);
    private static WindowsLocalDebugger CreateWindowsLocalDebuggerProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<WindowsLocalDebugger> GetWindowsLocalDebuggerPropertiesAsync();
    private static WindowsRemoteDebugger CreateWindowsRemoteDebuggerProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<WindowsRemoteDebugger> GetWindowsRemoteDebuggerPropertiesAsync();
    private static WebBrowserDebugger CreateWebBrowserDebuggerProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<WebBrowserDebugger> GetWebBrowserDebuggerPropertiesAsync();
    private static WebServiceDebugger CreateWebServiceDebuggerProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<WebServiceDebugger> GetWebServiceDebuggerPropertiesAsync();
    private static ConfigurationGeneral CreateConfigurationGeneralProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ConfigurationGeneral> GetConfigurationGeneralPropertiesAsync();
    private static ConnectedService CreateConnectedServiceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ConnectedService> GetConnectedServicePropertiesAsync();
    private static DebuggerGeneralProperties CreateDebuggerGeneralPropertiesProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<DebuggerGeneralProperties> GetDebuggerGeneralPropertiesPropertiesAsync();
    private static AssemblyReference CreateAssemblyReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<AssemblyReference> GetAssemblyReferencePropertiesAsync();
    private static ComReference CreateComReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ComReference> GetComReferencePropertiesAsync();
    private static ProjectReference CreateProjectReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ProjectReference> GetProjectReferencePropertiesAsync();
    private static SdkReference CreateSdkReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<SdkReference> GetSdkReferencePropertiesAsync();
    private static ResolvedAssemblyReference CreateResolvedAssemblyReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ResolvedAssemblyReference> GetResolvedAssemblyReferencePropertiesAsync();
    private static ResolvedCOMReference CreateResolvedCOMReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ResolvedCOMReference> GetResolvedCOMReferencePropertiesAsync();
    private static ResolvedProjectReference CreateResolvedProjectReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ResolvedProjectReference> GetResolvedProjectReferencePropertiesAsync();
    private static ResolvedSdkReference CreateResolvedSdkReferenceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<ResolvedSdkReference> GetResolvedSdkReferencePropertiesAsync();
    private static SourceControl CreateSourceControlProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<SourceControl> GetSourceControlPropertiesAsync();
    private static CSharp CreateCSharpProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<CSharp> GetCSharpPropertiesAsync();
    private static Content CreateContentProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<Content> GetContentPropertiesAsync();
    private static EmbeddedResource CreateEmbeddedResourceProperties(Task`1<IImmutableDictionary`2<string, IPropertyPagesCatalog>> namedCatalogs, object state);
    internal Task`1<EmbeddedResource> GetEmbeddedResourcePropertiesAsync();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.SdkReference : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string SDKRootFolderProperty;
    internal static string AppXLocationProperty;
    internal static string FrameworkIdentityProperty;
    internal static string CopyPayloadProperty;
    internal static string CopyPayloadToSubDirectoryProperty;
    internal static string ExpandContentProperty;
    internal static string ExpandReferenceAssembliesProperty;
    internal static string CopyLocalExpandedReferenceAssembliesProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty SDKRootFolder { get; }
    internal IEvaluatedProperty AppXLocation { get; }
    internal IEvaluatedProperty FrameworkIdentity { get; }
    internal IEvaluatedProperty CopyPayload { get; }
    internal IEvaluatedProperty CopyPayloadToSubDirectory { get; }
    internal IEvaluatedProperty ExpandContent { get; }
    internal IEvaluatedProperty ExpandReferenceAssemblies { get; }
    internal IEvaluatedProperty CopyLocalExpandedReferenceAssemblies { get; }
    private IRule GeneratedFallbackRule { get; }
    internal SdkReference(IRule rule);
    internal SdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal SdkReference(IRule rule, ConfiguredProject configuredProject);
    internal SdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal SdkReference(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_SDKRootFolder();
    internal IEvaluatedProperty get_AppXLocation();
    internal IEvaluatedProperty get_FrameworkIdentity();
    internal IEvaluatedProperty get_CopyPayload();
    internal IEvaluatedProperty get_CopyPayloadToSubDirectory();
    internal IEvaluatedProperty get_ExpandContent();
    internal IEvaluatedProperty get_ExpandReferenceAssemblies();
    internal IEvaluatedProperty get_CopyLocalExpandedReferenceAssemblies();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.SourceControl : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string SccProjectNameProperty;
    internal static string SccProviderProperty;
    internal static string SccAuxPathProperty;
    internal static string SccLocalPathProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty SccProjectName { get; }
    internal IEvaluatedProperty SccProvider { get; }
    internal IEvaluatedProperty SccAuxPath { get; }
    internal IEvaluatedProperty SccLocalPath { get; }
    private IRule GeneratedFallbackRule { get; }
    internal SourceControl(IRule rule);
    internal SourceControl(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal SourceControl(IRule rule, ConfiguredProject configuredProject);
    internal SourceControl(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal SourceControl(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_SccProjectName();
    internal IEvaluatedProperty get_SccProvider();
    internal IEvaluatedProperty get_SccAuxPath();
    internal IEvaluatedProperty get_SccLocalPath();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.SpecialFolder : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string IdentityProperty;
    internal static string FullPathProperty;
    internal static string FileNameAndExtensionProperty;
    internal static string DisableAddItemProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty Identity { get; }
    internal IEvaluatedProperty FullPath { get; }
    internal IEvaluatedProperty FileNameAndExtension { get; }
    internal IEvaluatedProperty DisableAddItem { get; }
    private IRule GeneratedFallbackRule { get; }
    internal SpecialFolder(IRule rule);
    internal SpecialFolder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal SpecialFolder(IRule rule, ConfiguredProject configuredProject);
    internal SpecialFolder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal SpecialFolder(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_Identity();
    internal IEvaluatedProperty get_FullPath();
    internal IEvaluatedProperty get_FileNameAndExtension();
    internal IEvaluatedProperty get_DisableAddItem();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.WebBrowserDebugger : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string WebBrowserDebuggerHttpUrlProperty;
    internal static string WebBrowserDebuggerDebuggerTypeProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty WebBrowserDebuggerHttpUrl { get; }
    internal IEvaluatedProperty WebBrowserDebuggerDebuggerType { get; }
    private IRule GeneratedFallbackRule { get; }
    internal WebBrowserDebugger(IRule rule);
    internal WebBrowserDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal WebBrowserDebugger(IRule rule, ConfiguredProject configuredProject);
    internal WebBrowserDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal WebBrowserDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_WebBrowserDebuggerHttpUrl();
    internal IEvaluatedProperty get_WebBrowserDebuggerDebuggerType();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.WebServiceDebugger : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string WebServiceDebuggerHttpUrlProperty;
    internal static string WebServiceDebuggerDebuggerTypeProperty;
    internal static string WebServiceDebuggerSQLDebuggingProperty;
    internal static string UseLegacyManagedDebuggerProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty WebServiceDebuggerHttpUrl { get; }
    internal IEvaluatedProperty WebServiceDebuggerDebuggerType { get; }
    internal IEvaluatedProperty WebServiceDebuggerSQLDebugging { get; }
    internal IEvaluatedProperty UseLegacyManagedDebugger { get; }
    private IRule GeneratedFallbackRule { get; }
    internal WebServiceDebugger(IRule rule);
    internal WebServiceDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal WebServiceDebugger(IRule rule, ConfiguredProject configuredProject);
    internal WebServiceDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal WebServiceDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_WebServiceDebuggerHttpUrl();
    internal IEvaluatedProperty get_WebServiceDebuggerDebuggerType();
    internal IEvaluatedProperty get_WebServiceDebuggerSQLDebugging();
    internal IEvaluatedProperty get_UseLegacyManagedDebugger();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.WindowsLocalDebugger : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string LocalDebuggerCommandProperty;
    internal static string LocalDebuggerCommandArgumentsProperty;
    internal static string LocalDebuggerWorkingDirectoryProperty;
    internal static string LocalDebuggerAttachProperty;
    internal static string LocalDebuggerDebuggerTypeProperty;
    internal static string LocalDebuggerEnvironmentProperty;
    internal static string LocalGPUDebuggerTargetTypeProperty;
    internal static string GPURefDebuggerBreakOnAllThreadsProperty;
    internal static string LocalDebuggerMergeEnvironmentProperty;
    internal static string LocalDebuggerSQLDebuggingProperty;
    internal static string LocalDebuggerAmpDefaultAcceleratorProperty;
    internal static string EnableVsGraphicsCaptureProperty;
    internal static string UseLegacyManagedDebuggerProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty LocalDebuggerCommand { get; }
    internal IEvaluatedProperty LocalDebuggerCommandArguments { get; }
    internal IEvaluatedProperty LocalDebuggerWorkingDirectory { get; }
    internal IEvaluatedProperty LocalDebuggerAttach { get; }
    internal IEvaluatedProperty LocalDebuggerDebuggerType { get; }
    internal IEvaluatedProperty LocalDebuggerEnvironment { get; }
    internal IEvaluatedProperty LocalGPUDebuggerTargetType { get; }
    internal IEvaluatedProperty GPURefDebuggerBreakOnAllThreads { get; }
    internal IEvaluatedProperty LocalDebuggerMergeEnvironment { get; }
    internal IEvaluatedProperty LocalDebuggerSQLDebugging { get; }
    internal IEvaluatedProperty LocalDebuggerAmpDefaultAccelerator { get; }
    internal IEvaluatedProperty EnableVsGraphicsCapture { get; }
    internal IEvaluatedProperty UseLegacyManagedDebugger { get; }
    private IRule GeneratedFallbackRule { get; }
    internal WindowsLocalDebugger(IRule rule);
    internal WindowsLocalDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal WindowsLocalDebugger(IRule rule, ConfiguredProject configuredProject);
    internal WindowsLocalDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal WindowsLocalDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_LocalDebuggerCommand();
    internal IEvaluatedProperty get_LocalDebuggerCommandArguments();
    internal IEvaluatedProperty get_LocalDebuggerWorkingDirectory();
    internal IEvaluatedProperty get_LocalDebuggerAttach();
    internal IEvaluatedProperty get_LocalDebuggerDebuggerType();
    internal IEvaluatedProperty get_LocalDebuggerEnvironment();
    internal IEvaluatedProperty get_LocalGPUDebuggerTargetType();
    internal IEvaluatedProperty get_GPURefDebuggerBreakOnAllThreads();
    internal IEvaluatedProperty get_LocalDebuggerMergeEnvironment();
    internal IEvaluatedProperty get_LocalDebuggerSQLDebugging();
    internal IEvaluatedProperty get_LocalDebuggerAmpDefaultAccelerator();
    internal IEvaluatedProperty get_EnableVsGraphicsCapture();
    internal IEvaluatedProperty get_UseLegacyManagedDebugger();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
internal class Microsoft.VisualStudio.ProjectSystem.Rules.WindowsRemoteDebugger : object {
    private static Rule deserializedFallbackRule;
    internal static string SchemaName;
    internal static string PrimaryDataSourceItemType;
    internal static string PrimaryDataSourceLabel;
    internal static string RemoteDebuggerCommandProperty;
    internal static string RemoteDebuggerCommandArgumentsProperty;
    internal static string RemoteDebuggerWorkingDirectoryProperty;
    internal static string RemoteDebuggerServerNameProperty;
    internal static string RemoteDebuggerConnectionProperty;
    internal static string RemoteDebuggerDebuggerTypeProperty;
    internal static string RemoteDebuggerEnvironmentProperty;
    internal static string RemoteGPUDebuggerTargetTypeProperty;
    internal static string GPURefDebuggerBreakOnAllThreadsProperty;
    internal static string RemoteDebuggerAttachProperty;
    internal static string RemoteDebuggerSQLDebuggingProperty;
    internal static string DeploymentDirectoryProperty;
    internal static string AdditionalFilesProperty;
    internal static string RemoteDebuggerDeployDebugCppRuntimeProperty;
    internal static string RemoteDebuggerAmpDefaultAcceleratorProperty;
    internal static string UseLegacyManagedDebuggerProperty;
    private IRule rule;
    private string file;
    private string itemType;
    private string itemName;
    private ConfiguredProject configuredProject;
    private IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs;
    private IRule fallbackRule;
    private object locker;
    public IRule Rule { get; }
    internal IEvaluatedProperty RemoteDebuggerCommand { get; }
    internal IEvaluatedProperty RemoteDebuggerCommandArguments { get; }
    internal IEvaluatedProperty RemoteDebuggerWorkingDirectory { get; }
    internal IEvaluatedProperty RemoteDebuggerServerName { get; }
    internal IEvaluatedProperty RemoteDebuggerConnection { get; }
    internal IEvaluatedProperty RemoteDebuggerDebuggerType { get; }
    internal IEvaluatedProperty RemoteDebuggerEnvironment { get; }
    internal IEvaluatedProperty RemoteGPUDebuggerTargetType { get; }
    internal IEvaluatedProperty GPURefDebuggerBreakOnAllThreads { get; }
    internal IEvaluatedProperty RemoteDebuggerAttach { get; }
    internal IEvaluatedProperty RemoteDebuggerSQLDebugging { get; }
    internal IEvaluatedProperty DeploymentDirectory { get; }
    internal IEvaluatedProperty AdditionalFiles { get; }
    internal IEvaluatedProperty RemoteDebuggerDeployDebugCppRuntime { get; }
    internal IEvaluatedProperty RemoteDebuggerAmpDefaultAccelerator { get; }
    internal IEvaluatedProperty UseLegacyManagedDebugger { get; }
    private IRule GeneratedFallbackRule { get; }
    internal WindowsRemoteDebugger(IRule rule);
    internal WindowsRemoteDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, string file, string itemType, string itemName);
    internal WindowsRemoteDebugger(IRule rule, ConfiguredProject configuredProject);
    internal WindowsRemoteDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs, string context, IProjectPropertiesContext propertyContext);
    internal WindowsRemoteDebugger(ConfiguredProject configuredProject, IImmutableDictionary`2<string, IPropertyPagesCatalog> catalogs);
    public IRule get_Rule();
    internal IEvaluatedProperty get_RemoteDebuggerCommand();
    internal IEvaluatedProperty get_RemoteDebuggerCommandArguments();
    internal IEvaluatedProperty get_RemoteDebuggerWorkingDirectory();
    internal IEvaluatedProperty get_RemoteDebuggerServerName();
    internal IEvaluatedProperty get_RemoteDebuggerConnection();
    internal IEvaluatedProperty get_RemoteDebuggerDebuggerType();
    internal IEvaluatedProperty get_RemoteDebuggerEnvironment();
    internal IEvaluatedProperty get_RemoteGPUDebuggerTargetType();
    internal IEvaluatedProperty get_GPURefDebuggerBreakOnAllThreads();
    internal IEvaluatedProperty get_RemoteDebuggerAttach();
    internal IEvaluatedProperty get_RemoteDebuggerSQLDebugging();
    internal IEvaluatedProperty get_DeploymentDirectory();
    internal IEvaluatedProperty get_AdditionalFiles();
    internal IEvaluatedProperty get_RemoteDebuggerDeployDebugCppRuntime();
    internal IEvaluatedProperty get_RemoteDebuggerAmpDefaultAccelerator();
    internal IEvaluatedProperty get_UseLegacyManagedDebugger();
    private IRule get_GeneratedFallbackRule();
    private static IRule GetRule(IPropertyPagesCatalog catalog, string file, string itemType, string itemName);
    private static string GetContextFile(IProjectPropertiesContext propertiesContext);
    private void InitializeFallbackRule();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.SaveOption : Enum {
    public int value__;
    public static SaveOption NoSave;
    public static SaveOption SaveIfDirty;
    public static SaveOption PromptSave;
}
internal static class Microsoft.VisualStudio.ProjectSystem.ServiceCapabilities : object {
    internal static string DiagnosticRuntimeServiceCapability;
    internal static string RetailRuntimeServiceCapability;
    internal static string MetricsCollectionServiceCapability;
    internal static string HonorProjectXmlToolsVersionWhenExists;
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.ServiceProviderExtensions : object {
    [ExtensionAttribute]
public static TInterface GetService(IServiceProvider sp);
}
public class Microsoft.VisualStudio.ProjectSystem.SetEqualityComparer`1 : object {
    private static SetEqualityComparer`1<T> instance;
    public static IEqualityComparer`1<IImmutableSet`1<T>> Default { get; }
    private static SetEqualityComparer`1();
    public static IEqualityComparer`1<IImmutableSet`1<T>> get_Default();
    public sealed virtual bool Equals(IImmutableSet`1<T> x, IImmutableSet`1<T> y);
    public sealed virtual int GetHashCode(IImmutableSet`1<T> obj);
}
internal class Microsoft.VisualStudio.ProjectSystem.SmallCalculationCache`2 : object {
    private object syncObject;
    private CacheData[] cache;
    private int cacheSize;
    private IEqualityComparer`1<TInput> inputComparer;
    private Func`2<TInput, Task`1<TOutput>> calculation;
    private int currentVersion;
    internal SmallCalculationCache`2(int cacheSize, Func`2<TInput, Task`1<TOutput>> calculation, IEqualityComparer`1<TInput> inputComparer);
    internal Task`1<TOutput> CalculateAsync(TInput input);
    private AsyncLazy`1<TOutput> GetLazyValue(TInput input);
    private bool TryGetCachedOutput(TInput input, AsyncLazy`1& output);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.ProjectSystem.SnapshotTools : object {
    public static IProjectChangeDescription CompareSnapshots(IProjectRuleSnapshot before, IProjectRuleSnapshot after, IImmutableList`1<Tuple`2<string, string>> renameHints);
    public static IImmutableDictionary`2<string, IProjectChangeDescription> SynthesizeDiffFromNothing(IImmutableDictionary`2<string, IProjectRuleSnapshot> initialSnapshot);
    [ExtensionAttribute]
public static bool IsEvaluationSucceeded(IProjectRuleSnapshot ruleSnapshot);
    [ExtensionAttribute]
internal static bool IsEmpty(IProjectRuleSnapshot ruleSnapshot);
    [ExtensionAttribute]
internal static bool IsChangedFromEmpty(IProjectSubscriptionUpdate subscriptionUpdate);
    internal static ImmutableDictionary`2<string, string> GetSimpleRenames(IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> beforeItems, IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> afterItems, IImmutableList`1<Tuple`2<string, string>> renameHints);
    internal static ImmutableDictionary`2<string, string> ApplyRenameHints(IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> before, IImmutableDictionary`2<string, IImmutableDictionary`2<string, string>> after, IImmutableList`1<Tuple`2<string, string>> renameHints, ImmutableHashSet`1& addedItems, ImmutableHashSet`1& removedItems);
    [ExtensionAttribute]
private static bool ContainsKeyWithOrdinalStringComparison(IImmutableDictionary`2<string, TValue> dictionary, string key);
    private static bool AddToItemsTouchedByRenames(Dictionary`2<string, Tuple`2<string, string>> itemsTouchedByRename, Tuple`2<string, string> rename);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.ProjectSystem.SpecialFileFlags : Enum {
    public int value__;
    public static SpecialFileFlags CreateIfNotExist;
    public static SpecialFileFlags FullPath;
    public static SpecialFileFlags CheckoutIfExists;
}
public enum Microsoft.VisualStudio.ProjectSystem.SpecialFiles : Enum {
    public int value__;
    public static SpecialFiles AppConfig;
    public static SpecialFiles Licenses;
    public static SpecialFiles WebSettings;
    public static SpecialFiles AppManifest;
    public static SpecialFiles AppDesigner;
    public static SpecialFiles AppSettings;
    public static SpecialFiles AssemblyResource;
    public static SpecialFiles AssemblyInfo;
    public static SpecialFiles AppXaml;
    public static SpecialFiles WcfServiceReferencesConfig;
    public static SpecialFiles AppxManifest;
}
public class Microsoft.VisualStudio.ProjectSystem.StandardActiveConfigurationChangedEventArgs : ActiveConfigurationChangedEventArgs {
    private ConfiguredProject previouslyActive;
    private ConfiguredProject nowActive;
    private int activeConfiguredProjectProviderDataSourceVersion;
    public ConfiguredProject PreviouslyActive { get; }
    public ConfiguredProject NowActive { get; }
    [ObsoleteAttribute]
public int ActiveConfiguredProjectProviderDataSourceVersion { get; }
    public StandardActiveConfigurationChangedEventArgs(ConfiguredProject previouslyActive, ConfiguredProject nowActive, int activeConfiguredProjectProviderDataSourceVersion);
    public virtual ConfiguredProject get_PreviouslyActive();
    public virtual ConfiguredProject get_NowActive();
    public virtual int get_ActiveConfiguredProjectProviderDataSourceVersion();
}
public class Microsoft.VisualStudio.ProjectSystem.StandardFaultChangedEventArgs : FaultChangedEventArgs {
    private bool isFaulted;
    public bool IsFaulted { get; }
    public StandardFaultChangedEventArgs(bool isFaulted);
    public virtual bool get_IsFaulted();
}
internal class Microsoft.VisualStudio.ProjectSystem.StandardItemIdentityChangedEventArgs : ItemIdentityChangedEventArgs {
    private IProjectItem item;
    private string propertySheet;
    private string oldItemType;
    private string newItemType;
    private string oldUnevaluatedInclude;
    private string newUnevaluatedInclude;
    private string oldEvaluatedInclude;
    private string newEvaluatedInclude;
    private bool hasItemTypeChanged;
    private bool hasUnevaluatedIncludeChanged;
    public IProjectItem Item { get; }
    public string PropertySheet { get; }
    public string OldItemType { get; }
    public string NewItemType { get; }
    public string OldUnevaluatedInclude { get; }
    public string NewUnevaluatedInclude { get; }
    public string OldEvaluatedInclude { get; }
    public string NewEvaluatedInclude { get; }
    public bool HasItemTypeChanged { get; }
    public bool HasUnevaluatedIncludeChanged { get; }
    internal StandardItemIdentityChangedEventArgs(IProjectItem item, string propertySheet, string oldItemType, string newItemType, string oldUnevaluatedInclude, string newUnevaluatedInclude, string oldEvaluatedInclude, string newEvaluatedInclude);
    public virtual IProjectItem get_Item();
    public virtual string get_PropertySheet();
    public virtual string get_OldItemType();
    public virtual string get_NewItemType();
    public virtual string get_OldUnevaluatedInclude();
    public virtual string get_NewUnevaluatedInclude();
    public virtual string get_OldEvaluatedInclude();
    public virtual string get_NewEvaluatedInclude();
    public virtual bool get_HasItemTypeChanged();
    public virtual bool get_HasUnevaluatedIncludeChanged();
}
[DebuggerDisplayAttribute("ProjectConfiguration: {Name}")]
public class Microsoft.VisualStudio.ProjectSystem.StandardProjectConfiguration : BaseStandardProjectConfiguration {
    public StandardProjectConfiguration(string name, IImmutableDictionary`2<string, string> dimensions);
    public sealed virtual bool Equals(ProjectConfiguration other);
}
internal static class Microsoft.VisualStudio.ProjectSystem.StringComparers : object {
    internal static IEqualityComparer`1<string> ProjectPropertyName { get; }
    internal static IEqualityComparer`1<string> ProjectPropertyValue { get; }
    internal static IEqualityComparer`1<string> File { get; }
    internal static IEqualityComparer`1<string> MSBuildTargetName { get; }
    internal static IEqualityComparer`1<string> MSBuildItemName { get; }
    internal static IEqualityComparer`1<string> MSBuildItemType { get; }
    internal static IEqualityComparer`1<string> RuleName { get; }
    internal static IEqualityComparer`1<string> Capability { get; }
    internal static IEqualityComparer`1<string> get_ProjectPropertyName();
    internal static IEqualityComparer`1<string> get_ProjectPropertyValue();
    internal static IEqualityComparer`1<string> get_File();
    internal static IEqualityComparer`1<string> get_MSBuildTargetName();
    internal static IEqualityComparer`1<string> get_MSBuildItemName();
    internal static IEqualityComparer`1<string> get_MSBuildItemType();
    internal static IEqualityComparer`1<string> get_RuleName();
    internal static IEqualityComparer`1<string> get_Capability();
}
[AttributeUsageAttribute("388")]
[MetadataAttributeAttribute]
public class Microsoft.VisualStudio.ProjectSystem.SupportedProjectTypeGuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Guid <SupportedProjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCompatibilityCheckLevel <ProjectCompatibilityCheckLevel>k__BackingField;
    public Guid SupportedProjectType { get; private set; }
    public ProjectCompatibilityCheckLevel ProjectCompatibilityCheckLevel { get; }
    public SupportedProjectTypeGuidAttribute(Guid supportedProjectType, ProjectCompatibilityCheckLevel projectCompatibilityCheckLevel);
    public SupportedProjectTypeGuidAttribute(string supportedProjectType, ProjectCompatibilityCheckLevel projectCompatibilityCheckLevel);
    [CompilerGeneratedAttribute]
public Guid get_SupportedProjectType();
    [CompilerGeneratedAttribute]
private void set_SupportedProjectType(Guid value);
    [CompilerGeneratedAttribute]
public ProjectCompatibilityCheckLevel get_ProjectCompatibilityCheckLevel();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("1476")]
public class Microsoft.VisualStudio.ProjectSystem.SupportsFileExtensionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SupportedExtension>k__BackingField;
    public string SupportedExtension { get; private set; }
    public SupportsFileExtensionAttribute(string supportedExtension);
    [CompilerGeneratedAttribute]
public string get_SupportedExtension();
    [CompilerGeneratedAttribute]
private void set_SupportedExtension(string value);
}
internal class Microsoft.VisualStudio.ProjectSystem.SyncContextProtector : ValueType {
    private SynchronizationContext initialSyncContext;
    private SyncContextProtector(SynchronizationContext initialSyncContext);
    public static SyncContextProtector Start();
    public void EnsureIntegrity();
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.ProjectSystem.SyncLinkDataflowLinkOptions : DataflowLinkOptions {
    [CompilerGeneratedAttribute]
private bool <SuppressCapabilitiesRelevance>k__BackingField;
    public bool SuppressCapabilitiesRelevance { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SuppressCapabilitiesRelevance();
    [CompilerGeneratedAttribute]
public void set_SuppressCapabilitiesRelevance(bool value);
    public sealed virtual object Clone();
}
internal class Microsoft.VisualStudio.ProjectSystem.SyncLinkToLink`1 : object {
    private object syncObject;
    private ImmutableList`1<SourceBlockAndLink`1<IProjectValueVersions>> sourceBlocks;
    private ITargetBlock`1<TOut> target;
    private Func`3<IProjectValueVersions[], IImmutableDictionary`2<NamedIdentity, IComparable>, TOut> targetDataConvertion;
    private CancellationToken cancellationToken;
    private IDisposable[] receiveLinks;
    private IProjectValueVersions[] receiveBuffer;
    private IProjectValueVersions[] processingBuffer;
    private TaskCompletionSource`1<bool> completion;
    private bool propagateCompletion;
    private bool suppressCapabilitiesRelevance;
    private CancellationTokenRegistration cancelationTokenRegistration;
    private bool disconnected;
    private bool isCompleted;
    private bool cancellationTokenUnregistered;
    private Exception failedException;
    private bool isProcessingData;
    private int receviedCount;
    private long receivedDataVersion;
    private long processedDataVersion;
    private IImmutableDictionary`2<NamedIdentity, IComparable> lastSubmittedVersions;
    private IProjectValueVersions[] lastSubmittedValues;
    private int completedSourceIndex;
    public SyncLinkToLink`1(ImmutableList`1<SourceBlockAndLink`1<IProjectValueVersions>> sourceBlocks, ITargetBlock`1<TOut> target, Func`3<IProjectValueVersions[], IImmutableDictionary`2<NamedIdentity, IComparable>, TOut> targetDataConvertion, DataflowLinkOptions linkOptions, CancellationToken cancellationToken);
    private string GetLinkDiagnosticName();
    public sealed virtual void Dispose();
    private void EnsureToProcessData();
    private DataflowMessageStatus OfferMessage(int index, IProjectValueVersions messageValue);
    private void ProcessData(bool inline);
    private void CompleteTarget();
    private void CleanupLinks();
    private void CleanupBuffers();
    private void OnSourceCompleted(int sourceIndex, Exception ex);
    private static bool TryFindOlderVersion(IProjectValueVersions[] values, Int32& minimumIndex);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.SyncLinkToLink`1/<EnumerateProjectConfigurationFirst>d__34")]
private static IEnumerable`1<KeyValuePair`2<NamedIdentity, IComparable>> EnumerateProjectConfigurationFirst(IImmutableDictionary`2<NamedIdentity, IComparable> map);
    [CompilerGeneratedAttribute]
private void <ProcessData>b__28_0();
    [CompilerGeneratedAttribute]
private int <ProcessData>g__cleanup|28_1();
    [CompilerGeneratedAttribute]
private int <ProcessData>b__28_2();
}
internal class Microsoft.VisualStudio.ProjectSystem.TaskDelayScheduler : OnceInitializedOnceDisposed {
    private IProjectThreadingService threadingService;
    private JoinableTask latestScheduledTask;
    private TaskCompletionSource`1<bool> latestExecuteNowSource;
    [CompilerGeneratedAttribute]
private TimeSpan <TaskDelayTime>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <PendingUpdateTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <OriginalSourceToken>k__BackingField;
    public TimeSpan TaskDelayTime { get; public set; }
    public bool HasPendingUpdates { get; }
    private CancellationTokenSource PendingUpdateTokenSource { get; private set; }
    private CancellationToken OriginalSourceToken { get; }
    public TaskDelayScheduler(TimeSpan taskDelayTime, IProjectThreadingService threadService, CancellationToken originalSourceToken);
    [CompilerGeneratedAttribute]
public TimeSpan get_TaskDelayTime();
    [CompilerGeneratedAttribute]
public void set_TaskDelayTime(TimeSpan value);
    public bool get_HasPendingUpdates();
    [CompilerGeneratedAttribute]
private CancellationTokenSource get_PendingUpdateTokenSource();
    [CompilerGeneratedAttribute]
private void set_PendingUpdateTokenSource(CancellationTokenSource value);
    [CompilerGeneratedAttribute]
private CancellationToken get_OriginalSourceToken();
    public Task FlushAsync();
    public void ScheduleAsyncTask(Func`2<CancellationToken, Task> asyncFnctionToCall);
    public void CancelPendingUpdates();
    protected virtual void Initialize();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.TaskDelayScheduler/<ThrottleAsync>d__22")]
private Task ThrottleAsync(Func`2<CancellationToken, Task> asyncFnctionToCall, Task executeNowTrigger, CancellationToken token);
    private void ClearPendingUpdates(bool cancel);
}
internal class Microsoft.VisualStudio.ProjectSystem.TaskResults : object {
    internal static Task`1<string> EmptyString;
    internal static Task`1<bool> True;
    internal static Task`1<bool> False;
    private static TaskResults();
    public static Task`1<string> FromResult(string value);
    public static Task`1<bool> FromResult(bool value);
}
internal static class Microsoft.VisualStudio.ProjectSystem.TraceUtilities : object {
    private static int CriticalTraceBufferSize;
    internal static TraceSource Source;
    private static String[] CriticalTraceRotatingBuffer;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) currentTraceIndex;
    internal static SourceLevels CurrentLevel { get; }
    [EditorBrowsableAttribute("1")]
internal static int CurrentTraceIndex { get; }
    [EditorBrowsableAttribute("1")]
internal static String[] CriticalTraceBuffer { get; }
    private static TraceUtilities();
    internal static SourceLevels get_CurrentLevel();
    internal static int get_CurrentTraceIndex();
    internal static String[] get_CriticalTraceBuffer();
    internal static void TraceVerbose(string formattedMessage);
    internal static void TraceVerbose(string unformattedMessage, Object[] args);
    internal static void TraceWarning(string formattedMessage);
    internal static void TraceWarning(string unformattedMessage, Object[] args);
    internal static void TraceError(string formattedMessage);
    internal static void TraceError(string unformattedMessage, Object[] args);
    internal static void TraceException(string formattedMessage, Exception e);
    private static void RecordCriticalMessage(string message);
}
[ProjectSystemContractAttribute("1", "0")]
public interface Microsoft.VisualStudio.ProjectSystem.UnconfiguredProject {
    public string FullPath { get; }
    public bool RequiresReloadForExternalFileChange { get; }
    public IProjectCapabilitiesScope Capabilities { get; }
    public IProjectService ProjectService { get; }
    public IUnconfiguredProjectServices Services { get; }
    public IEnumerable`1<ConfiguredProject> LoadedConfiguredProjects { get; }
    public bool IsLoading { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectUnloading(AsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectUnloading(AsyncEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectRenaming(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectRenaming(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectRenamedOnWriter(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectRenamedOnWriter(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectRenamed(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectRenamed(AsyncEventHandler`1<ProjectRenamedEventArgs> value);
    public abstract virtual string get_FullPath();
    public abstract virtual bool get_RequiresReloadForExternalFileChange();
    public abstract virtual IProjectCapabilitiesScope get_Capabilities();
    public abstract virtual IProjectService get_ProjectService();
    public abstract virtual IUnconfiguredProjectServices get_Services();
    public abstract virtual IEnumerable`1<ConfiguredProject> get_LoadedConfiguredProjects();
    public abstract virtual bool get_IsLoading();
    public abstract virtual Task`1<Encoding> GetFileEncodingAsync();
    public abstract virtual Task SetFileEncodingAsync(Encoding value);
    public abstract virtual Task`1<bool> GetIsDirtyAsync();
    public abstract virtual Task`1<ConfiguredProject> LoadConfiguredProjectAsync(string name, IImmutableDictionary`2<string, string> configurationProperties);
    public abstract virtual Task`1<ConfiguredProject> LoadConfiguredProjectAsync(ProjectConfiguration projectConfiguration);
    public abstract virtual Task`1<ConfiguredProject> GetSuggestedConfiguredProjectAsync();
    public abstract virtual Task`1<bool> CanRenameAsync(string newFilePath);
    public abstract virtual Task RenameAsync(string newFilePath);
    public abstract virtual Task SaveAsync(string filePath);
    public abstract virtual Task SaveCopyAsync(string filePath, Encoding fileEncoding);
    public abstract virtual Task SaveUserFileAsync();
    public abstract virtual Task ReloadAsync(bool immediately);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.UnconfiguredProjectActiveConfigurationChangedEventArgs : EventArgs {
    public bool InvalidConfiguration { get; }
    public abstract virtual bool get_InvalidConfiguration();
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.VisualStudio.ProjectSystem.UnconfiguredProjectAdvanced {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangingProjectFile(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangingProjectFile(EventHandler value);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.UnconfiguredProjectCapabilitiesProviderBase : ProjectCapabilitiesProviderBase {
    [CompilerGeneratedAttribute]
private UnconfiguredProject <UnconfiguredProject>k__BackingField;
    protected UnconfiguredProject UnconfiguredProject { get; private set; }
    protected UnconfiguredProjectCapabilitiesProviderBase(string name, UnconfiguredProject unconfiguredProject);
    [CompilerGeneratedAttribute]
protected UnconfiguredProject get_UnconfiguredProject();
    [CompilerGeneratedAttribute]
private void set_UnconfiguredProject(UnconfiguredProject value);
    protected virtual Task InitializeCoreAsync(CancellationToken cancellationToken);
    protected virtual Task DisposeCoreAsync(bool initialized);
    private void OnChangingProjectXml(object sender, EventArgs args);
}
[ProjectSystemContractAttribute("1", "3")]
internal interface Microsoft.VisualStudio.ProjectSystem.UnconfiguredProjectInternal {
    public IMinimalProjectConfiguration InitialProjectConfiguration { get; public set; }
    public IProjectValueDataSource`1<IReadOnlyCollection`1<ConfiguredProject>> LoadedConfiguredProjectsDataSource { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChangingProjectFileDependencies(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChangingProjectFileDependencies(EventHandler value);
    public abstract virtual IMinimalProjectConfiguration get_InitialProjectConfiguration();
    public abstract virtual void set_InitialProjectConfiguration(IMinimalProjectConfiguration value);
    public abstract virtual IProjectValueDataSource`1<IReadOnlyCollection`1<ConfiguredProject>> get_LoadedConfiguredProjectsDataSource();
    public abstract virtual Task ReportProgressAsync(ProjectLoadCheckpoint checkpoint);
    public abstract virtual Task`1<bool> IsReloadRequiredAsync(CancellationToken cancellationToken);
    public abstract virtual Task RenameCompanionFileAsync(string oldCompanionFileFullPath, string newCompanionFilePath);
    public abstract virtual void SetProjectLoadingVetoResult(bool isVetoed);
    public abstract virtual Task`1<bool> IsProjectLoadingVetoedAsync();
    public abstract virtual string MakeRooted(string path);
    public abstract virtual Task WaitForCheckPointAsync(ProjectLoadCheckpoint checkpoint);
    public abstract virtual void ClearDirtyState();
}
internal static class Microsoft.VisualStudio.ProjectSystem.UnlocalizedStrings : object {
    internal static string InternalCpsErrorCausedInconsistentState;
}
public class Microsoft.VisualStudio.ProjectSystem.UnwrapChainedProjectValueDataSource`2 : UnwrapChainedProjectValueDataSourceBase`2<TInput, TOutput> {
    private Func`2<TInput, IProjectValueDataSource`1<TOutput>> getDataSource;
    private bool includeSourceVersions;
    private IProjectValueDataSource`1<TOutput> currentDataSource;
    private StrongBox`1<IImmutableDictionary`2<NamedIdentity, IComparable>> versionBox;
    public UnwrapChainedProjectValueDataSource`2(IProjectCommonServices commonServices, Func`2<TInput, IProjectValueDataSource`1<TOutput>> getDataSource, bool synchronousDisposal, bool includeSourceVersions);
    protected virtual IDisposable CreateOrUpdateLink(IProjectVersionedValue`1<TInput> sourceData, IImmutableDictionary`2<NamedIdentity, IComparable> linkVersion, ITargetBlock`1<IProjectVersionedValue`1<TOutput>> targetBlock, IDisposable currentLink);
}
public abstract class Microsoft.VisualStudio.ProjectSystem.UnwrapChainedProjectValueDataSourceBase`2 : ChainedProjectValueDataSourceBase`1<TOutput> {
    private object syncObject;
    private NamedIdentity sequenceNumberId;
    private ActionBlock`1<IProjectVersionedValue`1<TInput>> inputDataBlock;
    private int currentSourceSequenceNumber;
    private bool isCompleted;
    private Exception faultException;
    private Task System.Threading.Tasks.Dataflow.IDataflowBlock.Completion { get; }
    protected UnwrapChainedProjectValueDataSourceBase`2(IProjectCommonServices commonServices, bool synchronousDisposal);
    private sealed virtual override Task System.Threading.Tasks.Dataflow.IDataflowBlock.get_Completion();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<Microsoft.VisualStudio.ProjectSystem.IProjectVersionedValue<TInput>>.OfferMessage(DataflowMessageHeader messageHeader, IProjectVersionedValue`1<TInput> messageValue, ISourceBlock`1<IProjectVersionedValue`1<TInput>> source, bool consumeToAccept);
    protected virtual IDisposable LinkExternalInput(ITargetBlock`1<IProjectVersionedValue`1<TOutput>> targetBlock);
    protected abstract virtual IDisposable CreateOrUpdateLink(IProjectVersionedValue`1<TInput> sourceData, IImmutableDictionary`2<NamedIdentity, IComparable> linkVersion, ITargetBlock`1<IProjectVersionedValue`1<TOutput>> targetBlock, IDisposable currentLink);
}
public class Microsoft.VisualStudio.ProjectSystem.UnwrapCollectionChainedProjectValueDataSource`2 : UnwrapChainedProjectValueDataSourceBase`2<TInput, IReadOnlyCollection`1<TOutput>> {
    private Func`2<TInput, IEnumerable`1<IProjectValueDataSource`1<TOutput>>> getDataSources;
    private bool includeSourceVersions;
    private IReadOnlyCollection`1<IProjectValueDataSource`1<TOutput>> currentDataSources;
    private StrongBox`1<IImmutableDictionary`2<NamedIdentity, IComparable>> versionBox;
    public UnwrapCollectionChainedProjectValueDataSource`2(IProjectCommonServices commonServices, Func`2<TInput, IEnumerable`1<IProjectValueDataSource`1<TOutput>>> getDataSource, bool synchronousDisposal, bool includeSourceVersions);
    protected virtual IDisposable CreateOrUpdateLink(IProjectVersionedValue`1<TInput> sourceData, IImmutableDictionary`2<NamedIdentity, IComparable> linkVersion, ITargetBlock`1<IProjectVersionedValue`1<IReadOnlyCollection`1<TOutput>>> targetBlock, IDisposable currentLink);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.ProjectSystem.UtilityStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AbsolutePathExpected { get; }
    internal static string AbsolutePathRequired { get; }
    internal static string Argument_EmptyArray { get; }
    internal static string Argument_EmptyString { get; }
    internal static string Argument_NullElement { get; }
    internal static string Argument_Whitespace { get; }
    internal static string BeforeAfterConstraintContradiction { get; }
    internal static string BuildDisabled { get; }
    internal static string CannotRemoveImplicitImport { get; }
    internal static string CannotSaveProjectOutsideProjectDirectory { get; }
    internal static string CapabilitiesNotYetReady { get; }
    internal static string CollectionCannotBeEmpty { get; }
    internal static string DataFlowFaults { get; }
    internal static string DataflowLinkOptionsOrCloneable { get; }
    internal static string DefaultCloseText { get; }
    internal static string DefaultConsentDialogBody { get; }
    internal static string DefaultConsentDialogHeader { get; }
    internal static string DefaultOfflineSolutionCheckText { get; }
    internal static string DefaultOnlineSolutionCheckText { get; }
    internal static string DelimitedStringListMissingDelimiterAfterQuote { get; }
    internal static string DelimitedStringMissingClosingQuote { get; }
    internal static string DelimiterCannotBeQuoteCharacter { get; }
    internal static string DeprecatedMethod { get; }
    internal static string DuplicateFolderProjectItem { get; }
    internal static string DuplicateKey { get; }
    internal static string DuplicateLinkedProjectItem { get; }
    internal static string ImportCardinalityMismatchExpectsAtLeastOne { get; }
    internal static string ImportCardinalityMismatchExpectsAtMostOne { get; }
    internal static string ImportCardinalityMismatchExpectsExactlyOne { get; }
    internal static string IncompatibleSnapshots { get; }
    internal static string InternalExceptionMessage { get; }
    internal static string InvalidCapabilityExpressionWithPosition { get; }
    internal static string InvalidEmptyOperation { get; }
    internal static string InvalidProjectItemWithTrailingSlash { get; }
    internal static string InvalidPropertyValue { get; }
    internal static string InvalidStringToValueConversion { get; }
    internal static string InvalidTypeConversion { get; }
    internal static string InvalidValueToStringConversion { get; }
    internal static string InvalidWhileWriteLockHeld { get; }
    internal static string ItemTypeNotSupported { get; }
    internal static string KeyNotFound { get; }
    internal static string NoComponentImplementationFound { get; }
    internal static string NoItemTypeForRule { get; }
    internal static string NotSupportedReadOnlyCollection { get; }
    internal static string ParameterCannotBeNull { get; }
    internal static string ParameterCannotHaveZeroLength { get; }
    internal static string ParameterContainsInvalidCharacters { get; }
    internal static string ParameterListHadNullElement { get; }
    internal static string ParameterMustEndWithAnySubstringSuffix { get; }
    internal static string ParameterOutOfRange { get; }
    internal static string ParameterPathMustBeRooted { get; }
    internal static string ParameterPathMustIncludeFileName { get; }
    internal static string ParametersMustHaveTheSameLength { get; }
    internal static string ParameterWrongConcreteType { get; }
    internal static string PathCannotEndWithSeperator { get; }
    internal static string ProjectFileIsInvalid { get; }
    internal static string ProjectFilePathEmptyOrWhitespace { get; }
    internal static string ProjectHasNoFilename { get; }
    internal static string ProjectItemNotFound { get; }
    internal static string ProjectRenameNotAllowed { get; }
    internal static string PropertyMissing { get; }
    internal static string RuleMissing { get; }
    internal static string RulePropertyMissing { get; }
    internal static string ServiceMissing { get; }
    internal static string ThereMustBeAtleastOneDimensionInAProjectConfiguration { get; }
    internal static string TooManyComponentImplementationsFound { get; }
    internal static string TreeUpdateRejected { get; }
    internal static string TypeConversionAlreadyMapped { get; }
    internal static string UnbalancedQuotes { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AbsolutePathExpected();
    internal static string get_AbsolutePathRequired();
    internal static string get_Argument_EmptyArray();
    internal static string get_Argument_EmptyString();
    internal static string get_Argument_NullElement();
    internal static string get_Argument_Whitespace();
    internal static string get_BeforeAfterConstraintContradiction();
    internal static string get_BuildDisabled();
    internal static string get_CannotRemoveImplicitImport();
    internal static string get_CannotSaveProjectOutsideProjectDirectory();
    internal static string get_CapabilitiesNotYetReady();
    internal static string get_CollectionCannotBeEmpty();
    internal static string get_DataFlowFaults();
    internal static string get_DataflowLinkOptionsOrCloneable();
    internal static string get_DefaultCloseText();
    internal static string get_DefaultConsentDialogBody();
    internal static string get_DefaultConsentDialogHeader();
    internal static string get_DefaultOfflineSolutionCheckText();
    internal static string get_DefaultOnlineSolutionCheckText();
    internal static string get_DelimitedStringListMissingDelimiterAfterQuote();
    internal static string get_DelimitedStringMissingClosingQuote();
    internal static string get_DelimiterCannotBeQuoteCharacter();
    internal static string get_DeprecatedMethod();
    internal static string get_DuplicateFolderProjectItem();
    internal static string get_DuplicateKey();
    internal static string get_DuplicateLinkedProjectItem();
    internal static string get_ImportCardinalityMismatchExpectsAtLeastOne();
    internal static string get_ImportCardinalityMismatchExpectsAtMostOne();
    internal static string get_ImportCardinalityMismatchExpectsExactlyOne();
    internal static string get_IncompatibleSnapshots();
    internal static string get_InternalExceptionMessage();
    internal static string get_InvalidCapabilityExpressionWithPosition();
    internal static string get_InvalidEmptyOperation();
    internal static string get_InvalidProjectItemWithTrailingSlash();
    internal static string get_InvalidPropertyValue();
    internal static string get_InvalidStringToValueConversion();
    internal static string get_InvalidTypeConversion();
    internal static string get_InvalidValueToStringConversion();
    internal static string get_InvalidWhileWriteLockHeld();
    internal static string get_ItemTypeNotSupported();
    internal static string get_KeyNotFound();
    internal static string get_NoComponentImplementationFound();
    internal static string get_NoItemTypeForRule();
    internal static string get_NotSupportedReadOnlyCollection();
    internal static string get_ParameterCannotBeNull();
    internal static string get_ParameterCannotHaveZeroLength();
    internal static string get_ParameterContainsInvalidCharacters();
    internal static string get_ParameterListHadNullElement();
    internal static string get_ParameterMustEndWithAnySubstringSuffix();
    internal static string get_ParameterOutOfRange();
    internal static string get_ParameterPathMustBeRooted();
    internal static string get_ParameterPathMustIncludeFileName();
    internal static string get_ParametersMustHaveTheSameLength();
    internal static string get_ParameterWrongConcreteType();
    internal static string get_PathCannotEndWithSeperator();
    internal static string get_ProjectFileIsInvalid();
    internal static string get_ProjectFilePathEmptyOrWhitespace();
    internal static string get_ProjectHasNoFilename();
    internal static string get_ProjectItemNotFound();
    internal static string get_ProjectRenameNotAllowed();
    internal static string get_PropertyMissing();
    internal static string get_RuleMissing();
    internal static string get_RulePropertyMissing();
    internal static string get_ServiceMissing();
    internal static string get_ThereMustBeAtleastOneDimensionInAProjectConfiguration();
    internal static string get_TooManyComponentImplementationsFound();
    internal static string get_TreeUpdateRejected();
    internal static string get_TypeConversionAlreadyMapped();
    internal static string get_UnbalancedQuotes();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.ProjectSystem.VCStringUtilities : object {
    internal static string NoInherit;
    internal static string Inherit;
    private static char Quote;
    private static Char[] CharactersToEscapePreservingMacros;
    private static Dictionary`2<string, string> escapingSequences;
    private static Dictionary`2<string, string> EscapingSequences { get; }
    private static VCStringUtilities();
    private static Dictionary`2<string, string> get_EscapingSequences();
    internal static IEnumerable`1<string> GetItemsFromVCProjList(string unevaluatedStringList, Char[] delimiters);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.VCStringUtilities/<GetItemsFromMSBuildList>d__8")]
internal static IEnumerable`1<string> GetItemsFromMSBuildList(string unevaluatedStringList);
    internal static string TrimMSBuildList(string unevaluatedStringList);
    internal static string AssembleMSBuildStringList(IEnumerable`1<string> items);
    internal static string AssembleVCProjStringList(IEnumerable`1<string> items, Char[] delimiters);
    internal static IEnumerable`1<string> GetMsBuildInheritance(IEvaluatedProperty property, IEnumerable`1<string> vcprojItems);
    internal static IEnumerable`1<string> GetMsBuildInheritance(string propertyName, IEnumerable`1<string> vcprojItems, PropertyKind location);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.VCStringUtilities/<GetMsBuildInheritance>d__14")]
internal static IEnumerable`1<string> GetMsBuildInheritance(IEnumerable`1<string> vcprojItems, string msbuildInheritToken);
    internal static IEnumerable`1<string> GetVCProjInheritance(IEvaluatedProperty property, IEnumerable`1<string> msbuildItems);
    internal static IEnumerable`1<string> GetVCProjInheritance(string propertyName, IEnumerable`1<string> msbuildItems, PropertyKind location);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.VCStringUtilities/<GetVCProjInheritance>d__17")]
internal static IEnumerable`1<string> GetVCProjInheritance(IEnumerable`1<string> msbuildItems, string msbuildInheritToken);
    internal static string GetVCProjInheritanceNonList(string msbuildValue, string msbuildInheritToken);
    internal static string GetVCProjInheritanceNonList(string msbuildValue, string msbuildInheritToken, string vcprojSeparator);
    internal static string GetMsBuildInheritanceNonList(string vcprojValue, string msbuildInheritToken);
    internal static string GetMsBuildInheritanceNonList(string vcprojValue, string msbuildInheritToken, string msbuildSeparator);
    internal static string EscapePreservingMacros(string value);
    internal static string GetMSBuildInheritanceToken(string propertyName, PropertyKind location);
    internal static string GetValueWithoutInheritanceToken(string value, string inheritanceToken);
    internal static string GetValueWithInheritanceToken(string value, string inheritanceToken);
    internal static void SplitPathUnevaluatedParts(string unevaluatedPath, Func`2<string, string> expansion, String& unevaluatedDirectory, String& unevaluatedFilename, String& unevaluatedExtension);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.VCStringUtilities/<TokenizeUnevaluatedString>d__27")]
internal static IEnumerable`1<string> TokenizeUnevaluatedString(string unevaluatedValue);
    internal static String[] TokenMatcher(String[] expandedTokens, IEnumerator`1<string> unexpandedTokens, Func`2<string, string> expansion, StringComparison comparison);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.VCStringUtilities/<SplitRespectingQuotes>d__29")]
internal static IEnumerable`1<string> SplitRespectingQuotes(string stringList, Char[] delimiters);
    internal static string RemoveUnescapedQuotes(string value);
    internal static string TrimSurroundingQuotes(string value);
    [ExtensionAttribute]
internal static string ReplaceIgnoreCase(string stringToSearch, string substringToFind, string replacementString);
    internal static string CreateSafeXmlTagName(string source);
    private static int CountCharacters(string value, char characterToMatch);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.ProjectSystem.WeakKeyDictionary`2 : object {
    [DebuggerBrowsableAttribute("3")]
private Dictionary`2<WeakReference`1<TKey, TValue, TKey>, TValue> dictionary;
    private IEqualityComparer`1<TKey> keyComparer;
    [DebuggerBrowsableAttribute("0")]
private int capacity;
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    public TValue Item { get; public set; }
    public WeakKeyDictionary`2(IEqualityComparer`1<TKey> keyComparer, int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public int Scavenge();
    public void Clear();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.ProjectSystem.WeakKeyDictionary`2/<GetEnumerator>d__14")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
