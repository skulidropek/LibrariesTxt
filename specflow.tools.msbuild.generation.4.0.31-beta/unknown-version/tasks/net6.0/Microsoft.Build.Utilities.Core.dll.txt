[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    private int capacity;
    private CopyOnWriteBackingDictionary`2<K, V, K, V> backing;
    [CompilerGeneratedAttribute]
private static CopyOnWriteDictionary`2<K, V> <Dummy>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<K> <Comparer>k__BackingField;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; private set; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> ReadOperation { get; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> WriteOperation { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`2(CopyOnWriteDictionary`2<K, V> that);
    public CopyOnWriteDictionary`2(IDictionary`2<K, V> dictionary);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [CompilerGeneratedAttribute]
internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<K> get_Comparer();
    [CompilerGeneratedAttribute]
private void set_Comparer(IEqualityComparer`1<K> value);
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_ReadOperation();
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_WriteOperation();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    private object store;
    private IEqualityComparer`1<TKey> comparer;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    private void AddToOrUpdateList(List`1<KeyValuePair`2<TKey, TValue>> list, TKey key, TValue value, bool throwIfPresent);
}
internal interface Microsoft.Build.Collections.IConstrainedEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y, int indexY, int length);
    public abstract virtual int GetHashCode(T obj, int index, int length);
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : object {
    private static ProcessorArchitectures s_runningProcessorArchitecture;
    [CompilerGeneratedAttribute]
private static MSBuildNameIgnoreCaseComparer <Default>k__BackingField;
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    private static MSBuildNameIgnoreCaseComparer();
    [CompilerGeneratedAttribute]
internal static MSBuildNameIgnoreCaseComparer get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public sealed virtual int GetHashCode(string obj, int start, int length);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal static class Microsoft.Build.OpportunisticIntern : object {
    private static bool s_useSimpleConcurrency;
    private static int s_smallMruSize;
    private static int s_largeMruSize;
    private static int s_hugeMruSize;
    private static int s_smallMruThreshold;
    private static int s_largeMruThreshold;
    private static int s_hugeMruThreshold;
    private static int s_ginormousThreshold;
    private static BucketedPrioritizedStringList s_si;
    private static BucketedPrioritizedStringList s_whatIfInfinite;
    private static BucketedPrioritizedStringList s_whatIfDoubled;
    private static BucketedPrioritizedStringList s_whatIfHalved;
    private static BucketedPrioritizedStringList s_whatIfZero;
    private static OpportunisticIntern();
    internal static int AssignViaEnvironment(string env, int default);
    internal static void EnableStatisticsGathering();
    internal static string InternableToString(IInternable candidate);
    internal static string StringBuilderToString(StringBuilder candidate);
    internal static string CharArrayToString(Char[] candidate, int count);
    internal static string CharArrayToString(Char[] candidate, int startIndex, int count);
    internal static string InternStringIfPossible(string candidate);
    internal static void ReportStatistics();
}
[DataContractAttribute]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection : object {
    [CompilerGeneratedAttribute]
private List`1<AssemblyFolderItem> <AssemblyFolders>k__BackingField;
    [DataMemberAttribute]
internal List`1<AssemblyFolderItem> AssemblyFolders { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<AssemblyFolderItem> get_AssemblyFolders();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolders(List`1<AssemblyFolderItem> value);
    internal static AssemblyFolderCollection Load(string filePath);
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{Name}: FrameworkVersion = {FrameworkVersion}, Platform = {Platform}, Path= {Path}")]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [DataMemberAttribute]
internal string Name { get; internal set; }
    [DataMemberAttribute]
internal string FrameworkVersion { get; internal set; }
    [DataMemberAttribute]
internal string Path { get; internal set; }
    [DataMemberAttribute]
internal string Platform { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
internal void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
internal string get_Platform();
    [CompilerGeneratedAttribute]
internal void set_Platform(string value);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <PrimaryResources>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <SharedResources>k__BackingField;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_PrimaryResources();
    [CompilerGeneratedAttribute]
internal static ResourceManager get_SharedResources();
    internal static string FormatString(string unformatted, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AssemblyUtilities : object {
    private static bool s_initialized;
    private static PropertyInfo s_assemblylocationProperty;
    private static MethodInfo s_cultureInfoGetCultureMethod;
    private static Lazy`1<CultureInfo[]> s_validCultures;
    private static Lazy`1<Assembly> s_entryAssembly;
    public static Assembly EntryAssembly { get; }
    private static AssemblyUtilities();
    public static Assembly get_EntryAssembly();
    public static string GetAssemblyLocation(Assembly assembly);
    [ExtensionAttribute]
public static AssemblyName CloneIfPossible(AssemblyName assemblyNameToClone);
    public static bool CultureInfoHasGetCultures();
    public static CultureInfo[] GetAllCultures();
    private static void Initialize();
    private static Assembly GetEntryAssembly();
    private static CultureInfo[] GetValidCultures();
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    private static Encoding s_currentOemEncoding;
    internal static Encoding CurrentSystemOemEncoding { get; }
    internal static Encoding get_CurrentSystemOemEncoding();
    [ExtensionAttribute]
internal static bool SimilarToEncoding(Encoding encoding1, Encoding encoding2);
    [ExtensionAttribute]
internal static bool IsUtf8Encoding(Encoding encoding);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream, Byte[] preamble);
    internal static bool FileStartsWithPreamble(string file);
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_throwExceptions;
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    private static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EscapingStringExtensions.EscapingStringExtensions : object {
    [ExtensionAttribute]
internal static string Unescape(string escapedString);
    [ExtensionAttribute]
internal static string Unescape(string escapedString, Boolean& escapingWasNecessary);
    [ExtensionAttribute]
internal static string Escape(string unescapedString);
    [ExtensionAttribute]
internal static bool ContainsEscapedWildcards(string escapedString);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    private static bool IsHexDigit(char character);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static String[] s_newLines;
    private static EventArgsFormatting();
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    private static String[] SplitStringOnNewLines(string s);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    [CompilerGeneratedAttribute]
private string <RegistryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    internal string RegistryKey { get; }
    internal Version TargetFrameworkVersion { get; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string dotdot;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    internal static Char[] directorySeparatorCharacters;
    internal static String[] directorySeparatorStrings;
    private static Lazy`1<ConcurrentDictionary`2<string, ImmutableArray`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, ImmutableArray`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, ImmutableArray`1<string>> fileEntryExpansionCache);
    public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, ImmutableArray`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    private static ImmutableArray`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static ImmutableArray`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__33")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__35")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    private static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, String& matchFileExpression, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsMatch(string input, string pattern, bool ignoreCase);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    internal String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    private static bool IsSlash(char c);
    private static int SkipCharacters(string aString, int startingIndex, Func`2<char, bool> jumpOverCharacter);
    internal static bool IsValidDriveChar(char value);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private String[] GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|49_0(char inputChar, char patternChar, int iIndex, int pIndex, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static bool <ComputeFileEnumerationCacheKey>g__FilespecIsAnAbsoluteGlobPointingOutsideOfProjectCone|54_0(string projectDirectory, string filespec);
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool DirectoryEntryExists(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <DirectoryEntryExists>b__3_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__4_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__5_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : object {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    private static Char[] Slashes;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    internal static string ExecutingAssemblyPath { get; }
    private static FileUtilities();
    internal static void ClearCacheDirectoryPath();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    private static bool IsUNCPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    private static Uri CreateUriFromPath(string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName);
    internal static string GetPathOfFileAbove(string file, string startingDirectory);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
    internal static string GetTemporaryDirectory(bool createDirectory);
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string dotNetFrameworkIdentifier;
    internal static Version dotNetFrameworkVersion11;
    internal static Version dotNetFrameworkVersion20;
    internal static Version dotNetFrameworkVersion30;
    internal static Version dotNetFrameworkVersion35;
    internal static Version dotNetFrameworkVersion40;
    internal static Version dotNetFrameworkVersion45;
    internal static Version dotNetFrameworkVersion451;
    internal static Version dotNetFrameworkVersion452;
    internal static Version dotNetFrameworkVersion46;
    internal static Version dotNetFrameworkVersion461;
    internal static Version dotNetFrameworkVersion462;
    internal static Version dotNetFrameworkVersion47;
    internal static Version dotNetFrameworkVersion471;
    internal static Version dotNetFrameworkVersion472;
    internal static Version visualStudioVersion100;
    internal static Version visualStudioVersion110;
    internal static Version visualStudioVersion120;
    internal static Version visualStudioVersion140;
    internal static Version visualStudioVersion150;
    internal static Version visualStudioVersionLatest;
    private static string dotNetFrameworkRegistryPath;
    private static string dotNetFrameworkSetupRegistryPath;
    private static string dotNetFrameworkSetupRegistryInstalledName;
    internal static string fullDotNetFrameworkRegistryKey;
    private static string dotNetFrameworkAssemblyFoldersRegistryPath;
    private static string referenceAssembliesRegistryValueName;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    private static string dotNetFrameworkVersionV11;
    private static string dotNetFrameworkRegistryKeyV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    private static string dotNetFrameworkVersionV20;
    private static string dotNetFrameworkRegistryKeyV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    private static string s_dotNetFrameworkRegistryKeyV30;
    private static string fallbackDotNetFrameworkSdkRegistryInstallPath;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    private static string s_dotNetFrameworkRegistryKeyV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    private static string ToolsVersionsRegistryPath;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    private static string s_fallbackDotNetFrameworkSdkInstallPath;
    private static string s_pathToV35ToolsInFallbackDotNetFrameworkSdk;
    private static string s_pathToV4ToolsInFallbackDotNetFrameworkSdk;
    private static DotNetFrameworkSpec[] s_dotNetFrameworkSpecs;
    private static VisualStudioSpec[] s_visualStudioSpecs;
    private static Tuple`2[0...,0...] s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools;
    private static IReadOnlyDictionary`2<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;
    private static IReadOnlyDictionary`2<Version, VisualStudioSpec> s_visualStudioSpecDict;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    private static string FallbackDotNetFrameworkSdkInstallPath { get; }
    private static string PathToV35ToolsInFallbackDotNetFrameworkSdk { get; }
    private static string PathToV4ToolsInFallbackDotNetFrameworkSdk { get; }
    private static FrameworkLocationHelper();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    private static string get_FallbackDotNetFrameworkSdkInstallPath();
    private static string get_PathToV35ToolsInFallbackDotNetFrameworkSdk();
    private static string get_PathToV4ToolsInFallbackDotNetFrameworkSdk();
    internal static string GetDotNetFrameworkSdkRootRegistryKey(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkSdkInstallKeyValue(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkVersionFolderPrefix(Version dotNetFrameworkVersion);
    internal static string GetPathToWindowsSdk(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkReferenceAssemblies(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkSdkTools(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkSdk(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
    internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture);
    internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootPath, FrameworkName frameworkName);
    internal static string RemoveDirectories(string path, int numberOfLevelsToRemove);
    private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture);
    private static string GenerateReferenceAssemblyDirectory(string versionPrefix);
    private static VisualStudioSpec GetVisualStudioSpec(Version version);
    private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version);
    private static DotNetFrameworkSpec CreateDotNetFrameworkSpecForV4(Version version, Version visualStudioVersion);
    private static void RedirectVersionsIfNecessary(Version& dotNetFrameworkVersion, Version& visualStudioVersion);
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
    private static void ConsiderDebuggerLaunch(string message, Exception innerException);
    private static void LaunchDebugger(string message, string innerMessage);
    private static bool RunningTests();
}
internal static class Microsoft.Build.Shared.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
}
internal static class Microsoft.Build.Shared.MSBuildConstants : object {
    internal static string ToolsPath;
    internal static string ToolsPath64;
    internal static string SdksPath;
    internal static string TreatWarningsAsErrors;
    internal static string WarningsAsErrors;
    internal static string WarningsAsMessages;
    internal static string NuGetAssemblyPathEnvironmentVariableName;
    internal static string RestoreTargetName;
    internal static string CurrentVisualStudioVersion;
    internal static string CurrentToolsVersion;
    internal static string MSBuildDummyGlobalPropertyHeader;
    internal static Version CurrentToolsVersionAsVersion;
    internal static string CurrentAssemblyVersion;
    internal static string CurrentProductVersion { get; }
    private static MSBuildConstants();
    internal static string get_CurrentProductVersion();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_ACCESS_DENIED;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int MAX_PATH;
    private static string kernel32Dll;
    private static string mscoreeDLL;
    private static string WINDOWS_FILE_SYSTEM_REGISTRY_KEY;
    private static string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME;
    internal static IntPtr NullIntPtr;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static CharSet AutoOrUnicode;
    private static MaxPathLimits osMaxPathLimit;
    private static object osMaxPathLimitLock;
    private static bool s_isUnixLike;
    private static object IsMonoLock;
    private static Nullable`1<bool> _isMono;
    private static string s_frameworkBasePath;
    private static string s_frameworkCurrentPath;
    private static SystemInformationData _systemInformation;
    private static bool _systemInformationInitialized;
    private static object SystemInformationLock;
    private static Version s_threadErrorModeMinOsVersion;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_ATTRIBUTE_NORMAL;
    internal static UInt32 FILE_FLAG_OPEN_REPARSE_POINT;
    internal static UInt32 OPEN_EXISTING;
    internal static MaxPathLimits OSMaxPathLimit { get; }
    internal static bool IsUnixLike { get; }
    internal static bool IsLinux { get; }
    internal static bool IsBSD { get; }
    internal static bool IsMono { get; }
    internal static bool IsWindows { get; }
    internal static bool IsOSX { get; }
    internal static string OSName { get; }
    internal static string FrameworkCurrentPath { get; }
    internal static string FrameworkBasePath { get; }
    private static SystemInformationData SystemInformation { get; }
    internal static ProcessorArchitectures ProcessorArchitecture { get; }
    internal static ProcessorArchitectures ProcessorArchitectureNative { get; }
    private static NativeMethodsShared();
    internal static MaxPathLimits get_OSMaxPathLimit();
    private static void SetOSMaxPathLimit();
    private static bool IsMaxPathLimitLegacyWindows();
    private static bool IsLongPathsEnabledRegistry();
    internal static bool get_IsUnixLike();
    internal static bool get_IsLinux();
    internal static bool get_IsBSD();
    internal static bool get_IsMono();
    internal static bool get_IsWindows();
    internal static bool get_IsOSX();
    internal static string get_OSName();
    internal static string GetOSNameForExtensionsPath();
    internal static string get_FrameworkCurrentPath();
    internal static string get_FrameworkBasePath();
    private static SystemInformationData get_SystemInformation();
    internal static ProcessorArchitectures get_ProcessorArchitecture();
    internal static ProcessorArchitectures get_ProcessorArchitectureNative();
    internal static int SetErrorMode(int newMode);
    private static bool SetErrorMode_Win7AndNewer(int newMode, Int32& oldMode);
    private static int SetErrorMode_VistaAndOlder(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    private static DateTime GetContentLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static void KillTree(int processIdToKill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    private static int GetCurrentDirectoryWin32(int nBufferLength, Char* lpBuffer);
    internal static string GetFullPath(string path);
    private static int GetFullPathWin32(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static bool AreStringsEqual(Char* buffer, int len, string s);
    internal static void VerifyThrowWin32Result(int result);
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    private static UInt32 SearchPath(string path, string fileName, string extension, int numBufferChars, StringBuilder buffer, Int32[] filePart);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(IntPtr hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, Char* lpBuffer);
    internal static bool SetCurrentDirectoryWindows(string path);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    private static int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, PROCESS_BASIC_INFORMATION& pbi, int cb, Int32& pSize);
    private static bool GlobalMemoryStatusEx(MemoryStatus lpBuffer);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool GetFileTime(SafeFileHandle hFile, FILETIME& lpCreationTime, FILETIME& lpLastAccessTime, FILETIME& lpLastWriteTime);
    internal static bool CloseHandle(IntPtr hObject);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
    internal static bool DirectoryExists(string fullPath);
    internal static bool DirectoryExistsWindows(string fullPath);
    internal static bool FileExists(string fullPath);
    internal static bool FileExistsWindows(string fullPath);
    internal static bool FileOrDirectoryExists(string path);
    internal static bool FileOrDirectoryExistsWindows(string path);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal class Microsoft.Build.Shared.VisualStudioInstance : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal Version Version { get; }
    internal string Path { get; }
    internal string Name { get; }
    internal VisualStudioInstance(string name, string path, Version version);
    [CompilerGeneratedAttribute]
internal Version get_Version();
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_Name();
}
internal class Microsoft.Build.Shared.VisualStudioLocationHelper : object {
    private static int REGDB_E_CLASSNOTREG;
    internal static IList`1<VisualStudioInstance> GetInstances();
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig : object {
    private List`1<AssemblyFoldersFromConfigInfo> _directoryNames;
    internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersion, ProcessorArchitecture targetArchitecture);
    private void FindDirectories(List`1<AssemblyFolderItem> assemblyTargets, Func`2<AssemblyFolderItem, bool> platformFilter);
    private static List`1<AssemblyFolderItem> GatherVersionStrings(string targetRuntimeVersion, AssemblyFolderCollection collection);
    private static Version GetFrameworkVersion(string version);
    private sealed virtual override IEnumerator`1<AssemblyFoldersFromConfigInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Utilities.ApiContract : ValueType {
    internal string Name;
    internal string Version;
    private ApiContract(string name, string version);
    internal static bool IsContainedApiContractsElement(string elementName);
    internal static bool IsVersionedContentElement(string elementName);
    internal static void ReadContractsElement(XmlElement element, ICollection`1<ApiContract> apiContracts);
}
[DebuggerDisplayAttribute("DirectoryPath: {DirectoryPath}, TargetFrameworkVersion = {TargetFrameworkVersion}")]
public class Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo : object {
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    public string DirectoryPath { get; }
    public Version TargetFrameworkVersion { get; }
    public AssemblyFoldersFromConfigInfo(string directoryPath, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public Version get_TargetFrameworkVersion();
}
public class Microsoft.Build.Utilities.CommandLineBuilder : object {
    [CompilerGeneratedAttribute]
private StringBuilder <CommandLine>k__BackingField;
    private static string s_allowedUnquotedRegexNoHyphen;
    private static string s_definitelyNeedQuotesRegexWithHyphen;
    private static string s_allowedUnquotedRegexWithHyphen;
    private static string s_definitelyNeedQuotesRegexNoHyphen;
    private bool _quoteHyphens;
    private bool _useNewLineSeparator;
    private Regex _allowedUnquoted;
    private Regex _definitelyNeedQuotes;
    public int Length { get; }
    protected StringBuilder CommandLine { get; }
    private Regex DefinitelyNeedQuotes { get; }
    private Regex AllowedUnquoted { get; }
    public CommandLineBuilder(bool quoteHyphensOnCommandLine);
    public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator);
    private static CommandLineBuilder();
    public int get_Length();
    [CompilerGeneratedAttribute]
protected StringBuilder get_CommandLine();
    public virtual string ToString();
    private Regex get_DefinitelyNeedQuotes();
    private Regex get_AllowedUnquoted();
    protected virtual bool IsQuotingRequired(string parameter);
    protected void AppendSpaceIfNotEmpty();
    protected void AppendTextWithQuoting(string textToAppend);
    protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTextToAppend);
    public void AppendTextUnquoted(string textToAppend);
    protected void AppendFileNameWithQuoting(string fileName);
    public void AppendFileNameIfNotNull(string fileName);
    public void AppendFileNameIfNotNull(ITaskItem fileItem);
    public void AppendFileNamesIfNotNull(String[] fileNames, string delimiter);
    public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter);
    public void AppendSwitch(string switchName);
    public void AppendSwitchIfNotNull(string switchName, string parameter);
    protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, string parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
}
public enum Microsoft.Build.Utilities.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal class Microsoft.Build.Utilities.EscapeHatches : object {
    public Nullable`1<bool> EvaluateElementsWithFalseConditionInProjectEvaluation;
    public bool AlwaysUseContentTimestamp;
    public bool LogProjectImports;
    public bool CacheAssemblyInformation;
    public Nullable`1<ProjectInstanceTranslationMode> ProjectInstanceTranslation;
    public bool UseSymlinkTimeInsteadOfTargetTime;
    public bool IgnoreEmptyImports;
    public bool IgnoreTreatAsLocalProperty;
    public bool DebugEvaluation;
    public bool WarnOnUninitializedProperty;
    public bool UseCaseSensitiveItemNames;
    public bool DisableSdkResolutionCache;
    public bool DisableNuGetSdkResolver;
    public bool UseAutoRunWhenLaunchingProcessUnderCmd;
    public bool EnsureStdOutForChildNodesIsPrimaryStdout;
    private static Nullable`1<bool> ParseNullableBoolFromEnvironmentVariable(string environmentVariable);
    private static Nullable`1<ProjectInstanceTranslationMode> ComputeProjectInstanceTranslation();
}
internal class Microsoft.Build.Utilities.ExtensionSDK : object {
    private string _path;
    private string _sdkMoniker;
    private Version _sdkVersion;
    private string _sdkIdentifier;
    private SDKManifest _manifest;
    private Version _minVSVersion;
    private Version _maxPlatformVersion;
    public Version Version { get; }
    public string Identifier { get; }
    public SDKType SDKType { get; }
    public Version MinVSVersion { get; }
    public Version MaxPlatformVersion { get; }
    public ICollection`1<ApiContract> ApiContracts { get; }
    private SDKManifest Manifest { get; }
    public ExtensionSDK(string extensionSdkMoniker, string extensionSdkPath);
    public Version get_Version();
    public string get_Identifier();
    public SDKType get_SDKType();
    public Version get_MinVSVersion();
    public Version get_MaxPlatformVersion();
    public ICollection`1<ApiContract> get_ApiContracts();
    private SDKManifest get_Manifest();
    private void ParseMoniker(string moniker);
}
public enum Microsoft.Build.Utilities.HostObjectInitializationStatus : Enum {
    public int value__;
    public static HostObjectInitializationStatus UseHostObjectToExecute;
    public static HostObjectInitializationStatus UseAlternateToolToExecute;
    public static HostObjectInitializationStatus NoActionReturnSuccess;
    public static HostObjectInitializationStatus NoActionReturnFailure;
}
public abstract class Microsoft.Build.Utilities.Logger : object {
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public virtual void set_Parameters(string value);
    public abstract virtual void Initialize(IEventSource eventSource);
    public virtual void Shutdown();
    public virtual string FormatErrorEvent(BuildErrorEventArgs args);
    public virtual string FormatWarningEvent(BuildWarningEventArgs args);
    public bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
}
public enum Microsoft.Build.Utilities.MultipleVersionSupport : Enum {
    public int value__;
    public static MultipleVersionSupport Allow;
    public static MultipleVersionSupport Warning;
    public static MultipleVersionSupport Error;
}
public class Microsoft.Build.Utilities.MuxLogger : object {
    private Dictionary`2<int, SubmissionRecord> _submissionRecords;
    private BuildStartedEventArgs _buildStartedEvent;
    private IEventSource _eventSourceForBuild;
    private BuildStartedEventHandler _buildStartedEventHandler;
    private BuildFinishedEventHandler _buildFinishedEventHandler;
    private ProjectStartedEventHandler _projectStartedEventHandler;
    private ProjectFinishedEventHandler _projectFinishedEventHandler;
    private Dictionary`2<int, int> _submissionProjectsInProgress;
    private int _maxNodeCount;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationMetaprojects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTaskInputs>k__BackingField;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfiles { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationMetaprojects();
    [CompilerGeneratedAttribute]
public void set_IncludeEvaluationMetaprojects(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationProfiles();
    [CompilerGeneratedAttribute]
public void set_IncludeEvaluationProfiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTaskInputs();
    [CompilerGeneratedAttribute]
public void set_IncludeTaskInputs(bool value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int maxNodeCount);
    public sealed virtual void Shutdown();
    public void RegisterLogger(int submissionId, ILogger logger);
    public bool UnregisterLoggers(int submissionId);
    private void BuildStarted(object sender, BuildStartedEventArgs e);
    private void BuildFinished(object sender, BuildFinishedEventArgs e);
    private void ProjectStarted(object sender, ProjectStartedEventArgs e);
    private void ProjectFinished(object sender, ProjectFinishedEventArgs e);
}
internal class Microsoft.Build.Utilities.PlatformManifest : object {
    private string _pathToManifest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<DependentPlatform> <DependentPlatforms>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ApiContract> <ApiContracts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VersionedContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadErrorMessage>k__BackingField;
    public string Name { get; private set; }
    public string FriendlyName { get; private set; }
    public string PlatformVersion { get; private set; }
    public ICollection`1<DependentPlatform> DependentPlatforms { get; private set; }
    public ICollection`1<ApiContract> ApiContracts { get; private set; }
    public bool VersionedContent { get; private set; }
    public bool ReadError { get; }
    public string ReadErrorMessage { get; private set; }
    public PlatformManifest(string pathToManifest);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_PlatformVersion();
    [CompilerGeneratedAttribute]
private void set_PlatformVersion(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<DependentPlatform> get_DependentPlatforms();
    [CompilerGeneratedAttribute]
private void set_DependentPlatforms(ICollection`1<DependentPlatform> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ApiContract> get_ApiContracts();
    [CompilerGeneratedAttribute]
private void set_ApiContracts(ICollection`1<ApiContract> value);
    [CompilerGeneratedAttribute]
public bool get_VersionedContent();
    [CompilerGeneratedAttribute]
private void set_VersionedContent(bool value);
    public bool get_ReadError();
    [CompilerGeneratedAttribute]
public string get_ReadErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ReadErrorMessage(string value);
    private void LoadManifestFile();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Utilities.ProcessExtensions : object {
    [ExtensionAttribute]
public static void KillTree(Process process, int timeout);
    private static void GetAllChildIdsUnix(int parentId, ISet`1<int> children);
    private static void KillProcessUnix(int processId);
    private static int RunProcessAndWaitForExit(string fileName, string arguments, String& stdout);
}
public static class Microsoft.Build.Utilities.ProcessorArchitecture : object {
    public static string X86;
    public static string IA64;
    public static string AMD64;
    public static string MSIL;
    public static string ARM;
    public static string CurrentProcessArchitecture { get; }
    public static string get_CurrentProcessArchitecture();
    private static string GetCurrentProcessArchitecture();
}
public class Microsoft.Build.Utilities.SDKManifest : object {
    private static string s_extensionSDKPathPattern;
    private static string s_defaultMaxPlatformVersion;
    private static string s_defaultMinOSVersion;
    private static string s_defaultMaxOSVersionTested;
    private MultipleVersionSupport _supportsMultipleVersions;
    private string _pathToSdk;
    private IDictionary`2<string, string> _appxLocations;
    private IDictionary`2<string, string> _frameworkIdentities;
    private string _maxOSVersionTested;
    private string _minOSVersion;
    private string _maxPlatformVersion;
    private SDKType _sdkType;
    [CompilerGeneratedAttribute]
private string <PlatformIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportPrefer32Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyRedistToSubDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportedArchitectures>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnSDK>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductFamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinVSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MoreInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ApiContract> <ApiContracts>k__BackingField;
    public MultipleVersionSupport SupportsMultipleVersions { get; }
    public IDictionary`2<string, string> FrameworkIdentities { get; }
    public IDictionary`2<string, string> AppxLocations { get; }
    public string PlatformIdentity { get; private set; }
    public string FrameworkIdentity { get; private set; }
    public string SupportPrefer32Bit { get; private set; }
    public SDKType SDKType { get; }
    public string CopyRedistToSubDirectory { get; private set; }
    public string SupportedArchitectures { get; private set; }
    public string DependsOnSDK { get; private set; }
    public string ProductFamilyName { get; private set; }
    public string TargetPlatform { get; private set; }
    public string TargetPlatformMinVersion { get; private set; }
    public string TargetPlatformVersion { get; private set; }
    public string DisplayName { get; private set; }
    public string MinVSVersion { get; private set; }
    public string MinOSVersion { get; }
    public string MaxPlatformVersion { get; }
    public string MaxOSVersionTested { get; }
    public string MoreInfo { get; private set; }
    public bool ReadError { get; private set; }
    public string ReadErrorMessage { get; private set; }
    internal ICollection`1<ApiContract> ApiContracts { get; private set; }
    private bool IsFrameworkExtensionSdkManifest { get; }
    public SDKManifest(string pathToSdk);
    private static SDKManifest();
    public MultipleVersionSupport get_SupportsMultipleVersions();
    public IDictionary`2<string, string> get_FrameworkIdentities();
    public IDictionary`2<string, string> get_AppxLocations();
    [CompilerGeneratedAttribute]
public string get_PlatformIdentity();
    [CompilerGeneratedAttribute]
private void set_PlatformIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_FrameworkIdentity();
    [CompilerGeneratedAttribute]
private void set_FrameworkIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_SupportPrefer32Bit();
    [CompilerGeneratedAttribute]
private void set_SupportPrefer32Bit(string value);
    public SDKType get_SDKType();
    [CompilerGeneratedAttribute]
public string get_CopyRedistToSubDirectory();
    [CompilerGeneratedAttribute]
private void set_CopyRedistToSubDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_SupportedArchitectures();
    [CompilerGeneratedAttribute]
private void set_SupportedArchitectures(string value);
    [CompilerGeneratedAttribute]
public string get_DependsOnSDK();
    [CompilerGeneratedAttribute]
private void set_DependsOnSDK(string value);
    [CompilerGeneratedAttribute]
public string get_ProductFamilyName();
    [CompilerGeneratedAttribute]
private void set_ProductFamilyName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatform();
    [CompilerGeneratedAttribute]
private void set_TargetPlatform(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformMinVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_MinVSVersion();
    [CompilerGeneratedAttribute]
private void set_MinVSVersion(string value);
    public string get_MinOSVersion();
    public string get_MaxPlatformVersion();
    public string get_MaxOSVersionTested();
    [CompilerGeneratedAttribute]
public string get_MoreInfo();
    [CompilerGeneratedAttribute]
private void set_MoreInfo(string value);
    [CompilerGeneratedAttribute]
public bool get_ReadError();
    [CompilerGeneratedAttribute]
private void set_ReadError(bool value);
    [CompilerGeneratedAttribute]
public string get_ReadErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ReadErrorMessage(string value);
    [CompilerGeneratedAttribute]
internal ICollection`1<ApiContract> get_ApiContracts();
    [CompilerGeneratedAttribute]
private void set_ApiContracts(ICollection`1<ApiContract> value);
    private bool get_IsFrameworkExtensionSdkManifest();
    private void LoadManifestFile();
    private void ReadFileListAttributes(XmlAttributeCollection attributes);
    private static MultipleVersionSupport ParseSupportMultipleVersions(string multipleVersionsValue);
}
public enum Microsoft.Build.Utilities.SDKType : Enum {
    public int value__;
    public static SDKType Unspecified;
    public static SDKType External;
    public static SDKType Platform;
    public static SDKType Framework;
}
public enum Microsoft.Build.Utilities.TargetDotNetFrameworkVersion : Enum {
    public int value__;
    public static TargetDotNetFrameworkVersion Version11;
    public static TargetDotNetFrameworkVersion Version20;
    public static TargetDotNetFrameworkVersion Version30;
    public static TargetDotNetFrameworkVersion Version35;
    public static TargetDotNetFrameworkVersion Version40;
    public static TargetDotNetFrameworkVersion Version45;
    public static TargetDotNetFrameworkVersion Version451;
    public static TargetDotNetFrameworkVersion Version46;
    public static TargetDotNetFrameworkVersion Version461;
    public static TargetDotNetFrameworkVersion Version452;
    public static TargetDotNetFrameworkVersion Version462;
    public static TargetDotNetFrameworkVersion Version47;
    public static TargetDotNetFrameworkVersion Version471;
    public static TargetDotNetFrameworkVersion Version472;
    public static TargetDotNetFrameworkVersion VersionLatest;
    public static TargetDotNetFrameworkVersion Latest;
}
public class Microsoft.Build.Utilities.TargetPlatformSDK : object {
    private string _path;
    private SDKManifest _manifest;
    private Version _minVSVersion;
    private Version _minOSVersion;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtensionSDKs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Platforms>k__BackingField;
    public Version MinVSVersion { get; }
    public Version MinOSVersion { get; }
    public string TargetPlatformIdentifier { get; }
    public Version TargetPlatformVersion { get; }
    public string Path { get; public set; }
    public string DisplayName { get; }
    internal Dictionary`2<string, string> ExtensionSDKs { get; }
    internal Dictionary`2<string, string> Platforms { get; }
    private SDKManifest Manifest { get; }
    public TargetPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string path);
    public Version get_MinVSVersion();
    public Version get_MinOSVersion();
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public Version get_TargetPlatformVersion();
    public string get_Path();
    public void set_Path(string value);
    public string get_DisplayName();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_ExtensionSDKs();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_Platforms();
    private SDKManifest get_Manifest();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetPlatformSDK other);
    public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion);
    internal static string GetSdkKey(string sdkIdentifier, string sdkVersion);
}
public abstract class Microsoft.Build.Utilities.Task : object {
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <Log>k__BackingField;
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public IBuildEngine4 BuildEngine4 { get; }
    public IBuildEngine5 BuildEngine5 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    protected ResourceManager TaskResources { get; protected set; }
    protected string HelpKeywordPrefix { get; protected set; }
    protected Task(ResourceManager taskResources);
    protected Task(ResourceManager taskResources, string helpKeywordPrefix);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public IBuildEngine4 get_BuildEngine4();
    public IBuildEngine5 get_BuildEngine5();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public TaskLoggingHelper get_Log();
    protected ResourceManager get_TaskResources();
    protected void set_TaskResources(ResourceManager value);
    protected string get_HelpKeywordPrefix();
    protected void set_HelpKeywordPrefix(string value);
    public abstract virtual bool Execute();
}
public class Microsoft.Build.Utilities.TaskItem : object {
    private string _itemSpec;
    private CopyOnWriteDictionary`2<string, string> _metadata;
    private string _fullPath;
    private string _definingProject;
    public string ItemSpec { get; public set; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public ICollection MetadataNames { get; }
    public int MetadataCount { get; }
    private CopyOnWriteDictionary`2<string, string> Metadata { get; private set; }
    public TaskItem(string itemSpec);
    public TaskItem(string itemSpec, IDictionary itemMetadata);
    public TaskItem(ITaskItem sourceItem);
    public sealed virtual string get_ItemSpec();
    public sealed virtual void set_ItemSpec(string value);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    private CopyOnWriteDictionary`2<string, string> get_Metadata();
    private void set_Metadata(CopyOnWriteDictionary`2<string, string> value);
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual IDictionary CloneCustomMetadata();
    public virtual string ToString();
    public static string op_Explicit(TaskItem taskItemToCast);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
}
public class Microsoft.Build.Utilities.TaskLoggingHelper : object {
    private ITask _taskInstance;
    private object _locker;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    private string _taskNameUpperCase;
    private IBuildEngine _buildEngine;
    [CompilerGeneratedAttribute]
private ResourceManager <TaskResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeywordPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLoggedErrors>k__BackingField;
    protected string TaskName { get; }
    private string TaskNameUpperCase { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; private set; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    [CompilerGeneratedAttribute]
protected string get_TaskName();
    private string get_TaskNameUpperCase();
    protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public ResourceManager get_TaskResources();
    [CompilerGeneratedAttribute]
public void set_TaskResources(ResourceManager value);
    [CompilerGeneratedAttribute]
public string get_HelpKeywordPrefix();
    [CompilerGeneratedAttribute]
public void set_HelpKeywordPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
private void set_HasLoggedErrors(bool value);
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
}
public static class Microsoft.Build.Utilities.ToolLocationHelper : object {
    private static Dictionary`2<string, string> s_chainedReferenceAssemblyPath;
    private static object s_locker;
    private static Dictionary`2<string, IList`1<string>> s_cachedReferenceAssemblyPaths;
    private static Dictionary`2<string, FrameworkName> s_cachedHighestFrameworkNameForTargetFrameworkIdentifier;
    private static Dictionary`2<string, IEnumerable`1<TargetPlatformSDK>> s_cachedTargetPlatforms;
    private static Dictionary`2<string, TargetPlatformSDK> s_cachedExtensionSdks;
    private static Dictionary`2<string, string> s_cachedTargetFrameworkDisplayNames;
    private static Dictionary`2<string, String[]> s_cachedTargetPlatformReferences;
    private static Dictionary`2<string, String[]> s_cachedExtensionSdkReferences;
    private static List`1<string> s_targetFrameworkMonikers;
    private static char _separatorForFallbackSearchPaths;
    private static string retailConfigurationName;
    private static string neutralArchitectureName;
    private static string commonConfigurationFolderName;
    private static string redistFolderName;
    private static string referencesFolderName;
    private static string designTimeFolderName;
    private static string platformsFolderName;
    private static string uapDirectoryName;
    private static string uapRegistryName;
    private static int uapVersion;
    private static Char[] s_diskRootSplitChars;
    public static string CurrentToolsVersion { get; }
    public static string PathToSystem { get; }
    private static ToolLocationHelper();
    public static string get_CurrentToolsVersion();
    public static IList`1<AssemblyFoldersFromConfigInfo> GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, ProcessorArchitecture targetProcessorArchitecture);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(String[] diskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(String[] diskRoots, String[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(String[] diskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(String[] diskRoots, String[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    private static IEnumerable`1<TargetPlatformSDK> GetTargetPlatformMonikers(String[] diskRoots, String[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, String[] extensionDiskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot);
    public static IDictionary`2<string, string> FilterPlatformExtensionSDKs(Version targetPlatformVersion, IDictionary`2<string, string> extensionSdks);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    private static void AddSDKPaths(string sdkRoot, string folderName, string targetConfiguration, string targetArchitecture, List`1<string> directories);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks();
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks(String[] diskRoots, string registryRoot);
    public static IList`1<TargetPlatformSDK> FilterTargetPlatformSdks(IList`1<TargetPlatformSDK> targetPlatformSdkList, Version osVersion, Version vsVersion);
    public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion);
    public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static String[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion);
    public static String[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static String[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot);
    public static String[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion);
    private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string targetPlatformIdentifier, string targetPlatformVersion);
    private static String[] GetLegacyTargetPlatformReferences(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    private static String[] GetTargetPlatformReferencesFromManifest(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    internal static String[] GetApiContractReferences(IEnumerable`1<ApiContract> apiContracts, string targetPlatformSdkRoot);
    internal static String[] GetApiContractReferences(IEnumerable`1<ApiContract> apiContracts, string targetPlatformSdkRoot, string targetPlatformSdkVersion);
    private static bool TryGetPlatformManifest(TargetPlatformSDK matchingSdk, string platformKey, PlatformManifest& manifest);
    public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static IEnumerable`1<string> GetPlatformsForSDK(string sdkIdentifier, Version sdkVersion);
    public static IEnumerable`1<string> GetPlatformsForSDK(string sdkIdentifier, Version sdkVersion, String[] diskRoots, string registryRoot);
    public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion);
    public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, String[] sdkRoots);
    private static bool TryParsePlatformVersion(string platformMoniker, Version& platformVersion);
    private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string multiPlatformDiskRoots, string registryRoot);
    private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, String[] multiPlatformDiskRoots, string registryRoot);
    private static string GenerateDefaultSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string get_PathToSystem();
    public static string GetDotNetFrameworkVersionFolderPrefix(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdk();
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion version);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths);
    public static IList`1<string> GetPathToReferenceAssemblies(FrameworkName frameworkName);
    private static string VersionToDotNetFrameworkPath(VersionToPath PathToDotNetFramework, TargetDotNetFrameworkVersion version);
    private static string VersionToDotNetReferenceAssemblies(VersionToPath PathToDotReferenceAssemblies, TargetDotNetFrameworkVersion version);
    internal static IList`1<string> HandleLegacyDotNetFrameworkReferenceAssemblyPaths(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies, FrameworkName frameworkName);
    private static string GetPathToDotNetFrameworkSdkToolsFolderRoot(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    private static Version TargetDotNetFrameworkVersionToSystemVersion(TargetDotNetFrameworkVersion version);
    private static Version VisualStudioVersionToSystemVersion(VisualStudioVersion version);
    private static string GenerateReferenceAssemblyCacheKey(string targetFrameworkRootPath, FrameworkName frameworkName);
    private static void CreateReferenceAssemblyPathsCache();
    private static IList`1<string> HandleLegacy35(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies);
    private static IList`1<string> HandleLegacy30(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies);
    private static IList`1<string> HandleLegacy20(VersionToPath PathToDotNetFramework);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, FrameworkName frameworkName);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, FrameworkName frameworkName);
    public static string GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, FrameworkName frameworkName);
    private static IList`1<string> GetPathAndChainReferenceAssemblyLocations(string targetFrameworkRootPath, FrameworkName frameworkName, bool chain);
    public static void ClearSDKStaticCache();
    internal static void ClearStaticCaches();
    private static string RemapSdkArchitecture(string targetArchitecture);
    private static void AddSDKPath(string sdkRoot, string contentFolderName, string targetConfiguration, string targetArchitecture, List`1<string> contentDirectories);
    private static IEnumerable`1<TargetPlatformSDK> RetrieveTargetPlatformList(String[] diskRoots, String[] extensionDiskRoots, string registrySearchLocation);
    private static void GatherExtensionSDKListFromDirectory(IEnumerable`1<string> diskRoots, TargetPlatformSDK extensionSdk);
    internal static void GatherExtensionSDKs(DirectoryInfo extensionSdksDirectory, TargetPlatformSDK targetPlatformSDK);
    internal static void GatherSDKListFromDirectory(List`1<string> diskroots, Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformSDKs);
    private static void GetDefaultSDKDiskRoots(List`1<string> diskRoots);
    private static void ExtractSdkDiskRootsFromEnvironment(List`1<string> diskRoots, string directoryRoots);
    private static List`1<string> GetTargetPlatformMonikerDiskRoots(String[] diskRoots);
    private static List`1<string> GetExtensionSdkDiskRoots(String[] diskRoots);
    private static string GetTargetPlatformMonikerRegistryRoots(string registryRootLocation);
    private static void GatherPlatformsForSdk(TargetPlatformSDK sdk);
    internal static string ChainReferenceAssemblyPath(string targetFrameworkDirectory);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary);
    internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture(DotNetFrameworkArchitecture architecture);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocation instead")]
public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
private static string GetPathToWindowsSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    public static string GetPathToBuildTools(string toolsVersion);
    public static string GetPathToBuildTools(string toolsVersion, DotNetFrameworkArchitecture architecture);
    public static string GetPathToBuildToolsFile(string fileName, string toolsVersion);
    public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToSystemFile(string fileName);
    public static IList`1<string> GetSupportedTargetFrameworks();
    public static FrameworkName HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier);
    public static string GetProgramFilesReferenceAssemblyRoot();
    private static DotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkArchitecture(DotNetFrameworkArchitecture architecture);
    private static Version ConvertTargetFrameworkVersionToVersion(string targetFrameworkVersion);
    internal static IList`1<string> GetFrameworkIdentifiers(string frameworkReferenceRoot);
    private static IList`1<string> GetFrameworkVersions(string frameworkReferenceRoot, string frameworkIdentifier);
    private static IList`1<string> GetFrameworkProfiles(string frameworkReferenceRoot, string frameworkIdentifier, string frameworkVersion);
    private static IList`1<string> GetFx35AndEarlierVersions(string frameworkReferenceRoot);
}
public abstract class Microsoft.Build.Utilities.ToolTask : Task {
    private static bool s_preserveTempFiles;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <YieldDuringToolExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCommandProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EchoOff>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TaskProcessTerminationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <ToolCanceled>k__BackingField;
    private string _temporaryBatchFile;
    [CompilerGeneratedAttribute]
private string <ToolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutputImportance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardErrorImportance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogStandardErrorAsError>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <LogPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <LogShared>k__BackingField;
    private object _eventCloseLock;
    private static Char[] s_equalsSplitter;
    private MessageImportance _standardOutputImportanceToUse;
    private MessageImportance _standardErrorImportanceToUse;
    private Queue _standardErrorData;
    private Queue _standardOutputData;
    private ManualResetEvent _standardErrorDataAvailable;
    private ManualResetEvent _standardOutputDataAvailable;
    private ManualResetEvent _toolExited;
    private bool _terminatedTool;
    private ManualResetEvent _toolTimeoutExpired;
    private Timer _toolTimer;
    private string _toolExe;
    private bool _eventsDisposed;
    private List`1<KeyValuePair`2<object, object>> _environmentVariablePairs;
    [OutputAttribute]
public int ExitCode { get; private set; }
    public bool YieldDuringToolExecution { get; public set; }
    public bool UseCommandProcessor { get; public set; }
    public bool EchoOff { get; public set; }
    protected int TaskProcessTerminationTimeout { get; protected set; }
    protected ManualResetEvent ToolCanceled { get; private set; }
    protected string ToolName { get; }
    public string ToolExe { get; public set; }
    public string ToolPath { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public int Timeout { get; public set; }
    protected Encoding ResponseFileEncoding { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    [ObsoleteAttribute("Use EnvironmentVariables property")]
protected Dictionary`2<string, string> EnvironmentOverride { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected bool HasLoggedErrors { get; }
    public string StandardOutputImportance { get; public set; }
    public string StandardErrorImportance { get; public set; }
    public bool LogStandardErrorAsError { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardOutputImportanceToUse { get; }
    protected MessageImportance StandardErrorImportanceToUse { get; }
    private TaskLoggingHelper LogPrivate { get; }
    private TaskLoggingHelper LogShared { get; }
    protected ToolTask(ResourceManager taskResources);
    protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix);
    private static ToolTask();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public bool get_YieldDuringToolExecution();
    [CompilerGeneratedAttribute]
public void set_YieldDuringToolExecution(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseCommandProcessor();
    [CompilerGeneratedAttribute]
public void set_UseCommandProcessor(bool value);
    [CompilerGeneratedAttribute]
public bool get_EchoOff();
    [CompilerGeneratedAttribute]
public void set_EchoOff(bool value);
    [CompilerGeneratedAttribute]
protected int get_TaskProcessTerminationTimeout();
    [CompilerGeneratedAttribute]
protected void set_TaskProcessTerminationTimeout(int value);
    [CompilerGeneratedAttribute]
protected ManualResetEvent get_ToolCanceled();
    [CompilerGeneratedAttribute]
private void set_ToolCanceled(ManualResetEvent value);
    protected abstract virtual string get_ToolName();
    public virtual string get_ToolExe();
    public virtual void set_ToolExe(string value);
    [CompilerGeneratedAttribute]
public void set_ToolPath(string value);
    [CompilerGeneratedAttribute]
public string get_ToolPath();
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    [CompilerGeneratedAttribute]
public virtual void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Timeout();
    protected virtual Encoding get_ResponseFileEncoding();
    protected virtual string ResponseFileEscape(string responseString);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    protected virtual Dictionary`2<string, string> get_EnvironmentOverride();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
public string get_StandardOutputImportance();
    [CompilerGeneratedAttribute]
public void set_StandardOutputImportance(string value);
    [CompilerGeneratedAttribute]
public string get_StandardErrorImportance();
    [CompilerGeneratedAttribute]
public void set_StandardErrorImportance(string value);
    [CompilerGeneratedAttribute]
public bool get_LogStandardErrorAsError();
    [CompilerGeneratedAttribute]
public void set_LogStandardErrorAsError(bool value);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected MessageImportance get_StandardOutputImportanceToUse();
    protected MessageImportance get_StandardErrorImportanceToUse();
    [CompilerGeneratedAttribute]
private TaskLoggingHelper get_LogPrivate();
    [CompilerGeneratedAttribute]
private TaskLoggingHelper get_LogShared();
    protected abstract virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    protected internal virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GetResponseFileSwitch(string responseFilePath);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual bool CallHostObjectToExecute();
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual void LogToolCommand(string message);
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    private string ComputePathToTool();
    private string GetTemporaryResponseFile(string responseFileCommands, String& responseFileSwitch);
    protected virtual ProcessStartInfo GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch);
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    public virtual void Cancel();
    protected void DeleteTempFile(string fileName);
    private void HandleToolNotifications(Process proc);
    private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled);
    private void TerminateToolProcess(Process proc, bool isBeingCancelled);
    private static void WaitForProcessExit(Process proc);
    private void LogMessagesFromStandardError();
    private void LogMessagesFromStandardOutput();
    private void LogMessagesFromStandardErrorOrOutput(Queue dataQueue, ManualResetEvent dataAvailableSignal, MessageImportance messageImportance, StandardOutputOrErrorQueueType queueType);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private void ReceiveTimeoutNotification(object unused);
    private void ReceiveExitNotification(object sender, EventArgs e);
    private void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e);
    private void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e);
    private void ReceiveStandardErrorOrOutputData(DataReceivedEventArgs e, Queue dataQueue, ManualResetEvent dataAvailableSignal);
    private bool AssignStandardStreamLoggingImportance();
    internal static string FindOnPath(string filename);
    public virtual bool Execute();
    protected virtual string AdjustCommandsForOperatingSystem(string input);
    private static string GetErrorMessageWithDiagnosticsCheck(Exception e);
    private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string key, string value);
}
public static class Microsoft.Build.Utilities.TrackedDependencies : object {
    public static ITaskItem[] ExpandWildcards(ITaskItem[] expand);
    internal static bool ItemsExist(ITaskItem[] files);
}
internal class Microsoft.Build.Utilities.Traits : object {
    private static Traits _instance;
    [CompilerGeneratedAttribute]
private EscapeHatches <EscapeHatches>k__BackingField;
    public bool UseLazyWildCardEvaluation;
    public bool LogExpandedWildcards;
    public bool CacheFileExistence;
    public bool UseSimpleInternConcurrency;
    public bool MSBuildCacheFileEnumerations;
    public bool EnableAllPropertyFunctions;
    public bool EnableRestoreFirst;
    public int CopyTaskParallelism;
    public bool EmitSolutionMetaproj;
    public static Traits Instance { get; }
    public EscapeHatches EscapeHatches { get; }
    private static Traits();
    public static Traits get_Instance();
    [CompilerGeneratedAttribute]
public EscapeHatches get_EscapeHatches();
    private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue);
}
public enum Microsoft.Build.Utilities.VisualStudioVersion : Enum {
    public int value__;
    public static VisualStudioVersion Version100;
    public static VisualStudioVersion Version110;
    public static VisualStudioVersion Version120;
    public static VisualStudioVersion Version140;
    public static VisualStudioVersion Version150;
    public static VisualStudioVersion VersionLatest;
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
