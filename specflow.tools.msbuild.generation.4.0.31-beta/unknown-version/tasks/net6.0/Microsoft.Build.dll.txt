internal class Microsoft.Build.BackEnd.AssemblyTaskFactory : object {
    private TypeLoader _typeLoader;
    private string _taskName;
    private LoadedType _loadedType;
    private IDictionary`2<string, string> _factoryIdentityParameters;
    private bool _taskHostFactoryExplicitlyRequested;
    private TaskLoggingContext _taskLoggingContext;
    public string FactoryName { get; }
    public Type TaskType { get; }
    public sealed virtual string get_FactoryName();
    public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary`2<string, string> taskIdentityParameters);
    public sealed virtual void CleanupTask(ITask task);
    internal LoadedType InitializeFactory(AssemblyLoadInfo loadInfo, string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IDictionary`2<string, string> taskFactoryIdentityParameters, bool taskHostFactoryExplicitlyRequested, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, string taskProjectFile);
    internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskIdentityParameters, bool isOutOfProc);
    internal bool TaskNameCreatableByFactory(string taskName, IDictionary`2<string, string> taskIdentityParameters, string taskProjectFile, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    private static void VerifyThrowIdentityParametersValid(IDictionary`2<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName);
    private static bool TaskIdentityParametersMatchFactory(IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, string> taskIdentityParameters);
    private static IDictionary`2<string, string> MergeTaskFactoryParameterSets(IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, string> taskIdentityParameters);
    private static bool TaskHostParametersMatchCurrentProcess(IDictionary`2<string, string> mergedParameters);
    private void ErrorLoggingDelegate(string taskLocation, int taskLine, int taskColumn, string message, Object[] messageArgs);
}
internal static class Microsoft.Build.BackEnd.BatchingEngine : object {
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, ElementLocation elementLocation);
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, string implicitBatchableItemType, ElementLocation elementLocation);
    private static Dictionary`2<string, ICollection`1<ProjectItemInstance>> GetItemListsToBeBatched(Dictionary`2<string, MetadataReference> consumedMetadataReferences, HashSet`1<string> consumedItemReferenceNames, Lookup lookup, ElementLocation elementLocation);
    private static List`1<ItemBucket> BucketConsumedItems(Lookup lookup, Dictionary`2<string, ICollection`1<ProjectItemInstance>> itemListsToBeBatched, Dictionary`2<string, MetadataReference> consumedMetadataReferences, ElementLocation elementLocation);
    private static Dictionary`2<string, string> GetItemMetadataValues(ProjectItemInstance item, Dictionary`2<string, MetadataReference> consumedMetadataReferences, ElementLocation elementLocation);
}
internal class Microsoft.Build.BackEnd.BufferedReadStream : Stream {
    private static int BUFFER_SIZE;
    private Stream _innerStream;
    private Byte[] _buffer;
    private int _currentlyBufferedByteCount;
    private int _currentIndexInBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedReadStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryCollection : object {
    private Dictionary`2<BuildComponentType, BuildComponentEntry> _componentEntriesByType;
    private IBuildComponentHost _host;
    public BuildComponentFactoryCollection(IBuildComponentHost host);
    public void RegisterDefaultFactories();
    public void ShutdownComponents();
    public void ShutdownComponent(BuildComponentType componentType);
    public void ReplaceFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    public void ReplaceFactory(BuildComponentType componentType, IBuildComponent instance);
    public void AddFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory, CreationPattern creationPattern);
    public IBuildComponent GetComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryDelegate : MulticastDelegate {
    public BuildComponentFactoryDelegate(object object, IntPtr method);
    public virtual IBuildComponent Invoke(BuildComponentType type);
    public virtual IAsyncResult BeginInvoke(BuildComponentType type, AsyncCallback callback, object object);
    public virtual IBuildComponent EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.BuildComponentType : Enum {
    public int value__;
    public static BuildComponentType RequestManager;
    public static BuildComponentType Scheduler;
    public static BuildComponentType ResultsCache;
    public static BuildComponentType PropertyCache;
    public static BuildComponentType ConfigCache;
    public static BuildComponentType NodeManager;
    public static BuildComponentType InProcNodeProvider;
    public static BuildComponentType OutOfProcNodeProvider;
    public static BuildComponentType RemoteNodeProvider;
    public static BuildComponentType NodePacketFactory;
    public static BuildComponentType RequestEngine;
    public static BuildComponentType FileMonitor;
    public static BuildComponentType NodeEndpoint;
    public static BuildComponentType LoggingService;
    public static BuildComponentType RequestBuilder;
    public static BuildComponentType TargetBuilder;
    public static BuildComponentType TaskBuilder;
    public static BuildComponentType TestDataProvider;
    public static BuildComponentType OutOfProcTaskHostNodeProvider;
    public static BuildComponentType TaskHostNodeManager;
    public static BuildComponentType RegisteredTaskObjectCache;
    public static BuildComponentType SdkResolverService;
}
internal class Microsoft.Build.BackEnd.BuildRequest : object {
    public static int InvalidGlobalRequestId;
    public static int InvalidNodeRequestId;
    public static int ResultsTransferNodeRequestId;
    private int _submissionId;
    private int _configurationId;
    private int _globalRequestId;
    private int _parentGlobalRequestId;
    private int _nodeRequestId;
    private List`1<string> _targets;
    private BuildEventContext _parentBuildEventContext;
    private BuildEventContext _buildEventContext;
    private BuildRequestDataFlags _buildRequestDataFlags;
    private RequestedProjectState _requestedProjectState;
    private bool _skipNonexistentTargets;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    public bool IsConfigurationResolved { get; }
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int GlobalRequestId { get; public set; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; public set; }
    public List`1<string> Targets { get; }
    public NodePacketType Type { get; }
    public BuildEventContext ParentBuildEventContext { get; }
    public BuildEventContext BuildEventContext { get; public set; }
    public BuildRequestDataFlags BuildRequestDataFlags { get; public set; }
    public RequestedProjectState RequestedProjectState { get; public set; }
    internal HostServices HostServices { get; }
    internal bool IsRootRequest { get; }
    internal bool SkipNonexistentTargets { get; internal set; }
    public BuildRequest(int submissionId, int nodeRequestId, int configurationId, ICollection`1<string> escapedTargets, HostServices hostServices, BuildEventContext parentBuildEventContext, BuildRequest parentRequest, BuildRequestDataFlags buildRequestDataFlags, RequestedProjectState requestedProjectState);
    private BuildRequest(INodePacketTranslator translator);
    [DebuggerStepThroughAttribute]
public bool get_IsConfigurationResolved();
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    public void set_GlobalRequestId(int value);
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public void set_NodeRequestId(int value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_Targets();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_ParentBuildEventContext();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    public void set_BuildEventContext(BuildEventContext value);
    public BuildRequestDataFlags get_BuildRequestDataFlags();
    public void set_BuildRequestDataFlags(BuildRequestDataFlags value);
    public RequestedProjectState get_RequestedProjectState();
    public void set_RequestedProjectState(RequestedProjectState value);
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
internal HostServices get_HostServices();
    [DebuggerStepThroughAttribute]
internal bool get_IsRootRequest();
    internal bool get_SkipNonexistentTargets();
    internal void set_SkipNonexistentTargets(bool value);
    public void ResolveConfiguration(int newConfigId);
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal bool DoesResultApplyToRequest(BuildResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestBlockedDelegate : MulticastDelegate {
    public BuildRequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry sourceEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry sourceEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestBlocker : object {
    private YieldAction _yieldAction;
    private int _blockedGlobalRequestId;
    private String[] _targetsInProgress;
    private int _blockingGlobalRequestId;
    private string _blockingTarget;
    private BuildResult _partialBuildResult;
    private BuildRequest[] _buildRequests;
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public String[] TargetsInProgress { get; }
    public int BlockingRequestId { get; }
    public string BlockingTarget { get; }
    public BuildRequest[] BuildRequests { get; }
    public YieldAction YieldAction { get; }
    public BuildResult PartialBuildResult { get; }
    internal BuildRequestBlocker(INodePacketTranslator translator);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, int blockingGlobalRequestId, string blockingTarget);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, BuildRequest[] buildRequests);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, YieldAction action);
    internal BuildRequestBlocker(int blockedGlobalRequestId);
    private BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress);
    public BuildRequestBlocker(int requestGlobalRequestId, String[] targetsInProgress, int unsubmittedRequestBlockingGlobalRequestId, string unsubmittedRequestBlockingTarget, BuildResult partialBuildResult);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public String[] get_TargetsInProgress();
    [DebuggerStepThroughAttribute]
public int get_BlockingRequestId();
    [DebuggerStepThroughAttribute]
public string get_BlockingTarget();
    [DebuggerStepThroughAttribute]
public BuildRequest[] get_BuildRequests();
    [DebuggerStepThroughAttribute]
public YieldAction get_YieldAction();
    public BuildResult get_PartialBuildResult();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestCompletedDelegate : MulticastDelegate {
    public BuildRequestCompletedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry completedEntry);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry completedEntry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfiguration : object {
    public static int InvalidConfigurationId;
    private int _configId;
    private string _projectFullPath;
    private string _toolsVersion;
    private bool _explicitToolsVersionSpecified;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private Nullable`1<bool> _isTraversalProject;
    private object _syncLock;
    private ProjectInstance _project;
    private ProjectInstance _transferredState;
    private List`1<ProjectPropertyInstance> _transferredProperties;
    private List`1<string> _projectInitialTargets;
    private List`1<string> _projectDefaultTargets;
    private Lookup _baseLookup;
    private Dictionary`2<string, int> _activelyBuildingTargets;
    private int _resultsNodeId;
    private Dictionary`2<string, string> _savedEnvironmentVariables;
    private string _savedCurrentDirectory;
    private bool _translateEntireProjectInstanceState;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <TargetNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCacheable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitlyLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCached>k__BackingField;
    internal IReadOnlyCollection`1<string> TargetNames { get; }
    public bool IsCacheable { get; public set; }
    public bool ExplicitlyLoaded { get; public set; }
    public bool IsActivelyBuilding { get; }
    public bool IsLoaded { get; }
    public bool IsCached { get; private set; }
    public bool IsTraversal { get; }
    public bool WasGeneratedByNode { get; }
    public int ConfigurationId { get; public set; }
    public string ProjectFullPath { get; }
    public string ToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalProperties { get; }
    public ProjectInstance Project { get; public set; }
    public bool HasTargetsResolved { get; }
    public List`1<string> ProjectInitialTargets { get; public set; }
    public List`1<string> ProjectDefaultTargets { get; public set; }
    public NodePacketType Type { get; }
    public Lookup BaseLookup { get; }
    public Dictionary`2<string, int> ActivelyBuildingTargets { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public bool ExplicitToolsVersionSpecified { get; }
    internal int ResultsNodeId { get; internal set; }
    internal BuildRequestConfiguration(BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, ProjectInstance instance);
    private BuildRequestConfiguration(int configId, BuildRequestConfiguration other);
    private BuildRequestConfiguration(INodePacketTranslator translator);
    [CompilerGeneratedAttribute]
internal IReadOnlyCollection`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
public bool get_IsCacheable();
    [CompilerGeneratedAttribute]
public void set_IsCacheable(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitlyLoaded();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyLoaded(bool value);
    public bool get_IsActivelyBuilding();
    public bool get_IsLoaded();
    [CompilerGeneratedAttribute]
public bool get_IsCached();
    [CompilerGeneratedAttribute]
private void set_IsCached(bool value);
    public bool get_IsTraversal();
    public bool get_WasGeneratedByNode();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public void set_ConfigurationId(int value);
    public string get_ProjectFullPath();
    public string get_ToolsVersion();
    public PropertyDictionary`1<ProjectPropertyInstance> get_GlobalProperties();
    [DebuggerStepThroughAttribute]
public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public void set_Project(ProjectInstance value);
    private void SetProjectBasedState(ProjectInstance project);
    public void InitializeProject(BuildParameters buildParameters, Func`1<ProjectInstance> loadProjectFromFile);
    internal void CreateUniqueGlobalProperty();
    public bool get_HasTargetsResolved();
    public List`1<string> get_ProjectInitialTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectInitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_ProjectDefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectDefaultTargets(List`1<string> value);
    public sealed virtual NodePacketType get_Type();
    public Lookup get_BaseLookup();
    public Dictionary`2<string, int> get_ActivelyBuildingTargets();
    public Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public string get_SavedCurrentDirectory();
    public void set_SavedCurrentDirectory(string value);
    public bool get_ExplicitToolsVersionSpecified();
    internal int get_ResultsNodeId();
    internal void set_ResultsNodeId(int value);
    public static bool op_Equality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public static bool op_Inequality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public void CacheIfPossible();
    public void RetrieveFromCache();
    public List`1<string> GetTargetsUsedToBuildRequest(BuildRequest request);
    public List`1<string> GetAfterTargetsForDefaultTargets(BuildRequest request);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildRequestConfiguration other);
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal void ApplyTransferredState(ProjectInstance instance);
    internal string GetCacheFile();
    internal void ClearCacheFile();
    internal BuildRequestConfiguration ShallowCloneWithNewId(int newId);
    private bool InternalEquals(BuildRequestConfiguration other);
    private static string ResolveToolsVersion(BuildRequestData data, string defaultToolsVersion);
    private INodePacketTranslator GetConfigurationTranslator(TranslationDirection direction);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfigurationResponse : object {
    private int _nodeConfigId;
    private int _globalConfigId;
    private int _resultsNodeId;
    public int NodeConfigurationId { get; }
    public int GlobalConfigurationId { get; }
    public int ResultsNodeId { get; }
    public NodePacketType Type { get; }
    public BuildRequestConfigurationResponse(int nodeConfigId, int globalConfigId, int resultsNodeId);
    private BuildRequestConfigurationResponse(INodePacketTranslator translator);
    public int get_NodeConfigurationId();
    public int get_GlobalConfigurationId();
    public int get_ResultsNodeId();
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestEngine : object {
    private static int StartingUnresolvedConfigId;
    private static int StartingBuildRequestId;
    private BuildRequestEngineStatus _status;
    private IBuildComponentHost _componentHost;
    private ActionBlock`1<Action> _workQueue;
    private List`1<BuildRequestEntry> _requests;
    private Dictionary`2<int, BuildRequestEntry> _requestsByGlobalRequestId;
    private Queue`1<PendingUnsubmittedBuildRequests> _unsubmittedRequests;
    private int _nextUnresolvedConfigurationId;
    private int _nextBuildRequestId;
    private IConfigCache _configCache;
    private IConfigCache _unresolvedConfigurations;
    private NodeLoggingContext _nodeLoggingContext;
    private bool _debugDumpState;
    private string _debugDumpPath;
    private bool _debugForceCaching;
    [CompilerGeneratedAttribute]
private RequestCompleteDelegate OnRequestComplete;
    [CompilerGeneratedAttribute]
private RequestResumedDelegate OnRequestResumed;
    [CompilerGeneratedAttribute]
private RequestBlockedDelegate OnRequestBlocked;
    [CompilerGeneratedAttribute]
private EngineStatusChangedDelegate OnStatusChanged;
    [CompilerGeneratedAttribute]
private NewConfigurationRequestDelegate OnNewConfigurationRequest;
    [CompilerGeneratedAttribute]
private EngineExceptionDelegate OnEngineException;
    public BuildRequestEngineStatus Status { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnEngineException(EngineExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnEngineException(EngineExceptionDelegate value);
    public sealed virtual BuildRequestEngineStatus get_Status();
    public sealed virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public sealed virtual void CleanupForBuild();
    public sealed virtual void SubmitBuildRequest(BuildRequest request);
    public sealed virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public sealed virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void BuildRequestEntry_StateChanged(BuildRequestEntry entry, BuildRequestEntryState newState);
    private void RaiseRequestComplete(BuildRequest request, BuildResult result);
    private void RaiseRequestResumed(BuildRequest request);
    private void RaiseEngineException(Exception e);
    private void RaiseRequestBlocked(BuildRequestBlocker blocker);
    private void RaiseEngineStatusChanged(BuildRequestEngineStatus newStatus);
    private void RaiseNewConfigurationRequest(BuildRequestConfiguration config);
    private void ChangeStatus(BuildRequestEngineStatus newStatus);
    private void EvaluateRequestStates();
    private void CheckMemoryUsage();
    private void ActivateBuildRequest(BuildRequestEntry entry);
    private IRequestBuilder GetRequestBuilder();
    private static void BeginDeactivateBuildRequest(BuildRequestEntry entry);
    private static void WaitForDeactivateCompletion(BuildRequestEntry entry);
    private void Builder_OnNewBuildRequests(BuildRequestEntry sourceEntry, FullyQualifiedBuildRequest[] newRequests);
    private void Builder_OnBlockedRequest(BuildRequestEntry sourceEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    private void IssueUnsubmittedRequests();
    private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBuildRequest[] newRequests);
    private int GetNextUnresolvedConfigurationId();
    private int GetNextBuildRequestId();
    private void IssueConfigurationRequest(BuildRequestConfiguration config);
    private void IssueBuildRequest(BuildRequestBlocker blocker);
    private void QueueAction(Action action, bool isLastTask);
    private void TraceEngine(string format, Object[] stuff);
    [CompilerGeneratedAttribute]
private void <CleanupForBuild>b__38_0();
    [CompilerGeneratedAttribute]
private void <BuildRequestEntry_StateChanged>b__45_0();
}
internal enum Microsoft.Build.BackEnd.BuildRequestEngineStatus : Enum {
    public int value__;
    public static BuildRequestEngineStatus Uninitialized;
    public static BuildRequestEngineStatus Idle;
    public static BuildRequestEngineStatus Active;
    public static BuildRequestEngineStatus Waiting;
    public static BuildRequestEngineStatus Shutdown;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntry : object {
    private Dictionary`2<int, List`1<BuildRequest>> _unresolvedConfigurations;
    private List`1<BuildRequest> _requestsToIssue;
    private List`1<BuildRequestConfiguration> _unresolvedConfigurationsToIssue;
    private Dictionary`2<int, BuildRequest> _outstandingRequests;
    private Dictionary`2<int, BuildResult> _outstandingResults;
    private int _blockingGlobalRequestId;
    private IRequestBuilder _requestBuilder;
    private string _projectRootDirectory;
    [CompilerGeneratedAttribute]
private BuildRequestEntryStateChangedDelegate OnStateChanged;
    [CompilerGeneratedAttribute]
private object <GlobalLock>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestEntryState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestConfiguration <RequestConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <Result>k__BackingField;
    public object GlobalLock { get; }
    public string ProjectRootDirectory { get; }
    public BuildRequestEntryState State { get; private set; }
    public BuildRequest Request { get; }
    public BuildRequestConfiguration RequestConfiguration { get; }
    public BuildResult Result { get; private set; }
    public IRequestBuilder Builder { get; public set; }
    internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration requestConfiguration);
    [CompilerGeneratedAttribute]
public void add_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    [CompilerGeneratedAttribute]
public object get_GlobalLock();
    public string get_ProjectRootDirectory();
    [CompilerGeneratedAttribute]
public BuildRequestEntryState get_State();
    [CompilerGeneratedAttribute]
private void set_State(BuildRequestEntryState value);
    [CompilerGeneratedAttribute]
public BuildRequest get_Request();
    [CompilerGeneratedAttribute]
public BuildRequestConfiguration get_RequestConfiguration();
    [CompilerGeneratedAttribute]
public BuildResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(BuildResult value);
    [DebuggerStepThroughAttribute]
public IRequestBuilder get_Builder();
    [DebuggerStepThroughAttribute]
public void set_Builder(IRequestBuilder value);
    public void WaitForConfiguration(BuildRequestConfiguration configuration);
    public void WaitForResult(BuildRequest newRequest);
    public void WaitForBlockingRequest(int blockingGlobalRequestId);
    public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId);
    public List`1<BuildRequest> GetRequestsToIssueIfReady();
    public List`1<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue();
    public String[] GetActiveTargets();
    public void ReportResult(BuildResult result);
    public void Unblock();
    public IDictionary`2<int, BuildResult> Continue();
    public void BeginCancel();
    public void WaitForCancelCompletion();
    public void Complete(BuildResult result);
    private void WaitForResult(BuildRequest newRequest, bool addToIssueList);
    private void ChangeState(BuildRequestEntryState newState);
}
internal enum Microsoft.Build.BackEnd.BuildRequestEntryState : Enum {
    public int value__;
    public static BuildRequestEntryState Active;
    public static BuildRequestEntryState Ready;
    public static BuildRequestEntryState Waiting;
    public static BuildRequestEntryState Complete;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntryStateChangedDelegate : MulticastDelegate {
    public BuildRequestEntryStateChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry entry, BuildRequestEntryState newState);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry entry, BuildRequestEntryState newState, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestUnblocker : object {
    private int _blockedGlobalRequestId;
    private BuildResult _buildResult;
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public BuildResult Result { get; }
    internal BuildRequestUnblocker(INodePacketTranslator translator);
    internal BuildRequestUnblocker(int globalRequestIdToResume);
    internal BuildRequestUnblocker(BuildResult buildResult);
    internal BuildRequestUnblocker(BuildRequest parentRequest, BuildResult buildResult);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public BuildResult get_Result();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
[RunInMTAAttribute]
internal class Microsoft.Build.BackEnd.CallTarget : object {
    private TaskLoggingHelper _logHelper;
    private List`1<ITaskItem> _targetOutputs;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    public TaskLoggingHelper get_Log();
    public sealed virtual bool Execute();
    public Task`1<bool> ExecuteInternal();
}
internal class Microsoft.Build.BackEnd.CircularDependencyException : Exception {
    protected CircularDependencyException(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache {
    public abstract virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public abstract virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public abstract virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public abstract virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache : RegisteredTaskObjectCacheBase {
    protected virtual override void Finalize();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase : object {
    private static Lazy`1<ConcurrentDictionary`2<object, object>> s_appDomainLifetimeObjects;
    private Lazy`1<ConcurrentDictionary`2<object, object>> _buildLifetimeObjects;
    private static RegisteredTaskObjectCacheBase();
    public sealed virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    protected bool IsCollectionEmptyOrUncreated(RegisteredTaskObjectLifetime lifetime);
    protected ConcurrentDictionary`2<object, object> GetCollectionForLifetime(RegisteredTaskObjectLifetime lifetime, bool dontCreate);
    protected Lazy`1<ConcurrentDictionary`2<object, object>> GetLazyCollectionForLifetime(RegisteredTaskObjectLifetime lifetime);
    private static void DisposeObjects(Lazy`1<ConcurrentDictionary`2<object, object>> lifetimeObjects);
}
internal class Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext : LoggingContext {
    private string _projectFile;
    public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, string projectFile);
    public void LogProjectEvaluationStarted();
    internal void LogProjectEvaluationFinished();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.BackEnd.ConfigCache : object {
    private Dictionary`2<int, BuildRequestConfiguration> _configurations;
    private object _lockObject;
    private Dictionary`2<ConfigurationMetadata, int> _configurationIdsByMetadata;
    private int _sweepThreshhold;
    public BuildRequestConfiguration Item { get; }
    public sealed virtual BuildRequestConfiguration get_Item(int configId);
    public sealed virtual void AddConfiguration(BuildRequestConfiguration config);
    public sealed virtual void RemoveConfiguration(int configId);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public sealed virtual bool HasConfiguration(int configId);
    public sealed virtual void ClearConfigurations();
    public sealed virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public sealed virtual bool IsConfigCacheSizeLargerThanThreshold();
    public sealed virtual bool WriteConfigurationsToDisk();
    public sealed virtual IEnumerator`1<BuildRequestConfiguration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    protected int GetKeyForConfiguration(BuildRequestConfiguration config);
}
internal class Microsoft.Build.BackEnd.ConfigCreateCallback : MulticastDelegate {
    public ConfigCreateCallback(object object, IntPtr method);
    public virtual BuildRequestConfiguration Invoke(BuildRequestConfiguration existingConfiguration, bool loadProject);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration existingConfiguration, bool loadProject, AsyncCallback callback, object object);
    public virtual BuildRequestConfiguration EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ConfigurationMetadata : object {
    [CompilerGeneratedAttribute]
private string <ProjectFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDictionary`1<ProjectPropertyInstance> <GlobalProperties>k__BackingField;
    public string ProjectFullPath { get; }
    public string ToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalProperties { get; }
    public ConfigurationMetadata(BuildRequestConfiguration configuration);
    public ConfigurationMetadata(Project project);
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public PropertyDictionary`1<ProjectPropertyInstance> get_GlobalProperties();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConfigurationMetadata other);
    private bool InternalEquals(ConfigurationMetadata other);
}
internal enum Microsoft.Build.BackEnd.ContinueOnError : Enum {
    public int value__;
    public static ContinueOnError ErrorAndStop;
    public static ContinueOnError ErrorAndContinue;
    public static ContinueOnError WarnAndContinue;
}
internal class Microsoft.Build.BackEnd.DataReceivedDelegate : MulticastDelegate {
    public DataReceivedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, INodePacket packet);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, INodePacket packet, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.DependencyAnalysisLogDetail : object {
    private OutofdateReason _reason;
    private string _inputItemName;
    private string _outputItemName;
    private string _input;
    private string _output;
    internal OutofdateReason Reason { get; }
    public string InputItemName { get; }
    public string OutputItemName { get; }
    public string Input { get; }
    public string Output { get; }
    public DependencyAnalysisLogDetail(string input, string output, string inputItemName, string outputItemName, OutofdateReason reason);
    internal OutofdateReason get_Reason();
    public string get_InputItemName();
    public string get_OutputItemName();
    public string get_Input();
    public string get_Output();
}
internal enum Microsoft.Build.BackEnd.DependencyAnalysisResult : Enum {
    public int value__;
    public static DependencyAnalysisResult SkipUpToDate;
    public static DependencyAnalysisResult SkipNoInputs;
    public static DependencyAnalysisResult SkipNoOutputs;
    public static DependencyAnalysisResult IncrementalBuild;
    public static DependencyAnalysisResult FullBuild;
}
internal class Microsoft.Build.BackEnd.EngineExceptionDelegate : MulticastDelegate {
    public EngineExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.EngineStatusChangedDelegate : MulticastDelegate {
    public EngineStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEngineStatus newStatus);
    public virtual IAsyncResult BeginInvoke(BuildRequestEngineStatus newStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.FullyQualifiedBuildRequest : object {
    [CompilerGeneratedAttribute]
private BuildRequestConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResultsNeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <BuildRequestDataFlags>k__BackingField;
    public BuildRequestConfiguration Config { get; }
    public String[] Targets { get; }
    public bool ResultsNeeded { get; }
    public BuildRequestDataFlags BuildRequestDataFlags { get; public set; }
    public FullyQualifiedBuildRequest(BuildRequestConfiguration config, String[] targets, bool resultsNeeded, BuildRequestDataFlags flags);
    [CompilerGeneratedAttribute]
public BuildRequestConfiguration get_Config();
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public bool get_ResultsNeeded();
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_BuildRequestDataFlags();
    [CompilerGeneratedAttribute]
public void set_BuildRequestDataFlags(BuildRequestDataFlags value);
    public static bool op_Equality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public static bool op_Inequality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool InternalEquals(FullyQualifiedBuildRequest other);
}
internal interface Microsoft.Build.BackEnd.IBuildComponent {
    public abstract virtual void InitializeComponent(IBuildComponentHost host);
    public abstract virtual void ShutdownComponent();
}
internal interface Microsoft.Build.BackEnd.IBuildComponentHost {
    public string Name { get; }
    public BuildParameters BuildParameters { get; }
    public LegacyThreadingData LegacyThreadingData { get; }
    public ILoggingService LoggingService { get; }
    public abstract virtual string get_Name();
    public abstract virtual BuildParameters get_BuildParameters();
    public abstract virtual LegacyThreadingData get_LegacyThreadingData();
    public abstract virtual ILoggingService get_LoggingService();
    public abstract virtual void RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    public abstract virtual IBuildComponent GetComponent(BuildComponentType type);
}
internal interface Microsoft.Build.BackEnd.IBuildRequestEngine {
    public BuildRequestEngineStatus Status { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnEngineException(EngineExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnEngineException(EngineExceptionDelegate value);
    public abstract virtual BuildRequestEngineStatus get_Status();
    public abstract virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public abstract virtual void CleanupForBuild();
    public abstract virtual void SubmitBuildRequest(BuildRequest request);
    public abstract virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public abstract virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IBuildResults {
    public Exception Exception { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public ITargetResult Item { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual BuildResultCode get_OverallResult();
    public abstract virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public abstract virtual Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public abstract virtual void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public abstract virtual string get_SavedCurrentDirectory();
    public abstract virtual void set_SavedCurrentDirectory(string value);
    public abstract virtual ITargetResult get_Item(string target);
    public abstract virtual bool HasResultsForTarget(string target);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IConfigCache {
    public BuildRequestConfiguration Item { get; }
    public abstract virtual BuildRequestConfiguration get_Item(int configId);
    public abstract virtual void AddConfiguration(BuildRequestConfiguration config);
    public abstract virtual void RemoveConfiguration(int configId);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public abstract virtual bool HasConfiguration(int configId);
    public abstract virtual void ClearConfigurations();
    public abstract virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public abstract virtual bool IsConfigCacheSizeLargerThanThreshold();
    public abstract virtual bool WriteConfigurationsToDisk();
}
internal interface Microsoft.Build.BackEnd.INode {
    public abstract virtual NodeEngineShutdownReason Run(Exception& shutdownException);
}
internal interface Microsoft.Build.BackEnd.INodeEndpoint {
    public LinkStatus LinkStatus { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public abstract virtual LinkStatus get_LinkStatus();
    public abstract virtual void Listen(INodePacketFactory factory);
    public abstract virtual void Connect(INodePacketFactory factory);
    public abstract virtual void Disconnect();
    public abstract virtual void SendData(INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodeManager {
    public abstract virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity affinity);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownConnectedNodes(bool enableReuse);
    public abstract virtual void ShutdownAllNodes();
    public abstract virtual void ClearPerBuildState();
}
internal interface Microsoft.Build.BackEnd.INodePacket {
    public NodePacketType Type { get; }
    public abstract virtual NodePacketType get_Type();
}
internal interface Microsoft.Build.BackEnd.INodePacketFactory {
    public abstract virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public abstract virtual void UnregisterPacketHandler(NodePacketType packetType);
    public abstract virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public abstract virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodePacketHandler {
    public abstract virtual void PacketReceived(int node, INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodePacketTranslatable {
    public abstract virtual void Translate(INodePacketTranslator translator);
}
internal interface Microsoft.Build.BackEnd.INodePacketTranslator {
    public TranslationDirection Mode { get; }
    public BinaryReader Reader { get; }
    public BinaryWriter Writer { get; }
    public abstract virtual TranslationDirection get_Mode();
    public abstract virtual BinaryReader get_Reader();
    public abstract virtual BinaryWriter get_Writer();
    public abstract virtual void Translate(Boolean& value);
    public abstract virtual void Translate(Byte& value);
    public abstract virtual void Translate(Int16& value);
    public abstract virtual void Translate(UInt16& value);
    public abstract virtual void Translate(Int32& value);
    public abstract virtual void Translate(Int64& value);
    public abstract virtual void Translate(String& value);
    public abstract virtual void Translate(Double& value);
    public abstract virtual void Translate(String[]& array);
    public abstract virtual void Translate(List`1& list);
    public abstract virtual void Translate(HashSet`1& set);
    public abstract virtual void Translate(List`1& list, NodePacketValueFactory`1<T> factory);
    public abstract virtual void Translate(IList`1& list, NodePacketValueFactory`1<T> factory, NodePacketCollectionCreator`1<L> collectionFactory);
    public abstract virtual void Translate(DateTime& value);
    public abstract virtual void Translate(TimeSpan& value);
    public abstract virtual void Translate(BuildEventContext& value);
    public abstract virtual void TranslateEnum(T& value, int numericValue);
    public abstract virtual void TranslateDotNet(T& value);
    public abstract virtual void TranslateException(Exception& value);
    public abstract virtual void Translate(T& value);
    public abstract virtual void Translate(T& value, NodePacketValueFactory`1<T> factory);
    public abstract virtual void TranslateCulture(CultureInfo& culture);
    public abstract virtual void Translate(Byte[]& byteArray);
    public abstract virtual void TranslateArray(T[]& array);
    public abstract virtual void TranslateArray(T[]& array, NodePacketValueFactory`1<T> factory);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer);
    public abstract virtual void TranslateDictionary(IDictionary`2& dictionary, NodePacketCollectionCreator`1<IDictionary`2<string, string>> collectionCreator);
    public abstract virtual void TranslateDictionary(IDictionary`2& dictionary, Translator`1<K> keyTranslator, Translator`1<V> valueTranslator, NodePacketCollectionCreator`1<IDictionary`2<K, V>> dictionaryCreator);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer, NodePacketValueFactory`1<T> valueFactory);
    public abstract virtual void TranslateDictionary(D& dictionary, NodePacketValueFactory`1<T> valueFactory);
    public abstract virtual void TranslateDictionary(D& dictionary, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<D> collectionCreator);
    public abstract virtual bool TranslateNullable(T value);
}
internal interface Microsoft.Build.BackEnd.INodeProvider {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    public abstract virtual NodeProviderType get_ProviderType();
    public abstract virtual int get_AvailableNodes();
    public abstract virtual bool CreateNode(int nodeId, INodePacketFactory packetFactory, NodeConfiguration configuration);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownConnectedNodes(bool enableReuse);
    public abstract virtual void ShutdownAllNodes();
}
internal class Microsoft.Build.BackEnd.InProcNode : object {
    private IBuildComponentHost _componentHost;
    private IDictionary`2<string, string> _savedEnvironment;
    private string _savedCurrentDirectory;
    private NodeLoggingContext _loggingContext;
    private IBuildRequestEngine _buildRequestEngine;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private AutoResetEvent _packetReceivedEvent;
    private AutoResetEvent _shutdownEvent;
    private NodeEngineShutdownReason _shutdownReason;
    private Exception _shutdownException;
    private INodeEndpoint _nodeEndpoint;
    private EngineExceptionDelegate _engineExceptionEventHandler;
    private NewConfigurationRequestDelegate _newConfigurationRequestEventHandler;
    private RequestBlockedDelegate _requestBlockedEventHandler;
    private RequestCompleteDelegate _requestCompleteEventHandler;
    public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEndpoint);
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    private void OnRequestComplete(BuildRequest request, BuildResult result);
    private void OnNewRequest(BuildRequestBlocker blocker);
    private void OnNewConfigurationRequest(BuildRequestConfiguration config);
    private void OnLoggingThreadException(Exception e);
    private void OnEngineException(Exception e);
    private NodeEngineShutdownReason HandleShutdown(Exception& exception);
    private void HandlePacket(INodePacket packet);
    private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void HandleBuildRequest(BuildRequest request);
    private static void HandleBuildRequestConfiguration();
    private void HandleBuildRequestConfigurationResponse(BuildRequestConfigurationResponse response);
    private void HandleBuildResult(BuildRequestUnblocker unblocker);
    private void HandleNodeConfiguration(NodeConfiguration configuration);
    private void HandleNodeBuildComplete(NodeBuildComplete buildComplete);
}
internal abstract class Microsoft.Build.BackEnd.IntrinsicTask : object {
    [CompilerGeneratedAttribute]
private TargetLoggingContext <LoggingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectInstance <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogTaskInputs>k__BackingField;
    internal TargetLoggingContext LoggingContext { get; private set; }
    internal ProjectInstance Project { get; private set; }
    protected bool LogTaskInputs { get; private set; }
    protected IntrinsicTask(TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    [CompilerGeneratedAttribute]
internal TargetLoggingContext get_LoggingContext();
    [CompilerGeneratedAttribute]
private void set_LoggingContext(TargetLoggingContext value);
    [CompilerGeneratedAttribute]
internal ProjectInstance get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(ProjectInstance value);
    [CompilerGeneratedAttribute]
protected bool get_LogTaskInputs();
    [CompilerGeneratedAttribute]
private void set_LogTaskInputs(bool value);
    internal static IntrinsicTask InstantiateTask(ProjectTargetInstanceChild taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal abstract virtual void ExecuteTask(Lookup lookup);
    protected static void AddIfNotEmptyString(List`1<string> list, string value);
}
internal class Microsoft.Build.BackEnd.IntrinsicTaskFactory : object {
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    public IntrinsicTaskFactory(Type intrinsicType);
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
internal interface Microsoft.Build.BackEnd.IPropertyCache {
}
internal interface Microsoft.Build.BackEnd.IRequestBuilder {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    public abstract virtual void BuildRequest(NodeLoggingContext nodeLoggingContext, BuildRequestEntry entry);
    public abstract virtual void ContinueRequest();
    public abstract virtual void CancelRequest();
    public abstract virtual void BeginCancel();
    public abstract virtual void WaitForCancelCompletion();
}
internal interface Microsoft.Build.BackEnd.IRequestBuilderCallback {
    public abstract virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    public abstract virtual Task BlockOnTargetInProgress(int blockingRequestId, string blockingTarget, BuildResult partialBuildResult);
    public abstract virtual void Yield();
    public abstract virtual void Reacquire();
    public abstract virtual void EnterMSBuildCallbackState();
    public abstract virtual void ExitMSBuildCallbackState();
}
internal interface Microsoft.Build.BackEnd.IResultsCache {
    public abstract virtual void AddResult(BuildResult result);
    public abstract virtual void ClearResults();
    public abstract virtual BuildResult GetResultForRequest(BuildRequest request);
    public abstract virtual BuildResult GetResultsForConfiguration(int configurationId);
    public abstract virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets, List`1<string> additionalTargetsToCheckForOverallResult, bool skippedResultsAreOK);
    public abstract virtual void ClearResultsForConfiguration(int configurationId);
    public abstract virtual void WriteResultsToDisk();
}
internal interface Microsoft.Build.BackEnd.IScheduler {
    public int MinimumAssignableConfigurationId { get; }
    public abstract virtual int get_MinimumAssignableConfigurationId();
    public abstract virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public abstract virtual int GetConfigurationIdFromPlan(string configurationPath);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfo);
    public abstract virtual void ReportBuildAborted(int nodeId);
    public abstract virtual void Reset();
    public abstract virtual void WriteDetailedSummary(int submissionId);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilder {
    public abstract virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext projectLoggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targets, Lookup baseLookup, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilderCallback {
    public abstract virtual Task`1<ITargetResult[]> LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation referenceLocation);
}
internal interface Microsoft.Build.BackEnd.ITaskBuilder {
    public abstract virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild task, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITaskExecutionHost {
    public ProjectInstance ProjectInstance { get; }
    public bool LogTaskInputs { get; }
    public abstract virtual ProjectInstance get_ProjectInstance();
    public abstract virtual bool get_LogTaskInputs();
    public abstract virtual void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, bool isOutOfProc, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<TaskRequirements> FindTask(IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool SetTaskParameters(IDictionary`2<string, Tuple`2<string, ElementLocation>> parameters);
    public abstract virtual bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    public abstract virtual void CleanupForBatch();
    public abstract virtual void CleanupForTask();
    public abstract virtual bool Execute();
}
internal class Microsoft.Build.BackEnd.ItemBucket : object {
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private Dictionary`2<string, string> _metadata;
    private Lookup _lookup;
    private int _bucketSequenceNumber;
    private Scope _lookupEntry;
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> Expander { get; }
    internal int BucketSequenceNumber { get; }
    internal Lookup Lookup { get; }
    internal ItemBucket(ICollection`1<string> itemNames, Dictionary`2<string, string> metadata, Lookup lookup, int bucketSequenceNumber);
    public sealed virtual int CompareTo(object obj);
    internal static ItemBucket GetDummyBucketForComparisons(Dictionary`2<string, string> metadata);
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> get_Expander();
    internal int get_BucketSequenceNumber();
    internal Lookup get_Lookup();
    internal void AddItem(ProjectItemInstance item);
    internal void LeaveScope();
}
internal class Microsoft.Build.BackEnd.ItemGroupIntrinsicTask : IntrinsicTask {
    private ProjectItemGroupTaskInstance _taskInstance;
    private EngineFileUtilities _engineFileUtilities;
    public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal virtual void ExecuteTask(Lookup lookup);
    private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata);
    private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bucket);
    private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata);
    private void GetBatchableValuesFromBuildItemGroupChild(List`1<string> parameterValues, ProjectItemGroupTaskItemInstance child);
    private IList`1<ProjectItemInstance> ExpandItemIntoItems(ProjectItemGroupTaskItemInstance originalItem, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata);
    private List`1<ProjectItemInstance> FindItemsMatchingSpecification(ICollection`1<ProjectItemInstance> items, string specification, ElementLocation specificationLocation, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander);
}
internal static class Microsoft.Build.BackEnd.ItemGroupLoggingHelper : object {
    internal static string GetParameterText(string prefix, string parameterName, Object[] parameterValues);
    internal static string GetParameterText(string prefix, string parameterName, IList parameterValue);
    internal static string GetStringFromParameterValue(object parameterValue);
}
internal enum Microsoft.Build.BackEnd.LinkStatus : Enum {
    public int value__;
    public static LinkStatus Inactive;
    public static LinkStatus Active;
    public static LinkStatus Failed;
    public static LinkStatus ConnectionFailed;
}
internal class Microsoft.Build.BackEnd.LinkStatusChangedDelegate : MulticastDelegate {
    public LinkStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, LinkStatus status);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, LinkStatus status, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class Microsoft.Build.BackEnd.Logging.BaseConsoleLogger : object {
    private static bool _supportReadingBackgroundColor;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipProjectStartedText>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShowSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private WriteHandler <WriteHandler>k__BackingField;
    internal DateTime buildStarted;
    internal ColorSetter setColor;
    internal ColorResetter resetColor;
    internal static int tabWidth;
    internal int currentIndentLevel;
    internal static String[] newLines;
    internal static string projectSeparatorLine;
    internal static Char[] parameterDelimiters;
    private static Char[] s_parameterValueSplitCharacter;
    internal bool showPerfSummary;
    internal bool showItemAndPropertyList;
    internal bool showTargetOutputs;
    protected bool showOnlyWarnings;
    protected bool showOnlyErrors;
    protected bool showEnvironment;
    protected bool showProjectFile;
    internal bool ignoreLoggerErrors;
    internal bool runningWithCharacterFileType;
    internal int errorCount;
    internal int warningCount;
    internal List`1<BuildErrorEventArgs> errorList;
    internal List`1<BuildWarningEventArgs> warningList;
    internal Dictionary`2<string, PerformanceCounter> projectPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> targetPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> taskPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> projectEvaluationPerformanceCounters;
    internal static ConsoleColor BackgroundColor { get; }
    public LoggerVerbosity Verbosity { get; public set; }
    public int NumberOfProcessors { get; public set; }
    public string Parameters { get; public set; }
    internal bool SkipProjectStartedText { get; internal set; }
    internal Nullable`1<bool> ShowSummary { get; internal set; }
    protected internal WriteHandler WriteHandler { get; protected internal set; }
    private static BaseConsoleLogger();
    internal static ConsoleColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public int get_NumberOfProcessors();
    [CompilerGeneratedAttribute]
public void set_NumberOfProcessors(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    [CompilerGeneratedAttribute]
internal bool get_SkipProjectStartedText();
    [CompilerGeneratedAttribute]
internal void set_SkipProjectStartedText(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_ShowSummary();
    [CompilerGeneratedAttribute]
internal void set_ShowSummary(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
protected internal WriteHandler get_WriteHandler();
    [CompilerGeneratedAttribute]
protected internal void set_WriteHandler(WriteHandler value);
    public void ParseParameters();
    internal string IndentString(string s, int indent);
    internal static String[] SplitStringOnNewLines(string s);
    internal void WriteNewLine();
    internal void WriteLinePrettyFromResource(string resourceString, Object[] args);
    internal void WriteLinePrettyFromResource(int indentLevel, string resourceString, Object[] args);
    internal void WritePretty(string formattedString);
    internal void ShowPerfSummary();
    internal void WritePretty(int indentLevel, string formattedString);
    internal void WriteLinePretty(string formattedString);
    internal void WriteLinePretty(int indentLevel, string formattedString);
    internal void IsRunningWithCharacterFileType();
    internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
    internal static void SetColor(ConsoleColor c);
    internal static void ResetColor();
    internal static void SetColorAnsi(ConsoleColor c);
    internal static void ResetColorAnsi();
    internal static ConsoleColor TransformColor(ConsoleColor foreground, ConsoleColor background);
    internal static void DontSetColor(ConsoleColor c);
    internal static void DontResetColor();
    internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandler logwriter, ColorSetter colorSet, ColorResetter colorReset);
    internal void WriteProperties(List`1<DictionaryEntry> properties);
    internal void WriteEnvironment(IDictionary`2<string, string> environment);
    internal List`1<DictionaryEntry> ExtractPropertyList(IEnumerable properties);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal virtual void OutputProperties(List`1<DictionaryEntry> list);
    internal void WriteItems(SortedList itemTypes);
    internal SortedList ExtractItemList(IEnumerable items);
    internal virtual void OutputItems(string itemType, ArrayList itemTypeList);
    internal static PerformanceCounter GetPerformanceCounter(string scopeName, Dictionary`2& table);
    internal void DisplayCounters(Dictionary`2<string, PerformanceCounter> counters);
    public virtual void Shutdown();
    internal abstract virtual void ResetConsoleLoggerState();
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Initialize(IEventSource eventSource);
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    private bool ApplyVerbosityParameter(string parameterValue);
    public abstract virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public abstract virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public abstract virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public abstract virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public abstract virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public abstract virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public abstract virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public abstract virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public abstract virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public abstract virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public abstract virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public abstract virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    public abstract virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink : object {
    private SendDataDelegate _sendDataDelegate;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildStartedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<int, ISet`1<string>> <WarningsAsErrorsByProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<int, ISet`1<string>> <WarningsAsMessagesByProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<int> <BuildSubmissionIdsThatHaveLoggedErrors>k__BackingField;
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public IDictionary`2<int, ISet`1<string>> WarningsAsErrorsByProject { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public IDictionary`2<int, ISet`1<string>> WarningsAsMessagesByProject { get; public set; }
    public ISet`1<int> BuildSubmissionIdsThatHaveLoggedErrors { get; }
    internal BuildEventArgTransportSink(SendDataDelegate sendData);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<int, ISet`1<string>> get_WarningsAsErrorsByProject();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrorsByProject(IDictionary`2<int, ISet`1<string>> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessages(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<int, ISet`1<string>> get_WarningsAsMessagesByProject();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessagesByProject(IDictionary`2<int, ISet`1<string>> value);
    [CompilerGeneratedAttribute]
public ISet`1<int> get_BuildSubmissionIdsThatHaveLoggedErrors();
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void ShutDown();
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventManager : object {
    private Dictionary`2<BuildEventContext, ProjectStartedEventMinimumFields> _projectStartedEvents;
    private Dictionary`2<BuildEventContext, TargetStartedEventMinimumFields> _targetStartedEvents;
    private Dictionary`2<string, int> _projectTargetKey;
    private Dictionary`2<string, int> _projectKey;
    private static ComparerContextNodeId`1<BuildEventContext> s_compareContextNodeId;
    private static ComparerContextNodeIdTargetId`1<BuildEventContext> s_compareContextNodeIdTargetId;
    private int _projectIncrementKey;
    private static BuildEventManager();
    internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTimestamp);
    internal void AddTargetStartedEvent(TargetStartedEventArgs e, bool requireTimeStamp);
    internal List`1<ProjectStartedEventMinimumFields> GetProjectCallStack(BuildEventContext e);
    internal void SetErrorWarningFlagOnCallStack(BuildEventContext e);
    internal String[] ProjectCallStackFromProject(BuildEventContext e);
    internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e);
    internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e);
    internal void RemoveProjectStartedEvent(BuildEventContext e);
    internal void RemoveTargetStartedEvent(BuildEventContext e);
}
internal class Microsoft.Build.BackEnd.Logging.BuildLoggingContext : LoggingContext {
    private bool _isInProcNode;
    public bool IsInProcNode { get; }
    protected BuildLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, bool inProc);
    protected BuildLoggingContext(BuildLoggingContext baseContext);
    [DebuggerStepThroughAttribute]
public bool get_IsInProcNode();
    internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, string taskName);
}
internal class Microsoft.Build.BackEnd.Logging.CentralForwardingLogger : object {
    [CompilerGeneratedAttribute]
private IEventRedirector <BuildEventRedirector>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IEventRedirector get_BuildEventRedirector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NodeId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent);
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeIdTargetId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal class Microsoft.Build.BackEnd.Logging.ErrorWarningSummaryDictionaryKey : object {
    private BuildEventContext _entryPointContext;
    private string _targetName;
    private static ComparerContextNodeId`1<BuildEventContext> s_eventComparer;
    internal BuildEventContext EntryPointContext { get; }
    internal string TargetName { get; }
    internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName);
    private static ErrorWarningSummaryDictionaryKey();
    internal BuildEventContext get_EntryPointContext();
    internal string get_TargetName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.EventRedirectorToSink : object {
    private int _centralLoggerId;
    private IBuildEventSink _sink;
    internal EventRedirectorToSink(int loggerId, IBuildEventSink eventSink);
    private sealed virtual override void Microsoft.Build.Framework.IEventRedirector.ForwardEvent(BuildEventArgs buildEvent);
}
internal class Microsoft.Build.BackEnd.Logging.EventSourceSink : object {
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
private TelemetryEventHandler TelemetryLogged;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildStartedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationMetaprojects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTaskInputs>k__BackingField;
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; private set; }
    public bool IncludeEvaluationProfiles { get; private set; }
    public bool IncludeTaskInputs { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TelemetryLogged(TelemetryEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TelemetryLogged(TelemetryEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationMetaprojects();
    [CompilerGeneratedAttribute]
private void set_IncludeEvaluationMetaprojects(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationProfiles();
    [CompilerGeneratedAttribute]
private void set_IncludeEvaluationProfiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTaskInputs();
    [CompilerGeneratedAttribute]
private void set_IncludeTaskInputs(bool value);
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects();
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles();
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs();
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void ShutDown();
    internal void UnregisterAllEventHandlers();
    private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent);
    private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent);
    private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent);
    private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent);
    private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent);
    private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent);
    private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent);
    private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent);
    private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent);
    private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent);
    private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent);
    private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent);
    private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent);
    private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent);
    private void RaiseTelemetryEvent(object sender, TelemetryEventArgs buildEvent);
}
internal interface Microsoft.Build.BackEnd.Logging.IBuildEventSink {
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual bool get_HaveLoggedBuildStartedEvent();
    public abstract virtual void set_HaveLoggedBuildStartedEvent(bool value);
    public abstract virtual bool get_HaveLoggedBuildFinishedEvent();
    public abstract virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    public abstract virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public abstract virtual void Consume(BuildEventArgs buildEvent);
    public abstract virtual void ShutDown();
}
internal interface Microsoft.Build.BackEnd.Logging.ILoggingService {
    public LoggingServiceState ServiceState { get; }
    public LoggerMode LoggingMode { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfile { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    public abstract virtual LoggingServiceState get_ServiceState();
    public abstract virtual LoggerMode get_LoggingMode();
    public abstract virtual bool get_OnlyLogCriticalEvents();
    public abstract virtual void set_OnlyLogCriticalEvents(bool value);
    public abstract virtual int get_MaxCPUCount();
    public abstract virtual void set_MaxCPUCount(int value);
    public abstract virtual ICollection`1<ILogger> get_Loggers();
    public abstract virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public abstract virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public abstract virtual ICollection`1<string> get_RegisteredSinkNames();
    public abstract virtual String[] get_PropertiesToSerialize();
    public abstract virtual void set_PropertiesToSerialize(String[] value);
    public abstract virtual bool get_SerializeAllProperties();
    public abstract virtual void set_SerializeAllProperties(bool value);
    public abstract virtual bool get_RunningOnRemoteNode();
    public abstract virtual void set_RunningOnRemoteNode(bool value);
    public abstract virtual ISet`1<string> get_WarningsAsErrors();
    public abstract virtual void set_WarningsAsErrors(ISet`1<string> value);
    public abstract virtual ISet`1<string> get_WarningsAsMessages();
    public abstract virtual void set_WarningsAsMessages(ISet`1<string> value);
    public abstract virtual bool get_IncludeEvaluationMetaprojects();
    public abstract virtual void set_IncludeEvaluationMetaprojects(bool value);
    public abstract virtual bool get_IncludeEvaluationProfile();
    public abstract virtual void set_IncludeEvaluationProfile(bool value);
    public abstract virtual bool get_IncludeTaskInputs();
    public abstract virtual void set_IncludeTaskInputs(bool value);
    public abstract virtual void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet`1<string> codes);
    public abstract virtual void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public abstract virtual bool HasBuildSubmissionLoggedErrors(int submissionId);
    public abstract virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public abstract virtual bool RegisterLogger(ILogger logger);
    public abstract virtual void UnregisterAllLoggers();
    public abstract virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> loggerDescriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public abstract virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public abstract virtual void LogBuildEvent(BuildEventArgs buildEvent);
    public abstract virtual void LogError(BuildEventContext buildEventContext, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public abstract virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public abstract virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogBuildStarted();
    public abstract virtual void LogBuildFinished(bool success);
    public abstract virtual BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
    public abstract virtual void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile);
    public abstract virtual void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile);
    public abstract virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items);
    public abstract virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public abstract virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason);
    public abstract virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public abstract virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public abstract virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public abstract virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
    public abstract virtual void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary`2<string, string> properties);
}
internal static class Microsoft.Build.BackEnd.Logging.LogFormatter : object {
    internal static string FormatLogTimeStamp(DateTime timeStamp);
    internal static string FormatTimeSpan(TimeSpan t);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggerMode : Enum {
    public int value__;
    public static LoggerMode Synchronous;
    public static LoggerMode Asynchronous;
}
internal class Microsoft.Build.BackEnd.Logging.LoggingContext : object {
    private ILoggingService _loggingService;
    private BuildEventContext _eventContext;
    private bool _isValid;
    public ILoggingService LoggingService { get; }
    public BuildEventContext BuildEventContext { get; protected set; }
    public bool IsValid { get; protected set; }
    public LoggingContext(ILoggingService loggingService, BuildEventContext eventContext);
    public LoggingContext(LoggingContext baseContext);
    [DebuggerStepThroughAttribute]
public ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    protected void set_BuildEventContext(BuildEventContext value);
    [DebuggerStepThroughAttribute]
public bool get_IsValid();
    [DebuggerStepThroughAttribute]
protected void set_IsValid(bool value);
    internal void LogComment(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    internal void LogCommentFromText(MessageImportance importance, string message);
    internal void LogError(BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogErrorFromText(string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProjectFileException);
    internal void LogFatalError(Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogWarning(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogWarningFromText(string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    internal void LogBuildEvent(BuildEventArgs buildEvent);
    internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingExceptionDelegate : MulticastDelegate {
    public LoggingExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingService : object {
    private static UInt32 DefaultQueueCapacity;
    private object _lockObject;
    private static Lazy`1<PropertyInfo> s_projectStartedEventArgsGlobalProperties;
    private static Lazy`1<PropertyInfo> s_projectStartedEventArgsToolsVersion;
    private Dictionary`2<int, string> _projectFileMap;
    private LoggingServiceState _serviceState;
    private bool _onlyLogCriticalEvents;
    private Dictionary`2<int, IBuildEventSink> _eventSinkDictionary;
    private List`1<ILogger> _loggers;
    private List`1<LoggerDescription> _loggerDescriptions;
    private EventSourceSink _filterEventSource;
    private int _centralForwardingLoggerSinkId;
    private int _nextSinkId;
    private int _maxCPUCount;
    private IBuildComponentHost _componentHost;
    private Lazy`1<IConfigCache> _configCache;
    private int _nextEvaluationId;
    private int _nextProjectId;
    private int _nextTargetId;
    private int _nextTaskId;
    private int _nodeId;
    private Nullable`1<bool> _includeEvaluationMetaprojects;
    private Nullable`1<bool> _includeEvaluationProfile;
    private Nullable`1<bool> _includeTaskInputs;
    private ISet`1<int> _buildSubmissionIdsThatHaveLoggedErrors;
    private IDictionary`2<int, ISet`1<string>> _warningsAsErrorsByProject;
    private IDictionary`2<int, ISet`1<string>> _warningsAsMessagesByProject;
    private BufferBlock`1<object> _loggingQueue;
    private ActionBlock`1<object> _loggingQueueProcessor;
    private UInt32 _queueCapacity;
    private LoggerMode _logMode;
    [CompilerGeneratedAttribute]
private LoggingExceptionDelegate OnLoggingThreadException;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler OnProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler OnProjectFinished;
    [CompilerGeneratedAttribute]
private String[] <PropertiesToSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeAllProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningOnRemoteNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public int NextEvaluationId { get; }
    public int NextProjectId { get; }
    public int NextTargetId { get; }
    public int NextTaskId { get; }
    public LoggingServiceState ServiceState { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public LoggerMode LoggingMode { get; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfile { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    public bool LoggingQueueHasEvents { get; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    protected LoggingService(LoggerMode loggerMode, int nodeId);
    private static LoggingService();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PropertiesToSerialize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PropertiesToSerialize(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SerializeAllProperties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SerializeAllProperties(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RunningOnRemoteNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RunningOnRemoteNode(bool value);
    public int get_NextEvaluationId();
    public int get_NextProjectId();
    public int get_NextTargetId();
    public int get_NextTaskId();
    public sealed virtual LoggingServiceState get_ServiceState();
    public sealed virtual bool get_OnlyLogCriticalEvents();
    public sealed virtual void set_OnlyLogCriticalEvents(bool value);
    public sealed virtual int get_MaxCPUCount();
    public sealed virtual void set_MaxCPUCount(int value);
    public sealed virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public sealed virtual ICollection`1<ILogger> get_Loggers();
    public sealed virtual LoggerMode get_LoggingMode();
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningsAsMessages(ISet`1<string> value);
    public sealed virtual bool get_IncludeEvaluationMetaprojects();
    public sealed virtual void set_IncludeEvaluationMetaprojects(bool value);
    public sealed virtual bool get_IncludeEvaluationProfile();
    public sealed virtual void set_IncludeEvaluationProfile(bool value);
    public sealed virtual bool get_IncludeTaskInputs();
    public sealed virtual void set_IncludeTaskInputs(bool value);
    public sealed virtual bool HasBuildSubmissionLoggedErrors(int submissionId);
    public sealed virtual void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public sealed virtual void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet`1<string> codes);
    public bool get_LoggingQueueHasEvents();
    public sealed virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public sealed virtual ICollection`1<string> get_RegisteredSinkNames();
    public static ILoggingService CreateLoggingService(LoggerMode mode, int node);
    public sealed virtual void InitializeComponent(IBuildComponentHost buildComponentHost);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    public sealed virtual bool RegisterLogger(ILogger logger);
    public sealed virtual void UnregisterAllLoggers();
    public sealed virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public sealed virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public sealed virtual void LogBuildEvent(BuildEventArgs buildEvent);
    internal virtual void ProcessLoggingEvent(object buildEvent, bool allowThrottling);
    internal void WaitForThreadToProcessEvents();
    internal void InjectNonSerializedData(LogMessagePacket loggingPacket);
    private static int GetWarningsAsErrorOrMessageKey(BuildEventContext buildEventContext);
    private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs);
    private void CreateLoggingEventQueue();
    private void TerminateLoggingEventQueue();
    private void ShutdownLogger(ILogger logger);
    private void CreateFilterEventSource();
    private void LoggingEventProcessor(object loggingEvent);
    private void RouteBuildEvent(object loggingEvent);
    private void RouteBuildEvent(KeyValuePair`2<int, BuildEventArgs> nodeEvent);
    private void RouteBuildEvent(BuildEventArgs eventArg);
    private void InitializeLogger(ILogger logger, IEventSource sourceForLogger);
    private void RaiseLoggingExceptionEvent(Exception ex);
    private void TryRaiseProjectStartedEvent(BuildEventArgs args);
    private void TryRaiseProjectFinishedEvent(BuildEventArgs args);
    private string GetAndVerifyProjectFileFromContext(BuildEventContext context);
    private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent);
    private bool ShouldTreatWarningAsError(BuildWarningEventArgs warningEvent);
    public sealed virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext location, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public sealed virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public sealed virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogBuildStarted();
    public sealed virtual void LogBuildFinished(bool success);
    public sealed virtual BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
    public sealed virtual void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEventContext, string projectFile);
    public sealed virtual void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile);
    public sealed virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items);
    public sealed virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public sealed virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason);
    public sealed virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public sealed virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public sealed virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public sealed virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
    public sealed virtual void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
private IConfigCache <.ctor>b__31_0();
    [CompilerGeneratedAttribute]
private void <CreateLoggingEventQueue>b__115_0(object loggingEvent);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingServiceFactory : object {
    private LoggerMode _logMode;
    private int _nodeId;
    internal LoggingServiceFactory(LoggerMode mode, int nodeId);
    public IBuildComponent CreateInstance(BuildComponentType type);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggingServiceState : Enum {
    public int value__;
    public static LoggingServiceState Instantiated;
    public static LoggingServiceState Initialized;
    public static LoggingServiceState ShuttingDown;
    public static LoggingServiceState Shutdown;
}
internal class Microsoft.Build.BackEnd.Logging.NodeLoggingContext : BuildLoggingContext {
    internal NodeLoggingContext(ILoggingService loggingService, int nodeId, bool inProcNode);
    internal void LogBuildFinished(bool success);
    internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry);
    internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration);
    internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfiguration configuration, BuildResult result);
}
internal class Microsoft.Build.BackEnd.Logging.NullCentralLogger : object {
    private string _parameters;
    private LoggerVerbosity _verbosity;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public void AnyEventRaisedHandler(object sender, BuildEventArgs e);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
internal class Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger : BaseConsoleLogger {
    private static ComparerContextNodeId`1<BuildEventContext> s_compareContextNodeId;
    private static ComparerContextNodeIdTargetId`1<BuildEventContext> s_compareContextNodeIdTargetId;
    private BuildEventContext _lastDisplayedBuildEventContext;
    private int _bufferWidth;
    private object _lockObject;
    private int _prefixWidth;
    private ProjectFullKey _lastProjectFullKey;
    private bool _alignMessages;
    private bool _forceNoAlign;
    private bool _showEventId;
    private static string consoleTab;
    private Dictionary`2<BuildEventContext, List`1<BuildMessageEventArgs>> _deferredMessages;
    private BuildEventManager _buildEventManager;
    private bool _hasBuildStarted;
    private Nullable`1<bool> _showCommandLine;
    private bool _showTimeStamp;
    public ParallelConsoleLogger(LoggerVerbosity verbosity);
    public ParallelConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    private static ParallelConsoleLogger();
    private void CheckIfOutputSupportsAlignment();
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    private void ShownBuildEventContext(BuildEventContext e);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ShowFlatErrorWarningSummary();
    private void ShowNestedErrorWarningSummary();
    private void ShowErrorWarningSummary(IEnumerable`1<BuildEventArgs> listToProcess);
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    internal void WriteProperties(BuildEventArgs e, IEnumerable properties);
    internal virtual void OutputProperties(List`1<DictionaryEntry> list);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal void WriteItems(BuildEventArgs e, IEnumerable items);
    internal virtual void OutputItems(string itemType, ArrayList itemTypeList);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
    private void DisplayDeferredStartedEvents(BuildEventContext e);
    private void PrintMessage(BuildMessageEventArgs e, bool lightenText);
    private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText);
    private bool WriteTargetMessagePrefix(BuildEventArgs e, BuildEventContext context, DateTime timeStamp);
    private void WriteMessageAligned(string message, bool prefixAlreadyWritten);
    private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int prefixAdjustment);
    private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten, int adjustedPrefixWidth);
    private void DisplayDeferredTargetStartedEvent(BuildEventContext e);
    private void DisplayDeferredProjectStartedEvent(BuildEventContext e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    private void WriteLinePrefix(BuildEventContext e, DateTime eventTimeStamp, bool isMessagePrefix);
    private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessagePrefix);
    private ProjectFullKey GetFullProjectKey(BuildEventContext e);
    internal static MPPerformanceCounter GetPerformanceCounter(string scopeName, Dictionary`2& table);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectFullKey : object {
    private int _projectKey;
    private int _entryPointKey;
    internal int ProjectKey { get; internal set; }
    internal int EntryPointKey { get; internal set; }
    internal ProjectFullKey(int projectKey, int entryPointKey);
    internal int get_ProjectKey();
    internal void set_ProjectKey(int value);
    internal int get_EntryPointKey();
    internal void set_EntryPointKey(int value);
    public string ToString(LoggerVerbosity verbosity);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.ProjectLoggingContext : BuildLoggingContext {
    private string _projectFullPath;
    private NodeLoggingContext _nodeLoggingContext;
    internal NodeLoggingContext NodeLoggingContext { get; }
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry, BuildEventContext parentBuildEventContext);
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, BuildEventContext parentBuildEventContext);
    private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List`1<string> targets, string toolsVersion, PropertyDictionary`1<ProjectPropertyInstance> projectProperties, ItemDictionary`1<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext);
    internal NodeLoggingContext get_NodeLoggingContext();
    internal void LogProjectFinished(bool success);
    internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectStartedEventMinimumFields : object {
    private DateTime _timeStamp;
    private string _targetNames;
    private string _projectFile;
    private bool _showProjectFinishedEvent;
    private bool _errorInProject;
    private int _projectId;
    private ProjectFullKey _projectFullKey;
    private BuildEventContext _buildEventContext;
    private ProjectStartedEventMinimumFields _parentProjectStartedEvent;
    internal DateTime TimeStamp { get; }
    internal int ProjectKey { get; }
    internal int EntryPointKey { get; }
    internal string FullProjectKey { get; }
    internal ProjectStartedEventMinimumFields ParentProjectStartedEvent { get; }
    internal string TargetNames { get; }
    internal int ProjectId { get; }
    internal string ProjectFile { get; }
    internal bool ShowProjectFinishedEvent { get; internal set; }
    internal bool ErrorInProject { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, ProjectStartedEventArgs startedEvent, ProjectStartedEventMinimumFields parentProjectStartedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal int get_ProjectKey();
    internal int get_EntryPointKey();
    internal string get_FullProjectKey();
    internal ProjectStartedEventMinimumFields get_ParentProjectStartedEvent();
    internal string get_TargetNames();
    internal int get_ProjectId();
    internal string get_ProjectFile();
    internal bool get_ShowProjectFinishedEvent();
    internal void set_ShowProjectFinishedEvent(bool value);
    internal bool get_ErrorInProject();
    internal void set_ErrorInProject(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
}
internal class Microsoft.Build.BackEnd.Logging.SendDataDelegate : MulticastDelegate {
    public SendDataDelegate(object object, IntPtr method);
    public virtual void Invoke(INodePacket packetToSend);
    public virtual IAsyncResult BeginInvoke(INodePacket packetToSend, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.SerialConsoleLogger : BaseConsoleLogger {
    internal FrameStack contextStack;
    public SerialConsoleLogger(LoggerVerbosity verbosity);
    public SerialConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ShowErrorWarningSummary();
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    public virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
    internal void WriteProjectStarted();
    private void WriteProjectStartedText(string current, string targetNames, string previous, int indentLevel);
    private void WriteTargetStarted();
    private string GetCurrentlyBuildingProjectFile();
    private void ShowDeferredMessages();
    private void SetErrorsOrWarningsOnCurrentFrame();
    private void VerifyStack(bool condition, string unformattedMessage, Object[] args);
}
internal class Microsoft.Build.BackEnd.Logging.TargetLoggingContext : BuildLoggingContext {
    private static bool s_enableTargetOutputLogging;
    private ProjectLoggingContext _projectLoggingContext;
    private ProjectTargetInstance _target;
    internal static bool EnableTargetOutputLogging { get; internal set; }
    internal ProjectLoggingContext ProjectLoggingContext { get; }
    internal ProjectTargetInstance Target { get; }
    internal TargetLoggingContext(ProjectLoggingContext projectLoggingContext, string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason);
    internal TargetLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    private static TargetLoggingContext();
    internal static bool get_EnableTargetOutputLogging();
    internal static void set_EnableTargetOutputLogging(bool value);
    internal ProjectLoggingContext get_ProjectLoggingContext();
    internal ProjectTargetInstance get_Target();
    internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable`1<TaskItem> targetOutputs);
    internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task);
}
internal class Microsoft.Build.BackEnd.Logging.TargetStartedEventMinimumFields : object {
    private DateTime _timeStamp;
    private string _targetName;
    private string _targetFile;
    private string _projectFile;
    private string _parentTarget;
    private bool _showTargetFinishedEvent;
    private bool _errorInTarget;
    private string _message;
    private BuildEventContext _buildEventContext;
    internal DateTime TimeStamp { get; }
    internal string TargetName { get; }
    internal string TargetFile { get; }
    internal string ProjectFile { get; }
    internal string Message { get; }
    internal bool ShowTargetFinishedEvent { get; internal set; }
    internal bool ErrorInTarget { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal string ParentTarget { get; }
    internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal string get_TargetName();
    internal string get_TargetFile();
    internal string get_ProjectFile();
    internal string get_Message();
    internal bool get_ShowTargetFinishedEvent();
    internal void set_ShowTargetFinishedEvent(bool value);
    internal bool get_ErrorInTarget();
    internal void set_ErrorInTarget(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
    internal string get_ParentTarget();
}
internal class Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver : object {
    private Func`3<AssemblyLoadContext, AssemblyName, Assembly> _eventHandler;
    private string _taskAssemblyFile;
    internal void Initialize(string taskAssemblyFileToResolve);
    internal void InstallHandler();
    internal void RemoveHandler();
    private Assembly ResolveAssembly(AssemblyLoadContext assemblyLoadContext, AssemblyName assemblyName);
}
internal class Microsoft.Build.BackEnd.Logging.TaskLoggingContext : BuildLoggingContext {
    private TargetLoggingContext _targetLoggingContext;
    private ProjectTargetInstanceChild _task;
    private string _taskName;
    internal TargetLoggingContext TargetLoggingContext { get; }
    internal ProjectTargetInstanceChild Task { get; }
    internal string TaskName { get; }
    internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task);
    internal TaskLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    internal TargetLoggingContext get_TargetLoggingContext();
    internal ProjectTargetInstanceChild get_Task();
    internal string get_TaskName();
    internal void LogTaskBatchFinished(string projectFullPath, bool success);
    internal void LogTaskWarningFromException(Exception exception, BuildEventFileInfo file, string taskName);
}
internal class Microsoft.Build.BackEnd.Logging.WriteLinePrettyFromResourceDelegate : MulticastDelegate {
    public WriteLinePrettyFromResourceDelegate(object object, IntPtr method);
    public virtual void Invoke(int indentLevel, string resourceString, Object[] args);
    public virtual IAsyncResult BeginInvoke(int indentLevel, string resourceString, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.LoggingNodeConfiguration : object {
    private bool _includeEvaluationMetaprojects;
    private bool _includeEvaluationProfiles;
    private bool _includeTaskInputs;
    public bool IncludeEvaluationMetaprojects { get; }
    public bool IncludeEvaluationProfiles { get; }
    public bool IncludeTaskInputs { get; }
    public LoggingNodeConfiguration(bool includeEvaluationMetaprojects, bool includeEvaluationProfiles, bool includeTaskInputs);
    public bool get_IncludeEvaluationMetaprojects();
    public bool get_IncludeEvaluationProfiles();
    public bool get_IncludeTaskInputs();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.LogMessagePacket : LogMessagePacketBase {
    internal LogMessagePacket(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent);
    private LogMessagePacket(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    private static void TranslateTargetFinishedEvent(INodePacketTranslator translator, TargetFinishedEventArgs finishedEvent);
}
internal class Microsoft.Build.BackEnd.Lookup : object {
    private LinkedList`1<Scope> _lookupScopes;
    private Dictionary`2<ProjectItemInstance, ProjectItemInstance> _cloneTable;
    private ItemDictionary`1<ProjectItemInstance> PrimaryTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> PrimaryAddTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> PrimaryRemoveTable { get; private set; }
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> PrimaryModifyTable { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> PrimaryPropertySets { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryAddTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryRemoveTable { get; private set; }
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> SecondaryModifyTable { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> SecondaryProperties { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> SecondaryPropertySets { get; private set; }
    internal Lookup(ItemDictionary`1<ProjectItemInstance> projectItems, PropertyDictionary`1<ProjectPropertyInstance> properties);
    private Lookup(Lookup that);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryTable();
    private void set_PrimaryTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryAddTable();
    private void set_PrimaryAddTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryRemoveTable();
    private void set_PrimaryRemoveTable(ItemDictionary`1<ProjectItemInstance> value);
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> get_PrimaryModifyTable();
    private void set_PrimaryModifyTable(Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_PrimaryPropertySets();
    private void set_PrimaryPropertySets(PropertyDictionary`1<ProjectPropertyInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryTable();
    private void set_SecondaryTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryAddTable();
    private void set_SecondaryAddTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryRemoveTable();
    private void set_SecondaryRemoveTable(ItemDictionary`1<ProjectItemInstance> value);
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> get_SecondaryModifyTable();
    private void set_SecondaryModifyTable(Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_SecondaryProperties();
    private void set_SecondaryProperties(PropertyDictionary`1<ProjectPropertyInstance> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_SecondaryPropertySets();
    private void set_SecondaryPropertySets(PropertyDictionary`1<ProjectPropertyInstance> value);
    internal List`1<string> GetPropertyOverrideMessages(Dictionary`2<string, string> lookupHash);
    internal Lookup Clone();
    internal Scope EnterScope(string description);
    private void LeaveScope(Scope scopeToLeave);
    private void MergeScopeIntoNotLastScope();
    private void MergeScopeIntoLastScope();
    public sealed virtual ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex);
    public sealed virtual ProjectPropertyInstance GetProperty(string name);
    public sealed virtual ICollection`1<ProjectItemInstance> GetItems(string itemType);
    internal void PopulateWithItems(string itemType, ICollection`1<ProjectItemInstance> group);
    internal void PopulateWithItem(ProjectItemInstance item);
    internal void SetProperty(ProjectPropertyInstance property);
    internal void AddNewItemsOfItemType(string itemType, ICollection`1<ProjectItemInstance> group, bool doNotAddDuplicates);
    internal void AddNewItem(ProjectItemInstance item);
    internal void RemoveItems(IEnumerable`1<ProjectItemInstance> items);
    internal void RemoveItem(ProjectItemInstance item);
    internal void ModifyItems(string itemType, ICollection`1<ProjectItemInstance> group, MetadataModifications metadataChanges);
    private void ApplyModifies(ItemDictionary`1<ProjectItemInstance> result, Dictionary`2<ProjectItemInstance, MetadataModifications> allModifies);
    private static void ApplyMetadataModificationsToItem(MetadataModifications modificationsToApply, ProjectItemInstance itemToModify);
    private ProjectItemInstance RetrieveOriginalFromCloneTable(ProjectItemInstance item);
    private void ApplyModificationsToTable(ItemDictionary`1<ProjectItemInstance> table, string itemType, Dictionary`2<ProjectItemInstance, MetadataModifications> modify);
    private void MergeModificationsIntoModificationTable(Dictionary`2<ProjectItemInstance, MetadataModifications> modifiesOfType, KeyValuePair`2<ProjectItemInstance, MetadataModifications> modify, ModifyMergeType mergeType);
    private void MustNotBeOuterScope();
}
internal class Microsoft.Build.BackEnd.MSBuild : object {
    private List`1<ITaskItem> _targetOutputs;
    private SkipNonexistentProjectsBehavior _skipNonexistentProjects;
    private TaskLoggingHelper _logHelper;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoveProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebaseOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildInParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnloadProjectsOnCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetAndPropertyListSeparators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipNonexistentTargets>k__BackingField;
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public TaskLoggingHelper Log { get; }
    public ITaskHost HostObject { get; public set; }
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    public bool SkipNonexistentTargets { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public TaskLoggingHelper get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public string get_RemoveProperties();
    [CompilerGeneratedAttribute]
public void set_RemoveProperties(string value);
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RebaseOutputs();
    [CompilerGeneratedAttribute]
public void set_RebaseOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFirstFailure();
    [CompilerGeneratedAttribute]
public void set_StopOnFirstFailure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_BuildInParallel();
    [CompilerGeneratedAttribute]
public void set_BuildInParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnloadProjectsOnCompletion();
    [CompilerGeneratedAttribute]
public void set_UnloadProjectsOnCompletion(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    [CompilerGeneratedAttribute]
public String[] get_TargetAndPropertyListSeparators();
    [CompilerGeneratedAttribute]
public void set_TargetAndPropertyListSeparators(String[] value);
    [CompilerGeneratedAttribute]
public bool get_SkipNonexistentTargets();
    [CompilerGeneratedAttribute]
public void set_SkipNonexistentTargets(bool value);
    public sealed virtual bool Execute();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteInternal>d__76")]
public Task`1<bool> ExecuteInternal();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<BuildProjectsInParallel>d__77")]
private Task`1<bool> BuildProjectsInParallel(Dictionary`2<string, string> propertiesTable, String[] undefinePropertiesArray, List`1<String[]> targetLists, bool success, Boolean[] skipProjects);
    private void ExpandAllTargetsAndProperties();
    internal static List`1<String[]> CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteTargets>d__80")]
internal static Task`1<bool> ExecuteTargets(ITaskItem[] projects, Dictionary`2<string, string> propertiesTable, String[] undefineProperties, List`1<String[]> targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, List`1<ITaskItem> targetOutputs, bool useResultsCache, bool unloadProjectsOnCompletion, string toolsVersion, bool skipNonexistentTargets);
}
internal static class Microsoft.Build.BackEnd.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidHandle;
    internal static UInt32 NORMALPRIORITYCLASS;
    internal static UInt32 CREATENOWINDOW;
    internal static int STARTFUSESTDHANDLES;
    internal static int CREATE_NEW_CONSOLE;
    private static NativeMethods();
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES& lpProcessAttributes, SECURITY_ATTRIBUTES& lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUP_INFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
}
internal class Microsoft.Build.BackEnd.NewBuildRequestsDelegate : MulticastDelegate {
    public NewBuildRequestsDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry sourceEntry, FullyQualifiedBuildRequest[] requests);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry sourceEntry, FullyQualifiedBuildRequest[] requests, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NewConfigurationRequestDelegate : MulticastDelegate {
    public NewConfigurationRequestDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestConfiguration config);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration config, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodeBuildComplete : object {
    private bool _prepareForReuse;
    public bool PrepareForReuse { get; }
    public NodePacketType Type { get; }
    public NodeBuildComplete(bool prepareForReuse);
    [DebuggerStepThroughAttribute]
public bool get_PrepareForReuse();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static NodeBuildComplete FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeConfiguration : object {
    private int _nodeId;
    private BuildParameters _buildParameters;
    private LoggerDescription[] _forwardingLoggers;
    private LoggingNodeConfiguration _loggingNodeConfiguration;
    public int NodeId { get; public set; }
    public BuildParameters BuildParameters { get; }
    public LoggerDescription[] LoggerDescriptions { get; }
    public LoggingNodeConfiguration LoggingNodeConfiguration { get; }
    public NodePacketType Type { get; }
    public NodeConfiguration(int nodeId, BuildParameters buildParameters, LoggerDescription[] forwardingLoggers, LoggingNodeConfiguration loggingNodeConfiguration);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public void set_NodeId(int value);
    [DebuggerStepThroughAttribute]
public BuildParameters get_BuildParameters();
    [DebuggerStepThroughAttribute]
public LoggerDescription[] get_LoggerDescriptions();
    [DebuggerStepThroughAttribute]
public LoggingNodeConfiguration get_LoggingNodeConfiguration();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    internal NodeConfiguration Clone();
}
internal class Microsoft.Build.BackEnd.NodeEndpointInProc : object {
    private static object s_locker;
    private LinkStatus _status;
    private EndpointMode _mode;
    private NodeEndpointInProc _peerEndpoint;
    private IBuildComponentHost _componentHost;
    private INodePacketFactory _packetFactory;
    private object _asyncDataMonitor;
    private AutoResetEvent _packetAvailable;
    private AutoResetEvent _terminatePacketPump;
    private Thread _packetPump;
    private bool _peerConnected;
    private ConcurrentQueue`1<INodePacket> _packetQueue;
    [CompilerGeneratedAttribute]
private LinkStatusChangedDelegate OnLinkStatusChanged;
    public LinkStatus LinkStatus { get; }
    private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host);
    private static NodeEndpointInProc();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComponentHost host);
    private void RaiseLinkStatusChanged(LinkStatus newStatus);
    private void SetPeerNodeConnected();
    private void SetPeerNodeDisconnected();
    private void InternalDisconnect();
    private void ChangeLinkStatus(LinkStatus newStatus);
    private void EnqueuePacket(INodePacket packet);
    private void InitializeAsyncPacketThread();
    private void TerminateAsyncPacketThread();
    private void PacketPumpProc();
}
internal class Microsoft.Build.BackEnd.NodeEndpointOutOfProc : NodeEndpointOutOfProcBase {
    private IBuildComponentHost _componentHost;
    private bool _enableReuse;
    internal NodeEndpointOutOfProc(string pipeName, IBuildComponentHost host, bool enableReuse);
    protected virtual long GetHostHandshake();
    protected virtual long GetClientHandshake();
}
internal abstract class Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase : object {
    private static int ClientConnectTimeout;
    private static int PipeBufferSize;
    private bool _debugCommunications;
    private LinkStatus _status;
    private NamedPipeServerStream _pipeServer;
    private object _asyncDataMonitor;
    private AutoResetEvent _packetAvailable;
    private AutoResetEvent _terminatePacketPump;
    private Thread _packetPump;
    private INodePacketFactory _packetFactory;
    private ConcurrentQueue`1<INodePacket> _packetQueue;
    private SharedReadBuffer _sharedReadBuffer;
    [CompilerGeneratedAttribute]
private LinkStatusChangedDelegate OnLinkStatusChanged;
    public LinkStatus LinkStatus { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    internal void InternalConstruct(string pipeName);
    protected abstract virtual long GetHostHandshake();
    protected abstract virtual long GetClientHandshake();
    protected void ChangeLinkStatus(LinkStatus newStatus);
    private void RaiseLinkStatusChanged(LinkStatus newStatus);
    private void InternalDisconnect();
    private void EnqueuePacket(INodePacket packet);
    private void InitializeAsyncPacketThread();
    private void PacketPumpProc();
    private void RunReadLoop(Stream localReadPipe, Stream localWritePipe, ConcurrentQueue`1<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump);
}
internal class Microsoft.Build.BackEnd.NodeFailedToLaunchException : Exception {
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    public string ErrorCode { get; private set; }
    public string ErrorDescription { get; private set; }
    internal NodeFailedToLaunchException(Exception innerException);
    internal NodeFailedToLaunchException(string errorCode, string message);
    protected NodeFailedToLaunchException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
private void set_ErrorDescription(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.BackEnd.NodeInfo : object {
    private int _nodeId;
    private NodeProviderType _providerType;
    private HashSet`1<int> _configurationIDs;
    public int NodeId { get; }
    public NodeProviderType ProviderType { get; }
    public NodeInfo(int nodeId, NodeProviderType providerType);
    public int get_NodeId();
    public NodeProviderType get_ProviderType();
    public bool AssignConfiguration(int configId);
    public bool HasConfiguration(int configId);
    internal bool CanServiceRequestWithAffinity(NodeAffinity nodeAffinity);
}
internal class Microsoft.Build.BackEnd.NodeManager : object {
    private static int InvalidNodeId;
    private INodeProvider _inProcNodeProvider;
    private INodeProvider _outOfProcNodeProvider;
    private IBuildComponentHost _componentHost;
    private Dictionary`2<int, INodeProvider> _nodeIdToProvider;
    private NodePacketFactory _packetFactory;
    private int _nextNodeId;
    private int _inprocNodeId;
    private bool _nodesShutdown;
    private bool _componentShutdown;
    public sealed virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void RemoveNodeFromMapping(int nodeId);
    private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration);
}
internal class Microsoft.Build.BackEnd.NodePacketCollectionCreator`1 : MulticastDelegate {
    public NodePacketCollectionCreator`1(object object, IntPtr method);
    public virtual T Invoke(int capacity);
    public virtual IAsyncResult BeginInvoke(int capacity, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodePacketFactory : object {
    private Dictionary`2<NodePacketType, PacketFactoryRecord> _packetFactories;
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal class Microsoft.Build.BackEnd.NodePacketFactoryMethod : MulticastDelegate {
    public NodePacketFactoryMethod(object object, IntPtr method);
    public virtual INodePacket Invoke(INodePacketTranslator translator);
    public virtual IAsyncResult BeginInvoke(INodePacketTranslator translator, AsyncCallback callback, object object);
    public virtual INodePacket EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.BackEnd.NodePacketTranslator : object {
    internal static INodePacketTranslator GetReadTranslator(Stream stream, SharedReadBuffer buffer);
    internal static INodePacketTranslator GetWriteTranslator(Stream stream);
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.NodePacketTranslatorExtensions : object {
    private static Lazy`1<ConcurrentDictionary`2<Type, ConstructorInfo>> parameterlessConstructorCache;
    private static NodePacketTranslatorExtensions();
    [ExtensionAttribute]
public static void TranslateProjectPropertyInstanceDictionary(INodePacketTranslator translator, PropertyDictionary`1& value);
    [ExtensionAttribute]
public static T FactoryForDeserializingTypeWithName(INodePacketTranslator translator);
}
internal enum Microsoft.Build.BackEnd.NodePacketType : Enum {
    public byte value__;
    public static NodePacketType NodeConfiguration;
    public static NodePacketType BuildRequestConfiguration;
    public static NodePacketType BuildRequestConfigurationResponse;
    public static NodePacketType ProjectLoadInfo;
    public static NodePacketType BuildRequestBlocker;
    public static NodePacketType BuildRequestUnblocker;
    public static NodePacketType BuildRequest;
    public static NodePacketType BuildResult;
    public static NodePacketType LogMessage;
    public static NodePacketType NodeBuildComplete;
    public static NodePacketType NodeShutdown;
    public static NodePacketType TaskHostConfiguration;
    public static NodePacketType TaskHostTaskComplete;
    public static NodePacketType TaskHostTaskCancelled;
    public static NodePacketType ResolveSdkRequest;
    public static NodePacketType ResolveSdkResponse;
}
internal class Microsoft.Build.BackEnd.NodePacketValueFactory`1 : MulticastDelegate {
    public NodePacketValueFactory`1(object object, IntPtr method);
    public virtual T Invoke(INodePacketTranslator translator);
    public virtual IAsyncResult BeginInvoke(INodePacketTranslator translator, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodeProviderInProc : object {
    private static int InvalidInProcNodeId;
    private bool _disposed;
    private static Semaphore InProcNodeOwningOperatingEnvironment;
    private IBuildComponentHost _componentHost;
    private INode _inProcNode;
    private INodeEndpoint _inProcNodeEndpoint;
    private INodePacketFactory _packetFactory;
    private Thread _inProcNodeThread;
    private AutoResetEvent _endpointConnectedEvent;
    private int _inProcNodeId;
    private bool _exclusiveOperatingEnvironment;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    protected virtual override void Finalize();
    public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private bool InstantiateNode(INodePacketFactory factory);
    private void InProcNodeThreadProc();
    private void InProcNodeEndpoint_OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void InProcNodeShutdown(NodeEngineShutdownReason reason, Exception e);
    private void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProc : NodeProviderOutOfProcBase {
    private Dictionary`2<int, NodeContext> _nodeContexts;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static long GetHostHandshake(bool enableNodeReuse);
    internal static long GetClientHandshake();
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private void NodeContextTerminated(int nodeId);
}
internal abstract class Microsoft.Build.BackEnd.NodeProviderOutOfProcBase : object {
    private static int MaxPacketWriteSize;
    private static int NodeCreationRetries;
    private static int TimeoutForNewNodeCreation;
    private IBuildComponentHost _componentHost;
    private HashSet`1<string> _processesToIgnore;
    private static string CurrentHost;
    protected IBuildComponentHost ComponentHost { get; protected set; }
    protected IBuildComponentHost get_ComponentHost();
    protected void set_ComponentHost(IBuildComponentHost value);
    protected void SendData(NodeContext context, INodePacket packet);
    protected void ShutdownConnectedNodes(List`1<NodeContext> contextsToShutDown, bool enableReuse);
    protected void ShutdownAllNodes(long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode);
    protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, long hostHandshake, long clientHandshake, NodeContextTerminateDelegate terminateNode);
    private List`1<Process> GetPossibleRunningNodes(string msbuildLocation);
    private string GetProcessesToIgnoreKey(long hostHandshake, long clientHandshake, int nodeProcessId);
    private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHandshake, long clientHandshake);
    private int LaunchNode(string msbuildLocation, string commandLineArgs);
    private static string GetCurrentHost();
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase {
    private static int MaxNodeCount;
    private static string s_baseTaskHostPath;
    private static string s_baseTaskHostPath64;
    private static string s_pathToX32Clr2;
    private static string s_pathToX64Clr2;
    private static string s_pathToX32Clr4;
    private static string s_pathToX64Clr4;
    private static string s_msbuildName;
    private static string s_msbuildTaskHostName;
    private ManualResetEvent _noNodesActiveEvent;
    private Dictionary`2<TaskHostContext, NodeContext> _nodeContexts;
    private IDictionary`2<int, INodePacketFactory> _nodeIdToPacketFactory;
    private IDictionary`2<int, INodePacketHandler> _nodeIdToPacketHandler;
    private HashSet`1<int> _activeNodes;
    private NodePacketFactory _localPacketFactory;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    internal static string TaskHostNameForClr2TaskHost { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static string get_TaskHostNameForClr2TaskHost();
    public sealed virtual bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public void SendData(TaskHostContext hostContext, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    internal static void ClearCachedTaskHostPaths();
    internal static string GetTaskHostNameFromHostContext(TaskHostContext hostContext);
    internal static string GetMSBuildLocationFromHostContext(TaskHostContext hostContext);
    internal bool AcquireAndSetUpHost(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
    internal void DisconnectFromHost(TaskHostContext hostContext);
    internal bool CreateNode(TaskHostContext hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
    private void NodeContextTerminated(int nodeId);
}
internal enum Microsoft.Build.BackEnd.NodeProviderType : Enum {
    public int value__;
    public static NodeProviderType InProc;
    public static NodeProviderType OutOfProc;
    public static NodeProviderType Remote;
}
internal class Microsoft.Build.BackEnd.NodeShutdown : object {
    private NodeShutdownReason _reason;
    private Exception _exception;
    public NodePacketType Type { get; }
    public NodeShutdownReason Reason { get; }
    public Exception Exception { get; }
    public NodeShutdown(NodeShutdownReason reason);
    public NodeShutdown(NodeShutdownReason reason, Exception e);
    public sealed virtual NodePacketType get_Type();
    public NodeShutdownReason get_Reason();
    public Exception get_Exception();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static NodeShutdown FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeShutdownDelegate : MulticastDelegate {
    public NodeShutdownDelegate(object object, IntPtr method);
    public virtual void Invoke(NodeEngineShutdownReason reason, Exception e);
    public virtual IAsyncResult BeginInvoke(NodeEngineShutdownReason reason, Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.NodeShutdownReason : Enum {
    public int value__;
    public static NodeShutdownReason Requested;
    public static NodeShutdownReason Error;
    public static NodeShutdownReason ConnectionFailed;
}
internal enum Microsoft.Build.BackEnd.OutofdateReason : Enum {
    public int value__;
    public static OutofdateReason MissingInput;
    public static OutofdateReason MissingOutput;
    public static OutofdateReason NewerInput;
}
internal class Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask : IntrinsicTask {
    private ProjectPropertyGroupTaskInstance _taskInstance;
    public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal virtual void ExecuteTask(Lookup lookup);
    private void GetBatchableValuesFromProperty(List`1<string> parameterValues, ProjectPropertyGroupTaskPropertyInstance property);
}
internal static class Microsoft.Build.BackEnd.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Dictionary`2& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Dictionary`2& finalPropertiesTable);
}
internal class Microsoft.Build.BackEnd.RequestBlockedDelegate : MulticastDelegate {
    public RequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestBlocker blocker);
    public virtual IAsyncResult BeginInvoke(BuildRequestBlocker blocker, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestBuilder : object {
    private static TaskScheduler s_dedicatedScheduler;
    private ManualResetEvent _terminateEvent;
    private AutoResetEvent _continueEvent;
    private IDictionary`2<int, BuildResult> _continueResults;
    private Task _requestTask;
    private CancellationTokenSource _cancellationTokenSource;
    private BuildRequestEntry _requestEntry;
    private IBuildComponentHost _componentHost;
    private NodeLoggingContext _nodeLoggingContext;
    private ProjectLoggingContext _projectLoggingContext;
    private ITargetBuilder _targetBuilder;
    private BlockType _blockType;
    private bool _inMSBuildCallback;
    private bool _isZombie;
    [CompilerGeneratedAttribute]
private NewBuildRequestsDelegate OnNewBuildRequests;
    [CompilerGeneratedAttribute]
private BuildRequestCompletedDelegate OnBuildRequestCompleted;
    [CompilerGeneratedAttribute]
private BuildRequestBlockedDelegate OnBuildRequestBlocked;
    internal BuildRequestEntry RequestEntry { get; }
    internal bool HasActiveBuildRequest { get; }
    private static RequestBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    internal BuildRequestEntry get_RequestEntry();
    internal bool get_HasActiveBuildRequest();
    public sealed virtual void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry);
    public sealed virtual void ContinueRequest();
    public sealed virtual void CancelRequest();
    public sealed virtual void BeginCancel();
    public sealed virtual void WaitForCancelCompletion();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildProjects>d__34")]
public sealed virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BlockOnTargetInProgress>d__35")]
public sealed virtual Task BlockOnTargetInProgress(int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void EnterMSBuildCallbackState();
    public sealed virtual void ExitMSBuildCallbackState();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static bool IsBuilderUsingLegacyThreadingSemantics(IBuildComponentHost host, BuildRequestEntry entry);
    internal static int WaitWithBuilderThreadStart(WaitHandle[] handles, bool recursive, LegacyThreadingData threadingData, int submissionId);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void StartBuilderThread();
    private void SetCommonWorkerThreadParameters();
    private void VerifyEntryInReadyState();
    private void VerifyEntryInActiveState();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<RequestThreadProc>d__49")]
private Task RequestThreadProc(bool setThreadParameters);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildAndReport>d__50")]
private Task BuildAndReport();
    private void ReportResultAndCleanUp(BuildResult result);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<StartNewBuildRequests>d__52")]
private Task`1<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildRequest[] requests);
    private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] requests, bool isContinue);
    private void RaiseOnNewBuildRequests(FullyQualifiedBuildRequest[] requests);
    private void RaiseBuildRequestCompleted(BuildRequestEntry entryToComplete);
    private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    private void SetProjectCurrentDirectory();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildProject>d__58")]
private Task`1<BuildResult> BuildProject();
    private void LoadProjectIntoConfiguration();
    private ProjectInstance LoadProjectFromFile();
    private void SaveOperatingEnvironment();
    private void InitializeOperatingEnvironment();
    private void RestoreOperatingEnvironment();
    private void SetEnvironmentVariableBlock(IDictionary`2<string, string> savedEnvironment);
    private void ClearVariablesNotInEnvironment(IDictionary`2<string, string> savedEnvironment, IDictionary`2<string, string> currentEnvironment);
    private void UpdateEnvironmentVariables(IDictionary`2<string, string> savedEnvironment, IDictionary`2<string, string> currentEnvironment);
    private void VerifyIsNotZombie();
    private void ConfigureWarningsAsErrorsAndMessages();
    private ISet`1<string> ParseWarningCodes(string warnings);
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__45_0();
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__45_1();
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__45_2();
}
internal class Microsoft.Build.BackEnd.RequestCompleteDelegate : MulticastDelegate {
    public RequestCompleteDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request, BuildResult result);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, BuildResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestResumedDelegate : MulticastDelegate {
    public RequestResumedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ResultsCache : object {
    private ConcurrentDictionary`2<int, BuildResult> _resultsByConfiguration;
    private IBuildComponentHost _componentHost;
    internal IDictionary`2<int, BuildResult> ResultsDictionary { get; }
    internal IDictionary`2<int, BuildResult> get_ResultsDictionary();
    public sealed virtual void AddResult(BuildResult result);
    public sealed virtual void ClearResults();
    public sealed virtual BuildResult GetResultForRequest(BuildRequest request);
    public sealed virtual BuildResult GetResultsForConfiguration(int configurationId);
    public sealed virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets, List`1<string> additionalTargetsToCheckForOverallResult, bool skippedResultsAreOK);
    public sealed virtual void ClearResultsForConfiguration(int configurationId);
    public sealed virtual void WriteResultsToDisk();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private bool CheckResults(BuildResult result, List`1<string> targets, TargetClass targetClass, HashSet`1<string> targetsMissingResults, bool skippedResultsAreOK);
}
internal class Microsoft.Build.BackEnd.ResultsCacheResponse : ValueType {
    public ResultsCacheResponseType Type;
    public BuildResult Results;
    public HashSet`1<string> ExplicitTargetsToBuild;
    public ResultsCacheResponse(ResultsCacheResponseType type);
}
internal enum Microsoft.Build.BackEnd.ResultsCacheResponseType : Enum {
    public int value__;
    public static ResultsCacheResponseType NotSatisfied;
    public static ResultsCacheResponseType Satisfied;
}
internal class Microsoft.Build.BackEnd.SchedulableRequest : object {
    private SchedulingData _schedulingData;
    private SchedulableRequestState _state;
    private int _assignedNodeId;
    private BuildRequest _request;
    private SchedulableRequest _parent;
    private String[] _activeTargetsWhenBlocked;
    private Dictionary`2<BlockingRequestKey, SchedulableRequest> _requestsWeAreBlockedBy;
    private HashSet`1<SchedulableRequest> _requestsWeAreBlocking;
    private DateTime _creationTime;
    private DateTime _startTime;
    private DateTime _endTime;
    private Dictionary`2<SchedulableRequestState, ScheduleTimeRecord> _timeRecords;
    [CompilerGeneratedAttribute]
private string <BlockingTarget>k__BackingField;
    public SchedulableRequestState State { get; }
    public BuildRequest BuildRequest { get; }
    public SchedulableRequest Parent { get; }
    public int AssignedNode { get; }
    public IEnumerable`1<string> ActiveTargets { get; }
    public string BlockingTarget { get; private set; }
    public int RequestsWeAreBlockedByCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlockedBy { get; }
    public int RequestsWeAreBlockingCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlocking { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent);
    public SchedulableRequestState get_State();
    public BuildRequest get_BuildRequest();
    public SchedulableRequest get_Parent();
    public int get_AssignedNode();
    public IEnumerable`1<string> get_ActiveTargets();
    [CompilerGeneratedAttribute]
public string get_BlockingTarget();
    [CompilerGeneratedAttribute]
private void set_BlockingTarget(string value);
    public int get_RequestsWeAreBlockedByCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlockedBy();
    public int get_RequestsWeAreBlockingCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlocking();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_StartTime();
    public void set_StartTime(DateTime value);
    public DateTime get_EndTime();
    public void set_EndTime(DateTime value);
    public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState);
    public void Yield(String[] activeTargets);
    public void Reacquire();
    public void BlockByRequest(SchedulableRequest blockingRequest, String[] activeTargets, string blockingTarget);
    public void UnblockWithPartialResultForBlockingTarget(BuildResult result);
    public void UnblockWithResult(BuildResult result);
    public void ResumeExecution(int nodeId);
    public void Complete(BuildResult result);
    public void Delete();
    public void VerifyState(SchedulableRequestState requiredState);
    public void VerifyOneOfStates(SchedulableRequestState[] requiredStates);
    private void ChangeToState(SchedulableRequestState newState);
    private void DetectCircularDependency(SchedulableRequest blockingRequest);
    private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest);
    private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest, SchedulableRequest requestToEvaluate);
    private void DetectDirectCircularDependency(SchedulableRequest blockingRequest);
    private void CleanupForCircularDependencyAndThrow(SchedulableRequest requestCausingFailure, List`1<SchedulableRequest> ancestors);
    internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequestKey);
}
internal enum Microsoft.Build.BackEnd.SchedulableRequestState : Enum {
    public int value__;
    public static SchedulableRequestState Unscheduled;
    public static SchedulableRequestState Ready;
    public static SchedulableRequestState Executing;
    public static SchedulableRequestState Blocked;
    public static SchedulableRequestState Yielding;
    public static SchedulableRequestState Completed;
}
internal enum Microsoft.Build.BackEnd.ScheduleActionType : Enum {
    public int value__;
    public static ScheduleActionType NoAction;
    public static ScheduleActionType Schedule;
    public static ScheduleActionType ScheduleWithConfiguration;
    public static ScheduleActionType ReportResults;
    public static ScheduleActionType ResumeExecution;
    public static ScheduleActionType CreateNode;
    public static ScheduleActionType SubmissionComplete;
    public static ScheduleActionType CircularDependency;
}
internal class Microsoft.Build.BackEnd.Scheduler : object {
    internal static int InvalidNodeId;
    internal static int ResultsTransferredId;
    internal static int InProcNodeId;
    internal static int VirtualNode;
    private static double DefaultCustomSchedulerForSQLConfigurationLimitMultiplier;
    private string _schedulingUnlimitedVariable;
    private bool _schedulingUnlimited;
    private int _nodeLimitOffset;
    private Dictionary`2<int, NodeInfo> _availableNodes;
    private int _currentInProcNodeCount;
    private int _currentOutOfProcNodeCount;
    private SchedulingData _schedulingData;
    private IBuildComponentHost _componentHost;
    private IConfigCache _configCache;
    private IResultsCache _resultsCache;
    private int _nextGlobalRequestId;
    private bool _debugDumpState;
    private bool _forceAffinityOutOfProc;
    private string _debugDumpPath;
    private double _customSchedulerForSQLConfigurationLimitMultiplier;
    private SchedulingPlan _schedulingPlan;
    private AssignUnscheduledRequestsDelegate _customRequestSchedulingAlgorithm;
    public int MinimumAssignableConfigurationId { get; }
    public sealed virtual int get_MinimumAssignableConfigurationId();
    public sealed virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public sealed virtual int GetConfigurationIdFromPlan(string configPath);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfos);
    public sealed virtual void ReportBuildAborted(int nodeId);
    public sealed virtual void Reset();
    public sealed virtual void WriteDetailedSummary(int submissionId);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private void HandleYieldAction(SchedulableRequest parentRequest, BuildRequestBlocker blocker);
    private void ScheduleUnassignedRequests(List`1<ScheduleResponse> responses);
    private void AssignUnscheduledRequestsToNodes(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private bool GetSchedulingPlanAndAlgorithm();
    private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsByTraversalsFirst(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private bool IsTraversalRequest(BuildRequest request);
    private void AssignUnscheduledRequestsWithConfigurationCountLevelling(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithSmallestFileSize(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithLargestFileSize(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithMaxWaitingRequests(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithMaxWaitingRequests2(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsFIFO(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestToNode(SchedulableRequest request, int nodeId, List`1<ScheduleResponse> responses);
    private bool AtSchedulingLimit();
    private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId);
    private bool CreateNewNodeIfPossible(List`1<ScheduleResponse> responses, IEnumerable`1<SchedulableRequest> requests);
    private void MarkRequestAborted(SchedulableRequest request);
    private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRequest, BuildRequestBlocker blocker);
    private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequest, List`1<ScheduleResponse> responses);
    private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest, BuildRequestBlocker blocker, List`1<ScheduleResponse> responses);
    private void ResumeReadyRequestIfAny(int nodeId, List`1<ScheduleResponse> responses);
    private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest request, List`1<ScheduleResponse> responses);
    private void ResumeRequiredWork(List`1<ScheduleResponse> responses);
    private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildRequest request, bool skippedResultsAreOK);
    private ScheduleResponse GetResponseForResult(int parentRequestNode, BuildRequest requestWhichGeneratedResult, BuildResult result);
    private void LogRequestHandledFromCache(BuildRequest request, BuildResult result);
    private int ComputeClosureOfWaitingRequests(SchedulableRequest request);
    private NodeAffinity GetNodeAffinityForRequest(BuildRequest request);
    private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request);
    private void AssignGlobalRequestId(BuildRequest request);
    private void WriteNodeUtilizationGraph(ILoggingService loggingService, BuildEventContext context, bool useConfigurations);
    private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, BuildEventContext context, Int32[] currentWork, Int32[] previousWork, DateTime currentEventTime, DateTime previousEventTime, int invalidWorkId, Double& accumulatedDuration);
    private void WriteRecursiveSummary(ILoggingService loggingService, BuildEventContext context, int submissionId, SchedulableRequest request, int level, bool useConfigurations, bool isLastChild);
    private void TraceScheduler(string format, Object[] stuff);
    private void DumpSchedulerState();
    private void DumpConfigurations();
    private void DumpRequests();
    private void DumpRequestHierarchy(StreamWriter file, SchedulableRequest root, int indent);
    private void DumpRequestState(StreamWriter file, SchedulableRequest request, int indent);
    private void DumpRequestSpec(StreamWriter file, SchedulableRequest request, int indent, string prefix);
    private void WriteSchedulingPlan(int submissionId);
    private void ReadSchedulingPlan(int submissionId);
    [CompilerGeneratedAttribute]
private int <AssignUnscheduledRequestsWithConfigurationCountLevelling>b__45_0(int left, int right);
}
internal class Microsoft.Build.BackEnd.SchedulerCircularDependencyException : Exception {
    private IList`1<SchedulableRequest> _ancestors;
    private BuildRequest _request;
    public IEnumerable`1<SchedulableRequest> Ancestors { get; }
    public BuildRequest Request { get; }
    public SchedulerCircularDependencyException(BuildRequest request, IList`1<SchedulableRequest> ancestors);
    public IEnumerable`1<SchedulableRequest> get_Ancestors();
    public BuildRequest get_Request();
}
internal class Microsoft.Build.BackEnd.ScheduleResponse : object {
    internal ScheduleActionType Action;
    internal int NodeId;
    internal BuildResult BuildResult;
    internal BuildRequest BuildRequest;
    internal BuildRequestUnblocker Unblocker;
    internal NodeAffinity RequiredNodeType;
    internal int NumberOfNodesToCreate;
    internal ScheduleResponse(ScheduleActionType type);
    private ScheduleResponse(NodeAffinity affinity, int count);
    private ScheduleResponse(BuildResult result);
    private ScheduleResponse(int nodeId, BuildRequest parentRequest, BuildRequest requestCausingCircularDependency);
    private ScheduleResponse(int node, BuildRequest request, bool sendConfiguration);
    private ScheduleResponse(int node, BuildRequestUnblocker unblocker);
    public static ScheduleResponse CreateScheduleResponse(int node, BuildRequest requestToSchedule, bool sendConfiguration);
    public static ScheduleResponse CreateReportResultResponse(int node, BuildResult resultToReport);
    public static ScheduleResponse CreateResumeExecutionResponse(int node, int globalRequestIdToResume);
    public static ScheduleResponse CreateCircularDependencyResponse(int node, BuildRequest parentRequest, BuildRequest requestCausingCircularDependency);
    public static ScheduleResponse CreateSubmissionCompleteResponse(BuildResult rootRequestResult);
    public static ScheduleResponse CreateNewNodeResponse(NodeAffinity typeOfNodeToCreate, int count);
    public virtual string ToString();
}
internal class Microsoft.Build.BackEnd.ScheduleTimeRecord : object {
    private DateTime _startTimeForCurrentState;
    private TimeSpan _accumulatedTime;
    public TimeSpan AccumulatedTime { get; }
    public TimeSpan get_AccumulatedTime();
    public void StartState(DateTime currentTime);
    public void EndState(DateTime currentTime);
}
internal class Microsoft.Build.BackEnd.SchedulingData : object {
    private Dictionary`2<int, SchedulableRequest> _executingRequests;
    private Dictionary`2<int, SchedulableRequest> _blockedRequests;
    private Dictionary`2<int, SchedulableRequest> _yieldingRequests;
    private Dictionary`2<int, SchedulableRequest> _readyRequests;
    private LinkedList`1<SchedulableRequest> _unscheduledRequests;
    private Dictionary`2<SchedulableRequest, LinkedListNode`1<SchedulableRequest>> _unscheduledRequestNodesByRequest;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _scheduledRequestsByNode;
    private Dictionary`2<int, SchedulableRequest> _executingRequestByNode;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _readyRequestsByNode;
    private Dictionary`2<int, HashSet`1<int>> _configurationsByNode;
    private Dictionary`2<int, int> _configurationCounts;
    private Dictionary`2<int, int> _configurationToNode;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _configurationToRequests;
    private Dictionary`2<SchedulableRequest, List`1<SchedulableRequest>> _buildHierarchy;
    private List`1<SchedulingEvent> _buildEvents;
    private DateTime _currentEventTime;
    public IEnumerable`1<SchedulingEvent> BuildEvents { get; }
    public IEnumerable`1<SchedulableRequest> ExecutingRequests { get; }
    public int ExecutingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> ReadyRequests { get; }
    public int ReadyRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> BlockedRequests { get; }
    public int BlockedRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> YieldingRequests { get; }
    public int YieldingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequests { get; }
    public int UnscheduledRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequestsWhichCanBeScheduled { get; }
    public IEnumerable`1<int> Configurations { get; }
    public DateTime EventTime { get; public set; }
    public IEnumerable`1<SchedulingEvent> get_BuildEvents();
    public IEnumerable`1<SchedulableRequest> get_ExecutingRequests();
    public int get_ExecutingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_ReadyRequests();
    public int get_ReadyRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_BlockedRequests();
    public int get_BlockedRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_YieldingRequests();
    public int get_YieldingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_UnscheduledRequests();
    public int get_UnscheduledRequestsCount();
    [IteratorStateMachineAttribute("Microsoft.Build.BackEnd.SchedulingData/<get_UnscheduledRequestsWhichCanBeScheduled>d__40")]
public IEnumerable`1<SchedulableRequest> get_UnscheduledRequestsWhichCanBeScheduled();
    public IEnumerable`1<int> get_Configurations();
    public DateTime get_EventTime();
    public void set_EventTime(DateTime value);
    public SchedulableRequest CreateRequest(BuildRequest buildRequest, SchedulableRequest parent);
    public void UpdateFromState(SchedulableRequest request, SchedulableRequestState previousState);
    public IEnumerable`1<SchedulableRequest> GetRequestsAssignedToConfiguration(int configurationId);
    public int GetRequestsAssignedToConfigurationCount(int configurationId);
    public SchedulableRequest GetExecutingRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequestIfAny(int globalRequestId);
    public SchedulableRequest GetYieldingRequest(int globalRequestId);
    public SchedulableRequest GetReadyRequest(int globalRequestId);
    public SchedulableRequest GetScheduledRequest(int globalRequestId);
    public bool IsNodeWorking(int nodeId);
    public int GetConfigurationsCountByNode(int nodeId, bool excludeTraversals, IConfigCache configCache);
    public SchedulableRequest GetExecutingRequestByNode(int nodeId);
    public bool IsRequestScheduled(SchedulableRequest request);
    public int GetScheduledRequestsCountByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetScheduledRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetReadyRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetRequestsByHierarchy(SchedulableRequest root);
    public int GetAssignedNodeForRequestConfiguration(int configurationId);
    public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId);
    internal void UnassignNodeForRequestConfiguration(int configurationId);
    private SchedulableRequest InternalGetScheduledRequestByGlobalRequestId(int globalRequestId);
    private void ExpectScheduledRequestState(int globalRequestId, SchedulableRequestState state);
}
internal class Microsoft.Build.BackEnd.SchedulingPlan : object {
    private IConfigCache _configCache;
    private SchedulingData _schedulingData;
    private Dictionary`2<string, PlanConfigData> _configPathToData;
    private Dictionary`2<int, PlanConfigData> _configIdToData;
    private Dictionary`2<int, List`1<Stack`1<PlanConfigData>>> _configIdToPaths;
    [CompilerGeneratedAttribute]
private bool <IsPlanValid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumConfigurationId>k__BackingField;
    public bool IsPlanValid { get; private set; }
    public int MaximumConfigurationId { get; private set; }
    public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData);
    [CompilerGeneratedAttribute]
public bool get_IsPlanValid();
    [CompilerGeneratedAttribute]
private void set_IsPlanValid(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumConfigurationId();
    [CompilerGeneratedAttribute]
private void set_MaximumConfigurationId(int value);
    public void WritePlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public void ReadPlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public int GetConfigIdForPath(string configPath);
    public int GetConfigWithGreatestNumberOfReferences(IEnumerable`1<int> configsToSchedule);
    public int GetConfigWithGreatestPlanTime(IEnumerable`1<int> realConfigsToSchedule);
    public int GetReferencesCountForConfigByPath(string configFullPath);
    public void VisitConfig(string configName);
    public void CompleteConfig(string configName);
    private string GetPlanName(SchedulableRequest rootRequest);
    private int GetConfigWithComparison(IEnumerable`1<int> realConfigsToSchedule, Comparison`1<PlanConfigData> comparer);
    private void AnalyzeData();
    private void DetermineConfigsWithGreatestPlanTime();
    private void DetermineConfigsWithTheMostImmediateReferences();
    private void DetermineConfigsByNumberOfOccurrences();
    private void DoRecursiveAnalysis();
    private void RecursiveVisitNodes(PlanConfigData root, Stack`1<PlanConfigData> currentPath);
    private void DetermineExpensiveConfigs();
    private void ReadHierarchy(StreamReader file);
    private void ReadTimes(StreamReader file);
    private SchedulableRequest GetRootRequest(int submissionId);
    private void RecursiveWriteDependencies(StreamWriter file, SchedulableRequest request);
    private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, Dictionary`2<int, double> accumulatedTimeByConfiguration);
    [CompilerGeneratedAttribute]
private int <DetermineConfigsWithGreatestPlanTime>b__25_0(int left, int right);
    [CompilerGeneratedAttribute]
private int <DetermineConfigsWithTheMostImmediateReferences>b__26_0(int left, int right);
    [CompilerGeneratedAttribute]
private int <DetermineConfigsByNumberOfOccurrences>b__27_0(int left, int right);
}
internal class Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService : SdkResolverService {
    private ConcurrentDictionary`2<int, ConcurrentDictionary`2<string, SdkResult>> _cache;
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private SdkResult <>n__0(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
}
internal class Microsoft.Build.BackEnd.SdkResolution.DefaultSdkResolver : SdkResolver {
    public string Name { get; }
    public int Priority { get; }
    public virtual string get_Name();
    public virtual int get_Priority();
    public virtual SdkResult Resolve(SdkReference sdk, SdkResolverContext context, SdkResultFactory factory);
}
internal abstract class Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase : object {
    protected AutoResetEvent ShutdownEvent;
    protected IBuildComponentHost Host;
    [CompilerGeneratedAttribute]
private Action`1<INodePacket> <SendPacket>k__BackingField;
    public Action`1<INodePacket> SendPacket { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<INodePacket> get_SendPacket();
    [CompilerGeneratedAttribute]
public void set_SendPacket(Action`1<INodePacket> value);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual void InitializeComponent(IBuildComponentHost host);
    public abstract virtual void PacketReceived(int node, INodePacket packet);
    public abstract virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
    public virtual void ShutdownComponent();
}
internal interface Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService {
    public Action`1<INodePacket> SendPacket { get; }
    public abstract virtual Action`1<INodePacket> get_SendPacket();
    public abstract virtual void ClearCache(int submissionId);
    public abstract virtual void ClearCaches();
    public abstract virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
}
internal class Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService : HostedSdkResolverServiceBase {
    private object _lockObject;
    private Task _requestHandler;
    private ManualResetEvent _requestReceivedEvent;
    private ConcurrentQueue`1<SdkResolverRequest> _requests;
    private ISdkResolverService _cachedSdkResolver;
    public static IBuildComponent CreateComponent(BuildComponentType type);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual void PacketReceived(int node, INodePacket packet);
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
    private void HandleRequest(int node, SdkResolverRequest request);
    private void ProcessRequests();
    private void RequestHandlerPumpProc();
}
internal class Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService : HostedSdkResolverServiceBase {
    private ConcurrentDictionary`2<string, SdkResult> _responseCache;
    private AutoResetEvent _responseReceivedEvent;
    private SdkResult modreq(System.Runtime.CompilerServices.IsVolatile) _lastResponse;
    public OutOfProcNodeSdkResolverService(Action`1<INodePacket> sendPacket);
    public virtual void PacketReceived(int node, INodePacket packet);
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
    public virtual void ShutdownComponent();
    private void HandleResponse(SdkResult response);
    private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
}
internal class Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverServiceFactory : object {
    private Action`1<INodePacket> _sendPacket;
    public OutOfProcNodeSdkResolverServiceFactory(Action`1<INodePacket> sendPacket);
    public IBuildComponent CreateInstance(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkLogger : SdkLogger {
    private LoggingContext _loggingContext;
    public SdkLogger(LoggingContext loggingContext);
    public virtual void LogMessage(string message, MessageImportance messageImportance);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverContext : SdkResolverContext {
    public SdkResolverContext(SdkLogger logger, string projectFilePath, string solutionPath, Version msBuildVersion);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader : object {
    private CoreClrAssemblyLoader _loader;
    internal virtual IList`1<SdkResolver> LoadResolvers(LoggingContext loggingContext, ElementLocation location);
    internal virtual IList`1<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location);
    private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List`1<string> assembliesList, ElementLocation location);
    private bool TryAddAssembly(string assemblyPath, List`1<string> assembliesList);
    protected virtual IEnumerable`1<Type> GetResolverTypes(Assembly assembly);
    protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location);
    protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List`1<SdkResolver> resolvers);
}
[DataContractAttribute]
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverManifest : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [DataMemberAttribute]
internal string Path { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    internal static SdkResolverManifest Load(string filePath);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverRequest : object {
    private BuildEventContext _buildEventContext;
    private ElementLocation _elementLocation;
    private string _minimumVersion;
    private string _name;
    private string _projectPath;
    private string _solutionPath;
    private int _submissionId;
    private string _version;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    public BuildEventContext BuildEventContext { get; }
    public ElementLocation ElementLocation { get; }
    public string MinimumVersion { get; }
    public string Name { get; }
    public int NodeId { get; public set; }
    public string ProjectPath { get; }
    public string SolutionPath { get; }
    public int SubmissionId { get; }
    public NodePacketType Type { get; }
    public string Version { get; }
    public SdkResolverRequest(INodePacketTranslator translator);
    private SdkResolverRequest(int submissionId, string name, string version, string minimumVersion, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath);
    public BuildEventContext get_BuildEventContext();
    public ElementLocation get_ElementLocation();
    public string get_MinimumVersion();
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_NodeId();
    [CompilerGeneratedAttribute]
public void set_NodeId(int value);
    public string get_ProjectPath();
    public string get_SolutionPath();
    public int get_SubmissionId();
    public sealed virtual NodePacketType get_Type();
    public string get_Version();
    public static SdkResolverRequest Create(int submissionId, SdkReference sdkReference, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath);
    public static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
    public sealed virtual void Translate(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverService : object {
    private static Lazy`1<SdkResolverService> InstanceLazy;
    private object _lockObject;
    private ConcurrentDictionary`2<int, ConcurrentDictionary`2<SdkResolver, object>> _resolverStateBySubmission;
    private IList`1<SdkResolver> _resolvers;
    private SdkResolverLoader _sdkResolverLoader;
    [CompilerGeneratedAttribute]
private Action`1<INodePacket> <SendPacket>k__BackingField;
    public static SdkResolverService Instance { get; }
    public Action`1<INodePacket> SendPacket { get; }
    private static SdkResolverService();
    public static SdkResolverService get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<INodePacket> get_SendPacket();
    public static bool IsReferenceSameVersion(SdkReference sdk, string version);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath);
    internal void InitializeForTests(SdkResolverLoader resolverLoader, IList`1<SdkResolver> resolvers);
    private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result);
    private object GetResolverState(int submissionId, SdkResolver resolver);
    private void Initialize(LoggingContext loggingContext, ElementLocation location);
    private void SetResolverState(int submissionId, SdkResolver resolver, object state);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResult : SdkResult {
    private string _path;
    private string _version;
    [CompilerGeneratedAttribute]
private ElementLocation <ElementLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkReference <SdkReference>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Warnings>k__BackingField;
    public ElementLocation ElementLocation { get; public set; }
    public IEnumerable`1<string> Errors { get; }
    public string Path { get; }
    public SdkReference SdkReference { get; protected set; }
    public string Version { get; }
    public IEnumerable`1<string> Warnings { get; }
    public NodePacketType Type { get; }
    public SdkResult(INodePacketTranslator translator);
    public SdkResult(SdkReference sdkReference, IEnumerable`1<string> errors, IEnumerable`1<string> warnings);
    public SdkResult(SdkReference sdkReference, string path, string version, IEnumerable`1<string> warnings);
    [CompilerGeneratedAttribute]
public ElementLocation get_ElementLocation();
    [CompilerGeneratedAttribute]
public void set_ElementLocation(ElementLocation value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Errors();
    public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual SdkReference get_SdkReference();
    [CompilerGeneratedAttribute]
protected virtual void set_SdkReference(SdkReference value);
    public virtual string get_Version();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Warnings();
    public sealed virtual void Translate(INodePacketTranslator translator);
    public sealed virtual NodePacketType get_Type();
    public static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResultFactory : SdkResultFactory {
    private SdkReference _sdkReference;
    internal SdkResultFactory(SdkReference sdkReference);
    public virtual SdkResult IndicateFailure(IEnumerable`1<string> errors, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(string path, string version, IEnumerable`1<string> warnings);
}
internal class Microsoft.Build.BackEnd.TargetBuilder : object {
    private CancellationToken _cancellationToken;
    private ConcurrentStack`1<TargetEntry> _targetsToBuild;
    private IBuildComponentHost _componentHost;
    private BuildRequestEntry _requestEntry;
    private Lookup _baseLookup;
    private IRequestBuilderCallback _requestBuilderCallback;
    private ProjectLoggingContext _projectLoggingContext;
    private BuildResult _buildResult;
    private ProjectInstance _projectInstance;
    private bool _legacyCallTargetContinueOnError;
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<BuildTargets>d__10")]
public sealed virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targetNames, Lookup baseLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<Microsoft-Build-BackEnd-ITargetBuilderCallback-LegacyCallTarget>d__13")]
private sealed virtual override Task`1<ITargetResult[]> Microsoft.Build.BackEnd.ITargetBuilderCallback.LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation taskLocation);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<Microsoft-Build-BackEnd-IRequestBuilderCallback-BuildProjects>d__14")]
private sealed virtual override Task`1<BuildResult[]> Microsoft.Build.BackEnd.IRequestBuilderCallback.BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    private sealed virtual override Task Microsoft.Build.BackEnd.IRequestBuilderCallback.BlockOnTargetInProgress(int blockingGlobalBuildRequestId, string blockingTarget, BuildResult partialBuildResult);
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Yield();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Reacquire();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.EnterMSBuildCallbackState();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.ExitMSBuildCallbackState();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<ProcessTargetStack>d__21")]
private Task ProcessTargetStack(ITaskBuilder taskBuilder);
    private bool CheckSkipTarget(Boolean& stopProcessingStack, TargetEntry currentTargetEntry);
    private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetResult targetResult, Boolean& stopProcessingStack);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<PushTargets>d__24")]
private Task`1<bool> PushTargets(IList`1<TargetSpecification> targets, TargetEntry parentTargetEntry, Lookup baseLookup, bool addAsErrorTarget, bool stopProcessingOnCompletion, TargetBuiltReason buildReason);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<CompleteOutstandingActiveRequests>d__25")]
private Task`1<bool> CompleteOutstandingActiveRequests(string targetName);
}
[DebuggerDisplayAttribute("Name={_targetSpecification.TargetName} State={_state} Result={_targetResult.ResultCode}")]
internal class Microsoft.Build.BackEnd.TargetEntry : object {
    private BuildRequestEntry _requestEntry;
    private TargetSpecification _targetSpecification;
    private ProjectTargetInstance _target;
    private TargetEntryState _state;
    private TargetResult _targetResult;
    private TargetEntry _parentTarget;
    private TargetBuiltReason _buildReason;
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private Lookup _baseLookup;
    private IBuildComponentHost _host;
    private ITargetBuilderCallback _targetBuilderCallback;
    private Stack`1<Scope> _legacyCallTargetScopes;
    private object _cancelLock;
    private CancellationToken _cancellationToken;
    private bool _isExecuting;
    private ITaskBuilder _currentTaskBuilder;
    [CompilerGeneratedAttribute]
private bool <ErrorTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopProcessingOnCompletion>k__BackingField;
    internal bool ErrorTarget { get; internal set; }
    internal ElementLocation ReferenceLocation { get; }
    internal bool StopProcessingOnCompletion { get; internal set; }
    internal string Name { get; }
    internal TargetEntryState State { get; }
    internal TargetResult Result { get; }
    internal Lookup Lookup { get; }
    internal ProjectTargetInstance Target { get; }
    internal BuildRequestEntry RequestEntry { get; }
    internal TargetEntry ParentEntry { get; }
    internal TargetBuiltReason BuildReason { get; }
    internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion);
    [CompilerGeneratedAttribute]
internal bool get_ErrorTarget();
    [CompilerGeneratedAttribute]
internal void set_ErrorTarget(bool value);
    internal ElementLocation get_ReferenceLocation();
    [CompilerGeneratedAttribute]
internal bool get_StopProcessingOnCompletion();
    [CompilerGeneratedAttribute]
internal void set_StopProcessingOnCompletion(bool value);
    internal string get_Name();
    internal TargetEntryState get_State();
    internal TargetResult get_Result();
    internal Lookup get_Lookup();
    internal ProjectTargetInstance get_Target();
    internal BuildRequestEntry get_RequestEntry();
    internal TargetEntry get_ParentEntry();
    internal TargetBuiltReason get_BuildReason();
    public sealed virtual bool Equals(TargetEntry other);
    internal List`1<TargetSpecification> GetDependencies(ProjectLoggingContext projectLoggingContext);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetEntry/<ExecuteTarget>d__45")]
internal Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry requestEntry, ProjectLoggingContext projectLoggingContext, CancellationToken cancellationToken);
    internal List`1<TargetSpecification> GetErrorTargets(ProjectLoggingContext projectLoggingContext);
    internal TargetResult GatherResults();
    internal void EnterLegacyCallTargetScope(Lookup lookup);
    internal void MarkForError();
    internal void MarkForStop();
    internal void LeaveLegacyCallTargetScopes();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetEntry/<ProcessBucket>d__52")]
private Task`1<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution);
    private TaskExecutionMode GetTaskExecutionMode(DependencyAnalysisResult analysis);
    private void VerifyState(TargetEntryState actual, TargetEntryState expected);
    private List`1<string> GetBatchableParametersForTarget();
    private void GetTargetInstance();
}
internal enum Microsoft.Build.BackEnd.TargetEntryState : Enum {
    public int value__;
    public static TargetEntryState Dependencies;
    public static TargetEntryState Execution;
    public static TargetEntryState ErrorExecution;
    public static TargetEntryState Completed;
}
[DebuggerDisplayAttribute("Name={TargetName}")]
internal class Microsoft.Build.BackEnd.TargetSpecification : object {
    private string _targetName;
    private ElementLocation _referenceLocation;
    public string TargetName { get; }
    public ElementLocation ReferenceLocation { get; }
    internal TargetSpecification(string targetName, ElementLocation referenceLocation);
    public string get_TargetName();
    public ElementLocation get_ReferenceLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static TargetSpecification FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TargetUpToDateChecker : object {
    private ProjectInstance _project;
    private ProjectTargetInstance _targetToAnalyze;
    private string _targetInputSpecification;
    private string _targetOutputSpecification;
    private List`1<DependencyAnalysisLogDetail> _dependencyAnalysisDetail;
    private ILoggingService _loggingService;
    private BuildEventContext _buildEventContext;
    private static bool s_sortInputsOutputs;
    private IDictionary`2<string, object> _uniqueTargetInputs;
    private IDictionary`2<string, object> _uniqueTargetOutputs;
    internal ProjectTargetInstance TargetToAnalyze { get; }
    private string TargetInputSpecification { get; }
    private string TargetOutputSpecification { get; }
    internal TargetUpToDateChecker(ProjectInstance project, ProjectTargetInstance targetToAnalyze, ILoggingService loggingServices, BuildEventContext buildEventContext);
    private static TargetUpToDateChecker();
    internal ProjectTargetInstance get_TargetToAnalyze();
    private string get_TargetInputSpecification();
    private string get_TargetOutputSpecification();
    internal DependencyAnalysisResult PerformDependencyAnalysis(ItemBucket bucket, ItemDictionary`1& changedTargetInputs, ItemDictionary`1& upToDateTargetInputs);
    private void LogReasonForBuildingTarget(DependencyAnalysisResult result);
    internal static string GetFullBuildReason(DependencyAnalysisLogDetail logDetail);
    private static string GetIncrementalBuildReason(DependencyAnalysisLogDetail logDetail);
    private void LogUniqueInputsAndOutputs();
    private void ParseTargetInputOutputSpecifications(ItemBucket bucket, Dictionary`2& itemVectorsInTargetInputs, Dictionary`2& itemVectorTransformsInTargetInputs, Dictionary`2& discreteItemsInTargetInputs, Dictionary`2& itemVectorsInTargetOutputs, Dictionary`2& discreteItemsInTargetOutputs, List`1& targetOutputItemSpecs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfNoInputs();
    private DependencyAnalysisResult PerformDependencyAnalysisIfNoOutputs();
    private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransformsInTargetInputs, Dictionary`2<string, string> discreteItemsInTargetInputs, List`1<string> itemVectorsReferencedOnlyInTargetInputs, List`1<string> targetOutputItemSpecs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfCorrelatedInputsOutputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetOutputs, List`1<string> itemVectorsReferencedInBothTargetInputsAndOutputs, ItemDictionary`1& changedTargetInputs, ItemDictionary`1& upToDateTargetInputs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransformsInTargetInputs, Dictionary`2<string, string> discreteItemsInTargetInputs, List`1<string> targetOutputItemSpecs);
    private void SeparateItemVectorsFromDiscreteItems(SemiColonTokenizer items, ItemBucket bucket, Dictionary`2& itemVectors, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransforms, Dictionary`2& discreteItems, ElementLocation elementLocation);
    private static List`1<string> GetItemSpecsFromItemVectors(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectors);
    private static List`1<string> GetItemSpecsFromItemVectors(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectors, string itemType);
    private static void DiffHashtables(IDictionary`2<K, V> h1, IDictionary`2<K, V> h2, List`1& commonKeys, List`1& uniqueKeysInH1, List`1& uniqueKeysInH2);
    internal static bool IsAnyOutOfDate(DependencyAnalysisLogDetail& dependencyAnalysisDetailEntry, string projectDirectory, IList`1<T> inputs, IList`1<T> outputs);
    private void RecordUniqueInputsAndOutputs(IList`1<T> inputs, IList`1<T> outputs);
    private bool IsOutOfDate(string input, string output, string inputItemName, string outputItemName);
    private void RecordComparisonResults(string input, string output, string inputItemName, string outputItemName, bool inputDoesNotExist, bool outputDoesNotExist, bool outOfDate);
    private int CompareLastWriteTimes(string path1, string path2, Boolean& path1DoesNotExist, Boolean& path2DoesNotExist);
}
internal class Microsoft.Build.BackEnd.TaskBuilder : object {
    private BuildRequestEntry _buildRequestEntry;
    private CancellationToken _cancellationToken;
    private IBuildComponentHost _componentHost;
    private ProjectTargetInstanceChild _targetChildInstance;
    private ProjectTaskInstance _taskNode;
    private ITaskHost _taskHostObject;
    private ContinueOnError _continueOnError;
    private TargetLoggingContext _targetLoggingContext;
    private string _projectFullPath;
    private ITargetBuilderCallback _targetBuilderCallback;
    private ITaskExecutionHost _taskExecutionHost;
    private object _taskExecutionHostSync;
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteTask>d__13")]
public sealed virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext loggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild taskInstance, TaskExecutionMode mode, Lookup inferLookup, Lookup executeLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private List`1<string> CreateListOfParameterValues();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteTask>d__18")]
private Task`1<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteBucket>d__19")]
private Task`1<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary`2<string, string> lookupHash);
    private IDictionary`2<string, string> GatherTaskIdentityParameters(Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander);
    private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTask);
    private void ExecuteIntrinsicTask(ItemBucket bucket);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<InitializeAndExecuteTask>d__23")]
private Task`1<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext taskLoggingContext, ItemBucket bucket, IDictionary`2<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask);
    private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteInstantiatedTask>d__25")]
private Task`1<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask);
    private bool GatherTaskOutputs(ITaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket);
    private void InferTaskOutputs(Lookup lookup, ProjectTaskInstanceChild taskOutputSpecification, string taskParameterName, string itemName, string propertyName, ItemBucket bucket);
}
internal enum Microsoft.Build.BackEnd.TaskCompleteType : Enum {
    public int value__;
    public static TaskCompleteType Success;
    public static TaskCompleteType Failure;
    public static TaskCompleteType CrashedDuringInitialization;
    public static TaskCompleteType CrashedDuringExecution;
    public static TaskCompleteType CrashedAfterExecution;
}
internal class Microsoft.Build.BackEnd.TaskExecutionHost : object {
    private static int CancelFirstWarningWaitInterval;
    private static int CancelWarningWaitInterval;
    private IBuildEngine2 _buildEngine;
    private ProjectInstance _projectInstance;
    private TargetLoggingContext _targetLoggingContext;
    private TaskLoggingContext _taskLoggingContext;
    private CancellationTokenRegistration _cancellationTokenRegistration;
    private string _taskName;
    private ElementLocation _taskLocation;
    private ITaskHost _taskHost;
    private ItemBucket _batchBucket;
    private TaskFactoryWrapper _taskFactoryWrapper;
    private bool _cancelled;
    private ManualResetEvent _taskExecutionIdle;
    private List`1<TaskItem> _remotedTaskItems;
    private IBuildComponentHost _buildComponentHost;
    private Dictionary`2<string, TaskFactoryWrapper> _intrinsicTasks;
    [CompilerGeneratedAttribute]
private bool <LogTaskInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ITask <TaskInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutOfProc>k__BackingField;
    public bool LogTaskInputs { get; }
    private ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.ProjectInstance { get; }
    internal ITask TaskInstance { get; private set; }
    internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    internal TaskExecutionHost(IBuildComponentHost host);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LogTaskInputs();
    private sealed virtual override ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.get_ProjectInstance();
    [CompilerGeneratedAttribute]
internal ITask get_TaskInstance();
    [CompilerGeneratedAttribute]
private void set_TaskInstance(ITask value);
    internal TaskFactoryWrapper get__UNITTESTONLY_TaskFactoryWrapper();
    internal void set__UNITTESTONLY_TaskFactoryWrapper(TaskFactoryWrapper value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, bool isOutOfProc, CancellationToken cancellationToken);
    private sealed virtual override Nullable`1<TaskRequirements> Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.SetTaskParameters(IDictionary`2<string, Tuple`2<string, ElementLocation>> parameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForBatch();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForTask();
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.Execute();
    protected virtual void Dispose(bool disposing);
    private void CleanupCancellationToken();
    private void Cancel();
    private bool SetTaskItemParameter(TaskPropertyInfo parameter, ITaskItem item);
    private bool SetValueParameter(TaskPropertyInfo parameter, Type parameterType, string expandedParameterValue);
    private bool SetParameterArray(TaskPropertyInfo parameter, Type parameterType, IList`1<TaskItem> taskItems, ElementLocation parameterLocation);
    private void RecordItemForDisconnectIfNecessary(TaskItem item);
    private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter);
    private String[] GetValueOutputs(TaskPropertyInfo parameter);
    private TaskFactoryWrapper FindTaskInRegistry(IDictionary`2<string, string> taskIdentityParameters);
    private ITask InstantiateTask(IDictionary`2<string, string> taskIdentityParameters);
    private bool SetTaskParameter(string parameterName, string parameterValue, ElementLocation parameterLocation, bool isRequired, Boolean& parameterSet);
    private bool InitializeTaskScalarParameter(TaskPropertyInfo parameter, Type parameterType, string parameterValue, ElementLocation parameterLocation, Boolean& taskParameterSet);
    private bool InitializeTaskVectorParameter(TaskPropertyInfo parameter, Type parameterType, string parameterValue, ElementLocation parameterLocation, bool isRequired, Boolean& taskParameterSet);
    private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList parameterValue);
    private bool InternalSetTaskParameter(TaskPropertyInfo parameter, object parameterValue);
    private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation);
    private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, String[] outputs, ElementLocation parameterLocation);
    private IDictionary`2<string, string> GetNamesOfPropertiesWithRequiredAttribute();
    private void DisplayCancelWaitMessage();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskExecutionHost/<<Cancel>b__47_0>d")]
[CompilerGeneratedAttribute]
private Task <Cancel>b__47_0();
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskExecutionMode : Enum {
    public int value__;
    public static TaskExecutionMode Invalid;
    public static TaskExecutionMode ExecuteTaskAndGatherOutputs;
    public static TaskExecutionMode InferOutputsOnly;
}
internal class Microsoft.Build.BackEnd.TaskFactoryLoggingHost : object {
    private ElementLocation _elementLocation;
    private BuildLoggingContext _loggingContext;
    private bool _isRunningWithMultipleNodes;
    private bool _activeProxy;
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal BuildLoggingContext LoggingContext { get; }
    public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BuildLoggingContext loggingContext);
    public bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    [DebuggerStepThroughAttribute]
internal BuildLoggingContext get_LoggingContext();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    internal bool IsEventSerializable(BuildEventArgs e);
    private void VerifyActiveProxy();
}
internal class Microsoft.Build.BackEnd.TaskHost : object {
    private static bool s_onlyUseOutOfProcNodes;
    private static bool s_breakOnLogAfterTaskReturns;
    private IBuildComponentHost _host;
    private BuildRequestEntry _requestEntry;
    private ElementLocation _taskLocation;
    private TaskLoggingContext _taskLoggingContext;
    private bool _activeProxy;
    private ITargetBuilderCallback _targetBuilderCallback;
    private object _callbackMonitor;
    private bool _continueOnError;
    private bool _convertErrorsToWarnings;
    private int _yieldThreadId;
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; internal set; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal bool ConvertErrorsToWarnings { get; internal set; }
    internal TaskLoggingContext LoggingContext { get; internal set; }
    internal bool IsOutOfProc { get; }
    public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback);
    private static TaskHost();
    public sealed virtual bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    internal void set_ContinueOnError(bool value);
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    internal bool get_ConvertErrorsToWarnings();
    internal void set_ConvertErrorsToWarnings(bool value);
    [DebuggerStepThroughAttribute]
internal TaskLoggingContext get_LoggingContext();
    [DebuggerStepThroughAttribute]
internal void set_LoggingContext(TaskLoggingContext value);
    internal bool get_IsOutOfProc();
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion);
    public sealed virtual bool BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, String[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
    public sealed virtual BuildEngineResult BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskHost/<InternalBuildProjects>d__46")]
public Task`1<BuildEngineResult> InternalBuildProjects(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets);
    internal bool IsEventSerializable(BuildEventArgs e);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskHost/<BuildProjectFilesInParallelAsync>d__48")]
private Task`1<BuildEngineResult> BuildProjectFilesInParallelAsync(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets);
    private void VerifyActiveProxy();
}
internal class Microsoft.Build.BackEnd.TaskHostConfiguration : object {
    private int _nodeId;
    private string _startupDirectory;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    private CultureInfo _culture;
    private CultureInfo _uiCulture;
    private int _lineNumberOfTask;
    private int _columnNumberOfTask;
    private string _projectFileOfTask;
    private bool _continueOnError;
    private string _taskName;
    private string _taskLocation;
    private Dictionary`2<string, TaskParameter> _taskParameters;
    public int NodeId { get; }
    public string StartupDirectory { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; }
    public CultureInfo UICulture { get; }
    public int LineNumberOfTask { get; }
    public int ColumnNumberOfTask { get; }
    public bool ContinueOnError { get; }
    public string ProjectFileOfTask { get; }
    public string TaskName { get; }
    public string TaskLocation { get; }
    public Dictionary`2<string, TaskParameter> TaskParameters { get; }
    public NodePacketType Type { get; }
    public TaskHostConfiguration(int nodeId, string startupDirectory, IDictionary`2<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture, int lineNumberOfTask, int columnNumberOfTask, string projectFileOfTask, bool continueOnError, string taskName, string taskLocation, IDictionary`2<string, object> taskParameters);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public string get_StartupDirectory();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    [DebuggerStepThroughAttribute]
public CultureInfo get_Culture();
    [DebuggerStepThroughAttribute]
public CultureInfo get_UICulture();
    [DebuggerStepThroughAttribute]
public int get_LineNumberOfTask();
    [DebuggerStepThroughAttribute]
public int get_ColumnNumberOfTask();
    [DebuggerStepThroughAttribute]
public bool get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public string get_ProjectFileOfTask();
    [DebuggerStepThroughAttribute]
public string get_TaskName();
    [DebuggerStepThroughAttribute]
public string get_TaskLocation();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskParameters();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostNodeManager : object {
    private INodeProvider _outOfProcTaskHostNodeProvider;
    private IBuildComponentHost _componentHost;
    private bool _componentShutdown;
    public sealed virtual NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAffinity);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.TaskHostTask : object {
    private IBuildEngine _buildEngine;
    private ITaskHost _hostObject;
    private TaskLoggingContext _taskLoggingContext;
    private IElementLocation _taskLocation;
    private IBuildComponentHost _buildComponentHost;
    private NodePacketFactory _packetFactory;
    private AutoResetEvent _packetReceivedEvent;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private IDictionary`2<string, string> _taskHostParameters;
    private LoadedType _taskType;
    private TaskHostContext _requiredContext;
    private bool _connectedToTaskHost;
    private NodeProviderOutOfProcTaskHost _taskHostProvider;
    private object _taskHostLock;
    private bool _taskCancelled;
    private IDictionary`2<string, object> _setParameters;
    private bool _taskExecutionSucceeded;
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskHostParameters, LoadedType taskType);
    public sealed virtual IBuildEngine get_BuildEngine();
    public sealed virtual void set_BuildEngine(IBuildEngine value);
    public sealed virtual ITaskHost get_HostObject();
    public sealed virtual void set_HostObject(ITaskHost value);
    public sealed virtual void SetPropertyValue(TaskPropertyInfo property, object value);
    public sealed virtual object GetPropertyValue(TaskPropertyInfo property);
    public sealed virtual void Cancel();
    public sealed virtual bool Execute();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal void Cleanup();
    private void HandlePacket(INodePacket packet, Boolean& taskFinished);
    private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete);
    private void HandleNodeShutdown(NodeShutdown nodeShutdown);
    private void HandleLoggedMessage(LogMessagePacket logMessagePacket);
    private void LogErrorUnableToCreateTaskHost(TaskHostContext requiredContext, string runtime, string architecture, NodeFailedToLaunchException e);
}
internal class Microsoft.Build.BackEnd.TaskHostTaskCancelled : object {
    public NodePacketType Type { get; }
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostTaskComplete : object {
    private TaskCompleteType _taskResult;
    private Exception _taskException;
    private string _taskExceptionMessage;
    private String[] _taskExceptionMessageArgs;
    private Dictionary`2<string, TaskParameter> _taskOutputParameters;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    public TaskCompleteType TaskResult { get; }
    public Exception TaskException { get; }
    public string TaskExceptionMessage { get; }
    public String[] TaskExceptionMessageArgs { get; }
    public Dictionary`2<string, TaskParameter> TaskOutputParameters { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public NodePacketType Type { get; }
    public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary`2<string, string> buildProcessEnvironment);
    [DebuggerStepThroughAttribute]
public TaskCompleteType get_TaskResult();
    [DebuggerStepThroughAttribute]
public Exception get_TaskException();
    [DebuggerStepThroughAttribute]
public string get_TaskExceptionMessage();
    [DebuggerStepThroughAttribute]
public String[] get_TaskExceptionMessageArgs();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskOutputParameters();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static INodePacket FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelper : object {
    private ITask _taskInstance;
    private object _locker;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    private string _taskNameUpperCase;
    private IBuildEngine _buildEngine;
    [CompilerGeneratedAttribute]
private ResourceManager <TaskResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeywordPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLoggedErrors>k__BackingField;
    protected string TaskName { get; }
    private string TaskNameUpperCase { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; private set; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    [CompilerGeneratedAttribute]
protected string get_TaskName();
    private string get_TaskNameUpperCase();
    protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public ResourceManager get_TaskResources();
    [CompilerGeneratedAttribute]
public void set_TaskResources(ResourceManager value);
    [CompilerGeneratedAttribute]
public string get_HelpKeywordPrefix();
    [CompilerGeneratedAttribute]
public void set_HelpKeywordPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
private void set_HasLoggedErrors(bool value);
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelperExtension : TaskLoggingHelper {
    private ResourceManager _taskSharedResources;
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
internal class Microsoft.Build.BackEnd.TaskParameter : object {
    private TaskParameterType _parameterType;
    private object _wrappedParameter;
    public TaskParameterType ParameterType { get; }
    public object WrappedParameter { get; }
    public TaskParameter(object wrappedParameter);
    [DebuggerStepThroughAttribute]
public TaskParameterType get_ParameterType();
    [DebuggerStepThroughAttribute]
public object get_WrappedParameter();
    public virtual string ToString();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static TaskParameter FactoryForDeserialization(INodePacketTranslator translator);
    private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom);
    private void TranslateITaskItemArray(INodePacketTranslator translator);
    private void TranslateITaskItem(INodePacketTranslator translator);
    private void WriteITaskItem(INodePacketTranslator translator, ITaskItem wrappedItem);
    private void ReadITaskItem(INodePacketTranslator translator, ITaskItem& wrappedItem);
    private bool TranslateNullable(INodePacketTranslator translator, T value);
}
internal enum Microsoft.Build.BackEnd.TaskParameterType : Enum {
    public int value__;
    public static TaskParameterType Null;
    public static TaskParameterType String;
    public static TaskParameterType StringArray;
    public static TaskParameterType ValueType;
    public static TaskParameterType ValueTypeArray;
    public static TaskParameterType ITaskItem;
    public static TaskParameterType ITaskItemArray;
    public static TaskParameterType Invalid;
}
internal static class Microsoft.Build.BackEnd.TaskParameterTypeVerifier : object {
    internal static bool IsValidScalarInputParameter(Type parameterType);
    internal static bool IsValidVectorInputParameter(Type parameterType);
    internal static bool IsAssignableToITask(Type parameterType);
    internal static bool IsValueTypeOutputParameter(Type parameterType);
    internal static bool IsValidInputParameter(Type parameterType);
    internal static bool IsValidOutputParameter(Type parameterType);
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskRequirements : Enum {
    public int value__;
    public static TaskRequirements None;
    public static TaskRequirements RequireSTAThread;
    public static TaskRequirements RequireSeparateAppDomain;
}
internal enum Microsoft.Build.BackEnd.TranslationDirection : Enum {
    public int value__;
    public static TranslationDirection WriteToStream;
    public static TranslationDirection ReadFromStream;
}
internal class Microsoft.Build.BackEnd.Translator`1 : MulticastDelegate {
    public Translator`1(object object, IntPtr method);
    public virtual void Invoke(T& obj, INodePacketTranslator translator);
    public virtual IAsyncResult BeginInvoke(T& obj, INodePacketTranslator translator, AsyncCallback callback, object object);
    public virtual void EndInvoke(T& obj, IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.WorkUnitActionCode : Enum {
    public int value__;
    public static WorkUnitActionCode Continue;
    public static WorkUnitActionCode Stop;
}
internal class Microsoft.Build.BackEnd.WorkUnitResult : object {
    private WorkUnitResultCode _resultCode;
    private WorkUnitActionCode _actionCode;
    private Exception _exception;
    internal WorkUnitResultCode ResultCode { get; }
    internal WorkUnitActionCode ActionCode { get; internal set; }
    internal Exception Exception { get; }
    internal WorkUnitResult(WorkUnitResultCode resultCode, WorkUnitActionCode actionCode, Exception e);
    private WorkUnitResult(INodePacketTranslator translator);
    internal WorkUnitResultCode get_ResultCode();
    internal WorkUnitActionCode get_ActionCode();
    internal void set_ActionCode(WorkUnitActionCode value);
    internal Exception get_Exception();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static WorkUnitResult FactoryForDeserialization(INodePacketTranslator translator);
    internal WorkUnitResult AggregateResult(WorkUnitResult result);
}
internal enum Microsoft.Build.BackEnd.WorkUnitResultCode : Enum {
    public int value__;
    public static WorkUnitResultCode Skipped;
    public static WorkUnitResultCode Success;
    public static WorkUnitResultCode Failed;
    public static WorkUnitResultCode Canceled;
}
internal enum Microsoft.Build.BackEnd.YieldAction : Enum {
    public byte value__;
    public static YieldAction Yield;
    public static YieldAction Reacquire;
    public static YieldAction None;
}
internal class Microsoft.Build.Collections.BitHelper : object {
    private static byte MarkedBitFlag;
    private static byte IntSize;
    private int _length;
    [SecurityCriticalAttribute]
private Int32* _arrayPtr;
    private Int32[] _array;
    private bool _useStackAlloc;
    [SecurityCriticalAttribute]
internal BitHelper(Int32* bitArrayPtr, int length);
    [SecurityCriticalAttribute]
internal BitHelper(Int32[] bitArray, int length);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static T Dequeue(ConcurrentQueue`1<T> stack);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentStackExtensions : object {
    [ExtensionAttribute]
public static T Peek(ConcurrentStack`1<T> stack);
    [ExtensionAttribute]
public static T Pop(ConcurrentStack`1<T> stack);
}
internal class Microsoft.Build.Collections.ConvertingEnumerable`2 : object {
    private IEnumerable`1<TFrom> _backingEnumerable;
    private Func`2<TFrom, TTo> _converter;
    internal ConvertingEnumerable`2(IEnumerable`1<TFrom> backingEnumerable, Func`2<TFrom, TTo> converter);
    public sealed virtual IEnumerator`1<TTo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Collections.CopyOnReadEnumerable`1 : object {
    private IEnumerable`1<T> _backingEnumerable;
    private object _syncRoot;
    public CopyOnReadEnumerable`1(IEnumerable`1<T> backingEnumerable, object syncRoot);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    private int capacity;
    private CopyOnWriteBackingDictionary`2<K, V, K, V> backing;
    [CompilerGeneratedAttribute]
private static CopyOnWriteDictionary`2<K, V> <Dummy>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<K> <Comparer>k__BackingField;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; private set; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> ReadOperation { get; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> WriteOperation { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`2(CopyOnWriteDictionary`2<K, V> that);
    public CopyOnWriteDictionary`2(IDictionary`2<K, V> dictionary);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [CompilerGeneratedAttribute]
internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<K> get_Comparer();
    [CompilerGeneratedAttribute]
private void set_Comparer(IEqualityComparer`1<K> value);
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_ReadOperation();
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_WriteOperation();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1 : object {
    private CopyOnWriteDictionary`2<string, T> _properties;
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    internal int Count { get; }
    internal ICollection`1<string> PropertyNames { get; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    internal T Item { get; internal set; }
    public CopyOnWritePropertyDictionary`1(int capacity);
    private CopyOnWritePropertyDictionary`1(CopyOnWritePropertyDictionary`1<T> that);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    internal int get_Count();
    internal ICollection`1<string> get_PropertyNames();
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public bool Contains(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(CopyOnWritePropertyDictionary`1<T> other);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    internal bool Remove(string name);
    internal bool Remove(string name, bool clearIfEmpty);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal void RemoveProperties(IEnumerable`1<T> other);
    internal IDictionary`2<string, string> ToDictionary();
    internal CopyOnWritePropertyDictionary`1<T> DeepClone();
}
internal static class Microsoft.Build.Collections.HashHelpers : object {
    internal static Int32[] primes;
    internal static int MaxPrimeArrayLength;
    private static HashHelpers();
    internal static bool IsPrime(int candidate);
    internal static int GetPrime(int min);
    internal static int GetMinPrime();
    internal static int ExpandPrime(int oldSize);
}
internal class Microsoft.Build.Collections.HashSetDebugView`1 : object {
    private RetrievableEntryHashSet`1<T> _set;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public HashSetDebugView`1(RetrievableEntryHashSet`1<T> set);
    public T[] get_Items();
}
internal static class Microsoft.Build.Collections.HashTableUtility : object {
    internal static int Compare(Dictionary`2<string, string> h1, Dictionary`2<string, string> h2);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    private object store;
    private IEqualityComparer`1<TKey> comparer;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    private void AddToOrUpdateList(List`1<KeyValuePair`2<TKey, TValue>> list, TKey key, TValue value, bool throwIfPresent);
}
internal interface Microsoft.Build.Collections.IConstrainedEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y, int indexY, int length);
    public abstract virtual int GetHashCode(T obj, int index, int length);
}
internal interface Microsoft.Build.Collections.IDeepCloneable`1 {
    public abstract virtual T DeepClone();
}
internal interface Microsoft.Build.Collections.IImmutable {
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Item types={ItemTypes.Count} #Items={Count}")]
internal class Microsoft.Build.Collections.ItemDictionary`1 : object {
    private Dictionary`2<string, LinkedList`1<T>> _itemLists;
    private Dictionary`2<T, LinkedListNode`1<T>> _nodes;
    internal int Count { get; }
    internal ICollection`1<string> ItemTypes { get; }
    internal ICollection`1<T> Item { get; }
    internal ItemDictionary`1(int initialItemTypesCapacity, int initialItemsCapacity);
    internal ItemDictionary`1(IEnumerable`1<T> items);
    internal int get_Count();
    internal ICollection`1<string> get_ItemTypes();
    internal ICollection`1<T> get_Item(string itemtype);
    public void Clear();
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ICollection`1<T> GetItems(string itemType);
    internal bool Contains(T projectItem);
    internal void Add(T projectItem);
    internal bool Remove(T projectItem);
    internal void Replace(T existingItem, T newItem);
    internal void ImportItems(IEnumerable`1<T> other);
    internal void ImportItemsOfType(string itemType, IEnumerable`1<T> items);
    internal void RemoveItems(IEnumerable`1<T> other);
    internal void AddEmptyMarker(string itemType);
    internal bool HasEmptyMarker(string itemType);
}
internal interface Microsoft.Build.Collections.IValued {
    public string EscapedValue { get; }
    public abstract virtual string get_EscapedValue();
}
internal class Microsoft.Build.Collections.LookasideStringInterner : object {
    private static int NullStringIndex;
    private static int EmptyStringIndex;
    private Dictionary`2<string, int> _stringToIdsMap;
    private List`1<string> _strings;
    public LookasideStringInterner(StringComparer comparer, int defaultCollectionSize);
    public LookasideStringInterner(INodePacketTranslator translator);
    public int Intern(string str);
    public string GetString(int index);
    public sealed virtual void Translate(INodePacketTranslator translator);
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : object {
    private static ProcessorArchitectures s_runningProcessorArchitecture;
    [CompilerGeneratedAttribute]
private static MSBuildNameIgnoreCaseComparer <Default>k__BackingField;
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    private static MSBuildNameIgnoreCaseComparer();
    [CompilerGeneratedAttribute]
internal static MSBuildNameIgnoreCaseComparer get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public sealed virtual int GetHashCode(string obj, int start, int length);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Keys={KeyCount} #Values={ValueCount}")]
internal class Microsoft.Build.Collections.MultiDictionary`2 : object {
    private Dictionary`2<K, SmallList`1<K, V, V>> _backing;
    private int _valueCount;
    internal int KeyCount { get; }
    internal int ValueCount { get; }
    internal IEnumerable`1<K> Keys { get; }
    internal IEnumerable`1<V> Item { get; }
    internal MultiDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal int get_KeyCount();
    internal int get_ValueCount();
    internal IEnumerable`1<K> get_Keys();
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.MultiDictionary`2/<get_Item>d__10")]
internal IEnumerable`1<V> get_Item(K key);
    internal void Add(K key, V value);
    internal bool Remove(K key, V value);
    internal void Clear();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.PropertyDictionary`1 : object {
    [DebuggerBrowsableAttribute("3")]
private RetrievableEntryHashSet`1<T> _properties;
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    internal int Count { get; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    internal T Item { get; internal set; }
    internal PropertyDictionary`1(int capacity);
    internal PropertyDictionary`1(IEnumerable`1<T> elements);
    internal PropertyDictionary`1(MSBuildNameIgnoreCaseComparer comparer);
    internal PropertyDictionary`1(int capacity, IEnumerable`1<T> elements);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    internal int get_Count();
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    public IEnumerable`1<T> GetCopyOnReadEnumerable();
    public bool Contains(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(PropertyDictionary`1<T> other);
    public sealed virtual T GetProperty(string name);
    public sealed virtual T GetProperty(string name, int startIndex, int endIndex);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.PropertyDictionary`1/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,T>>-GetEnumerator>d__39")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    internal bool Remove(string name);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal void RemoveProperties(IEnumerable`1<T> other);
    internal IDictionary`2<string, string> ToDictionary();
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    private IEnumerable`1<T> _backing;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection`1<T> BackingCollection { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private ICollection`1<T> get_BackingCollection();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3 : object {
    private IDictionary`2<K, V> _backing;
    private Func`2<V, N> _converter;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<N> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public N Item { get; public set; }
    internal ReadOnlyConvertingDictionary`3(IDictionary`2<K, V> backing, Func`2<V, N> converter);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<N> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual N get_Item(K key);
    public sealed virtual void set_Item(K key, N value);
    public sealed virtual void Add(K key, N value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, N& value);
    public sealed virtual void Add(KeyValuePair`2<K, N> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, N> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, N> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, N>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private KeyValuePair`2<K, N> KeyValueConverter(KeyValuePair`2<K, V> original);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Build.Collections.HashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.Build.Collections.RetrievableEntryHashSet`1 : object {
    private static int Lower31BitMask;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private static string CapacityName;
    private static string ElementsName;
    private static string ComparerName;
    private static string VersionName;
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    private int _lastIndex;
    private int _freeList;
    private IEqualityComparer`1<string> _comparer;
    private IConstrainedEqualityComparer`1<string> _constrainedComparer;
    private int _version;
    private bool _readOnly;
    private SerializationInfo _siInfo;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<T> Values { get; }
    internal T Item { get; internal set; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public RetrievableEntryHashSet`1(IEqualityComparer`1<string> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<string> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(IEnumerable`1<KeyValuePair`2<string, T>> collection, IEqualityComparer`1<string> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(int suggestedCapacity, IEqualityComparer`1<string> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<string> comparer);
    protected RetrievableEntryHashSet`1(SerializationInfo info, StreamingContext context);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<T> get_Values();
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    internal bool Contains(string key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> entry);
    public sealed virtual bool ContainsKey(string key);
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool TryGetValue(string key, T& item);
    public T Get(string key);
    public T Get(string key, int index, int length);
    private T GetCore(string item, int index, int length);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> entry);
    public sealed virtual bool Remove(string item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal void MakeReadOnly();
    public Enumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.RetrievableEntryHashSet`1/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,T>>-GetEnumerator>d__53")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public void Add(T item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> entry);
    public void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int index);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public void TrimExcess();
    private void Initialize(int capacity);
    private void IncreaseCapacity();
    private bool AddEvenIfPresent(T value);
    internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet`1<T> other);
    internal T[] ToArray();
    private int InternalGetHashCode(string item, int index, int length);
    private int InternalGetHashCode(string item);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.WeakValueDictionary`2 : object {
    [DebuggerBrowsableAttribute("3")]
private Dictionary`2<K, WeakReference`1<V>> _dictionary;
    [DebuggerBrowsableAttribute("0")]
private int _capacity;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public V Item { get; public set; }
    public WeakValueDictionary`2(IEqualityComparer`1<K> keyComparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool Contains(K key);
    public bool TryGetValue(K key, V& value);
    public bool Remove(K key);
    public int Scavenge();
    public void Clear();
}
internal class Microsoft.Build.Construction.AspNetCompilerParameters : ValueType {
    internal string aspNetVirtualPath;
    internal string aspNetPhysicalPath;
    internal string aspNetTargetPath;
    internal string aspNetForce;
    internal string aspNetUpdateable;
    internal string aspNetDebug;
    internal string aspNetKeyFile;
    internal string aspNetKeyContainer;
    internal string aspNetDelaySign;
    internal string aspNetAPTCA;
    internal string aspNetFixedNames;
}
public abstract class Microsoft.Build.Construction.ElementLocation : object {
    private static ElementLocation s_emptyElementLocation;
    [DebuggerBrowsableAttribute("0")]
public string File { get; }
    [DebuggerBrowsableAttribute("0")]
public int Line { get; }
    [DebuggerBrowsableAttribute("0")]
public int Column { get; }
    public string LocationString { get; }
    internal static ElementLocation EmptyLocation { get; }
    private static ElementLocation();
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public sealed virtual string get_LocationString();
    internal static ElementLocation get_EmptyLocation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ElementLocation FactoryForDeserialization(INodePacketTranslator translator);
    internal static ElementLocation Create(string file);
    internal static ElementLocation Create(string file, int line, int column);
    private static string GetLocationString(string file, int line, int column);
}
public enum Microsoft.Build.Construction.ImplicitImportLocation : Enum {
    public int value__;
    public static ImplicitImportLocation None;
    public static ImplicitImportLocation Top;
    public static ImplicitImportLocation Bottom;
}
[DebuggerDisplayAttribute("ProjectChooseElement (#Children={Count} HasOtherwise={OtherwiseElement != null})")]
public class Microsoft.Build.Construction.ProjectChooseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectWhenElement> WhenElements { get; }
    public ProjectOtherwiseElement OtherwiseElement { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectChooseElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectChooseElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectWhenElement> get_WhenElements();
    public ProjectOtherwiseElement get_OtherwiseElement();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
public class Microsoft.Build.Construction.ProjectConfigurationInSolution : object {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInBuild>k__BackingField;
    public string ConfigurationName { get; }
    public string PlatformName { get; }
    public string FullName { get; }
    public bool IncludeInBuild { get; }
    internal ProjectConfigurationInSolution(string configurationName, string platformName, bool includeInBuild);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public string get_PlatformName();
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public bool get_IncludeInBuild();
    private static string RemoveSpaceFromAnyCpuPlatform(string platformName);
}
public abstract class Microsoft.Build.Construction.ProjectElement : object {
    private ProjectElementContainer _parent;
    private string _condition;
    private bool _expressedAsAttribute;
    [CompilerGeneratedAttribute]
private ProjectElement <PreviousSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectElement <NextSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlElementWithLocation <XmlElement>k__BackingField;
    internal bool ExpressedAsAttribute { get; internal set; }
    public string Condition { get; public set; }
    public string Label { get; public set; }
    public ProjectElementContainer Parent { get; internal set; }
    public string OuterElement { get; }
    public IEnumerable`1<ProjectElementContainer> AllParents { get; }
    public ProjectElement PreviousSibling { get; internal set; }
    public ProjectElement NextSibling { get; internal set; }
    public ProjectRootElement ContainingProject { get; internal set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation LabelLocation { get; }
    public ElementLocation Location { get; }
    public string ElementName { get; }
    internal XmlElementWithLocation XmlElement { get; private set; }
    internal XmlDocumentWithLocation XmlDocument { get; }
    internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    internal virtual bool get_ExpressedAsAttribute();
    internal virtual void set_ExpressedAsAttribute(bool value);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Label();
    [DebuggerStepThroughAttribute]
public void set_Label(string value);
    [DebuggerStepThroughAttribute]
public ProjectElementContainer get_Parent();
    internal void set_Parent(ProjectElementContainer value);
    public sealed virtual string get_OuterElement();
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectElement/<get_AllParents>d__20")]
public IEnumerable`1<ProjectElementContainer> get_AllParents();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public ProjectElement get_PreviousSibling();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
internal void set_PreviousSibling(ProjectElement value);
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
public ProjectElement get_NextSibling();
    [CompilerGeneratedAttribute]
[DebuggerStepThroughAttribute]
internal void set_NextSibling(ProjectElement value);
    public ProjectRootElement get_ContainingProject();
    internal void set_ContainingProject(ProjectRootElement value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_LabelLocation();
    public ElementLocation get_Location();
    public sealed virtual string get_ElementName();
    [CompilerGeneratedAttribute]
internal XmlElementWithLocation get_XmlElement();
    [CompilerGeneratedAttribute]
private void set_XmlElement(XmlElementWithLocation value);
    [DebuggerStepThroughAttribute]
internal XmlDocumentWithLocation get_XmlDocument();
    public ProjectElement Clone();
    public virtual void CopyFrom(ProjectElement element);
    protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute);
    internal void SetProjectRootElementFromParser(XmlElementWithLocation xmlElement, ProjectRootElement projectRootElement);
    internal void ClearParent();
    internal void ReplaceElement(XmlElementWithLocation newElement);
    internal abstract virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer proposedParent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
    internal virtual void OnAfterParentChanged(ProjectElementContainer newParent);
    protected internal virtual ProjectElement Clone(ProjectRootElement factory);
    protected abstract virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
public abstract class Microsoft.Build.Construction.ProjectElementContainer : ProjectElement {
    private static string DEFAULT_INDENT;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectElement <FirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectElement <LastChild>k__BackingField;
    public IEnumerable`1<ProjectElement> AllChildren { get; }
    public ICollection`1<ProjectElement> Children { get; }
    public ICollection`1<ProjectElement> ChildrenReversed { get; }
    public int Count { get; private set; }
    public ProjectElement FirstChild { get; private set; }
    public ProjectElement LastChild { get; private set; }
    internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    public IEnumerable`1<ProjectElement> get_AllChildren();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_Children();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_ChildrenReversed();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public ProjectElement get_FirstChild();
    [CompilerGeneratedAttribute]
private void set_FirstChild(ProjectElement value);
    [CompilerGeneratedAttribute]
public ProjectElement get_LastChild();
    [CompilerGeneratedAttribute]
private void set_LastChild(ProjectElement value);
    public void InsertAfterChild(ProjectElement child, ProjectElement reference);
    public void InsertBeforeChild(ProjectElement child, ProjectElement reference);
    public void AppendChild(ProjectElement child);
    public void PrependChild(ProjectElement child);
    public void RemoveChild(ProjectElement child);
    public void RemoveAllChildren();
    public virtual void DeepCopyFrom(ProjectElementContainer element);
    internal void AppendParentedChildNoChecks(ProjectElement child);
    protected internal virtual ProjectElementContainer DeepClone(ProjectRootElement factory, ProjectElementContainer parent);
    private void SetElementAsAttributeValue(ProjectElement child);
    internal void UpdateElementValue(ProjectElement child);
    internal void AddToXml(ProjectElement child);
    private static string GetElementIndentation(XmlElementWithLocation xmlElement);
    internal void RemoveFromXml(ProjectElement child);
    private void AddInitialChild(ProjectElement child);
    private void VerifyForInsertBeforeAfterFirst(ProjectElement child, ProjectElement reference);
    private void VerifyThrowInvalidOperationNotSelfAncestor(ProjectElement element);
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectElementContainer/<GetChildrenRecursively>d__38")]
private IEnumerable`1<ProjectElement> GetChildrenRecursively();
    private static bool TrySearchLeftSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, ProjectElement& referenceSibling);
    private static bool TrySearchRightSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, ProjectElement& referenceSibling);
    private static bool TrySearchSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, Func`2<ProjectElement, ProjectElement> nextSibling, ProjectElement& referenceSibling);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Construction.ProjectExtensionsElement : ProjectElement {
    public string Condition { get; public set; }
    public string Content { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public string Item { get; public set; }
    internal ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement project);
    private ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement project);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Content();
    public void set_Content(string value);
    public virtual ElementLocation get_ConditionLocation();
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectExtensionsElement CreateParented(XmlElementWithLocation element, ProjectRootElement parent, ProjectRootElement containingProject);
    internal static ProjectExtensionsElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("Project={Project} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectImportElement : ProjectElement {
    [CompilerGeneratedAttribute]
private ImplicitImportLocation <ImplicitImportLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectElement <OriginalElement>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkReference <ParsedSdkReference>k__BackingField;
    public string Project { get; public set; }
    public ElementLocation ProjectLocation { get; }
    public string Sdk { get; public set; }
    public string Version { get; public set; }
    public string MinimumVersion { get; public set; }
    public ElementLocation SdkLocation { get; }
    public ImplicitImportLocation ImplicitImportLocation { get; internal set; }
    public ProjectElement OriginalElement { get; internal set; }
    internal SdkReference ParsedSdkReference { get; internal set; }
    internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject, SdkReference sdkReference);
    internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_Project();
    public void set_Project(string value);
    public ElementLocation get_ProjectLocation();
    public string get_Sdk();
    public void set_Sdk(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_MinimumVersion();
    public void set_MinimumVersion(string value);
    public ElementLocation get_SdkLocation();
    [CompilerGeneratedAttribute]
public ImplicitImportLocation get_ImplicitImportLocation();
    [CompilerGeneratedAttribute]
internal void set_ImplicitImportLocation(ImplicitImportLocation value);
    [CompilerGeneratedAttribute]
public ProjectElement get_OriginalElement();
    [CompilerGeneratedAttribute]
internal void set_OriginalElement(ProjectElement value);
    [CompilerGeneratedAttribute]
internal SdkReference get_ParsedSdkReference();
    [CompilerGeneratedAttribute]
internal void set_ParsedSdkReference(SdkReference value);
    internal static ProjectImportElement CreateDisconnected(string project, ProjectRootElement containingProject);
    internal static ProjectImportElement CreateImplicit(string project, ProjectRootElement containingProject, ImplicitImportLocation implicitImportLocation, SdkReference sdkReference, ProjectElement originalElement);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private bool CheckUpdatedSdk();
}
[DebuggerDisplayAttribute("#Imports={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectImportGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectImportElement> Imports { get; }
    internal ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectImportElement> get_Imports();
    public ProjectImportElement AddImport(string project);
    internal static ProjectImportGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
public class Microsoft.Build.Construction.ProjectInSolution : object {
    private static Char[] s_charsToCleanse;
    internal static String[] projectNamesToDisambiguate;
    private static char cleanCharacter;
    private string _relativePath;
    private List`1<string> _dependencies;
    private string _uniqueProjectName;
    private Dictionary`2<string, ProjectConfigurationInSolution> _projectConfigurations;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private SolutionProjectType <ProjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private SolutionFile <ParentSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <AspNetConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    private bool _checkedIfCanBeMSBuildProjectFile;
    private bool _canBeMSBuildProjectFile;
    private string _canBeMSBuildProjectFileErrorMessage;
    internal static int DependencyLevelUnknown;
    internal static int DependencyLevelBeingDetermined;
    public string ProjectName { get; internal set; }
    public string RelativePath { get; internal set; }
    public string AbsolutePath { get; }
    public string ProjectGuid { get; internal set; }
    public string ParentProjectGuid { get; internal set; }
    public IReadOnlyList`1<string> Dependencies { get; }
    public IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> ProjectConfigurations { get; }
    internal string Extension { get; }
    public SolutionProjectType ProjectType { get; public set; }
    internal List`1<string> ProjectReferences { get; }
    internal SolutionFile ParentSolution { get; internal set; }
    internal Hashtable AspNetConfigurations { get; internal set; }
    internal string TargetFrameworkMoniker { get; internal set; }
    internal ProjectInSolution(SolutionFile solution);
    private static ProjectInSolution();
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
internal void set_ProjectName(string value);
    public string get_RelativePath();
    internal void set_RelativePath(string value);
    public string get_AbsolutePath();
    [CompilerGeneratedAttribute]
public string get_ProjectGuid();
    [CompilerGeneratedAttribute]
internal void set_ProjectGuid(string value);
    [CompilerGeneratedAttribute]
public string get_ParentProjectGuid();
    [CompilerGeneratedAttribute]
internal void set_ParentProjectGuid(string value);
    public IReadOnlyList`1<string> get_Dependencies();
    public IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> get_ProjectConfigurations();
    internal string get_Extension();
    [CompilerGeneratedAttribute]
public SolutionProjectType get_ProjectType();
    [CompilerGeneratedAttribute]
public void set_ProjectType(SolutionProjectType value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_ProjectReferences();
    [CompilerGeneratedAttribute]
internal SolutionFile get_ParentSolution();
    [CompilerGeneratedAttribute]
internal void set_ParentSolution(SolutionFile value);
    [CompilerGeneratedAttribute]
internal Hashtable get_AspNetConfigurations();
    [CompilerGeneratedAttribute]
internal void set_AspNetConfigurations(Hashtable value);
    [CompilerGeneratedAttribute]
internal string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
internal void set_TargetFrameworkMoniker(string value);
    internal void AddDependency(string referencedProjectGuid);
    internal void SetProjectConfiguration(string configurationName, ProjectConfigurationInSolution configuration);
    internal bool CanBeMSBuildProjectFile(String& errorMessage);
    internal string GetUniqueProjectName();
    internal void UpdateUniqueProjectName(string newUniqueName);
    private static string CleanseProjectName(string projectName);
    internal static string DisambiguateProjectTargetName(string uniqueProjectName);
    private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProjectElement);
}
[DebuggerDisplayAttribute("{ItemType} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionElement : ProjectElementContainer {
    public string ItemType { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    internal ProjectItemDefinitionElement(XmlElement xmlElement, ProjectItemDefinitionGroupElement parent, ProjectRootElement containingProject);
    private ProjectItemDefinitionElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public string get_ItemType();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    internal static ProjectItemDefinitionElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#ItemDefinitions={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    internal static ProjectItemDefinitionGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{ItemType} Include={Include} Exclude={Exclude} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemElement : ProjectElementContainer {
    private string _include;
    private string _exclude;
    private string _remove;
    private string _update;
    private Nullable`1<bool> _includeHasWildcards;
    public string ItemType { get; public set; }
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string Remove { get; public set; }
    public string Update { get; public set; }
    public string KeepMetadata { get; public set; }
    public string RemoveMetadata { get; public set; }
    public string KeepDuplicates { get; public set; }
    public bool HasMetadata { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation UpdateLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    internal bool IncludeHasWildcards { get; }
    internal ProjectItemElement NextItem { get; }
    internal ProjectItemElement(XmlElementWithLocation xmlElement, ProjectItemGroupElement parent, ProjectRootElement containingProject);
    private ProjectItemElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_Include();
    public void set_Include(string value);
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    public void set_Exclude(string value);
    [DebuggerStepThroughAttribute]
public string get_Remove();
    public void set_Remove(string value);
    [DebuggerStepThroughAttribute]
public string get_Update();
    public void set_Update(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    public void set_KeepMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    public void set_RemoveMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    public void set_KeepDuplicates(string value);
    public bool get_HasMetadata();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ElementLocation get_IncludeLocation();
    public ElementLocation get_ExcludeLocation();
    public ElementLocation get_RemoveLocation();
    public ElementLocation get_UpdateLocation();
    public ElementLocation get_KeepMetadataLocation();
    public ElementLocation get_RemoveMetadataLocation();
    public ElementLocation get_KeepDuplicatesLocation();
    internal bool get_IncludeHasWildcards();
    internal ProjectItemElement get_NextItem();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectItemElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal void ChangeItemType(string newItemType);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void OnAfterParentChanged(ProjectElementContainer parent);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute);
}
[DebuggerDisplayAttribute("#Items={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemGroupElement : ProjectElementContainer {
    private bool _definitelyAreNoChildrenWithWildcards;
    public ICollection`1<ProjectItemElement> Items { get; }
    internal bool DefinitelyAreNoChildrenWithWildcards { get; internal set; }
    internal ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemElement> get_Items();
    internal bool get_DefinitelyAreNoChildrenWithWildcards();
    internal void set_DefinitelyAreNoChildrenWithWildcards(bool value);
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectItemGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectMetadataElement : ProjectElement {
    public string Name { get; public set; }
    public bool ExpressedAsAttribute { get; public set; }
    public string Value { get; public set; }
    internal ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    private ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    public string get_Name();
    public void set_Name(string value);
    public bool get_ExpressedAsAttribute();
    public void set_ExpressedAsAttribute(bool value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal void ChangeName(string newName);
    internal static void ValidateValidMetadataAsAttributeName(string name, string parentName, IElementLocation parentLocation);
    internal static bool AttributeNameIsValidMetadataName(string name);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("ExecuteTargetsAttribute={ExecuteTargetsAttribute}")]
public class Microsoft.Build.Construction.ProjectOnErrorElement : ProjectElement {
    public string ExecuteTargetsAttribute { get; public set; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement project);
    private ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    [DebuggerStepThroughAttribute]
public string get_ExecuteTargetsAttribute();
    public void set_ExecuteTargetsAttribute(string value);
    public ElementLocation get_ExecuteTargetsLocation();
    internal static ProjectOnErrorElement CreateDisconnected(string executeTargets, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Children={Count}")]
public class Microsoft.Build.Construction.ProjectOtherwiseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    private ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectOtherwiseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("TaskParameter={TaskParameter} ItemType={ItemType} PropertyName={PropertyName} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectOutputElement : ProjectElement {
    public string TaskParameter { get; public set; }
    public bool IsOutputItem { get; }
    public bool IsOutputProperty { get; }
    public string ItemType { get; public set; }
    public string PropertyName { get; public set; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectOutputElement(XmlElement xmlElement, ProjectTaskElement parent, ProjectRootElement containingProject);
    private ProjectOutputElement(XmlElement xmlElement, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_TaskParameter();
    [DebuggerStepThroughAttribute]
public void set_TaskParameter(string value);
    public bool get_IsOutputItem();
    public bool get_IsOutputProperty();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_PropertyName();
    public void set_PropertyName(string value);
    public ElementLocation get_TaskParameterLocation();
    public ElementLocation get_PropertyNameLocation();
    public ElementLocation get_ItemTypeLocation();
    internal static ProjectOutputElement CreateDisconnected(string taskParameter, string itemType, string propertyName, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
internal class Microsoft.Build.Construction.ProjectParser : object {
    internal static int MaximumChooseNesting;
    private static HashSet`1<string> ValidAttributesOnlyConditionAndLabel;
    private static HashSet`1<string> KnownAttributesOnItem;
    private static HashSet`1<string> KnownAttributesOnItemIgnoreCase;
    private static HashSet`1<string> ValidAttributesOnImport;
    private static HashSet`1<string> ValidAttributesOnUsingTask;
    private static HashSet`1<string> ValidAttributesOnTarget;
    private static HashSet`1<string> ValidAttributesOnOnError;
    private static HashSet`1<string> ValidAttributesOnOutput;
    private static HashSet`1<string> ValidAttributesOnUsingTaskParameter;
    private static HashSet`1<string> ValidAttributesOnUsingTaskBody;
    private ProjectRootElement _project;
    private XmlDocumentWithLocation _document;
    private bool _seenProjectExtensions;
    private ProjectParser(XmlDocumentWithLocation document, ProjectRootElement project);
    private static ProjectParser();
    internal static void Parse(XmlDocumentWithLocation document, ProjectRootElement projectRootElement);
    private void Parse();
    private ProjectPropertyGroupElement ParseProjectPropertyGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectItemGroupElement ParseProjectItemGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation element, ProjectItemGroupElement parent);
    internal static void CheckMetadataAsAttributeName(string name, Boolean& isReservedAttributeName, Boolean& isValidMetadataNameInAttribute);
    private ProjectMetadataElement ParseProjectMetadataElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectImportGroupElement ParseProjectImportGroupElement(XmlElementWithLocation element, ProjectRootElement parent);
    private ProjectImportElement ParseProjectImportElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private UsingTaskParameterGroupElement ParseUsingTaskParameterGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectUsingTaskElement ParseProjectUsingTaskElement(XmlElementWithLocation element);
    private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation element);
    private ProjectTaskElement ParseProjectTaskElement(XmlElementWithLocation element, ProjectTargetElement parent);
    private ProjectOutputElement ParseProjectOutputElement(XmlElementWithLocation element, ProjectTaskElement parent);
    private ProjectItemDefinitionGroupElement ParseProjectItemDefinitionGroupElement(XmlElementWithLocation element);
    private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWithLocation element, ProjectItemDefinitionGroupElement parent);
    private ProjectChooseElement ParseProjectChooseElement(XmlElementWithLocation element, ProjectElementContainer parent, int nestingDepth);
    private ProjectWhenElement ParseProjectWhenElement(XmlElementWithLocation element, ProjectChooseElement parent, int nestingDepth);
    private ProjectOtherwiseElement ParseProjectOtherwiseElement(XmlElementWithLocation element, ProjectChooseElement parent, int nestingDepth);
    private void ParseWhenOtherwiseChildren(XmlElementWithLocation element, ProjectElementContainer parent, int nestingDepth);
    private ProjectExtensionsElement ParseProjectExtensionsElement(XmlElementWithLocation element);
    private ProjectSdkElement ParseProjectSdkElement(XmlElementWithLocation element);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectPropertyElement : ProjectElement {
    public string Name { get; public set; }
    public string Value { get; public set; }
    internal ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectPropertyGroupElement parent, ProjectRootElement containingProject);
    private ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectPropertyElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal void ChangeName(string newName);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Properties={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectPropertyGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectPropertyElement> PropertiesReversed { get; }
    internal ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectPropertyElement> get_PropertiesReversed();
    public ProjectPropertyElement AddProperty(string name, string unevaluatedValue);
    public ProjectPropertyElement SetProperty(string name, string unevaluatedValue);
    internal static ProjectPropertyGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")]
public class Microsoft.Build.Construction.ProjectRootElement : ProjectElementContainer {
    private static string EmptyProjectFileContent;
    private static string EmptyProjectFileXmlDeclaration;
    private static string EmptyProjectFileToolsVersion;
    private static string EmptyProjectFileXmlNamespace;
    private static OpenProjectRootElement s_openLoaderDelegate;
    private static OpenProjectRootElement s_openLoaderPreserveFormattingDelegate;
    private static Lazy`1<Regex> XmlDeclarationRegEx;
    private static Encoding s_defaultEncoding;
    private static int s_globalVersionCounter;
    private int _versionOnDisk;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    private ElementLocation _projectFileLocation;
    private string _directory;
    private DateTime _timeLastChangedUtc;
    private DateTime _lastWriteTimeWhenRead;
    private string _dirtyReason;
    private string _dirtyParameter;
    [CompilerGeneratedAttribute]
private RenameHandlerDelegate OnAfterProjectRename;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> OnProjectXmlChanged;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExplicitlyLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCache <ProjectRootElementCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsTargetsWithReturnsAttribute>k__BackingField;
    internal string XmlNamespace { get; internal set; }
    public string Condition { get; public set; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroups { get; }
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectItemElement> Items { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroups { get; }
    public ICollection`1<ProjectImportElement> Imports { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectTargetElement> Targets { get; }
    public ICollection`1<ProjectUsingTaskElement> UsingTasks { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroupsReversed { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroupsReversed { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroupsReversed { get; }
    public string DirectoryPath { get; internal set; }
    public string FullPath { get; public set; }
    public Encoding Encoding { get; }
    public string DefaultTargets { get; public set; }
    public string InitialTargets { get; public set; }
    public string Sdk { get; public set; }
    public string TreatAsLocalProperty { get; public set; }
    public string ToolsVersion { get; public set; }
    public string RawXml { get; }
    public bool HasUnsavedChanges { get; }
    public bool PreserveFormatting { get; }
    public int Version { get; private set; }
    public DateTime TimeLastChanged { get; }
    public DateTime LastWriteTimeWhenRead { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ProjectFileLocation { get; }
    public ElementLocation ToolsVersionLocation { get; }
    public ElementLocation DefaultTargetsLocation { get; }
    public ElementLocation InitialTargetsLocation { get; }
    public ElementLocation SdkLocation { get; }
    public ElementLocation TreatAsLocalPropertyLocation { get; }
    internal bool IsExplicitlyLoaded { get; private set; }
    internal ProjectRootElementCache ProjectRootElementCache { get; }
    internal bool IsMemberOfProjectCollection { get; }
    internal bool ContainsTargetsWithReturnsAttribute { get; internal set; }
    internal ProjectExtensionsElement ProjectExtensions { get; }
    internal string LastDirtyReason { get; }
    internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded, bool preserveFormatting);
    private ProjectRootElement(ProjectRootElementCache projectRootElementCache, NewProjectFileOptions projectFileOptions);
    private ProjectRootElement(string path, ProjectRootElementCache projectRootElementCache, bool preserveFormatting);
    private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementCache projectRootElementCache);
    private ProjectRootElement(XmlDocumentWithLocation document);
    private static ProjectRootElement();
    [CompilerGeneratedAttribute]
internal string get_XmlNamespace();
    [CompilerGeneratedAttribute]
internal void set_XmlNamespace(string value);
    [CompilerGeneratedAttribute]
internal void add_OnAfterProjectRename(RenameHandlerDelegate value);
    [CompilerGeneratedAttribute]
internal void remove_OnAfterProjectRename(RenameHandlerDelegate value);
    [CompilerGeneratedAttribute]
internal void add_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroups();
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectItemElement> get_Items();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroups();
    public ICollection`1<ProjectImportElement> get_Imports();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectTargetElement> get_Targets();
    public ICollection`1<ProjectUsingTaskElement> get_UsingTasks();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroupsReversed();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroupsReversed();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroupsReversed();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroupsReversed();
    public string get_DirectoryPath();
    internal void set_DirectoryPath(string value);
    public string get_FullPath();
    public void set_FullPath(string value);
    public Encoding get_Encoding();
    [DebuggerStepThroughAttribute]
public string get_DefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_DefaultTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_InitialTargets();
    [DebuggerStepThroughAttribute]
public void set_InitialTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_Sdk();
    [DebuggerStepThroughAttribute]
public void set_Sdk(string value);
    [DebuggerStepThroughAttribute]
public string get_TreatAsLocalProperty();
    [DebuggerStepThroughAttribute]
public void set_TreatAsLocalProperty(string value);
    [DebuggerStepThroughAttribute]
public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public void set_ToolsVersion(string value);
    public string get_RawXml();
    public bool get_HasUnsavedChanges();
    public bool get_PreserveFormatting();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    public DateTime get_TimeLastChanged();
    public DateTime get_LastWriteTimeWhenRead();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ProjectFileLocation();
    public ElementLocation get_ToolsVersionLocation();
    public ElementLocation get_DefaultTargetsLocation();
    public ElementLocation get_InitialTargetsLocation();
    public ElementLocation get_SdkLocation();
    public ElementLocation get_TreatAsLocalPropertyLocation();
    [CompilerGeneratedAttribute]
internal bool get_IsExplicitlyLoaded();
    [CompilerGeneratedAttribute]
private void set_IsExplicitlyLoaded(bool value);
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    internal bool get_IsMemberOfProjectCollection();
    [CompilerGeneratedAttribute]
internal bool get_ContainsTargetsWithReturnsAttribute();
    [CompilerGeneratedAttribute]
internal void set_ContainsTargetsWithReturnsAttribute(bool value);
    internal ProjectExtensionsElement get_ProjectExtensions();
    internal string get_LastDirtyReason();
    public static ProjectRootElement Create();
    public static ProjectRootElement Create(NewProjectFileOptions projectFileOptions);
    public static ProjectRootElement Create(ProjectCollection projectCollection);
    public static ProjectRootElement Create(ProjectCollection projectCollection, NewProjectFileOptions projectFileOptions);
    public static ProjectRootElement Create(string path);
    public static ProjectRootElement Create(string path, NewProjectFileOptions newProjectFileOptions);
    public static ProjectRootElement Create(string path, ProjectCollection projectCollection);
    public static ProjectRootElement Create(string path, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public static ProjectRootElement Create(XmlReader xmlReader);
    public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection);
    public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection, bool preserveFormatting);
    public static ProjectRootElement Open(string path);
    public static ProjectRootElement Open(string path, ProjectCollection projectCollection);
    public static ProjectRootElement Open(string path, ProjectCollection projectCollection, Nullable`1<bool> preserveFormatting);
    public static ProjectRootElement TryOpen(string path);
    public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection);
    public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection, Nullable`1<bool> preserveFormatting);
    public ProjectImportElement AddImport(string project);
    public ProjectImportGroupElement AddImportGroup();
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    public ProjectItemDefinitionGroupElement AddItemDefinitionGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectPropertyElement AddProperty(string name, string value);
    public ProjectTargetElement AddTarget(string name);
    public ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName);
    public ProjectChooseElement CreateChooseElement();
    public ProjectImportElement CreateImportElement(string project);
    public ProjectItemElement CreateItemElement(string itemType);
    public ProjectItemElement CreateItemElement(string itemType, string include);
    public ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
    public ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
    public ProjectItemGroupElement CreateItemGroupElement();
    public ProjectImportGroupElement CreateImportGroupElement();
    public ProjectMetadataElement CreateMetadataElement(string name);
    public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
    public ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
    public ProjectOtherwiseElement CreateOtherwiseElement();
    public ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
    public ProjectExtensionsElement CreateProjectExtensionsElement();
    public ProjectPropertyGroupElement CreatePropertyGroupElement();
    public ProjectPropertyElement CreatePropertyElement(string name);
    public ProjectTargetElement CreateTargetElement(string name);
    public ProjectTaskElement CreateTaskElement(string name);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
    public UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
    public ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
    public ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
    public ProjectWhenElement CreateWhenElement(string condition);
    public ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion);
    public void Save();
    public void Save(Encoding saveEncoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    public ProjectRootElement DeepClone();
    public void Reload(bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    public void ReloadFrom(string path, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    public void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    private void ReloadFrom(Func`2<bool, XmlDocumentWithLocation> documentProducer, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    private static void ThrowIfDocumentHasParsingErrors(XmlDocumentWithLocation document);
    internal static ProjectRootElement Create(ProjectRootElementCache projectRootElementCache);
    internal static ProjectRootElement Create(ProjectRootElementCache projectRootElementCache, NewProjectFileOptions projectFileOptions);
    internal static ProjectRootElement Open(string path, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    internal static ProjectRootElement Open(XmlDocumentWithLocation document);
    internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectRootElementCache projectRootElementCache, bool isExplicitlyLoaded);
    internal XmlElementWithLocation CreateElement(string name);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal sealed virtual void MarkDirty(string reason, string param);
    internal void MarkProjectDirty(Project project);
    internal void MarkAsExplicitlyLoaded();
    internal List`1<ProjectImportElement> GetImplicitImportNodes(ProjectRootElement currentProjectOrImport);
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectRootElement/<ParseSdks>d__208")]
private static IEnumerable`1<SdkReference> ParseSdks(string sdks, IElementLocation sdkLocation);
    internal static bool IsEmptyXmlFile(string path);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static ProjectRootElement OpenLoader(string path, ProjectRootElementCache projectRootElementCache);
    private static ProjectRootElement OpenLoaderPreserveFormatting(string path, ProjectRootElementCache projectRootElementCache);
    private static ProjectRootElement OpenLoader(string path, ProjectRootElementCache projectRootElementCache, bool preserveFormatting);
    private static ProjectRootElement CreateProjectFromPath(string projectFile, ProjectRootElementCache projectRootElementCache, bool preserveFormatting);
    private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveFormatting);
    private static XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveFormatting);
    private void IncrementVersion();
    private void ThrowIfUnsavedChanges(bool throwIfUnsavedChanges);
}
public class Microsoft.Build.Construction.ProjectSdkElement : ProjectElementContainer {
    public string Name { get; public set; }
    public string Version { get; public set; }
    public string MinimumVersion { get; public set; }
    internal ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_Name();
    public void set_Name(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_MinimumVersion();
    public void set_MinimumVersion(string value);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    internal static ProjectSdkElement CreateDisconnected(string sdkName, string sdkVersion, ProjectRootElement containingProject);
}
[DebuggerDisplayAttribute("#Strings={Count} #Documents={_documents.Count}")]
internal class Microsoft.Build.Construction.ProjectStringCache : object {
    private static int InitialSize;
    private RetrievableEntryHashSet`1<StringCacheEntry> _strings;
    private Dictionary`2<XmlDocument, HashSet`1<StringCacheEntry>> _documents;
    private object _locker;
    internal int Count { get; }
    internal int get_Count();
    public string Add(string key, XmlDocument document);
    public string Get(string key);
    public void Clear(XmlDocument document);
    [ConditionalAttribute("NEVER")]
private void VerifyState();
    private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement);
}
[DebuggerDisplayAttribute("Name={Name} #Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectTargetElement : ProjectElementContainer {
    private string _name;
    [CompilerGeneratedAttribute]
private ProjectTargetInstance <TargetInstance>k__BackingField;
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectTaskElement> Tasks { get; }
    public ICollection`1<ProjectOnErrorElement> OnErrors { get; }
    public string Name { get; public set; }
    public string Inputs { get; public set; }
    public string Outputs { get; public set; }
    public string KeepDuplicateOutputs { get; public set; }
    public string DependsOnTargets { get; public set; }
    public string BeforeTargets { get; public set; }
    public string AfterTargets { get; public set; }
    public string Returns { get; public set; }
    public ElementLocation NameLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    internal ProjectTargetInstance TargetInstance { get; internal set; }
    internal ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectTaskElement> get_Tasks();
    public ICollection`1<ProjectOnErrorElement> get_OnErrors();
    [DebuggerStepThroughAttribute]
public string get_Name();
    public void set_Name(string value);
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    public void set_Inputs(string value);
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    public void set_Outputs(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    public void set_KeepDuplicateOutputs(string value);
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    public void set_DependsOnTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_BeforeTargets();
    public void set_BeforeTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_AfterTargets();
    public void set_AfterTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_Returns();
    public void set_Returns(string value);
    public ElementLocation get_NameLocation();
    public ElementLocation get_InputsLocation();
    public ElementLocation get_OutputsLocation();
    public ElementLocation get_KeepDuplicateOutputsLocation();
    public ElementLocation get_DependsOnTargetsLocation();
    public ElementLocation get_BeforeTargetsLocation();
    public ElementLocation get_ReturnsLocation();
    public ElementLocation get_AfterTargetsLocation();
    [CompilerGeneratedAttribute]
internal ProjectTargetInstance get_TargetInstance();
    [CompilerGeneratedAttribute]
internal void set_TargetInstance(ProjectTargetInstance value);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectTaskElement AddTask(string taskName);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectTargetElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{Name} Condition={Condition} ContinueOnError={ContinueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Outputs={Count}")]
public class Microsoft.Build.Construction.ProjectTaskElement : ProjectElementContainer {
    private CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> _parameters;
    private object _locker;
    public string ContinueOnError { get; public set; }
    public string MSBuildRuntime { get; public set; }
    public string MSBuildArchitecture { get; public set; }
    public string Name { get; }
    public ICollection`1<ProjectOutputElement> Outputs { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> ParameterLocations { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    internal CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> ParametersForEvaluation { get; }
    internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject);
    private ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public void set_ContinueOnError(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildRuntime();
    [DebuggerStepThroughAttribute]
public void set_MSBuildRuntime(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildArchitecture();
    [DebuggerStepThroughAttribute]
public void set_MSBuildArchitecture(string value);
    public string get_Name();
    public ICollection`1<ProjectOutputElement> get_Outputs();
    public IDictionary`2<string, string> get_Parameters();
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> get_ParameterLocations();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    internal CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> get_ParametersForEvaluation();
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType);
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition);
    public string GetParameter(string name);
    public void SetParameter(string name, string unevaluatedValue);
    public void RemoveParameter(string name);
    public void RemoveAllParameters();
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectTaskElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private void EnsureParametersInitialized();
}
[DebuggerDisplayAttribute("Evaluate={Evaluate} TaskBody={TaskBody}")]
public class Microsoft.Build.Construction.ProjectUsingTaskBodyElement : ProjectElement {
    public string Condition { get; public set; }
    public string TaskBody { get; public set; }
    public string Evaluate { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation EvaluateLocation { get; }
    internal ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectUsingTaskElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public string get_TaskBody();
    public void set_TaskBody(string value);
    public string get_Evaluate();
    public void set_Evaluate(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_EvaluateLocation();
    internal static ProjectUsingTaskBodyElement CreateDisconnected(string evaluate, string body, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static void VerifyCorrectParent(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("TaskName={TaskName} AssemblyName={AssemblyName} AssemblyFile={AssemblyFile} Condition={Condition} Runtime={Runtime} Architecture={Architecture}")]
public class Microsoft.Build.Construction.ProjectUsingTaskElement : ProjectElementContainer {
    public string AssemblyFile { get; public set; }
    public string AssemblyName { get; public set; }
    public string TaskName { get; public set; }
    public string TaskFactory { get; public set; }
    public string Runtime { get; public set; }
    public string Architecture { get; public set; }
    public ProjectUsingTaskBodyElement TaskBody { get; }
    public UsingTaskParameterGroupElement ParameterGroup { get; }
    public ElementLocation TaskNameLocation { get; }
    public ElementLocation AssemblyFileLocation { get; }
    public ElementLocation AssemblyNameLocation { get; }
    public ElementLocation RuntimeLocation { get; }
    public ElementLocation ArchitectureLocation { get; }
    public ElementLocation TaskFactoryLocation { get; }
    internal ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_AssemblyFile();
    public void set_AssemblyFile(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_TaskName();
    public void set_TaskName(string value);
    public string get_TaskFactory();
    public void set_TaskFactory(string value);
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_Architecture();
    public void set_Architecture(string value);
    public ProjectUsingTaskBodyElement get_TaskBody();
    public UsingTaskParameterGroupElement get_ParameterGroup();
    public ElementLocation get_TaskNameLocation();
    public ElementLocation get_AssemblyFileLocation();
    public ElementLocation get_AssemblyNameLocation();
    public ElementLocation get_RuntimeLocation();
    public ElementLocation get_ArchitectureLocation();
    public ElementLocation get_TaskFactoryLocation();
    public UsingTaskParameterGroupElement AddParameterGroup();
    public ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string taskBody);
    internal static ProjectUsingTaskElement CreateDisconnected(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("Name={Name} ParameterType={ParameterType} Output={Output} Required={Required}")]
public class Microsoft.Build.Construction.ProjectUsingTaskParameterElement : ProjectElement {
    public string Condition { get; public set; }
    public string Name { get; public set; }
    public string ParameterType { get; public set; }
    public string Output { get; public set; }
    public string Required { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ParameterTypeLocation { get; }
    public ElementLocation OutputLocation { get; }
    public ElementLocation RequiredLocation { get; }
    internal ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, UsingTaskParameterGroupElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ParameterType();
    public void set_ParameterType(string value);
    public string get_Output();
    public void set_Output(string value);
    public string get_Required();
    public void set_Required(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ParameterTypeLocation();
    public ElementLocation get_OutputLocation();
    public ElementLocation get_RequiredLocation();
    internal static ProjectUsingTaskParameterElement CreateDisconnected(string parameterName, string output, string required, string parameterType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectWhenElement : ProjectElementContainer {
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    internal ProjectWhenElement(XmlElement xmlElement, ProjectChooseElement parent, ProjectRootElement containingProject);
    private ProjectWhenElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    internal static ProjectWhenElement CreateDisconnected(string condition, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
internal class Microsoft.Build.Construction.RegistryLocation : object {
    private string registryPath;
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    internal RegistryLocation(string registryPath);
    private RegistryLocation(INodePacketTranslator translator);
    public sealed virtual string get_File();
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public sealed virtual string get_LocationString();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static RegistryLocation FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.Construction.RenameHandlerDelegate : MulticastDelegate {
    public RenameHandlerDelegate(object object, IntPtr method);
    public virtual void Invoke(string oldFullPath);
    public virtual IAsyncResult BeginInvoke(string oldFullPath, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Construction.SolutionConfigurationInSolution : object {
    internal static char ConfigurationPlatformSeparator;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string ConfigurationName { get; }
    public string PlatformName { get; }
    public string FullName { get; }
    internal SolutionConfigurationInSolution(string configurationName, string platformName);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public string get_PlatformName();
    [CompilerGeneratedAttribute]
public string get_FullName();
    internal static string ComputeFullName(string configurationName, string platformName);
}
public class Microsoft.Build.Construction.SolutionFile : object {
    private static Lazy`1<Regex> s_crackProjectLine;
    private static Lazy`1<Regex> s_crackPropertyLine;
    internal static int slnFileMinUpgradableVersion;
    internal static int slnFileMinVersion;
    internal static int slnFileMaxVersion;
    private static string vbProjectGuid;
    private static string csProjectGuid;
    private static string cpsProjectGuid;
    private static string cpsCsProjectGuid;
    private static string cpsVbProjectGuid;
    private static string vjProjectGuid;
    private static string vcProjectGuid;
    private static string fsProjectGuid;
    private static string dbProjectGuid;
    private static string wdProjectGuid;
    private static string webProjectGuid;
    private static string solutionFolderGuid;
    private static string sharedProjectGuid;
    private string _solutionFile;
    private bool _parsingForConversionOnly;
    private Dictionary`2<string, ProjectInSolution> _projects;
    private List`1<ProjectInSolution> _projectsInOrder;
    private List`1<SolutionConfigurationInSolution> _solutionConfigurations;
    private string _defaultConfigurationName;
    private string _defaultPlatformName;
    private Version _currentVisualStudioVersion;
    private int _currentLineNumber;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserComments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserErrorCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsWebProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsWebDeploymentProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFileDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamReader <SolutionReader>k__BackingField;
    internal List`1<string> SolutionParserWarnings { get; }
    internal List`1<string> SolutionParserComments { get; }
    internal List`1<string> SolutionParserErrorCodes { get; }
    internal int Version { get; private set; }
    internal int VisualStudioVersion { get; }
    internal bool ContainsWebProjects { get; private set; }
    internal bool ContainsWebDeploymentProjects { get; private set; }
    public IReadOnlyList`1<ProjectInSolution> ProjectsInOrder { get; }
    public IReadOnlyDictionary`2<string, ProjectInSolution> ProjectsByGuid { get; }
    internal string FullPath { get; internal set; }
    internal string SolutionFileDirectory { get; internal set; }
    internal StreamReader SolutionReader { get; internal set; }
    public IReadOnlyList`1<SolutionConfigurationInSolution> SolutionConfigurations { get; }
    private static SolutionFile();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserWarnings();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserComments();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserErrorCodes();
    [CompilerGeneratedAttribute]
internal int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    internal int get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
internal bool get_ContainsWebProjects();
    [CompilerGeneratedAttribute]
private void set_ContainsWebProjects(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ContainsWebDeploymentProjects();
    [CompilerGeneratedAttribute]
private void set_ContainsWebDeploymentProjects(bool value);
    public IReadOnlyList`1<ProjectInSolution> get_ProjectsInOrder();
    public IReadOnlyDictionary`2<string, ProjectInSolution> get_ProjectsByGuid();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    [CompilerGeneratedAttribute]
internal string get_SolutionFileDirectory();
    [CompilerGeneratedAttribute]
internal void set_SolutionFileDirectory(string value);
    [CompilerGeneratedAttribute]
internal StreamReader get_SolutionReader();
    [CompilerGeneratedAttribute]
internal void set_SolutionReader(StreamReader value);
    public IReadOnlyList`1<SolutionConfigurationInSolution> get_SolutionConfigurations();
    public static SolutionFile Parse(string solutionFile);
    internal static bool IsBuildableProject(ProjectInSolution project);
    internal static void GetSolutionFileAndVisualStudioMajorVersions(string solutionFile, Int32& solutionVersion, Int32& visualStudioMajorVersion);
    internal void AddSolutionConfiguration(string configurationName, string platformName);
    private string ReadLine();
    internal void ParseSolutionFileForConversion();
    internal void ParseSolutionFile();
    internal void ParseSolution();
    private void ParseFileHeader();
    private static Version ParseVisualStudioVersion(string str);
    private void ValidateSolutionFileVersion(string versionString);
    private void ParseProject(string firstLine);
    internal void ParseEtpProject(ProjectInSolution etpProj);
    private void AddProjectToSolution(ProjectInSolution proj);
    private static bool IsEtpProjectFile(string projectFile);
    private void ValidateProjectRelativePath(ProjectInSolution proj);
    private static void ParseAspNetCompilerProperty(ProjectInSolution proj, string propertyName, string propertyValue);
    private static string TrimQuotes(string property);
    internal void ParseFirstProjectLine(string firstLine, ProjectInSolution proj);
    internal void ParseNestedProjects();
    internal void ParseSolutionConfigurations();
    internal Dictionary`2<string, string> ParseProjectConfigurations();
    internal void ProcessProjectConfigurationSection(Dictionary`2<string, string> rawProjectConfigurationsEntries);
    public string GetDefaultConfigurationName();
    public string GetDefaultPlatformName();
    internal string GetProjectUniqueNameByGuid(string projectGuid);
    internal string GetProjectRelativePathByGuid(string projectGuid);
}
internal class Microsoft.Build.Construction.SolutionProjectGenerator : object {
    internal static string SolutionPathPropertyName;
    private static string WebProjectOverrideFolder;
    private static string SolutionProperties;
    private static string SolutionConfigurationAndPlatformProperties;
    internal static ISet`1<string> _defaultTargetNames;
    private Version _version20;
    private Version _version40;
    private Tuple`2[] _metaprojectGlobalProperties;
    private SolutionFile _solutionFile;
    private IDictionary`2<string, string> _globalProperties;
    private string _toolsVersionOverride;
    private BuildEventContext _projectBuildEventContext;
    private ILoggingService _loggingService;
    private IReadOnlyCollection`1<string> _targetNames;
    private string _selectedSolutionConfiguration;
    private ISdkResolverService _sdkResolverService;
    private int _submissionId;
    private SolutionProjectGenerator(SolutionFile solution, IDictionary`2<string, string> globalProperties, string toolsVersionOverride, BuildEventContext projectBuildEventContext, ILoggingService loggingService, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    private static SolutionProjectGenerator();
    internal static ProjectInstance[] Generate(SolutionFile solution, IDictionary`2<string, string> globalProperties, string toolsVersionOverride, BuildEventContext projectBuildEventContext, ILoggingService loggingService, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement msbuildProject, SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration);
    internal static ProjectTaskElement AddErrorWarningMessageElement(ProjectTargetElement target, string elementType, bool treatAsLiteral, string textResourceName, Object[] args);
    internal static string PredictActiveSolutionConfigurationName(SolutionFile solutionFile, IDictionary`2<string, string> globalProperties);
    private static string GetMetaprojectName(string fullPathToProject);
    private static string DetermineWrapperProjectToolsVersion(string toolsVersionOverride, Boolean& explicitToolsVersionSpecified);
    private static void AddTasksToCopyAllDependenciesIntoBinDir(ProjectTargetInstance target, ProjectInSolution project, string referenceItemName, string conditionDescribingValidConfigurations);
    private static void AddTasksToResolveAutoRefreshFileReferences(ProjectTargetInstance target, ProjectInSolution project, string referenceItemName);
    private static ProjectTaskInstance AddMSBuildTaskInstance(ProjectTargetInstance target, string projectPath, string msbuildTargetName, string configurationName, string platformName, bool specifyProjectToolsVersion);
    private static string GenerateSafePropertyName(ProjectInSolution proj, string propertyName);
    private static string MakeIntoSafeItemName(string name);
    private static ProjectTaskInstance AddErrorWarningMessageInstance(ProjectTargetInstance target, string condition, string elementType, bool treatAsLiteral, string textResourceName, Object[] args);
    private static string GetConditionStringForConfiguration(SolutionConfigurationInSolution configuration);
    private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile solutionFile, IDictionary`2<string, string> globalProperties);
    private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration);
    private ProjectInstance[] Generate();
    private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersion, bool explicitToolsVersionSpecified);
    private void EvaluateAndAddProjects(List`1<ProjectInSolution> projectsInOrder, List`1<ProjectInstance> projectInstances, ProjectInstance traversalInstance, string selectedSolutionConfiguration);
    private void AddStandardTraversalTargets(ProjectInstance traversalInstance, List`1<ProjectInSolution> projectsInOrder);
    private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersion, bool explicitToolsVersionSpecified, List`1<ProjectInSolution> projectsInOrder);
    private void EmitMetaproject(ProjectRootElement metaproject, string path);
    private void AddProjectReference(ProjectInstance traversalProject, ProjectInstance projectInstance, ProjectInSolution projectToAdd, ProjectConfigurationInSolution projectConfiguration, bool direct);
    private static string GetToolsVersionMetadataForDirectMSBuildTask(ProjectInstance traversalProject);
    private static string GetToolsVersionAttributeForDirectMSBuildTask();
    private static string GetPropertiesMetadataForProjectReference(ProjectInstance traversalProject, string configurationAndPlatformProperties);
    private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigurationInSolution projectConfiguration);
    private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration);
    private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolution projectToAdd, ProjectConfigurationInSolution projectConfiguration);
    private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration);
    private string GetMetaprojectName(ProjectInSolution project);
    private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project);
    private static void AddMetaprojectTargetForManagedProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetName, string outputItem);
    private static void AddProjectBuildTask(ProjectInstance traversalProject, ProjectConfigurationInSolution projectConfiguration, ProjectTargetInstance target, string targetToBuild, string sourceItems, string condition, string outputItem);
    private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem);
    private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string targetName);
    private void AddTaskForAspNetCompiler(ProjectTargetInstance target, ProjectInSolution project, string conditionDescribingValidConfigurations);
    private void ValidateTargetFrameworkForWebProject(ProjectInSolution project);
    private void SetToolPathForAspNetCompilerTask(ProjectInSolution project, ProjectTaskInstance task);
    private void AddResolveProjectReferenceTasks(ProjectInstance traversalProject, ProjectTargetInstance target, ProjectInSolution project, SolutionConfigurationInSolution solutionConfiguration, string outputReferenceItemName, String& addedReferenceGuids);
    private static void AddPropertyGroupForAspNetConfiguration(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string configurationName, AspNetCompilerParameters aspNetCompilerParameters, string solutionFile);
    private string ComputeTargetConditionForWebProject(ProjectInSolution project);
    private static void AddTargetForGetFrameworkPathAndRedistList(ProjectInstance metaprojectInstance);
    private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string targetName, string unknownProjectTypeErrorMessage);
    private void AddValidateProjectsTarget(ProjectInstance traversalProject, List`1<ProjectInSolution> projects);
    private static void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem);
    private static void AddReferencesBuildTask(ProjectTargetInstance target, string targetToBuild, string outputItem);
    private void AddTraversalTargetForProject(ProjectInstance traversalProject, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetToBuild, string outputItem, bool canBuildDirectly);
    private IDictionary`2<string, string> GetMetaprojectGlobalProperties(ProjectInstance traversalProject);
    private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersion);
    private string PredictActiveSolutionConfigurationName();
    private void ScanProjectDependencies(string childProjectToolsVersion, string fullSolutionConfigurationName);
    private void AddDependencyByGuid(ProjectInSolution project, string dependencyGuid);
    private void AddConfigurationPlatformDefaults(ProjectRootElement traversalProject);
    private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement traversalProject, SolutionConfigurationInSolution solutionConfiguration);
    private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject);
    private void AddGlobalProperties(ProjectRootElement traversalProject);
    private void AddFakeReleaseSolutionConfigurationIfNecessary();
    private void AddInitialTargets(ProjectInstance traversalProject, List`1<ProjectInSolution> projects);
    private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalProject);
    private static void AddValidateToolsVersionsTarget(ProjectInstance traversalProject);
    private static void AddGetSolutionConfigurationContentsTarget(ProjectInstance traversalProject);
}
public enum Microsoft.Build.Construction.SolutionProjectType : Enum {
    public int value__;
    public static SolutionProjectType Unknown;
    public static SolutionProjectType KnownToBeMSBuildFormat;
    public static SolutionProjectType SolutionFolder;
    public static SolutionProjectType WebProject;
    public static SolutionProjectType WebDeploymentProject;
    public static SolutionProjectType EtpSubProject;
    public static SolutionProjectType SharedProject;
}
[DebuggerDisplayAttribute("#Parameters={Count}")]
public class Microsoft.Build.Construction.UsingTaskParameterGroupElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectUsingTaskParameterElement> Parameters { get; }
    public ElementLocation ConditionLocation { get; }
    internal UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectUsingTaskParameterElement> get_Parameters();
    public virtual ElementLocation get_ConditionLocation();
    public ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType);
    public ProjectUsingTaskParameterElement AddParameter(string name);
    internal static UsingTaskParameterGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static void VerifyCorrectParent(ProjectElementContainer parent);
}
internal class Microsoft.Build.Construction.XmlAttributeWithLocation : XmlAttribute {
    private ElementLocation _elementLocation;
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document);
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document, int lineNumber, int columnNumber);
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
}
internal class Microsoft.Build.Construction.XmlDocumentWithLocation : XmlDocument {
    private static ProjectStringCache s_globalStringCache;
    private static NameTable s_nameTable;
    private static ReadOnlyLoadFlags s_readOnlyFlags;
    private IXmlLineInfo _reader;
    private string _fullPath;
    private ProjectStringCache _stringCache;
    private Nullable`1<bool> _loadAsReadOnly;
    internal string FullPath { get; internal set; }
    internal ProjectStringCache StringCache { get; internal set; }
    public bool IsReadOnly { get; }
    internal XmlDocumentWithLocation(bool loadAsReadOnly);
    private static XmlDocumentWithLocation();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal ProjectStringCache get_StringCache();
    internal void set_StringCache(ProjectStringCache value);
    public virtual void Load(XmlReader reader);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI);
    public virtual XmlWhitespace CreateWhitespace(string text);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlComment CreateComment(string data);
    public virtual void Save(Stream outStream);
    public virtual void Save(TextWriter writer);
    public virtual void Save(XmlWriter writer);
    public virtual bool get_IsReadOnly();
    internal static void ClearReadOnlyFlags_UnitTestsOnly();
    internal void ClearAnyCachedStrings();
    private void DetermineWhetherToLoadReadOnly(string fullPath);
    private void DetermineWhetherToLoadReadOnlyIfPossible();
    private void VerifyThrowNotReadOnly();
}
internal class Microsoft.Build.Construction.XmlElementWithLocation : XmlElement {
    private ElementLocation _elementLocation;
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document);
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document, int lineNumber, int columnNumber);
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
    public XmlAttributeWithLocation GetAttributeWithLocation(string name);
    public virtual XmlNode RemoveChild(XmlNode oldChild);
    internal ElementLocation GetAttributeLocation(string name);
}
internal class Microsoft.Build.Construction.XmlNameTableThreadSafe : NameTable {
    private object _locker;
    public virtual string Add(string key);
    public virtual string Add(Char[] key, int start, int len);
    public virtual string Get(string value);
    public virtual string Get(Char[] key, int start, int len);
}
public class Microsoft.Build.Definition.ProjectOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <GlobalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubToolsetVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCollection <ProjectCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectLoadSettings <LoadSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationContext <EvaluationContext>k__BackingField;
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public string ToolsVersion { get; public set; }
    public string SubToolsetVersion { get; public set; }
    public ProjectCollection ProjectCollection { get; public set; }
    public ProjectLoadSettings LoadSettings { get; public set; }
    public EvaluationContext EvaluationContext { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SubToolsetVersion();
    [CompilerGeneratedAttribute]
public void set_SubToolsetVersion(string value);
    [CompilerGeneratedAttribute]
public ProjectCollection get_ProjectCollection();
    [CompilerGeneratedAttribute]
public void set_ProjectCollection(ProjectCollection value);
    [CompilerGeneratedAttribute]
public ProjectLoadSettings get_LoadSettings();
    [CompilerGeneratedAttribute]
public void set_LoadSettings(ProjectLoadSettings value);
    [CompilerGeneratedAttribute]
public EvaluationContext get_EvaluationContext();
    [CompilerGeneratedAttribute]
public void set_EvaluationContext(EvaluationContext value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.AndExpressionNode : OperatorExpressionNode {
    private bool _possibleAndCollision;
    internal string DebuggerDisplay { get; }
    internal bool PossibleAndCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
}
internal static class Microsoft.Build.Evaluation.BuiltInMetadata : object {
    internal static int MetadataCount { get; }
    internal static ICollection`1<string> MetadataNames { get; }
    [DebuggerStepThroughAttribute]
internal static int get_MetadataCount();
    [DebuggerStepThroughAttribute]
internal static ICollection`1<string> get_MetadataNames();
    internal static string GetMetadataValue(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string definingProjectEscaped, string name, String& fullPath);
    internal static string GetMetadataValueEscaped(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string definingProjectEscaped, string name, String& fullPath);
    private static string GetRecursiveDirValue(string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped);
}
internal static class Microsoft.Build.Evaluation.CharacterUtilities : object {
    internal static bool IsNumberStart(char candidate);
    internal static bool IsSimpleStringStart(char candidate);
    internal static bool IsSimpleStringChar(char candidate);
    internal static bool IsHexAlphabetic(char candidate);
    internal static bool IsHexDigit(char candidate);
}
internal static class Microsoft.Build.Evaluation.ConditionEvaluator : object {
    private static Lazy`1<Regex> s_singlePropertyRegex;
    private static ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedExpressionTrees;
    private static bool s_disableExpressionCaching;
    private static ConditionEvaluator();
    internal static void UpdateConditionedPropertiesTable(Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string leftValue, string rightValueExpanded);
    internal static bool EvaluateCondition(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext, IFileSystem fileSystem, ProjectRootElementCache projectRootElementCache);
    internal static bool EvaluateConditionCollectingConditionedProperties(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext, IFileSystem fileSystem, ProjectRootElementCache projectRootElementCache);
    private static ExpressionTreeForCurrentOptionsWithSize FlushCacheIfLargerThanThreshold(ParserOptions options, ExpressionTreeForCurrentOptionsWithSize cachedExpressionTreesForCurrentOptions);
}
public class Microsoft.Build.Evaluation.Context.EvaluationContext : object {
    [CompilerGeneratedAttribute]
private static Action`1<EvaluationContext> <TestOnlyHookOnCreate>k__BackingField;
    private int _used;
    [CompilerGeneratedAttribute]
private SharingPolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISdkResolverService <SdkResolverService>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private EngineFileUtilities <EngineFileUtilities>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ImmutableArray`1<string>> <FileEntryExpansionCache>k__BackingField;
    internal static Action`1<EvaluationContext> TestOnlyHookOnCreate { get; internal set; }
    internal SharingPolicy Policy { get; }
    internal ISdkResolverService SdkResolverService { get; }
    internal IFileSystem FileSystem { get; }
    internal EngineFileUtilities EngineFileUtilities { get; }
    internal ConcurrentDictionary`2<string, ImmutableArray`1<string>> FileEntryExpansionCache { get; }
    internal EvaluationContext(SharingPolicy policy);
    [CompilerGeneratedAttribute]
internal static Action`1<EvaluationContext> get_TestOnlyHookOnCreate();
    [CompilerGeneratedAttribute]
internal static void set_TestOnlyHookOnCreate(Action`1<EvaluationContext> value);
    [CompilerGeneratedAttribute]
internal SharingPolicy get_Policy();
    [CompilerGeneratedAttribute]
internal ISdkResolverService get_SdkResolverService();
    [CompilerGeneratedAttribute]
internal IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
internal EngineFileUtilities get_EngineFileUtilities();
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, ImmutableArray`1<string>> get_FileEntryExpansionCache();
    public static EvaluationContext Create(SharingPolicy policy);
    private EvaluationContext CreateUsedIsolatedContext();
    internal EvaluationContext ContextForNewProject();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.EqualExpressionNode : MultipleComparisonNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
    internal virtual string get_DebuggerDisplay();
}
internal class Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter : EvaluationLocationPrettyPrinterBase {
    private static string Separator;
    internal virtual void AppendHeader(StringBuilder stringBuilder);
    internal virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
}
internal abstract class Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase : object {
    internal abstract virtual void AppendHeader(StringBuilder stringBuilder);
    internal abstract virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected abstract virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
    protected static double GetMilliseconds(TimeSpan timeSpan);
    protected static double GetPercentage(TimeSpan total, TimeSpan time);
    protected static string GetElementOrConditionText(string description, EvaluationLocationKind kind);
    protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator);
    protected void AppendDefaultLocationWithSeparator(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation, string separator);
}
internal class Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter : EvaluationLocationPrettyPrinterBase {
    private static string Separator;
    internal virtual void AppendHeader(StringBuilder stringBuilder);
    internal virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
}
internal class Microsoft.Build.Evaluation.EvaluationProfiler : object {
    private bool _shouldTrackElements;
    private Stack`1<EvaluationFrame> _evaluationStack;
    private Dictionary`2<EvaluationLocation, ProfiledLocation> _timeSpent;
    private EvaluationLocation CurrentLocation { get; }
    public Nullable`1<ProfilerResult> ProfiledResult { get; }
    internal EvaluationProfiler(bool shouldTrackElements);
    private EvaluationLocation get_CurrentLocation();
    public Nullable`1<ProfilerResult> get_ProfiledResult();
    public IDisposable TrackPass(EvaluationPass evaluationPass, string passDescription);
    public IDisposable TrackFile(string file);
    public IDisposable TrackGlob(string rootDirectory, string glob, ISet`1<string> excludePatterns);
    public IDisposable TrackElement(ProjectElement element);
    public IDisposable TrackCondition(IElementLocation location, string condition);
    internal bool IsEmpty();
}
internal class Microsoft.Build.Evaluation.Evaluator`4 : object {
    private static Char[] s_splitter;
    private static String[] s_localsTypesNames;
    private Expander`2<P, I> _expander;
    private IEvaluatorData`4<P, I, M, D> _data;
    private List`1<ProjectItemGroupElement> _itemGroupElements;
    private List`1<ProjectItemDefinitionGroupElement> _itemDefinitionGroupElements;
    private List`1<Pair`2<string, ProjectUsingTaskElement>> _usingTaskElements;
    private List`1<ProjectTargetElement> _targetElements;
    private Dictionary`2<string, ProjectImportElement> _importsSeen;
    private List`1<string> _initialTargetsList;
    private Dictionary`2<ProjectRootElement, NGen`1<bool>> _projectSupportsReturnsAttribute;
    private ProjectRootElement _projectRootElement;
    private IItemFactory`2<I, I> _itemFactory;
    private ProjectLoadSettings _loadSettings;
    private int _maxNodeCount;
    private ISdkResolverService _sdkResolverService;
    private int _submissionId;
    private EvaluationContext _evaluationContext;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private ProjectRootElementCache _projectRootElementCache;
    private EvaluationLoggingContext _evaluationLoggingContext;
    private bool _logProjectImportedEvents;
    private static IOCache _fallbackSearchPathsCache;
    private EvaluationProfiler _evaluationProfiler;
    private Evaluator`4(IEvaluatorData`4<P, I, M, D> data, ProjectRootElement projectRootElement, ProjectLoadSettings loadSettings, int maxNodeCount, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, IItemFactory`2<I, I> itemFactory, IToolsetProvider toolsetProvider, ProjectRootElementCache projectRootElementCache, ISdkResolverService sdkResolverService, int submissionId, EvaluationContext evaluationContext, bool profileEvaluation);
    private static Evaluator`4();
    internal static void Evaluate(IEvaluatorData`4<P, I, M, D> data, ProjectRootElement root, ProjectLoadSettings loadSettings, int maxNodeCount, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, ILoggingService loggingService, IItemFactory`2<I, I> itemFactory, IToolsetProvider toolsetProvider, ProjectRootElementCache projectRootElementCache, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, EvaluationContext evaluationContext);
    internal static List`1<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory`2<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander`2<P, I> expander);
    private static ProjectTaskInstance ReadTaskElement(ProjectTaskElement taskElement);
    private static ProjectPropertyGroupTaskInstance ReadPropertyGroupUnderTargetElement(ProjectPropertyGroupElement propertyGroupElement);
    private static ProjectOnErrorInstance ReadOnErrorElement(ProjectOnErrorElement projectOnErrorElement);
    private static ProjectItemGroupTaskInstance ReadItemGroupUnderTargetElement(ProjectItemGroupElement itemGroupElement);
    private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement targetElement, bool parentProjectSupportsReturnsAttribute, EvaluationProfiler evaluationProfiler);
    private void Evaluate(ILoggingService loggingService, BuildEventContext buildEventContext);
    private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport);
    private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport);
    private void EvaluatePropertyGroupElement(ProjectPropertyGroupElement propertyGroupElement);
    private void EvaluateItemDefinitionGroupElement(ProjectItemDefinitionGroupElement itemDefinitionGroupElement);
    private void EvaluateItemGroupElement(ProjectItemGroupElement itemGroupElement, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUsingTaskElement projectUsingTaskElement);
    private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList`1<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary`2<string, LinkedListNode`1<ProjectTargetElement>> activeTargets);
    private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary`2<string, LinkedListNode`1<ProjectTargetElement>> activeTargets, Dictionary`2<string, List`1<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary`2<string, List`1<TargetSpecification>> targetsWhichRunAfterByTarget);
    private ICollection`1<P> AddBuiltInProperties();
    private ICollection`1<P> AddEnvironmentProperties();
    private ICollection`1<P> AddToolsetProperties();
    private ICollection`1<P> AddGlobalProperties();
    private P SetBuiltInProperty(string name, string evaluatedValueEscaped);
    private void EvaluatePropertyElement(ProjectPropertyElement propertyElement);
    private void LogPropertyReassignment(P predecessor, P property, string location);
    private void EvaluateItemElement(bool itemGroupConditionResult, ProjectItemElement itemElement, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void EvaluateItemElementUpdate(ProjectItemElement itemElement);
    private void EvaluateItemElementInclude(bool itemGroupConditionResult, bool itemConditionResult, ProjectItemElement itemElement);
    private void DecorateItemsWithMetadataFromProjectItemElement(ProjectItemElement itemElement, IList`1<I> items);
    private void EvaluateItemDefinitionElement(ProjectItemDefinitionElement itemDefinitionElement);
    private void EvaluateImportElement(string directoryOfImportingFile, ProjectImportElement importElement);
    private void EvaluateImportGroupElement(string directoryOfImportingFile, ProjectImportGroupElement importGroupElement);
    private void EvaluateChooseElement(ProjectChooseElement chooseElement);
    private bool EvaluateWhenOrOtherwiseChildren(IEnumerable`1<ProjectElement> children);
    private List`1<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportingFile, ProjectImportElement importElement, SdkResult& sdkResult);
    private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(string directoryOfImportingFile, ProjectImportElement importElement, List`1& projects, SdkResult& sdkResult, bool throwOnFileNotExistsError);
    private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression, bool throwOnFileNotExistsError, List`1& imports);
    private bool IntroducesCircularity(string importFileUnescaped, ProjectImportElement importElement);
    private bool EvaluateCondition(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private bool EvaluateCondition(ProjectElement element, string condition, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private bool EvaluateConditionCollectingConditionedProperties(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions, ProjectRootElementCache projectRootElementCache);
    private bool EvaluateConditionCollectingConditionedProperties(ProjectElement element, string condition, ExpanderOptions expanderOptions, ParserOptions parserOptions, ProjectRootElementCache projectRootElementCache);
    private string GetCurrentDirectoryForConditionEvaluation(ProjectElement element);
    private void RecordEvaluatedItemElement(ProjectItemElement itemElement);
    private void ThrowForImportedProjectWithSearchPathsNotFound(ProjectImportPathMatch searchPathMatch, ProjectImportElement importElement);
    private static string StringifyList(IList`1<string> strings);
    [CompilerGeneratedAttribute]
private string <ThrowForImportedProjectWithSearchPathsNotFound>b__70_0(string s);
}
internal class Microsoft.Build.Evaluation.EvaluatorMetadataTable : object {
    private Dictionary`2<string, EvaluatorMetadata> _metadata;
    private string _implicitItemType;
    internal IEnumerable`1<EvaluatorMetadata> Entries { get; }
    public EvaluatorMetadataTable(string implicitItemType);
    internal IEnumerable`1<EvaluatorMetadata> get_Entries();
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
    internal void SetValue(ProjectMetadataElement xml, string evaluatedValueEscaped);
}
internal class Microsoft.Build.Evaluation.Expander`2 : object {
    private static Char[] s_singleQuoteChar;
    private static Char[] s_backtickChar;
    private static Char[] s_doubleQuoteChar;
    private static Char[] s_expandableChars;
    private static CompareInfo s_invariantCompareInfo;
    private IPropertyProvider`1<P> _properties;
    private IItemProvider`1<I> _items;
    private IMetadataTable _metadata;
    private UsedUninitializedProperties _usedUninitializedProperties;
    internal bool WarnForUninitializedProperties { get; internal set; }
    internal IMetadataTable Metadata { get; internal set; }
    internal UsedUninitializedProperties UsedUninitializedProperties { get; internal set; }
    internal Expander`2(IPropertyProvider`1<P> properties);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items, IMetadataTable metadata);
    private static Expander`2();
    internal bool get_WarnForUninitializedProperties();
    internal void set_WarnForUninitializedProperties(bool value);
    internal IMetadataTable get_Metadata();
    internal void set_Metadata(IMetadataTable value);
    internal UsedUninitializedProperties get_UsedUninitializedProperties();
    internal void set_UsedUninitializedProperties(UsedUninitializedProperties value);
    internal static bool ExpressionMayContainExpandableExpressions(string expression);
    internal static bool ExpressionContainsItemVector(string expression);
    internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandIntoItemsLeaveEscaped(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandSingleItemVectorExpressionIntoItems(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, Boolean& isTransformExpression, IElementLocation elementLocation);
    internal static ItemExpressionCapture ExpandSingleItemVectorExpressionIntoExpressionCapture(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandExpressionCaptureIntoItems(ItemExpressionCapture expressionCapture, IItemProvider`1<S> items, IItemFactory`2<S, T> itemFactory, ExpanderOptions options, bool includeNullEntries, Boolean& isTransformExpression, IElementLocation elementLocation);
    internal bool ExpandExpressionCapture(ItemExpressionCapture expressionCapture, IElementLocation elementLocation, ExpanderOptions options, bool includeNullEntries, Boolean& isTransformExpression, List`1& itemsFromCapture);
    private static bool IsValidPropertyName(string propertyName);
    private static int ScanForClosingParenthesis(string expression, int index);
    private static int ScanForClosingParenthesis(string expression, int index, Boolean& potentialPropertyFunction, Boolean& potentialRegistryFunction);
    private static int ScanForClosingQuote(char quoteChar, string expression, int index);
    private static void AddArgument(List`1<string> arguments, ReuseableStringBuilder argumentBuilder);
    private static String[] ExtractFunctionArguments(IElementLocation elementLocation, string expressionFunction, string argumentsString);
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ExpanderOptions : Enum {
    public int value__;
    public static ExpanderOptions Invalid;
    public static ExpanderOptions ExpandCustomMetadata;
    public static ExpanderOptions ExpandBuiltInMetadata;
    public static ExpanderOptions ExpandMetadata;
    public static ExpanderOptions ExpandProperties;
    public static ExpanderOptions ExpandItems;
    public static ExpanderOptions BreakOnNotEmpty;
    public static ExpanderOptions LeavePropertiesUnexpandedOnError;
    public static ExpanderOptions ExpandPropertiesAndItems;
    public static ExpanderOptions ExpandPropertiesAndMetadata;
    public static ExpanderOptions ExpandPropertiesAndCustomMetadata;
    public static ExpanderOptions ExpandAll;
}
internal static class Microsoft.Build.Evaluation.ExpressionShredder : object {
    internal static SemiColonTokenizer SplitSemiColonSeparatedList(string expression);
    internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(List`1<string> expressions);
    internal static bool ContainsMetadataExpressionOutsideTransform(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression, int start, int end);
    private static void GetReferencedItemNamesAndMetadata(string expression, int start, int end, ItemsAndMetadataPair& pair, ShredderOptions whatToShredFor);
    private static bool SinkSingleQuotedExpression(string expression, Int32& i, int end);
    private static bool SinkArgumentsInParentheses(string expression, Int32& i, int end);
    private static bool SinkUntilClosingQuote(char quoteChar, string expression, Int32& i, int end);
    private static ItemExpressionCapture SinkItemFunctionExpression(string expression, int startTransform, Int32& i, int end);
    private static bool SinkValidName(string expression, Int32& i, int end);
    private static bool Sink(string expression, Int32& i, char c);
    private static bool Sink(string expression, Int32& i, int end, char c1, char c2);
    private static void SinkWhitespace(string expression, Int32& i);
}
internal class Microsoft.Build.Evaluation.FunctionCallExpressionNode : OperatorExpressionNode {
    private List`1<GenericExpressionNode> _arguments;
    private string _functionName;
    internal FunctionCallExpressionNode(string functionName, List`1<GenericExpressionNode> arguments);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    private static string ExpandArgumentForScalarParameter(string function, GenericExpressionNode argumentNode, IConditionEvaluationState state, bool isFilePath);
    private List`1<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode, IConditionEvaluationState state, bool isFilePath);
    private void VerifyArgumentCount(int expected, IConditionEvaluationState state);
}
internal abstract class Microsoft.Build.Evaluation.GenericExpressionNode : object {
    [CompilerGeneratedAttribute]
private string <DebuggerDisplay>k__BackingField;
    internal string DebuggerDisplay { get; }
    internal bool PossibleAndCollision { get; internal set; }
    internal bool PossibleOrCollision { get; internal set; }
    internal abstract virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal abstract virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal abstract virtual bool CanVersionEvaluate(IConditionEvaluationState state);
    internal abstract virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal abstract virtual double NumericEvaluate(IConditionEvaluationState state);
    internal abstract virtual Version VersionEvaluate(IConditionEvaluationState state);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state);
    internal abstract virtual string GetExpandedValue(IConditionEvaluationState state);
    internal abstract virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal abstract virtual void ResetState();
    internal bool Evaluate(IConditionEvaluationState state);
    [CompilerGeneratedAttribute]
internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
    internal bool PotentialAndOrConflict();
    internal abstract virtual bool DetectOr();
    internal abstract virtual bool DetectAnd();
}
internal class Microsoft.Build.Evaluation.GlobFragment : ItemFragment {
    public GlobFragment(string itemSpecFragment, string projectDirectory);
}
public class Microsoft.Build.Evaluation.GlobResult : object {
    [CompilerGeneratedAttribute]
private ProjectItemElement <ItemElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IncludeGlobs>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildGlob <MsBuildGlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Excludes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Removes>k__BackingField;
    public ProjectItemElement ItemElement { get; }
    public IEnumerable`1<string> IncludeGlobs { get; }
    public IMSBuildGlob MsBuildGlob { get; public set; }
    public IEnumerable`1<string> Excludes { get; }
    public IEnumerable`1<string> Removes { get; public set; }
    public GlobResult(ProjectItemElement itemElement, IEnumerable`1<string> includeGlobStrings, IMSBuildGlob globWithGaps, IEnumerable`1<string> excludeFragmentStrings, IEnumerable`1<string> removeFragmentStrings);
    [CompilerGeneratedAttribute]
public ProjectItemElement get_ItemElement();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_IncludeGlobs();
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_MsBuildGlob();
    [CompilerGeneratedAttribute]
public void set_MsBuildGlob(IMSBuildGlob value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Excludes();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Removes();
    [CompilerGeneratedAttribute]
public void set_Removes(IEnumerable`1<string> value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.GreaterThanExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
internal interface Microsoft.Build.Evaluation.IEvaluatorData`4 {
    public int EvaluationId { get; public set; }
    public string Directory { get; }
    public TaskRegistry TaskRegistry { get; public set; }
    public Toolset Toolset { get; }
    public string SubToolsetVersion { get; }
    public string ExplicitToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    public List`1<string> InitialTargets { get; public set; }
    public List`1<string> DefaultTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> BeforeTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> AfterTargets { get; public set; }
    public Dictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public bool ShouldEvaluateForDesignTime { get; }
    public bool CanEvaluateElementsWithFalseConditions { get; }
    public PropertyDictionary`1<P> Properties { get; }
    public IEnumerable`1<D> ItemDefinitionsEnumerable { get; }
    public ItemDictionary`1<I> Items { get; }
    public List`1<ProjectItemElement> EvaluatedItemElements { get; }
    public abstract virtual int get_EvaluationId();
    public abstract virtual void set_EvaluationId(int value);
    public abstract virtual string get_Directory();
    public abstract virtual TaskRegistry get_TaskRegistry();
    public abstract virtual void set_TaskRegistry(TaskRegistry value);
    public abstract virtual Toolset get_Toolset();
    public abstract virtual string get_SubToolsetVersion();
    public abstract virtual string get_ExplicitToolsVersion();
    public abstract virtual PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    public abstract virtual ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    public abstract virtual List`1<string> get_InitialTargets();
    public abstract virtual void set_InitialTargets(List`1<string> value);
    public abstract virtual List`1<string> get_DefaultTargets();
    public abstract virtual void set_DefaultTargets(List`1<string> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_BeforeTargets();
    public abstract virtual void set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_AfterTargets();
    public abstract virtual void set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual Dictionary`2<string, List`1<string>> get_ConditionedProperties();
    public abstract virtual bool get_ShouldEvaluateForDesignTime();
    public abstract virtual bool get_CanEvaluateElementsWithFalseConditions();
    public abstract virtual PropertyDictionary`1<P> get_Properties();
    public abstract virtual IEnumerable`1<D> get_ItemDefinitionsEnumerable();
    public abstract virtual ItemDictionary`1<I> get_Items();
    public abstract virtual List`1<ProjectItemElement> get_EvaluatedItemElements();
    public abstract virtual void InitializeForEvaluation(IToolsetProvider toolsetProvider);
    public abstract virtual void FinishEvaluation();
    public abstract virtual void AddItem(I item);
    public abstract virtual void AddItemIgnoringCondition(I item);
    public abstract virtual IItemDefinition`1<M> AddItemDefinition(string itemType);
    public abstract virtual void AddToAllEvaluatedPropertiesList(P property);
    public abstract virtual void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
    public abstract virtual void AddToAllEvaluatedItemsList(I item);
    public abstract virtual IItemDefinition`1<M> GetItemDefinition(string itemType);
    public abstract virtual P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    public abstract virtual P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, P predecessor);
    public abstract virtual ProjectTargetInstance GetTarget(string targetName);
    public abstract virtual void AddTarget(ProjectTargetInstance target);
    public abstract virtual void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult);
    public abstract virtual void RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    public abstract virtual string ExpandString(string unexpandedValue);
    public abstract virtual bool EvaluateCondition(string condition);
}
internal interface Microsoft.Build.Evaluation.IItem {
    public string EvaluatedInclude { get; }
    public string EvaluatedIncludeEscaped { get; }
    public string ProjectDirectory { get; }
    public abstract virtual string get_EvaluatedInclude();
    public abstract virtual string get_EvaluatedIncludeEscaped();
    public abstract virtual string get_ProjectDirectory();
    public abstract virtual string GetMetadataValue(string name);
    public abstract virtual string GetMetadataValueEscaped(string name);
}
internal interface Microsoft.Build.Evaluation.IItem`1 {
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue);
}
internal interface Microsoft.Build.Evaluation.IItemDefinition`1 {
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, M predecessor);
}
internal interface Microsoft.Build.Evaluation.IItemFactory`2 {
    public string ItemType { get; public set; }
    unknown ProjectItemElement ItemElement {public set; }
    public abstract virtual string get_ItemType();
    public abstract virtual void set_ItemType(string value);
    public abstract virtual void set_ItemElement(ProjectItemElement value);
    public abstract virtual T CreateItem(string include, string definingProject);
    public abstract virtual T CreateItem(S source, string definingProject);
    public abstract virtual T CreateItem(string include, S baseItem, string definingProject);
    public abstract virtual T CreateItem(string include, string includeBeforeWildcardExpansion, string definingProject);
    public abstract virtual void SetMetadata(IEnumerable`1<Pair`2<ProjectMetadataElement, string>> metadata, IEnumerable`1<T> destinationItems);
}
internal interface Microsoft.Build.Evaluation.IItemProvider`1 {
    public abstract virtual ICollection`1<T> GetItems(string itemType);
}
internal interface Microsoft.Build.Evaluation.IMetadataTable {
    public abstract virtual string GetEscapedValue(string name);
    public abstract virtual string GetEscapedValue(string itemType, string name);
    public abstract virtual string GetEscapedValueIfPresent(string itemType, string name);
}
internal interface Microsoft.Build.Evaluation.IMetadatum {
}
internal static class Microsoft.Build.Evaluation.IntrinsicFunctions : object {
    private static Lazy`1<string> _validOsPlatforms;
    private static IntrinsicFunctions();
    internal static double Add(double a, double b);
    internal static long Add(long a, long b);
    internal static double Subtract(double a, double b);
    internal static long Subtract(long a, long b);
    internal static double Multiply(double a, double b);
    internal static long Multiply(long a, long b);
    internal static double Divide(double a, double b);
    internal static long Divide(long a, long b);
    internal static double Modulo(double a, double b);
    internal static long Modulo(long a, long b);
    internal static string Escape(string unescaped);
    internal static string Unescape(string escaped);
    internal static int BitwiseOr(int first, int second);
    internal static int BitwiseAnd(int first, int second);
    internal static int BitwiseXor(int first, int second);
    internal static int BitwiseNot(int first);
    internal static object GetRegistryValue(string keyName, string valueName);
    internal static object GetRegistryValue(string keyName, string valueName, object defaultValue);
    internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, Object[] views);
    internal static string MakeRelative(string basePath, string path);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName);
    internal static string GetPathOfFileAbove(string file, string startingDirectory);
    internal static string ValueOrDefault(string conditionValue, string defaultValue);
    internal static bool DoesTaskHostExist(string runtime, string architecture);
    internal static string EnsureTrailingSlash(string path);
    internal static string NormalizeDirectory(String[] path);
    internal static string NormalizePath(String[] path);
    internal static bool IsOSPlatform(string platformString);
    internal static bool IsOsUnixLike();
    internal static bool IsOsBsdLike();
    public static string GetCurrentToolsDirectory();
    public static string GetToolsDirectory32();
    public static string GetToolsDirectory64();
    public static string GetMSBuildSDKsPath();
    public static string GetVsInstallRoot();
    public static string GetProgramFiles32();
    public static string GetMSBuildExtensionsPath();
    public static bool IsRunningFromVisualStudio();
    internal static List`1<string> __GetListTest();
}
internal interface Microsoft.Build.Evaluation.IProjectMetadataParent {
    public Project Project { get; }
    public string ItemType { get; }
    public abstract virtual Project get_Project();
    public abstract virtual string get_ItemType();
}
internal interface Microsoft.Build.Evaluation.IProperty {
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string EvaluatedValueEscaped { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_EvaluatedValue();
    public abstract virtual string get_EvaluatedValueEscaped();
}
internal interface Microsoft.Build.Evaluation.IPropertyProvider`1 {
    public abstract virtual T GetProperty(string name);
    public abstract virtual T GetProperty(string name, int startIndex, int endIndex);
}
internal class Microsoft.Build.Evaluation.ItemExpressionFragment`2 : ItemFragment {
    [CompilerGeneratedAttribute]
private ItemExpressionCapture <Capture>k__BackingField;
    private ItemSpec`2<P, I> _containingItemSpec;
    private Expander`2<P, I> _expander;
    private IList`1<ValueFragment> _referencedItems;
    private IMSBuildGlob _msbuildGlob;
    public ItemExpressionCapture Capture { get; }
    public IList`1<ValueFragment> ReferencedItems { get; }
    protected IMSBuildGlob MsBuildGlob { get; }
    public ItemExpressionFragment`2(ItemExpressionCapture capture, string itemSpecFragment, ItemSpec`2<P, I> containingItemSpec, string projectDirectory);
    [CompilerGeneratedAttribute]
public ItemExpressionCapture get_Capture();
    public IList`1<ValueFragment> get_ReferencedItems();
    protected virtual IMSBuildGlob get_MsBuildGlob();
    public virtual int MatchCount(string itemToMatch);
    public virtual IMSBuildGlob ToMSBuildGlob();
    protected virtual IMSBuildGlob CreateMsBuildGlob();
    private bool InitReferencedItemsIfNecessary();
    [CompilerGeneratedAttribute]
private ValueFragment <InitReferencedItemsIfNecessary>b__15_0(Pair`2<string, I> i);
}
internal abstract class Microsoft.Build.Evaluation.ItemFragment : object {
    [CompilerGeneratedAttribute]
private string <ItemSpecFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    private bool _fileMatcherInitialized;
    private FileSpecMatcherTester _fileMatcher;
    private IMSBuildGlob _msbuildGlob;
    public string ItemSpecFragment { get; }
    protected string ProjectDirectory { get; }
    private FileSpecMatcherTester FileMatcher { get; }
    protected IMSBuildGlob MsBuildGlob { get; }
    protected ItemFragment(string itemSpecFragment, string projectDirectory);
    [CompilerGeneratedAttribute]
public string get_ItemSpecFragment();
    [CompilerGeneratedAttribute]
protected string get_ProjectDirectory();
    private FileSpecMatcherTester get_FileMatcher();
    protected virtual IMSBuildGlob get_MsBuildGlob();
    public virtual int MatchCount(string itemToMatch);
    public virtual IMSBuildGlob ToMSBuildGlob();
    protected virtual IMSBuildGlob CreateMsBuildGlob();
    private FileSpecMatcherTester CreateFileSpecMatcher();
}
internal class Microsoft.Build.Evaluation.ItemsAndMetadataPair : ValueType {
    private HashSet`1<string> _items;
    private Dictionary`2<string, MetadataReference> _metadata;
    internal HashSet`1<string> Items { get; internal set; }
    internal Dictionary`2<string, MetadataReference> Metadata { get; internal set; }
    internal ItemsAndMetadataPair(HashSet`1<string> items, Dictionary`2<string, MetadataReference> metadata);
    internal HashSet`1<string> get_Items();
    internal void set_Items(HashSet`1<string> value);
    internal Dictionary`2<string, MetadataReference> get_Metadata();
    internal void set_Metadata(Dictionary`2<string, MetadataReference> value);
}
internal class Microsoft.Build.Evaluation.ItemSpec`2 : object {
    [CompilerGeneratedAttribute]
private string <ItemSpecString>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ItemFragment> <Fragments>k__BackingField;
    [CompilerGeneratedAttribute]
private Expander`2<P, I> <Expander>k__BackingField;
    [CompilerGeneratedAttribute]
private IElementLocation <ItemSpecLocation>k__BackingField;
    public string ItemSpecString { get; }
    public List`1<ItemFragment> Fragments { get; }
    public Expander`2<P, I> Expander { get; public set; }
    public IElementLocation ItemSpecLocation { get; }
    public ItemSpec`2(string itemSpec, Expander`2<P, I> expander, IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties);
    [CompilerGeneratedAttribute]
public string get_ItemSpecString();
    [CompilerGeneratedAttribute]
public List`1<ItemFragment> get_Fragments();
    [CompilerGeneratedAttribute]
public Expander`2<P, I> get_Expander();
    [CompilerGeneratedAttribute]
public void set_Expander(Expander`2<P, I> value);
    [CompilerGeneratedAttribute]
public IElementLocation get_ItemSpecLocation();
    private List`1<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties);
    private ItemExpressionFragment`2<P, I> ProcessItemExpression(string expression, IElementLocation elementLocation, string projectDirectory, Boolean& isItemListExpression);
    public bool MatchesItem(I item);
    public IEnumerable`1<ItemFragment> FragmentsMatchingItem(string itemToMatch, Int32& matches);
    public IMSBuildGlob ToMSBuildGlob();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ItemSpec`2/<FlattenFragmentsAsStrings>d__19")]
public IEnumerable`1<string> FlattenFragmentsAsStrings();
    public virtual string ToString();
}
internal interface Microsoft.Build.Evaluation.IToolsetProvider {
    public ICollection`1<Toolset> Toolsets { get; }
    public abstract virtual ICollection`1<Toolset> get_Toolsets();
    public abstract virtual Toolset GetToolset(string toolsVersion);
}
internal class Microsoft.Build.Evaluation.LazyItemEvaluator`4 : object {
    private IEvaluatorData`4<P, I, M, D> _outerEvaluatorData;
    private Expander`2<P, I> _outerExpander;
    private IEvaluatorData`4<P, I, M, D> _evaluatorData;
    private Expander`2<P, I> _expander;
    private IItemFactory`2<I, I> _itemFactory;
    private LoggingContext _loggingContext;
    private EvaluationProfiler _evaluationProfiler;
    private int _nextElementOrder;
    private static CompareInfo s_invariantCompareInfo;
    private Dictionary`2<string, LazyItemList<P, I, M, D>> _itemLists;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private EngineFileUtilities <EngineFileUtilities>k__BackingField;
    protected IFileSystem FileSystem { get; }
    protected EngineFileUtilities EngineFileUtilities { get; }
    public LazyItemEvaluator`4(IEvaluatorData`4<P, I, M, D> data, IItemFactory`2<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext);
    private static LazyItemEvaluator`4();
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
protected EngineFileUtilities get_EngineFileUtilities();
    private ImmutableList`1<I> GetItems(string itemType);
    public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private static bool EvaluateCondition(string condition, ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions, Expander`2<P, I> expander, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private static bool EvaluateCondition(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions, Expander`2<P, I> expander, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private static string GetCurrentDirectoryForConditionEvaluation(ProjectElement element, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void AddReferencedItemList(string itemType, IDictionary`2<string, LazyItemList<P, I, M, D>> referencedItemLists);
    private LazyItemList<P, I, M, D> GetItemList(string itemType);
    public IEnumerable`1<ItemData<P, I, M, D>> GetAllItemsDeferred();
    public void ProcessItemElement(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private UpdateOperation<P, I, M, D> BuildUpdateOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private IncludeOperation<P, I, M, D> BuildIncludeOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private RemoveOperation<P, I, M, D> BuildRemoveOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder<P, I, M, D> builder);
    private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBuilderWithMetadata<P, I, M, D> operationBuilder);
    private void AddItemReferences(string expression, IncludeOperationBuilder<P, I, M, D> operationBuilder, IElementLocation elementLocation);
    private void AddReferencedItemLists(OperationBuilder<P, I, M, D> operationBuilder, ItemExpressionCapture match);
    [CompilerGeneratedAttribute]
private ICollection`1<I> <.ctor>b__16_0(string itemType);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.LessThanExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
internal enum Microsoft.Build.Evaluation.LoadImportsResult : Enum {
    public int value__;
    public static LoadImportsResult ProjectsImported;
    public static LoadImportsResult FoundFilesToImportButIgnored;
    public static LoadImportsResult TriedToImportButFileNotFound;
    public static LoadImportsResult ImportExpressionResolvedToNothing;
    public static LoadImportsResult ConditionWasFalse;
}
internal class Microsoft.Build.Evaluation.LoadXmlFromPath : MulticastDelegate {
    public LoadXmlFromPath(object object, IntPtr method);
    public virtual XmlDocumentWithLocation Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual XmlDocumentWithLocation EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Evaluation.MetadataReference : ValueType {
    internal string ItemName;
    internal string MetadataName;
    internal MetadataReference(string itemName, string metadataName);
}
internal class Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind : ValueType {
    public static MSBuildExtensionsPathReferenceKind Default;
    public static MSBuildExtensionsPathReferenceKind Path32;
    public static MSBuildExtensionsPathReferenceKind Path64;
    public static MSBuildExtensionsPathReferenceKind None;
    [CompilerGeneratedAttribute]
private string <StringRepresentation>k__BackingField;
    public string StringRepresentation { get; private set; }
    public string MSBuildPropertyName { get; }
    private MSBuildExtensionsPathReferenceKind(string value);
    private static MSBuildExtensionsPathReferenceKind();
    [CompilerGeneratedAttribute]
public string get_StringRepresentation();
    [CompilerGeneratedAttribute]
private void set_StringRepresentation(string value);
    public string get_MSBuildPropertyName();
    public static MSBuildExtensionsPathReferenceKind FindIn(string expression);
}
internal abstract class Microsoft.Build.Evaluation.MultipleComparisonNode : OperatorExpressionNode {
    private bool _conditionedPropertiesUpdated;
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(bool left, bool right);
    protected abstract virtual bool Compare(string left, string right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual void ResetState();
    private void UpdateConditionedProperties(IConditionEvaluationState state);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.NewProjectFileOptions : Enum {
    public int value__;
    public static NewProjectFileOptions None;
    public static NewProjectFileOptions IncludeXmlDeclaration;
    public static NewProjectFileOptions IncludeToolsVersion;
    public static NewProjectFileOptions IncludeXmlNamespace;
    public static NewProjectFileOptions IncludeAllOptions;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NotEqualExpressionNode : MultipleComparisonNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NotExpressionNode : OperatorExpressionNode {
    internal string DebuggerDisplay { get; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual string get_DebuggerDisplay();
}
internal abstract class Microsoft.Build.Evaluation.NumericComparisonExpressionNode : OperatorExpressionNode {
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(Version left, Version right);
    protected abstract virtual bool Compare(Version left, double right);
    protected abstract virtual bool Compare(double left, Version right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NumericExpressionNode : OperandExpressionNode {
    private string _value;
    internal string DebuggerDisplay { get; }
    internal NumericExpressionNode(string value);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual Version VersionEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanVersionEvaluate(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
    internal virtual string get_DebuggerDisplay();
}
internal abstract class Microsoft.Build.Evaluation.OperandExpressionNode : GenericExpressionNode {
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
public enum Microsoft.Build.Evaluation.Operation : Enum {
    public int value__;
    public static Operation Include;
    public static Operation Exclude;
    public static Operation Update;
    public static Operation Remove;
}
internal abstract class Microsoft.Build.Evaluation.OperatorExpressionNode : GenericExpressionNode {
    [CompilerGeneratedAttribute]
private GenericExpressionNode <LeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericExpressionNode <RightChild>k__BackingField;
    internal GenericExpressionNode LeftChild { get; internal set; }
    internal GenericExpressionNode RightChild { get; internal set; }
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual Version VersionEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanVersionEvaluate(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
    [CompilerGeneratedAttribute]
internal void set_LeftChild(GenericExpressionNode value);
    [CompilerGeneratedAttribute]
internal GenericExpressionNode get_LeftChild();
    [CompilerGeneratedAttribute]
internal void set_RightChild(GenericExpressionNode value);
    [CompilerGeneratedAttribute]
internal GenericExpressionNode get_RightChild();
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.OrExpressionNode : OperatorExpressionNode {
    private bool _possibleOrCollision;
    internal string DebuggerDisplay { get; }
    internal bool PossibleOrCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
}
internal class Microsoft.Build.Evaluation.Parser : object {
    private Scanner _lexer;
    private ParserOptions _options;
    private ElementLocation _elementLocation;
    internal int errorPosition;
    private bool _warnedForExpression;
    private BuildEventContext _logBuildEventContext;
    private ILoggingService _loggingServices;
    internal BuildEventContext LogBuildEventContext { get; internal set; }
    internal ILoggingService LoggingServices { get; internal set; }
    internal BuildEventContext get_LogBuildEventContext();
    internal void set_LogBuildEventContext(BuildEventContext value);
    internal void set_LoggingServices(ILoggingService value);
    internal ILoggingService get_LoggingServices();
    internal GenericExpressionNode Parse(string expression, ParserOptions optionSettings, ElementLocation elementLocation);
    private GenericExpressionNode Expr(string expression);
    private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode lhs);
    private GenericExpressionNode BooleanTerm(string expression);
    private GenericExpressionNode BooleanTermPrime(string expression, GenericExpressionNode lhs);
    private GenericExpressionNode RelationalExpr(string expression);
    private OperatorExpressionNode RelationalOperation(string expression);
    private GenericExpressionNode Factor(string expression);
    private void Arglist(string expression, List`1<GenericExpressionNode> arglist);
    private void Args(string expression, List`1<GenericExpressionNode> arglist);
    private GenericExpressionNode Arg(string expression);
    private bool Same(string expression, TokenType token);
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ParserOptions : Enum {
    public int value__;
    public static ParserOptions None;
    public static ParserOptions AllowProperties;
    public static ParserOptions AllowItemLists;
    public static ParserOptions AllowPropertiesAndItemLists;
    public static ParserOptions AllowBuiltInMetadata;
    public static ParserOptions AllowCustomMetadata;
    public static ParserOptions AllowItemMetadata;
    public static ParserOptions AllowPropertiesAndItemMetadata;
    public static ParserOptions AllowPropertiesAndCustomMetadata;
    public static ParserOptions AllowAll;
}
internal class Microsoft.Build.Evaluation.Preprocessor : object {
    private Project _project;
    private Dictionary`2<XmlElement, IList`1<ProjectRootElement>> _importTable;
    private Stack`1<string> _filePaths;
    private List`1<XmlNode> _addedNodes;
    private Dictionary`2<XmlDocument, List`1<ResolvedImport>> _implicitImportsByProject;
    private Preprocessor(Project project);
    internal static XmlDocument GetPreprocessedDocument(Project project);
    private XmlDocument Preprocess();
    private void AddToImportTable(XmlElement element, ProjectRootElement importedProject);
    private void CreateImplicitImportTable();
    private void AddImplicitImportNodes(XmlElement documentElement);
    private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination);
}
internal class Microsoft.Build.Evaluation.ProfilerResultPrettyPrinter : object {
    public static string GetMarkdownContent(ProfilerResult result);
    public static string GetTsvContent(ProfilerResult result);
    private static string GetContent(ProfilerResult result, EvaluationLocationPrettyPrinterBase evaluationLocationPrinter);
}
[DebuggerDisplayAttribute("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]
public class Microsoft.Build.Evaluation.Project : object {
    private static bool s_debugEvaluation;
    private static BuildEventContext s_buildEventContext;
    private Data _data;
    private int _evaluatedVersion;
    private int _evaluatedToolsetCollectionVersion;
    private bool _explicitlyMarkedDirty;
    private BuildEnabledSetting _isBuildEnabled;
    private ProjectLoadSettings _loadSettings;
    private RenameHandlerDelegate _renameHandler;
    internal static NewProjectFileOptions DefaultNewProjectTemplateOptions;
    [CompilerGeneratedAttribute]
private bool <ThrowInsteadOfSplittingItemElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCollection <ProjectCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElement <Xml>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipEvaluation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableMarkDirty>k__BackingField;
    public bool ThrowInsteadOfSplittingItemElement { get; public set; }
    internal Data TestOnlyGetPrivateData { get; }
    public ProjectCollection ProjectCollection { get; }
    public ProjectRootElement Xml { get; }
    public bool IsDirty { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<string> ItemTypes { get; }
    public ICollection`1<ProjectProperty> Properties { get; }
    public IDictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public IDictionary`2<string, ProjectItemDefinition> ItemDefinitions { get; }
    public ICollection`1<ProjectItem> Items { get; }
    public ICollection`1<ProjectItem> ItemsIgnoringCondition { get; }
    public IList`1<ResolvedImport> Imports { get; }
    public IList`1<ResolvedImport> ImportsIncludingDuplicates { get; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public ICollection`1<ProjectProperty> AllEvaluatedProperties { get; }
    public ICollection`1<ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
    public ICollection`1<ProjectItem> AllEvaluatedItems { get; }
    public string ToolsVersion { get; }
    public string SubToolsetVersion { get; }
    public string DirectoryPath { get; }
    public string FullPath { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    public bool IsBuildEnabled { get; public set; }
    public ElementLocation ProjectFileLocation { get; }
    public int EvaluationCounter { get; }
    public int LastEvaluationId { get; }
    internal ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    internal ILoggingService LoggingService { get; }
    public Project(NewProjectFileOptions newProjectFileOptions);
    public Project(ProjectCollection projectCollection);
    public Project(ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public Project(IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public Project(ProjectRootElement xml);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    public Project(XmlReader xmlReader);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    public Project(string projectFile);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    private static Project();
    [CompilerGeneratedAttribute]
public bool get_ThrowInsteadOfSplittingItemElement();
    [CompilerGeneratedAttribute]
public void set_ThrowInsteadOfSplittingItemElement(bool value);
    public static Project FromFile(string file, ProjectOptions options);
    public static Project FromProjectRootElement(ProjectRootElement rootElement, ProjectOptions options);
    public static Project FromXmlReader(XmlReader reader, ProjectOptions options);
    internal Data get_TestOnlyGetPrivateData();
    [CompilerGeneratedAttribute]
public ProjectCollection get_ProjectCollection();
    [CompilerGeneratedAttribute]
public ProjectRootElement get_Xml();
    public bool get_IsDirty();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    public ICollection`1<string> get_ItemTypes();
    public ICollection`1<ProjectProperty> get_Properties();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, List`1<string>> get_ConditionedProperties();
    public IDictionary`2<string, ProjectItemDefinition> get_ItemDefinitions();
    public ICollection`1<ProjectItem> get_Items();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItem> get_ItemsIgnoringCondition();
    public IList`1<ResolvedImport> get_Imports();
    public IList`1<ResolvedImport> get_ImportsIncludingDuplicates();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public ICollection`1<ProjectProperty> get_AllEvaluatedProperties();
    public ICollection`1<ProjectMetadata> get_AllEvaluatedItemDefinitionMetadata();
    public ICollection`1<ProjectItem> get_AllEvaluatedItems();
    public string get_ToolsVersion();
    public string get_SubToolsetVersion();
    public string get_DirectoryPath();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public void set_FullPath(string value);
    [CompilerGeneratedAttribute]
public bool get_SkipEvaluation();
    [CompilerGeneratedAttribute]
public void set_SkipEvaluation(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableMarkDirty();
    [CompilerGeneratedAttribute]
public void set_DisableMarkDirty(bool value);
    public bool get_IsBuildEnabled();
    public void set_IsBuildEnabled(bool value);
    public ElementLocation get_ProjectFileLocation();
    public int get_EvaluationCounter();
    public int get_LastEvaluationId();
    internal ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    internal ILoggingService get_LoggingService();
    public static string GetEvaluatedItemIncludeEscaped(ProjectItem item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item);
    public List`1<GlobResult> GetAllGlobs();
    public List`1<GlobResult> GetAllGlobs(EvaluationContext evaluationContext);
    public List`1<GlobResult> GetAllGlobs(string itemType);
    public List`1<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext);
    private List`1<GlobResult> GetAllGlobs(List`1<ProjectItemElement> projectItemElements);
    private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement, IReadOnlyDictionary`2<string, CumulativeRemoveElementData> removeElementCache);
    private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob);
    private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary`2<string, CumulativeRemoveElementData> removeElementCache);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext);
    public List`1<ProvenanceResult> GetItemProvenance(ProjectItem item);
    public List`1<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext);
    private List`1<ProjectItemElement> GetEvaluatedItemElements(EvaluationContext evaluationContext);
    private static IEnumerable`1<ProjectItemElement> GetItemElementsThatMightAffectItem(List`1<ProjectItemElement> evaluatedItemElements, ProjectItem item);
    private static List`1<ProjectItemElement> GetItemElementsByType(IEnumerable`1<ProjectItemElement> itemElements, string itemType);
    private List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable`1<ProjectItemElement> projectItemElements);
    private ProvenanceResult ComputeProvenanceResult(string itemToMatch, ProjectItemElement itemElement);
    private static int ItemMatchesInItemSpecString(string itemToMatch, string itemSpec, IElementLocation elementLocation, string projectDirectory, Expander`2<ProjectProperty, ProjectItem> expander, Provenance& provenance);
    private static int ItemMatchesInItemSpec(string itemToMatch, ItemSpec`2<ProjectProperty, ProjectItem> itemSpec, Provenance& provenance);
    public static string GetMetadataValueEscaped(ProjectMetadata metadatum);
    public static string GetMetadataValueEscaped(ProjectItem item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name);
    public static string GetPropertyValueEscaped(ProjectProperty property);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.Project/<GetLogicalProject>d__136")]
public IEnumerable`1<ProjectElement> GetLogicalProject();
    [DebuggerStepThroughAttribute]
public ProjectProperty GetProperty(string name);
    public string GetPropertyValue(string name);
    public ProjectProperty SetProperty(string name, string unevaluatedValue);
    public bool SetGlobalProperty(string name, string escapedValue);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItem> GetItems(string itemType);
    public ICollection`1<ProjectItem> GetItemsIgnoringCondition(string itemType);
    public ICollection`1<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
    public bool RemoveProperty(ProjectProperty property);
    public bool RemoveGlobalProperty(string name);
    public bool RemoveItem(ProjectItem item);
    public void RemoveItems(IEnumerable`1<ProjectItem> items);
    public string ExpandString(string unexpandedValue);
    public ProjectInstance CreateProjectInstance();
    public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings);
    public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext);
    public void MarkDirty();
    public void ReevaluateIfNecessary();
    public void ReevaluateIfNecessary(EvaluationContext evaluationContext);
    public void Save();
    public void Save(Encoding encoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    public void SaveLogicalProject(TextWriter writer);
    public bool Build();
    public bool Build(ILogger logger);
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext);
    internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement);
    internal bool SplitItemElementIfNecessary(ProjectItemElement itemElement);
    internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement);
    internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXml, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    internal void RemoveItemBeforeItemTypeChange(ProjectItem item);
    internal void ReAddExistingItemAfterItemTypeChange(ProjectItem item);
    internal string ExpandPropertyValueBestEffortLeaveEscaped(string unevaluatedValue, ElementLocation propertyLocation);
    internal string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamedItemElement);
    internal string ExpandMetadataValueBestEffortLeaveEscaped(IMetadataTable metadataTable, string unevaluatedValue, ElementLocation metadataLocation);
    internal void Zombify();
    internal void VerifyThrowInvalidOperationNotZombie();
    internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml);
    private List`1<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    private bool RemoveItemHelper(ProjectItem item);
    private void ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, EvaluationContext evaluationContext);
    private void ReevaluateIfNecessary(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    private ProjectInstance CreateProjectInstance(ILoggingService loggingServiceForEvaluation, ProjectInstanceSettings settings, EvaluationContext evaluationContext);
    private void Reevaluate(ILoggingService loggingServiceForEvaluation, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    private void Initialize(IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext);
    private void ProjectRootElement_ProjectXmlChangedHandler(object sender, ProjectXmlChangedEventArgs args);
    private ProjectElement GetAnySuitableExistingItemXml(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata, ProjectItemElement& suitableExistingItemXml);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.Project/<GetLogicalProject>d__197")]
private IEnumerable`1<ProjectElement> GetLogicalProject(IEnumerable`1<ProjectElement> projectElements);
    [CompilerGeneratedAttribute]
private void <Initialize>b__194_0(string oldFullPath);
}
public class Microsoft.Build.Evaluation.ProjectChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public Project Project { get; private set; }
    internal ProjectChangedEventArgs(Project project);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(Project value);
}
public class Microsoft.Build.Evaluation.ProjectCollection : object {
    private DisposableReaderWriterLockSlim _locker;
    private static ProjectCollection s_globalProjectCollection;
    private static Version s_engineVersion;
    private LoadedProjectCollection _loadedProjects;
    private ILoggingService _loggingService;
    private HostServices _hostServices;
    private ToolsetDefinitionLocations _toolsetDefinitionLocations;
    private Dictionary`2<string, Toolset> _toolsets;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private string _defaultToolsVersion;
    private int _toolsetsVersion;
    private bool _isBuildEnabled;
    private bool _onlyLogCriticalEvents;
    private bool _skipEvaluation;
    private bool _disableMarkDirty;
    private int _maxNodeCount;
    [CompilerGeneratedAttribute]
private ProjectAddedEventHandler ProjectAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectCollectionChangedEventArgs> ProjectCollectionChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> ProjectXmlChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectChangedEventArgs> ProjectChanged;
    [CompilerGeneratedAttribute]
private ProjectRootElementCache <ProjectRootElementCache>k__BackingField;
    public static ProjectCollection GlobalProjectCollection { get; }
    public static Version Version { get; }
    public string DefaultToolsVersion { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<Project> LoadedProjects { get; }
    public int Count { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetDefinitionLocations ToolsetLocations { get; }
    public bool IsBuildEnabled { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    internal ILoggingService LoggingService { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesCollection { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentProperties { get; }
    internal int ToolsetsVersion { get; }
    internal int MaxNodeCount { get; internal set; }
    internal ProjectRootElementCache ProjectRootElementCache { get; }
    private static ProjectCollection();
    public ProjectCollection(ToolsetDefinitionLocations toolsetLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents);
    [CompilerGeneratedAttribute]
public void add_ProjectAdded(ProjectAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProjectAdded(ProjectAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    public static ProjectCollection get_GlobalProjectCollection();
    public static Version get_Version();
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public ICollection`1<Project> get_LoadedProjects();
    public int get_Count();
    [DebuggerStepThroughAttribute]
public ICollection`1<ILogger> get_Loggers();
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    [DebuggerStepThroughAttribute]
public ToolsetDefinitionLocations get_ToolsetLocations();
    [DebuggerStepThroughAttribute]
public bool get_IsBuildEnabled();
    [DebuggerStepThroughAttribute]
public void set_IsBuildEnabled(bool value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    public HostServices get_HostServices();
    public void set_HostServices(HostServices value);
    public bool get_SkipEvaluation();
    public void set_SkipEvaluation(bool value);
    public bool get_DisableMarkDirty();
    public void set_DisableMarkDirty(bool value);
    [DebuggerStepThroughAttribute]
internal ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesCollection();
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentProperties();
    [DebuggerStepThroughAttribute]
internal int get_ToolsetsVersion();
    internal int get_MaxNodeCount();
    internal void set_MaxNodeCount(int value);
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    public static string Escape(string unescapedString);
    public static string Unescape(string escapedString);
    public bool ContainsToolset(string toolsVersion);
    public void AddToolset(Toolset toolset);
    public bool RemoveToolset(string toolsVersion);
    public void RemoveAllToolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    public string GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject);
    public ICollection`1<Project> GetLoadedProjects(string fullPath);
    public Project LoadProject(string fileName);
    public Project LoadProject(string fileName, string toolsVersion);
    public Project LoadProject(string fileName, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader);
    public Project LoadProject(XmlReader xmlReader, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public void RegisterLogger(ILogger logger);
    public void RegisterLoggers(IEnumerable`1<ILogger> loggers);
    public void RegisterForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public void UnregisterAllLoggers();
    public void UnloadProject(Project project);
    public void UnloadProject(ProjectRootElement projectRootElement);
    public void UnloadAllProjects();
    public ProjectPropertyInstance GetGlobalProperty(string name);
    public void SetGlobalProperty(string name, string value);
    public bool RemoveGlobalProperty(string name);
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.InitializeComponent(IBuildComponentHost host);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent();
    public bool TryUnloadProject(ProjectRootElement projectRootElement);
    internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project project);
    internal void AfterUpdateLoadedProjectGlobalProperties(Project project);
    protected virtual void Dispose(bool disposing);
    private bool RemoveToolsetInternal(string toolsVersion);
    private void RegisterLoggerInternal(ILogger logger);
    private void ProjectRootElementCache_ProjectRootElementAddedHandler(object sender, ProjectRootElementCacheAddEntryEventArgs e);
    private void ProjectRootElementCache_ProjectRootElementDirtiedHandler(object sender, ProjectXmlChangedEventArgs e);
    private void ProjectRootElementCache_ProjectDirtiedHandler(object sender, ProjectChangedEventArgs e);
    private void OnProjectXmlChanged(ProjectXmlChangedEventArgs e);
    private void OnProjectChanged(ProjectChangedEventArgs e);
    private void OnProjectCollectionChanged(ProjectCollectionChangedEventArgs e);
    private void OnProjectCollectionChangedIfNonNull(ProjectCollectionChangedEventArgs e);
    private void ShutDownLoggingService();
    private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents);
    private void InitializeToolsetCollection();
}
public class Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ProjectCollectionChangedState <Changed>k__BackingField;
    public ProjectCollectionChangedState Changed { get; private set; }
    internal ProjectCollectionChangedEventArgs(ProjectCollectionChangedState changedState);
    [CompilerGeneratedAttribute]
public ProjectCollectionChangedState get_Changed();
    [CompilerGeneratedAttribute]
private void set_Changed(ProjectCollectionChangedState value);
}
public enum Microsoft.Build.Evaluation.ProjectCollectionChangedState : Enum {
    public int value__;
    public static ProjectCollectionChangedState DefaultToolsVersion;
    public static ProjectCollectionChangedState Toolsets;
    public static ProjectCollectionChangedState Loggers;
    public static ProjectCollectionChangedState GlobalProperties;
    public static ProjectCollectionChangedState IsBuildEnabled;
    public static ProjectCollectionChangedState OnlyLogCriticalEvents;
    public static ProjectCollectionChangedState HostServices;
    public static ProjectCollectionChangedState DisableMarkDirty;
    public static ProjectCollectionChangedState SkipEvaluation;
}
internal class Microsoft.Build.Evaluation.ProjectImportPathMatch : object {
    public static ProjectImportPathMatch None;
    public string PropertyName;
    public string MsBuildPropertyFormat;
    public List`1<string> SearchPaths;
    internal ProjectImportPathMatch(string propertyName, List`1<string> searchPaths);
    public ProjectImportPathMatch(INodePacketTranslator translator);
    private static ProjectImportPathMatch();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal static ProjectImportPathMatch FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItem : object {
    private Project _project;
    private string _evaluatedIncludeBeforeWildcardExpansionEscaped;
    private List`1<ProjectItemDefinition> _inheritedItemDefinitions;
    private ProjectItemElement _xml;
    private string _evaluatedIncludeEscaped;
    private PropertyDictionary`1<ProjectMetadata> _directMetadata;
    private string _fullPath;
    [DebuggerBrowsableAttribute("0")]
public ProjectItemElement Xml { get; }
    public string ItemType { get; public set; }
    public string UnevaluatedInclude { get; public set; }
    public string EvaluatedInclude { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public bool IsImported { get; }
    public IEnumerable`1<ProjectMetadata> DirectMetadata { get; }
    public int DirectMetadataCount { get; }
    public ICollection`1<ProjectMetadata> Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ICollection`1<ProjectMetadata> MetadataCollection { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansion { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansionEscaped { get; }
    internal List`1<ProjectItemDefinition> InheritedItemDefinitions { get; }
    internal ProjectItem(Project project, ProjectItemElement xml, string evaluatedIncludeEscaped, string evaluatedIncludeBeforeWildcardExpansionEscaped, PropertyDictionary`1<ProjectMetadata> directMetadataCloned, List`1<ProjectItemDefinition> inheritedItemDefinitionsCloned);
    [DebuggerStepThroughAttribute]
public ProjectItemElement get_Xml();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedInclude();
    public void set_UnevaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    public bool get_IsImported();
    public IEnumerable`1<ProjectMetadata> get_DirectMetadata();
    [DebuggerStepThroughAttribute]
public int get_DirectMetadataCount();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectMetadata> get_Metadata();
    [DebuggerStepThroughAttribute]
public int get_MetadataCount();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    internal ICollection`1<ProjectMetadata> get_MetadataCollection();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansion();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansionEscaped();
    [DebuggerStepThroughAttribute]
internal List`1<ProjectItemDefinition> get_InheritedItemDefinitions();
    public ProjectMetadata GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.GetMetadata(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
    private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
    public bool RemoveMetadata(string name);
    public void Rename(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    internal void ChangeItemType(string newItemType);
    internal void SplitOwnItemElement();
    private string GetBuiltInMetadataEscaped(string name);
    private ProjectMetadata GetItemDefinitionMetadata(string name);
    [CompilerGeneratedAttribute]
private bool <SetMetadataOperation>b__52_0(ProjectItem i);
}
[DebuggerDisplayAttribute("{_itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItemDefinition : object {
    private Project _project;
    private string _itemType;
    private PropertyDictionary`1<ProjectMetadata> _metadata;
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public IEnumerable`1<ProjectMetadata> Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ProjectItemDefinition(Project project, string itemType);
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public IEnumerable`1<ProjectMetadata> get_Metadata();
    public int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadata GetMetadata(string name);
    public string GetMetadataValue(string name);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ProjectLoadSettings : Enum {
    public int value__;
    public static ProjectLoadSettings Default;
    public static ProjectLoadSettings IgnoreMissingImports;
    public static ProjectLoadSettings RecordDuplicateButNotCircularImports;
    public static ProjectLoadSettings RejectCircularImports;
    public static ProjectLoadSettings RecordEvaluatedItemElements;
    public static ProjectLoadSettings IgnoreEmptyImports;
    public static ProjectLoadSettings DoNotEvaluateElementsWithFalseCondition;
    public static ProjectLoadSettings IgnoreInvalidImports;
    public static ProjectLoadSettings ProfileEvaluation;
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{_xml.Value}]")]
public class Microsoft.Build.Evaluation.ProjectMetadata : object {
    private IProjectMetadataParent _parent;
    private ProjectMetadataElement _xml;
    private string _evaluatedValueEscaped;
    private ProjectMetadata _predecessor;
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string UnevaluatedValue { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public ProjectMetadataElement Xml { get; }
    public Project Project { get; }
    public string ItemType { get; }
    public ProjectMetadata Predecessor { get; }
    public bool IsImported { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_UnevaluatedValue(string value);
    [DebuggerStepThroughAttribute]
public ProjectMetadataElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    public string get_ItemType();
    [DebuggerStepThroughAttribute]
public ProjectMetadata get_Predecessor();
    public bool get_IsImported();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>.Equals(ProjectMetadata other);
    internal ProjectMetadata DeepClone();
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
public abstract class Microsoft.Build.Evaluation.ProjectProperty : object {
    private Project _project;
    private string _evaluatedValueEscaped;
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    public string UnevaluatedValue { get; public set; }
    public bool IsEnvironmentProperty { get; }
    public bool IsGlobalProperty { get; }
    public bool IsReservedProperty { get; }
    [DebuggerBrowsableAttribute("0")]
public ProjectPropertyElement Xml { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public ProjectProperty Predecessor { get; }
    public bool IsImported { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    internal ProjectProperty(Project project, string evaluatedValueEscaped);
    [DebuggerStepThroughAttribute]
public abstract virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    [DebuggerStepThroughAttribute]
public abstract virtual string get_UnevaluatedValue();
    public abstract virtual void set_UnevaluatedValue(string value);
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsEnvironmentProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsGlobalProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsReservedProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectPropertyElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectProperty get_Predecessor();
    public abstract virtual bool get_IsImported();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>.Equals(ProjectProperty other);
    internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    internal static ProjectProperty Create(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor);
    internal void UpdateEvaluatedValue(string evaluatedValueEscaped);
    private static bool ProjectHasMatchingGlobalProperty(Project project, string propertyName);
}
internal class Microsoft.Build.Evaluation.ProjectRootElementCache : object {
    private static int s_maximumStrongCacheSize;
    private static bool s_debugLogCacheActivity;
    private WeakValueDictionary`2<string, ProjectRootElement> _weakCache;
    private LinkedList`1<ProjectRootElement> _strongCache;
    private bool _autoReloadFromDisk;
    private object _locker;
    [CompilerGeneratedAttribute]
private static StrongCacheEntryRemovedDelegate StrongCacheEntryRemoved;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheAddEntryHandler ProjectRootElementAddedHandler;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> ProjectRootElementDirtied;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectChangedEventArgs> ProjectDirtied;
    private static ProjectRootElementCache();
    internal ProjectRootElementCache(bool autoReloadFromDisk);
    [CompilerGeneratedAttribute]
internal static void add_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    [CompilerGeneratedAttribute]
internal static void remove_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    [CompilerGeneratedAttribute]
internal void add_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    [CompilerGeneratedAttribute]
internal void add_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    internal ProjectRootElement Get(string projectFile, OpenProjectRootElement openProjectRootElement, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    internal void AddEntry(ProjectRootElement projectRootElement);
    internal void OnProjectRootElementDirtied(ProjectRootElement sender, ProjectXmlChangedEventArgs e);
    internal void OnProjectDirtied(Project sender, ProjectChangedEventArgs e);
    internal void RenameEntry(string oldFullPath, ProjectRootElement projectRootElement);
    internal ProjectRootElement TryGet(string projectFile);
    internal ProjectRootElement TryGet(string projectFile, Nullable`1<bool> preserveFormatting);
    internal void DiscardStrongReferences();
    internal void Clear();
    internal void DiscardImplicitReferences();
    internal void DiscardAnyWeakReference(ProjectRootElement projectRootElement);
    private void RaiseProjectRootElementAddedToCacheEvent(ProjectRootElement rootElement);
    private void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement);
    private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement projectRootElement);
    private void BoostEntryInStrongCache(ProjectRootElement projectRootElement);
    private void ForgetEntry(ProjectRootElement projectRootElement);
    private void DebugTraceCache(string message, bool param1);
    private void DebugTraceCache(string message, int param1);
    private void DebugTraceCache(string message, string param1);
}
public class Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs : EventArgs {
    private string _unformattedReason;
    private string _formattingParameter;
    [CompilerGeneratedAttribute]
private ProjectRootElement <ProjectXml>k__BackingField;
    public ProjectRootElement ProjectXml { get; private set; }
    public string Reason { get; }
    internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter);
    [CompilerGeneratedAttribute]
public ProjectRootElement get_ProjectXml();
    [CompilerGeneratedAttribute]
private void set_ProjectXml(ProjectRootElement value);
    public string get_Reason();
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.Provenance : Enum {
    public int value__;
    public static Provenance Undefined;
    public static Provenance StringLiteral;
    public static Provenance Glob;
    public static Provenance Inconclusive;
}
public class Microsoft.Build.Evaluation.ProvenanceResult : object {
    [CompilerGeneratedAttribute]
private Operation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectItemElement <ItemElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Provenance <Provenance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Occurrences>k__BackingField;
    public Operation Operation { get; }
    public ProjectItemElement ItemElement { get; }
    public Provenance Provenance { get; }
    public int Occurrences { get; }
    public ProvenanceResult(ProjectItemElement itemElement, Operation operation, Provenance provenance, int occurrences);
    [CompilerGeneratedAttribute]
public Operation get_Operation();
    [CompilerGeneratedAttribute]
public ProjectItemElement get_ItemElement();
    [CompilerGeneratedAttribute]
public Provenance get_Provenance();
    [CompilerGeneratedAttribute]
public int get_Occurrences();
}
public class Microsoft.Build.Evaluation.ResolvedImport : ValueType {
    [CompilerGeneratedAttribute]
private ProjectImportElement <ImportingElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElement <ImportedProject>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkResult <SdkResult>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VersionEvaluated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImported>k__BackingField;
    public ProjectImportElement ImportingElement { get; }
    public ProjectRootElement ImportedProject { get; }
    public SdkResult SdkResult { get; }
    internal int VersionEvaluated { get; }
    public bool IsImported { get; }
    internal ResolvedImport(Project project, ProjectImportElement importingElement, ProjectRootElement importedProject, int versionEvaluated, SdkResult sdkResult);
    [CompilerGeneratedAttribute]
public ProjectImportElement get_ImportingElement();
    [CompilerGeneratedAttribute]
public ProjectRootElement get_ImportedProject();
    [CompilerGeneratedAttribute]
public SdkResult get_SdkResult();
    [CompilerGeneratedAttribute]
internal int get_VersionEvaluated();
    [CompilerGeneratedAttribute]
public bool get_IsImported();
}
internal class Microsoft.Build.Evaluation.Scanner : object {
    private string _expression;
    private int _parsePoint;
    private Token _lookahead;
    private bool _errorState;
    private int _errorPosition;
    private string _unexpectedlyFound;
    private ParserOptions _options;
    private string _errorResource;
    private static string s_endOfInput;
    private string EndOfInput { get; }
    internal Token CurrentToken { get; }
    internal string UnexpectedlyFound { get; }
    internal Scanner(string expressionToParse, ParserOptions options);
    private static Scanner();
    private string get_EndOfInput();
    internal string GetErrorResource();
    internal bool IsNext(TokenType type);
    internal string IsNextString();
    internal Token get_CurrentToken();
    internal int GetErrorPosition();
    internal string get_UnexpectedlyFound();
    internal bool Advance();
    private string ParsePropertyOrItemMetadata();
    private static int ScanForPropertyExpressionEnd(string expression, int index);
    private bool ParseProperty();
    private bool ParseItemMetadata();
    private bool CheckForUnexpectedMetadata(string expression);
    private bool ParseInternalItemList();
    private bool ParseItemList();
    private bool ParseQuotedString();
    private bool ParseRemaining();
    private bool ParseSimpleStringOrFunction(int start);
    private bool ParseNumeric(int start);
    private void SkipWhiteSpace();
    private void SkipDigits();
    private void SkipHexDigits();
    private void SkipSimpleStringChars();
}
internal class Microsoft.Build.Evaluation.SemiColonTokenizer : ValueType {
    private string _expression;
    public SemiColonTokenizer(string expression);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ShredderOptions : Enum {
    public int value__;
    public static ShredderOptions Invalid;
    public static ShredderOptions ItemTypes;
    public static ShredderOptions MetadataOutsideTransforms;
    public static ShredderOptions All;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.StringExpressionNode : OperandExpressionNode {
    private string _value;
    private string _cachedExpandedValue;
    private bool _expandable;
    internal string DebuggerDisplay { get; }
    internal StringExpressionNode(string value, bool expandable);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state);
    internal virtual double NumericEvaluate(IConditionEvaluationState state);
    internal virtual Version VersionEvaluate(IConditionEvaluationState state);
    internal virtual bool CanBoolEvaluate(IConditionEvaluationState state);
    internal virtual bool CanNumericEvaluate(IConditionEvaluationState state);
    internal virtual bool CanVersionEvaluate(IConditionEvaluationState state);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
    internal virtual string get_DebuggerDisplay();
}
internal class Microsoft.Build.Evaluation.StringMetadataTable : object {
    private Dictionary`2<string, string> _metadata;
    internal StringMetadataTable(Dictionary`2<string, string> metadata);
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
}
[DebuggerDisplayAttribute("SubToolsetVersion={SubToolsetVersion} #Properties={_properties.Count}")]
public class Microsoft.Build.Evaluation.SubToolset : object {
    private string _subToolsetVersion;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    public string SubToolsetVersion { get; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    internal SubToolset(string subToolsetVersion, PropertyDictionary`1<ProjectPropertyInstance> properties);
    private SubToolset(INodePacketTranslator translator);
    public string get_SubToolsetVersion();
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static SubToolset FactoryForDeserialization(INodePacketTranslator translator);
}
internal class Microsoft.Build.Evaluation.Token : object {
    internal static Token Comma;
    internal static Token LeftParenthesis;
    internal static Token RightParenthesis;
    internal static Token LessThan;
    internal static Token GreaterThan;
    internal static Token LessThanOrEqualTo;
    internal static Token GreaterThanOrEqualTo;
    internal static Token And;
    internal static Token Or;
    internal static Token EqualTo;
    internal static Token NotEqualTo;
    internal static Token Not;
    internal static Token EndOfInput;
    private TokenType _tokenType;
    private string _tokenString;
    [CompilerGeneratedAttribute]
private bool <Expandable>k__BackingField;
    internal bool Expandable { get; internal set; }
    internal string String { get; }
    private Token(TokenType tokenType);
    internal Token(TokenType type, string tokenString);
    internal Token(TokenType type, string tokenString, bool expandable);
    private static Token();
    [CompilerGeneratedAttribute]
internal bool get_Expandable();
    [CompilerGeneratedAttribute]
internal void set_Expandable(bool value);
    internal bool IsToken(TokenType type);
    internal string get_String();
}
[DebuggerDisplayAttribute("ToolsVersion={ToolsVersion} ToolsPath={ToolsPath} #Properties={_properties.Count}")]
public class Microsoft.Build.Evaluation.Toolset : object {
    private static string DefaultTasksFilePattern;
    private static string OverrideTasksFilePattern;
    private static string Dev10OverallInstallKeyRegistryPath;
    private static string Dev10UltimateInstallKeyRegistryPath;
    private static string Dev10PremiumInstallKeyRegistryPath;
    private static string Dev10ProfessionalInstallKeyRegistryPath;
    private static string Dev10VCSExpressInstallKeyRegistryPath;
    private static string Dev10VBExpressInstallKeyRegistryPath;
    private static string Dev10VCExpressInstallKeyRegistryPath;
    private static string Dev10VWDExpressInstallKeyRegistryPath;
    private static string Dev10LightSwitchInstallKeyRegistryPath;
    private string _toolsVersion;
    private string _toolsPath;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    private string _overrideTasksPath;
    private string _defaultOverrideToolsVersion;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private bool _defaultTasksRegistrationAttempted;
    private bool _overrideTasksRegistrationAttempted;
    private TaskRegistry _defaultTaskRegistry;
    private TaskRegistry _overrideTaskRegistry;
    private DirectoryGetFiles _getFiles;
    private DirectoryExists _directoryExists;
    private LoadXmlFromPath _loadXmlFromPath;
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private PropertyDictionary`1<ProjectPropertyInstance> _propertyBag;
    private Dictionary`2<string, SubToolset> _subToolsets;
    private string _defaultSubToolsetVersion;
    private Dictionary`2<string, ProjectImportPathMatch> _propertySearchPathsTable;
    [CompilerGeneratedAttribute]
private Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> <MSBuildExtensionsPathSearchPathsTable>k__BackingField;
    public string ToolsVersion { get; }
    public string ToolsPath { get; private set; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    public IDictionary`2<string, SubToolset> SubToolsets { get; }
    public string DefaultSubToolsetVersion { get; }
    internal static bool Dev10IsInstalled { get; }
    internal string OverrideTasksPath { get; }
    internal string DefaultOverrideToolsVersion { get; }
    internal Dictionary`2<string, ProjectImportPathMatch> ImportPropertySearchPathsTable { get; }
    internal Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> MSBuildExtensionsPathSearchPathsTable { get; internal set; }
    public Toolset(string toolsVersion, string toolsPath, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion, Dictionary`2<string, ProjectImportPathMatch> importSearchPathsTable);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists);
    private Toolset(INodePacketTranslator translator);
    internal ProjectImportPathMatch GetProjectImportSearchPaths(string expression);
    public string get_ToolsVersion();
    public string get_ToolsPath();
    private void set_ToolsPath(string value);
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    public IDictionary`2<string, SubToolset> get_SubToolsets();
    public string get_DefaultSubToolsetVersion();
    internal static bool get_Dev10IsInstalled();
    internal string get_OverrideTasksPath();
    internal string get_DefaultOverrideToolsVersion();
    internal Dictionary`2<string, ProjectImportPathMatch> get_ImportPropertySearchPathsTable();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> get_MSBuildExtensionsPathSearchPathsTable();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPathSearchPathsTable(Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> value);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    public string GenerateSubToolsetVersion();
    public string GenerateSubToolsetVersion(IDictionary`2<string, string> overrideGlobalProperties, int solutionVersion);
    public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion);
    internal static Toolset FactoryForDeserialization(INodePacketTranslator translator);
    internal static String[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning);
    internal string GenerateSubToolsetVersion(PropertyDictionary`1<ProjectPropertyInstance> overrideGlobalProperties);
    internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution);
    internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
    internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary`2<string, string> overrideGlobalProperties, int visualStudioVersionFromSolution);
    internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
    private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
    private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext);
    private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCache projectRootElementCache);
    private void LoadAndRegisterFromTasksFile(string searchPath, String[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string defaultTasksFilePattern, string taskFileError, ProjectRootElementCache projectRootElementCache, TaskRegistry registry);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ToolsetDefinitionLocations : Enum {
    public int value__;
    public static ToolsetDefinitionLocations None;
    public static ToolsetDefinitionLocations ConfigurationFile;
    public static ToolsetDefinitionLocations Registry;
    public static ToolsetDefinitionLocations Local;
    public static ToolsetDefinitionLocations Default;
}
internal class Microsoft.Build.Evaluation.ToolsetLocalReader : ToolsetReader {
    private IElementLocation _sourceLocation;
    protected string DefaultOverrideToolsVersion { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    internal ToolsetLocalReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    protected virtual string get_DefaultOverrideToolsVersion();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetLocalReader/<get_ToolsVersions>d__9")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetLocalReader/<GetPropertyDefinitions>d__10")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
}
[DebuggerDisplayAttribute("Name={Name} Value={Value}")]
internal class Microsoft.Build.Evaluation.ToolsetPropertyDefinition : object {
    private string _name;
    private string _value;
    private IElementLocation _source;
    public string Name { get; }
    public string Value { get; public set; }
    public IElementLocation Source { get; }
    public ToolsetPropertyDefinition(string name, string value, IElementLocation source);
    public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public IElementLocation get_Source();
}
internal class Microsoft.Build.Evaluation.ToolsetProvider : object {
    private Dictionary`2<string, Toolset> _toolsets;
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetProvider(string defaultToolsVersion, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ToolsetProvider(IEnumerable`1<Toolset> toolsets);
    private ToolsetProvider(INodePacketTranslator translator);
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ToolsetProvider FactoryForDeserialization(INodePacketTranslator translator);
    private void InitializeToolsetCollection(string defaultToolsVersion, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations);
}
internal abstract class Microsoft.Build.Evaluation.ToolsetReader : object {
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected string DefaultOverrideToolsVersion { get; }
    protected ToolsetReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected abstract virtual string get_DefaultToolsVersion();
    protected abstract virtual string get_MSBuildOverrideTasksPath();
    protected abstract virtual string get_DefaultOverrideToolsVersion();
    internal static string ReadAllToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations locations);
    internal string ReadToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties, String& msBuildOverrideTasksPath, String& defaultOverrideToolsVersion);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected abstract virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected abstract virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    private void ReadEachToolset(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties);
    private Toolset ReadToolset(ToolsetPropertyDefinition toolsVersion, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties);
    private static PropertyDictionary`1<ProjectPropertyInstance> CreateStandardProperties(PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string version, string root, string toolsPath);
    private static void AppendStandardProperties(PropertyDictionary`1<ProjectPropertyInstance> properties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string version, string root, string toolsPath);
    private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, PropertyDictionary`1<ProjectPropertyInstance> properties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties, String& toolsPath, String& binPath, Expander`2& expander);
    private string ExpandPropertyUnescaped(ToolsetPropertyDefinition property, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander);
    private void SetProperty(ToolsetPropertyDefinition property, PropertyDictionary`1<ProjectPropertyInstance> propertyGroup, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    private string ExpandRelativePathsRelativeToExeLocation(string path);
}
internal class Microsoft.Build.Evaluation.UsedUninitializedProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IElementLocation> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentlyEvaluatingPropertyElementName>k__BackingField;
    internal IDictionary`2<string, IElementLocation> Properties { get; internal set; }
    internal bool Warn { get; internal set; }
    internal string CurrentlyEvaluatingPropertyElementName { get; internal set; }
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, IElementLocation> get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(IDictionary`2<string, IElementLocation> value);
    [CompilerGeneratedAttribute]
internal bool get_Warn();
    [CompilerGeneratedAttribute]
internal void set_Warn(bool value);
    [CompilerGeneratedAttribute]
internal string get_CurrentlyEvaluatingPropertyElementName();
    [CompilerGeneratedAttribute]
internal void set_CurrentlyEvaluatingPropertyElementName(string value);
}
internal class Microsoft.Build.Evaluation.ValueFragment : ItemFragment {
    public ValueFragment(string itemSpecFragment, string projectDirectory);
}
public class Microsoft.Build.Exceptions.BuildAbortedException : Exception {
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    public string ErrorCode { get; }
    public BuildAbortedException(string message);
    public BuildAbortedException(string message, Exception innerException);
    protected BuildAbortedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Build.Exceptions.InternalLoggerException : Exception {
    private BuildEventArgs e;
    private string errorCode;
    private string helpKeyword;
    [OptionalFieldAttribute]
private bool initializationException;
    public BuildEventArgs BuildEventArgs { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool InitializationException { get; }
    public InternalLoggerException(string message);
    public InternalLoggerException(string message, Exception innerException);
    internal InternalLoggerException(string message, Exception innerException, BuildEventArgs e, string errorCode, string helpKeyword, bool initializationException);
    private InternalLoggerException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [OnDeserializingAttribute]
private void SetDefaultsBeforeSerialization(StreamingContext sc);
    [OnDeserializedAttribute]
private void SetValueAfterDeserialization(StreamingContext sx);
    public BuildEventArgs get_BuildEventArgs();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_InitializationException();
    internal static void Throw(Exception innerException, BuildEventArgs e, string messageResourceName, bool initializationException, String[] messageArgs);
}
public class Microsoft.Build.Exceptions.InvalidProjectFileException : Exception {
    private string file;
    private int lineNumber;
    private int columnNumber;
    private int endLineNumber;
    private int endColumnNumber;
    private string errorSubcategory;
    private string errorCode;
    private string helpKeyword;
    private bool hasBeenLogged;
    public string Message { get; }
    public string BaseMessage { get; }
    public string ProjectFile { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string ErrorSubcategory { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool HasBeenLogged { get; internal set; }
    public InvalidProjectFileException(string message);
    public InvalidProjectFileException(string message, Exception innerException);
    internal InvalidProjectFileException(string message, InvalidProjectFileException innerException);
    private InvalidProjectFileException(SerializationInfo info, StreamingContext context);
    public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword);
    internal InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_BaseMessage();
    public string get_ProjectFile();
    public int get_LineNumber();
    public int get_ColumnNumber();
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_ErrorSubcategory();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_HasBeenLogged();
    internal void set_HasBeenLogged(bool value);
}
public class Microsoft.Build.Exceptions.InvalidToolsetDefinitionException : Exception {
    private string errorCode;
    public string ErrorCode { get; }
    public InvalidToolsetDefinitionException(string message);
    public InvalidToolsetDefinitionException(string message, Exception innerException);
    protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context);
    public InvalidToolsetDefinitionException(string message, string errorCode);
    public InvalidToolsetDefinitionException(string message, string errorCode, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_ErrorCode();
    internal static void Throw(string resourceName, String[] args);
    internal static void Throw(Exception innerException, string resourceName, String[] args);
}
internal class Microsoft.Build.Exceptions.RegistryException : Exception {
    public RegistryException(string message);
    public RegistryException(string message, Exception innerException);
    public RegistryException(string message, string source);
    protected RegistryException(SerializationInfo info, StreamingContext context);
    public RegistryException(string message, string source, Exception innerException);
}
public class Microsoft.Build.Execution.BuildManager : object {
    private static object s_staticSyncLock;
    private object _syncLock;
    private static BuildManager s_singletonInstance;
    private static int s_nextBuildId;
    private static int s_nextBuildRequestConfigurationId;
    private IConfigCache _configCache;
    private IResultsCache _resultsCache;
    private INodeManager _nodeManager;
    private INodeManager _taskHostNodeManager;
    private IScheduler _scheduler;
    private NodeConfiguration _nodeConfiguration;
    private Exception _threadException;
    private HashSet`1<NGen`1<int>> _activeNodes;
    private AutoResetEvent _noNodesActiveEvent;
    private Dictionary`2<NGen`1<int>, HashSet`1<NGen`1<int>>> _nodeIdToKnownConfigurations;
    private bool _shuttingDown;
    private BuildManagerState _buildManagerState;
    private string _hostName;
    private BuildParameters _buildParameters;
    private Dictionary`2<int, BuildSubmission> _buildSubmissions;
    private AutoResetEvent _noActiveSubmissionsEvent;
    private bool _overallBuildSuccess;
    private int _nextBuildSubmissionId;
    private Dictionary`2<ProjectInstance, string> _unnamedProjectInstanceToNames;
    private int _nextUnnamedProjectId;
    private BuildComponentFactoryCollection _componentFactories;
    private Dictionary`2<int, BuildEventArgs> _projectStartedEvents;
    private bool _acquiredProjectRootElementCacheFromProjectInstance;
    private ProjectStartedEventHandler _projectStartedEventHandler;
    private ProjectFinishedEventHandler _projectFinishedEventHandler;
    private LoggingExceptionDelegate _loggingThreadExceptionEventHandler;
    private LegacyThreadingData _legacyThreadingData;
    private ActionBlock`1<Action> _workQueue;
    private bool _disposed;
    public static BuildManager DefaultBuildManager { get; }
    private ISdkResolverService SdkResolverService { get; }
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    public BuildManager(string hostName);
    private static BuildManager();
    protected virtual override void Finalize();
    public static BuildManager get_DefaultBuildManager();
    private ISdkResolverService get_SdkResolverService();
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    public void BeginBuild(BuildParameters parameters);
    public void CancelAllSubmissions();
    public void ResetCaches();
    public ProjectInstance GetProjectInstanceForBuild(Project project);
    public BuildSubmission PendBuildRequest(BuildRequestData requestData);
    public BuildResult BuildRequest(BuildRequestData requestData);
    public void EndBuild();
    public BuildResult Build(BuildParameters parameters, BuildRequestData requestData);
    public void ShutdownAllNodes();
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild);
    internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request);
    private static int GetNextBuildId();
    private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequestConfiguration existingConfiguration);
    private void ProcessWorkQueue(Action action);
    private void ProcessPacket(int node, INodePacket packet);
    private void HandleExecuteSubmissionException(BuildSubmission submission, Exception ex);
    private void IssueRequestToScheduler(BuildSubmission submission, bool allowMainThreadBuild, BuildRequestBlocker blocker);
    private void ShutdownConnectedNodesAsync(bool abort);
    private int GetNextSubmissionId();
    private void ErrorIfState(BuildManagerState disallowedState, string exceptionResouorce);
    private void RequireState(BuildManagerState requiredState, string exceptionResouorce);
    private void VerifyStateInternal(BuildManagerState requiredState);
    private void Reset();
    private int GetNewConfigurationId();
    private BuildRequestConfiguration ResolveConfiguration(BuildRequestConfiguration unresolvedConfiguration, BuildRequestConfiguration matchingConfigurationFromCache, bool replaceProjectInstance);
    private void ReplaceExistingProjectInstance(BuildRequestConfiguration newConfiguration, BuildRequestConfiguration existingConfiguration);
    private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration unresolvedConfiguration);
    private void HandleNewRequest(int node, BuildRequestBlocker blocker);
    private void HandleConfigurationRequest(int node, BuildRequestConfiguration unresolvedConfiguration);
    private void HandleResult(int node, BuildResult result);
    private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket);
    private void CheckForActiveNodesAndCleanUpSubmissions();
    private void PerformSchedulingActions(IEnumerable`1<ScheduleResponse> responses);
    private void ReportResultsToSubmission(BuildResult result);
    private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission);
    private NodeConfiguration GetNodeConfiguration();
    private void OnThreadException(Exception e);
    private void OnProjectFinished(object sender, ProjectFinishedEventArgs e);
    private void OnProjectStarted(object sender, ProjectStartedEventArgs e);
    private ILoggingService CreateLoggingService(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> forwardingLoggers, ISet`1<string> warningsAsErrors, ISet`1<string> warningsAsMessages);
    private static I ExpectPacketType(INodePacket packet, NodePacketType expectedType);
    private void SetOverallResultIfWarningsAsErrors(BuildResult result);
    private void ShutdownLoggingService(ILoggingService loggingService);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <BeginBuild>b__50_0(Action action);
    [CompilerGeneratedAttribute]
private void <CancelAllSubmissions>g__Callback|51_0(object state);
}
public class Microsoft.Build.Execution.BuildParameters : object {
    private static int DefaultThreadStackSize;
    private static int DefaultEndpointShutdownTimeout;
    private static int DefaultEngineShutdownTimeout;
    private static int DefaultLoggingThreadShutdownTimeout;
    private static int DefaultRequestBuilderShutdownTimeout;
    private static int DefaultIdleRequestBuilderLimit;
    private static string s_startupDirectory;
    private static Nullable`1<bool> s_warnOnUninitializedProperty;
    private static Nullable`1<bool> s_dumpOpportunisticInternStats;
    private static Nullable`1<bool> s_debugExpansion;
    private static Nullable`1<bool> s_keepDuplicateOutputs;
    private static Nullable`1<bool> s_enableBuildPlan;
    private static Nullable`1<int> s_idleRequestBuilderLimit;
    private static string s_msbuildExeKnownToExistAt;
    private int _buildId;
    private CultureInfo _culture;
    private string _defaultToolsVersion;
    private bool _enableNodeReuse;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private IEnumerable`1<ForwardingLoggerRecord> _forwardingLoggers;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private IEnumerable`1<ILogger> _loggers;
    private int _maxNodeCount;
    private int _memoryUseLimit;
    private string _nodeExeLocation;
    private bool _onlyLogCriticalEvents;
    private CultureInfo _uiCulture;
    private ToolsetProvider _toolsetProvider;
    private bool _useSynchronousLogging;
    private bool _shutdownInProcNodeOnBuildFinish;
    private bool _disableInProcNode;
    private bool _logTaskInputs;
    private bool _logInitialPropertiesAndItems;
    private ProjectLoadSettings _projectLoadSettings;
    [CompilerGeneratedAttribute]
private bool <DetailedSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyThreadingSemantics>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ToolsetDefinitionLocations <ToolsetDefinitionLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveOperatingEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCache <ProjectRootElementCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutOfProc>k__BackingField;
    public bool UseSynchronousLogging { get; public set; }
    public IDictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; public set; }
    public string DefaultToolsVersion { get; public set; }
    public bool DetailedSummary { get; public set; }
    public bool DisableInProcNode { get; public set; }
    public bool LogTaskInputs { get; public set; }
    public bool LogInitialPropertiesAndItems { get; public set; }
    public bool ResetCaches { get; public set; }
    public bool EnableNodeReuse { get; public set; }
    public IDictionary`2<string, string> EnvironmentProperties { get; }
    public IEnumerable`1<ForwardingLoggerRecord> ForwardingLoggers { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool LegacyThreadingSemantics { get; public set; }
    public IEnumerable`1<ILogger> Loggers { get; public set; }
    public int MaxNodeCount { get; public set; }
    public int MemoryUseLimit { get; public set; }
    public string NodeExeLocation { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public ToolsetDefinitionLocations ToolsetDefinitionLocations { get; public set; }
    public ICollection`1<Toolset> Toolsets { get; }
    public CultureInfo UICulture { get; public set; }
    public bool SaveOperatingEnvironment { get; public set; }
    public bool ShutdownInProcNodeOnBuildFinish { get; public set; }
    internal static int ThreadStackSize { get; }
    internal static int EndpointShutdownTimeout { get; }
    internal static int EngineShutdownTimeout { get; }
    internal static int IdleRequestBuilderLimit { get; }
    internal static int LoggingThreadShutdownTimeout { get; }
    internal static int RequestBuilderShutdownTimeout { get; }
    internal static string StartupDirectory { get; }
    internal static bool EnableBuildPlan { get; }
    internal static bool WarnOnUninitializedProperty { get; internal set; }
    internal static bool DumpOpportunisticInternStats { get; }
    internal static bool DebugExpansion { get; }
    internal static bool KeepDuplicateOutputs { get; }
    internal int BuildId { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentPropertiesInternal { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesInternal { get; }
    internal int NodeId { get; internal set; }
    internal IToolsetProvider ToolsetProvider { get; }
    internal ProjectRootElementCache ProjectRootElementCache { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    public ProjectLoadSettings ProjectLoadSettings { get; public set; }
    public BuildParameters(ProjectCollection projectCollection);
    private BuildParameters(INodePacketTranslator translator);
    private BuildParameters(BuildParameters other);
    private static BuildParameters();
    public bool get_UseSynchronousLogging();
    public void set_UseSynchronousLogging(bool value);
    public IDictionary`2<string, string> get_BuildProcessEnvironment();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_DetailedSummary();
    [CompilerGeneratedAttribute]
public void set_DetailedSummary(bool value);
    public bool get_DisableInProcNode();
    public void set_DisableInProcNode(bool value);
    public bool get_LogTaskInputs();
    public void set_LogTaskInputs(bool value);
    public bool get_LogInitialPropertiesAndItems();
    public void set_LogInitialPropertiesAndItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResetCaches();
    [CompilerGeneratedAttribute]
public void set_ResetCaches(bool value);
    public bool get_EnableNodeReuse();
    public void set_EnableNodeReuse(bool value);
    public IDictionary`2<string, string> get_EnvironmentProperties();
    public IEnumerable`1<ForwardingLoggerRecord> get_ForwardingLoggers();
    public void set_ForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public void set_GlobalProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
    [CompilerGeneratedAttribute]
public void set_HostServices(HostServices value);
    [CompilerGeneratedAttribute]
public bool get_LegacyThreadingSemantics();
    [CompilerGeneratedAttribute]
public void set_LegacyThreadingSemantics(bool value);
    public IEnumerable`1<ILogger> get_Loggers();
    public void set_Loggers(IEnumerable`1<ILogger> value);
    public int get_MaxNodeCount();
    public void set_MaxNodeCount(int value);
    public int get_MemoryUseLimit();
    public void set_MemoryUseLimit(int value);
    public string get_NodeExeLocation();
    public void set_NodeExeLocation(string value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessages(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ToolsetDefinitionLocations get_ToolsetDefinitionLocations();
    [CompilerGeneratedAttribute]
public void set_ToolsetDefinitionLocations(ToolsetDefinitionLocations value);
    public ICollection`1<Toolset> get_Toolsets();
    public CultureInfo get_UICulture();
    public void set_UICulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public bool get_SaveOperatingEnvironment();
    [CompilerGeneratedAttribute]
public void set_SaveOperatingEnvironment(bool value);
    public bool get_ShutdownInProcNodeOnBuildFinish();
    public void set_ShutdownInProcNodeOnBuildFinish(bool value);
    internal static int get_ThreadStackSize();
    internal static int get_EndpointShutdownTimeout();
    internal static int get_EngineShutdownTimeout();
    internal static int get_IdleRequestBuilderLimit();
    internal static int get_LoggingThreadShutdownTimeout();
    internal static int get_RequestBuilderShutdownTimeout();
    internal static string get_StartupDirectory();
    internal static bool get_EnableBuildPlan();
    internal static bool get_WarnOnUninitializedProperty();
    internal static void set_WarnOnUninitializedProperty(bool value);
    internal static bool get_DumpOpportunisticInternStats();
    internal static bool get_DebugExpansion();
    internal static bool get_KeepDuplicateOutputs();
    internal int get_BuildId();
    internal void set_BuildId(int value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentPropertiesInternal();
    internal void set_EnvironmentPropertiesInternal(PropertyDictionary`1<ProjectPropertyInstance> value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesInternal();
    [CompilerGeneratedAttribute]
internal int get_NodeId();
    [CompilerGeneratedAttribute]
internal void set_NodeId(int value);
    internal IToolsetProvider get_ToolsetProvider();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
internal void set_ProjectRootElementCache(ProjectRootElementCache value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public ProjectLoadSettings get_ProjectLoadSettings();
    public void set_ProjectLoadSettings(ProjectLoadSettings value);
    public Toolset GetToolset(string toolsVersion);
    public BuildParameters Clone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static BuildParameters FactoryForDeserialization(INodePacketTranslator translator);
    private static bool GetStaticBoolVariableOrDefault(string environmentVariable, Nullable`1& backing, bool default);
    private static int GetStaticIntVariableOrDefault(string environmentVariable, Nullable`1& backingValue, int defaultValue);
    private void Initialize(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, ProjectRootElementCache projectRootElementCache, ToolsetProvider toolsetProvider);
    private void EnsureToolsets();
    private string FindMSBuildExe();
    private static bool CheckMSBuildExeExistsAt(string path);
}
public class Microsoft.Build.Execution.BuildRequestData : object {
    [CompilerGeneratedAttribute]
private ProjectInstance <ProjectInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <TargetNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitlySpecifiedToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PropertiesToTransfer>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestedProjectState <RequestedProjectState>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDictionary`1<ProjectPropertyInstance> <GlobalPropertiesDictionary>k__BackingField;
    public ProjectInstance ProjectInstance { get; }
    public string ProjectFullPath { get; internal set; }
    public ICollection`1<string> TargetNames { get; }
    public BuildRequestDataFlags Flags { get; }
    public ICollection`1<ProjectPropertyInstance> GlobalProperties { get; }
    public string ExplicitlySpecifiedToolsVersion { get; }
    public HostServices HostServices { get; }
    public IEnumerable`1<string> PropertiesToTransfer { get; }
    public RequestedProjectState RequestedProjectState { get; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable`1<string> propertiesToTransfer);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable`1<string> propertiesToTransfer, RequestedProjectState requestedProjectState);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, RequestedProjectState requestedProjectState);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    private BuildRequestData(String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    [CompilerGeneratedAttribute]
public ProjectInstance get_ProjectInstance();
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
internal void set_ProjectFullPath(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_Flags();
    public ICollection`1<ProjectPropertyInstance> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public string get_ExplicitlySpecifiedToolsVersion();
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PropertiesToTransfer();
    [CompilerGeneratedAttribute]
public RequestedProjectState get_RequestedProjectState();
    internal bool get_ExplicitToolsVersionSpecified();
    [CompilerGeneratedAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.BuildRequestDataFlags : Enum {
    public int value__;
    public static BuildRequestDataFlags None;
    public static BuildRequestDataFlags ReplaceExistingProjectInstance;
    public static BuildRequestDataFlags ProvideProjectStateAfterBuild;
    public static BuildRequestDataFlags IgnoreExistingProjectState;
    public static BuildRequestDataFlags ClearCachesAfterBuild;
    public static BuildRequestDataFlags SkipNonexistentTargets;
    public static BuildRequestDataFlags ProvideSubsetOfStateAfterBuild;
    public static BuildRequestDataFlags IgnoreMissingEmptyAndInvalidImports;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Execution.BuildResult : object {
    private int _submissionId;
    private int _configurationId;
    private int _globalRequestId;
    private int _parentGlobalRequestId;
    private int _nodeRequestId;
    private List`1<string> _initialTargets;
    private List`1<string> _defaultTargets;
    private ConcurrentDictionary`2<string, TargetResult> _resultsByTarget;
    private bool _circularDependency;
    private Exception _requestException;
    private bool _baseOverallResult;
    private Dictionary`2<string, string> _savedEnvironmentVariables;
    private string _savedCurrentDirectory;
    private ProjectInstance _projectStateAfterBuild;
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int GlobalRequestId { get; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; }
    public Exception Exception { get; internal set; }
    public bool CircularDependency { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public ProjectInstance ProjectStateAfterBuild { get; public set; }
    private NodePacketType Microsoft.Build.BackEnd.INodePacket.Type { get; }
    private Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.SavedEnvironmentVariables { get; private set; }
    private string Microsoft.Build.BackEnd.IBuildResults.SavedCurrentDirectory { get; private set; }
    internal List`1<string> InitialTargets { get; internal set; }
    internal List`1<string> DefaultTargets { get; internal set; }
    internal bool ResultBelongsToRootRequest { get; }
    public ITargetResult Item { get; }
    internal BuildResult(BuildRequest request);
    internal BuildResult(BuildRequest request, Exception exception);
    internal BuildResult(BuildRequest request, bool circularDependency);
    internal BuildResult(BuildResult existingResults, String[] targetNames);
    internal BuildResult(BuildRequest request, BuildResult existingResults, Exception exception);
    internal BuildResult(BuildRequest request, BuildResult existingResults, String[] targetNames, List`1<string> additionalTargetsToCheck, Exception exception);
    internal BuildResult(BuildResult result, int nodeRequestId);
    private BuildResult(INodePacketTranslator translator);
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
internal void set_Exception(Exception value);
    [DebuggerStepThroughAttribute]
public bool get_CircularDependency();
    public sealed virtual BuildResultCode get_OverallResult();
    [DebuggerStepThroughAttribute]
public sealed virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public ProjectInstance get_ProjectStateAfterBuild();
    public void set_ProjectStateAfterBuild(ProjectInstance value);
    [DebuggerStepThroughAttribute]
private sealed virtual override NodePacketType Microsoft.Build.BackEnd.INodePacket.get_Type();
    private sealed virtual override Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.get_SavedEnvironmentVariables();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildResults.get_SavedCurrentDirectory();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedCurrentDirectory(string value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_InitialTargets();
    [DebuggerStepThroughAttribute]
internal void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_DefaultTargets();
    [DebuggerStepThroughAttribute]
internal void set_DefaultTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal bool get_ResultBelongsToRootRequest();
    [DebuggerStepThroughAttribute]
public sealed virtual ITargetResult get_Item(string target);
    public void AddResultsForTarget(string target, TargetResult result);
    public void MergeResults(BuildResult results);
    public sealed virtual bool HasResultsForTarget(string target);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static BuildResult FactoryForDeserialization(INodePacketTranslator translator);
    internal void CacheIfPossible();
    internal void ClearCachedFiles();
    internal BuildResult Clone();
    internal void SetOverallResult(bool overallResult);
    private static ConcurrentDictionary`2<string, TargetResult> CreateTargetResultDictionary(int capacity);
    private static ConcurrentDictionary`2<string, TargetResult> CreateTargetResultDictionaryWithContents(BuildResult existingResults, String[] targetNames);
}
public enum Microsoft.Build.Execution.BuildResultCode : Enum {
    public int value__;
    public static BuildResultCode Success;
    public static BuildResultCode Failure;
}
public class Microsoft.Build.Execution.BuildSubmission : object {
    private BuildSubmissionCompleteCallback _completionCallback;
    private ManualResetEvent _completionEvent;
    [CompilerGeneratedAttribute]
private bool <LoggingCompleted>k__BackingField;
    private int _completionInvoked;
    private bool _legacyThreadingSemantics;
    [CompilerGeneratedAttribute]
private BuildManager <BuildManager>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubmissionId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AsyncContext>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestData <BuildRequestData>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequest <BuildRequest>k__BackingField;
    internal bool LoggingCompleted { get; private set; }
    public BuildManager BuildManager { get; }
    public int SubmissionId { get; }
    public object AsyncContext { get; private set; }
    public WaitHandle WaitHandle { get; }
    public bool IsCompleted { get; }
    public BuildResult BuildResult { get; public set; }
    internal BuildRequestData BuildRequestData { get; }
    internal BuildRequest BuildRequest { get; internal set; }
    internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics);
    [CompilerGeneratedAttribute]
internal bool get_LoggingCompleted();
    [CompilerGeneratedAttribute]
private void set_LoggingCompleted(bool value);
    [CompilerGeneratedAttribute]
public BuildManager get_BuildManager();
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    [CompilerGeneratedAttribute]
public object get_AsyncContext();
    [CompilerGeneratedAttribute]
private void set_AsyncContext(object value);
    public WaitHandle get_WaitHandle();
    public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
public void set_BuildResult(BuildResult value);
    [CompilerGeneratedAttribute]
internal BuildRequestData get_BuildRequestData();
    [CompilerGeneratedAttribute]
internal BuildRequest get_BuildRequest();
    [CompilerGeneratedAttribute]
internal void set_BuildRequest(BuildRequest value);
    public BuildResult Execute();
    public void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context);
    internal void CompleteResults(BuildResult result);
    internal void CompleteLogging(bool waitForLoggingThread);
    private void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context, bool allowMainThreadBuild);
    private void CheckForCompletion();
    [CompilerGeneratedAttribute]
private void <CheckForCompletion>g__Callback|39_0(object state);
}
public class Microsoft.Build.Execution.BuildSubmissionCompleteCallback : MulticastDelegate {
    public BuildSubmissionCompleteCallback(object object, IntPtr method);
    public virtual void Invoke(BuildSubmission submission);
    public virtual IAsyncResult BeginInvoke(BuildSubmission submission, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("#Entries={_hostObjectMap.Count}")]
public class Microsoft.Build.Execution.HostServices : object {
    private Dictionary`2<string, HostObjects> _hostObjectMap;
    private Dictionary`2<string, NodeAffinity> _projectAffinities;
    public ITaskHost GetHostObject(string projectFile, string targetName, string taskName);
    public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject);
    public void UnregisterProject(string projectFullPath);
    public NodeAffinity GetNodeAffinity(string projectFile);
    public void SetNodeAffinity(string projectFile, NodeAffinity nodeAffinity);
    public void OnRenameProject(string oldFullPath, string newFullPath);
    internal bool HasHostObject(string projectFile);
    private NodeAffinity GetNodeAffinity(string projectFile, Boolean& isExplicit);
}
public interface Microsoft.Build.Execution.ITargetResult {
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual ITaskItem[] get_Items();
    public abstract virtual TargetResultCode get_ResultCode();
}
internal class Microsoft.Build.Execution.LegacyThreadingData : object {
    private IDictionary`2<int, Tuple`2<AutoResetEvent, ManualResetEvent>> _legacyThreadingEventsById;
    private int _mainThreadSubmissionId;
    private RequestBuilder _instanceForMainThread;
    private object _legacyThreadingEventsLock;
    internal RequestBuilder InstanceForMainThread { get; internal set; }
    internal int MainThreadSubmissionId { get; internal set; }
    internal RequestBuilder get_InstanceForMainThread();
    internal void set_InstanceForMainThread(RequestBuilder value);
    internal int get_MainThreadSubmissionId();
    internal void set_MainThreadSubmissionId(int value);
    internal void RegisterSubmissionForLegacyThread(int submissionId);
    internal void UnregisterSubmissionForLegacyThread(int submissionId);
    internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submissionId);
    internal Task GetLegacyThreadInactiveTask(int submissionId);
    internal void SignalLegacyThreadStart(RequestBuilder instance);
    internal void SignalLegacyThreadEnd(int submissionId);
}
public enum Microsoft.Build.Execution.NodeAffinity : Enum {
    public int value__;
    public static NodeAffinity InProc;
    public static NodeAffinity OutOfProc;
    public static NodeAffinity Any;
}
public enum Microsoft.Build.Execution.NodeEngineShutdownReason : Enum {
    public int value__;
    public static NodeEngineShutdownReason BuildComplete;
    public static NodeEngineShutdownReason BuildCompleteReuse;
    public static NodeEngineShutdownReason ConnectionFailed;
    public static NodeEngineShutdownReason Error;
}
public class Microsoft.Build.Execution.OutOfProcNode : object {
    private static bool s_isOutOfProcNode;
    private static ProjectRootElementCache s_projectRootElementCache;
    private NodeEndpointOutOfProc _nodeEndpoint;
    private IDictionary`2<string, string> _savedEnvironment;
    private BuildComponentFactoryCollection _componentFactories;
    private BuildParameters _buildParameters;
    private ILoggingService _loggingService;
    private NodeLoggingContext _loggingContext;
    private IConfigCache _globalConfigCache;
    private INodeManager _taskHostNodeManager;
    private IBuildRequestEngine _buildRequestEngine;
    private NodePacketFactory _packetFactory;
    private NodeConfiguration _currentConfiguration;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private AutoResetEvent _packetReceivedEvent;
    private ManualResetEvent _shutdownEvent;
    private NodeEngineShutdownReason _shutdownReason;
    private Exception _shutdownException;
    private bool _debugCommunications;
    private LegacyThreadingData _legacyThreadingData;
    private ISdkResolverService _sdkResolverService;
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    internal static bool IsOutOfProcNode { get; }
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    internal static bool get_IsOutOfProcNode();
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    public NodeEngineShutdownReason Run(bool enableReuse, Exception& shutdownException);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, INodePacketTranslator translator);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RoutePacket(int nodeId, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    private void OnRequestComplete(BuildRequest request, BuildResult result);
    private void OnNewRequest(BuildRequestBlocker blocker);
    private void OnNewConfigurationRequest(BuildRequestConfiguration config);
    private void OnLoggingThreadException(Exception e);
    private void OnEngineException(Exception e);
    private NodeEngineShutdownReason HandleShutdown(Exception& exception);
    private void CleanupCaches();
    private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void SendPacket(INodePacket packet);
    private void HandlePacket(INodePacket packet);
    private void HandleBuildRequest(BuildRequest request);
    private void HandleBuildRequestConfiguration(BuildRequestConfiguration configuration);
    private void HandleBuildRequestConfigurationResponse(BuildRequestConfigurationResponse response);
    private void HandleBuildRequestUnblocker(BuildRequestUnblocker unblocker);
    private void HandleNodeConfiguration(NodeConfiguration configuration);
    private void HandleNodeBuildComplete(NodeBuildComplete buildComplete);
}
[DebuggerDisplayAttribute("{FullPath} #Targets={TargetsCount} DefaultTargets={(DefaultTargets == null) ? System.String.Empty : System.String.Join(";", DefaultTargets.ToArray())} ToolsVersion={Toolset.ToolsVersion} InitialTargets={(InitialTargets == null) ? System.String.Empty : System.String.Join(";", InitialTargets.ToArray())} #GlobalProperties={GlobalProperties.Count} #Properties={Properties.Count} #ItemTypes={ItemTypes.Count} #Items={Items.Count}")]
public class Microsoft.Build.Execution.ProjectInstance : object {
    private RetrievableEntryHashSet`1<ProjectTargetInstance> _actualTargets;
    private IDictionary`2<string, ProjectTargetInstance> _targets;
    private List`1<string> _defaultTargets;
    private List`1<string> _initialTargets;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private ISet`1<string> _globalPropertiesToTreatAsLocal;
    private bool _explicitToolsVersionSpecified;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentVariableProperties;
    private ItemDictionary`1<ProjectItemInstance> _items;
    private MultiDictionary`2<string, ProjectItemInstance> _itemsByEvaluatedInclude;
    private string _directory;
    private ElementLocation _projectFileLocation;
    private RetrievableEntryHashSet`1<ProjectItemDefinitionInstance> _itemDefinitions;
    private HostServices _hostServices;
    private bool _usingDifferentToolsVersionFromProjectFile;
    private string _originalProjectToolsVersion;
    private bool _isImmutable;
    private IDictionary`2<string, List`1<TargetSpecification>> _beforeTargets;
    private IDictionary`2<string, List`1<TargetSpecification>> _afterTargets;
    private Toolset _toolset;
    private string _subToolsetVersion;
    private TaskRegistry _taskRegistry;
    private bool _translateEntireState;
    private int _evaluationId;
    [CompilerGeneratedAttribute]
private List`1<ProjectItemElement> <EvaluatedItemElements>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCache <ProjectRootElementCache>k__BackingField;
    public IDictionary`2<string, string> GlobalProperties { get; }
    public string ToolsVersion { get; }
    public ICollection`1<string> ItemTypes { get; }
    private bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.CanEvaluateElementsWithFalseConditions { get; }
    public ICollection`1<ProjectPropertyInstance> Properties { get; }
    public ICollection`1<ProjectItemInstance> Items { get; }
    public List`1<ProjectItemElement> EvaluatedItemElements { get; private set; }
    public bool TranslateEntireState { get; public set; }
    public int EvaluationId { get; public set; }
    public string Directory { get; }
    public string FullPath { get; }
    public IDictionary`2<string, ProjectItemDefinitionInstance> ItemDefinitions { get; }
    public List`1<string> DefaultTargets { get; private set; }
    public List`1<string> InitialTargets { get; private set; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public bool IsImmutable { get; }
    private TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.TaskRegistry { get; private set; }
    private Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Toolset { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SubToolsetVersion { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ExplicitToolsVersion { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesDictionary { get; }
    private ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Properties { get; }
    private IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable { get; }
    private ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Items { get; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitialTargets { get; private set; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.DefaultTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.BeforeTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AfterTargets { get; private set; }
    private Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ConditionedProperties { get; }
    private bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ShouldEvaluateForDesignTime { get; }
    public ElementLocation ProjectFileLocation { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    internal Toolset Toolset { get; private set; }
    internal bool UsingDifferentToolsVersionFromProjectFile { get; }
    internal string OriginalProjectToolsVersion { get; }
    internal string ExplicitToolsVersion { get; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal string SubToolsetVersion { get; private set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> PropertiesToBuildWith { get; }
    internal ICollection`1<ProjectPropertyInstance> TestEnvironmentalProperties { get; }
    internal ItemDictionary`1<ProjectItemInstance> ItemsToBuildWith { get; }
    internal TaskRegistry TaskRegistry { get; private set; }
    internal int TargetsCount { get; }
    internal ProjectRootElementCache ProjectRootElementCache { get; private set; }
    internal bool IsLoaded { get; }
    public ProjectInstance(string projectFile);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    public ProjectInstance(ProjectRootElement xml);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFrom, IDictionary`2<string, string> globalProperties);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId);
    internal ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, Nullable`1<ProjectLoadSettings> projectLoadSettings);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId);
    internal ProjectInstance(Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary`1<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings);
    private ProjectInstance(INodePacketTranslator translator);
    private ProjectInstance(ProjectInstance that);
    private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProjectState filter);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_ItemTypes();
    private sealed virtual override bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_CanEvaluateElementsWithFalseConditions();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyInstance> get_Properties();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemInstance> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ProjectItemElement> get_EvaluatedItemElements();
    [CompilerGeneratedAttribute]
private void set_EvaluatedItemElements(List`1<ProjectItemElement> value);
    public bool get_TranslateEntireState();
    public void set_TranslateEntireState(bool value);
    public sealed virtual int get_EvaluationId();
    public sealed virtual void set_EvaluationId(int value);
    [DebuggerStepThroughAttribute]
public sealed virtual string get_Directory();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectItemDefinitionInstance> get_ItemDefinitions();
    public List`1<string> get_DefaultTargets();
    private void set_DefaultTargets(List`1<string> value);
    public List`1<string> get_InitialTargets();
    private void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public bool get_IsImmutable();
    [DebuggerStepThroughAttribute]
private sealed virtual override TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_TaskRegistry();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_TaskRegistry(TaskRegistry value);
    [DebuggerStepThroughAttribute]
private sealed virtual override Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Toolset();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_SubToolsetVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ExplicitToolsVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesDictionary();
    private sealed virtual override ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesToTreatAsLocal();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Properties();
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ItemDefinitionsEnumerable();
    [DebuggerStepThroughAttribute]
private sealed virtual override ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Items();
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_InitialTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_DefaultTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_DefaultTargets(List`1<string> value);
    private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_BeforeTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_AfterTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    private sealed virtual override Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ConditionedProperties();
    private sealed virtual override bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ShouldEvaluateForDesignTime();
    public ElementLocation get_ProjectFileLocation();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    internal Toolset get_Toolset();
    private void set_Toolset(Toolset value);
    internal bool get_UsingDifferentToolsVersionFromProjectFile();
    internal string get_OriginalProjectToolsVersion();
    internal string get_ExplicitToolsVersion();
    internal bool get_ExplicitToolsVersionSpecified();
    internal string get_SubToolsetVersion();
    private void set_SubToolsetVersion(string value);
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_PropertiesToBuildWith();
    internal ICollection`1<ProjectPropertyInstance> get_TestEnvironmentalProperties();
    [DebuggerStepThroughAttribute]
internal ItemDictionary`1<ProjectItemInstance> get_ItemsToBuildWith();
    internal TaskRegistry get_TaskRegistry();
    private void set_TaskRegistry(TaskRegistry value);
    internal int get_TargetsCount();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
private void set_ProjectRootElementCache(ProjectRootElementCache value);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item);
    public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum);
    public static string GetMetadataValueEscaped(ProjectItemInstance item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name);
    public static string GetPropertyValueEscaped(ProjectPropertyInstance property);
    private sealed virtual override ICollection`1<ProjectItemInstance> Microsoft.Build.Evaluation.IItemProvider<Microsoft.Build.Execution.ProjectItemInstance>.GetItems(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitializeForEvaluation(IToolsetProvider toolsetProvider);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.FinishEvaluation();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItem(ProjectItemInstance item);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemIgnoringCondition(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemDefinition(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedPropertiesList(ProjectPropertyInstance property);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadataInstance itemDefinitionMetadatum);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemsList(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetItemDefinition(string itemType);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, ProjectPropertyInstance predecessor);
    private sealed virtual override ProjectTargetInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetTarget(string targetName);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddTarget(ProjectTargetInstance target);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectPropertyInstance GetProperty(string name);
    [DebuggerStepThroughAttribute]
private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IPropertyProvider<Microsoft.Build.Execution.ProjectPropertyInstance>.GetProperty(string name, int startIndex, int endIndex);
    public string GetPropertyValue(string name);
    public ProjectPropertyInstance SetProperty(string name, string evaluatedValue);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItemInstance> GetItems(string itemType);
    [IteratorStateMachineAttribute("Microsoft.Build.Execution.ProjectInstance/<GetItemsByItemTypeAndEvaluatedInclude>d__175")]
public IEnumerable`1<ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude);
    public bool RemoveItem(ProjectItemInstance item);
    public bool RemoveProperty(string name);
    public ProjectInstance DeepCopy();
    public ProjectInstance FilteredCopy(RequestedProjectState filter);
    public ProjectInstance DeepCopy(bool isImmutable);
    public bool Build();
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IDictionary`2& targetOutputs);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, IDictionary`2& targetOutputs);
    public sealed virtual string ExpandString(string unexpandedValue);
    public sealed virtual bool EvaluateCondition(string condition);
    public ProjectRootElement ToProjectRootElement();
    public void UpdateStateFrom(ProjectInstance projectState);
    internal bool get_IsLoaded();
    internal void LateInitialize(ProjectRootElementCache projectRootElementCache, HostServices hostServices);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal void TranslateMinimalState(INodePacketTranslator translator);
    private void TranslateAllState(INodePacketTranslator translator);
    private void TranslateToolsetSpecificState(INodePacketTranslator translator);
    private void TranslateProperties(INodePacketTranslator translator);
    private void TranslateTargets(INodePacketTranslator translator);
    private static void TranslatorForTargetSpecificDictionaryKey(String& key, INodePacketTranslator translator);
    private static void TranslatorForTargetSpecificDictionaryValue(List`1& value, INodePacketTranslator translator);
    private void TranslateItems(INodePacketTranslator translator);
    internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary`1<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    internal static ProjectInstance FactoryForDeserialization(INodePacketTranslator translator);
    internal static void VerifyThrowNotImmutable(bool isImmutable);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, int maxNodeCount, IDictionary`2& targetOutputs);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, IDictionary`2& targetOutputs);
    internal IList`1<TargetSpecification> GetTargetsWhichRunBefore(string target);
    internal IList`1<TargetSpecification> GetTargetsWhichRunAfter(string target);
    internal void Cache(INodePacketTranslator translator);
    internal void RetrieveFromCache(INodePacketTranslator translator);
    internal ProjectTargetInstance AddTarget(string targetName, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, bool parentProjectSupportsReturnsAttribute);
    internal void RemoveTarget(string targetName);
    internal void VerifyThrowNotImmutable();
    private static ProjectInstance[] GenerateSolutionWrapper(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, BuildEventContext projectBuildEventContext, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectRootElementCache projectRootElementCache, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, ISdkResolverService sdkResolverService, int submissionId);
    private static ReadOnlyDictionary`2<string, TValue> CreateCloneDictionary(IDictionary`2<string, TValue> dictionary, StringComparer strComparer);
    private static IDictionary`2<string, TValue> CreateCloneDictionary(IDictionary`2<string, TValue> dictionary);
    private void Initialize(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string explicitToolsVersion, string explicitSubToolsetVersion, int visualStudioVersionFromSolution, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, Nullable`1<ProjectLoadSettings> projectLoadSettings);
    private IEnumerable`1<ProjectItemInstance> GetItemsByEvaluatedInclude(string evaluatedInclude);
    private void CreateTargetsSnapshot(Data data);
    private void CreateEnvironmentVariablePropertiesSnapshot(PropertyDictionary`1<ProjectPropertyInstance> environmentVariableProperties);
    private void CreateGlobalPropertiesSnapshot(Data data);
    private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, Data data, Dictionary`2<ProjectItem, ProjectItemInstance> projectItemToInstanceMap);
    private Dictionary`2<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Data data, bool keepEvaluationCache);
    private void CreateItemDefinitionsSnapshot(Data data);
    private void CreatePropertiesSnapshot(Data data, bool isImmutable);
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.ProjectInstanceSettings : Enum {
    public int value__;
    public static ProjectInstanceSettings None;
    public static ProjectInstanceSettings Immutable;
    public static ProjectInstanceSettings ImmutableWithFastItemLookup;
}
[DebuggerDisplayAttribute("{_itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Execution.ProjectItemDefinitionInstance : object {
    private string _itemType;
    private CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> _metadata;
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public ICollection`1<ProjectMetadataInstance> Metadata { get; }
    public int MetadataCount { get; }
    public IEnumerable`1<string> MetadataNames { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ProjectItemDefinitionInstance(ProjectInstance projectInstance, string itemType);
    internal ProjectItemDefinitionInstance(ProjectInstance projectInstance, ProjectItemDefinition itemDefinition);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public ICollection`1<ProjectMetadataInstance> get_Metadata();
    public int get_MetadataCount();
    [IteratorStateMachineAttribute("Microsoft.Build.Execution.ProjectItemDefinitionInstance/<get_MetadataNames>d__12")]
public IEnumerable`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor);
    internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElementContainer parent);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectItemDefinitionInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskInstance : ProjectTargetInstanceChild {
    private string _condition;
    private List`1<ProjectItemGroupTaskItemInstance> _items;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskItemInstance> Items { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, List`1<ProjectItemGroupTaskItemInstance> items);
    private ProjectItemGroupTaskInstance(ProjectItemGroupTaskInstance that);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskItemInstance> get_Items();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{_itemType} Include={_include} Exclude={_exclude} Remove={_remove} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance : object {
    private string _itemType;
    private string _include;
    private string _exclude;
    private string _remove;
    private string _keepMetadata;
    private string _removeMetadata;
    private string _keepDuplicates;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _includeLocation;
    private ElementLocation _excludeLocation;
    private ElementLocation _removeLocation;
    private ElementLocation _keepMetadataLocation;
    private ElementLocation _removeMetadataLocation;
    private ElementLocation _keepDuplicatesLocation;
    private ElementLocation _conditionLocation;
    private List`1<ProjectItemGroupTaskMetadataInstance> _metadata;
    public string ItemType { get; }
    public string Include { get; }
    public string Exclude { get; }
    public string Remove { get; }
    public string KeepMetadata { get; }
    public string RemoveMetadata { get; }
    public string KeepDuplicates { get; }
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskMetadataInstance> Metadata { get; }
    public ElementLocation Location { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskItemInstance(string itemType, string include, string exclude, string remove, string keepMetadata, string removeMetadata, string keepDuplicates, string condition, ElementLocation location, ElementLocation includeLocation, ElementLocation excludeLocation, ElementLocation removeLocation, ElementLocation keepMetadataLocation, ElementLocation removeMetadataLocation, ElementLocation keepDuplicatesLocation, ElementLocation conditionLocation, List`1<ProjectItemGroupTaskMetadataInstance> metadata);
    private ProjectItemGroupTaskItemInstance(ProjectItemGroupTaskItemInstance that);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    [DebuggerStepThroughAttribute]
public string get_Include();
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    [DebuggerStepThroughAttribute]
public string get_Remove();
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskMetadataInstance> get_Metadata();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_IncludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ExcludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicatesLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskItemInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectItemGroupTaskItemInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{_name} Value={_value} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance : object {
    private string _name;
    private string _value;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    private ProjectItemGroupTaskMetadataInstance(ProjectItemGroupTaskMetadataInstance that);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskMetadataInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectItemGroupTaskMetadataInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
public class Microsoft.Build.Execution.ProjectItemInstance : object {
    private ProjectInstance _project;
    private string _itemType;
    private TaskItem _taskItem;
    [DebuggerBrowsableAttribute("0")]
public ProjectInstance Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public string EvaluatedInclude { get; public set; }
    private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public IEnumerable`1<ProjectMetadataInstance> Metadata { get; }
    public int DirectMetadataCount { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    public ICollection`1<string> MetadataNames { get; }
    private string Microsoft.Build.Framework.ITaskItem.ItemSpec { get; private set; }
    private ICollection Microsoft.Build.Framework.ITaskItem.MetadataNames { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    internal static IEqualityComparer`1<ProjectItemInstance> EqualityComparer { get; }
    internal string ProjectFullPath { get; }
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> directMetadata, List`1<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, IEnumerable`1<KeyValuePair`2<string, string>> directMetadata, string definingFileEscaped);
    private ProjectItemInstance(ProjectItemInstance that);
    private ProjectItemInstance(ProjectItemInstance that, ProjectInstance newProject);
    private ProjectItemInstance(ProjectInstance projectInstance);
    public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public IEnumerable`1<ProjectMetadataInstance> get_Metadata();
    public int get_DirectMetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    public ICollection`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.get_ItemSpec();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.set_ItemSpec(string value);
    private sealed virtual override ICollection Microsoft.Build.Framework.ITaskItem.get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    internal static IEqualityComparer`1<ProjectItemInstance> get_EqualityComparer();
    internal string get_ProjectFullPath();
    public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    public ProjectMetadataInstance SetMetadata(string name, string evaluatedValue);
    public void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataDictionary);
    public sealed virtual void RemoveMetadata(string metadataName);
    public virtual string ToString();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItem<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string name);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(ITaskItem destinationItem);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata();
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override ProjectItemInstance Microsoft.Build.Collections.IDeepCloneable<Microsoft.Build.Execution.ProjectItemInstance>.DeepClone();
    internal static void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataList, IEnumerable`1<ProjectItemInstance> items);
    internal static ProjectItemInstance FactoryForDeserialization(INodePacketTranslator translator, ProjectInstance projectInstance);
    internal void SetMetadata(CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> metadataDictionary);
    internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped);
    internal ProjectItemInstance DeepClone();
    internal ProjectItemInstance DeepClone(ProjectInstance newProject);
    internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent);
    private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> directMetadata, List`1<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped);
}
[DebuggerDisplayAttribute("{_name}={EvaluatedValue}")]
public class Microsoft.Build.Execution.ProjectMetadataInstance : object {
    private string _name;
    private string _escapedValue;
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadataInstance(string name, string escapedValue);
    internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers);
    internal ProjectMetadataInstance(ProjectMetadata metadatum);
    private ProjectMetadataInstance(INodePacketTranslator translator);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>.Equals(ProjectMetadataInstance other);
    public sealed virtual ProjectMetadataInstance DeepClone();
    internal static ProjectMetadataInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("ExecuteTargets={_executeTargets} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectOnErrorInstance : ProjectTargetInstanceChild {
    private string _executeTargets;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _executeTargetsLocation;
    public string Condition { get; }
    public string ExecuteTargets { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorInstance(string executeTargets, string condition, ElementLocation location, ElementLocation executeTargetsLocation, ElementLocation conditionLocation);
    public virtual string get_Condition();
    public string get_ExecuteTargets();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ExecuteTargetsLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectOnErrorInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance : ProjectTargetInstanceChild {
    private string _condition;
    private List`1<ProjectPropertyGroupTaskPropertyInstance> _properties;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Condition { get; }
    public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> Properties { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, List`1<ProjectPropertyGroupTaskPropertyInstance> properties);
    private ProjectPropertyGroupTaskInstance(ProjectPropertyGroupTaskInstance that);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> get_Properties();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{_name}={Value} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance : object {
    private string _name;
    private string _value;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    private ProjectPropertyGroupTaskPropertyInstance(ProjectPropertyGroupTaskPropertyInstance that);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskPropertyInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectPropertyGroupTaskPropertyInstance FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("{_name}={_escapedValue}")]
public class Microsoft.Build.Execution.ProjectPropertyInstance : object {
    private string _name;
    private string _escapedValue;
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; public set; }
    public bool IsImmutable { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    private ProjectPropertyInstance(string name, string escapedValue);
    public sealed virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedValue(string value);
    public virtual bool get_IsImmutable();
    private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(ProjectPropertyInstance other);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Collections.IDeepCloneable<Microsoft.Build.Execution.ProjectPropertyInstance>.DeepClone();
    public virtual string ToString();
    internal static ProjectPropertyInstance Create(string name, string escapedValue);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location, bool isImmutable);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable);
    internal static ProjectPropertyInstance FactoryForDeserialization(INodePacketTranslator translator);
    internal ProjectPropertyInstance DeepClone();
    internal ProjectPropertyInstance DeepClone(bool isImmutable);
    internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer parent);
    private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable);
}
[DebuggerDisplayAttribute("Name={_name} Count={_children.Count} Condition={_condition} Inputs={_inputs} Outputs={_outputs} DependsOnTargets={_dependsOnTargets}")]
public class Microsoft.Build.Execution.ProjectTargetInstance : object {
    private string _name;
    private string _condition;
    private string _inputs;
    private string _outputs;
    private string _returns;
    private string _dependsOnTargets;
    private string _keepDuplicateOutputs;
    private ReadOnlyCollection`1<ProjectOnErrorInstance> _onErrorChildren;
    private bool _parentProjectSupportsReturnsAttribute;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _inputsLocation;
    private ElementLocation _outputsLocation;
    private ElementLocation _returnsLocation;
    private ElementLocation _keepDuplicateOutputsLocation;
    private ElementLocation _dependsOnTargetsLocation;
    private ElementLocation _beforeTargetsLocation;
    private ElementLocation _afterTargetsLocation;
    private IList`1<ProjectTargetInstanceChild> _children;
    public string Name { get; }
    public string Condition { get; }
    public string Inputs { get; }
    public string Outputs { get; }
    public string Returns { get; }
    public string KeepDuplicateOutputs { get; }
    public string DependsOnTargets { get; }
    public IList`1<ProjectTargetInstanceChild> Children { get; }
    public IList`1<ProjectOnErrorInstance> OnErrorChildren { get; }
    public ICollection`1<ProjectTaskInstance> Tasks { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal bool ParentProjectSupportsReturnsAttribute { get; }
    internal ProjectTargetInstance(string name, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, ElementLocation location, ElementLocation conditionLocation, ElementLocation inputsLocation, ElementLocation outputsLocation, ElementLocation returnsLocation, ElementLocation keepDuplicateOutputsLocation, ElementLocation dependsOnTargetsLocation, ElementLocation beforeTargetsLocation, ElementLocation afterTargetsLocation, ReadOnlyCollection`1<ProjectTargetInstanceChild> children, ReadOnlyCollection`1<ProjectOnErrorInstance> onErrorChildren, bool parentProjectSupportsReturnsAttribute);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    [DebuggerStepThroughAttribute]
public string get_Returns();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectTargetInstanceChild> get_Children();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectOnErrorInstance> get_OnErrorChildren();
    public ICollection`1<ProjectTaskInstance> get_Tasks();
    public string get_FullPath();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_InputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_OutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ReturnsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicateOutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_DependsOnTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_BeforeTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_AfterTargetsLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
internal bool get_ParentProjectSupportsReturnsAttribute();
    internal ProjectTargetElement ToProjectTargetElement(ProjectRootElement rootElement);
    internal void AddProjectTargetInstanceChild(ProjectTargetInstanceChild projectTargetInstanceChild);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectTargetInstance FactoryForDeserialization(INodePacketTranslator translator);
}
public abstract class Microsoft.Build.Execution.ProjectTargetInstanceChild : object {
    public string Condition { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public string get_FullPath();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_ConditionLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectTargetInstanceChild FactoryForDeserialization(INodePacketTranslator translator);
}
[DebuggerDisplayAttribute("Name={_name} Condition={_condition} ContinueOnError={_continueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Parameters={_parameters.Count} #Outputs={_outputs.Count}")]
public class Microsoft.Build.Execution.ProjectTaskInstance : ProjectTargetInstanceChild {
    private string _name;
    private string _condition;
    private string _continueOnError;
    private string _msbuildRuntime;
    private string _msbuildArchitecture;
    private CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> _parameters;
    private List`1<ProjectTaskInstanceChild> _outputs;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _continueOnErrorLocation;
    private ElementLocation _msbuildRuntimeLocation;
    private ElementLocation _msbuildArchitectureLocation;
    public string Name { get; }
    public string Condition { get; }
    public string ContinueOnError { get; }
    public string MSBuildRuntime { get; }
    public string MSBuildArchitecture { get; }
    public IDictionary`2<string, string> Parameters { get; }
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> TestGetParameters { get; }
    public IList`1<ProjectTaskInstanceChild> Outputs { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> ParametersForBuild { get; }
    internal ProjectTaskInstance(ProjectTaskElement element, IList`1<ProjectTaskInstanceChild> outputs);
    internal ProjectTaskInstance(string name, ElementLocation location, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
    internal ProjectTaskInstance(string name, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture, CopyOnWriteDictionary`2<string, Tuple`2<string, ElementLocation>> parameters, List`1<ProjectTaskInstanceChild> outputs, ElementLocation location, ElementLocation conditionLocation, ElementLocation continueOnErrorElementLocation, ElementLocation msbuildRuntimeLocation, ElementLocation msbuildArchitectureLocation);
    public string get_Name();
    public virtual string get_Condition();
    public string get_ContinueOnError();
    public string get_MSBuildRuntime();
    public string get_MSBuildArchitecture();
    public IDictionary`2<string, string> get_Parameters();
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> get_TestGetParameters();
    public IList`1<ProjectTaskInstanceChild> get_Outputs();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal IDictionary`2<string, Tuple`2<string, ElementLocation>> get_ParametersForBuild();
    internal string GetParameter(string parameterName);
    internal void SetParameter(string parameterName, string unevaluatedValue);
    internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition);
    internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private static void ParametersKeyTranslator(String& key, INodePacketTranslator translator);
    private static void ParametersValueTranslator(Tuple`2& value, INodePacketTranslator translator);
    internal static ProjectTaskInstance FactoryForDeserialization(INodePacketTranslator translator);
}
public abstract class Microsoft.Build.Execution.ProjectTaskInstanceChild : object {
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_TaskParameterLocation();
    public abstract virtual ElementLocation get_ConditionLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static ProjectTaskInstanceChild FactoryForDeserialization(INodePacketTranslator translator);
}
public class Microsoft.Build.Execution.ProjectTaskOutputItemInstance : ProjectTaskInstanceChild {
    private string _itemType;
    private string _taskParameter;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _itemTypeLocation;
    private ElementLocation _taskParameterLocation;
    private ElementLocation _conditionLocation;
    public string ItemType { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_ItemType();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
    public ElementLocation get_ItemTypeLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
}
public class Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild {
    private string _propertyName;
    private string _taskParameter;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _propertyNameLocation;
    private ElementLocation _taskParameterLocation;
    private ElementLocation _conditionLocation;
    public string PropertyName { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_PropertyName();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public ElementLocation get_PropertyNameLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
}
internal class Microsoft.Build.Execution.ReflectableTaskPropertyInfo : TaskPropertyInfo {
    private PropertyInfo _propertyInfo;
    private Type _taskType;
    internal PropertyInfo Reflection { get; }
    internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType);
    internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo);
    internal PropertyInfo get_Reflection();
}
public class Microsoft.Build.Execution.RequestedProjectState : object {
    private List`1<string> _propertyFilters;
    private IDictionary`2<string, List`1<string>> _itemFilters;
    public List`1<string> PropertyFilters { get; public set; }
    public IDictionary`2<string, List`1<string>> ItemFilters { get; public set; }
    public List`1<string> get_PropertyFilters();
    public void set_PropertyFilters(List`1<string> value);
    public IDictionary`2<string, List`1<string>> get_ItemFilters();
    public void set_ItemFilters(IDictionary`2<string, List`1<string>> value);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    private static IDictionary`2<string, List`1<string>> CreateItemMetadataDictionary(int capacity);
    private static void TranslateMetadataForItem(List`1& list, INodePacketTranslator translator);
    private static void TranslateString(String& s, INodePacketTranslator translator);
}
public class Microsoft.Build.Execution.TargetResult : object {
    private WorkUnitResult _result;
    private bool _targetFailureDoesntCauseBuildFailure;
    private ItemsStore _itemsStore;
    private CacheInfo _cacheInfo;
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    internal WorkUnitResult WorkUnitResult { get; }
    internal bool TargetFailureDoesntCauseBuildFailure { get; internal set; }
    internal TargetResult(TaskItem[] items, WorkUnitResult result);
    private TargetResult(INodePacketTranslator translator);
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
public sealed virtual ITaskItem[] get_Items();
    [DebuggerStepThroughAttribute]
public sealed virtual TargetResultCode get_ResultCode();
    [DebuggerStepThroughAttribute]
internal WorkUnitResult get_WorkUnitResult();
    [DebuggerStepThroughAttribute]
internal bool get_TargetFailureDoesntCauseBuildFailure();
    [DebuggerStepThroughAttribute]
internal void set_TargetFailureDoesntCauseBuildFailure(bool value);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static TargetResult FactoryForDeserialization(INodePacketTranslator translator);
    internal static string GetCacheFile(int configId, string targetToCache);
    internal static string GetCacheDirectory(int configId, string targetToCache);
    internal void CacheItems(int configId, string targetName);
    private void InternalTranslate(INodePacketTranslator translator);
    private void RetrieveItemsFromCache();
    private static INodePacketTranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction);
}
public enum Microsoft.Build.Execution.TargetResultCode : Enum {
    public byte value__;
    public static TargetResultCode Skipped;
    public static TargetResultCode Success;
    public static TargetResultCode Failure;
}
internal class Microsoft.Build.Execution.TaskFactoryWrapper : object {
    private ITaskFactory _taskFactory;
    private IDictionary`2<string, string> _namesOfPropertiesWithRequiredAttribute;
    private IDictionary`2<string, string> _namesOfPropertiesWithOutputAttribute;
    private IDictionary`2<string, string> _namesOfPropertiesWithAmbiguousMatches;
    private IDictionary`2<string, TaskPropertyInfo> _propertyInfoCache;
    private string _taskName;
    private IDictionary`2<string, string> _factoryIdentityParameters;
    [CompilerGeneratedAttribute]
private LoadedType <TaskFactoryLoadedType>k__BackingField;
    public LoadedType TaskFactoryLoadedType { get; private set; }
    public ITaskFactory TaskFactory { get; }
    public IDictionary`2<string, string> GetNamesOfPropertiesWithRequiredAttribute { get; }
    public IDictionary`2<string, string> GetNamesOfPropertiesWithOutputAttribute { get; }
    public string Name { get; }
    public IDictionary`2<string, string> FactoryIdentityParameters { get; }
    internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary`2<string, string> factoryIdentityParameters);
    [CompilerGeneratedAttribute]
public LoadedType get_TaskFactoryLoadedType();
    [CompilerGeneratedAttribute]
private void set_TaskFactoryLoadedType(LoadedType value);
    public ITaskFactory get_TaskFactory();
    public IDictionary`2<string, string> get_GetNamesOfPropertiesWithRequiredAttribute();
    public IDictionary`2<string, string> get_GetNamesOfPropertiesWithOutputAttribute();
    public string get_Name();
    public IDictionary`2<string, string> get_FactoryIdentityParameters();
    public TaskPropertyInfo GetProperty(string propertyName);
    internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value);
    internal object GetPropertyValue(ITask task, TaskPropertyInfo property);
    internal bool IsCreatableByFactory(string taskName);
    private void PopulatePropertyInfoCacheIfNecessary();
}
internal class Microsoft.Build.Execution.TaskRegistry : object {
    private Toolset _toolset;
    private static bool s_forceTaskHostLaunch;
    private static string s_tasksV4SimpleName;
    private static string s_tasksV4Filename;
    private static string s_potentialTasksV4Location;
    private static string s_tasksV12SimpleName;
    private static string s_tasksV12Filename;
    private static string s_potentialTasksV12Location;
    private static string s_tasksCoreSimpleName;
    private static string s_tasksCoreFilename;
    private static string s_potentialTasksCoreLocation;
    private Dictionary`2<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch;
    private Dictionary`2<string, HybridDictionary`2<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
    private Dictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> _taskRegistrations;
    [CompilerGeneratedAttribute]
private ProjectRootElementCache <RootElementCache>k__BackingField;
    internal ProjectRootElementCache RootElementCache { get; internal set; }
    internal Toolset Toolset { get; }
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> TaskRegistrations { get; }
    internal bool IsLoaded { get; }
    internal TaskRegistry(ProjectRootElementCache projectRootElementCache);
    internal TaskRegistry(Toolset toolset, ProjectRootElementCache projectRootElementCache);
    private static TaskRegistry();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCache get_RootElementCache();
    [CompilerGeneratedAttribute]
internal void set_RootElementCache(ProjectRootElementCache value);
    [DebuggerStepThroughAttribute]
internal Toolset get_Toolset();
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> get_TaskRegistrations();
    internal bool get_IsLoaded();
    internal static void RegisterTasksFromUsingTaskElement(ILoggingService loggingService, BuildEventContext buildEventContext, string directoryOfImportingFile, ProjectUsingTaskElement projectUsingTaskXml, TaskRegistry taskRegistry, Expander`2<P, I> expander, ExpanderOptions expanderOptions, IFileSystem fileSystem);
    private static Dictionary`2<string, string> CreateTaskFactoryParametersDictionary(Nullable`1<int> initialCount);
    internal TaskFactoryWrapper GetRegisteredTask(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    internal RegisteredTaskRecord GetTaskRegistrationRecord(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, Boolean& retrievedFromCache);
    private static bool IsTaskFactoryClass(Type type, object unused);
    private Dictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> GetRelevantRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired);
    private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary`2<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTaskRecord);
    private static Dictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(Nullable`1<int> capacity);
    private RegisteredTaskRecord GetMatchingRegistration(string taskName, List`1<RegisteredTaskRecord> taskRecords, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    public sealed virtual void Translate(INodePacketTranslator translator);
    private void TranslateTaskRegistrationKey(RegisteredTaskIdentity& taskIdentity, INodePacketTranslator translator);
    private void TranslateTaskRegistrationValue(List`1& taskRecords, INodePacketTranslator translator);
    public static TaskRegistry FactoryForDeserialization(INodePacketTranslator translator);
}
public class Microsoft.Build.Globbing.CompositeGlob : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IMSBuildGlob> <Globs>k__BackingField;
    public IEnumerable`1<IMSBuildGlob> Globs { get; }
    public CompositeGlob(IEnumerable`1<IMSBuildGlob> globs);
    public CompositeGlob(IMSBuildGlob[] globs);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IMSBuildGlob> get_Globs();
    public sealed virtual bool IsMatch(string stringToMatch);
}
[ExtensionAttribute]
public static class Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MSBuildGlob> GetParsedGlobs(IMSBuildGlob glob);
}
public interface Microsoft.Build.Globbing.IMSBuildGlob {
    public abstract virtual bool IsMatch(string stringToMatch);
}
public class Microsoft.Build.Globbing.MSBuildGlob : object {
    private Lazy`1<GlobState> _state;
    internal string TestOnlyGlobRoot { get; }
    internal string TestOnlyFileSpec { get; }
    internal bool TestOnlyNeedsRecursion { get; }
    public string FixedDirectoryPart { get; }
    public string WildcardDirectoryPart { get; }
    public string FilenamePart { get; }
    public bool IsLegal { get; }
    private MSBuildGlob(Lazy`1<GlobState> state);
    internal string get_TestOnlyGlobRoot();
    internal string get_TestOnlyFileSpec();
    internal bool get_TestOnlyNeedsRecursion();
    public string get_FixedDirectoryPart();
    public string get_WildcardDirectoryPart();
    public string get_FilenamePart();
    public bool get_IsLegal();
    public sealed virtual bool IsMatch(string stringToMatch);
    public MatchInfoResult MatchInfo(string stringToMatch);
    private string NormalizeMatchInput(string stringToMatch);
    public static MSBuildGlob Parse(string globRoot, string fileSpec);
    private static string NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(string fixedDirPart, string globRoot);
    public static MSBuildGlob Parse(string fileSpec);
}
public class Microsoft.Build.Globbing.MSBuildGlobWithGaps : object {
    [CompilerGeneratedAttribute]
private IMSBuildGlob <MainGlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildGlob <Gaps>k__BackingField;
    public IMSBuildGlob MainGlob { get; }
    public IMSBuildGlob Gaps { get; }
    public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable`1<IMSBuildGlob> gaps);
    public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob[] gaps);
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_MainGlob();
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_Gaps();
    public sealed virtual bool IsMatch(string stringToMatch);
}
internal abstract class Microsoft.Build.Globbing.Visitor.GlobVisitor : object {
    public void Visit(IMSBuildGlob glob);
    protected virtual void VisitGlobWithGaps(MSBuildGlobWithGaps globWithGaps);
    protected virtual void VisitCompositeGlob(CompositeGlob compositGlob);
    protected virtual void VisitMSBuildGlob(MSBuildGlob msbuildGlob);
}
internal class Microsoft.Build.Globbing.Visitor.ParsedGlobCollector : GlobVisitor {
    private Builder<MSBuildGlob> _collectedGlobs;
    public ImmutableList`1<MSBuildGlob> CollectedGlobs { get; }
    public ImmutableList`1<MSBuildGlob> get_CollectedGlobs();
    protected virtual void VisitMSBuildGlob(MSBuildGlob msbuildGlob);
}
internal static class Microsoft.Build.Internal.AvailableStaticMethods : object {
    private static ConcurrentDictionary`2<string, Tuple`2<string, Type>> s_availableStaticMethods;
    private static object s_locker;
    private static AvailableStaticMethods();
    internal static bool ContainsKey(string key);
    internal static bool TryAdd(string key, Tuple`2<string, Type> value);
    public static bool TryAdd(string typeFullName, string simpleMethodName, Tuple`2<string, Type> typeInformation);
    internal static bool TryGetValue(string key, Tuple`2& value);
    internal static Tuple`2<string, Type> GetValue(string key);
    internal static Tuple`2<string, Type> GetTypeInformationFromTypeCache(string typeFullName, string simpleMethodName);
    private static string CreateQualifiedMethodName(string typeFullName, string simpleMethodName);
    internal static void Reset_ForUnitTestsOnly();
    private static void InitializeAvailableMethods();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.CommunicationsUtilities : object {
    private static int DefaultNodeConnectionTimeout;
    private static bool s_fileVersionChecked;
    private static int s_fileVersionHash;
    private static bool s_trace;
    private static string s_debugDumpPath;
    private static long s_lastLoggedTicks;
    internal static int NodeConnectionTimeout { get; }
    private static int FileVersionHash { get; }
    private static CommunicationsUtilities();
    internal static int get_NodeConnectionTimeout();
    private static int get_FileVersionHash();
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static Dictionary`2<string, string> GetEnvironmentVariables();
    internal static void SetEnvironment(IDictionary`2<string, string> newEnvironment);
    internal static long GenerateHostHandshakeFromBase(long baseHandshake, long clientHandshake);
    internal static long GetTaskHostHostHandshake(TaskHostContext hostContext);
    internal static long GetTaskHostClientHandshake(TaskHostContext hostContext);
    [ExtensionAttribute]
internal static void WriteLongForHandshake(PipeStream stream, long value);
    [ExtensionAttribute]
internal static long ReadLongForHandshake(PipeStream stream, int handshakeReadTimeout);
    [ExtensionAttribute]
internal static long ReadLongForHandshake(PipeStream stream, Byte[] leadingBytesToReject, byte rejectionByteToReturn, int timeout);
    [AsyncStateMachineAttribute("Microsoft.Build.Internal.CommunicationsUtilities/<ReadAsync>d__21")]
internal static Task`1<int> ReadAsync(Stream stream, Byte[] buffer, int bytesToRead);
    internal static TaskHostContext GetTaskHostContext(IDictionary`2<string, string> taskHostParameters);
    internal static TaskHostContext GetTaskHostContext(bool is64BitProcess, int clrVersion);
    internal static TaskHostContext GetCurrentTaskHostContext();
    internal static int GetIntegerVariableOrDefault(string environmentVariable, int defaultValue);
    internal static void Trace(string format, Object[] args);
    internal static void Trace(int nodeId, string format, Object[] args);
    private static long GetBaseHandshakeForContext(TaskHostContext hostContext);
    private static int GetHandshakeHashCode(string fileVersion);
}
internal static class Microsoft.Build.Internal.Constants : object {
    internal static string defaultToolsVersion;
    internal static string defaultFallbackToolsVersion;
    internal static string defaultSolutionWrapperProjectToolsVersion;
    internal static string VisualStudioVersionPropertyName;
    internal static string SubToolsetVersionPropertyName;
    internal static string Dev10SubToolsetValue;
    internal static long assemblyTimestamp;
    internal static string programFilesx86;
    internal static string AssemblyVersion { get; }
    internal static long AssemblyTimestamp { get; }
    private static Constants();
    internal static string get_AssemblyVersion();
    internal static long get_AssemblyTimestamp();
}
internal class Microsoft.Build.Internal.EngineFileUtilities : object {
    private FileMatcher _fileMatcher;
    private static List`1<Regex> s_lazyWildCardExpansionRegexes;
    public static EngineFileUtilities Default;
    private static Lazy`1<ConcurrentDictionary`2<string, bool>> _regexMatchCache;
    private static EngineFileUtilities();
    public EngineFileUtilities(FileMatcher fileMatcher);
    internal static void CaptureLazyWildcardRegexes();
    internal String[] GetFileListUnescaped(string directoryEscaped, string filespecEscaped, bool forceEvaluate);
    internal String[] GetFileListEscaped(string directoryEscaped, string filespecEscaped, IEnumerable`1<string> excludeSpecsEscaped, bool forceEvaluate);
    internal static bool FilespecHasWildcards(string filespecEscaped);
    private String[] GetFileList(string directoryEscaped, string filespecEscaped, bool returnEscaped, bool forceEvaluateWildCards, IEnumerable`1<string> excludeSpecsEscaped);
    private static bool FilespecMatchesLazyWildcard(string filespecEscaped, bool forceEvaluateWildCards);
    private static bool IsValidExclude(string exclude);
    private static List`1<Regex> PopulateRegexFromEnvironment();
    private static bool MatchesLazyWildcard(string fileSpec);
    internal static Func`2<string, bool> GetFileSpecMatchTester(IList`1<string> filespecsEscaped, string currentDirectory);
}
internal class Microsoft.Build.Internal.FileSpecMatcherTester : ValueType {
    private string _currentDirectory;
    private string _unescapedFileSpec;
    private Regex _regex;
    private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex);
    public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec);
    public bool IsMatch(string fileToMatch);
    private static Regex CreateRegex(string unescapedFileSpec, string currentDirectory);
}
internal class Microsoft.Build.Internal.MSBuildAssemblyFileVersion : object {
    private static Lazy`1<MSBuildAssemblyFileVersion> MSBuildAssemblyFileVersionLazy;
    [CompilerGeneratedAttribute]
private string <MajorMinorBuild>k__BackingField;
    public static MSBuildAssemblyFileVersion Instance { get; }
    public string MajorMinorBuild { get; public set; }
    private MSBuildAssemblyFileVersion(string majorMinorBuild);
    private static MSBuildAssemblyFileVersion();
    public static MSBuildAssemblyFileVersion get_Instance();
    [CompilerGeneratedAttribute]
public string get_MajorMinorBuild();
    [CompilerGeneratedAttribute]
public void set_MajorMinorBuild(string value);
    private static MSBuildAssemblyFileVersion GetMSBuildAssemblyFileVersion();
}
internal static class Microsoft.Build.Internal.ProjectXmlUtilities : object {
    internal static XmlElementChildIterator GetVerifyThrowProjectChildElements(XmlElementWithLocation element);
    private static XmlElementChildIterator GetChildElements(XmlElementWithLocation element, bool throwForInvalidNodeTypes);
    internal static void VerifyThrowProjectNoChildElements(XmlElementWithLocation element);
    internal static void ThrowProjectInvalidChildElementDueToDuplicate(XmlElementWithLocation child);
    internal static void ThrowProjectInvalidChildElement(string name, string parentName, ElementLocation location);
    internal static bool VerifyValidProjectNamespace(XmlElementWithLocation element);
    internal static void VerifyThrowProjectAttributeEitherMissingOrNotEmpty(XmlElementWithLocation xmlElement, string attributeName);
    internal static void VerifyThrowProjectAttributeEitherMissingOrNotEmpty(XmlElementWithLocation xmlElement, XmlAttributeWithLocation attribute, string attributeName);
    internal static void VerifyThrowProjectNoAttributes(XmlElementWithLocation element);
    internal static void VerifyThrowProjectInvalidAttribute(bool condition, XmlAttributeWithLocation attribute);
    internal static void VerifyThrowProjectRequiredAttribute(XmlElementWithLocation element, string attributeName);
    internal static void VerifyThrowProjectAttributes(XmlElementWithLocation element, HashSet`1<string> validAttributes);
    internal static void ThrowProjectInvalidAttribute(XmlAttributeWithLocation attribute);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value, bool allowSettingEmptyAttributes);
    internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool nullIfNotExists);
}
internal static class Microsoft.Build.Internal.ReservedPropertyNames : object {
    internal static string projectDirectory;
    internal static string projectDirectoryNoRoot;
    internal static string projectFile;
    internal static string projectExtension;
    internal static string projectFullPath;
    internal static string projectName;
    internal static string thisFileDirectory;
    internal static string thisFileDirectoryNoRoot;
    internal static string thisFile;
    internal static string thisFileExtension;
    internal static string thisFileFullPath;
    internal static string thisFileName;
    internal static string binPath;
    internal static string projectDefaultTargets;
    internal static string extensionsPath;
    internal static string extensionsPath32;
    internal static string extensionsPath64;
    internal static string userExtensionsPath;
    internal static string toolsPath;
    internal static string toolsVersion;
    internal static string msbuildRuntimeType;
    internal static string overrideTasksPath;
    internal static string defaultOverrideToolsVersion;
    internal static string startupDirectory;
    internal static string buildNodeCount;
    internal static string lastTaskResult;
    internal static string extensionsPathSuffix;
    internal static string userExtensionsPathSuffix;
    internal static string programFiles32;
    internal static string localAppData;
    internal static string assemblyVersion;
    internal static string version;
    internal static string osName;
    internal static string frameworkToolsRoot;
    private static HashSet`1<string> ReservedProperties;
    private static ReservedPropertyNames();
    internal static bool IsReservedProperty(string property);
}
internal enum Microsoft.Build.Internal.TaskHostContext : Enum {
    public int value__;
    public static TaskHostContext X32CLR2;
    public static TaskHostContext X64CLR2;
    public static TaskHostContext X32CLR4;
    public static TaskHostContext X64CLR4;
    public static TaskHostContext Invalid;
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.Utilities : object {
    private static bool s_shouldTreatHigherToolsVersionsAsCurrent;
    private static bool s_shouldTreatOtherToolsVersionsAsCurrent;
    private static bool s_uselegacyDefaultToolsVersionBehavior;
    private static string s_defaultToolsVersionFromEnvironment;
    private static Regex s_xmlnsPattern;
    private static Utilities();
    internal static void RefreshInternalEnvironmentValues();
    internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string s);
    internal static string GetXmlNodeInnerContents(XmlElementWithLocation node);
    private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLessThan);
    internal static string RemoveXmlNamespace(string xml);
    internal static string CreateToolsVersionListString(IEnumerable`1<Toolset> toolsets);
    internal static string GenerateToolsVersionToUse(string explicitToolsVersion, string toolsVersionFromProject, GetToolset getToolset, string defaultToolsVersion, Boolean& usingDifferentToolsVersionFromProjectFile);
    private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersionFromProject, string toolsVersionToUse, bool explicitToolsVersionSpecified);
    internal static PropertyDictionary`1<ProjectPropertyInstance> GetEnvironmentProperties();
    [ExtensionAttribute]
public static int FastCountOrZero(IEnumerable enumerable);
    [IteratorStateMachineAttribute("Microsoft.Build.Internal.Utilities/<Values>d__16`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Values(IEnumerable`1<KeyValuePair`2<string, T>> source);
}
internal class Microsoft.Build.Internal.XmlReaderExtension : object {
    private static Encoding s_utf8NoBom;
    private Stream _stream;
    private StreamReader _streamReader;
    [CompilerGeneratedAttribute]
private XmlReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    internal XmlReader Reader { get; }
    internal Encoding Encoding { get; }
    private XmlReaderExtension(string file);
    private static XmlReaderExtension();
    internal static XmlReaderExtension Create(string filePath);
    [CompilerGeneratedAttribute]
internal XmlReader get_Reader();
    [CompilerGeneratedAttribute]
internal Encoding get_Encoding();
    public sealed virtual void Dispose();
    private static XmlReader GetXmlReader(string file, StreamReader input, Encoding& encoding);
    private static Encoding GetEncodingFromAttribute(XmlReader reader);
}
internal class Microsoft.Build.InterningBinaryReader : BinaryReader {
    private static int MaxCharsBuffer;
    private Buffer _buffer;
    private Decoder _decoder;
    private InterningBinaryReader(Stream input, Buffer buffer);
    public virtual string ReadString();
    internal static SharedReadBuffer CreateSharedBuffer();
    internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer);
}
public class Microsoft.Build.Logging.BinaryLogger : object {
    internal static int FileFormatVersion;
    private Stream stream;
    private BinaryWriter binaryWriter;
    private BuildEventArgsWriter eventArgsWriter;
    private ProjectImportsCollector projectImportsCollector;
    private string _initialTargetOutputLogging;
    private string _initialLogImports;
    [CompilerGeneratedAttribute]
private ProjectImportsCollectionMode <CollectProjectImports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public ProjectImportsCollectionMode CollectProjectImports { get; public set; }
    private string FilePath { get; private set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectImportsCollectionMode get_CollectProjectImports();
    [CompilerGeneratedAttribute]
public void set_CollectProjectImports(ProjectImportsCollectionMode value);
    [CompilerGeneratedAttribute]
private string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e);
    private void Write(BuildEventArgs e);
    private void CollectImports(BuildEventArgs e);
    private void ProcessParameters();
}
internal enum Microsoft.Build.Logging.BinaryLogRecordKind : Enum {
    public int value__;
    public static BinaryLogRecordKind EndOfFile;
    public static BinaryLogRecordKind BuildStarted;
    public static BinaryLogRecordKind BuildFinished;
    public static BinaryLogRecordKind ProjectStarted;
    public static BinaryLogRecordKind ProjectFinished;
    public static BinaryLogRecordKind TargetStarted;
    public static BinaryLogRecordKind TargetFinished;
    public static BinaryLogRecordKind TaskStarted;
    public static BinaryLogRecordKind TaskFinished;
    public static BinaryLogRecordKind Error;
    public static BinaryLogRecordKind Warning;
    public static BinaryLogRecordKind Message;
    public static BinaryLogRecordKind TaskCommandLine;
    public static BinaryLogRecordKind CriticalBuildMessage;
    public static BinaryLogRecordKind ProjectEvaluationStarted;
    public static BinaryLogRecordKind ProjectEvaluationFinished;
    public static BinaryLogRecordKind ProjectImported;
    public static BinaryLogRecordKind ProjectImportArchive;
    public static BinaryLogRecordKind TargetSkipped;
}
public class Microsoft.Build.Logging.BinaryLogReplayEventSource : EventArgsDispatcher {
    public void Replay(string sourceFilePath);
}
[FlagsAttribute]
internal enum Microsoft.Build.Logging.BuildEventArgsFieldFlags : Enum {
    public int value__;
    public static BuildEventArgsFieldFlags None;
    public static BuildEventArgsFieldFlags BuildEventContext;
    public static BuildEventArgsFieldFlags HelpHeyword;
    public static BuildEventArgsFieldFlags Message;
    public static BuildEventArgsFieldFlags SenderName;
    public static BuildEventArgsFieldFlags ThreadId;
    public static BuildEventArgsFieldFlags Timestamp;
    public static BuildEventArgsFieldFlags Subcategory;
    public static BuildEventArgsFieldFlags Code;
    public static BuildEventArgsFieldFlags File;
    public static BuildEventArgsFieldFlags ProjectFile;
    public static BuildEventArgsFieldFlags LineNumber;
    public static BuildEventArgsFieldFlags ColumnNumber;
    public static BuildEventArgsFieldFlags EndLineNumber;
    public static BuildEventArgsFieldFlags EndColumnNumber;
}
internal class Microsoft.Build.Logging.BuildEventArgsFields : object {
    [CompilerGeneratedAttribute]
private BuildEventArgsFieldFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildEventContext <BuildEventContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public BuildEventArgsFieldFlags Flags { get; public set; }
    public string Message { get; public set; }
    public BuildEventContext BuildEventContext { get; public set; }
    public int ThreadId { get; public set; }
    public string HelpKeyword { get; public set; }
    public string SenderName { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string Subcategory { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string ProjectFile { get; public set; }
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    [CompilerGeneratedAttribute]
public BuildEventArgsFieldFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(BuildEventArgsFieldFlags value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public BuildEventContext get_BuildEventContext();
    [CompilerGeneratedAttribute]
public void set_BuildEventContext(BuildEventContext value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_SenderName();
    [CompilerGeneratedAttribute]
public void set_SenderName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
}
internal class Microsoft.Build.Logging.BuildEventArgsReader : object {
    private BinaryReader binaryReader;
    private int fileFormatVersion;
    private static FieldInfo buildEventArgsFieldThreadId;
    private static FieldInfo buildEventArgsFieldSenderName;
    private static FieldInfo buildEventArgsFieldTimestamp;
    [CompilerGeneratedAttribute]
private Action`2<BinaryLogRecordKind, Byte[]> OnBlobRead;
    public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion);
    private static BuildEventArgsReader();
    [CompilerGeneratedAttribute]
internal void add_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [CompilerGeneratedAttribute]
internal void remove_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    public BuildEventArgs Read();
    private static bool IsBlob(BinaryLogRecordKind recordKind);
    private void ReadBlob(BinaryLogRecordKind kind);
    private BuildEventArgs ReadProjectImportedEventArgs();
    private BuildEventArgs ReadTargetSkippedEventArgs();
    private BuildEventArgs ReadBuildStartedEventArgs();
    private BuildEventArgs ReadBuildFinishedEventArgs();
    private BuildEventArgs ReadProjectEvaluationStartedEventArgs();
    private BuildEventArgs ReadProjectEvaluationFinishedEventArgs();
    private BuildEventArgs ReadProjectStartedEventArgs();
    private BuildEventArgs ReadProjectFinishedEventArgs();
    private BuildEventArgs ReadTargetStartedEventArgs();
    private BuildEventArgs ReadTargetFinishedEventArgs();
    private BuildEventArgs ReadTaskStartedEventArgs();
    private BuildEventArgs ReadTaskFinishedEventArgs();
    private BuildEventArgs ReadBuildErrorEventArgs();
    private BuildEventArgs ReadBuildWarningEventArgs();
    private BuildEventArgs ReadBuildMessageEventArgs();
    private BuildEventArgs ReadTaskCommandLineEventArgs();
    private BuildEventArgs ReadCriticalBuildMessageEventArgs();
    private void ReadDiagnosticFields(BuildEventArgsFields fields);
    private BuildEventArgsFields ReadBuildEventArgsFields();
    private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields fields);
    private ArrayList ReadPropertyList();
    private BuildEventContext ReadBuildEventContext();
    private Dictionary`2<string, string> ReadStringDictionary();
    private ITaskItem ReadItem();
    private IEnumerable ReadItems();
    private IEnumerable ReadItemList();
    private string ReadOptionalString();
    private string ReadString();
    private int ReadInt32();
    private long ReadInt64();
    private bool ReadBoolean();
    private DateTime ReadDateTime();
    private TimeSpan ReadTimeSpan();
    private int Read7BitEncodedInt(BinaryReader reader);
    private ProfiledLocation ReadProfiledLocation();
    private EvaluationLocation ReadEvaluationLocation();
}
internal class Microsoft.Build.Logging.BuildEventArgsWriter : object {
    private BinaryWriter binaryWriter;
    public BuildEventArgsWriter(BinaryWriter binaryWriter);
    public void Write(BuildEventArgs e);
    public void WriteBlob(BinaryLogRecordKind kind, Byte[] bytes);
    private void Write(BuildStartedEventArgs e);
    private void Write(BuildFinishedEventArgs e);
    private void Write(ProjectEvaluationStartedEventArgs e);
    private void Write(ProjectEvaluationFinishedEventArgs e);
    private void Write(ProjectStartedEventArgs e);
    private void Write(ProjectFinishedEventArgs e);
    private void Write(TargetStartedEventArgs e);
    private void Write(TargetFinishedEventArgs e);
    private void Write(TaskStartedEventArgs e);
    private void Write(TaskFinishedEventArgs e);
    private void Write(BuildErrorEventArgs e);
    private void Write(BuildWarningEventArgs e);
    private void Write(BuildMessageEventArgs e);
    private void Write(ProjectImportedEventArgs e);
    private void Write(TargetSkippedEventArgs e);
    private void Write(CriticalBuildMessageEventArgs e);
    private void Write(TaskCommandLineEventArgs e);
    private void WriteBuildEventArgsFields(BuildEventArgs e);
    private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags);
    private void WriteMessageFields(BuildMessageEventArgs e);
    private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e, BuildEventArgsFieldFlags flags);
    private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e);
    private void WriteItemList(IEnumerable items);
    private void WriteItems(IEnumerable items);
    private void Write(ITaskItem item);
    private void WriteProperties(IEnumerable properties);
    private void Write(BuildEventContext buildEventContext);
    private void Write(IEnumerable`1<KeyValuePair`2<TKey, TValue>> keyValuePairs);
    private void Write(BinaryLogRecordKind kind);
    private void Write(int value);
    private void Write(long value);
    private void Write7BitEncodedInt(BinaryWriter writer, int value);
    private void Write(Byte[] bytes);
    private void Write(bool boolean);
    private void Write(string text);
    private void WriteOptionalString(string text);
    private void Write(DateTime timestamp);
    private void Write(TimeSpan timeSpan);
    private void Write(EvaluationLocation item);
    private void Write(ProfiledLocation e);
}
public class Microsoft.Build.Logging.ColorResetter : MulticastDelegate {
    public ColorResetter(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ColorSetter : MulticastDelegate {
    public ColorSetter(object object, IntPtr method);
    public virtual void Invoke(ConsoleColor color);
    public virtual IAsyncResult BeginInvoke(ConsoleColor color, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ConfigurableForwardingLogger : object {
    private LoggerVerbosity _verbosity;
    private string _loggerParameters;
    private static Char[] s_parameterDelimiters;
    private static string BuildStartedEventDescription;
    private static string BuildFinishedEventDescription;
    private static string ProjectStartedEventDescription;
    private static string ProjectFinishedEventDescription;
    private static string ProjectEvaluationStartedEventDescription;
    private static string ProjectEvaluationFinishedEventDescription;
    private static string TargetStartedEventDescription;
    private static string TargetFinishedEventDescription;
    private static string TaskStartedEventDescription;
    private static string TaskFinishedEventDescription;
    private static string ErrorEventDescription;
    private static string WarningEventDescription;
    private static string HighMessageEventDescription;
    private static string NormalMessageEventDescription;
    private static string LowMessageEventDescription;
    private static string CustomEventDescription;
    private static string CommandLineDescription;
    private static string PerformanceSummaryDescription;
    private static string NoSummaryDescription;
    private static string ShowCommandLineDescription;
    private Dictionary`2<string, int> _forwardingTable;
    private IEventRedirector _buildEventRedirector;
    private bool _forwardingSetFromParameters;
    private bool _showSummary;
    private bool _showPerfSummary;
    private bool _showCommandLine;
    private int _nodeId;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    private static ConfigurableForwardingLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    private void InitializeForwardingTable();
    private void ParseParameters();
    private void ApplyParameter(string parameterName);
    public virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void SetForwardingBasedOnVerbosity();
    private void ResetLoggerState();
    public virtual void Shutdown();
    private void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    private void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    private void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    private void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    private void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    private void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    private void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    private void ErrorHandler(object sender, BuildErrorEventArgs e);
    private void WarningHandler(object sender, BuildWarningEventArgs e);
    private void MessageHandler(object sender, BuildMessageEventArgs e);
    private void CustomEventHandler(object sender, CustomBuildEventArgs e);
    private void BuildStatusHandler(object sender, BuildStatusEventArgs e);
    protected virtual void ForwardToCentralLogger(BuildEventArgs e);
    private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
}
public class Microsoft.Build.Logging.ConsoleLogger : object {
    private BaseConsoleLogger _consoleLogger;
    private int _numberOfProcessors;
    private LoggerVerbosity _verbosity;
    private WriteHandler _write;
    private ColorSetter _colorSet;
    private ColorResetter _colorReset;
    private string _parameters;
    private bool _skipProjectStartedText;
    private Nullable`1<bool> _showSummary;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public bool SkipProjectStartedText { get; public set; }
    public bool ShowSummary { get; public set; }
    protected WriteHandler WriteHandler { get; protected set; }
    public ConsoleLogger(LoggerVerbosity verbosity);
    public ConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    private void InitializeBaseConsoleLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public bool get_SkipProjectStartedText();
    public void set_SkipProjectStartedText(bool value);
    public bool get_ShowSummary();
    public void set_ShowSummary(bool value);
    protected WriteHandler get_WriteHandler();
    protected void set_WriteHandler(WriteHandler value);
    public void ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Shutdown();
    public void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public void ErrorHandler(object sender, BuildErrorEventArgs e);
    public void WarningHandler(object sender, BuildWarningEventArgs e);
    public void MessageHandler(object sender, BuildMessageEventArgs e);
    public void CustomEventHandler(object sender, CustomBuildEventArgs e);
}
public class Microsoft.Build.Logging.DistributedFileLogger : object {
    private FileLogger _nodeFileLogger;
    private IEventRedirector _buildEventRedirector;
    private int _nodeId;
    private string _logFile;
    private string _parameters;
    private static Char[] s_fileLoggerParameterDelimiters;
    private static Char[] s_fileLoggerParameterValueSplitCharacter;
    internal FileLogger InternalFilelogger { get; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    private static DistributedFileLogger();
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void ParseFileLoggerParameters();
    private void ApplyFileLoggerParameter(string parameterName, string parameterValue);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    internal FileLogger get_InternalFilelogger();
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
}
internal class Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer : object {
    public static EvaluationLocationIdAgnosticComparer Singleton;
    private static EvaluationLocationIdAgnosticComparer();
    public sealed virtual bool Equals(EvaluationLocation x, EvaluationLocation y);
    public sealed virtual int GetHashCode(EvaluationLocation obj);
}
public class Microsoft.Build.Logging.EventArgsDispatcher : object {
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    public void Dispatch(BuildEventArgs buildEvent);
}
public class Microsoft.Build.Logging.FileLogger : ConsoleLogger {
    private string _logFileName;
    private StreamWriter _fileWriter;
    private bool _append;
    private bool _autoFlush;
    private Encoding _encoding;
    private static Char[] s_fileLoggerParameterDelimiters;
    private static Char[] s_fileLoggerParameterValueSplitCharacter;
    private static FileLogger();
    public virtual void Initialize(IEventSource eventSource);
    private void FileLoggerBuildFinished(object sender, BuildFinishedEventArgs e);
    private void InitializeFileLogger(IEventSource eventSource, int nodeCount);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void Write(string text);
    public virtual void Shutdown();
    private void ParseFileLoggerParameters();
    private void ApplyFileLoggerParameter(string parameterName, string parameterValue);
}
public class Microsoft.Build.Logging.ForwardingLoggerRecord : object {
    [CompilerGeneratedAttribute]
private ILogger <CentralLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerDescription <ForwardingLoggerDescription>k__BackingField;
    public ILogger CentralLogger { get; private set; }
    public LoggerDescription ForwardingLoggerDescription { get; private set; }
    public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription);
    [CompilerGeneratedAttribute]
public ILogger get_CentralLogger();
    [CompilerGeneratedAttribute]
private void set_CentralLogger(ILogger value);
    [CompilerGeneratedAttribute]
public LoggerDescription get_ForwardingLoggerDescription();
    [CompilerGeneratedAttribute]
private void set_ForwardingLoggerDescription(LoggerDescription value);
}
public class Microsoft.Build.Logging.LoggerDescription : object {
    private static Func`3<Type, object, bool> s_forwardingLoggerClassFilter;
    private static Func`3<Type, object, bool> s_loggerClassFilter;
    private string _loggerClassName;
    private string _loggerSwitchParameters;
    private AssemblyLoadInfo _loggerAssembly;
    private LoggerVerbosity _verbosity;
    private int _loggerId;
    internal int LoggerId { get; internal set; }
    internal string Name { get; }
    public string LoggerSwitchParameters { get; }
    public LoggerVerbosity Verbosity { get; }
    public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, LoggerVerbosity verbosity);
    private static LoggerDescription();
    internal int get_LoggerId();
    internal void set_LoggerId(int value);
    internal string get_Name();
    public string get_LoggerSwitchParameters();
    public LoggerVerbosity get_Verbosity();
    internal IForwardingLogger CreateForwardingLogger();
    public ILogger CreateLogger();
    private ILogger CreateLogger(bool forwardingLogger);
    private static bool IsForwardingLoggerClass(Type type, object unused);
    private static bool IsLoggerClass(Type type, object unused);
    internal void ConvertPathsToFullPaths();
    internal void WriteToStream(BinaryWriter writer);
    internal void CreateFromStream(BinaryReader reader);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketTranslatable.Translate(INodePacketTranslator translator);
    internal static LoggerDescription FactoryForTranslation(INodePacketTranslator translator);
}
public class Microsoft.Build.Logging.ProfilerLogger : object {
    private ConcurrentQueue`1<ProfilerResult> _profiledResults;
    private Dictionary`2<EvaluationLocation, ProfiledLocation> _aggregatedLocations;
    [CompilerGeneratedAttribute]
private string <FileToLog>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string FileToLog { get; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public ProfilerLogger(string fileToLog);
    [CompilerGeneratedAttribute]
public string get_FileToLog();
    internal static ProfilerLogger CreateForTesting();
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    private void ProjectEvaluationFinishedRaised(object sender, BuildEventArgs e);
    internal ProfilerResult GetAggregatedResult(bool pruneSmallItems);
    private static void MergeItem(IDictionary`2<EvaluationLocation, EvaluationLocation> originalLocations, IDictionary`2<long, long> mergeMap, IDictionary`2<EvaluationLocation, ProfiledLocation> aggregatedLocations, KeyValuePair`2<EvaluationLocation, ProfiledLocation> pairToMerge);
    private static Dictionary`2<EvaluationLocation, ProfiledLocation> PruneSmallItems(IDictionary`2<EvaluationLocation, ProfiledLocation> aggregatedLocations);
    private static Nullable`1<long> FindBigEnoughParentId(IDictionary`2<long, Pair`2<EvaluationLocation, ProfiledLocation>> idTable, Nullable`1<long> parentId);
    private static bool IsTooSmall(ProfiledLocation profiledData);
    private static ProfiledLocation AggregateProfiledLocation(ProfiledLocation location, ProfiledLocation otherLocation);
    private void GenerateProfilerReport();
    [CompilerGeneratedAttribute]
private ProfiledLocation <GetAggregatedResult>b__18_1(ProfiledLocation profiledLocation, EvaluationLocation evaluationLocation);
}
internal class Microsoft.Build.Logging.ProjectImportsCollector : object {
    private FileStream _fileStream;
    private ZipArchive _zipArchive;
    [CompilerGeneratedAttribute]
private string <ArchiveFilePath>k__BackingField;
    private HashSet`1<string> _processedFiles;
    private Task _currentTask;
    public string ArchiveFilePath { get; public set; }
    public ProjectImportsCollector(string logFilePath, string sourcesArchiveExtension);
    [CompilerGeneratedAttribute]
public string get_ArchiveFilePath();
    [CompilerGeneratedAttribute]
public void set_ArchiveFilePath(string value);
    public void AddFile(string filePath);
    public void AddFileFromMemory(string filePath, string data);
    private void AddFileCore(string filePath);
    private void AddFileFromMemoryCore(string filePath, string data);
    private Stream OpenArchiveEntry(string filePath, DateTime lastWriteTime);
    private static string CalculateArchivePath(string filePath);
    public void Close();
}
public class Microsoft.Build.Logging.WriteHandler : MulticastDelegate {
    public WriteHandler(object object, IntPtr method);
    public virtual void Invoke(string message);
    public virtual IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.OpportunisticIntern : object {
    private static bool s_useSimpleConcurrency;
    private static int s_smallMruSize;
    private static int s_largeMruSize;
    private static int s_hugeMruSize;
    private static int s_smallMruThreshold;
    private static int s_largeMruThreshold;
    private static int s_hugeMruThreshold;
    private static int s_ginormousThreshold;
    private static BucketedPrioritizedStringList s_si;
    private static BucketedPrioritizedStringList s_whatIfInfinite;
    private static BucketedPrioritizedStringList s_whatIfDoubled;
    private static BucketedPrioritizedStringList s_whatIfHalved;
    private static BucketedPrioritizedStringList s_whatIfZero;
    private static OpportunisticIntern();
    internal static int AssignViaEnvironment(string env, int default);
    internal static void EnableStatisticsGathering();
    internal static string InternableToString(IInternable candidate);
    internal static string StringBuilderToString(StringBuilder candidate);
    internal static string CharArrayToString(Char[] candidate, int count);
    internal static string CharArrayToString(Char[] candidate, int startIndex, int count);
    internal static string InternStringIfPossible(string candidate);
    internal static void ReportStatistics();
}
internal abstract class Microsoft.Build.Shared.AssemblyLoadInfo : object {
    public string AssemblyName { get; }
    public string AssemblyFile { get; }
    internal string AssemblyLocation { get; }
    internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile);
    public abstract virtual string get_AssemblyName();
    public abstract virtual string get_AssemblyFile();
    internal abstract virtual string get_AssemblyLocation();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AssemblyLoadInfo other);
    public virtual bool Equals(object obj);
    public sealed virtual void Translate(INodePacketTranslator translator);
    public static AssemblyLoadInfo FactoryForTranslation(INodePacketTranslator translator);
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private bool considerRetargetableFlag;
    private AssemblyNameComparer(bool considerRetargetableFlag);
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    private AssemblyName asAssemblyName;
    private string asString;
    private bool isSimpleName;
    private bool hasProcessorArchitectureInFusionName;
    private bool immutable;
    private HashSet`1<AssemblyNameExtension> remappedFrom;
    private static AssemblyNameExtension s_unnamedAssembly;
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private AssemblyNameExtension(SerializationInfo info, StreamingContext context);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    [OnDeserializedAttribute]
private void SetRemappedFromDefaultAfterSerialization(StreamingContext sc);
    private void InitializeRemappedFrom();
    private void CreateAssemblyName();
    private void CreateFullName();
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    private int CompareBaseNameToImpl(AssemblyNameExtension that);
    private static int CompareBaseNamesStringWise(string asString1, string asString2);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Shared.AssemblyNameExtension>.Equals(AssemblyNameExtension other);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool considerRetargetableFlag);
    internal static bool CompareCultures(AssemblyName a, AssemblyName b);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal static bool ComparePublicKeyTokens(Byte[] aPKT, Byte[] bPKT);
    internal bool get_IsUnnamedAssembly();
    private static AssemblyName GetAssemblyNameFromDisplayName(string displayName);
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    private static ResourceManager s_msbuildExeResourceManager;
    private static ResourceManager s_resources;
    private static ResourceManager s_sharedResources;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static void RegisterMSBuildExeResources(ResourceManager manager);
    internal static string GetString(string name);
    internal static string GetStringLookingInMSBuildExeResourcesFirst(string name);
    private static string GetStringFromEngineResources(string name);
    private static string GetStringFromMSBuildExeResources(string name);
    internal static ResourceManager get_PrimaryResources();
    internal static ResourceManager get_SharedResources();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AssemblyUtilities : object {
    private static bool s_initialized;
    private static PropertyInfo s_assemblylocationProperty;
    private static MethodInfo s_cultureInfoGetCultureMethod;
    private static Lazy`1<CultureInfo[]> s_validCultures;
    private static Lazy`1<Assembly> s_entryAssembly;
    public static Assembly EntryAssembly { get; }
    private static AssemblyUtilities();
    public static Assembly get_EntryAssembly();
    public static string GetAssemblyLocation(Assembly assembly);
    [ExtensionAttribute]
public static AssemblyName CloneIfPossible(AssemblyName assemblyNameToClone);
    public static bool CultureInfoHasGetCultures();
    public static CultureInfo[] GetAllCultures();
    private static void Initialize();
    private static Assembly GetEntryAssembly();
    private static CultureInfo[] GetValidCultures();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AwaitExtensions : object {
    private static object s_staSchedulerSync;
    private static TaskScheduler s_staScheduler;
    internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance { get; }
    private static AwaitExtensions();
    internal static TaskScheduler get_OneSTAThreadPerTaskSchedulerInstance();
    [ExtensionAttribute]
internal static TaskAwaiter GetAwaiter(WaitHandle handle);
    [ExtensionAttribute]
internal static TaskAwaiter`1<int> GetAwaiter(WaitHandle[] handles);
    [ExtensionAttribute]
internal static Task ToTask(WaitHandle handle, int timeout);
    [ExtensionAttribute]
internal static Task`1<int> ToTask(WaitHandle[] handles, int timeout);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.BinaryWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteOptionalString(BinaryWriter writer, string value);
    [ExtensionAttribute]
public static void WriteTimestamp(BinaryWriter writer, DateTime timestamp);
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal class Microsoft.Build.Shared.BuildEventFileInfo : object {
    private string _file;
    private int _line;
    private int _column;
    private int _endLine;
    private int _endColumn;
    internal string File { get; }
    internal int Line { get; }
    internal int Column { get; }
    internal int EndLine { get; }
    internal int EndColumn { get; }
    internal BuildEventFileInfo(string file);
    internal BuildEventFileInfo(IElementLocation location);
    internal BuildEventFileInfo(string file, int line, int column);
    internal BuildEventFileInfo(string file, int line, int column, int endLine, int endColumn);
    internal BuildEventFileInfo(XmlException e);
    internal BuildEventFileInfo(string file, XmlException e);
    internal string get_File();
    internal int get_Line();
    internal int get_Column();
    internal int get_EndLine();
    internal int get_EndColumn();
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.CollectionHelpers : object {
    internal static List`1<T> RemoveNulls(List`1<T> inputs);
    [ExtensionAttribute]
internal static bool ContainsValueAndIsEqual(Dictionary`2<string, string> dictionary, string key, string value, StringComparison comparer);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static string ConvertByteArrayToHex(Byte[] bytes);
    internal static bool CanConvertStringToBool(string parameterValue);
    private static bool ValidBooleanTrue(string parameterValue);
    private static bool ValidBooleanFalse(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    private static bool ValidHexNumber(string number);
    private static bool ValidDecimalNumber(string number);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal class Microsoft.Build.Shared.CoreClrAssemblyLoader : object {
    private Dictionary`2<string, Assembly> _pathsToAssemblies;
    private Dictionary`2<string, Assembly> _namesToAssemblies;
    private HashSet`1<string> _dependencyPaths;
    private object _guard;
    private bool _resolvingHandlerHookedUp;
    private static String[] _extensions;
    private static Version _currentAssemblyVersion;
    private static HashSet`1<string> _wellKnownAssemblyNames;
    private static CoreClrAssemblyLoader();
    public void AddDependencyLocation(string fullPath);
    public Assembly LoadFromPath(string fullPath);
    private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyName assemblyName);
    private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName assemblyName);
    private Assembly LoadAndCache(string fullPath);
    private bool IsAssemblyAlreadyLoaded(string path);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal class Microsoft.Build.Shared.EncodingStringWriter : StringWriter {
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public EncodingStringWriter(Encoding encoding);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    private static Encoding s_currentOemEncoding;
    internal static Encoding CurrentSystemOemEncoding { get; }
    internal static Encoding get_CurrentSystemOemEncoding();
    [ExtensionAttribute]
internal static bool SimilarToEncoding(Encoding encoding1, Encoding encoding2);
    [ExtensionAttribute]
internal static bool IsUtf8Encoding(Encoding encoding);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream, Byte[] preamble);
    internal static bool FileStartsWithPreamble(string file);
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_throwExceptions;
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    private static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EscapingStringExtensions.EscapingStringExtensions : object {
    [ExtensionAttribute]
internal static string Unescape(string escapedString);
    [ExtensionAttribute]
internal static string Unescape(string escapedString, Boolean& escapingWasNecessary);
    [ExtensionAttribute]
internal static string Escape(string unescapedString);
    [ExtensionAttribute]
internal static bool ContainsEscapedWildcards(string escapedString);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    private static bool IsHexDigit(char character);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static String[] s_newLines;
    private static EventArgsFormatting();
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    private static String[] SplitStringOnNewLines(string s);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string dotdot;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    internal static Char[] directorySeparatorCharacters;
    internal static String[] directorySeparatorStrings;
    private static Lazy`1<ConcurrentDictionary`2<string, ImmutableArray`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, ImmutableArray`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, ImmutableArray`1<string>> fileEntryExpansionCache);
    public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, ImmutableArray`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    private static ImmutableArray`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static ImmutableArray`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__33")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__35")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    private static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, String& matchFileExpression, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsMatch(string input, string pattern, bool ignoreCase);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    internal String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    private static bool IsSlash(char c);
    private static int SkipCharacters(string aString, int startingIndex, Func`2<char, bool> jumpOverCharacter);
    internal static bool IsValidDriveChar(char value);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private String[] GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|49_0(char inputChar, char patternChar, int iIndex, int pIndex, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static bool <ComputeFileEnumerationCacheKey>g__FilespecIsAnAbsoluteGlobPointingOutsideOfProjectCone|54_0(string projectDirectory, string filespec);
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool DirectoryEntryExists(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <DirectoryEntryExists>b__3_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__4_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__5_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : object {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    private static Char[] Slashes;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    internal static string ExecutingAssemblyPath { get; }
    private static FileUtilities();
    internal static void ClearCacheDirectoryPath();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    private static bool IsUNCPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    private static Uri CreateUriFromPath(string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName);
    internal static string GetPathOfFileAbove(string file, string startingDirectory);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
    internal static string GetTemporaryDirectory(bool createDirectory);
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string dotNetFrameworkIdentifier;
    internal static Version dotNetFrameworkVersion11;
    internal static Version dotNetFrameworkVersion20;
    internal static Version dotNetFrameworkVersion30;
    internal static Version dotNetFrameworkVersion35;
    internal static Version dotNetFrameworkVersion40;
    internal static Version dotNetFrameworkVersion45;
    internal static Version dotNetFrameworkVersion451;
    internal static Version dotNetFrameworkVersion452;
    internal static Version dotNetFrameworkVersion46;
    internal static Version dotNetFrameworkVersion461;
    internal static Version dotNetFrameworkVersion462;
    internal static Version dotNetFrameworkVersion47;
    internal static Version dotNetFrameworkVersion471;
    internal static Version dotNetFrameworkVersion472;
    internal static Version visualStudioVersion100;
    internal static Version visualStudioVersion110;
    internal static Version visualStudioVersion120;
    internal static Version visualStudioVersion140;
    internal static Version visualStudioVersion150;
    internal static Version visualStudioVersionLatest;
    private static string dotNetFrameworkRegistryPath;
    private static string dotNetFrameworkSetupRegistryPath;
    private static string dotNetFrameworkSetupRegistryInstalledName;
    internal static string fullDotNetFrameworkRegistryKey;
    private static string dotNetFrameworkAssemblyFoldersRegistryPath;
    private static string referenceAssembliesRegistryValueName;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    private static string dotNetFrameworkVersionV11;
    private static string dotNetFrameworkRegistryKeyV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    private static string dotNetFrameworkVersionV20;
    private static string dotNetFrameworkRegistryKeyV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    private static string s_dotNetFrameworkRegistryKeyV30;
    private static string fallbackDotNetFrameworkSdkRegistryInstallPath;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    private static string s_dotNetFrameworkRegistryKeyV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    private static string ToolsVersionsRegistryPath;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    private static string s_fallbackDotNetFrameworkSdkInstallPath;
    private static string s_pathToV35ToolsInFallbackDotNetFrameworkSdk;
    private static string s_pathToV4ToolsInFallbackDotNetFrameworkSdk;
    private static DotNetFrameworkSpec[] s_dotNetFrameworkSpecs;
    private static VisualStudioSpec[] s_visualStudioSpecs;
    private static Tuple`2[0...,0...] s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools;
    private static IReadOnlyDictionary`2<Version, DotNetFrameworkSpec> s_dotNetFrameworkSpecDict;
    private static IReadOnlyDictionary`2<Version, VisualStudioSpec> s_visualStudioSpecDict;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    private static string FallbackDotNetFrameworkSdkInstallPath { get; }
    private static string PathToV35ToolsInFallbackDotNetFrameworkSdk { get; }
    private static string PathToV4ToolsInFallbackDotNetFrameworkSdk { get; }
    private static FrameworkLocationHelper();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    private static string get_FallbackDotNetFrameworkSdkInstallPath();
    private static string get_PathToV35ToolsInFallbackDotNetFrameworkSdk();
    private static string get_PathToV4ToolsInFallbackDotNetFrameworkSdk();
    internal static string GetDotNetFrameworkSdkRootRegistryKey(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkSdkInstallKeyValue(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkVersionFolderPrefix(Version dotNetFrameworkVersion);
    internal static string GetPathToWindowsSdk(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkReferenceAssemblies(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkSdkTools(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkSdk(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
    internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture);
    internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootPath, FrameworkName frameworkName);
    internal static string RemoveDirectories(string path, int numberOfLevelsToRemove);
    private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture);
    private static string GenerateReferenceAssemblyDirectory(string versionPrefix);
    private static VisualStudioSpec GetVisualStudioSpec(Version version);
    private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version);
    private static DotNetFrameworkSpec CreateDotNetFrameworkSpecForV4(Version version, Version visualStudioVersion);
    private static void RedirectVersionsIfNecessary(Version& dotNetFrameworkVersion, Version& visualStudioVersion);
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal interface Microsoft.Build.Shared.IElementLocation {
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual string get_LocationString();
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
    private static void ConsiderDebuggerLaunch(string message, Exception innerException);
    private static void LaunchDebugger(string message, string innerMessage);
    private static bool RunningTests();
}
internal static class Microsoft.Build.Shared.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
}
internal class Microsoft.Build.Shared.LoadedType : object {
    private Type _type;
    private AssemblyLoadInfo _assembly;
    private Nullable`1<bool> _hasLoadInSeparateAppDomainAttribute;
    private Nullable`1<bool> _hasSTAThreadAttribute;
    private Assembly _loadedAssembly;
    internal Type Type { get; }
    internal Assembly LoadedAssembly { get; }
    internal AssemblyLoadInfo Assembly { get; }
    internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo);
    internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly);
    public bool HasLoadInSeparateAppDomainAttribute();
    public bool HasSTAThreadAttribute();
    private void CheckForHardcodedSTARequirement();
    internal Type get_Type();
    internal Assembly get_LoadedAssembly();
    internal AssemblyLoadInfo get_Assembly();
}
internal enum Microsoft.Build.Shared.LoggingEventType : Enum {
    public int value__;
    public static LoggingEventType Invalid;
    public static LoggingEventType CustomEvent;
    public static LoggingEventType BuildErrorEvent;
    public static LoggingEventType BuildFinishedEvent;
    public static LoggingEventType BuildMessageEvent;
    public static LoggingEventType BuildStartedEvent;
    public static LoggingEventType BuildWarningEvent;
    public static LoggingEventType ProjectFinishedEvent;
    public static LoggingEventType ProjectStartedEvent;
    public static LoggingEventType TargetStartedEvent;
    public static LoggingEventType TargetFinishedEvent;
    public static LoggingEventType TaskStartedEvent;
    public static LoggingEventType TaskFinishedEvent;
    public static LoggingEventType TaskCommandLineEvent;
}
internal abstract class Microsoft.Build.Shared.LogMessagePacketBase : object {
    private static int s_defaultPacketVersion;
    private static Dictionary`2<LoggingEventType, MethodInfo> s_readMethodCache;
    private static Dictionary`2<LoggingEventType, MethodInfo> s_writeMethodCache;
    private static HashSet`1<string> s_customEventsLoaded;
    private static object s_lockObject;
    private TargetFinishedTranslator _targetFinishedTranslator;
    private LoggingEventType _eventType;
    private BuildEventArgs _buildEvent;
    private int _sinkId;
    public NodePacketType Type { get; }
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> NodeBuildEvent { get; }
    internal LoggingEventType EventType { get; }
    internal LogMessagePacketBase(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent, TargetFinishedTranslator targetFinishedTranslator);
    protected LogMessagePacketBase(INodePacketTranslator translator);
    private static LogMessagePacketBase();
    private static int GetDefaultPacketVersion();
    public sealed virtual NodePacketType get_Type();
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> get_NodeBuildEvent();
    internal LoggingEventType get_EventType();
    public sealed virtual void Translate(INodePacketTranslator translator);
    internal void WriteToStream(INodePacketTranslator translator);
    internal void ReadFromStream(INodePacketTranslator translator);
    private static Delegate CreateDelegateRobust(Type type, object firstArgument, MethodInfo methodInfo);
    private BuildEventArgs GetBuildEventArgFromId();
    private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg);
    private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, INodePacketTranslator translator);
    private void WriteExternalProjectFinishedEventToStream(ExternalProjectFinishedEventArgs externalProjectFinishedEventArgs, INodePacketTranslator translator);
    private void WriteExternalProjectStartedEventToStream(ExternalProjectStartedEventArgs externalProjectStartedEventArgs, INodePacketTranslator translator);
    private void WriteBuildWarningEventToStream(BuildWarningEventArgs buildWarningEventArgs, INodePacketTranslator translator);
    private void WriteBuildErrorEventToStream(BuildErrorEventArgs buildErrorEventArgs, INodePacketTranslator translator);
    private void WriteTaskCommandLineEventToStream(TaskCommandLineEventArgs taskCommandLineEventArgs, INodePacketTranslator translator);
    private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEventArgs, INodePacketTranslator translator);
    private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, INodePacketTranslator translator);
    private ExternalProjectFinishedEventArgs ReadExternalProjectFinishedEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
    private ExternalProjectStartedEventArgs ReadExternalProjectStartedEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
    private BuildWarningEventArgs ReadBuildWarningEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
    private BuildErrorEventArgs ReadTaskBuildErrorEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
    private TaskCommandLineEventArgs ReadTaskCommandLineEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
    private BuildMessageEventArgs ReadBuildMessageEventFromStream(INodePacketTranslator translator, string message, string helpKeyword, string senderName);
}
internal static class Microsoft.Build.Shared.MSBuildConstants : object {
    internal static string ToolsPath;
    internal static string ToolsPath64;
    internal static string SdksPath;
    internal static string TreatWarningsAsErrors;
    internal static string WarningsAsErrors;
    internal static string WarningsAsMessages;
    internal static string NuGetAssemblyPathEnvironmentVariableName;
    internal static string RestoreTargetName;
    internal static string CurrentVisualStudioVersion;
    internal static string CurrentToolsVersion;
    internal static string MSBuildDummyGlobalPropertyHeader;
    internal static Version CurrentToolsVersionAsVersion;
    internal static string CurrentAssemblyVersion;
    internal static string CurrentProductVersion { get; }
    private static MSBuildConstants();
    internal static string get_CurrentProductVersion();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_ACCESS_DENIED;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int MAX_PATH;
    private static string kernel32Dll;
    private static string mscoreeDLL;
    private static string WINDOWS_FILE_SYSTEM_REGISTRY_KEY;
    private static string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME;
    internal static IntPtr NullIntPtr;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static CharSet AutoOrUnicode;
    private static MaxPathLimits osMaxPathLimit;
    private static object osMaxPathLimitLock;
    private static bool s_isUnixLike;
    private static object IsMonoLock;
    private static Nullable`1<bool> _isMono;
    private static string s_frameworkBasePath;
    private static string s_frameworkCurrentPath;
    private static SystemInformationData _systemInformation;
    private static bool _systemInformationInitialized;
    private static object SystemInformationLock;
    private static Version s_threadErrorModeMinOsVersion;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_ATTRIBUTE_NORMAL;
    internal static UInt32 FILE_FLAG_OPEN_REPARSE_POINT;
    internal static UInt32 OPEN_EXISTING;
    internal static MaxPathLimits OSMaxPathLimit { get; }
    internal static bool IsUnixLike { get; }
    internal static bool IsLinux { get; }
    internal static bool IsBSD { get; }
    internal static bool IsMono { get; }
    internal static bool IsWindows { get; }
    internal static bool IsOSX { get; }
    internal static string OSName { get; }
    internal static string FrameworkCurrentPath { get; }
    internal static string FrameworkBasePath { get; }
    private static SystemInformationData SystemInformation { get; }
    internal static ProcessorArchitectures ProcessorArchitecture { get; }
    internal static ProcessorArchitectures ProcessorArchitectureNative { get; }
    private static NativeMethodsShared();
    internal static MaxPathLimits get_OSMaxPathLimit();
    private static void SetOSMaxPathLimit();
    private static bool IsMaxPathLimitLegacyWindows();
    private static bool IsLongPathsEnabledRegistry();
    internal static bool get_IsUnixLike();
    internal static bool get_IsLinux();
    internal static bool get_IsBSD();
    internal static bool get_IsMono();
    internal static bool get_IsWindows();
    internal static bool get_IsOSX();
    internal static string get_OSName();
    internal static string GetOSNameForExtensionsPath();
    internal static string get_FrameworkCurrentPath();
    internal static string get_FrameworkBasePath();
    private static SystemInformationData get_SystemInformation();
    internal static ProcessorArchitectures get_ProcessorArchitecture();
    internal static ProcessorArchitectures get_ProcessorArchitectureNative();
    internal static int SetErrorMode(int newMode);
    private static bool SetErrorMode_Win7AndNewer(int newMode, Int32& oldMode);
    private static int SetErrorMode_VistaAndOlder(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    private static DateTime GetContentLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static void KillTree(int processIdToKill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    private static int GetCurrentDirectoryWin32(int nBufferLength, Char* lpBuffer);
    internal static string GetFullPath(string path);
    private static int GetFullPathWin32(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static bool AreStringsEqual(Char* buffer, int len, string s);
    internal static void VerifyThrowWin32Result(int result);
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    private static UInt32 SearchPath(string path, string fileName, string extension, int numBufferChars, StringBuilder buffer, Int32[] filePart);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(IntPtr hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, Char* lpBuffer);
    internal static bool SetCurrentDirectoryWindows(string path);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    private static int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, PROCESS_BASIC_INFORMATION& pbi, int cb, Int32& pSize);
    private static bool GlobalMemoryStatusEx(MemoryStatus lpBuffer);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool GetFileTime(SafeFileHandle hFile, FILETIME& lpCreationTime, FILETIME& lpLastAccessTime, FILETIME& lpLastWriteTime);
    internal static bool CloseHandle(IntPtr hObject);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
    internal static bool DirectoryExists(string fullPath);
    internal static bool DirectoryExistsWindows(string fullPath);
    internal static bool FileExists(string fullPath);
    internal static bool FileExistsWindows(string fullPath);
    internal static bool FileOrDirectoryExists(string path);
    internal static bool FileOrDirectoryExistsWindows(string path);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T _value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
internal class Microsoft.Build.Shared.OutOfProcTaskHostTaskResult : object {
    [CompilerGeneratedAttribute]
private TaskCompleteType <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <FinalParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <TaskException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExceptionMessageArgs>k__BackingField;
    public TaskCompleteType Result { get; private set; }
    public IDictionary`2<string, object> FinalParameterValues { get; private set; }
    public Exception TaskException { get; private set; }
    public string ExceptionMessage { get; private set; }
    public String[] ExceptionMessageArgs { get; private set; }
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    [CompilerGeneratedAttribute]
public TaskCompleteType get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(TaskCompleteType value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_FinalParameterValues();
    [CompilerGeneratedAttribute]
private void set_FinalParameterValues(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Exception get_TaskException();
    [CompilerGeneratedAttribute]
private void set_TaskException(Exception value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public String[] get_ExceptionMessageArgs();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessageArgs(String[] value);
}
internal class Microsoft.Build.Shared.Pair`2 : ValueType {
    private TKey _key;
    private TValue _value;
    internal TKey Key { get; }
    internal TValue Value { get; }
    public Pair`2(TKey key, TValue value);
    internal TKey get_Key();
    internal TValue get_Value();
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
internal static class Microsoft.Build.Shared.ProjectErrorUtilities : object {
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    private static void ThrowInvalidProject(string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, Object[] args);
}
internal static class Microsoft.Build.Shared.ProjectFileErrorUtilities : object {
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
}
internal class Microsoft.Build.Shared.ProjectWriter : XmlTextWriter {
    internal static string itemTypeOrMetadataNameSpecification;
    internal static string itemFunctionNameSpecification;
    private static string itemVectorTransformSpecification;
    internal static Lazy`1<Regex> itemVectorTransformPattern;
    private static string itemVectorTransformRawSpecification;
    internal static Lazy`1<Regex> itemVectorTransformRawPattern;
    private bool _writeXmlDeclaration;
    private Encoding _documentEncoding;
    internal ProjectWriter(TextWriter w);
    internal ProjectWriter(string filename, Encoding encoding);
    private static ProjectWriter();
    internal void Initialize(XmlDocument project);
    internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementDeclaration);
    public virtual void WriteString(string text);
    public virtual void WriteStartDocument();
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReuseableStringBuilder : object {
    private StringBuilder _borrowedBuilder;
    private string _cachedString;
    private int _capacity;
    private static int MaxByCharCompareLength;
    public int Length { get; public set; }
    private char Microsoft.Build.OpportunisticIntern.IInternable.Item { get; }
    internal ReuseableStringBuilder(int capacity);
    public sealed virtual int get_Length();
    public void set_Length(int value);
    private sealed virtual override char Microsoft.Build.OpportunisticIntern.IInternable.get_Item(int index);
    private sealed virtual override string Microsoft.Build.OpportunisticIntern.IInternable.ExpensiveConvertToString();
    private sealed virtual override bool Microsoft.Build.OpportunisticIntern.IInternable.IsOrdinalEqualToStringOfSameLength(string other);
    private sealed virtual override bool Microsoft.Build.OpportunisticIntern.IInternable.ReferenceEquals(string other);
    public virtual string ToString();
    private sealed virtual override void System.IDisposable.Dispose();
    internal ReuseableStringBuilder Append(char value);
    internal ReuseableStringBuilder Append(string value);
    internal ReuseableStringBuilder Append(string value, int startIndex, int count);
    internal ReuseableStringBuilder Remove(int startIndex, int length);
    private void LazyPrepare();
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string aString, string oldValue, string newValue, StringComparison stringComparison);
}
internal static class Microsoft.Build.Shared.TaskLoader : object {
    internal static bool IsTaskClass(Type type, object unused);
    internal static ITask CreateTask(LoadedType loadedType, string taskName, string taskLocation, int taskLine, int taskColumn, LogError logError, bool isOutOfProc);
}
internal static class Microsoft.Build.Shared.ThreadPoolExtensions : object {
    internal static bool QueueThreadPoolWorkItemWithCulture(WaitCallback callback, CultureInfo culture, CultureInfo uiCulture);
}
internal class Microsoft.Build.Shared.TypeLoader : object {
    private static CoreClrAssemblyLoader s_coreClrAssemblyLoader;
    private static ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter;
    private static ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter;
    private Func`3<Type, object, bool> _isDesiredType;
    private static TypeLoader();
    internal TypeLoader(Func`3<Type, object, bool> isDesiredType);
    internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2);
    private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo);
    internal LoadedType Load(string typeName, AssemblyLoadInfo assembly);
    internal LoadedType ReflectionOnlyLoad(string typeName, AssemblyLoadInfo assembly);
    private LoadedType GetLoadedType(ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly);
    [CompilerGeneratedAttribute]
private AssemblyInfoToLoadedTypes <GetLoadedType>b__10_1(AssemblyLoadInfo _);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
internal class Microsoft.Build.Shared.VisualStudioInstance : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal Version Version { get; }
    internal string Path { get; }
    internal string Name { get; }
    internal VisualStudioInstance(string name, string path, Version version);
    [CompilerGeneratedAttribute]
internal Version get_Version();
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_Name();
}
internal class Microsoft.Build.Shared.VisualStudioLocationHelper : object {
    private static int REGDB_E_CLASSNOTREG;
    internal static IList`1<VisualStudioInstance> GetInstances();
}
internal static class Microsoft.Build.Shared.XMakeAttributes : object {
    internal static string condition;
    internal static string executeTargets;
    internal static string name;
    internal static string msbuildVersion;
    internal static string xmlns;
    internal static string defaultTargets;
    internal static string initialTargets;
    internal static string treatAsLocalProperty;
    internal static string dependsOnTargets;
    internal static string beforeTargets;
    internal static string afterTargets;
    internal static string include;
    internal static string exclude;
    internal static string remove;
    internal static string update;
    internal static string keepMetadata;
    internal static string removeMetadata;
    internal static string keepDuplicates;
    internal static string inputs;
    internal static string outputs;
    internal static string keepDuplicateOutputs;
    internal static string assemblyName;
    internal static string assemblyFile;
    internal static string taskName;
    internal static string continueOnError;
    internal static string project;
    internal static string taskParameter;
    internal static string itemName;
    internal static string propertyName;
    internal static string sdk;
    internal static string sdkName;
    internal static string sdkVersion;
    internal static string sdkMinimumVersion;
    internal static string toolsVersion;
    internal static string runtime;
    internal static string msbuildRuntime;
    internal static string architecture;
    internal static string msbuildArchitecture;
    internal static string taskFactory;
    internal static string parameterType;
    internal static string required;
    internal static string output;
    internal static string defaultValue;
    internal static string evaluate;
    internal static string label;
    internal static string returns;
    internal static string requiredRuntime;
    internal static string requiredPlatform;
    internal static string defaultXmlNamespace;
    private static HashSet`1<string> KnownSpecialTaskAttributes;
    private static HashSet`1<string> KnownSpecialTaskAttributesIgnoreCase;
    private static HashSet`1<string> KnownBatchingTargetAttributes;
    private static HashSet`1<string> ValidMSBuildRuntimeValues;
    private static HashSet`1<string> ValidMSBuildArchitectureValues;
    private static XMakeAttributes();
    internal static bool IsSpecialTaskAttribute(string attribute);
    internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute);
    internal static bool IsNonBatchingTargetAttribute(string attribute);
    internal static bool IsValidMSBuildRuntimeValue(string runtime);
    internal static bool IsValidMSBuildArchitectureValue(string architecture);
    internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB);
    internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, String& mergedRuntime);
    internal static bool ArchitectureValuesMatch(string architectureA, string architectureB);
    internal static string GetExplicitMSBuildRuntime(string runtime);
    internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, String& mergedArchitecture);
    internal static string GetCurrentMSBuildArchitecture();
    internal static string GetExplicitMSBuildArchitecture(string architecture);
}
internal static class Microsoft.Build.Shared.XMakeElements : object {
    internal static string project;
    internal static string visualStudioProject;
    internal static string target;
    internal static string propertyGroup;
    internal static string output;
    internal static string itemGroup;
    internal static string itemDefinitionGroup;
    internal static string usingTask;
    internal static string projectExtensions;
    internal static string onError;
    internal static string error;
    internal static string warning;
    internal static string message;
    internal static string import;
    internal static string importGroup;
    internal static string choose;
    internal static string when;
    internal static string otherwise;
    internal static string usingTaskParameterGroup;
    internal static string usingTaskParameter;
    internal static string usingTaskBody;
    internal static string sdk;
    internal static Char[] InvalidTargetNameCharacters;
    internal static HashSet`1<string> ReservedItemNames;
    private static XMakeElements();
}
internal static class Microsoft.Build.Shared.XmlUtilities : object {
    internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation oldElement, string newElementName, string xmlNamespace);
    internal static void VerifyThrowArgumentValidElementName(string name);
    internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location);
    internal static void VerifyThrowProjectValidElementName(XmlElementWithLocation element);
    internal static bool IsValidElementName(string name);
    internal static int LocateFirstInvalidElementNameCharacter(string name);
    internal static bool IsValidInitialElementNameCharacter(char c);
    internal static bool IsValidSubsequentElementNameCharacter(char c);
}
internal abstract class Microsoft.Build.SharedReadBuffer : object {
}
internal class Microsoft.Build.Utilities.EscapeHatches : object {
    public Nullable`1<bool> EvaluateElementsWithFalseConditionInProjectEvaluation;
    public bool AlwaysUseContentTimestamp;
    public bool LogProjectImports;
    public bool CacheAssemblyInformation;
    public Nullable`1<ProjectInstanceTranslationMode> ProjectInstanceTranslation;
    public bool UseSymlinkTimeInsteadOfTargetTime;
    public bool IgnoreEmptyImports;
    public bool IgnoreTreatAsLocalProperty;
    public bool DebugEvaluation;
    public bool WarnOnUninitializedProperty;
    public bool UseCaseSensitiveItemNames;
    public bool DisableSdkResolutionCache;
    public bool DisableNuGetSdkResolver;
    public bool UseAutoRunWhenLaunchingProcessUnderCmd;
    public bool EnsureStdOutForChildNodesIsPrimaryStdout;
    private static Nullable`1<bool> ParseNullableBoolFromEnvironmentVariable(string environmentVariable);
    private static Nullable`1<ProjectInstanceTranslationMode> ComputeProjectInstanceTranslation();
}
internal class Microsoft.Build.Utilities.Traits : object {
    private static Traits _instance;
    [CompilerGeneratedAttribute]
private EscapeHatches <EscapeHatches>k__BackingField;
    public bool UseLazyWildCardEvaluation;
    public bool LogExpandedWildcards;
    public bool CacheFileExistence;
    public bool UseSimpleInternConcurrency;
    public bool MSBuildCacheFileEnumerations;
    public bool EnableAllPropertyFunctions;
    public bool EnableRestoreFirst;
    public int CopyTaskParallelism;
    public bool EmitSolutionMetaproj;
    public static Traits Instance { get; }
    public EscapeHatches EscapeHatches { get; }
    private static Traits();
    public static Traits get_Instance();
    [CompilerGeneratedAttribute]
public EscapeHatches get_EscapeHatches();
    private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue);
}
internal class System.DefaultBinder : object {
    private static UInt32 PT_Primitive;
    private static UInt32[] PrimitiveAttributes;
    private static DefaultBinder();
    [SecuritySafeCriticalAttribute]
public static MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    [SecuritySafeCriticalAttribute]
public static MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static void ReorderArgumentArray(Object[]& args, object state);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    [SecuritySafeCriticalAttribute]
private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    internal static bool CompareMethodSigAndName(MethodBase m1, MethodBase m2);
    internal static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    internal static bool CanConvertPrimitiveObjectToType(object source, Type type);
    internal static bool CanConvertPrimitive(Type source, Type type);
    private static CorElementType GetCorElementType(Type type);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsEquivalentTo(Type type, Type other);
    [ExtensionAttribute]
public static object InvokeMember(Type type, string name, BindingFlags bindingFlags, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, BindingFlags bindingAttr, object binder, Type[] types, ParameterModifier[] modifiers);
}
internal abstract class System.Xml.Base64Encoder : object {
    private Byte[] leftOverBytes;
    private int leftOverBytesCount;
    private Char[] charsLine;
    internal static int Base64LineSize;
    internal static int LineSizeInBytes;
    internal abstract virtual void WriteChars(Char[] chars, int index, int count);
    internal void Encode(Byte[] buffer, int index, int count);
    internal void Flush();
}
internal static class System.Xml.BinHexEncoder : object {
    private static string s_hexDigits;
    private static int CharsChunkSize;
    internal static void Encode(Byte[] buffer, int index, int count, XmlWriter writer);
    internal static string Encode(Byte[] inArray, int offsetIn, int count);
    private static int Encode(Byte[] inArray, int offsetIn, int count, Char[] outArray);
}
internal class System.Xml.SecureStringHasher : object {
    private int hashCodeRandomizer;
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string key);
}
internal static class System.Xml.ValidateNames : object {
    private static XmlCharType xmlCharType;
    private static ValidateNames();
    internal static int ParseNmtoken(string s, int offset);
    internal static int ParseNmtokenNoNamespaces(string s, int offset);
    internal static bool IsNmtokenNoNamespaces(string s);
    internal static int ParseNameNoNamespaces(string s, int offset);
    internal static bool IsNameNoNamespaces(string s);
    internal static int ParseNCName(string s, int offset);
    internal static int ParseNCName(string s);
    internal static string ParseNCNameThrow(string s);
    private static bool ParseNCNameInternal(string s, bool throwOnError);
    internal static int ParseQName(string s, int offset, Int32& colonOffset);
    internal static void ParseQNameThrow(string s, String& prefix, String& localName);
    internal static void ParseNameTestThrow(string s, String& prefix, String& localName);
    internal static void ThrowInvalidName(string s, int offsetStartChar, int offsetBadChar);
    internal static Exception GetInvalidNameException(string s, int offsetStartChar, int offsetBadChar);
    internal static bool StartsWithXml(string s);
    internal static bool IsReservedNamespace(string s);
    private static string CreateName(string prefix, string localName);
    internal static void SplitQName(string name, String& prefix, String& lname);
}
internal class System.Xml.XmlCharType : ValueType {
    internal static int SurHighStart;
    internal static int SurHighEnd;
    internal static int SurLowStart;
    internal static int SurLowEnd;
    internal static int SurMask;
    internal static int fWhitespace;
    internal static int fLetter;
    internal static int fNCStartNameSC;
    internal static int fNCNameSC;
    internal static int fCharData;
    internal static int fNCNameXml4e;
    internal static int fText;
    internal static int fAttrValue;
    private static string s_PublicIdBitmap;
    private static UInt32 CharPropertiesSize;
    internal static string s_Whitespace;
    private static string s_NCStartName;
    private static string s_NCName;
    private static string s_CharData;
    private static string s_PublicID;
    private static string s_Text;
    private static string s_AttrValue;
    private static string s_LetterXml4e;
    private static string s_NCNameXml4e;
    private static object s_Lock;
    private static Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) s_CharProperties;
    internal Byte[] charProperties;
    private static object StaticLock { get; }
    public static XmlCharType Instance { get; }
    private XmlCharType(Byte[] charProperties);
    private static object get_StaticLock();
    private static void InitInstance();
    private static void SetProperties(string ranges, byte value);
    public static XmlCharType get_Instance();
    public bool IsWhiteSpace(char ch);
    public bool IsExtender(char ch);
    public bool IsNCNameSingleChar(char ch);
    public bool IsStartNCNameSingleChar(char ch);
    public bool IsNameSingleChar(char ch);
    public bool IsStartNameSingleChar(char ch);
    public bool IsCharData(char ch);
    public bool IsPubidChar(char ch);
    internal bool IsTextChar(char ch);
    internal bool IsAttributeValueChar(char ch);
    public bool IsLetter(char ch);
    public bool IsNCNameCharXml4e(char ch);
    public bool IsStartNCNameCharXml4e(char ch);
    public bool IsNameCharXml4e(char ch);
    public bool IsStartNameCharXml4e(char ch);
    public static bool IsDigit(char ch);
    public static bool IsHexDigit(char ch);
    internal static bool IsHighSurrogate(int ch);
    internal static bool IsLowSurrogate(int ch);
    internal static bool IsSurrogate(int ch);
    internal static int CombineSurrogateChar(int lowChar, int highChar);
    internal static void SplitSurrogateChar(int combinedChar, Char& lowChar, Char& highChar);
    internal bool IsOnlyWhitespace(string str);
    internal int IsOnlyWhitespaceWithPos(string str);
    internal int IsOnlyCharData(string str);
    internal static bool IsOnlyDigits(string str, int startPos, int len);
    internal static bool IsOnlyDigits(Char[] chars, int startPos, int len);
    internal int IsPublicId(string str);
    private static bool InRange(int value, int start, int end);
}
internal static class System.Xml.XmlReservedNs : object {
    internal static string NsXml;
    internal static string NsXmlNs;
    internal static string NsDataType;
    internal static string NsDataTypeAlias;
    internal static string NsDataTypeOld;
    internal static string NsMsxsl;
    internal static string NsXdr;
    internal static string NsXslDebug;
    internal static string NsXdrAlias;
    internal static string NsWdXsl;
    internal static string NsXs;
    internal static string NsXsd;
    internal static string NsXsi;
    internal static string NsXslt;
    internal static string NsExsltCommon;
    internal static string NsExsltDates;
    internal static string NsExsltMath;
    internal static string NsExsltRegExps;
    internal static string NsExsltSets;
    internal static string NsExsltStrings;
    internal static string NsXQueryFunc;
    internal static string NsXQueryDataType;
    internal static string NsCollationBase;
    internal static string NsCollCodePoint;
    internal static string NsXsltInternal;
}
internal class System.Xml.XmlTextEncoder : object {
    private TextWriter textWriter;
    private bool inAttribute;
    private char quoteChar;
    private StringBuilder attrValue;
    private bool cacheAttrValue;
    private XmlCharType xmlCharType;
    unknown char QuoteChar {internal set; }
    internal string AttributeValue { get; }
    internal XmlTextEncoder(TextWriter textWriter);
    internal void set_QuoteChar(char value);
    internal void StartAttribute(bool cacheAttrValue);
    internal void EndAttribute();
    internal string get_AttributeValue();
    internal void WriteSurrogateChar(char lowChar, char highChar);
    internal void Write(Char[] array, int offset, int count);
    internal void WriteSurrogateCharEntity(char lowChar, char highChar);
    internal void Write(string text);
    internal void WriteRawWithSurrogateChecking(string text);
    internal void WriteRaw(string value);
    internal void WriteRaw(Char[] array, int offset, int count);
    internal void WriteCharEntity(char ch);
    internal void WriteEntityRef(string name);
    internal void Flush();
    private void WriteStringFragment(string str, int offset, int count, Char[] helperBuffer);
    private void WriteCharEntityImpl(char ch);
    private void WriteCharEntityImpl(string strVal);
    private void WriteEntityRefImpl(string name);
    internal static Exception CreateInvalidSurrogatePairException(char low, char hi);
    internal static Exception CreateInvalidHighSurrogateCharException(char hi);
}
internal class System.Xml.XmlTextWriterBase64Encoder : Base64Encoder {
    private XmlTextEncoder xmlTextEncoder;
    internal XmlTextWriterBase64Encoder(XmlTextEncoder xmlTextEncoder);
    internal virtual void WriteChars(Char[] chars, int index, int count);
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
