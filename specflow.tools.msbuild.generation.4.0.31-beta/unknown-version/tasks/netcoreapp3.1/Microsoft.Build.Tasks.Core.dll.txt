[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    private int capacity;
    private CopyOnWriteBackingDictionary`2<K, V, K, V> backing;
    [CompilerGeneratedAttribute]
private static CopyOnWriteDictionary`2<K, V> <Dummy>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<K> <Comparer>k__BackingField;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; private set; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> ReadOperation { get; }
    private CopyOnWriteBackingDictionary`2<K, V, K, V> WriteOperation { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`2(CopyOnWriteDictionary`2<K, V> that);
    public CopyOnWriteDictionary`2(IDictionary`2<K, V> dictionary);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [CompilerGeneratedAttribute]
internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<K> get_Comparer();
    [CompilerGeneratedAttribute]
private void set_Comparer(IEqualityComparer`1<K> value);
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_ReadOperation();
    private CopyOnWriteBackingDictionary`2<K, V, K, V> get_WriteOperation();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    private object store;
    private IEqualityComparer`1<TKey> comparer;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    private void AddToOrUpdateList(List`1<KeyValuePair`2<TKey, TValue>> list, TKey key, TValue value, bool throwIfPresent);
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    private IEnumerable`1<T> _backing;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection`1<T> BackingCollection { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private ICollection`1<T> get_BackingCollection();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal static class Microsoft.Build.OpportunisticIntern : object {
    private static bool s_useSimpleConcurrency;
    private static int s_smallMruSize;
    private static int s_largeMruSize;
    private static int s_hugeMruSize;
    private static int s_smallMruThreshold;
    private static int s_largeMruThreshold;
    private static int s_hugeMruThreshold;
    private static int s_ginormousThreshold;
    private static BucketedPrioritizedStringList s_si;
    private static BucketedPrioritizedStringList s_whatIfInfinite;
    private static BucketedPrioritizedStringList s_whatIfDoubled;
    private static BucketedPrioritizedStringList s_whatIfHalved;
    private static BucketedPrioritizedStringList s_whatIfZero;
    private static OpportunisticIntern();
    internal static int AssignViaEnvironment(string env, int default);
    internal static void EnableStatisticsGathering();
    internal static string InternableToString(IInternable candidate);
    internal static string StringBuilderToString(StringBuilder candidate);
    internal static string CharArrayToString(Char[] candidate, int count);
    internal static string CharArrayToString(Char[] candidate, int startIndex, int count);
    internal static string InternStringIfPossible(string candidate);
    internal static void ReportStatistics();
}
[DataContractAttribute]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection : object {
    [CompilerGeneratedAttribute]
private List`1<AssemblyFolderItem> <AssemblyFolders>k__BackingField;
    [DataMemberAttribute]
internal List`1<AssemblyFolderItem> AssemblyFolders { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<AssemblyFolderItem> get_AssemblyFolders();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolders(List`1<AssemblyFolderItem> value);
    internal static AssemblyFolderCollection Load(string filePath);
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{Name}: FrameworkVersion = {FrameworkVersion}, Platform = {Platform}, Path= {Path}")]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [DataMemberAttribute]
internal string Name { get; internal set; }
    [DataMemberAttribute]
internal string FrameworkVersion { get; internal set; }
    [DataMemberAttribute]
internal string Path { get; internal set; }
    [DataMemberAttribute]
internal string Platform { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
internal void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
internal string get_Platform();
    [CompilerGeneratedAttribute]
internal void set_Platform(string value);
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private bool considerRetargetableFlag;
    private AssemblyNameComparer(bool considerRetargetableFlag);
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    private AssemblyName asAssemblyName;
    private string asString;
    private bool isSimpleName;
    private bool hasProcessorArchitectureInFusionName;
    private bool immutable;
    private HashSet`1<AssemblyNameExtension> remappedFrom;
    private static AssemblyNameExtension s_unnamedAssembly;
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private AssemblyNameExtension(SerializationInfo info, StreamingContext context);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    [OnDeserializedAttribute]
private void SetRemappedFromDefaultAfterSerialization(StreamingContext sc);
    private void InitializeRemappedFrom();
    private void CreateAssemblyName();
    private void CreateFullName();
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    private int CompareBaseNameToImpl(AssemblyNameExtension that);
    private static int CompareBaseNamesStringWise(string asString1, string asString2);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Shared.AssemblyNameExtension>.Equals(AssemblyNameExtension other);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool considerRetargetableFlag);
    internal static bool CompareCultures(AssemblyName a, AssemblyName b);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal static bool ComparePublicKeyTokens(Byte[] aPKT, Byte[] bPKT);
    internal bool get_IsUnnamedAssembly();
    private static AssemblyName GetAssemblyNameFromDisplayName(string displayName);
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <PrimaryResources>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <SharedResources>k__BackingField;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_PrimaryResources();
    [CompilerGeneratedAttribute]
internal static ResourceManager get_SharedResources();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AssemblyUtilities : object {
    private static bool s_initialized;
    private static PropertyInfo s_assemblylocationProperty;
    private static MethodInfo s_cultureInfoGetCultureMethod;
    private static Lazy`1<CultureInfo[]> s_validCultures;
    private static Lazy`1<Assembly> s_entryAssembly;
    public static Assembly EntryAssembly { get; }
    private static AssemblyUtilities();
    public static Assembly get_EntryAssembly();
    public static string GetAssemblyLocation(Assembly assembly);
    [ExtensionAttribute]
public static AssemblyName CloneIfPossible(AssemblyName assemblyNameToClone);
    public static bool CultureInfoHasGetCultures();
    public static CultureInfo[] GetAllCultures();
    private static void Initialize();
    private static Assembly GetEntryAssembly();
    private static CultureInfo[] GetValidCultures();
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static string ConvertByteArrayToHex(Byte[] bytes);
    internal static bool CanConvertStringToBool(string parameterValue);
    private static bool ValidBooleanTrue(string parameterValue);
    private static bool ValidBooleanFalse(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    private static bool ValidHexNumber(string number);
    private static bool ValidDecimalNumber(string number);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    private static Encoding s_currentOemEncoding;
    internal static Encoding CurrentSystemOemEncoding { get; }
    internal static Encoding get_CurrentSystemOemEncoding();
    [ExtensionAttribute]
internal static bool SimilarToEncoding(Encoding encoding1, Encoding encoding2);
    [ExtensionAttribute]
internal static bool IsUtf8Encoding(Encoding encoding);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream, Byte[] preamble);
    internal static bool FileStartsWithPreamble(string file);
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_throwExceptions;
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    private static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    private static bool IsHexDigit(char character);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    [CompilerGeneratedAttribute]
private string <RegistryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    internal string RegistryKey { get; }
    internal Version TargetFrameworkVersion { get; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string dotdot;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    internal static Char[] directorySeparatorCharacters;
    internal static String[] directorySeparatorStrings;
    private static Lazy`1<ConcurrentDictionary`2<string, ImmutableArray`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, ImmutableArray`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, ImmutableArray`1<string>> fileEntryExpansionCache);
    public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, ImmutableArray`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    private static ImmutableArray`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static ImmutableArray`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static ImmutableArray`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__33")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__35")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    private static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, String& matchFileExpression, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsMatch(string input, string pattern, bool ignoreCase);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    internal String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    private static bool IsSlash(char c);
    private static int SkipCharacters(string aString, int startingIndex, Func`2<char, bool> jumpOverCharacter);
    internal static bool IsValidDriveChar(char value);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private String[] GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|49_0(char inputChar, char patternChar, int iIndex, int pIndex, <>c__DisplayClass49_0& );
    [CompilerGeneratedAttribute]
internal static bool <ComputeFileEnumerationCacheKey>g__FilespecIsAnAbsoluteGlobPointingOutsideOfProjectCone|54_0(string projectDirectory, string filespec);
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool DirectoryEntryExists(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <DirectoryEntryExists>b__3_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__4_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__5_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : object {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryEntryExists(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    private static Char[] Slashes;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    internal static string ExecutingAssemblyPath { get; }
    private static FileUtilities();
    internal static string GetTemporaryDirectory(bool createDirectory);
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
    internal static void ClearCacheDirectoryPath();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    private static bool IsUNCPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    private static Uri CreateUriFromPath(string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName);
    internal static string GetPathOfFileAbove(string file, string startingDirectory);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
    private static void ConsiderDebuggerLaunch(string message, Exception innerException);
    private static void LaunchDebugger(string message, string innerMessage);
    private static bool RunningTests();
}
internal class Microsoft.Build.Shared.LanguageParser.BooleanLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CloseConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.CommentToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenCharReader : TokenCharReader {
    internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkLongIntegerSuffix();
    internal bool SinkOperatorOrPunctuator();
    internal bool SinkStringEscape();
    internal bool MatchRegularStringLiteral();
    internal bool SinkMultipleWhiteSpace();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenEnumerator : TokenEnumerator {
    private CSharpTokenCharReader _reader;
    private static String[] s_keywordList;
    internal TokenCharReader Reader { get; }
    internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static CSharpTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenizer : object {
    private Stream _binaryStream;
    private bool _forceANSI;
    internal CSharpTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.DecimalIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.EndOfFileInsideStringToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedIdentifierToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedValidHexDigitToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.HexIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.IdentifierToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.IntegerLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.KeywordToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.LiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OpenConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorOrPunctuatorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorToken : OperatorOrPunctuatorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.PreprocessorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.StreamMappedString : object {
    private Stream _binaryStream;
    private StreamReader _reader;
    private bool _forceANSI;
    private int _currentPageNumber;
    private int _finalPageNumber;
    private int _charactersRead;
    private Char[] _priorPage;
    private Char[] _currentPage;
    private int _pagesAllocated;
    private int _pageSize;
    public int PagesAllocated { get; }
    public static int DefaultPageSize { get; }
    public StreamMappedString(Stream binaryStream, bool forceANSI);
    internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize);
    private void RestartReader();
    public int get_PagesAllocated();
    public static int get_DefaultPageSize();
    public char GetAt(int offset);
    private Char[] GetPage(int offset);
    private bool ReadNextPage();
    private void ReadBlockStripEOF();
    private void AppendCharacterToStream(char c);
    private char LastCharacterInStream();
    private void SwapPages();
    private bool IsZeroLengthStream();
    private int AbsoluteOffsetToPageOffset(int offset);
    private int PageFromAbsoluteOffset(int offset);
    public bool IsPastEnd(int offset);
    public string Substring(int startPosition, int length);
    private int GetCharactersOnPage(int offset);
}
internal class Microsoft.Build.Shared.LanguageParser.StringLiteralToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.SyntaxErrorToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.Token : object {
    private string _innerText;
    private int _line;
    internal string InnerText { get; internal set; }
    internal int Line { get; internal set; }
    internal string get_InnerText();
    internal void set_InnerText(string value);
    internal int get_Line();
    internal void set_Line(int value);
    internal bool EqualsIgnoreCase(string compareTo);
}
internal static class Microsoft.Build.Shared.LanguageParser.TokenChar : object {
    internal static bool IsNewLine(char c);
    internal static bool IsLetter(char c);
    internal static bool IsDecimalDigit(char c);
    internal static bool IsConnecting(char c);
    internal static bool IsCombining(char c);
    internal static bool IsFormatting(char c);
    internal static bool IsHexDigit(char c);
    internal static bool IsOctalDigit(char c);
}
internal class Microsoft.Build.Shared.LanguageParser.TokenCharReader : object {
    private StreamMappedString _sources;
    private int _position;
    private int _currentLine;
    internal int CurrentLine { get; }
    internal int Position { get; internal set; }
    internal char CurrentCharacter { get; }
    internal bool EndOfLines { get; }
    internal TokenCharReader(Stream binaryStream, bool forceANSI);
    internal void Reset();
    internal int get_CurrentLine();
    internal int get_Position();
    internal void set_Position(int value);
    protected void Skip();
    protected void Skip(int n);
    internal char get_CurrentCharacter();
    internal bool get_EndOfLines();
    internal string GetCurrentMatchedString(int startPosition);
    internal bool Sink(string match);
    private bool Sink(string match, bool ignoreCase);
    internal char SinkCharacter();
    internal bool SinkIgnoreCase(string match);
    internal bool MatchNextIdentifierStart();
    internal bool SinkIdentifierStart();
    internal bool SinkIdentifierPart();
    internal bool SinkNewLine();
    internal bool SinkToEndOfLine();
    internal bool SinkUntil(string find);
    internal bool SinkMultipleHexDigits();
    internal bool SinkMultipleDecimalDigits();
}
internal abstract class Microsoft.Build.Shared.LanguageParser.TokenEnumerator : object {
    protected Token current;
    internal TokenCharReader Reader { get; }
    public object Current { get; }
    internal abstract virtual TokenCharReader get_Reader();
    internal abstract virtual bool FindNextToken();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
internal class Microsoft.Build.Shared.LanguageParser.UnrecognizedToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenCharReader : TokenCharReader {
    internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkSeparatorCharacter();
    internal bool SinkLineContinuationCharacter();
    internal bool SinkLineCommentStart();
    internal bool SinkHexIntegerPrefix();
    internal bool SinkOctalIntegerPrefix();
    internal bool SinkWhiteSpace();
    internal bool SinkIntegerSuffix();
    internal bool SinkDecimalIntegerSuffix();
    internal bool SinkMultipleOctalDigits();
    internal bool SinkOperator();
    internal bool SinkTypeCharacter();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenEnumerator : TokenEnumerator {
    private VisualBasicTokenCharReader _reader;
    private static String[] s_keywordList;
    internal TokenCharReader Reader { get; }
    internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static VisualBasicTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenizer : object {
    private Stream _binaryStream;
    private bool _forceANSI;
    internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.WhitespaceToken : Token {
}
internal static class Microsoft.Build.Shared.MetadataConversionUtilities : object {
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName, Boolean& metadataFound);
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_ACCESS_DENIED;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int MAX_PATH;
    private static string kernel32Dll;
    private static string mscoreeDLL;
    private static string WINDOWS_FILE_SYSTEM_REGISTRY_KEY;
    private static string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME;
    internal static IntPtr NullIntPtr;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static CharSet AutoOrUnicode;
    private static MaxPathLimits osMaxPathLimit;
    private static object osMaxPathLimitLock;
    private static bool s_isUnixLike;
    private static object IsMonoLock;
    private static Nullable`1<bool> _isMono;
    private static string s_frameworkBasePath;
    private static string s_frameworkCurrentPath;
    private static SystemInformationData _systemInformation;
    private static bool _systemInformationInitialized;
    private static object SystemInformationLock;
    private static Version s_threadErrorModeMinOsVersion;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_ATTRIBUTE_NORMAL;
    internal static UInt32 FILE_FLAG_OPEN_REPARSE_POINT;
    internal static UInt32 OPEN_EXISTING;
    internal static MaxPathLimits OSMaxPathLimit { get; }
    internal static bool IsUnixLike { get; }
    internal static bool IsLinux { get; }
    internal static bool IsBSD { get; }
    internal static bool IsMono { get; }
    internal static bool IsWindows { get; }
    internal static bool IsOSX { get; }
    internal static string OSName { get; }
    internal static string FrameworkCurrentPath { get; }
    internal static string FrameworkBasePath { get; }
    private static SystemInformationData SystemInformation { get; }
    internal static ProcessorArchitectures ProcessorArchitecture { get; }
    internal static ProcessorArchitectures ProcessorArchitectureNative { get; }
    private static NativeMethodsShared();
    internal static MaxPathLimits get_OSMaxPathLimit();
    private static void SetOSMaxPathLimit();
    private static bool IsMaxPathLimitLegacyWindows();
    private static bool IsLongPathsEnabledRegistry();
    internal static bool get_IsUnixLike();
    internal static bool get_IsLinux();
    internal static bool get_IsBSD();
    internal static bool get_IsMono();
    internal static bool get_IsWindows();
    internal static bool get_IsOSX();
    internal static string get_OSName();
    internal static string GetOSNameForExtensionsPath();
    internal static string get_FrameworkCurrentPath();
    internal static string get_FrameworkBasePath();
    private static SystemInformationData get_SystemInformation();
    internal static ProcessorArchitectures get_ProcessorArchitecture();
    internal static ProcessorArchitectures get_ProcessorArchitectureNative();
    internal static int SetErrorMode(int newMode);
    private static bool SetErrorMode_Win7AndNewer(int newMode, Int32& oldMode);
    private static int SetErrorMode_VistaAndOlder(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    private static DateTime GetContentLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static void KillTree(int processIdToKill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    private static int GetCurrentDirectoryWin32(int nBufferLength, Char* lpBuffer);
    internal static string GetFullPath(string path);
    private static int GetFullPathWin32(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static bool AreStringsEqual(Char* buffer, int len, string s);
    internal static void VerifyThrowWin32Result(int result);
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    private static UInt32 SearchPath(string path, string fileName, string extension, int numBufferChars, StringBuilder buffer, Int32[] filePart);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(IntPtr hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, Char* lpBuffer);
    internal static bool SetCurrentDirectoryWindows(string path);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    private static int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, PROCESS_BASIC_INFORMATION& pbi, int cb, Int32& pSize);
    private static bool GlobalMemoryStatusEx(MemoryStatus lpBuffer);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool GetFileTime(SafeFileHandle hFile, FILETIME& lpCreationTime, FILETIME& lpLastAccessTime, FILETIME& lpLastWriteTime);
    internal static bool CloseHandle(IntPtr hObject);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
    internal static bool DirectoryExists(string fullPath);
    internal static bool DirectoryExistsWindows(string fullPath);
    internal static bool FileExists(string fullPath);
    internal static bool FileExistsWindows(string fullPath);
    internal static bool FileOrDirectoryExists(string path);
    internal static bool FileOrDirectoryExistsWindows(string path);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T _value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
internal class Microsoft.Build.Shared.VisualStudioInstance : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal Version Version { get; }
    internal string Path { get; }
    internal string Name { get; }
    internal VisualStudioInstance(string name, string path, Version version);
    [CompilerGeneratedAttribute]
internal Version get_Version();
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_Name();
}
internal class Microsoft.Build.Shared.VisualStudioLocationHelper : object {
    private static int REGDB_E_CLASSNOTREG;
    internal static IList`1<VisualStudioInstance> GetInstances();
}
internal class Microsoft.Build.Tasks.AppConfig : object {
    [CompilerGeneratedAttribute]
private RuntimeSection <Runtime>k__BackingField;
    internal RuntimeSection Runtime { get; }
    internal void Load(string appConfigFile);
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal RuntimeSection get_Runtime();
    internal static bool StringEquals(string a, string b);
}
internal class Microsoft.Build.Tasks.AppConfigException : Exception {
    private string fileName;
    private int line;
    private int column;
    internal string FileName { get; }
    internal int Line { get; }
    internal int Column { get; }
    public AppConfigException(string message, string fileName, int line, int column, Exception inner);
    protected AppConfigException(SerializationInfo info, StreamingContext context);
    internal string get_FileName();
    internal int get_Line();
    internal int get_Column();
}
internal class Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata : object {
    public AssemblyNameExtension[] Dependencies;
    public FrameworkName FrameworkName;
    public String[] ScatterFiles;
    public AssemblyMetadata(string path);
}
internal class Microsoft.Build.Tasks.AssemblyEntry : object {
    private AssemblyNameExtension _assemblyName;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InGAC>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Retargetable>k__BackingField;
    public string FullName { get; }
    public bool InGAC { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public string SimpleName { get; }
    public string FrameworkDirectory { get; }
    public bool Retargetable { get; }
    public AssemblyNameExtension AssemblyNameExtension { get; }
    public AssemblyEntry(string name, string version, string publicKeyToken, string culture, bool inGAC, Nullable`1<bool> isRedistRoot, string redistName, string frameworkDirectory, bool retargetable);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public bool get_InGAC();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
public string get_RedistName();
    [CompilerGeneratedAttribute]
public string get_SimpleName();
    [CompilerGeneratedAttribute]
public string get_FrameworkDirectory();
    [CompilerGeneratedAttribute]
public bool get_Retargetable();
    public AssemblyNameExtension get_AssemblyNameExtension();
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig : object {
    private List`1<AssemblyFoldersFromConfigInfo> _directoryNames;
    internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersion, ProcessorArchitecture targetArchitecture);
    private void FindDirectories(List`1<AssemblyFolderItem> assemblyTargets, Func`2<AssemblyFolderItem, bool> platformFilter);
    private static List`1<AssemblyFolderItem> GatherVersionStrings(string targetRuntimeVersion, AssemblyFolderCollection collection);
    private static Version GetFrameworkVersion(string version);
    private sealed virtual override IEnumerator`1<AssemblyFoldersFromConfigInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache : object {
    private ImmutableHashSet`1<string> _filesInDirectories;
    private FileExists _fileExists;
    private bool _useOriginalFileExists;
    [CompilerGeneratedAttribute]
private AssemblyFoldersFromConfig <AssemblyFoldersFromConfig>k__BackingField;
    internal AssemblyFoldersFromConfig AssemblyFoldersFromConfig { get; }
    internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFoldersFromConfig, FileExists fileExists);
    [CompilerGeneratedAttribute]
internal AssemblyFoldersFromConfig get_AssemblyFoldersFromConfig();
    internal bool FileExists(string path);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver : Resolver {
    private static Lazy`1<Regex> s_crackAssemblyFoldersFromConfigSentinel;
    private bool _wasMatch;
    private string _targetRuntimeVersion;
    private bool _isInitialized;
    private AssemblyFoldersFromConfigCache _assemblyFoldersCache;
    private IBuildEngine4 _buildEngine;
    private TaskLoggingHelper _taskLogger;
    private string _assemblyFolderConfigFile;
    internal AssemblyFoldersFromConfig AssemblyFoldersExLocations { get; }
    public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine, TaskLoggingHelper log);
    private static AssemblyFoldersFromConfigResolver();
    internal AssemblyFoldersFromConfig get_AssemblyFoldersExLocations();
    private void LazyInitialize();
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersResolver : Resolver {
    public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.AssemblyInformation : DisposableBase {
    private AssemblyNameExtension[] _assemblyDependencies;
    private String[] _assemblyFiles;
    private string _sourceFile;
    private FrameworkName _frameworkName;
    private bool _metadataRead;
    private static int GENMAN_STRING_BUF_SIZE;
    private static int GENMAN_LOCALE_BUF_SIZE;
    private static int GENMAN_ENUM_TOKEN_BUF_SIZE;
    public AssemblyNameExtension[] Dependencies { get; }
    public String[] Files { get; }
    public FrameworkName FrameworkNameAttribute { get; }
    internal AssemblyInformation(string sourceFile);
    public AssemblyNameExtension[] get_Dependencies();
    public String[] get_Files();
    public FrameworkName get_FrameworkNameAttribute();
    internal static void GetAssemblyMetadata(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkName);
    internal static FrameworkName GetTargetFrameworkAttribute(string path);
    internal static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    private FrameworkName GetFrameworkName();
    private void CorePopulateMetadata();
    private static List`1<string> GetFixedStringArguments(MetadataReader reader, CustomAttribute attribute);
    internal static string GetRuntimeVersion(string path);
    private AssemblyNameExtension[] ImportAssemblyDependencies();
    private String[] ImportFiles();
}
internal class Microsoft.Build.Tasks.AssemblyNameReference : ValueType {
    internal AssemblyNameExtension assemblyName;
    internal Reference reference;
    public virtual string ToString();
    public sealed virtual int CompareTo(AssemblyNameReference other);
    public static AssemblyNameReference Create(AssemblyNameExtension assemblyName, Reference reference);
}
internal class Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer : object {
    internal static IComparer`1<AssemblyNameReference> comparer;
    private static AssemblyNameReferenceAscendingVersionComparer();
    public sealed virtual int Compare(AssemblyNameReference i1, AssemblyNameReference i2);
}
internal class Microsoft.Build.Tasks.AssemblyRemapping : object {
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <From>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <To>k__BackingField;
    public AssemblyNameExtension From { get; }
    public AssemblyNameExtension To { get; }
    public AssemblyRemapping(AssemblyNameExtension from, AssemblyNameExtension to);
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_From();
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_To();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AssemblyRemapping other);
}
internal static class Microsoft.Build.Tasks.AssemblyResolution : object {
    internal static string ResolveReference(IEnumerable`1<Resolver[]> jaggedResolvers, AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& resolvedSearchPath, Boolean& userRequestedSpecificFile);
    public static Resolver[] CompileSearchPaths(IBuildEngine buildEngine, String[] searchPaths, String[] candidateAssemblyFiles, ProcessorArchitecture targetProcessorArchitecture, String[] frameworkPaths, FileExists fileExists, GetAssemblyName getAssemblyName, InstalledAssemblies installedAssemblies, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, GetAssemblyPathInGac getAssemblyPathInGac, TaskLoggingHelper log);
    internal static Resolver[] CompileDirectories(List`1<string> directories, FileExists fileExists, GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion);
}
internal static class Microsoft.Build.Tasks.AssemblyResolutionConstants : object {
    public static string hintPathSentinel;
    public static string assemblyFoldersSentinel;
    public static string candidateAssemblyFilesSentinel;
    public static string gacSentinel;
    public static string frameworkPathSentinel;
    public static string rawFileNameSentinel;
    public static string assemblyFoldersExSentinel;
    public static string assemblyFoldersFromConfigSentinel;
}
internal class Microsoft.Build.Tasks.AssemblyTableInfo : object {
    private string _descriptor;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkDirectory>k__BackingField;
    internal string Path { get; }
    internal string FrameworkDirectory { get; }
    internal string Descriptor { get; }
    internal AssemblyTableInfo(string path, string frameworkDirectory);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_FrameworkDirectory();
    internal string get_Descriptor();
    public sealed virtual int CompareTo(object obj);
}
public class Microsoft.Build.Tasks.AssignCulture : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFilesWithCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFilesWithNoCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CultureNeutralAssignedFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; private set; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithCulture { get; private set; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithNoCulture { get; private set; }
    [OutputAttribute]
public ITaskItem[] CultureNeutralAssignedFiles { get; private set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFiles();
    [CompilerGeneratedAttribute]
private void set_AssignedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFilesWithCulture();
    [CompilerGeneratedAttribute]
private void set_AssignedFilesWithCulture(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFilesWithNoCulture();
    [CompilerGeneratedAttribute]
private void set_AssignedFilesWithNoCulture(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CultureNeutralAssignedFiles();
    [CompilerGeneratedAttribute]
private void set_CultureNeutralAssignedFiles(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.AssignLinkMetadata : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputItems>k__BackingField;
    public ITaskItem[] Items { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputItems { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputItems();
    [CompilerGeneratedAttribute]
public void set_OutputItems(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.AssignProjectConfiguration : ResolveProjectBase {
    [CompilerGeneratedAttribute]
private string <SolutionConfigurationContents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddSyntheticProjectReferencesForSolutionDependencies>k__BackingField;
    private string _defaultToVcxPlatformMapping;
    private string _vcxToDefaultPlatformMapping;
    [CompilerGeneratedAttribute]
private string <CurrentProject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentProjectConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentProjectPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldUnsetParentConfigurationAndPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveConfigurationPlatformUsingMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <UnassignedProjects>k__BackingField;
    private static string attrFullConfiguration;
    private static string buildReferenceMetadataName;
    private static string referenceOutputAssemblyMetadataName;
    private static string buildProjectInSolutionAttribute;
    private static string attrConfiguration;
    private static string attrPlatform;
    private static string attrSetConfiguration;
    private static string attrSetPlatform;
    private static Char[] s_configPlatformSeparator;
    private IDictionary`2<string, string> _vcxToDefaultMap;
    private IDictionary`2<string, string> _defaultToVcxMap;
    private bool _mappingsPopulated;
    public string SolutionConfigurationContents { get; public set; }
    public bool AddSyntheticProjectReferencesForSolutionDependencies { get; public set; }
    public string DefaultToVcxPlatformMapping { get; public set; }
    public string VcxToDefaultPlatformMapping { get; public set; }
    public string CurrentProject { get; public set; }
    public string CurrentProjectConfiguration { get; public set; }
    public string CurrentProjectPlatform { get; public set; }
    public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; public set; }
    public bool ShouldUnsetParentConfigurationAndPlatform { get; public set; }
    public string OutputType { get; public set; }
    public bool ResolveConfigurationPlatformUsingMappings { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedProjects { get; public set; }
    [OutputAttribute]
public ITaskItem[] UnassignedProjects { get; public set; }
    private static AssignProjectConfiguration();
    [CompilerGeneratedAttribute]
public string get_SolutionConfigurationContents();
    [CompilerGeneratedAttribute]
public void set_SolutionConfigurationContents(string value);
    [CompilerGeneratedAttribute]
public bool get_AddSyntheticProjectReferencesForSolutionDependencies();
    [CompilerGeneratedAttribute]
public void set_AddSyntheticProjectReferencesForSolutionDependencies(bool value);
    public string get_DefaultToVcxPlatformMapping();
    public void set_DefaultToVcxPlatformMapping(string value);
    public string get_VcxToDefaultPlatformMapping();
    public void set_VcxToDefaultPlatformMapping(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProject();
    [CompilerGeneratedAttribute]
public void set_CurrentProject(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProjectConfiguration();
    [CompilerGeneratedAttribute]
public void set_CurrentProjectConfiguration(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProjectPlatform();
    [CompilerGeneratedAttribute]
public void set_CurrentProjectPlatform(string value);
    [CompilerGeneratedAttribute]
public bool get_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration();
    [CompilerGeneratedAttribute]
public void set_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldUnsetParentConfigurationAndPlatform();
    [CompilerGeneratedAttribute]
public void set_ShouldUnsetParentConfigurationAndPlatform(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputType();
    [CompilerGeneratedAttribute]
public void set_OutputType(string value);
    [CompilerGeneratedAttribute]
public bool get_ResolveConfigurationPlatformUsingMappings();
    [CompilerGeneratedAttribute]
public void set_ResolveConfigurationPlatformUsingMappings(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedProjects();
    [CompilerGeneratedAttribute]
public void set_AssignedProjects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_UnassignedProjects();
    [CompilerGeneratedAttribute]
public void set_UnassignedProjects(ITaskItem[] value);
    public virtual bool Execute();
    internal bool ResolveProject(ITaskItem projectRef, ITaskItem& resolvedProjectWithConfiguration);
    internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration, ITaskItem resolvedProjectWithConfiguration, XmlElement projectConfigurationElement);
    private void SetupDefaultPlatformMappings();
    private void PopulateMappingDictionary(IDictionary`2<string, string> map, string mappingList);
}
public class Microsoft.Build.Tasks.AssignTargetPath : TaskExtension {
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFiles>k__BackingField;
    [RequiredAttribute]
public string RootFolder { get; public set; }
    public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; private set; }
    [CompilerGeneratedAttribute]
public string get_RootFolder();
    [CompilerGeneratedAttribute]
public void set_RootFolder(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFiles();
    [CompilerGeneratedAttribute]
private void set_AssignedFiles(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.BadImageReferenceException : Exception {
    internal BadImageReferenceException(string message, Exception innerException);
    private BadImageReferenceException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.BindingRedirect : object {
    [CompilerGeneratedAttribute]
private Version <OldVersionLow>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <OldVersionHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <NewVersion>k__BackingField;
    internal Version OldVersionLow { get; internal set; }
    internal Version OldVersionHigh { get; internal set; }
    internal Version NewVersion { get; internal set; }
    [CompilerGeneratedAttribute]
internal void set_OldVersionLow(Version value);
    [CompilerGeneratedAttribute]
internal Version get_OldVersionLow();
    [CompilerGeneratedAttribute]
internal void set_OldVersionHigh(Version value);
    [CompilerGeneratedAttribute]
internal Version get_OldVersionHigh();
    [CompilerGeneratedAttribute]
internal void set_NewVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_NewVersion();
    internal void Read(XmlReader reader);
}
internal class Microsoft.Build.Tasks.BuildCacheDisposeWrapper : object {
    private bool _disposed;
    private CallDuringDispose _callDuringDispose;
    internal BuildCacheDisposeWrapper(CallDuringDispose callDuringDispose);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.CallTarget : TaskExtension {
    private List`1<ITaskItem> _targetOutputs;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.CandidateAssemblyFilesResolver : Resolver {
    private String[] _candidateAssemblyFiles;
    public CandidateAssemblyFilesResolver(String[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
[ObsoleteAttribute("The CodeTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", "True")]
public class Microsoft.Build.Tasks.CodeTaskFactory : object {
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; }
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
public class Microsoft.Build.Tasks.CombinePath : TaskExtension {
    private ITaskItem[] _paths;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CombinedPaths>k__BackingField;
    public string BasePath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] CombinedPaths { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CombinedPaths();
    [CompilerGeneratedAttribute]
public void set_CombinedPaths(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CommandLineBuilderExtension : CommandLineBuilder {
    public CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator);
    internal void AppendWhenTrue(string switchName, Hashtable bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, Hashtable bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, Nullable`1<bool> value);
    internal void AppendByChoiceSwitch(string switchName, Hashtable bag, string parameterName, string choice1, string choice2);
    internal void AppendSwitchWithInteger(string switchName, Hashtable bag, string parameterName);
    internal void AppendSwitchAliased(string switchName, string alias, string parameter);
    internal void AppendNestedSwitch(string outerSwitchName, string innerSwitchName, string parameter);
    protected string GetQuotedText(string unquotedText);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] attributes);
    internal void AppendSwitchWithSplitting(string switchName, string parameter, string delimiter, Char[] splitOn);
    internal static bool IsParameterEmpty(string parameter, Char[] splitOn);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] metadataNames, Boolean[] treatAsFlags);
    internal void AppendSwitchIfTrue(string switchName, Nullable`1<bool> value);
}
internal enum Microsoft.Build.Tasks.ConflictLossReason : Enum {
    public int value__;
    public static ConflictLossReason DidntLose;
    public static ConflictLossReason HadLowerVersion;
    public static ConflictLossReason InsolubleConflict;
    public static ConflictLossReason WasNotPrimary;
    public static ConflictLossReason FusionEquivalentWithSameVersion;
}
public class Microsoft.Build.Tasks.ConvertToAbsolutePath : TaskExtension {
    private ITaskItem[] _paths;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AbsolutePaths>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] AbsolutePaths { get; public set; }
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AbsolutePaths();
    [CompilerGeneratedAttribute]
public void set_AbsolutePaths(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Copy : TaskExtension {
    internal static string AlwaysRetryEnvVar;
    internal static string AlwaysOverwriteReadOnlyFilesEnvVar;
    private static int DefaultCopyParallelism;
    private CancellationTokenSource _cancellationTokenSource;
    private ConcurrentDictionary`2<string, bool> _directoriesKnownToExist;
    private static bool s_alwaysRetryCopy;
    private static bool s_forceSymlinks;
    private static int s_parallelism;
    private static int RetryDelayMillisecondsDefault;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseHardlinksIfPossible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSymboliclinksIfPossible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DestinationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CopiedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public int Retries { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool UseHardlinksIfPossible { get; public set; }
    public bool UseSymboliclinksIfPossible { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] CopiedFiles { get; private set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    private static Copy();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public bool get_UseHardlinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseHardlinksIfPossible(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSymboliclinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseSymboliclinksIfPossible(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DestinationFiles();
    [CompilerGeneratedAttribute]
public void set_DestinationFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CopiedFiles();
    [CompilerGeneratedAttribute]
private void set_CopiedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    public sealed virtual void Cancel();
    private static bool IsMatchingSizeAndTimeStamp(FileState sourceFile, FileState destinationFile);
    internal static void RefreshInternalEnvironmentValues();
    private void LogDiagnostic(string message, Object[] messageArgs);
    private Nullable`1<bool> CopyFileWithLogging(FileState sourceFileState, FileState destinationFileState);
    private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, Boolean& destinationFileExists, Boolean& linkCreated, String& errorMessage, Func`4<string, string, string, bool> createLink);
    private void MakeFileWriteable(FileState file, bool logActivity);
    internal bool Execute(CopyFileWithState copyFile, int parallelism);
    private bool CopySingleThreaded(CopyFileWithState copyFile, List`1& destinationFilesSuccessfullyCopied);
    private bool CopyParallel(CopyFileWithState copyFile, int parallelism, List`1& destinationFilesSuccessfullyCopied);
    private bool ValidateInputs();
    private bool InitializeDestinationFiles();
    private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile);
    private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile);
    private static string GetLockedFileMessage(string file);
    public virtual bool Execute();
    private static bool PathsAreIdentical(string source, string destination);
    private static int GetParallelismFromEnvironment();
}
internal class Microsoft.Build.Tasks.CopyFile : MulticastDelegate {
    public CopyFile(object object, IntPtr method);
    public virtual bool Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.CopyFileWithState : MulticastDelegate {
    public CopyFileWithState(object object, IntPtr method);
    public virtual Nullable`1<bool> Invoke(FileState source, FileState destination);
    public virtual IAsyncResult BeginInvoke(FileState source, FileState destination, AsyncCallback callback, object object);
    public virtual Nullable`1<bool> EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Tasks.CopyLocalState : Enum {
    public int value__;
    public static CopyLocalState Undecided;
    public static CopyLocalState YesBecauseOfHeuristic;
    public static CopyLocalState YesBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseFrameworkFile;
    public static CopyLocalState NoBecausePrerequisite;
    public static CopyLocalState NoBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseReferenceResolvedFromGAC;
    public static CopyLocalState NoBecauseReferenceFoundInGAC;
    public static CopyLocalState NoBecauseConflictVictim;
    public static CopyLocalState NoBecauseUnresolved;
    public static CopyLocalState NoBecauseEmbedded;
    public static CopyLocalState NoBecauseParentReferencesFoundInGAC;
}
internal static class Microsoft.Build.Tasks.CopyLocalStateUtility : object {
    internal static bool IsCopyLocal(CopyLocalState state);
}
public class Microsoft.Build.Tasks.CreateCSharpManifestResourceName : CreateManifestResourceName {
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log);
    protected virtual bool IsSourceFile(string fileName);
}
internal class Microsoft.Build.Tasks.CreateFileStream : MulticastDelegate {
    public CreateFileStream(object object, IntPtr method);
    public virtual Stream Invoke(string path, FileMode mode, FileAccess access);
    public virtual IAsyncResult BeginInvoke(string path, FileMode mode, FileAccess access, AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.CreateItem : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveExistingMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionalMetadata>k__BackingField;
    [OutputAttribute]
public ITaskItem[] Include { get; public set; }
    public ITaskItem[] Exclude { get; public set; }
    public bool PreserveExistingMetadata { get; public set; }
    public String[] AdditionalMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_PreserveExistingMetadata();
    [CompilerGeneratedAttribute]
public void set_PreserveExistingMetadata(bool value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalMetadata();
    [CompilerGeneratedAttribute]
public void set_AdditionalMetadata(String[] value);
    public virtual bool Execute();
    private List`1<ITaskItem> CreateOutputItems(Dictionary`2<string, string> metadataTable, Dictionary`2<string, string> excludeItems);
    private static ITaskItem[] ExpandWildcards(ITaskItem[] expand);
    private static Dictionary`2<string, string> GetUniqueItems(ITaskItem[] items);
}
public abstract class Microsoft.Build.Tasks.CreateManifestResourceName : TaskExtension {
    private ITaskItem[] _resourceFiles;
    protected Dictionary`2<string, ITaskItem> itemSpecToTaskitem;
    [CompilerGeneratedAttribute]
private bool <PrependCultureAsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ManifestResourceNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResourceFilesWithManifestResourceNames>k__BackingField;
    public bool PrependCultureAsDirectory { get; public set; }
    [RequiredAttribute]
public ITaskItem[] ResourceFiles { get; public set; }
    public string RootNamespace { get; public set; }
    [OutputAttribute]
public ITaskItem[] ManifestResourceNames { get; private set; }
    [OutputAttribute]
public ITaskItem[] ResourceFilesWithManifestResourceNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PrependCultureAsDirectory();
    [CompilerGeneratedAttribute]
public void set_PrependCultureAsDirectory(bool value);
    public ITaskItem[] get_ResourceFiles();
    public void set_ResourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ManifestResourceNames();
    [CompilerGeneratedAttribute]
private void set_ManifestResourceNames(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ResourceFilesWithManifestResourceNames();
    [CompilerGeneratedAttribute]
public void set_ResourceFilesWithManifestResourceNames(ITaskItem[] value);
    protected abstract virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, Stream binaryStream);
    protected abstract virtual bool IsSourceFile(string fileName);
    private static Stream CreateFileStreamOverNewFileStream(string path, FileMode mode, FileAccess access);
    internal bool Execute(CreateFileStream createFileStream);
    public virtual bool Execute();
    private static bool IsValidEverettIdFirstChar(char c);
    private static bool IsValidEverettIdChar(char c);
    private static string MakeValidEverettSubFolderIdentifier(string subName);
    internal static string MakeValidEverettFolderIdentifier(string name);
    public static string MakeValidEverettIdentifier(string name);
}
public class Microsoft.Build.Tasks.CreateProperty : TaskExtension {
    [CompilerGeneratedAttribute]
private String[] <Value>k__BackingField;
    [OutputAttribute]
public String[] Value { get; public set; }
    [OutputAttribute]
public String[] ValueSetByTask { get; }
    [CompilerGeneratedAttribute]
public String[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(String[] value);
    public String[] get_ValueSetByTask();
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName : CreateManifestResourceName {
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log);
    protected virtual bool IsSourceFile(string fileName);
}
internal static class Microsoft.Build.Tasks.CSharpParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
    private static ExtractedClassName Extract(CSharpTokenizer tokens);
}
internal static class Microsoft.Build.Tasks.Culture : object {
    internal static ItemCultureInfo GetItemCultureInfo(string name, string dependentUponFilename);
}
internal static class Microsoft.Build.Tasks.CultureInfoCache : object {
    private static HashSet`1<string> ValidCultureNames;
    private static HashSet`1<string> HardcodedCultureNames;
    private static CultureInfoCache();
    internal static bool IsValidCultureString(string name);
}
public class Microsoft.Build.Tasks.Delete : TaskExtension {
    private ITaskItem[] _files;
    private bool _canceling;
    [CompilerGeneratedAttribute]
private bool <TreatErrorsAsWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DeletedFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public bool TreatErrorsAsWarnings { get; public set; }
    [OutputAttribute]
public ITaskItem[] DeletedFiles { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_TreatErrorsAsWarnings();
    [CompilerGeneratedAttribute]
public void set_TreatErrorsAsWarnings(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DeletedFiles();
    [CompilerGeneratedAttribute]
public void set_DeletedFiles(ITaskItem[] value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private void LogError(ITaskItem file, Exception e);
}
internal class Microsoft.Build.Tasks.Dependencies : object {
    private Hashtable dependencies;
    internal DependencyFile GetDependencyFile(string filename);
    internal void AddDependencyFile(string filename, DependencyFile file);
    internal void RemoveDependencyFile(string filename);
    internal void Clear();
}
internal class Microsoft.Build.Tasks.DependencyFile : object {
    private string filename;
    private DateTime lastModified;
    private bool exists;
    internal string FileName { get; }
    internal DateTime LastModified { get; }
    internal bool Exists { get; }
    internal DependencyFile(string filename);
    internal string get_FileName();
    internal DateTime get_LastModified();
    internal bool get_Exists();
    internal bool HasFileChanged();
}
internal class Microsoft.Build.Tasks.DependencyResolutionException : Exception {
    internal DependencyResolutionException(string message, Exception innerException);
    private DependencyResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.DependentAssembly : object {
    [CompilerGeneratedAttribute]
private AssemblyName <AssemblyNameReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BindingRedirect> <BindingRedirects>k__BackingField;
    internal AssemblyName PartialAssemblyName { get; internal set; }
    internal AssemblyName AssemblyNameReadOnly { get; private set; }
    internal List`1<BindingRedirect> BindingRedirects { get; internal set; }
    internal void set_PartialAssemblyName(AssemblyName value);
    internal AssemblyName get_PartialAssemblyName();
    [CompilerGeneratedAttribute]
internal AssemblyName get_AssemblyNameReadOnly();
    [CompilerGeneratedAttribute]
private void set_AssemblyNameReadOnly(AssemblyName value);
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal void set_BindingRedirects(List`1<BindingRedirect> value);
    [CompilerGeneratedAttribute]
internal List`1<BindingRedirect> get_BindingRedirects();
}
internal class Microsoft.Build.Tasks.DirectoryResolver : Resolver {
    public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal abstract class Microsoft.Build.Tasks.DisposableBase : object {
    private bool _disposed;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual void DisposeManagedResources();
    protected virtual void DisposeUnmanagedResources();
}
public class Microsoft.Build.Tasks.DownloadFile : TaskExtension {
    private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DownloadedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMessageHandler <HttpMessageHandler>k__BackingField;
    public ITaskItem DestinationFileName { get; public set; }
    [RequiredAttribute]
public ITaskItem DestinationFolder { get; public set; }
    [OutputAttribute]
public ITaskItem DownloadedFile { get; public set; }
    public int Retries { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [RequiredAttribute]
public string SourceUrl { get; public set; }
    internal HttpMessageHandler HttpMessageHandler { get; internal set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFileName();
    [CompilerGeneratedAttribute]
public void set_DestinationFileName(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DownloadedFile();
    [CompilerGeneratedAttribute]
public void set_DownloadedFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
internal HttpMessageHandler get_HttpMessageHandler();
    [CompilerGeneratedAttribute]
internal void set_HttpMessageHandler(HttpMessageHandler value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private void Download(Uri uri);
    private static bool IsRetriable(Exception exception, Exception& actualException);
    private bool TryGetFileName(HttpResponseMessage response, String& filename);
    private bool ShouldSkip(HttpResponseMessage response, FileInfo destinationFile);
}
public class Microsoft.Build.Tasks.Error : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ErrorFromResources : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [RequiredAttribute]
public string Resource { get; public set; }
    public String[] Arguments { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(String[] value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Exec : ToolTaskExtension {
    private static string UseUtf8Always;
    private static string UseUtf8Never;
    private static string UseUtf8Detect;
    private bool _encodingParametersValid;
    private string _workingDirectory;
    private ITaskItem[] _outputs;
    internal bool workingDirectoryIsUNC;
    private string _batchFile;
    private string _customErrorRegex;
    private string _customWarningRegex;
    private List`1<ITaskItem> _nonEmptyOutput;
    private Encoding _standardErrorEncoding;
    private Encoding _standardOutputEncoding;
    private string _command;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConsoleToMSBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreStandardErrorWarningFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseUtf8Encoding>k__BackingField;
    private static Lazy`1<string> CommandProcessorPath;
    private static Encoding s_utf8WithoutBom;
    [RequiredAttribute]
public string Command { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool IgnoreExitCode { get; public set; }
    public bool ConsoleToMSBuild { get; public set; }
    public string CustomErrorRegularExpression { get; public set; }
    public string CustomWarningRegularExpression { get; public set; }
    public bool IgnoreStandardErrorWarningFormat { get; public set; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    public string UseUtf8Encoding { get; public set; }
    [OutputAttribute]
public string StdOutEncoding { get; public set; }
    [OutputAttribute]
public string StdErrEncoding { get; public set; }
    [OutputAttribute]
public ITaskItem[] Outputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] ConsoleOutput { get; }
    protected string ToolName { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    private static Exec();
    public string get_Command();
    public void set_Command(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExitCode();
    [CompilerGeneratedAttribute]
public void set_IgnoreExitCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConsoleToMSBuild();
    [CompilerGeneratedAttribute]
public void set_ConsoleToMSBuild(bool value);
    public string get_CustomErrorRegularExpression();
    public void set_CustomErrorRegularExpression(string value);
    public string get_CustomWarningRegularExpression();
    public void set_CustomWarningRegularExpression(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreStandardErrorWarningFormat();
    [CompilerGeneratedAttribute]
public void set_IgnoreStandardErrorWarningFormat(bool value);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    [CompilerGeneratedAttribute]
public string get_UseUtf8Encoding();
    [CompilerGeneratedAttribute]
public void set_UseUtf8Encoding(string value);
    public string get_StdOutEncoding();
    public void set_StdOutEncoding(string value);
    public string get_StdErrEncoding();
    public void set_StdErrEncoding(string value);
    public ITaskItem[] get_Outputs();
    public void set_Outputs(ITaskItem[] value);
    public ITaskItem[] get_ConsoleOutput();
    private void CreateTemporaryBatchFile();
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    protected virtual void LogToolCommand(string message);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private bool OutputMatchesRegex(string singleLine, String& regularExpression);
    protected virtual bool ValidateParameters();
    internal bool ValidateParametersAccessor();
    protected virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    internal string GetWorkingDirectoryAccessor();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    private Encoding BatchFileEncoding();
    internal static bool CanEncodeString(int codePage, string stringToEncode);
}
public class Microsoft.Build.Tasks.ExtractedClassName : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsInsideConditionalBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsInsideConditionalBlock { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsInsideConditionalBlock();
    [CompilerGeneratedAttribute]
public void set_IsInsideConditionalBlock(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Microsoft.Build.Tasks.FileState : object {
    private string _filename;
    private Lazy`1<FileDirInfo> _data;
    internal bool IsReadOnly { get; }
    internal bool FileExists { get; }
    internal bool DirectoryExists { get; }
    internal DateTime LastWriteTime { get; }
    internal DateTime LastWriteTimeUtcFast { get; }
    internal long Length { get; }
    internal string Name { get; }
    internal bool IsDirectory { get; }
    internal FileState(string filename);
    internal bool get_IsReadOnly();
    internal bool get_FileExists();
    internal bool get_DirectoryExists();
    internal DateTime get_LastWriteTime();
    internal DateTime get_LastWriteTimeUtcFast();
    internal long get_Length();
    internal string get_Name();
    internal bool get_IsDirectory();
    internal void Reset();
    [CompilerGeneratedAttribute]
private FileDirInfo <.ctor>b__3_0();
    [CompilerGeneratedAttribute]
private FileDirInfo <Reset>b__20_0();
}
public class Microsoft.Build.Tasks.FindAppConfigFile : TaskExtension {
    private ITaskItem[] _primaryList;
    private ITaskItem[] _secondaryList;
    private static string appConfigFile;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AppConfigFile>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] PrimaryList { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SecondaryList { get; public set; }
    [RequiredAttribute]
public string TargetPath { get; public set; }
    [OutputAttribute]
public ITaskItem AppConfigFile { get; public set; }
    public ITaskItem[] get_PrimaryList();
    public void set_PrimaryList(ITaskItem[] value);
    public ITaskItem[] get_SecondaryList();
    public void set_SecondaryList(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public void set_TargetPath(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AppConfigFile();
    [CompilerGeneratedAttribute]
public void set_AppConfigFile(ITaskItem value);
    public virtual bool Execute();
    private bool ConsultLists(bool matchWholeItemSpec);
    private bool IsMatchingItem(ITaskItem item, bool matchWholeItemSpec);
}
public class Microsoft.Build.Tasks.FindInList : TaskExtension {
    private ITaskItem[] _list;
    [CompilerGeneratedAttribute]
private bool <MatchFileNameOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ItemFound>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemSpecToFind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindLastMatch>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] List { get; public set; }
    public bool MatchFileNameOnly { get; public set; }
    [OutputAttribute]
public ITaskItem ItemFound { get; public set; }
    [RequiredAttribute]
public string ItemSpecToFind { get; public set; }
    public bool CaseSensitive { get; public set; }
    public bool FindLastMatch { get; public set; }
    public ITaskItem[] get_List();
    public void set_List(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_MatchFileNameOnly();
    [CompilerGeneratedAttribute]
public void set_MatchFileNameOnly(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ItemFound();
    [CompilerGeneratedAttribute]
public void set_ItemFound(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_ItemSpecToFind();
    [CompilerGeneratedAttribute]
public void set_ItemSpecToFind(string value);
    [CompilerGeneratedAttribute]
public bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindLastMatch();
    [CompilerGeneratedAttribute]
public void set_FindLastMatch(bool value);
    public virtual bool Execute();
    private bool IsMatchingItem(StringComparison comparison, ITaskItem item);
}
public class Microsoft.Build.Tasks.FindUnderPath : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateToAbsolutePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutOfPath>k__BackingField;
    [RequiredAttribute]
public ITaskItem Path { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool UpdateToAbsolutePaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] InPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutOfPath { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_UpdateToAbsolutePaths();
    [CompilerGeneratedAttribute]
public void set_UpdateToAbsolutePaths(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InPath();
    [CompilerGeneratedAttribute]
public void set_InPath(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutOfPath();
    [CompilerGeneratedAttribute]
public void set_OutOfPath(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FormatVersion : TaskExtension {
    private _FormatType _formatType;
    [CompilerGeneratedAttribute]
private string <OutputVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [OutputAttribute]
public string OutputVersion { get; public set; }
    public string FormatType { get; public set; }
    public int Revision { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputVersion();
    [CompilerGeneratedAttribute]
public void set_OutputVersion(string value);
    [CompilerGeneratedAttribute]
public string get_FormatType();
    [CompilerGeneratedAttribute]
public void set_FormatType(string value);
    [CompilerGeneratedAttribute]
public int get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(int value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public virtual bool Execute();
    private bool ValidateInputs();
}
internal class Microsoft.Build.Tasks.FrameworkPathResolver : Resolver {
    private String[] _frameworkPaths;
    private InstalledAssemblies _installedAssemblies;
    public FrameworkPathResolver(String[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssemblies installedAssemblies, AssemblyNameExtension assemblyName);
}
public class Microsoft.Build.Tasks.GenerateBindingRedirects : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <SuggestedRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AppConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputAppConfigFile>k__BackingField;
    public ITaskItem[] SuggestedRedirects { get; public set; }
    public ITaskItem AppConfigFile { get; public set; }
    public string TargetName { get; public set; }
    [OutputAttribute]
public ITaskItem OutputAppConfigFile { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SuggestedRedirects();
    [CompilerGeneratedAttribute]
public void set_SuggestedRedirects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AppConfigFile();
    [CompilerGeneratedAttribute]
public void set_AppConfigFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputAppConfigFile();
    [CompilerGeneratedAttribute]
public void set_OutputAppConfigFile(ITaskItem value);
    public virtual bool Execute();
    private static bool IsMatch(AssemblyName suggestedRedirect, string name, string culture, string publicKeyToken);
    private static bool ByteArrayMatchesString(Byte[] a, string s);
    private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary`2<AssemblyName, string> redirects);
    private XDocument LoadAppConfig(ITaskItem appConfigItem);
    private IDictionary`2<AssemblyName, string> ParseSuggestedRedirects();
}
[RequiredRuntimeAttribute("v2.0")]
public class Microsoft.Build.Tasks.GenerateResource : TaskExtension {
    private string CSharpLanguageName;
    private string VisualBasicLanguageName;
    private ITaskItem[] _sources;
    private bool _useSourcePath;
    private ITaskItem[] _references;
    private ITaskItem[] _additionalInputs;
    private ITaskItem _stateFile;
    private ITaskItem[] _outputResources;
    private ArrayList _unsuccessfullyCreatedOutFiles;
    private ArrayList _filesWritten;
    private string _stronglyTypedLanguage;
    private string _stronglyTypedNamespace;
    private string _stronglyTypedManifestPrefix;
    private string _stronglyTypedClassName;
    private string _stronglyTypedFileName;
    private bool _publicClass;
    private bool _stronglyTypedResourceSuccessfullyCreated;
    private bool _neverLockTypeAssemblies;
    private bool _foundNewestUncorrelatedInputWriteTime;
    private DateTime _newestUncorrelatedInputWriteTime;
    private string _sdkToolsPath;
    private bool _executeAsTool;
    private string _resgenPath;
    private Dictionary`2<string, Type> _typeTable;
    private Dictionary`2<string, string> _aliases;
    private static int s_maximumCommandLength;
    private ITaskItem[] _excludedInputPaths;
    private List`1<ITaskItem> _satelliteInputs;
    [CompilerGeneratedAttribute]
private bool <ExtractResWFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    private static Char[] s_specialChars;
    [RequiredAttribute]
[OutputAttribute]
public ITaskItem[] Sources { get; public set; }
    public bool UseSourcePath { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] AdditionalInputs { get; public set; }
    public ITaskItem StateFile { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputResources { get; public set; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; }
    public string StronglyTypedLanguage { get; public set; }
    public string StronglyTypedNamespace { get; public set; }
    public string StronglyTypedManifestPrefix { get; public set; }
    [OutputAttribute]
public string StronglyTypedClassName { get; public set; }
    [OutputAttribute]
public string StronglyTypedFileName { get; public set; }
    public bool PublicClass { get; public set; }
    public bool ExtractResWFiles { get; public set; }
    public bool NeverLockTypeAssemblies { get; public set; }
    public string SdkToolsPath { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public ITaskItem[] ExcludedInputPaths { get; public set; }
    public bool MinimalRebuildFromTracking { get; public set; }
    public bool TrackFileAccess { get; public set; }
    public ITaskItem[] TLogReadFiles { get; }
    public ITaskItem[] TLogWriteFiles { get; }
    public string TrackerLogDirectory { get; public set; }
    public string ToolArchitecture { get; public set; }
    public string TrackerFrameworkPath { get; public set; }
    public string TrackerSdkPath { get; public set; }
    public string OutputDirectory { get; public set; }
    private static GenerateResource();
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_UseSourcePath(bool value);
    public bool get_UseSourcePath();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    public void set_AdditionalInputs(ITaskItem[] value);
    public ITaskItem[] get_AdditionalInputs();
    public void set_StateFile(ITaskItem value);
    public ITaskItem get_StateFile();
    public void set_OutputResources(ITaskItem[] value);
    public ITaskItem[] get_OutputResources();
    public ITaskItem[] get_FilesWritten();
    public void set_StronglyTypedLanguage(string value);
    public string get_StronglyTypedLanguage();
    public void set_StronglyTypedNamespace(string value);
    public string get_StronglyTypedNamespace();
    public void set_StronglyTypedManifestPrefix(string value);
    public string get_StronglyTypedManifestPrefix();
    public void set_StronglyTypedClassName(string value);
    public string get_StronglyTypedClassName();
    public void set_StronglyTypedFileName(string value);
    public string get_StronglyTypedFileName();
    public void set_PublicClass(bool value);
    public bool get_PublicClass();
    [CompilerGeneratedAttribute]
public bool get_ExtractResWFiles();
    [CompilerGeneratedAttribute]
public void set_ExtractResWFiles(bool value);
    public void set_NeverLockTypeAssemblies(bool value);
    public bool get_NeverLockTypeAssemblies();
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public void set_ExecuteAsTool(bool value);
    public bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    public ITaskItem[] get_ExcludedInputPaths();
    public void set_ExcludedInputPaths(ITaskItem[] value);
    public bool get_MinimalRebuildFromTracking();
    public void set_MinimalRebuildFromTracking(bool value);
    public bool get_TrackFileAccess();
    public void set_TrackFileAccess(bool value);
    public ITaskItem[] get_TLogReadFiles();
    public ITaskItem[] get_TLogWriteFiles();
    public string get_TrackerLogDirectory();
    public void set_TrackerLogDirectory(string value);
    public string get_ToolArchitecture();
    public void set_ToolArchitecture(string value);
    public string get_TrackerFrameworkPath();
    public void set_TrackerFrameworkPath(string value);
    public string get_TrackerSdkPath();
    public void set_TrackerSdkPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    private void LogResgenCommandLine(List`1<ITaskItem> inputFiles, List`1<ITaskItem> outputFiles);
    private void GenerateResGenCommandLineWithoutResources(CommandLineBuilderExtension resGenCommand);
    public virtual bool Execute();
    private bool IsDangerous(string filename);
    private static ITaskItem[] CloneValuesInThisAppDomain(IList`1<ITaskItem> remoteValues);
    private bool ComputePathToResGen();
    private bool GenerateResourcesUsingResGen(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess);
    private int CalculateResourceBatchSize(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess, string resourcelessCommand, int initialResourceIndex);
    private bool ValidateParameters();
    private void GetResourcesToProcess(List`1& inputsToProcess, List`1& outputsToProcess, List`1& cachedOutputFiles);
    private bool ContainsDuplicates(IList`1<ITaskItem> originalList);
    private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputFilePath);
    private bool NeedToRebuildSourceFile(DateTime sourceTime, DateTime outputTime);
    private void GetStronglyTypedResourceToProcess(List`1& inputsToProcess, List`1& outputsToProcess);
    private DateTime GetNewestUncorrelatedInputWriteTime();
    private static Byte[] ByteArrayFromBase64WrappedString(string text);
    private bool CreateOutputResourcesNames();
    private void RemoveUnsuccessfullyCreatedResourcesFromOutputResources();
    private void RecordFilesWritten();
    private string TryGenerateDefaultStronglyTypedFilename();
}
public class Microsoft.Build.Tasks.GetAssemblyIdentity : TaskExtension {
    private ITaskItem[] _assemblyFiles;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] AssemblyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    private static string ByteArrayToHex(Byte[] a);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetAssemblyMetadata : MulticastDelegate {
    public GetAssemblyMetadata(object object, IntPtr method);
    public virtual void Invoke(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute);
    public virtual IAsyncResult BeginInvoke(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, AsyncCallback callback, object object);
    public virtual void EndInvoke(AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyName : MulticastDelegate {
    public GetAssemblyName(object object, IntPtr method);
    public virtual AssemblyNameExtension Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual AssemblyNameExtension EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyPathInGac : MulticastDelegate {
    public GetAssemblyPathInGac(object object, IntPtr method);
    public virtual string Invoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
    public virtual IAsyncResult BeginInvoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyRuntimeVersion : MulticastDelegate {
    public GetAssemblyRuntimeVersion(object object, IntPtr method);
    public virtual string Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAttributes : MulticastDelegate {
    public GetAttributes(object object, IntPtr method);
    public virtual FileAttributes Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileAttributes EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetFileHash : TaskExtension {
    internal static string _defaultFileHashAlgorithm;
    internal static string _hashEncodingHex;
    internal static string _hashEncodingBase64;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetadataName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Items>k__BackingField;
    private static HashSet`1<string> _supportedAlgorithms;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public string Algorithm { get; public set; }
    public string MetadataName { get; public set; }
    public string HashEncoding { get; public set; }
    [OutputAttribute]
public string Hash { get; public set; }
    [OutputAttribute]
public ITaskItem[] Items { get; public set; }
    private static GetFileHash();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    [CompilerGeneratedAttribute]
public string get_MetadataName();
    [CompilerGeneratedAttribute]
public void set_MetadataName(string value);
    [CompilerGeneratedAttribute]
public string get_HashEncoding();
    [CompilerGeneratedAttribute]
public void set_HashEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ITaskItem[] value);
    public virtual bool Execute();
    internal static string EncodeHash(HashEncoding encoding, Byte[] hash);
    internal static bool TryParseHashEncoding(string value, HashEncoding& encoding);
    internal static bool SupportsAlgorithm(string algorithmName);
    internal static Byte[] ComputeHash(string algorithmName, string filePath);
    private static HashAlgorithm CreateAlgorithm(string algorithmName);
}
public class Microsoft.Build.Tasks.GetFrameworkPath : TaskExtension {
    private static Lazy`1<string> s_path;
    private static Lazy`1<string> s_version11Path;
    private static Lazy`1<string> s_version20Path;
    private static Lazy`1<string> s_version30Path;
    private static Lazy`1<string> s_version35Path;
    private static Lazy`1<string> s_version40Path;
    private static Lazy`1<string> s_version45Path;
    private static Lazy`1<string> s_version451Path;
    private static Lazy`1<string> s_version452Path;
    private static Lazy`1<string> s_version46Path;
    private static Lazy`1<string> s_version461Path;
    private static Lazy`1<string> s_version462Path;
    private static Lazy`1<string> s_version47Path;
    private static Lazy`1<string> s_version471Path;
    private static Lazy`1<string> s_version472Path;
    [OutputAttribute]
public string Path { get; }
    [OutputAttribute]
public string FrameworkVersion11Path { get; }
    [OutputAttribute]
public string FrameworkVersion20Path { get; }
    [OutputAttribute]
public string FrameworkVersion30Path { get; }
    [OutputAttribute]
public string FrameworkVersion35Path { get; }
    [OutputAttribute]
public string FrameworkVersion40Path { get; }
    [OutputAttribute]
public string FrameworkVersion45Path { get; }
    [OutputAttribute]
public string FrameworkVersion451Path { get; }
    [OutputAttribute]
public string FrameworkVersion452Path { get; }
    [OutputAttribute]
public string FrameworkVersion46Path { get; }
    [OutputAttribute]
public string FrameworkVersion461Path { get; }
    [OutputAttribute]
public string FrameworkVersion462Path { get; }
    [OutputAttribute]
public string FrameworkVersion47Path { get; }
    [OutputAttribute]
public string FrameworkVersion471Path { get; }
    [OutputAttribute]
public string FrameworkVersion472Path { get; }
    private static GetFrameworkPath();
    public virtual bool Execute();
    public string get_Path();
    public string get_FrameworkVersion11Path();
    public string get_FrameworkVersion20Path();
    public string get_FrameworkVersion30Path();
    public string get_FrameworkVersion35Path();
    public string get_FrameworkVersion40Path();
    public string get_FrameworkVersion45Path();
    public string get_FrameworkVersion451Path();
    public string get_FrameworkVersion452Path();
    public string get_FrameworkVersion46Path();
    public string get_FrameworkVersion461Path();
    public string get_FrameworkVersion462Path();
    public string get_FrameworkVersion47Path();
    public string get_FrameworkVersion471Path();
    public string get_FrameworkVersion472Path();
}
internal class Microsoft.Build.Tasks.GetGacEnumerator : MulticastDelegate {
    public GetGacEnumerator(object object, IntPtr method);
    public virtual IEnumerable`1<AssemblyNameExtension> Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual IEnumerable`1<AssemblyNameExtension> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetLastWriteTime : MulticastDelegate {
    public GetLastWriteTime(object object, IntPtr method);
    public virtual DateTime Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetPathFromFusionName : MulticastDelegate {
    public GetPathFromFusionName(object object, IntPtr method);
    public virtual string Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetReferenceAssemblyPaths : TaskExtension {
    private IList`1<string> _tfmPaths;
    private IList`1<string> _tfmPathsNoProfile;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BypassFrameworkInstallChecks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressNotFoundError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMonikerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkFallbackSearchPaths>k__BackingField;
    [OutputAttribute]
public String[] ReferenceAssemblyPaths { get; }
    [OutputAttribute]
public String[] FullFrameworkReferenceAssemblyPaths { get; }
    public string TargetFrameworkMoniker { get; public set; }
    public string RootPath { get; public set; }
    public bool BypassFrameworkInstallChecks { get; public set; }
    public bool SuppressNotFoundError { get; public set; }
    [OutputAttribute]
public string TargetFrameworkMonikerDisplayName { get; public set; }
    public string TargetFrameworkFallbackSearchPaths { get; public set; }
    public String[] get_ReferenceAssemblyPaths();
    public String[] get_FullFrameworkReferenceAssemblyPaths();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public void set_RootPath(string value);
    [CompilerGeneratedAttribute]
public bool get_BypassFrameworkInstallChecks();
    [CompilerGeneratedAttribute]
public void set_BypassFrameworkInstallChecks(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressNotFoundError();
    [CompilerGeneratedAttribute]
public void set_SuppressNotFoundError(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkFallbackSearchPaths();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkFallbackSearchPaths(string value);
    public virtual bool Execute();
    private IList`1<string> GetPaths(string rootPath, string targetFrameworkFallbackSearchPaths, FrameworkName frameworkmoniker);
}
public class Microsoft.Build.Tasks.Hash : TaskExtension {
    private static string ItemSeparatorCharacter;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ItemsToHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashResult>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] ItemsToHash { get; public set; }
    [OutputAttribute]
public string HashResult { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ItemsToHash();
    [CompilerGeneratedAttribute]
public void set_ItemsToHash(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_HashResult();
    [CompilerGeneratedAttribute]
public void set_HashResult(string value);
    public virtual bool Execute();
}
internal enum Microsoft.Build.Tasks.HashEncoding : Enum {
    public int value__;
    public static HashEncoding Hex;
    public static HashEncoding Base64;
}
internal class Microsoft.Build.Tasks.HintPathResolver : Resolver {
    public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
public interface Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject {
    public abstract virtual bool SetAnalyzers(ITaskItem[] analyzers);
    public abstract virtual bool SetRuleSet(string ruleSetFile);
    public abstract virtual bool SetAdditionalFiles(ITaskItem[] additionalFiles);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject {
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual void BeginInitialization();
    public abstract virtual bool EndInitialization(String& errorMessage, Int32& errorCode);
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetAllowUnsafeBlocks(bool allowUnsafeBlocks);
    public abstract virtual bool SetBaseAddress(string baseAddress);
    public abstract virtual bool SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySignExplicitlySet, bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetEmitDebugInformation(bool emitDebugInformation);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateFullPaths(bool generateFullPaths);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLangVersion(string langVersion);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string targetType, string mainEntryPoint);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetPdbFile(string pdbFile);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningLevel(int warningLevel);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject2 {
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject3 {
    public abstract virtual bool SetApplicationConfiguration(string applicationConfiguration);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject4 {
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject {
    public abstract virtual void BeginInitialization();
    public abstract virtual void EndInitialization();
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetBaseAddress(string targetType, string baseAddress);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(bool emitDebugInformation, string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateDocumentation(bool generateDocumentation);
    public abstract virtual bool SetImports(ITaskItem[] importsList);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string mainEntryPoint);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetNoWarnings(bool noWarnings);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOptionCompare(string optionCompare);
    public abstract virtual bool SetOptionExplicit(bool optionExplicit);
    public abstract virtual bool SetOptionStrict(bool optionStrict);
    public abstract virtual bool SetOptionStrictType(string optionStrictType);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetRemoveIntegerChecks(bool removeIntegerChecks);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetRootNamespace(string rootNamespace);
    public abstract virtual bool SetSdkPath(string sdkPath);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetCompactFramework(bool targetCompactFramework);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject2 {
    public abstract virtual bool SetOptionInfer(bool optionInfer);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject3 {
    public abstract virtual bool SetLanguageVersion(string languageVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject4 {
    public abstract virtual bool SetVBRuntime(string VBRuntime);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject5 {
    public abstract virtual IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
    public abstract virtual int CompileAsync(IntPtr& buildSucceededEvent, IntPtr& buildFailedEvent);
    public abstract virtual int EndCompile(bool buildSuccess);
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded {
    public abstract virtual bool Compile();
}
internal class Microsoft.Build.Tasks.InstalledAssemblies : object {
    private RedistList _redistList;
    internal InstalledAssemblies(RedistList redistList);
    internal void GetInfo(AssemblyNameExtension assemblyName, Version& unifiedVersion, Boolean& isPrerequisite, Nullable`1& isRedistRoot, String& redistName);
    internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension assemblyName);
    internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension assemblyName);
    internal bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    internal IEnumerable`1<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName);
}
internal class Microsoft.Build.Tasks.InstalledSDKResolver : Resolver {
    private Dictionary`2<string, ITaskItem> _resolvedSDKs;
    public InstalledSDKResolver(Dictionary`2<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.InvalidParameterValueException : Exception {
    [CompilerGeneratedAttribute]
private string <ParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActualValue>k__BackingField;
    public string ParamName { get; public set; }
    public string ActualValue { get; public set; }
    internal InvalidParameterValueException(string paramName, string actualValue, string message);
    internal InvalidParameterValueException(string paramName, string actualValue, string message, Exception innerException);
    private InvalidParameterValueException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ParamName();
    [CompilerGeneratedAttribute]
public void set_ParamName(string value);
    [CompilerGeneratedAttribute]
public string get_ActualValue();
    [CompilerGeneratedAttribute]
public void set_ActualValue(string value);
}
internal class Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException : Exception {
    [CompilerGeneratedAttribute]
private string <SourceItemSpec>k__BackingField;
    internal string SourceItemSpec { get; }
    internal InvalidReferenceAssemblyNameException(string sourceItemSpec);
    private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal string get_SourceItemSpec();
}
internal class Microsoft.Build.Tasks.IsWinMDFile : MulticastDelegate {
    public IsWinMDFile(object object, IntPtr method);
    public virtual bool Invoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    public virtual IAsyncResult BeginInvoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& imageRuntimeVersion, Boolean& isManagedWinmd, IAsyncResult result);
}
internal static class Microsoft.Build.Tasks.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
}
public class Microsoft.Build.Tasks.MakeDir : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <DirectoriesCreated>k__BackingField;
    private ITaskItem[] _directories;
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] DirectoriesCreated { get; private set; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DirectoriesCreated();
    [CompilerGeneratedAttribute]
private void set_DirectoriesCreated(ITaskItem[] value);
    public virtual bool Execute();
}
internal static class Microsoft.Build.Tasks.ManagedRuntimeVersionReader : object {
    public static string GetRuntimeVersion(string path);
    private static bool ReadBytes(BinaryReader r, Byte[] bytes);
    private static UInt32 RvaToOffset(HeaderInfo[] sections, UInt32 rva);
}
public class Microsoft.Build.Tasks.Message : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCritical>k__BackingField;
    public string Text { get; public set; }
    public string Importance { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public bool IsCritical { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Importance();
    [CompilerGeneratedAttribute]
public void set_Importance(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public bool get_IsCritical();
    [CompilerGeneratedAttribute]
public void set_IsCritical(bool value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Move : TaskExtension {
    private static MoveFileFlags Flags;
    private bool _canceling;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DestinationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <MovedFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] MovedFiles { get; private set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DestinationFiles();
    [CompilerGeneratedAttribute]
public void set_DestinationFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_MovedFiles();
    [CompilerGeneratedAttribute]
private void set_MovedFiles(ITaskItem[] value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private static void MakeWriteableIfReadOnly(string file);
    private bool MoveFileWithLogging(string sourceFile, string destinationFile);
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.MSBuild : TaskExtension {
    private List`1<ITaskItem> _targetOutputs;
    private SkipNonexistentProjectsBehavior _skipNonexistentProjects;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoveProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebaseOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildInParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnloadProjectsOnCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetAndPropertyListSeparators>k__BackingField;
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public string get_RemoveProperties();
    [CompilerGeneratedAttribute]
public void set_RemoveProperties(string value);
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RebaseOutputs();
    [CompilerGeneratedAttribute]
public void set_RebaseOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFirstFailure();
    [CompilerGeneratedAttribute]
public void set_StopOnFirstFailure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_BuildInParallel();
    [CompilerGeneratedAttribute]
public void set_BuildInParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnloadProjectsOnCompletion();
    [CompilerGeneratedAttribute]
public void set_UnloadProjectsOnCompletion(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    [CompilerGeneratedAttribute]
public String[] get_TargetAndPropertyListSeparators();
    [CompilerGeneratedAttribute]
public void set_TargetAndPropertyListSeparators(String[] value);
    public virtual bool Execute();
    private bool BuildProjectsInParallel(Dictionary`2<string, string> propertiesTable, String[] undefinePropertiesArray, List`1<String[]> targetLists, bool success, Boolean[] skipProjects);
    private void ExpandAllTargetsAndProperties();
    internal static List`1<String[]> CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    internal static bool ExecuteTargets(List`1<ITaskItem> projects, Dictionary`2<string, string> propertiesTable, String[] undefineProperties, List`1<String[]> targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, List`1<ITaskItem> targetOutputs, bool useResultsCache, bool unloadProjectsOnCompletion, string toolsVersion);
}
internal static class Microsoft.Build.Tasks.MSBuildConstants : object {
    internal static string ToolsPath;
    internal static string ToolsPath64;
    internal static string SdksPath;
    internal static string TreatWarningsAsErrors;
    internal static string WarningsAsErrors;
    internal static string WarningsAsMessages;
    internal static string NuGetAssemblyPathEnvironmentVariableName;
    internal static string RestoreTargetName;
    internal static string CurrentVisualStudioVersion;
    internal static string CurrentToolsVersion;
    internal static string MSBuildDummyGlobalPropertyHeader;
    internal static Version CurrentToolsVersionAsVersion;
    internal static string CurrentAssemblyVersion;
    internal static string CurrentProductVersion { get; }
    private static MSBuildConstants();
    internal static string get_CurrentProductVersion();
}
internal static class Microsoft.Build.Tasks.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidIntPtr;
    internal static UInt32 NORMAL_PRIORITY_CLASS;
    internal static UInt32 CREATE_NO_WINDOW;
    internal static int STARTF_USESTDHANDLES;
    internal static int ERROR_SUCCESS;
    internal static int TYPE_E_REGISTRYACCESS;
    internal static int TYPE_E_CANTLOADLIBRARY;
    internal static int HRESULT_E_CLASSNOTREGISTERED;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_SHARING_VIOLATION;
    internal static Guid GUID_TYPELIB_NAMESPACE;
    internal static Guid GUID_ExportedFromComPlus;
    internal static Guid IID_IUnknown;
    internal static Guid IID_IDispatch;
    internal static Guid IID_ITypeInfo;
    internal static Guid IID_IEnumVariant;
    internal static Guid IID_IDispatchEx;
    internal static Guid IID_StdOle;
    internal static ushort IMAGE_FILE_MACHINE_UNKNOWN;
    internal static ushort IMAGE_FILE_MACHINE_INVALID;
    internal static ushort IMAGE_FILE_MACHINE_AMD64;
    internal static ushort IMAGE_FILE_MACHINE_ARM;
    internal static ushort IMAGE_FILE_MACHINE_ARMV7;
    internal static ushort IMAGE_FILE_MACHINE_I386;
    internal static ushort IMAGE_FILE_MACHINE_IA64;
    internal static ushort IMAGE_FILE_MACHINE_R4000;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 PAGE_READONLY;
    internal static UInt32 FILE_MAP_READ;
    internal static UInt32 FILE_TYPE_DISK;
    internal static int SE_ERR_ACCESSDENIED;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    internal static UInt32 IMAGE_DIRECTORY_ENTRY_COMHEADER;
    internal static UInt32 COMIMAGE_FLAGS_STRONGNAMESIGNED;
    private static string Crypt32DLL;
    private static string Advapi32DLL;
    private static string MscoreeDLL;
    private static NativeMethods();
    private static bool CreateHardLink(string newFileName, string exitingFileName, IntPtr securityAttributes);
    internal static int link(string oldpath, string newpath);
    internal static bool MakeHardLink(string newFileName, string exitingFileName, String& errorMessage);
    internal static bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
    internal static int symlink(string oldpath, string newpath);
    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, String& errorMessage);
    internal static bool MoveFileExWindows(string existingFileName, string newFileName, MoveFileFlags flags);
    internal static bool MoveFileEx(string existingFileName, string newFileName, MoveFileFlags flags);
    internal static void RegisterTypeLib(object pTypeLib, string szFullPath, string szHelpDir);
    internal static void UnregisterTypeLib(Guid& guid, short wMajorVerNum, short wMinorVerNum, int lcid, SYSKIND syskind);
    internal static object LoadTypeLibEx(string szFullPath, int regKind);
    internal static object LoadRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static string QueryPathOfRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static IntPtr CreateFile(string lpFileName, UInt32 dwDesiredAccess, FileShare dwShareMode, IntPtr lpSecurityAttributes, FileMode dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static bool CloseHandle(IntPtr hObject);
    internal static IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, UInt32 flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    internal static IntPtr MapViewOfFile(IntPtr hFileMapping, UInt32 dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    internal static IntPtr ImageNtHeader(IntPtr imageBase);
    internal static IntPtr ImageRvaToVa(IntPtr ntHeaders, IntPtr imageBase, UInt32 Rva, IntPtr& LastRvaSection);
    private static UInt32 GetLogicalDrives();
    internal static bool AllDrivesMapped();
    internal static int CompareAssemblyIdentityWindows(string pwzAssemblyIdentity1, bool fUnified1, string pwzAssemblyIdentity2, bool fUnified2, Boolean& pfEquivalent, AssemblyComparisonResult& pResult);
    internal static void CompareAssemblyIdentity(string assemblyIdentity1, bool fUnified1, string assemblyIdentity2, bool fUnified2, Boolean& pfEquivalent, AssemblyComparisonResult& pResult);
    private static bool RefMatchesDef(AssemblyName ref, AssemblyName def);
    private static bool IsStrongNamed(AssemblyName assembly);
    private static bool CompareRefToDef(AssemblyName ref, AssemblyName def);
    internal static IntPtr PFXImportCertStore(IntPtr blob, string password, CryptFlags flags);
    internal static bool CertCloseStore(IntPtr CertStore, CertStoreClose Flags);
    internal static IntPtr CertEnumCertificatesInStore(IntPtr CertStore, IntPtr PrevCertContext);
    internal static bool CryptAcquireCertificatePrivateKey(IntPtr CertContext, UInt32 flags, IntPtr reserved, IntPtr& CryptProv, KeySpec& KeySpec, Boolean& CallerFreeProv);
    internal static bool CryptGetUserKey(IntPtr CryptProv, KeySpec KeySpec, IntPtr& Key);
    internal static bool CryptExportKey(IntPtr Key, IntPtr ExpKey, BlobType type, UInt32 Flags, IntPtr Data, UInt32& DataLen);
    internal static bool CryptDestroyKey(IntPtr hKey);
    internal static bool CryptReleaseContext(IntPtr Prov, UInt32 Flags);
    internal static bool CertFreeCertificateContext(IntPtr CertContext);
    internal static int CorSigUncompressData(IntPtr data, Int32& uncompressedDataLength);
}
internal enum Microsoft.Build.Tasks.NoMatchReason : Enum {
    public int value__;
    public static NoMatchReason Unknown;
    public static NoMatchReason FileNotFound;
    public static NoMatchReason FusionNamesDidNotMatch;
    public static NoMatchReason TargetHadNoFusionName;
    public static NoMatchReason NotInGac;
    public static NoMatchReason NotAFileNameOnDisk;
    public static NoMatchReason ProcessorArchitectureDoesNotMatch;
}
internal class Microsoft.Build.Tasks.ParseState : object {
    private int _openConditionalDirectives;
    private Stack _namespaceStack;
    [CompilerGeneratedAttribute]
private bool <ResolvingNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolvingClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    internal bool ResolvingNamespace { get; internal set; }
    internal bool ResolvingClass { get; internal set; }
    internal bool InsideConditionalDirective { get; }
    internal string Namespace { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_ResolvingNamespace();
    [CompilerGeneratedAttribute]
internal void set_ResolvingNamespace(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ResolvingClass();
    [CompilerGeneratedAttribute]
internal void set_ResolvingClass(bool value);
    internal bool get_InsideConditionalDirective();
    [CompilerGeneratedAttribute]
internal string get_Namespace();
    [CompilerGeneratedAttribute]
internal void set_Namespace(string value);
    internal void Reset();
    internal void OpenConditionalDirective();
    internal void CloseConditionalDirective();
    internal void PushNamespacePart(string namespacePart);
    internal string PopNamespacePart();
    internal string ComposeQualifiedClassName(string className);
}
internal class Microsoft.Build.Tasks.PROCESS_INFORMATION : ValueType {
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}
internal class Microsoft.Build.Tasks.ProcessResourceFiles : object {
    private List`1<ReaderInfo> _readers;
    private TaskLoggingHelper _logger;
    private string _stronglyTypedLanguage;
    private string _stronglyTypedFilename;
    private string _stronglyTypedNamespace;
    private string _stronglyTypedResourcesNamespace;
    private string _stronglyTypedClassName;
    private bool _stronglyTypedClassIsPublic;
    private ITaskItem[] _assemblyFiles;
    private List`1<ITaskItem> _inFiles;
    private List`1<ITaskItem> _satelliteInFiles;
    private List`1<ITaskItem> _outFiles;
    private bool _extractResWFiles;
    private string _resWOutputDirectory;
    private List`1<ITaskItem> _extractedResWFiles;
    private ArrayList _unsuccessfullyCreatedOutFiles;
    private bool _stronglyTypedResourceSuccessfullyCreated;
    private bool _useSourcePath;
    internal string StronglyTypedFilename { get; }
    internal string StronglyTypedClassName { get; }
    internal List`1<ITaskItem> ExtractedResWFiles { get; }
    internal ArrayList UnsuccessfullyCreatedOutFiles { get; }
    internal bool StronglyTypedResourceSuccessfullyCreated { get; }
    internal string get_StronglyTypedFilename();
    internal string get_StronglyTypedClassName();
    internal List`1<ITaskItem> get_ExtractedResWFiles();
    internal ArrayList get_UnsuccessfullyCreatedOutFiles();
    internal bool get_StronglyTypedResourceSuccessfullyCreated();
    internal void Run(TaskLoggingHelper log, ITaskItem[] assemblyFilesList, List`1<ITaskItem> inputs, List`1<ITaskItem> satelliteInputs, List`1<ITaskItem> outputs, bool sourcePath, string language, string namespacename, string resourcesNamespace, string filename, string classname, bool publicClass, bool extractingResWFiles, string resWOutputDirectory);
    private bool ProcessFile(string inFile, string outFileOrDir);
    private string EnsurePathIsShortEnough(string currentOutputFile, string currentOutputFileNoPath, string outputDirectory, string cultureName);
    private void RemoveCorruptedFile(string filename);
    private Format GetFormat(string filename);
    private void ReadResources(string filename, bool shouldUseSourcePath, string outFileOrDir);
    private void WriteResources(ReaderInfo reader, string filename);
    private void CreateStronglyTypedResources(ReaderInfo reader, string outFile, string inputFileName, String& sourceFile);
    private void ReadTextResources(ReaderInfo reader, string fileName);
    private void WriteResources(ReaderInfo reader, ResourceWriter writer);
    private void WriteTextResources(ReaderInfo reader, string fileName);
    private void AddResource(ReaderInfo reader, string name, object value, string inputFileName, int lineNumber, int linePosition);
    private void AddResource(ReaderInfo reader, string name, object value, string inputFileName);
}
internal static class Microsoft.Build.Tasks.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Dictionary`2& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Dictionary`2& finalPropertiesTable);
}
internal class Microsoft.Build.Tasks.RawFilenameResolver : Resolver {
    public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
public class Microsoft.Build.Tasks.ReadLinesFromFile : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Lines>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    [OutputAttribute]
public ITaskItem[] Lines { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader : MulticastDelegate {
    public ReadMachineTypeFromPEHeader(object object, IntPtr method);
    public virtual ushort Invoke(string dllPath);
    public virtual IAsyncResult BeginInvoke(string dllPath, AsyncCallback callback, object object);
    public virtual ushort EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.RedistList : object {
    private static Dictionary`2<string, RedistList> s_cachedRedistList;
    private static Dictionary`2<string, String[]> s_redistListPathCache;
    private static object s_locker;
    private ConcurrentDictionary`2<AssemblyNameExtension, NGen`1<bool>> _assemblyNameInRedist;
    private ConcurrentDictionary`2<string, AssemblyEntry> _assemblyNameToUnifiedAssemblyName;
    private ConcurrentDictionary`2<string, AssemblyNameExtension> _assemblyNameToAssemblyNameExtension;
    private ConcurrentDictionary`2<AssemblyNameExtension, AssemblyNameExtension> _remappingCache;
    private ConcurrentDictionary`2<string, Hashtable> _cachedBlackList;
    private ReadOnlyCollection`1<Exception> _errors;
    private ReadOnlyCollection`1<string> _errorFilenames;
    private ReadOnlyCollection`1<AssemblyEntry> _assemblyList;
    private ReadOnlyDictionary`2<string, int> _simpleNameMap;
    private ReadOnlyCollection`1<AssemblyRemapping> _remapEntries;
    private static string MatchPattern;
    internal static string RedistListFolder;
    private static IComparer`1<AssemblyEntry> s_sortByVersionDescending;
    internal Exception[] Errors { get; }
    internal String[] ErrorFileNames { get; }
    internal int Count { get; }
    private RedistList(AssemblyTableInfo[] assemblyTableInfos);
    private static RedistList();
    internal Exception[] get_Errors();
    internal String[] get_ErrorFileNames();
    internal int get_Count();
    public bool IsFrameworkAssembly(string assemblyName);
    public bool IsPrerequisiteAssembly(string assemblyName);
    public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap);
    internal Nullable`1<bool> IsRedistRoot(string assemblyName);
    public static RedistList GetFrameworkList20();
    public static RedistList GetFrameworkList30();
    public static RedistList GetFrameworkList35();
    public static RedistList GetRedistListFromPath(string path);
    private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotNetFrameworkVersion version);
    public static String[] GetRedistListPathsFromDisk(string frameworkDirectory);
    internal string RedistName(string assemblyName);
    public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables);
    private static string GetSimpleName(string assemblyName);
    private AssemblyEntry GetUnifiedAssemblyEntry(string assemblyName);
    private AssemblyNameExtension GetAssemblyNameExtension(string assemblyName);
    public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    public string GetUnifiedAssemblyName(string assemblyName);
    [IteratorStateMachineAttribute("Microsoft.Build.Tasks.RedistList/<FindAssemblyNameFromSimpleName>d__39")]
internal IEnumerable`1<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName);
    internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List`1<Exception> whiteListErrors, List`1<string> whiteListErrorFileNames);
    internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List`1<AssemblyEntry> assembliesList, List`1<Exception> errorsList, List`1<string> errorFilenamesList, List`1<AssemblyRemapping> remapEntries);
    private static void ParseRemapSection(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, List`1<AssemblyRemapping> mapping);
    private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, Dictionary`2<string, AssemblyEntry> assemblyEntries, List`1<AssemblyRemapping> remapEntries);
    private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, bool fullFusionNameRequired);
}
internal class Microsoft.Build.Tasks.Reference : object {
    private Dictionary`2<string, ITaskItem> _sourceItems;
    private HashSet`1<Reference> _dependees;
    private HashSet`1<Reference> _dependencies;
    private String[] _scatterFiles;
    private List`1<Exception> _errors;
    private List`1<string> _relatedFileExtensions;
    private List`1<string> _satelliteFiles;
    private List`1<string> _serializationAssemblyFiles;
    private List`1<AssemblyNameExtension> _conflictVictims;
    private Dictionary`2<string, UnificationVersion> _preUnificationVersions;
    private ITaskItem _primarySourceItem;
    private string _fullPath;
    private string _directoryName;
    private string _fileNameWithoutExtension;
    private string _fullPathWithoutExtension;
    private List`1<string> _expectedExtensions;
    private bool _isManagedWinMDFile;
    private string _imageRuntimeVersion;
    private HashSet`1<AssemblyRemapping> _remappedAssemblyNames;
    private IsWinMDFile _isWinMDFile;
    private FileExists _fileExists;
    private GetAssemblyRuntimeVersion _getRuntimeVersion;
    [CompilerGeneratedAttribute]
private bool <WantSpecificVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmbedInteropTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserRequestedSpecificFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ReferenceVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FoundInGac>k__BackingField;
    [CompilerGeneratedAttribute]
private ExclusionListProperties <ExclusionListLoggingProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HintPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFolderKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrerequisite>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBadImage>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <ConflictVictorName>k__BackingField;
    [CompilerGeneratedAttribute]
private ConflictLossReason <ConflictLossExplanation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWinMDFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImplementationAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyLocalState <CopyLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DependenciesFound>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SDKName>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayList <AssembliesConsideredAndRejected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedSearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkName <FrameworkNameAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExternallyResolved>k__BackingField;
    internal bool WantSpecificVersion { get; private set; }
    internal bool EmbedInteropTypes { get; internal set; }
    internal bool UserRequestedSpecificFile { get; internal set; }
    internal Version ReferenceVersion { get; internal set; }
    internal Nullable`1<bool> FoundInGac { get; private set; }
    internal bool ResolvedFromGac { get; }
    internal ExclusionListProperties ExclusionListLoggingProperties { get; }
    internal string FullPath { get; internal set; }
    internal string DirectoryName { get; }
    internal string FileNameWithoutExtension { get; }
    internal string FullPathWithoutExtension { get; }
    internal string HintPath { get; internal set; }
    internal string AssemblyFolderKey { get; internal set; }
    internal bool IsPrimary { get; private set; }
    internal bool IsPrerequisite { get; internal set; }
    internal Nullable`1<bool> IsRedistRoot { get; internal set; }
    internal string RedistName { get; internal set; }
    internal ITaskItem PrimarySourceItem { get; }
    internal bool IsBadImage { get; private set; }
    internal bool IsConflictVictim { get; }
    internal AssemblyNameExtension ConflictVictorName { get; internal set; }
    internal ConflictLossReason ConflictLossExplanation { get; internal set; }
    internal bool IsWinMDFile { get; internal set; }
    internal bool IsManagedWinMDFile { get; internal set; }
    public string ImplementationAssembly { get; public set; }
    internal string ImageRuntime { get; internal set; }
    internal bool IsUnified { get; }
    internal CopyLocalState CopyLocal { get; private set; }
    internal bool IsCopyLocal { get; }
    internal bool IsResolved { get; }
    internal bool IsUnresolvable { get; }
    internal bool DependenciesFound { get; internal set; }
    internal string SDKName { get; private set; }
    internal ArrayList AssembliesConsideredAndRejected { get; private set; }
    internal string ResolvedSearchPath { get; internal set; }
    internal FrameworkName FrameworkNameAttribute { get; internal set; }
    internal bool ExternallyResolved { get; private set; }
    internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion);
    internal void AddSourceItem(ITaskItem sourceItem);
    internal void AddSourceItems(IEnumerable sourceItemsToAdd);
    internal void PropagateSourceItems(ITaskItem sourceItem);
    internal ICollection GetSourceItems();
    internal void AddDependency(Reference dependency);
    internal void AddDependee(Reference dependee);
    internal void RemoveDependee(Reference dependeeToRemove);
    internal void RemoveDependency(Reference dependencyToRemove);
    internal ICollection GetDependees();
    internal void AttachScatterFiles(String[] scatterFilesToAttach);
    internal String[] GetScatterFiles();
    internal void SetExecutableExtension(string extension);
    internal String[] GetExecutableExtensions(String[] allowedAssemblyExtensions);
    [CompilerGeneratedAttribute]
internal bool get_WantSpecificVersion();
    [CompilerGeneratedAttribute]
private void set_WantSpecificVersion(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EmbedInteropTypes();
    [CompilerGeneratedAttribute]
internal void set_EmbedInteropTypes(bool value);
    [CompilerGeneratedAttribute]
internal bool get_UserRequestedSpecificFile();
    [CompilerGeneratedAttribute]
internal void set_UserRequestedSpecificFile(bool value);
    [CompilerGeneratedAttribute]
internal Version get_ReferenceVersion();
    [CompilerGeneratedAttribute]
internal void set_ReferenceVersion(Version value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_FoundInGac();
    [CompilerGeneratedAttribute]
private void set_FoundInGac(Nullable`1<bool> value);
    internal bool get_ResolvedFromGac();
    [CompilerGeneratedAttribute]
internal ExclusionListProperties get_ExclusionListLoggingProperties();
    internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHasMetadata);
    internal void AddError(Exception e);
    internal ICollection GetErrors();
    internal void AddRelatedFileExtension(string filenameExtension);
    internal ICollection GetRelatedFileExtensions();
    internal void AddSatelliteFile(string filename);
    internal void AddSerializationAssemblyFile(string filename);
    internal ICollection GetSatelliteFiles();
    internal ICollection GetSerializationAssemblyFiles();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal string get_DirectoryName();
    internal string get_FileNameWithoutExtension();
    internal string get_FullPathWithoutExtension();
    [CompilerGeneratedAttribute]
internal string get_HintPath();
    [CompilerGeneratedAttribute]
internal void set_HintPath(string value);
    [CompilerGeneratedAttribute]
internal string get_AssemblyFolderKey();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolderKey(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void set_IsPrimary(bool value);
    [CompilerGeneratedAttribute]
internal void set_IsPrerequisite(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrerequisite();
    [CompilerGeneratedAttribute]
internal void set_IsRedistRoot(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
internal void set_RedistName(string value);
    [CompilerGeneratedAttribute]
internal string get_RedistName();
    internal ITaskItem get_PrimarySourceItem();
    [CompilerGeneratedAttribute]
internal bool get_IsBadImage();
    [CompilerGeneratedAttribute]
private void set_IsBadImage(bool value);
    internal bool get_IsConflictVictim();
    internal void AddConflictVictim(AssemblyNameExtension victim);
    internal List`1<AssemblyNameExtension> GetConflictVictims();
    [CompilerGeneratedAttribute]
internal AssemblyNameExtension get_ConflictVictorName();
    [CompilerGeneratedAttribute]
internal void set_ConflictVictorName(AssemblyNameExtension value);
    [CompilerGeneratedAttribute]
internal ConflictLossReason get_ConflictLossExplanation();
    [CompilerGeneratedAttribute]
internal void set_ConflictLossExplanation(ConflictLossReason value);
    [CompilerGeneratedAttribute]
internal bool get_IsWinMDFile();
    [CompilerGeneratedAttribute]
internal void set_IsWinMDFile(bool value);
    internal bool get_IsManagedWinMDFile();
    internal void set_IsManagedWinMDFile(bool value);
    [CompilerGeneratedAttribute]
public string get_ImplementationAssembly();
    [CompilerGeneratedAttribute]
public void set_ImplementationAssembly(string value);
    internal string get_ImageRuntime();
    internal void set_ImageRuntime(string value);
    internal List`1<UnificationVersion> GetPreUnificationVersions();
    internal HashSet`1<AssemblyRemapping> RemappedAssemblyNames();
    internal void AddPreUnificationVersion(string referencePath, Version version, UnificationReason reason);
    internal void AddRemapping(AssemblyNameExtension remappedFrom, AssemblyNameExtension remappedTo);
    internal bool get_IsUnified();
    [CompilerGeneratedAttribute]
internal CopyLocalState get_CopyLocal();
    [CompilerGeneratedAttribute]
private void set_CopyLocal(CopyLocalState value);
    internal bool get_IsCopyLocal();
    internal bool get_IsResolved();
    internal bool get_IsUnresolvable();
    [CompilerGeneratedAttribute]
internal bool get_DependenciesFound();
    [CompilerGeneratedAttribute]
internal void set_DependenciesFound(bool value);
    [CompilerGeneratedAttribute]
internal string get_SDKName();
    [CompilerGeneratedAttribute]
private void set_SDKName(string value);
    internal void AddAssembliesConsideredAndRejected(ArrayList assembliesConsideredAndRejectedToAdd);
    [CompilerGeneratedAttribute]
internal ArrayList get_AssembliesConsideredAndRejected();
    [CompilerGeneratedAttribute]
private void set_AssembliesConsideredAndRejected(ArrayList value);
    [CompilerGeneratedAttribute]
internal string get_ResolvedSearchPath();
    [CompilerGeneratedAttribute]
internal void set_ResolvedSearchPath(string value);
    [CompilerGeneratedAttribute]
internal FrameworkName get_FrameworkNameAttribute();
    [CompilerGeneratedAttribute]
internal void set_FrameworkNameAttribute(FrameworkName value);
    [CompilerGeneratedAttribute]
internal bool get_ExternallyResolved();
    [CompilerGeneratedAttribute]
private void set_ExternallyResolved(bool value);
    internal void MakeDependentAssemblyReference(Reference sourceReference);
    internal void MakePrimaryAssemblyReference(ITaskItem sourceItem, bool wantSpecificVersionValue, string executableExtension);
    internal static bool IsFrameworkFile(string fullPath, String[] frameworkPaths);
    internal void SetFinalCopyLocalState(AssemblyNameExtension assemblyName, String[] frameworkPaths, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, GetAssemblyPathInGac getAssemblyPathInGac, bool copyLocalDependenciesWhenParentReferenceInGac, bool doNotCopyLocalIfInGac, ReferenceTable referenceTable);
    public virtual string ToString();
}
internal class Microsoft.Build.Tasks.ReferenceResolutionException : Exception {
    internal ReferenceResolutionException(string message, Exception innerException);
    private ReferenceResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.ReferenceTable : object {
    private static Version s_targetFrameworkVersion_40;
    private static Dictionary`2<string, Tuple`2<RedistList, string>> s_monikerToHighestRedistList;
    private HashSet`1<string> _externallyResolvedPrimaryReferences;
    private IEnumerable`1<DependentAssembly> _remappedAssemblies;
    private bool _findDependencies;
    private bool _ignoreVersionForFrameworkReferences;
    private bool _findSatellites;
    private bool _findSerializationAssemblies;
    private bool _findRelatedFiles;
    private bool _checkAssemblyVersionAgainstTargetFrameworkVersion;
    private String[] _frameworkPaths;
    private String[] _allowedAssemblyExtensions;
    private String[] _relatedFileExtensions;
    private Dictionary`2<string, ITaskItem> _resolvedSDKReferences;
    private InstalledAssemblies _installedAssemblies;
    private ProcessorArchitecture _targetProcessorArchitecture;
    private FileExists _fileExists;
    private DirectoryExists _directoryExists;
    private GetDirectories _getDirectories;
    private GetAssemblyName _getAssemblyName;
    private GetAssemblyMetadata _getAssemblyMetadata;
    private GetAssemblyRuntimeVersion _getRuntimeVersion;
    private Version _targetedRuntimeVersion;
    private ReadMachineTypeFromPEHeader _readMachineTypeFromPEHeader;
    private IsWinMDFile _isWinMDFile;
    private Version _projectTargetFramework;
    private FrameworkName _targetFrameworkMoniker;
    private TaskLoggingHelper _log;
    private String[] _latestTargetFrameworkDirectories;
    private bool _copyLocalDependenciesWhenParentReferenceInGac;
    private bool _doNotCopyLocalIfInGac;
    private bool _ignoreFrameworkAttributeVersionMismatch;
    private GetAssemblyPathInGac _getAssemblyPathInGac;
    private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch;
    private ConcurrentDictionary`2<string, AssemblyMetadata> _assemblyMetadataCache;
    private static int PEOFFSET;
    private static int PEHEADER;
    [CompilerGeneratedAttribute]
private Resolver[] <Resolvers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AssemblyNameExtension, Reference> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ListOfExcludedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkippedFindingExternallyResolvedDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindDependenciesOfExternallyResolvedReferences>k__BackingField;
    internal Resolver[] Resolvers { get; }
    internal Dictionary`2<AssemblyNameExtension, Reference> References { get; private set; }
    internal List`1<string> ListOfExcludedAssemblies { get; private set; }
    internal bool SkippedFindingExternallyResolvedDependencies { get; private set; }
    internal bool FindDependenciesOfExternallyResolvedReferences { get; internal set; }
    internal ReferenceTable(IBuildEngine buildEngine, bool findDependencies, bool findSatellites, bool findSerializationAssemblies, bool findRelatedFiles, String[] searchPaths, String[] allowedAssemblyExtensions, String[] relatedFileExtensions, String[] candidateAssemblyFiles, ITaskItem[] resolvedSDKItems, String[] frameworkPaths, InstalledAssemblies installedAssemblies, ProcessorArchitecture targetProcessorArchitecture, FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, Version projectTargetFramework, FrameworkName targetFrameworkMoniker, TaskLoggingHelper log, String[] latestTargetFrameworkDirectories, bool copyLocalDependenciesWhenParentReferenceInGac, bool doNotCopyLocalIfInGac, GetAssemblyPathInGac getAssemblyPathInGac, IsWinMDFile isWinMDFile, bool ignoreVersionForFrameworkReferences, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader, WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch, bool ignoreFrameworkAttributeVersionMismatch, bool unresolveFrameworkAssembliesFromHigherFrameworks, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache);
    private static ReferenceTable();
    [CompilerGeneratedAttribute]
internal Resolver[] get_Resolvers();
    [CompilerGeneratedAttribute]
internal Dictionary`2<AssemblyNameExtension, Reference> get_References();
    [CompilerGeneratedAttribute]
private void set_References(Dictionary`2<AssemblyNameExtension, Reference> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_ListOfExcludedAssemblies();
    [CompilerGeneratedAttribute]
private void set_ListOfExcludedAssemblies(List`1<string> value);
    [CompilerGeneratedAttribute]
internal bool get_SkippedFindingExternallyResolvedDependencies();
    [CompilerGeneratedAttribute]
private void set_SkippedFindingExternallyResolvedDependencies(bool value);
    [CompilerGeneratedAttribute]
internal bool get_FindDependenciesOfExternallyResolvedReferences();
    [CompilerGeneratedAttribute]
internal void set_FindDependenciesOfExternallyResolvedReferences(bool value);
    internal void AddReference(AssemblyNameExtension assemblyName, Reference reference);
    internal Reference GetReference(AssemblyNameExtension assemblyName);
    private AssemblyNameExtension NameAssemblyFileReference(Reference reference, string assemblyFileName);
    private void SetPrimaryItems(ITaskItem[] referenceAssemblyFiles, ITaskItem[] referenceAssemblyNames, ArrayList exceptions);
    private Exception SetPrimaryAssemblyReferenceItem(ITaskItem referenceAssemblyName);
    private static void TryConvertToAssemblyName(string itemSpec, string fusionName, AssemblyNameExtension& assemblyName);
    private static void TryGatherAssemblyNameEssentials(string fusionName, AssemblyNameExtension& assemblyName);
    private static void TryGetAssemblyNameComponent(string fusionName, string component, String& value);
    private void SetPrimaryFileItem(ITaskItem referenceAssemblyFile);
    private void FindRelatedFiles(Reference reference);
    private void FindSatellites(Reference reference);
    private void FindSerializationAssemblies(Reference reference);
    private void GetUnifiedAssemblyMetadata(Reference reference, IEnumerable`1& unifiedDependencies, String[]& scatterFiles);
    [IteratorStateMachineAttribute("Microsoft.Build.Tasks.ReferenceTable/<GetUnifiedAssemblyNames>d__71")]
private IEnumerable`1<UnifiedAssemblyName> GetUnifiedAssemblyNames(IEnumerable`1<AssemblyNameExtension> preUnificationAssemblyNames);
    private void FindDependenciesAndScatterFiles(Reference reference, List`1<KeyValuePair`2<AssemblyNameExtension, Reference>> newEntries);
    private static bool IsPseudoAssembly(string name);
    internal static void CalculateParentAssemblyDirectories(List`1<string> parentReferenceFolders, Reference parentReference);
    private void ResolveReference(AssemblyNameExtension assemblyName, string rawFileNameCandidate, Reference reference);
    internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, string subsetName);
    private static void AddToDependencyGraph(Dictionary`2<Reference, List`1<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference);
    private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary`2<AssemblyNameExtension, Reference> goodReferences, List`1<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference);
    private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, List`1<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference);
    internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec);
    private static void RemoveDependencies(Reference removedReference, Dictionary`2<AssemblyNameExtension, Reference> referenceList, Dictionary`2<Reference, List`1<ReferenceAssemblyExtensionPair>> dependencyList);
    internal void ComputeClosure(IEnumerable`1<DependentAssembly> remappedAssembliesValue, ITaskItem[] referenceAssemblyFiles, ITaskItem[] referenceAssemblyNames, ArrayList exceptions);
    private void ComputeClosure();
    private bool FindAssociatedFiles();
    private void ResolveAssemblyFilenames();
    private int ResolveConflictsBetweenReferences();
    internal void ResolveConflicts(List`1& idealRemappings, List`1& conflictingReferences);
    internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension assemblyName, Reference reference);
    private bool InLatestRedistList(AssemblyNameExtension assemblyName);
    private Tuple`2<RedistList, string> GetHighestVersionFullFrameworkForTFM(FrameworkName targetFrameworkMoniker);
    private static IList`1<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkName targetFrameworkMoniker, FrameworkName& highestVersionMoniker);
    internal void MarkReferenceWithHighestVersionInCurrentRedistList(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(AssemblyNameExtension assemblyName, Reference reference);
    private Dictionary`2<string, List`1<AssemblyNameReference>> BuildSimpleNameTable();
    private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyReference0, AssemblyNameReference assemblyReference1);
    private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension assemblyName, string fullPath, String[] frameworkPaths, InstalledAssemblies installedAssemblies);
    private bool UnifyAssemblyNameVersions(AssemblyNameExtension assemblyName, Version& unifiedVersion, UnificationReason& unificationReason, Boolean& isPrerequisite, Nullable`1& isRedistRoot, String& redistName);
    private bool CompareAssembliesIgnoringVersion(AssemblyName a, AssemblyName b);
    internal void GetReferenceItems(ITaskItem[]& primaryFiles, ITaskItem[]& dependencyFiles, ITaskItem[]& relatedFiles, ITaskItem[]& satelliteFiles, ITaskItem[]& serializationAssemblyFiles, ITaskItem[]& scatterFiles, ITaskItem[]& copyLocalFiles);
    private ITaskItem SetItemMetadata(List`1<ITaskItem> relatedItems, List`1<ITaskItem> satelliteItems, List`1<ITaskItem> serializationAssemblyItems, List`1<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName);
    private bool VerifyArchitectureOfImplementationDll(string dllPath, string winmdFile);
    internal static ushort ReadMachineTypeFromPEHeader(string dllPath);
    private static void RemoveNonForwardableMetadata(ITaskItem item);
    private static void FindCopyLocalItems(ITaskItem[] items, List`1<ITaskItem> copyLocalItems);
    internal void LogHigherVersionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogHigherVersionUnresolveDueToAttribute(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogAnotherFrameworkUnResolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogProfileExclusionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal bool MarkReferencesForExclusion(Hashtable exclusionList);
}
public class Microsoft.Build.Tasks.RemoveDir : TaskExtension {
    private ITaskItem[] _directories;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RemovedDirectories>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] RemovedDirectories { get; public set; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RemovedDirectories();
    [CompilerGeneratedAttribute]
public void set_RemovedDirectories(ITaskItem[] value);
    public virtual bool Execute();
    private bool RemoveDirectory(ITaskItem directory, bool logUnauthorizedError, Boolean& unauthorizedAccess);
    private bool RemoveReadOnlyAttributeRecursively(DirectoryInfo directory);
}
public class Microsoft.Build.Tasks.RemoveDuplicates : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Filtered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadAnyDuplicates>k__BackingField;
    public ITaskItem[] Inputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] Filtered { get; public set; }
    [OutputAttribute]
public bool HadAnyDuplicates { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Filtered();
    [CompilerGeneratedAttribute]
public void set_Filtered(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_HadAnyDuplicates();
    [CompilerGeneratedAttribute]
public void set_HadAnyDuplicates(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ResolutionSearchLocation : object {
    [CompilerGeneratedAttribute]
private string <FileNameAttempted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private NoMatchReason <Reason>k__BackingField;
    internal string FileNameAttempted { get; internal set; }
    internal string SearchPath { get; internal set; }
    internal AssemblyNameExtension AssemblyName { get; internal set; }
    internal NoMatchReason Reason { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_FileNameAttempted();
    [CompilerGeneratedAttribute]
internal void set_FileNameAttempted(string value);
    [CompilerGeneratedAttribute]
internal string get_SearchPath();
    [CompilerGeneratedAttribute]
internal void set_SearchPath(string value);
    [CompilerGeneratedAttribute]
internal AssemblyNameExtension get_AssemblyName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyName(AssemblyNameExtension value);
    [CompilerGeneratedAttribute]
internal NoMatchReason get_Reason();
    [CompilerGeneratedAttribute]
internal void set_Reason(NoMatchReason value);
}
public class Microsoft.Build.Tasks.ResolveAssemblyReference : TaskExtension {
    private static string SystemRuntimeAssemblyName;
    private static string NETStandardAssemblyName;
    private SystemState _cache;
    private ITaskItem[] _assemblyFiles;
    private ITaskItem[] _assemblyNames;
    private ITaskItem[] _installedAssemblyTables;
    private ITaskItem[] _installedAssemblySubsetTables;
    private ITaskItem[] _fullFrameworkAssemblyTables;
    private ITaskItem[] _resolvedSDKReferences;
    private bool _ignoreDefaultInstalledAssemblyTables;
    private bool _ignoreDefaultInstalledAssemblySubsetTables;
    private String[] _candidateAssemblyFiles;
    private String[] _targetFrameworkDirectories;
    private String[] _searchPaths;
    private String[] _allowedAssemblyExtensions;
    private String[] _relatedFileExtensions;
    private string _appConfigFile;
    private bool _supportsBindingRedirectGeneration;
    private bool _autoUnify;
    private bool _ignoreVersionForFrameworkReferences;
    private bool _ignoreTargetFrameworkAttributeVersionMismatch;
    private ITaskItem[] _resolvedFiles;
    private ITaskItem[] _resolvedDependencyFiles;
    private ITaskItem[] _relatedFiles;
    private ITaskItem[] _satelliteFiles;
    private ITaskItem[] _serializationAssemblyFiles;
    private ITaskItem[] _scatterFiles;
    private ITaskItem[] _copyLocalFiles;
    private ITaskItem[] _suggestedRedirects;
    private String[] _targetFrameworkSubsets;
    private String[] _fullTargetFrameworkSubsetNames;
    private string _targetedFrameworkMoniker;
    private bool _findDependencies;
    private bool _findSatellites;
    private bool _findSerializationAssemblies;
    private bool _findRelatedFiles;
    private bool _silent;
    private string _projectTargetFrameworkAsString;
    private string _targetedRuntimeVersionRawValue;
    private Version _projectTargetFramework;
    private string _stateFile;
    private string _targetProcessorArchitecture;
    private string _profileName;
    private String[] _fullFrameworkFolders;
    private String[] _latestTargetFrameworkDirectories;
    private bool _copyLocalDependenciesWhenParentReferenceInGac;
    private Dictionary`2<string, MessageImportance> _showAssemblyFoldersExLocations;
    private bool _logVerboseSearchResults;
    private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch;
    private bool _unresolveFrameworkAssembliesFromHigherFrameworks;
    [CompilerGeneratedAttribute]
private bool <FindDependenciesOfExternallyResolvedReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotCopyLocalIfInGac>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMonikerDisplayName>k__BackingField;
    private ArrayList _filesWritten;
    [CompilerGeneratedAttribute]
private string <DependsOnSystemRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnNETStandard>k__BackingField;
    public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; public set; }
    public string WarnOrErrorOnTargetArchitectureMismatch { get; public set; }
    public ITaskItem[] AssemblyFiles { get; public set; }
    public String[] LatestTargetFrameworkDirectories { get; public set; }
    public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; public set; }
    public bool FindDependenciesOfExternallyResolvedReferences { get; public set; }
    public String[] TargetFrameworkSubsets { get; public set; }
    public ITaskItem[] Assemblies { get; public set; }
    public String[] CandidateAssemblyFiles { get; public set; }
    public ITaskItem[] ResolvedSDKReferences { get; public set; }
    public String[] TargetFrameworkDirectories { get; public set; }
    public ITaskItem[] InstalledAssemblyTables { get; public set; }
    public ITaskItem[] InstalledAssemblySubsetTables { get; public set; }
    public ITaskItem[] FullFrameworkAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblySubsetTables { get; public set; }
    public bool IgnoreVersionForFrameworkReferences { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public string TargetedRuntimeVersion { get; public set; }
    [RequiredAttribute]
public String[] SearchPaths { get; public set; }
    public String[] AllowedAssemblyExtensions { get; public set; }
    public String[] AllowedRelatedFileExtensions { get; public set; }
    public string AppConfigFile { get; public set; }
    public bool SupportsBindingRedirectGeneration { get; public set; }
    public bool AutoUnify { get; public set; }
    public bool CopyLocalDependenciesWhenParentReferenceInGac { get; public set; }
    public bool DoNotCopyLocalIfInGac { get; public set; }
    public string StateFile { get; public set; }
    public bool FindDependencies { get; public set; }
    public bool FindSatellites { get; public set; }
    public bool FindSerializationAssemblies { get; public set; }
    public bool FindRelatedFiles { get; public set; }
    public bool Silent { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetFrameworkMonikerDisplayName { get; public set; }
    public String[] FullTargetFrameworkSubsetNames { get; public set; }
    public string ProfileName { get; public set; }
    public String[] FullFrameworkFolders { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; }
    [OutputAttribute]
public ITaskItem[] ResolvedDependencyFiles { get; }
    [OutputAttribute]
public ITaskItem[] RelatedFiles { get; }
    [OutputAttribute]
public ITaskItem[] SatelliteFiles { get; }
    [OutputAttribute]
public ITaskItem[] SerializationAssemblyFiles { get; }
    [OutputAttribute]
public ITaskItem[] ScatterFiles { get; }
    [OutputAttribute]
public ITaskItem[] CopyLocalFiles { get; }
    [OutputAttribute]
public ITaskItem[] SuggestedRedirects { get; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; public set; }
    [OutputAttribute]
public string DependsOnSystemRuntime { get; private set; }
    [OutputAttribute]
public string DependsOnNETStandard { get; private set; }
    public bool get_UnresolveFrameworkAssembliesFromHigherFrameworks();
    public void set_UnresolveFrameworkAssembliesFromHigherFrameworks(bool value);
    public string get_WarnOrErrorOnTargetArchitectureMismatch();
    public void set_WarnOrErrorOnTargetArchitectureMismatch(string value);
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    public String[] get_LatestTargetFrameworkDirectories();
    public void set_LatestTargetFrameworkDirectories(String[] value);
    public bool get_IgnoreTargetFrameworkAttributeVersionMismatch();
    public void set_IgnoreTargetFrameworkAttributeVersionMismatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindDependenciesOfExternallyResolvedReferences();
    [CompilerGeneratedAttribute]
public void set_FindDependenciesOfExternallyResolvedReferences(bool value);
    public String[] get_TargetFrameworkSubsets();
    public void set_TargetFrameworkSubsets(String[] value);
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public String[] get_CandidateAssemblyFiles();
    public void set_CandidateAssemblyFiles(String[] value);
    public ITaskItem[] get_ResolvedSDKReferences();
    public void set_ResolvedSDKReferences(ITaskItem[] value);
    public String[] get_TargetFrameworkDirectories();
    public void set_TargetFrameworkDirectories(String[] value);
    public ITaskItem[] get_InstalledAssemblyTables();
    public void set_InstalledAssemblyTables(ITaskItem[] value);
    public ITaskItem[] get_InstalledAssemblySubsetTables();
    public void set_InstalledAssemblySubsetTables(ITaskItem[] value);
    public ITaskItem[] get_FullFrameworkAssemblyTables();
    public void set_FullFrameworkAssemblyTables(ITaskItem[] value);
    public bool get_IgnoreDefaultInstalledAssemblyTables();
    public void set_IgnoreDefaultInstalledAssemblyTables(bool value);
    public bool get_IgnoreDefaultInstalledAssemblySubsetTables();
    public void set_IgnoreDefaultInstalledAssemblySubsetTables(bool value);
    public bool get_IgnoreVersionForFrameworkReferences();
    public void set_IgnoreVersionForFrameworkReferences(bool value);
    public string get_TargetProcessorArchitecture();
    public void set_TargetProcessorArchitecture(string value);
    public string get_TargetedRuntimeVersion();
    public void set_TargetedRuntimeVersion(string value);
    public String[] get_SearchPaths();
    public void set_SearchPaths(String[] value);
    public String[] get_AllowedAssemblyExtensions();
    public void set_AllowedAssemblyExtensions(String[] value);
    public String[] get_AllowedRelatedFileExtensions();
    public void set_AllowedRelatedFileExtensions(String[] value);
    public string get_AppConfigFile();
    public void set_AppConfigFile(string value);
    public bool get_SupportsBindingRedirectGeneration();
    public void set_SupportsBindingRedirectGeneration(bool value);
    public bool get_AutoUnify();
    public void set_AutoUnify(bool value);
    public bool get_CopyLocalDependenciesWhenParentReferenceInGac();
    public void set_CopyLocalDependenciesWhenParentReferenceInGac(bool value);
    [CompilerGeneratedAttribute]
public bool get_DoNotCopyLocalIfInGac();
    [CompilerGeneratedAttribute]
public void set_DoNotCopyLocalIfInGac(bool value);
    public string get_StateFile();
    public void set_StateFile(string value);
    public bool get_FindDependencies();
    public void set_FindDependencies(bool value);
    public bool get_FindSatellites();
    public void set_FindSatellites(bool value);
    public bool get_FindSerializationAssemblies();
    public void set_FindSerializationAssemblies(bool value);
    public bool get_FindRelatedFiles();
    public void set_FindRelatedFiles(bool value);
    public bool get_Silent();
    public void set_Silent(bool value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    public String[] get_FullTargetFrameworkSubsetNames();
    public void set_FullTargetFrameworkSubsetNames(String[] value);
    public string get_ProfileName();
    public void set_ProfileName(string value);
    public String[] get_FullFrameworkFolders();
    public void set_FullFrameworkFolders(String[] value);
    public ITaskItem[] get_ResolvedFiles();
    public ITaskItem[] get_ResolvedDependencyFiles();
    public ITaskItem[] get_RelatedFiles();
    public ITaskItem[] get_SatelliteFiles();
    public ITaskItem[] get_SerializationAssemblyFiles();
    public ITaskItem[] get_ScatterFiles();
    public ITaskItem[] get_CopyLocalFiles();
    public ITaskItem[] get_SuggestedRedirects();
    public void set_FilesWritten(ITaskItem[] value);
    public ITaskItem[] get_FilesWritten();
    [CompilerGeneratedAttribute]
public string get_DependsOnSystemRuntime();
    [CompilerGeneratedAttribute]
private void set_DependsOnSystemRuntime(string value);
    [CompilerGeneratedAttribute]
public string get_DependsOnNETStandard();
    [CompilerGeneratedAttribute]
private void set_DependsOnNETStandard(string value);
    private bool LogResults(ReferenceTable dependencyTable, List`1<DependentAssembly> idealAssemblyRemappings, List`1<AssemblyNameReference> idealAssemblyRemappingsIdentities, ArrayList generalResolutionExceptions);
    internal static string ByteArrayToString(Byte[] a);
    private void LogReferenceDependenciesAndSourceItems(string fusionName, Reference conflictCandidate);
    private void LogDependeeReference(Reference dependeeReference);
    private void LogReference(Reference reference, string fusionName);
    private MessageImportance ChooseReferenceLoggingImportance(Reference reference);
    private void LogInputs();
    private void LogAttribute(ITaskItem item, string metadataName);
    private void LogPrimaryOrDependency(Reference reference, string fusionName, MessageImportance importance);
    private void LogReferenceErrors(Reference reference, MessageImportance importance);
    private void LogFullName(Reference reference, MessageImportance importance);
    private void LogAssembliesConsideredAndRejected(Reference reference, string fusionName, MessageImportance importance);
    private void LogDependees(Reference reference, MessageImportance importance);
    private void LogRelatedFiles(Reference reference, MessageImportance importance);
    private void LogSatellites(Reference reference, MessageImportance importance);
    private void LogScatterFiles(Reference reference, MessageImportance importance);
    private void LogCopyLocalState(Reference reference, MessageImportance importance);
    private void LogImageRuntime(Reference reference, MessageImportance importance);
    private void LogConflict(Reference reference, string fusionName);
    private void ReadStateFile();
    private void WriteStateFile();
    private List`1<DependentAssembly> GetAssemblyRemappingsFromAppConfig();
    internal bool Execute(FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetLastWriteTime getLastWriteTime, GetAssemblyRuntimeVersion getRuntimeVersion, GetAssemblyPathInGac getAssemblyPathInGac, IsWinMDFile isWinMDFile, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader);
    private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache);
    private static IReadOnlyCollection`1<DependentAssembly> CombineRemappedAssemblies(IReadOnlyCollection`1<DependentAssembly> first, IReadOnlyCollection`1<DependentAssembly> second);
    internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionRawValue);
    private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[]& fullRedistAssemblyTableInfo, Hashtable& blackList, RedistList& fullFrameworkRedistList);
    internal static string GenerateSubSetName(String[] frameworkSubSetNames, ITaskItem[] installedSubSetNames);
    private bool VerifyInputConditions();
    private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] whiteListSubsetTableInfo, ReferenceTable referenceTable);
    private bool ShouldUseSubsetBlackList();
    private void PopulateSuggestedRedirects(List`1<DependentAssembly> idealAssemblyRemappings, List`1<AssemblyNameReference> idealAssemblyRemappedReferences);
    private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAssemblyTables, ITaskItem[] assemblyTables, GetListPath GetAssemblyListPaths, String[] targetFrameworkDirectories);
    private Version FrameworkVersionFromString(string version);
    private bool IsAvailableForTargetFramework(string assemblyFXVersionAsString);
    private void FilterBySubtypeAndTargetFramework();
    internal static string ProcessorArchitectureToString(ProcessorArchitecture processorArchitecture);
    internal static ProcessorArchitecture TargetProcessorArchitectureToEnumeration(string targetedProcessorArchitecture);
    private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet : TaskExtension {
    [CompilerGeneratedAttribute]
private string <CodeAnalysisRuleSet>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CodeAnalysisRuleSetDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedCodeAnalysisRuleSet>k__BackingField;
    public string CodeAnalysisRuleSet { get; public set; }
    public String[] CodeAnalysisRuleSetDirectories { get; public set; }
    public string MSBuildProjectDirectory { get; public set; }
    [OutputAttribute]
public string ResolvedCodeAnalysisRuleSet { get; private set; }
    [CompilerGeneratedAttribute]
public string get_CodeAnalysisRuleSet();
    [CompilerGeneratedAttribute]
public void set_CodeAnalysisRuleSet(string value);
    [CompilerGeneratedAttribute]
public String[] get_CodeAnalysisRuleSetDirectories();
    [CompilerGeneratedAttribute]
public void set_CodeAnalysisRuleSetDirectories(String[] value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_MSBuildProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedCodeAnalysisRuleSet();
    [CompilerGeneratedAttribute]
private void set_ResolvedCodeAnalysisRuleSet(string value);
    public virtual bool Execute();
    private string GetResolvedRuleSetPath();
}
public class Microsoft.Build.Tasks.ResolveKeySource : TaskExtension {
    private static string pfxFileExtension;
    private static string pfxFileContainerPrefix;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateThumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressAutoClosePasswordPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowImportDialogDespitePreviousFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoClosePasswordPromptTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoClosePasswordPromptShow>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedThumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedKeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedKeyFile>k__BackingField;
    public string KeyFile { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public string CertificateFile { get; public set; }
    public bool SuppressAutoClosePasswordPrompt { get; public set; }
    public bool ShowImportDialogDespitePreviousFailures { get; public set; }
    public int AutoClosePasswordPromptTimeout { get; public set; }
    public int AutoClosePasswordPromptShow { get; public set; }
    [OutputAttribute]
public string ResolvedThumbprint { get; public set; }
    [OutputAttribute]
public string ResolvedKeyContainer { get; public set; }
    [OutputAttribute]
public string ResolvedKeyFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateThumbprint();
    [CompilerGeneratedAttribute]
public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFile();
    [CompilerGeneratedAttribute]
public void set_CertificateFile(string value);
    [CompilerGeneratedAttribute]
public bool get_SuppressAutoClosePasswordPrompt();
    [CompilerGeneratedAttribute]
public void set_SuppressAutoClosePasswordPrompt(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowImportDialogDespitePreviousFailures();
    [CompilerGeneratedAttribute]
public void set_ShowImportDialogDespitePreviousFailures(bool value);
    [CompilerGeneratedAttribute]
public int get_AutoClosePasswordPromptTimeout();
    [CompilerGeneratedAttribute]
public void set_AutoClosePasswordPromptTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_AutoClosePasswordPromptShow();
    [CompilerGeneratedAttribute]
public void set_AutoClosePasswordPromptShow(int value);
    [CompilerGeneratedAttribute]
public string get_ResolvedThumbprint();
    [CompilerGeneratedAttribute]
public void set_ResolvedThumbprint(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedKeyContainer();
    [CompilerGeneratedAttribute]
public void set_ResolvedKeyContainer(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedKeyFile();
    [CompilerGeneratedAttribute]
public void set_ResolvedKeyFile(string value);
    public virtual bool Execute();
    private static ulong HashFromBlob(Byte[] data);
    private bool ResolveAssemblyKey();
    private bool ResolveManifestKey();
}
public abstract class Microsoft.Build.Tasks.ResolveProjectBase : TaskExtension {
    private ITaskItem[] _projectReferences;
    private HashSet`1<string> _cachedProjectReferencesByAbsolutePath;
    private Dictionary`2<string, XmlElement> _cachedProjectElements;
    private Dictionary`2<string, XmlElement> _cachedProjectElementsByAbsolutePath;
    private Dictionary`2<string, string> _cachedProjectAbsolutePathsByGuid;
    private Dictionary`2<string, string> _cachedProjectGuidsByAbsolutePath;
    private Dictionary`2<string, List`1<string>> _cachedDependencyProjectGuidsByDependingProjectGuid;
    private static string attributeProject;
    private static string attributeAbsolutePath;
    [RequiredAttribute]
public ITaskItem[] ProjectReferences { get; public set; }
    public ITaskItem[] get_ProjectReferences();
    public void set_ProjectReferences(ITaskItem[] value);
    internal bool VerifyReferenceAttributes(ITaskItem reference, String& missingAttribute);
    internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsError);
    internal void CacheProjectElementsFromXml(string xmlString);
    protected string GetProjectItem(ITaskItem projectRef);
    protected XmlElement GetProjectElement(ITaskItem projectRef);
    protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath);
}
internal abstract class Microsoft.Build.Tasks.Resolver : object {
    protected string searchPathElement;
    protected GetAssemblyName getAssemblyName;
    protected FileExists fileExists;
    protected GetAssemblyRuntimeVersion getRuntimeVersion;
    protected Version targetedRuntimeVersion;
    protected ProcessorArchitecture targetProcessorArchitecture;
    protected bool compareProcessorArchitecture;
    public string SearchPath { get; }
    protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture);
    public abstract virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    public string get_SearchPath();
    protected bool ResolveAsFile(string fullPath, AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, ArrayList assembliesConsideredAndRejected);
    protected bool FileMatchesAssemblyName(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, string pathToCandidateAssembly, ResolutionSearchLocation searchLocation);
    protected string ResolveFromDirectory(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string directory, ArrayList assembliesConsideredAndRejected);
}
public class Microsoft.Build.Tasks.RoslynCodeTaskFactory : object {
    internal static IList`1<string> DefaultNamespaces;
    internal static IDictionary`2<string, IEnumerable`1<string>> DefaultReferences;
    internal static IDictionary`2<string, ISet`1<string>> ValidCodeLanguages;
    private static string ReferenceAssemblyDirectoryName;
    private static ConcurrentDictionary`2<RoslynCodeTaskFactoryTaskInfo, Assembly> CompiledAssemblyCache;
    private static Lazy`1<string> ThisAssemblyDirectoryLazy;
    private TaskLoggingHelper _log;
    private TaskPropertyInfo[] _parameters;
    private string _taskName;
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    private static RoslynCodeTaskFactory();
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual void CleanupTask(ITask task);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    internal static string GetSourceCode(RoslynCodeTaskFactoryTaskInfo taskInfo, ICollection`1<TaskPropertyInfo> parameters);
    internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, string taskBody, ICollection`1<TaskPropertyInfo> parameters, RoslynCodeTaskFactoryTaskInfo& taskInfo);
    internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, ITaskItem[]& items);
    private static CodeMemberProperty CreateProperty(CodeTypeDeclaration codeTypeDeclaration, string name, Type type, object defaultValue);
    private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTaskFactoryTaskInfo taskInfo, Assembly& assembly);
}
internal enum Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType : Enum {
    public int value__;
    public static RoslynCodeTaskFactoryCodeType Fragment;
    public static RoslynCodeTaskFactoryCodeType Method;
    public static RoslynCodeTaskFactoryCodeType Class;
}
internal abstract class Microsoft.Build.Tasks.RoslynCodeTaskFactoryCompilerBase : ToolTaskExtension {
    private static string DotnetCliPath;
    private Lazy`1<string> _executablePath;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoStandardLib>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseSharedCompilation>k__BackingField;
    public Nullable`1<bool> Deterministic { get; public set; }
    public Nullable`1<bool> NoConfig { get; public set; }
    public Nullable`1<bool> NoLogo { get; public set; }
    public Nullable`1<bool> NoStandardLib { get; public set; }
    public Nullable`1<bool> Optimize { get; public set; }
    public ITaskItem OutputAssembly { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] Sources { get; public set; }
    public string TargetType { get; public set; }
    public Nullable`1<bool> UseSharedCompilation { get; public set; }
    protected string ReferenceSwitch { get; }
    private static RoslynCodeTaskFactoryCompilerBase();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoConfig();
    [CompilerGeneratedAttribute]
public void set_NoConfig(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoLogo();
    [CompilerGeneratedAttribute]
public void set_NoLogo(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoStandardLib();
    [CompilerGeneratedAttribute]
public void set_NoStandardLib(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public void set_Optimize(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputAssembly();
    [CompilerGeneratedAttribute]
public void set_OutputAssembly(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseSharedCompilation();
    [CompilerGeneratedAttribute]
public void set_UseSharedCompilation(Nullable`1<bool> value);
    protected virtual string get_ReferenceSwitch();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    [CompilerGeneratedAttribute]
private string <.ctor>b__2_0();
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryCSharpCompiler : RoslynCodeTaskFactoryCompilerBase {
    protected string ToolName { get; }
    protected virtual string get_ToolName();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo : object {
    [CompilerGeneratedAttribute]
private string <CodeLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private RoslynCodeTaskFactoryCodeType <CodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCode>k__BackingField;
    public string CodeLanguage { get; public set; }
    public RoslynCodeTaskFactoryCodeType CodeType { get; public set; }
    public string Name { get; public set; }
    public ISet`1<string> Namespaces { get; }
    public ISet`1<string> References { get; }
    public string SourceCode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CodeLanguage();
    [CompilerGeneratedAttribute]
public void set_CodeLanguage(string value);
    [CompilerGeneratedAttribute]
public RoslynCodeTaskFactoryCodeType get_CodeType();
    [CompilerGeneratedAttribute]
public void set_CodeType(RoslynCodeTaskFactoryCodeType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_References();
    [CompilerGeneratedAttribute]
public string get_SourceCode();
    [CompilerGeneratedAttribute]
public void set_SourceCode(string value);
    public sealed virtual bool Equals(RoslynCodeTaskFactoryTaskInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryVisualBasicCompiler : RoslynCodeTaskFactoryCompilerBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OptionExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    public Nullable`1<bool> OptionExplicit { get; public set; }
    public string RootNamespace { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OptionExplicit();
    [CompilerGeneratedAttribute]
public void set_OptionExplicit(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    protected virtual string get_ToolName();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
internal class Microsoft.Build.Tasks.RuntimeSection : object {
    [CompilerGeneratedAttribute]
private List`1<DependentAssembly> <DependentAssemblies>k__BackingField;
    internal List`1<DependentAssembly> DependentAssemblies { get; }
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal List`1<DependentAssembly> get_DependentAssemblies();
}
internal class Microsoft.Build.Tasks.SetAttributes : MulticastDelegate {
    public SetAttributes(object object, IntPtr method);
    public virtual void Invoke(string path, FileAttributes attributes);
    public virtual IAsyncResult BeginInvoke(string path, FileAttributes attributes, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastAccessTime : MulticastDelegate {
    public SetLastAccessTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastWriteTime : MulticastDelegate {
    public SetLastWriteTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.STARTUPINFO : ValueType {
    internal int cb;
    internal string lpReserved;
    internal string lpDesktop;
    internal string lpTitle;
    internal int dwX;
    internal int dwY;
    internal int dwXSize;
    internal int dwYSize;
    internal int dwXCountChars;
    internal int dwYCountChars;
    internal int dwFillAttribute;
    internal int dwFlags;
    internal short wShowWindow;
    internal short cbReserved2;
    internal IntPtr lpReserved2;
    internal IntPtr hStdInput;
    internal IntPtr hStdOutput;
    internal IntPtr hStdError;
}
internal class Microsoft.Build.Tasks.StateFileBase : object {
    private static byte CurrentSerializationVersion;
    private byte _serializedVersion;
    internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log);
    internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType);
    internal static void DeleteFile(string stateFile, TaskLoggingHelper log);
}
internal class Microsoft.Build.Tasks.SubsetListFinder : object {
    private static Dictionary`2<string, String[]> s_subsetListPathCache;
    private static object s_subsetListPathCacheLock;
    private static string subsetListFolder;
    private String[] _subsetToSearchFor;
    public static string SubsetListFolder { get; }
    internal SubsetListFinder(String[] subsetToSearchFor);
    private static SubsetListFinder();
    public static string get_SubsetListFolder();
    public String[] GetSubsetListPathsFromDisk(string frameworkDirectory);
}
internal enum Microsoft.Build.Tasks.SymbolicLink : Enum {
    public int value__;
    public static SymbolicLink File;
    public static SymbolicLink Directory;
}
internal class Microsoft.Build.Tasks.SystemState : StateFileBase {
    private Hashtable upToDateLocalFileStateCache;
    private Hashtable instanceLocalFileStateCache;
    private Hashtable instanceLocalFileExists;
    private Hashtable instanceLocalDirectoryExists;
    private Hashtable instanceLocalDirectories;
    private static ConcurrentDictionary`2<string, FileState> s_processWideFileStateCache;
    private RedistList redistList;
    private bool isDirty;
    private GetLastWriteTime getLastWriteTime;
    private GetAssemblyName getAssemblyName;
    private GetAssemblyMetadata getAssemblyMetadata;
    private FileExists fileExists;
    private DirectoryExists directoryExists;
    private GetDirectories getDirectories;
    private GetAssemblyRuntimeVersion getAssemblyRuntimeVersion;
    internal bool IsDirty { get; }
    internal SystemState(SerializationInfo info, StreamingContext context);
    private static SystemState();
    internal void SetInstalledAssemblyInformation(AssemblyTableInfo[] installedAssemblyTableInfos);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal bool get_IsDirty();
    internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue);
    internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue);
    internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetadataValue);
    internal FileExists CacheDelegate(FileExists fileExistsValue);
    public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue);
    internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue);
    internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAssemblyRuntimeVersion);
    private FileState GetFileState(string path);
    private FileState ComputeFileStateFromCachesAndDisk(string path);
    private FileState GetFileStateFromProcessWideCache(string path, FileState template);
    private FileState CreateFileState(DateTime lastModified, FileState template);
    private AssemblyNameExtension GetAssemblyName(string path);
    private string GetRuntimeVersion(string path);
    private void GetAssemblyMetadata(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkName);
    private String[] GetDirectories(string path, string pattern);
    private bool FileExists(string path);
    private bool DirectoryExists(string path);
}
public abstract class Microsoft.Build.Tasks.TaskExtension : Task {
    private TaskLoggingHelperExtension _logExtension;
    public TaskLoggingHelper Log { get; }
    public TaskLoggingHelper get_Log();
}
internal class Microsoft.Build.Tasks.TaskItemSpecFilenameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer`1<ITaskItem> GenericComparer;
    private static TaskItemSpecFilenameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual int Compare(ITaskItem x, ITaskItem y);
}
public class Microsoft.Build.Tasks.TaskLoggingHelperExtension : TaskLoggingHelper {
    private ResourceManager _taskSharedResources;
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
public class Microsoft.Build.Tasks.Telemetry : TaskExtension {
    [CompilerGeneratedAttribute]
private string <EventData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    public string EventData { get; public set; }
    [RequiredAttribute]
public string EventName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventData();
    [CompilerGeneratedAttribute]
public void set_EventData(string value);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    public virtual bool Execute();
}
public abstract class Microsoft.Build.Tasks.ToolTaskExtension : ToolTask {
    private TaskLoggingHelperExtension _logExtension;
    [CompilerGeneratedAttribute]
private Hashtable <Bag>k__BackingField;
    public TaskLoggingHelper Log { get; }
    protected bool HasLoggedErrors { get; }
    protected internal Hashtable Bag { get; }
    protected bool UseNewLineSeparatorInResponseFile { get; }
    public TaskLoggingHelper get_Log();
    protected virtual bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
protected internal Hashtable get_Bag();
    protected virtual bool get_UseNewLineSeparatorInResponseFile();
    protected internal bool GetBoolParameterWithDefault(string parameterName, bool defaultValue);
    protected internal int GetIntParameterWithDefault(string parameterName, int defaultValue);
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
public class Microsoft.Build.Tasks.Touch : TaskExtension {
    [CompilerGeneratedAttribute]
private bool <ForceTouch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TouchedFiles>k__BackingField;
    public bool ForceTouch { get; public set; }
    public bool AlwaysCreate { get; public set; }
    public string Time { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] TouchedFiles { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceTouch();
    [CompilerGeneratedAttribute]
public void set_ForceTouch(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysCreate();
    [CompilerGeneratedAttribute]
public void set_AlwaysCreate(bool value);
    [CompilerGeneratedAttribute]
public string get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_TouchedFiles();
    [CompilerGeneratedAttribute]
public void set_TouchedFiles(ITaskItem[] value);
    internal bool ExecuteImpl(FileExists fileExists, FileCreate fileCreate, GetAttributes fileGetAttributes, SetAttributes fileSetAttributes, SetLastAccessTime fileSetLastAccessTime, SetLastWriteTime fileSetLastWriteTime);
    public virtual bool Execute();
    private bool CreateFile(string file, FileCreate fileCreate);
    private bool TouchFile(string file, DateTime dt, FileExists fileExists, FileCreate fileCreate, GetAttributes fileGetAttributes, SetAttributes fileSetAttributes, SetLastAccessTime fileSetLastAccessTime, SetLastWriteTime fileSetLastWriteTime);
    private DateTime GetTouchDateTime();
}
internal enum Microsoft.Build.Tasks.UnificationReason : Enum {
    public int value__;
    public static UnificationReason DidntUnify;
    public static UnificationReason FrameworkRetarget;
    public static UnificationReason BecauseOfBindingRedirect;
}
internal class Microsoft.Build.Tasks.UnificationVersion : ValueType {
    internal string referenceFullPath;
    internal Version version;
    internal UnificationReason reason;
}
internal class Microsoft.Build.Tasks.UnifiedAssemblyName : object {
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <PreUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <PostUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private UnificationReason <UnificationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrerequisite>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    public AssemblyNameExtension PreUnified { get; }
    public AssemblyNameExtension PostUnified { get; }
    public bool IsUnified { get; }
    public UnificationReason UnificationReason { get; }
    public bool IsPrerequisite { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public UnifiedAssemblyName(AssemblyNameExtension preUnified, AssemblyNameExtension postUnified, bool isUnified, UnificationReason unificationReason, bool isPrerequisite, Nullable`1<bool> isRedistRoot, string redistName);
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_PreUnified();
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_PostUnified();
    [CompilerGeneratedAttribute]
public bool get_IsUnified();
    [CompilerGeneratedAttribute]
public UnificationReason get_UnificationReason();
    [CompilerGeneratedAttribute]
public bool get_IsPrerequisite();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
public string get_RedistName();
}
public class Microsoft.Build.Tasks.Unzip : TaskExtension {
    private static int _DefaultCopyBufferSize;
    private CancellationTokenSource _cancellationToken;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem DestinationFolder { get; public set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory);
    private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo);
    [CompilerGeneratedAttribute]
private bool <Execute>b__19_0(ITaskItem i);
    [CompilerGeneratedAttribute]
private bool <Extract>b__20_0(ZipArchiveEntry i);
}
public class Microsoft.Build.Tasks.VerifyFileHash : TaskExtension {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [RequiredAttribute]
public string File { get; public set; }
    [RequiredAttribute]
public string Hash { get; public set; }
    public string HashEncoding { get; public set; }
    public string Algorithm { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public string get_HashEncoding();
    [CompilerGeneratedAttribute]
public void set_HashEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    public virtual bool Execute();
}
internal static class Microsoft.Build.Tasks.VisualBasicParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
    private static ExtractedClassName Extract(VisualBasicTokenizer tokens);
}
public class Microsoft.Build.Tasks.Warning : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
internal enum Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior : Enum {
    public int value__;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Error;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Warning;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior None;
}
public class Microsoft.Build.Tasks.WriteCodeFragment : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssemblyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    private static int MaxLineLength;
    [RequiredAttribute]
public string Language { get; public set; }
    public ITaskItem[] AssemblyAttributes { get; public set; }
    public ITaskItem OutputDirectory { get; public set; }
    [OutputAttribute]
public ITaskItem OutputFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssemblyAttributes();
    [CompilerGeneratedAttribute]
public void set_AssemblyAttributes(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    public virtual bool Execute();
    private string GenerateCodeCoreClr(String& extension);
    private string GetAttributeArguments(ITaskItem attributeItem, string namedArgumentString, Func`2<string, string> quoteString);
    private static string QuoteSnippetStringCSharp(string value);
    private static string QuoteSnippetStringCStyle(string value);
    private static string QuoteSnippetStringVerbatimStyle(string value);
    private static string QuoteSnippetStringVisualBasic(string value);
    private static void EnsureNotInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b);
    private static void EnsureInDoubleQuotes(Boolean& fInDoubleQuotes, StringBuilder b);
}
public class Microsoft.Build.Tasks.WriteLinesToFile : TaskExtension {
    private static Encoding s_defaultEncoding;
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteOnlyWhenDifferent>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    public ITaskItem[] Lines { get; public set; }
    public bool Overwrite { get; public set; }
    public string Encoding { get; public set; }
    public bool WriteOnlyWhenDifferent { get; public set; }
    private static WriteLinesToFile();
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public string get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteOnlyWhenDifferent();
    [CompilerGeneratedAttribute]
public void set_WriteOnlyWhenDifferent(bool value);
    public virtual bool Execute();
}
[ObsoleteAttribute("The XamlTaskFactory is not supported on .NET Core.  This class is included so that users receive run-time errors and should not be used for any other purpose.", "True")]
public class Microsoft.Build.Tasks.XamlTaskFactory : object {
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; }
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
public class Microsoft.Build.Tasks.XmlPeek : TaskExtension {
    private string _query;
    [CompilerGeneratedAttribute]
private ITaskItem <XmlInputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlContent>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProhibitDtd>k__BackingField;
    public ITaskItem XmlInputPath { get; public set; }
    public string XmlContent { get; public set; }
    public string Query { get; public set; }
    [OutputAttribute]
public ITaskItem[] Result { get; private set; }
    public string Namespaces { get; public set; }
    public bool ProhibitDtd { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_XmlInputPath();
    [CompilerGeneratedAttribute]
public void set_XmlInputPath(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_XmlContent();
    [CompilerGeneratedAttribute]
public void set_XmlContent(string value);
    public string get_Query();
    public void set_Query(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(string value);
    [CompilerGeneratedAttribute]
public bool get_ProhibitDtd();
    [CompilerGeneratedAttribute]
public void set_ProhibitDtd(bool value);
    public virtual bool Execute();
    private static void LoadNamespaces(XmlNamespaceManager& namespaceManager, string namepaces);
}
public class Microsoft.Build.Tasks.XmlPoke : TaskExtension {
    private ITaskItem _xmlInputPath;
    private string _query;
    private ITaskItem _value;
    [CompilerGeneratedAttribute]
private string <Namespaces>k__BackingField;
    public ITaskItem XmlInputPath { get; public set; }
    public string Query { get; public set; }
    [RequiredAttribute]
public ITaskItem Value { get; public set; }
    public string Namespaces { get; public set; }
    public ITaskItem get_XmlInputPath();
    public void set_XmlInputPath(ITaskItem value);
    public string get_Query();
    public void set_Query(string value);
    public ITaskItem get_Value();
    public void set_Value(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(string value);
    public virtual bool Execute();
    private static void LoadNamespaces(XmlNamespaceManager& namespaceManager, string namepaces);
}
public class Microsoft.Build.Tasks.ZipDirectory : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <SourceDirectory>k__BackingField;
    [RequiredAttribute]
public ITaskItem DestinationFile { get; public set; }
    public bool Overwrite { get; public set; }
    [RequiredAttribute]
public ITaskItem SourceDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFile();
    [CompilerGeneratedAttribute]
public void set_DestinationFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_SourceDirectory();
    [CompilerGeneratedAttribute]
public void set_SourceDirectory(ITaskItem value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Utilities.EscapeHatches : object {
    public Nullable`1<bool> EvaluateElementsWithFalseConditionInProjectEvaluation;
    public bool AlwaysUseContentTimestamp;
    public bool LogProjectImports;
    public bool CacheAssemblyInformation;
    public Nullable`1<ProjectInstanceTranslationMode> ProjectInstanceTranslation;
    public bool UseSymlinkTimeInsteadOfTargetTime;
    public bool IgnoreEmptyImports;
    public bool IgnoreTreatAsLocalProperty;
    public bool DebugEvaluation;
    public bool WarnOnUninitializedProperty;
    public bool UseCaseSensitiveItemNames;
    public bool DisableSdkResolutionCache;
    public bool DisableNuGetSdkResolver;
    public bool UseAutoRunWhenLaunchingProcessUnderCmd;
    public bool EnsureStdOutForChildNodesIsPrimaryStdout;
    private static Nullable`1<bool> ParseNullableBoolFromEnvironmentVariable(string environmentVariable);
    private static Nullable`1<ProjectInstanceTranslationMode> ComputeProjectInstanceTranslation();
}
internal class Microsoft.Build.Utilities.Traits : object {
    private static Traits _instance;
    [CompilerGeneratedAttribute]
private EscapeHatches <EscapeHatches>k__BackingField;
    public bool UseLazyWildCardEvaluation;
    public bool LogExpandedWildcards;
    public bool CacheFileExistence;
    public bool UseSimpleInternConcurrency;
    public bool MSBuildCacheFileEnumerations;
    public bool EnableAllPropertyFunctions;
    public bool EnableRestoreFirst;
    public int CopyTaskParallelism;
    public bool EmitSolutionMetaproj;
    public static Traits Instance { get; }
    public EscapeHatches EscapeHatches { get; }
    private static Traits();
    public static Traits get_Instance();
    [CompilerGeneratedAttribute]
public EscapeHatches get_EscapeHatches();
    private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue);
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
