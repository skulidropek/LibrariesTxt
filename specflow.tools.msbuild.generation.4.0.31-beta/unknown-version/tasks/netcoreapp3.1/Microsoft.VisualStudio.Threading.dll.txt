[DebuggerDisplayAttribute("Signaled: {signaled}")]
public class Microsoft.VisualStudio.Threading.AsyncAutoResetEvent : object {
    private Queue`1<WaiterCompletionSource> signalAwaiters;
    private bool allowInliningAwaiters;
    private Action`1<object> onCancellationRequestHandler;
    private bool signaled;
    public AsyncAutoResetEvent(bool allowInliningAwaiters);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Set();
    private void OnCancellationRequest(object state);
}
public class Microsoft.VisualStudio.Threading.AsyncBarrier : object {
    private int participantCount;
    private Stack`1<TaskCompletionSource`1<EmptyStruct>> waiters;
    public AsyncBarrier(int participants);
    public Task SignalAndWait();
}
public class Microsoft.VisualStudio.Threading.AsyncCountdownEvent : object {
    private AsyncManualResetEvent manualEvent;
    private int remainingCount;
    public AsyncCountdownEvent(int initialCount);
    public Task WaitAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.AsyncCountdownEvent/<SignalAsync>d__4")]
[ObsoleteAttribute("Use Signal() instead.")]
[EditorBrowsableAttribute("1")]
public Task SignalAsync();
    public void Signal();
    public Task SignalAndWaitAsync();
}
public class Microsoft.VisualStudio.Threading.AsyncEventHandler : MulticastDelegate {
    public AsyncEventHandler(object object, IntPtr method);
    public virtual Task Invoke(object sender, EventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs args, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Threading.AsyncEventHandler`1 : MulticastDelegate {
    public AsyncEventHandler`1(object object, IntPtr method);
    public virtual Task Invoke(object sender, T args);
    public virtual IAsyncResult BeginInvoke(object sender, T args, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.Threading.AsyncLazy`1 : object {
    private static object RecursiveCheckSentinel;
    private object syncObject;
    private AsyncLocal`1<object> recursiveFactoryCheck;
    private Func`1<Task`1<T>> valueFactory;
    private JoinableTaskFactory jobFactory;
    private Task`1<T> value;
    private JoinableTask`1<T> joinableTask;
    public bool IsValueCreated { get; }
    public bool IsValueFactoryCompleted { get; }
    public AsyncLazy`1(Func`1<Task`1<T>> valueFactory, JoinableTaskFactory joinableTaskFactory);
    private static AsyncLazy`1();
    public bool get_IsValueCreated();
    public bool get_IsValueFactoryCompleted();
    public Task`1<T> GetValueAsync();
    public Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Threading.AsyncLocal`1 : object {
    private AsyncLocal`1<T> asyncLocal;
    public T Value { get; public set; }
    public T get_Value();
    public void set_Value(T value);
}
[DebuggerDisplayAttribute("Signaled: {IsSet}")]
public class Microsoft.VisualStudio.Threading.AsyncManualResetEvent : object {
    private bool allowInliningAwaiters;
    private object syncObject;
    private TaskCompletionSourceWithoutInlining`1<EmptyStruct> taskCompletionSource;
    private bool isSet;
    public bool IsSet { get; }
    public AsyncManualResetEvent(bool initialState, bool allowInliningAwaiters);
    public bool get_IsSet();
    public Task WaitAsync();
    [ObsoleteAttribute("Use Set() instead.")]
[EditorBrowsableAttribute("1")]
public Task SetAsync();
    public void Set();
    public void Reset();
    [ObsoleteAttribute("Use PulseAll() instead.")]
[EditorBrowsableAttribute("1")]
public Task PulseAllAsync();
    public void PulseAll();
    [EditorBrowsableAttribute("1")]
public TaskAwaiter GetAwaiter();
    private TaskCompletionSourceWithoutInlining`1<EmptyStruct> CreateTaskSource();
}
[DebuggerDisplayAttribute("Count = {Count}, Completed = {completeSignaled}")]
public class Microsoft.VisualStudio.Threading.AsyncQueue`1 : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) completedSource;
    private Queue`1<T> queueElements;
    private Queue`1<TaskCompletionSource`1<T>> dequeuingWaiters;
    private bool completeSignaled;
    private bool onCompletedInvoked;
    public bool IsEmpty { get; }
    public int Count { get; }
    public bool IsCompleted { get; }
    public Task Completion { get; }
    protected object SyncRoot { get; }
    protected int InitialCapacity { get; }
    public bool get_IsEmpty();
    public int get_Count();
    public bool get_IsCompleted();
    public Task get_Completion();
    protected object get_SyncRoot();
    protected virtual int get_InitialCapacity();
    public void Complete();
    public void Enqueue(T value);
    public bool TryEnqueue(T value);
    public bool TryPeek(T& value);
    public T Peek();
    public Task`1<T> DequeueAsync(CancellationToken cancellationToken);
    public bool TryDequeue(T& value);
    private sealed virtual override void Microsoft.VisualStudio.Threading.ThreadingTools.ICancellationNotification.OnCanceled();
    internal T[] ToArray();
    protected bool TryDequeue(Predicate`1<T> valueCheck, T& value);
    protected virtual void OnEnqueued(T value, bool alreadyDispatched);
    protected virtual void OnDequeued(T value);
    protected virtual void OnCompleted();
    private bool TryDequeueInternal(Predicate`1<T> valueCheck, T& value);
    private void CompleteIfNecessary();
    private void FreeCanceledDequeuers();
}
public class Microsoft.VisualStudio.Threading.AsyncReaderWriterLock : object {
    private static string DgmlNamespace;
    private object syncObject;
    private NonConcurrentSynchronizationContext nonConcurrentSyncContext;
    private AsyncLocal`1<Awaiter> topAwaiter;
    private HashSet`1<Awaiter> issuedReadLocks;
    private HashSet`1<Awaiter> issuedUpgradeableReadLocks;
    private HashSet`1<Awaiter> issuedWriteLocks;
    private Queue`1<Awaiter> waitingReaders;
    private Queue`1<Awaiter> waitingUpgradeableReaders;
    private Queue`1<Awaiter> waitingWriters;
    private TaskCompletionSource`1<object> completionSource;
    private Queue`1<Func`1<Task>> beforeWriteReleasedCallbacks;
    private bool captureDiagnostics;
    private Awaiter modreq(System.Runtime.CompilerServices.IsVolatile) reenterConcurrencyPrepRunning;
    private bool completeInvoked;
    private EventsHelper etw;
    protected internal SynchronizationContext NoMessagePumpSynchronizationContext { get; }
    public bool IsAnyLockHeld { get; }
    public bool IsAnyPassiveLockHeld { get; }
    public bool IsReadLockHeld { get; }
    public bool IsPassiveReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsPassiveUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public bool IsPassiveWriteLockHeld { get; }
    public Task Completion { get; }
    protected object SyncObject { get; }
    protected LockHandle AmbientLock { get; }
    protected bool CaptureDiagnostics { get; protected set; }
    protected bool CanCurrentThreadHoldActiveLock { get; }
    protected bool IsUnsupportedSynchronizationContext { get; }
    public AsyncReaderWriterLock(bool captureDiagnostics);
    protected internal virtual SynchronizationContext get_NoMessagePumpSynchronizationContext();
    private sealed virtual override HangReportContribution Microsoft.VisualStudio.Threading.IHangReportContributor.GetHangReport();
    protected virtual HangReportContribution GetHangReport();
    private static XDocument CreateDgml(XElement& nodes, XElement& links);
    private static XElement CreateAwaiterNode(Awaiter awaiter);
    private static string GetAwaiterId(Awaiter awaiter);
    private static string GetAwaiterGroupId(Awaiter awaiter);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.AsyncReaderWriterLock/<GetLockStack>d__10")]
private static IEnumerable`1<Awaiter> GetLockStack(Awaiter awaiter);
    public bool get_IsAnyLockHeld();
    public bool get_IsAnyPassiveLockHeld();
    public bool get_IsReadLockHeld();
    public bool get_IsPassiveReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsPassiveUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public bool get_IsPassiveWriteLockHeld();
    public Task get_Completion();
    protected object get_SyncObject();
    protected LockHandle get_AmbientLock();
    protected bool get_CaptureDiagnostics();
    protected void set_CaptureDiagnostics(bool value);
    protected virtual bool get_CanCurrentThreadHoldActiveLock();
    protected virtual bool get_IsUnsupportedSynchronizationContext();
    public Awaitable ReadLockAsync(CancellationToken cancellationToken);
    public Awaitable UpgradeableReadLockAsync(CancellationToken cancellationToken);
    public Awaitable UpgradeableReadLockAsync(LockFlags options, CancellationToken cancellationToken);
    public Awaitable WriteLockAsync(CancellationToken cancellationToken);
    public Awaitable WriteLockAsync(LockFlags options, CancellationToken cancellationToken);
    public Suppression HideLocks();
    public void Complete();
    public void OnBeforeWriteLockReleased(Func`1<Task> action);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected bool LockStackContains(LockFlags flags, LockHandle handle);
    protected LockFlags GetAggregateLockFlags();
    protected virtual Task OnBeforeLockReleasedAsync(bool exclusiveLockRelease, LockHandle releasingLock);
    protected virtual Task OnBeforeExclusiveLockReleasedAsync();
    protected virtual TaskScheduler GetTaskSchedulerForReadLockRequest();
    private void ThrowIfUnsupportedThreadOrSyncContext();
    private bool IsLockSupportingContext(Awaiter awaiter);
    private void CompleteIfAppropriate();
    private void AggregateLockStackKinds(Awaiter awaiter, Boolean& read, Boolean& upgradeableRead, Boolean& write);
    private bool AllHeldLocksAreByThisStack(Awaiter awaiter);
    private bool LockStackContains(LockKind kind, Awaiter awaiter);
    private bool IsStickyWriteUpgradedLock(Awaiter awaiter);
    private bool IsLockHeld(LockKind kind, Awaiter awaiter, bool checkSyncContextCompatibility, bool allowNonLockSupportingContext);
    private bool IsLockActive(Awaiter awaiter, bool considerStaActive, bool checkSyncContextCompatibility);
    private void CheckSynchronizationContextAppropriateForLock(Awaiter awaiter);
    private bool TryIssueLock(Awaiter awaiter, bool previouslyQueued);
    private Awaiter FindRootUpgradeableReadWithStickyWrite(Awaiter headAwaiter);
    private HashSet`1<Awaiter> GetActiveLockSet(LockKind kind);
    private Queue`1<Awaiter> GetLockQueue(LockKind kind);
    private Awaiter GetFirstActiveSelfOrAncestor(Awaiter awaiter);
    private void IssueAndExecute(Awaiter awaiter);
    protected virtual Task OnExclusiveLockReleasedAsync();
    protected virtual void OnUpgradeableReadLockReleased();
    protected virtual Exception OnCriticalFailure(Exception ex);
    protected Exception OnCriticalFailure(string message);
    private static bool HasAnyNestedLocks(Awaiter lck, HashSet`1<Awaiter> lockCollection);
    private Task ReleaseAsync(Awaiter awaiter, bool lockConsumerCanceled);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.AsyncReaderWriterLock/<DowngradeLockAsync>d__97")]
private Task DowngradeLockAsync(Awaiter awaiter, bool upgradedStickyWrite, bool fireUpgradeableReadLockReleased, Task beginAfterPrerequisite);
    private bool HasAnyNestedLocks(Awaiter lck);
    private void OnReleaseReenterConcurrencyComplete(Awaiter awaiter, bool upgradedStickyWrite, bool searchAllWaiters);
    private bool TryInvokeLockConsumer(bool searchAllWaiters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.AsyncReaderWriterLock/<InvokeBeforeWriteLockReleaseHandlersAsync>d__101")]
private Task InvokeBeforeWriteLockReleaseHandlersAsync();
    private bool TryDequeueBeforeWriteReleasedCallback(Func`1& callback);
    private void ApplyLockToCallContext(Awaiter topAwaiter);
    private bool TryInvokeAllReadersIfAppropriate(bool searchAllWaiters);
    private bool TryInvokeOneUpgradeableReaderIfAppropriate(bool searchAllWaiters);
    private bool TryInvokeOneWriterIfAppropriate(bool searchAllWaiters);
    private bool TryInvokeAnyWaitersInQueue(Queue`1<Awaiter> waiters, bool breakOnFirstIssue);
    private void PendAwaiter(Awaiter awaiter);
    private bool ExecuteOrHandleCancellation(Awaiter awaiter, bool stillInQueue);
    [CompilerGeneratedAttribute]
private void <CompleteIfAppropriate>b__77_0();
}
public abstract class Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2 : AsyncReaderWriterLock {
    private Helper<TMoniker, TResource> helper;
    protected AsyncReaderWriterResourceLock`2(bool captureDiagnostics);
    public ResourceAwaitable<TMoniker, TResource> ReadLockAsync(CancellationToken cancellationToken);
    public ResourceAwaitable<TMoniker, TResource> UpgradeableReadLockAsync(LockFlags<TMoniker, TResource> options, CancellationToken cancellationToken);
    public ResourceAwaitable<TMoniker, TResource> UpgradeableReadLockAsync(CancellationToken cancellationToken);
    public ResourceAwaitable<TMoniker, TResource> WriteLockAsync(CancellationToken cancellationToken);
    public ResourceAwaitable<TMoniker, TResource> WriteLockAsync(LockFlags<TMoniker, TResource> options, CancellationToken cancellationToken);
    protected abstract virtual Task`1<TResource> GetResourceAsync(TMoniker resourceMoniker, CancellationToken cancellationToken);
    protected void SetResourceAsAccessed(TResource resource);
    protected bool SetResourceAsAccessed(Func`3<TResource, object, bool> resourceCheck, object state);
    protected void SetAllResourcesToUnknownState();
    protected LockFlags<TMoniker, TResource> GetAggregateLockFlags();
    protected abstract virtual Task PrepareResourceForConcurrentAccessAsync(TResource resource, CancellationToken cancellationToken);
    protected abstract virtual Task PrepareResourceForExclusiveAccessAsync(TResource resource, LockFlags<TMoniker, TResource> lockFlags, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2/<OnExclusiveLockReleasedAsync>d__16")]
protected virtual Task OnExclusiveLockReleasedAsync();
    protected virtual void OnUpgradeableReadLockReleased();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public class Microsoft.VisualStudio.Threading.AsyncSemaphore : object {
    private SemaphoreSlim semaphore;
    private Task`1<Releaser> uncontestedReleaser;
    private Task`1<Releaser> canceledReleaser;
    public int CurrentCount { get; }
    public AsyncSemaphore(int initialCount);
    public int get_CurrentCount();
    public Task`1<Releaser> EnterAsync(CancellationToken cancellationToken);
    public Task`1<Releaser> EnterAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<Releaser> EnterAsync(int timeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private Task`1<Releaser> LockWaitingHelper(Task waitTask);
    private Task`1<Releaser> LockWaitingHelper(Task`1<bool> waitTask);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Threading.AwaitExtensions : object {
    [ExtensionAttribute]
public static TaskSchedulerAwaiter GetAwaiter(TaskScheduler scheduler);
    [ExtensionAttribute]
public static TaskSchedulerAwaitable SwitchTo(TaskScheduler scheduler, bool alwaysYield);
    [ExtensionAttribute]
public static TaskAwaiter GetAwaiter(WaitHandle handle);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.AwaitExtensions/<WaitForExitAsync>d__3")]
[ExtensionAttribute]
public static Task`1<int> WaitForExitAsync(Process process, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ConfiguredTaskYieldAwaitable ConfigureAwait(YieldAwaitable yieldAwaitable, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ExecuteContinuationSynchronouslyAwaitable ConfigureAwaitRunInline(Task antecedent);
    [ExtensionAttribute]
public static ExecuteContinuationSynchronouslyAwaitable`1<T> ConfigureAwaitRunInline(Task`1<T> antecedent);
}
public class Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory : JoinableTaskFactory {
    private JoinableTaskFactory innerFactory;
    protected DelegatingJoinableTaskFactory(JoinableTaskFactory innerFactory);
    protected internal virtual void WaitSynchronously(Task task);
    protected internal virtual void PostToUnderlyingSynchronizationContext(SendOrPostCallback callback, object state);
    protected internal virtual void OnTransitioningToMainThread(JoinableTask joinableTask);
    protected internal virtual void OnTransitionedToMainThread(JoinableTask joinableTask, bool canceled);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Threading.Dgml : object {
    internal static string Namespace;
    private static XName NodeName;
    private static XName NodesName;
    private static XName LinkName;
    private static XName LinksName;
    private static XName StylesName;
    private static XName StyleName;
    private static Dgml();
    internal static XDocument Create(XElement& nodes, XElement& links, string layout, string direction);
    [ExtensionAttribute]
private static XElement GetRootElement(XDocument document, XName name);
    private static XElement GetRootElement(XDocument document, string elementName);
    [ExtensionAttribute]
internal static XDocument WithCategories(XDocument document, String[] categories);
    [ExtensionAttribute]
internal static XDocument WithCategories(XDocument document, XElement[] categories);
    internal static XElement Node(string id, string label, string group);
    [ExtensionAttribute]
internal static XDocument WithNode(XDocument document, XElement node);
    internal static XElement Link(string source, string target);
    internal static XElement Link(XElement source, XElement target);
    [ExtensionAttribute]
internal static XDocument WithLink(XDocument document, XElement link);
    internal static XElement Category(string id, string label, string background, string foreground, string icon, bool isTag, bool isContainment);
    internal static XElement Comment(string label);
    internal static XElement Container(string id, string label);
    [ExtensionAttribute]
internal static XDocument WithContainers(XDocument document, IEnumerable`1<XElement> containers);
    [ExtensionAttribute]
internal static XElement ContainedBy(XElement node, XElement container);
    [ExtensionAttribute]
internal static XElement ContainedBy(XElement node, string containerId, XDocument document);
    [ExtensionAttribute]
internal static XElement WithCategories(XElement element, String[] categories);
    [ExtensionAttribute]
internal static XDocument WithStyle(XDocument document, string categoryId, IEnumerable`1<KeyValuePair`2<string, string>> properties, string targetType);
    [ExtensionAttribute]
internal static XDocument WithStyle(XDocument document, string categoryId, string targetType, string foreground, string background, string icon);
}
internal class Microsoft.VisualStudio.Threading.EmptyStruct : ValueType {
    internal static EmptyStruct Instance { get; }
    internal static EmptyStruct get_Instance();
}
internal class Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1 : ValueType {
    private T value;
    private Enumerator<T> enumerator;
    private bool justOne;
    private int position;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal EnumerateOneOrMany`1(T value);
    internal EnumerateOneOrMany`1(List`1<T> values);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class Microsoft.VisualStudio.Threading.HangReportContribution : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<HangReportContribution> <NestedReports>k__BackingField;
    public string Content { get; private set; }
    public string ContentType { get; private set; }
    public string ContentName { get; private set; }
    public IReadOnlyCollection`1<HangReportContribution> NestedReports { get; private set; }
    public HangReportContribution(string content, string contentType, string contentName);
    public HangReportContribution(string content, string contentType, string contentName, HangReportContribution[] nestedReports);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_ContentName();
    [CompilerGeneratedAttribute]
private void set_ContentName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<HangReportContribution> get_NestedReports();
    [CompilerGeneratedAttribute]
private void set_NestedReports(IReadOnlyCollection`1<HangReportContribution> value);
}
public interface Microsoft.VisualStudio.Threading.IAsyncDisposable {
    public abstract virtual Task DisposeAsync();
}
public interface Microsoft.VisualStudio.Threading.IHangReportContributor {
    public abstract virtual HangReportContribution GetHangReport();
}
internal class Microsoft.VisualStudio.Threading.InlineResumable : object {
    private Action continuation;
    private SynchronizationContext capturedSynchronizationContext;
    private bool resumed;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public InlineResumable GetAwaiter();
    public void Resume();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Threading.InternalUtilities : object {
    private static string AsyncReturnStackPrefix;
    [ExtensionAttribute]
internal static bool RemoveMidQueue(Queue`1<T> queue, T valueToRemove);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.InternalUtilities/<GetAsyncReturnStackFrames>d__2")]
[ExtensionAttribute]
internal static IEnumerable`1<string> GetAsyncReturnStackFrames(Delegate continuationDelegate);
    private static string GetDelegateLabel(Delegate invokeDelegate);
    private static IntPtr GetAddress(object value);
    private static IAsyncStateMachine FindAsyncStateMachine(Delegate invokeDelegate);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Threading.InternalUtilities/<FindContinuationDelegates>d__6")]
private static IEnumerable`1<Delegate> FindContinuationDelegates(IAsyncStateMachine stateMachine);
    private static object GetFieldValue(object obj, string fieldName);
    private static object GetStateMachineFieldValueOnSuffix(IAsyncStateMachine stateMachine, string suffix);
}
[DebuggerDisplayAttribute("IsCompleted: {IsCompleted}, Method = {EntryMethodInfo != null ? EntryMethodInfo.Name : null}")]
public class Microsoft.VisualStudio.Threading.JoinableTask : object {
    private DependentSynchronousTask dependingSynchronousTaskTracking;
    private static ThreadLocal`1<JoinableTask> CompletingTask;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskFactory owner;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskCreationOptions creationOptions;
    [DebuggerBrowsableAttribute("0")]
private ListOfOftenOne`1<JoinableTaskFactory> nestingFactories;
    [DebuggerBrowsableAttribute("0")]
private ListOfOftenOne`1<JoinableTaskCollection> collectionMembership;
    [DebuggerBrowsableAttribute("0")]
private Task wrappedTask;
    [DebuggerBrowsableAttribute("0")]
private WeakKeyDictionary`2<JoinableTask, int> childOrJoinedJobs;
    [DebuggerBrowsableAttribute("0")]
private AsyncManualResetEvent queueNeedProcessEvent;
    [DebuggerBrowsableAttribute("0")]
private WeakReference`1<JoinableTask> pendingEventSource;
    [DebuggerBrowsableAttribute("0")]
private int pendingEventCount;
    [DebuggerBrowsableAttribute("0")]
private ExecutionQueue mainThreadQueue;
    [DebuggerBrowsableAttribute("0")]
private ExecutionQueue threadPoolQueue;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskFlags state;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskSynchronizationContext mainThreadJobSyncContext;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskSynchronizationContext threadPoolJobSyncContext;
    [DebuggerBrowsableAttribute("0")]
private Delegate initialDelegate;
    internal bool HasMainThreadSynchronousTaskWaiting { get; }
    [DebuggerBrowsableAttribute("0")]
private Task QueueNeedProcessEvent { get; }
    internal ListOfOftenOne`1<JoinableTaskFactory> NestingFactories { get; internal set; }
    public bool IsCompleted { get; }
    public Task Task { get; }
    internal static JoinableTask TaskCompletingOnThisThread { get; }
    internal JoinableTaskFactory Factory { get; }
    [DebuggerBrowsableAttribute("0")]
internal SynchronizationContext ApplicableJobSyncContext { get; }
    internal JoinableTaskFlags State { get; }
    internal JoinableTaskCreationOptions CreationOptions { get; }
    internal MethodInfo EntryMethodInfo { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool HasNonEmptyQueue { get; }
    [DebuggerBrowsableAttribute("0")]
internal IEnumerable`1<JoinableTask> ChildOrJoinedJobs { get; }
    [DebuggerBrowsableAttribute("0")]
internal IEnumerable`1<SingleExecuteProtector> MainThreadQueueContents { get; }
    [DebuggerBrowsableAttribute("0")]
internal IEnumerable`1<SingleExecuteProtector> ThreadPoolQueueContents { get; }
    [DebuggerBrowsableAttribute("0")]
internal IEnumerable`1<JoinableTaskCollection> ContainingCollections { get; }
    [DebuggerBrowsableAttribute("0")]
private bool IsCompleteRequested { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private bool SynchronouslyBlockingThreadPool { get; }
    [DebuggerBrowsableAttribute("0")]
private bool SynchronouslyBlockingMainThread { get; }
    internal static bool AwaitShouldCaptureSyncContext { get; }
    internal JoinableTask(JoinableTaskFactory owner, bool synchronouslyBlocking, JoinableTaskCreationOptions creationOptions, Delegate initialDelegate);
    private static JoinableTask();
    internal bool get_HasMainThreadSynchronousTaskWaiting();
    private int CountOfDependingSynchronousTasks();
    private bool IsDependingSynchronousTask(JoinableTask syncTask);
    private List`1<JoinableTask> GetDependingSynchronousTasks(bool forMainThread);
    private List`1<PendingNotification> AddDependingSynchronousTaskToChild(JoinableTask child);
    private void RemoveDependingSynchronousTaskFromChild(JoinableTask child);
    private int GetPendingEventCountForTask(JoinableTask task);
    private JoinableTask AddDependingSynchronousTask(JoinableTask task, Int32& totalEventsPending);
    private void CleanupDependingSynchronousTask();
    private void RemoveDependingSynchronousTask(JoinableTask task, bool force);
    private static void RemoveDependingSynchronousTaskFrom(IReadOnlyList`1<JoinableTask> tasks, JoinableTask syncTask, bool force);
    private void ComputeSelfAndDescendentOrJoinedJobsAndRemainTasks(HashSet`1<JoinableTask> reachableTasks, HashSet`1<JoinableTask> remainTasks);
    private void RemoveDependingSynchronousTask(JoinableTask task, HashSet`1<JoinableTask> reachableTasks, HashSet`1& remainingDependentTasks);
    private Task get_QueueNeedProcessEvent();
    internal ListOfOftenOne`1<JoinableTaskFactory> get_NestingFactories();
    internal void set_NestingFactories(ListOfOftenOne`1<JoinableTaskFactory> value);
    public bool get_IsCompleted();
    public Task get_Task();
    internal static JoinableTask get_TaskCompletingOnThisThread();
    internal JoinableTaskFactory get_Factory();
    internal SynchronizationContext get_ApplicableJobSyncContext();
    internal JoinableTaskFlags get_State();
    internal JoinableTaskCreationOptions get_CreationOptions();
    internal MethodInfo get_EntryMethodInfo();
    internal bool get_HasNonEmptyQueue();
    internal IEnumerable`1<JoinableTask> get_ChildOrJoinedJobs();
    internal IEnumerable`1<SingleExecuteProtector> get_MainThreadQueueContents();
    internal IEnumerable`1<SingleExecuteProtector> get_ThreadPoolQueueContents();
    internal IEnumerable`1<JoinableTaskCollection> get_ContainingCollections();
    private bool get_IsCompleteRequested();
    private void set_IsCompleteRequested(bool value);
    private bool get_SynchronouslyBlockingThreadPool();
    private bool get_SynchronouslyBlockingMainThread();
    internal static bool get_AwaitShouldCaptureSyncContext();
    public void Join(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.JoinableTask/<JoinAsync>d__78")]
public Task JoinAsync(CancellationToken cancellationToken);
    internal void Post(SendOrPostCallback d, object state, bool mainThreadAffinitized);
    public TaskAwaiter GetAwaiter();
    internal void SetWrappedTask(Task wrappedTask);
    internal void Complete();
    internal void RemoveDependency(JoinableTask joinChild);
    internal void AddSelfAndDescendentOrJoinedJobs(HashSet`1<JoinableTask> joinables);
    internal void CompleteOnCurrentThread();
    internal void OnQueueCompleted();
    internal void OnAddedToCollection(JoinableTaskCollection collection);
    internal void OnRemovedFromCollection(JoinableTaskCollection collection);
    private void AddStateFlags(JoinableTaskFlags flags);
    private bool TryDequeueSelfOrDependencies(bool onMainThread, HashSet`1& visited, SingleExecuteProtector& work, Task& tryAgainAfter);
    private bool TryDequeueSelfOrDependencies(bool onMainThread, HashSet`1<JoinableTask> visited, SingleExecuteProtector& work);
    internal JoinRelease AddDependency(JoinableTask joinChild);
    private JoinRelease AmbientJobJoinsThis();
}
[DebuggerDisplayAttribute("IsCompleted: {IsCompleted}, Method = {EntryMethodInfo != null ? EntryMethodInfo.Name : null}")]
public class Microsoft.VisualStudio.Threading.JoinableTask`1 : JoinableTask {
    public Task`1<T> Task { get; }
    internal JoinableTask`1(JoinableTaskFactory owner, bool synchronouslyBlocking, JoinableTaskCreationOptions creationOptions, Delegate initialDelegate);
    public Task`1<T> get_Task();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.JoinableTask`1/<JoinAsync>d__3")]
public Task`1<T> JoinAsync(CancellationToken cancellationToken);
    public T Join(CancellationToken cancellationToken);
    public TaskAwaiter`1<T> GetAwaiter();
    internal T CompleteOnCurrentThread();
}
[DebuggerDisplayAttribute("JoinableTaskCollection: {displayName ?? "(anonymous)"}")]
public class Microsoft.VisualStudio.Threading.JoinableTaskCollection : object {
    private WeakKeyDictionary`2<JoinableTask, int> joinables;
    private WeakKeyDictionary`2<JoinableTask, int> joiners;
    private bool refCountAddedJobs;
    [DebuggerBrowsableAttribute("0")]
private string displayName;
    private AsyncManualResetEvent emptyEvent;
    [CompilerGeneratedAttribute]
private JoinableTaskContext <Context>k__BackingField;
    public JoinableTaskContext Context { get; private set; }
    public string DisplayName { get; public set; }
    public JoinableTaskCollection(JoinableTaskContext context, bool refCountAddedJobs);
    [CompilerGeneratedAttribute]
public JoinableTaskContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(JoinableTaskContext value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public void Add(JoinableTask joinableTask);
    public void Remove(JoinableTask joinableTask);
    public JoinRelease Join();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.JoinableTaskCollection/<JoinTillEmptyAsync>d__16")]
public Task JoinTillEmptyAsync();
    public bool Contains(JoinableTask joinableTask);
    public sealed virtual IEnumerator`1<JoinableTask> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Disjoin(JoinableTask joinableTask);
}
public class Microsoft.VisualStudio.Threading.JoinableTaskContext : object {
    [DebuggerBrowsableAttribute("0")]
private object syncContextLock;
    private AsyncLocal`1<JoinableTask> joinableOperation;
    private HashSet`1<JoinableTask> pendingTasks;
    private Stack`1<JoinableTask> initializingSynchronouslyMainThreadTasks;
    private HashSet`1<JoinableTaskContextNode> hangNotifications;
    private int mainThreadManagedThreadId;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskFactory nonJoinableFactory;
    [CompilerGeneratedAttribute]
private Thread <MainThread>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationContext <UnderlyingSynchronizationContext>k__BackingField;
    public JoinableTaskFactory Factory { get; }
    public Thread MainThread { get; private set; }
    public bool IsOnMainThread { get; }
    public bool IsWithinJoinableTask { get; }
    internal SynchronizationContext UnderlyingSynchronizationContext { get; private set; }
    internal object SyncContextLock { get; }
    internal JoinableTask AmbientTask { get; internal set; }
    protected internal SynchronizationContext NoMessagePumpSynchronizationContext { get; }
    public JoinableTaskContext(Thread mainThread, SynchronizationContext synchronizationContext);
    private sealed virtual override HangReportContribution Microsoft.VisualStudio.Threading.IHangReportContributor.GetHangReport();
    protected virtual HangReportContribution GetHangReport();
    private static XDocument CreateTemplateDgml(XElement& nodes, XElement& links);
    private static ICollection`1<XElement> CreatesLinksBetweenNodes(Dictionary`2<JoinableTask, XElement> pendingTasksElements);
    private static ICollection`1<XElement> CreateCollectionContainingTaskLinks(Dictionary`2<JoinableTask, XElement> tasks, Dictionary`2<JoinableTaskCollection, XElement> collections);
    private static Dictionary`2<JoinableTaskCollection, XElement> CreateNodesForJoinableTaskCollections(IEnumerable`1<JoinableTask> tasks);
    private static List`1<Tuple`2<XElement, XElement>> CreateNodeLabels(Dictionary`2<JoinableTask, XElement> tasksAndElements);
    private Dictionary`2<JoinableTask, XElement> CreateNodesForPendingTasks();
    private static string GetAsyncReturnStack(SingleExecuteProtector singleExecuteProtector);
    public JoinableTaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public Thread get_MainThread();
    [CompilerGeneratedAttribute]
private void set_MainThread(Thread value);
    public bool get_IsOnMainThread();
    public bool get_IsWithinJoinableTask();
    [CompilerGeneratedAttribute]
internal SynchronizationContext get_UnderlyingSynchronizationContext();
    [CompilerGeneratedAttribute]
private void set_UnderlyingSynchronizationContext(SynchronizationContext value);
    internal object get_SyncContextLock();
    internal JoinableTask get_AmbientTask();
    internal void set_AmbientTask(JoinableTask value);
    protected internal virtual SynchronizationContext get_NoMessagePumpSynchronizationContext();
    public RevertRelevance SuppressRelevance();
    public bool IsMainThreadBlocked();
    public virtual JoinableTaskFactory CreateFactory(JoinableTaskCollection collection);
    public JoinableTaskCollection CreateCollection();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected internal virtual void OnHangDetected(TimeSpan hangDuration, int notificationCount, Guid hangId);
    protected internal virtual void OnFalseHangDetected(TimeSpan hangDuration, Guid hangId);
    protected internal virtual JoinableTaskFactory CreateDefaultFactory();
    internal void OnJoinableTaskStarted(JoinableTask task);
    internal void OnJoinableTaskCompleted(JoinableTask task);
    internal void OnSynchronousJoinableTaskToCompleteOnMainThread(JoinableTask task);
    internal IDisposable RegisterHangNotifications(JoinableTaskContextNode node);
}
public class Microsoft.VisualStudio.Threading.JoinableTaskContextException : Exception {
    public JoinableTaskContextException(string message);
    public JoinableTaskContextException(string message, Exception inner);
    protected JoinableTaskContextException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Threading.JoinableTaskContextNode : object {
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskContext context;
    [DebuggerBrowsableAttribute("0")]
private JoinableTaskFactory nonJoinableFactory;
    public JoinableTaskFactory Factory { get; }
    public Thread MainThread { get; }
    public bool IsOnMainThread { get; }
    public JoinableTaskContext Context { get; }
    public JoinableTaskContextNode(JoinableTaskContext context);
    public JoinableTaskFactory get_Factory();
    public Thread get_MainThread();
    public bool get_IsOnMainThread();
    public JoinableTaskContext get_Context();
    public virtual JoinableTaskFactory CreateFactory(JoinableTaskCollection collection);
    public JoinableTaskCollection CreateCollection();
    public RevertRelevance SuppressRelevance();
    public bool IsMainThreadBlocked();
    protected virtual void OnHangDetected(TimeSpan hangDuration, int notificationCount, Guid hangId);
    protected internal virtual void OnHangDetected(HangDetails details);
    protected internal virtual void OnFalseHangDetected(TimeSpan hangDuration, Guid hangId);
    protected virtual JoinableTaskFactory CreateDefaultFactory();
    protected IDisposable RegisterOnHangDetected();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions : Enum {
    public int value__;
    public static JoinableTaskCreationOptions None;
    public static JoinableTaskCreationOptions LongRunning;
}
public class Microsoft.VisualStudio.Threading.JoinableTaskFactory : object {
    private JoinableTaskContext owner;
    private SynchronizationContext mainThreadJobSyncContext;
    private JoinableTaskCollection jobCollection;
    private TimeSpan hangDetectionTimeout;
    public JoinableTaskContext Context { get; }
    internal SynchronizationContext ApplicableJobSyncContext { get; }
    internal JoinableTaskCollection Collection { get; }
    protected TimeSpan HangDetectionTimeout { get; protected set; }
    protected SynchronizationContext UnderlyingSynchronizationContext { get; }
    public JoinableTaskFactory(JoinableTaskContext owner);
    public JoinableTaskFactory(JoinableTaskCollection collection);
    internal JoinableTaskFactory(JoinableTaskContext owner, JoinableTaskCollection collection);
    public JoinableTaskContext get_Context();
    internal SynchronizationContext get_ApplicableJobSyncContext();
    internal JoinableTaskCollection get_Collection();
    protected TimeSpan get_HangDetectionTimeout();
    protected void set_HangDetectionTimeout(TimeSpan value);
    protected SynchronizationContext get_UnderlyingSynchronizationContext();
    public MainThreadAwaitable SwitchToMainThreadAsync(CancellationToken cancellationToken);
    internal SingleExecuteProtector RequestSwitchToMainThread(Action callback);
    protected internal virtual void PostToUnderlyingSynchronizationContext(SendOrPostCallback callback, object state);
    protected internal virtual void OnTransitioningToMainThread(JoinableTask joinableTask);
    protected internal virtual void OnTransitionedToMainThread(JoinableTask joinableTask, bool canceled);
    internal void PostToUnderlyingSynchronizationContextOrThreadPool(SingleExecuteProtector callback);
    protected internal virtual void WaitSynchronously(Task task);
    protected virtual void WaitSynchronouslyCore(Task task);
    protected bool IsWaitingOnLongRunningTask();
    public void Run(Func`1<Task> asyncMethod);
    public void Run(Func`1<Task> asyncMethod, JoinableTaskCreationOptions creationOptions);
    public T Run(Func`1<Task`1<T>> asyncMethod);
    public T Run(Func`1<Task`1<T>> asyncMethod, JoinableTaskCreationOptions creationOptions);
    public JoinableTask RunAsync(Func`1<Task> asyncMethod);
    public JoinableTask RunAsync(Func`1<Task> asyncMethod, JoinableTaskCreationOptions creationOptions);
    internal void Run(Func`1<Task> asyncMethod, JoinableTaskCreationOptions creationOptions, Delegate entrypointOverride);
    private JoinableTask RunAsync(Func`1<Task> asyncMethod, bool synchronouslyBlocking, JoinableTaskCreationOptions creationOptions, Delegate entrypointOverride);
    public JoinableTask`1<T> RunAsync(Func`1<Task`1<T>> asyncMethod);
    public JoinableTask`1<T> RunAsync(Func`1<Task`1<T>> asyncMethod, JoinableTaskCreationOptions creationOptions);
    internal void Post(SendOrPostCallback callback, object state, bool mainThreadAffinitized);
    protected void Add(JoinableTask joinable);
    private static void VerifyNoNonConcurrentSyncContext();
    private JoinableTask`1<T> RunAsync(Func`1<Task`1<T>> asyncMethod, bool synchronouslyBlocking, JoinableTaskCreationOptions creationOptions);
    private void ExecuteJob(Func`1<Task> asyncMethod, JoinableTask job);
}
internal static class Microsoft.VisualStudio.Threading.LightUps : object {
    private static Version Windows8Version;
    internal static bool ForceNet45Mode;
    internal static bool ForceWindows7Mode;
    internal static bool IsRunContinuationsAsynchronouslySupported;
    internal static TaskCreationOptions RunContinuationsAsynchronously;
    internal static bool IsWindows8OrLater { get; }
    private static LightUps();
    internal static bool get_IsWindows8OrLater();
}
internal static class Microsoft.VisualStudio.Threading.LightUps`1 : object {
    private static LightUps`1();
}
internal class Microsoft.VisualStudio.Threading.ListOfOftenOne`1 : ValueType {
    private object value;
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(T value);
    public void Remove(T value);
    public bool Contains(T value);
    internal Enumerator<T> EnumerateAndClear();
    private static object Combine(object baseValue, T value);
    private static object Remove(object baseValue, T value);
}
internal class Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext : SynchronizationContext {
    private static SynchronizationContext DefaultInstance;
    public static SynchronizationContext Default { get; }
    private static NoMessagePumpSyncContext();
    public static SynchronizationContext get_Default();
}
public class Microsoft.VisualStudio.Threading.ProgressWithCompletion`1 : object {
    private object syncObject;
    private Func`2<T, Task> handler;
    private HashSet`1<Task> outstandingTasks;
    private TaskFactory taskFactory;
    public ProgressWithCompletion`1(Action`1<T> handler);
    public ProgressWithCompletion`1(Func`2<T, Task> handler);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    protected virtual void Report(T value);
    public Task WaitAsync();
}
[DebuggerDisplayAttribute("CurrentCount = {CurrentCount}")]
public abstract class Microsoft.VisualStudio.Threading.ReentrantSemaphore : object {
    private JoinableTaskFactory joinableTaskFactory;
    private JoinableTaskCollection joinableTaskCollection;
    private AsyncSemaphore semaphore;
    public int CurrentCount { get; }
    private bool IsJoinableTaskAware { get; }
    private protected ReentrantSemaphore(int initialCount, JoinableTaskContext joinableTaskContext);
    public int get_CurrentCount();
    private bool get_IsJoinableTaskAware();
    public static ReentrantSemaphore Create(int initialCount, JoinableTaskContext joinableTaskContext, ReentrancyMode mode);
    public abstract virtual Task ExecuteAsync(Func`1<Task> operation, CancellationToken cancellationToken);
    public virtual RevertRelevance SuppressRelevance();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void ThrowIfFaulted();
    private static void DisposeReleaserNoThrow(Releaser releaser);
    private ExecuteContinuationSynchronouslyAwaitable ExecuteCoreAsync(Func`1<Task> semaphoreUser);
}
public class Microsoft.VisualStudio.Threading.SpecializedSyncContext : ValueType {
    private bool initialized;
    private SynchronizationContext prior;
    private SynchronizationContext appliedContext;
    private bool checkForChangesOnRevert;
    private SpecializedSyncContext(SynchronizationContext syncContext, bool checkForChangesOnRevert);
    public static SpecializedSyncContext Apply(SynchronizationContext syncContext, bool checkForChangesOnRevert);
    public sealed virtual void Dispose();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Threading.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AppliedSynchronizationContextNotAllowed { get; }
    internal static string CannotUpgradeNonUpgradeableLock { get; }
    internal static string DangerousReadLockRequestFromWriteLockFork { get; }
    internal static string InvalidAfterCompleted { get; }
    internal static string InvalidLock { get; }
    internal static string InvalidWithoutLock { get; }
    internal static string JoinableTaskContextAndCollectionMismatch { get; }
    internal static string JoinableTaskContextNodeAlreadyRegistered { get; }
    internal static string LazyValueFaulted { get; }
    internal static string LazyValueNotCreated { get; }
    internal static string LockCompletionAlreadyRequested { get; }
    internal static string NotAllowedUnderURorWLock { get; }
    internal static string QueueEmpty { get; }
    internal static string SemaphoreMisused { get; }
    internal static string SemaphoreStackNestingViolated { get; }
    internal static string STAThreadCallerNotAllowed { get; }
    internal static string SwitchToMainThreadFailedToReachExpectedThread { get; }
    internal static string ValueFactoryReentrancy { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AppliedSynchronizationContextNotAllowed();
    internal static string get_CannotUpgradeNonUpgradeableLock();
    internal static string get_DangerousReadLockRequestFromWriteLockFork();
    internal static string get_InvalidAfterCompleted();
    internal static string get_InvalidLock();
    internal static string get_InvalidWithoutLock();
    internal static string get_JoinableTaskContextAndCollectionMismatch();
    internal static string get_JoinableTaskContextNodeAlreadyRegistered();
    internal static string get_LazyValueFaulted();
    internal static string get_LazyValueNotCreated();
    internal static string get_LockCompletionAlreadyRequested();
    internal static string get_NotAllowedUnderURorWLock();
    internal static string get_QueueEmpty();
    internal static string get_SemaphoreMisused();
    internal static string get_SemaphoreStackNestingViolated();
    internal static string get_STAThreadCallerNotAllowed();
    internal static string get_SwitchToMainThreadFailedToReachExpectedThread();
    internal static string get_ValueFactoryReentrancy();
}
internal class Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1 : TaskCompletionSource`1<T> {
    private Task`1<T> exposedTask;
    internal Task`1<T> Task { get; }
    internal TaskCompletionSourceWithoutInlining`1(bool allowInliningContinuations, TaskCreationOptions options, object state);
    internal Task`1<T> get_Task();
    private static TaskCreationOptions AdjustFlags(TaskCreationOptions options, bool allowInliningContinuations);
}
[EventSourceAttribute]
internal class Microsoft.VisualStudio.Threading.ThreadingEventSource : EventSource {
    private static int ReaderWriterLockIssuedLockCountsEvent;
    private static int WaitReaderWriterLockStartEvent;
    private static int WaitReaderWriterLockStopEvent;
    private static int CompleteOnCurrentThreadStartEvent;
    private static int CompleteOnCurrentThreadStopEvent;
    private static int WaitSynchronouslyStartEvent;
    private static int WaitSynchronouslyStopEvent;
    private static int PostExecutionStartEvent;
    private static int PostExecutionStopEvent;
    internal static ThreadingEventSource Instance;
    private static ThreadingEventSource();
    [EventAttribute("1")]
public void ReaderWriterLockIssued(int lockId, LockKind kind, int issuedUpgradeableReadCount, int issuedReadCount);
    [EventAttribute("2")]
public void WaitReaderWriterLockStart(int lockId, LockKind kind, int issuedWriteCount, int issuedUpgradeableReadCount, int issuedReadCount);
    [EventAttribute("3")]
public void WaitReaderWriterLockStop(int lockId, LockKind kind);
    [EventAttribute("11")]
public void CompleteOnCurrentThreadStart(int taskId, bool isOnMainThread);
    [EventAttribute("12")]
public void CompleteOnCurrentThreadStop(int taskId);
    [EventAttribute("13")]
public void WaitSynchronouslyStart();
    [EventAttribute("14")]
public void WaitSynchronouslyStop();
    [EventAttribute("15")]
public void PostExecutionStart(int requestId, bool mainThreadAffinitized);
    [EventAttribute("16")]
public void PostExecutionStop(int requestId);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Threading.ThreadingTools : object {
    public static bool ApplyChangeOptimistically(T& hotLocation, Func`2<T, T> applyChange);
    [ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SpecializedSyncContext Apply(SynchronizationContext syncContext, bool checkForChangesOnRevert);
    [ExtensionAttribute]
internal static Task WithCancellation(Task task, bool continueOnCapturedContext, CancellationToken cancellationToken);
    internal static Task TaskFromCanceled(CancellationToken cancellationToken);
    internal static Task`1<T> TaskFromCanceled(CancellationToken cancellationToken);
    internal static Task TaskFromException(Exception exception);
    internal static Task`1<T> TaskFromException(Exception exception);
    [ExtensionAttribute]
internal static void AttachCancellation(TaskCompletionSource`1<T> taskCompletionSource, CancellationToken cancellationToken, ICancellationNotification cancellationCallback);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.ThreadingTools/<WithCancellationSlow>d__10`1")]
private static Task`1<T> WithCancellationSlow(Task`1<T> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.ThreadingTools/<WithCancellationSlow>d__11")]
[ExtensionAttribute]
private static Task WithCancellationSlow(Task task, bool continueOnCapturedContext, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Threading.TplExtensions : object {
    public static Task CompletedTask;
    public static Task CanceledTask;
    public static Task`1<bool> TrueTask;
    public static Task`1<bool> FalseTask;
    private static TplExtensions();
    [ExtensionAttribute]
public static void WaitWithoutInlining(Task task);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.TplExtensions/<WithTimeout>d__5")]
[ExtensionAttribute]
public static Task WithTimeout(Task task, TimeSpan timeout);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.TplExtensions/<WithTimeout>d__6`1")]
[ExtensionAttribute]
public static Task`1<T> WithTimeout(Task`1<T> task, TimeSpan timeout);
    [ExtensionAttribute]
public static void ApplyResultTo(Task`1<T> task, TaskCompletionSource`1<T> tcs);
    [ExtensionAttribute]
public static void ApplyResultTo(Task task, TaskCompletionSource`1<T> tcs);
    [ExtensionAttribute]
public static Task`1<T> AttachToParent(Task`1<T> task);
    [ExtensionAttribute]
public static Task AttachToParent(Task task);
    [ExtensionAttribute]
public static Task AppendAction(Task task, Action action, TaskContinuationOptions options, CancellationToken cancellation);
    public static Task`1<T> FollowCancelableTaskToCompletion(Func`1<Task`1<T>> taskToFollow, CancellationToken ultimateCancellation, TaskCompletionSource`1<T> taskThatFollows);
    [ExtensionAttribute]
public static NoThrowTaskAwaitable NoThrowAwaitable(Task task, bool captureContext);
    [ExtensionAttribute]
public static void Forget(Task task);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.TplExtensions/<InvokeAsync>d__15")]
[ExtensionAttribute]
public static Task InvokeAsync(AsyncEventHandler handlers, object sender, EventArgs args);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Threading.TplExtensions/<InvokeAsync>d__16`1")]
[ExtensionAttribute]
public static Task InvokeAsync(AsyncEventHandler`1<TEventArgs> handlers, object sender, TEventArgs args);
    [ExtensionAttribute]
public static Task`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static Task ToApm(Task task, AsyncCallback callback, object state);
    [ExtensionAttribute]
public static Task`1<bool> ToTask(WaitHandle handle, int timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static void ApplyResultTo(Task`1<T> task, TaskCompletionSource`1<T> tcs, bool inlineSubsequentCompletion);
    internal static Task`1<T> CanceledTaskOfT();
    private static void ApplyCompletedTaskResultTo(Task`1<T> completedTask, TaskCompletionSource`1<T> taskCompletionSource);
    private static void ApplyCompletedTaskResultTo(Task completedTask, TaskCompletionSource`1<T> taskCompletionSource, T valueOnRanToCompletion);
    private static Task`1<T> FollowCancelableTaskToCompletionHelper(TaskCompletionSource`2<FollowCancelableTaskState`1<T>, T> tcs, Task`1<T> currentTask);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Threading.WeakKeyDictionary`2 : object {
    [DebuggerBrowsableAttribute("3")]
private Dictionary`2<WeakReference`1<TKey, TValue, TKey>, TValue> dictionary;
    private IEqualityComparer`1<TKey> keyComparer;
    [DebuggerBrowsableAttribute("0")]
private int capacity;
    [DebuggerBrowsableAttribute("0")]
public int Count { get; }
    public TValue Item { get; public set; }
    public WeakKeyDictionary`2(IEqualityComparer`1<TKey> keyComparer, int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool ContainsKey(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public int Scavenge();
    public void Clear();
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
