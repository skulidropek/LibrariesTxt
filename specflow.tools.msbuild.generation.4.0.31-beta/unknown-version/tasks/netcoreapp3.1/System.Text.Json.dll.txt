internal static class FxResources.System.Text.Json.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal enum System.Buffers.Text.SequenceValidity : Enum {
    public int value__;
    public static SequenceValidity Empty;
    public static SequenceValidity WellFormed;
    public static SequenceValidity Incomplete;
    public static SequenceValidity Invalid;
}
internal class System.Collections.Generic.ReferenceEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ReferenceEqualityComparer <Instance>k__BackingField;
    public static ReferenceEqualityComparer Instance { get; }
    private static ReferenceEqualityComparer();
    [CompilerGeneratedAttribute]
public static ReferenceEqualityComparer get_Instance();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public DynamicDependencyAttribute(string memberSignature);
    public DynamicDependencyAttribute(string memberSignature, Type type);
    public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[AttributeUsageAttribute("6140")]
internal class System.ObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string Message { get; }
    public bool IsError { get; }
    public string DiagnosticId { get; public set; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public void set_DiagnosticId(string value);
    [CompilerGeneratedAttribute]
public string get_UrlFormat();
    [CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayDepthTooLarge { get; }
    internal static string CallFlushToAvoidDataLoss { get; }
    internal static string CannotReadIncompleteUTF16 { get; }
    internal static string CannotReadInvalidUTF16 { get; }
    internal static string CannotStartObjectArrayAfterPrimitiveOrClose { get; }
    internal static string CannotStartObjectArrayWithoutProperty { get; }
    internal static string CannotTranscodeInvalidUtf8 { get; }
    internal static string CannotDecodeInvalidBase64 { get; }
    internal static string CannotTranscodeInvalidUtf16 { get; }
    internal static string CannotEncodeInvalidUTF16 { get; }
    internal static string CannotEncodeInvalidUTF8 { get; }
    internal static string CannotWritePropertyWithinArray { get; }
    internal static string CannotWritePropertyAfterProperty { get; }
    internal static string CannotWriteValueAfterPrimitiveOrClose { get; }
    internal static string CannotWriteValueWithinObject { get; }
    internal static string DepthTooLarge { get; }
    internal static string EmptyJsonIsInvalid { get; }
    internal static string EndOfCommentNotFound { get; }
    internal static string EndOfStringNotFound { get; }
    internal static string ExpectedEndAfterSingleJson { get; }
    internal static string ExpectedEndOfDigitNotFound { get; }
    internal static string ExpectedFalse { get; }
    internal static string ExpectedJsonTokens { get; }
    internal static string ExpectedOneCompleteToken { get; }
    internal static string ExpectedNextDigitEValueNotFound { get; }
    internal static string ExpectedNull { get; }
    internal static string ExpectedSeparatorAfterPropertyNameNotFound { get; }
    internal static string ExpectedStartOfPropertyNotFound { get; }
    internal static string ExpectedStartOfPropertyOrValueNotFound { get; }
    internal static string ExpectedStartOfValueNotFound { get; }
    internal static string ExpectedTrue { get; }
    internal static string ExpectedValueAfterPropertyNameNotFound { get; }
    internal static string FailedToGetLargerSpan { get; }
    internal static string FoundInvalidCharacter { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidCharacterAfterEscapeWithinString { get; }
    internal static string InvalidCharacterWithinString { get; }
    internal static string InvalidEndOfJsonNonPrimitive { get; }
    internal static string InvalidHexCharacterWithinString { get; }
    internal static string JsonDocumentDoesNotSupportComments { get; }
    internal static string JsonElementHasWrongType { get; }
    internal static string MaxDepthMustBePositive { get; }
    internal static string CommentHandlingMustBeValid { get; }
    internal static string MismatchedObjectArray { get; }
    internal static string CannotWriteEndAfterProperty { get; }
    internal static string ObjectDepthTooLarge { get; }
    internal static string PropertyNameTooLarge { get; }
    internal static string FormatDecimal { get; }
    internal static string FormatDouble { get; }
    internal static string FormatInt32 { get; }
    internal static string FormatInt64 { get; }
    internal static string FormatSingle { get; }
    internal static string FormatUInt32 { get; }
    internal static string FormatUInt64 { get; }
    internal static string RequiredDigitNotFoundAfterDecimal { get; }
    internal static string RequiredDigitNotFoundAfterSign { get; }
    internal static string RequiredDigitNotFoundEndOfData { get; }
    internal static string SpecialNumberValuesNotSupported { get; }
    internal static string ValueTooLarge { get; }
    internal static string ZeroDepthAtEnd { get; }
    internal static string DeserializeUnableToConvertValue { get; }
    internal static string DeserializeWrongType { get; }
    internal static string SerializationInvalidBufferSize { get; }
    internal static string BufferWriterAdvancedTooFar { get; }
    internal static string InvalidComparison { get; }
    internal static string FormatDateTime { get; }
    internal static string FormatDateTimeOffset { get; }
    internal static string FormatTimeSpan { get; }
    internal static string FormatGuid { get; }
    internal static string ExpectedStartOfPropertyOrValueAfterComment { get; }
    internal static string TrailingCommaNotAllowedBeforeArrayEnd { get; }
    internal static string TrailingCommaNotAllowedBeforeObjectEnd { get; }
    internal static string SerializerOptionsImmutable { get; }
    internal static string StreamNotWritable { get; }
    internal static string CannotWriteCommentWithEmbeddedDelimiter { get; }
    internal static string SerializerPropertyNameConflict { get; }
    internal static string SerializerPropertyNameNull { get; }
    internal static string SerializationDataExtensionPropertyInvalid { get; }
    internal static string SerializationDuplicateTypeAttribute { get; }
    internal static string SerializationNotSupportedType { get; }
    internal static string TypeRequiresAsyncSerialization { get; }
    internal static string InvalidCharacterAtStartOfComment { get; }
    internal static string UnexpectedEndOfDataWhileReadingComment { get; }
    internal static string CannotSkip { get; }
    internal static string NotEnoughData { get; }
    internal static string UnexpectedEndOfLineSeparator { get; }
    internal static string JsonSerializerDoesNotSupportComments { get; }
    internal static string DeserializeNoConstructor { get; }
    internal static string DeserializePolymorphicInterface { get; }
    internal static string SerializationConverterOnAttributeNotCompatible { get; }
    internal static string SerializationConverterOnAttributeInvalid { get; }
    internal static string SerializationConverterRead { get; }
    internal static string SerializationConverterNotCompatible { get; }
    internal static string SerializationConverterWrite { get; }
    internal static string NamingPolicyReturnNull { get; }
    internal static string SerializationDuplicateAttribute { get; }
    internal static string SerializeUnableToSerialize { get; }
    internal static string FormatByte { get; }
    internal static string FormatInt16 { get; }
    internal static string FormatSByte { get; }
    internal static string FormatUInt16 { get; }
    internal static string SerializerCycleDetected { get; }
    internal static string InvalidLeadingZeroInNumber { get; }
    internal static string MetadataCannotParsePreservedObjectToImmutable { get; }
    internal static string MetadataDuplicateIdFound { get; }
    internal static string MetadataIdIsNotFirstProperty { get; }
    internal static string MetadataInvalidReferenceToValueType { get; }
    internal static string MetadataInvalidTokenAfterValues { get; }
    internal static string MetadataPreservedArrayFailed { get; }
    internal static string MetadataPreservedArrayInvalidProperty { get; }
    internal static string MetadataPreservedArrayPropertyNotFound { get; }
    internal static string MetadataReferenceCannotContainOtherProperties { get; }
    internal static string MetadataReferenceNotFound { get; }
    internal static string MetadataValueWasNotString { get; }
    internal static string MetadataInvalidPropertyWithLeadingDollarSign { get; }
    internal static string MultipleMembersBindWithConstructorParameter { get; }
    internal static string ConstructorParamIncompleteBinding { get; }
    internal static string ConstructorMaxOf64Parameters { get; }
    internal static string ObjectWithParameterizedCtorRefMetadataNotHonored { get; }
    internal static string SerializerConverterFactoryReturnsNull { get; }
    internal static string SerializationNotSupportedParentType { get; }
    internal static string ExtensionDataCannotBindToCtorParam { get; }
    internal static string BufferMaximumSizeExceeded { get; }
    internal static string CannotSerializeInvalidType { get; }
    internal static string SerializeTypeInstanceNotSupported { get; }
    internal static string JsonIncludeOnNonPublicInvalid { get; }
    internal static string CannotSerializeInvalidMember { get; }
    internal static string CannotPopulateCollection { get; }
    internal static string DefaultIgnoreConditionAlreadySpecified { get; }
    internal static string DefaultIgnoreConditionInvalid { get; }
    internal static string FormatBoolean { get; }
    internal static string DictionaryKeyTypeNotSupported { get; }
    internal static string IgnoreConditionOnValueTypeInvalid { get; }
    internal static string NumberHandlingOnPropertyInvalid { get; }
    internal static string ConverterCanConvertMultipleTypes { get; }
    internal static string MetadataReferenceOfTypeCannotBeAssignedToType { get; }
    internal static string DeserializeUnableToAssignValue { get; }
    internal static string DeserializeUnableToAssignNull { get; }
    internal static string SerializerConverterFactoryReturnsJsonConverterFactory { get; }
    internal static string NodeDynamicObjectResultNotAssignable { get; }
    internal static string NodeElementWrongType { get; }
    internal static string NodeElementCannotBeObjectOrArray { get; }
    internal static string NodeAlreadyHasParent { get; }
    internal static string NodeCycleDetected { get; }
    internal static string NodeUnableToConvert { get; }
    internal static string NodeUnableToConvertElement { get; }
    internal static string NodeValueNotAllowed { get; }
    internal static string NodeWrongType { get; }
    internal static string NodeDuplicateKey { get; }
    internal static string SerializerContextOptionsImmutable { get; }
    internal static string OptionsAlreadyBoundToContext { get; }
    internal static string InitializeTypeInfoAsObjectInvalid { get; }
    internal static string ConverterForPropertyMustBeValid { get; }
    internal static string BuiltInConvertersNotRooted { get; }
    internal static string NoMetadataForType { get; }
    internal static string NodeCollectionIsReadOnly { get; }
    internal static string NodeArrayIndexNegative { get; }
    internal static string NodeArrayTooSmall { get; }
    internal static string NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty { get; }
    internal static string MetadataInitFuncsNull { get; }
    internal static string NoMetadataForTypeProperties { get; }
    internal static string NoDefaultOptionsForContext { get; }
    internal static string FieldCannotBeVirtual { get; }
    internal static string MissingFSharpCoreMember { get; }
    internal static string FSharpDiscriminatedUnionsNotSupported { get; }
    internal static string NoMetadataForTypeCtorParams { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayDepthTooLarge();
    internal static string get_CallFlushToAvoidDataLoss();
    internal static string get_CannotReadIncompleteUTF16();
    internal static string get_CannotReadInvalidUTF16();
    internal static string get_CannotStartObjectArrayAfterPrimitiveOrClose();
    internal static string get_CannotStartObjectArrayWithoutProperty();
    internal static string get_CannotTranscodeInvalidUtf8();
    internal static string get_CannotDecodeInvalidBase64();
    internal static string get_CannotTranscodeInvalidUtf16();
    internal static string get_CannotEncodeInvalidUTF16();
    internal static string get_CannotEncodeInvalidUTF8();
    internal static string get_CannotWritePropertyWithinArray();
    internal static string get_CannotWritePropertyAfterProperty();
    internal static string get_CannotWriteValueAfterPrimitiveOrClose();
    internal static string get_CannotWriteValueWithinObject();
    internal static string get_DepthTooLarge();
    internal static string get_EmptyJsonIsInvalid();
    internal static string get_EndOfCommentNotFound();
    internal static string get_EndOfStringNotFound();
    internal static string get_ExpectedEndAfterSingleJson();
    internal static string get_ExpectedEndOfDigitNotFound();
    internal static string get_ExpectedFalse();
    internal static string get_ExpectedJsonTokens();
    internal static string get_ExpectedOneCompleteToken();
    internal static string get_ExpectedNextDigitEValueNotFound();
    internal static string get_ExpectedNull();
    internal static string get_ExpectedSeparatorAfterPropertyNameNotFound();
    internal static string get_ExpectedStartOfPropertyNotFound();
    internal static string get_ExpectedStartOfPropertyOrValueNotFound();
    internal static string get_ExpectedStartOfValueNotFound();
    internal static string get_ExpectedTrue();
    internal static string get_ExpectedValueAfterPropertyNameNotFound();
    internal static string get_FailedToGetLargerSpan();
    internal static string get_FoundInvalidCharacter();
    internal static string get_InvalidCast();
    internal static string get_InvalidCharacterAfterEscapeWithinString();
    internal static string get_InvalidCharacterWithinString();
    internal static string get_InvalidEndOfJsonNonPrimitive();
    internal static string get_InvalidHexCharacterWithinString();
    internal static string get_JsonDocumentDoesNotSupportComments();
    internal static string get_JsonElementHasWrongType();
    internal static string get_MaxDepthMustBePositive();
    internal static string get_CommentHandlingMustBeValid();
    internal static string get_MismatchedObjectArray();
    internal static string get_CannotWriteEndAfterProperty();
    internal static string get_ObjectDepthTooLarge();
    internal static string get_PropertyNameTooLarge();
    internal static string get_FormatDecimal();
    internal static string get_FormatDouble();
    internal static string get_FormatInt32();
    internal static string get_FormatInt64();
    internal static string get_FormatSingle();
    internal static string get_FormatUInt32();
    internal static string get_FormatUInt64();
    internal static string get_RequiredDigitNotFoundAfterDecimal();
    internal static string get_RequiredDigitNotFoundAfterSign();
    internal static string get_RequiredDigitNotFoundEndOfData();
    internal static string get_SpecialNumberValuesNotSupported();
    internal static string get_ValueTooLarge();
    internal static string get_ZeroDepthAtEnd();
    internal static string get_DeserializeUnableToConvertValue();
    internal static string get_DeserializeWrongType();
    internal static string get_SerializationInvalidBufferSize();
    internal static string get_BufferWriterAdvancedTooFar();
    internal static string get_InvalidComparison();
    internal static string get_FormatDateTime();
    internal static string get_FormatDateTimeOffset();
    internal static string get_FormatTimeSpan();
    internal static string get_FormatGuid();
    internal static string get_ExpectedStartOfPropertyOrValueAfterComment();
    internal static string get_TrailingCommaNotAllowedBeforeArrayEnd();
    internal static string get_TrailingCommaNotAllowedBeforeObjectEnd();
    internal static string get_SerializerOptionsImmutable();
    internal static string get_StreamNotWritable();
    internal static string get_CannotWriteCommentWithEmbeddedDelimiter();
    internal static string get_SerializerPropertyNameConflict();
    internal static string get_SerializerPropertyNameNull();
    internal static string get_SerializationDataExtensionPropertyInvalid();
    internal static string get_SerializationDuplicateTypeAttribute();
    internal static string get_SerializationNotSupportedType();
    internal static string get_TypeRequiresAsyncSerialization();
    internal static string get_InvalidCharacterAtStartOfComment();
    internal static string get_UnexpectedEndOfDataWhileReadingComment();
    internal static string get_CannotSkip();
    internal static string get_NotEnoughData();
    internal static string get_UnexpectedEndOfLineSeparator();
    internal static string get_JsonSerializerDoesNotSupportComments();
    internal static string get_DeserializeNoConstructor();
    internal static string get_DeserializePolymorphicInterface();
    internal static string get_SerializationConverterOnAttributeNotCompatible();
    internal static string get_SerializationConverterOnAttributeInvalid();
    internal static string get_SerializationConverterRead();
    internal static string get_SerializationConverterNotCompatible();
    internal static string get_SerializationConverterWrite();
    internal static string get_NamingPolicyReturnNull();
    internal static string get_SerializationDuplicateAttribute();
    internal static string get_SerializeUnableToSerialize();
    internal static string get_FormatByte();
    internal static string get_FormatInt16();
    internal static string get_FormatSByte();
    internal static string get_FormatUInt16();
    internal static string get_SerializerCycleDetected();
    internal static string get_InvalidLeadingZeroInNumber();
    internal static string get_MetadataCannotParsePreservedObjectToImmutable();
    internal static string get_MetadataDuplicateIdFound();
    internal static string get_MetadataIdIsNotFirstProperty();
    internal static string get_MetadataInvalidReferenceToValueType();
    internal static string get_MetadataInvalidTokenAfterValues();
    internal static string get_MetadataPreservedArrayFailed();
    internal static string get_MetadataPreservedArrayInvalidProperty();
    internal static string get_MetadataPreservedArrayPropertyNotFound();
    internal static string get_MetadataReferenceCannotContainOtherProperties();
    internal static string get_MetadataReferenceNotFound();
    internal static string get_MetadataValueWasNotString();
    internal static string get_MetadataInvalidPropertyWithLeadingDollarSign();
    internal static string get_MultipleMembersBindWithConstructorParameter();
    internal static string get_ConstructorParamIncompleteBinding();
    internal static string get_ConstructorMaxOf64Parameters();
    internal static string get_ObjectWithParameterizedCtorRefMetadataNotHonored();
    internal static string get_SerializerConverterFactoryReturnsNull();
    internal static string get_SerializationNotSupportedParentType();
    internal static string get_ExtensionDataCannotBindToCtorParam();
    internal static string get_BufferMaximumSizeExceeded();
    internal static string get_CannotSerializeInvalidType();
    internal static string get_SerializeTypeInstanceNotSupported();
    internal static string get_JsonIncludeOnNonPublicInvalid();
    internal static string get_CannotSerializeInvalidMember();
    internal static string get_CannotPopulateCollection();
    internal static string get_DefaultIgnoreConditionAlreadySpecified();
    internal static string get_DefaultIgnoreConditionInvalid();
    internal static string get_FormatBoolean();
    internal static string get_DictionaryKeyTypeNotSupported();
    internal static string get_IgnoreConditionOnValueTypeInvalid();
    internal static string get_NumberHandlingOnPropertyInvalid();
    internal static string get_ConverterCanConvertMultipleTypes();
    internal static string get_MetadataReferenceOfTypeCannotBeAssignedToType();
    internal static string get_DeserializeUnableToAssignValue();
    internal static string get_DeserializeUnableToAssignNull();
    internal static string get_SerializerConverterFactoryReturnsJsonConverterFactory();
    internal static string get_NodeDynamicObjectResultNotAssignable();
    internal static string get_NodeElementWrongType();
    internal static string get_NodeElementCannotBeObjectOrArray();
    internal static string get_NodeAlreadyHasParent();
    internal static string get_NodeCycleDetected();
    internal static string get_NodeUnableToConvert();
    internal static string get_NodeUnableToConvertElement();
    internal static string get_NodeValueNotAllowed();
    internal static string get_NodeWrongType();
    internal static string get_NodeDuplicateKey();
    internal static string get_SerializerContextOptionsImmutable();
    internal static string get_OptionsAlreadyBoundToContext();
    internal static string get_InitializeTypeInfoAsObjectInvalid();
    internal static string get_ConverterForPropertyMustBeValid();
    internal static string get_BuiltInConvertersNotRooted();
    internal static string get_NoMetadataForType();
    internal static string get_NodeCollectionIsReadOnly();
    internal static string get_NodeArrayIndexNegative();
    internal static string get_NodeArrayTooSmall();
    internal static string get_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
    internal static string get_MetadataInitFuncsNull();
    internal static string get_NoMetadataForTypeProperties();
    internal static string get_NoDefaultOptionsForContext();
    internal static string get_FieldCannotBeVirtual();
    internal static string get_MissingFSharpCoreMember();
    internal static string get_FSharpDiscriminatedUnionsNotSupported();
    internal static string get_NoMetadataForTypeCtorParams();
}
internal class System.Text.Json.Arguments`4 : object {
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
}
internal class System.Text.Json.ArgumentState : object {
    public object Arguments;
    public ValueTuple`5[] FoundProperties;
    public ValueTuple`3[] FoundPropertiesAsync;
    public int FoundPropertyCount;
    public JsonParameterInfo JsonParameterInfo;
    public int ParameterIndex;
    public List`1<ParameterRef> ParameterRefCache;
    public bool FoundKey;
    public bool FoundValue;
}
internal class System.Text.Json.BitStack : ValueType {
    private static int AllocationFreeMaxDepth;
    private static int DefaultInitialArraySize;
    private Int32[] _array;
    private ulong _allocationFreeContainer;
    private int _currentDepth;
    public int CurrentDepth { get; }
    public int get_CurrentDepth();
    public void PushTrue();
    public void PushFalse();
    private void PushToArray(bool value);
    public bool Pop();
    private bool PopFromArray();
    private void DoubleArray(int minSize);
    public void SetFirstBit();
    public void ResetFirstBit();
    private static int Div32Rem(int number, Int32& remainder);
}
internal enum System.Text.Json.ConsumeNumberResult : Enum {
    public byte value__;
    public static ConsumeNumberResult Success;
    public static ConsumeNumberResult OperationIncomplete;
    public static ConsumeNumberResult NeedMoreData;
}
internal enum System.Text.Json.ConsumeTokenResult : Enum {
    public byte value__;
    public static ConsumeTokenResult Success;
    public static ConsumeTokenResult NotEnoughDataRollBackState;
    public static ConsumeTokenResult IncompleteNoRollBackNecessary;
}
internal enum System.Text.Json.ConverterStrategy : Enum {
    public byte value__;
    public static ConverterStrategy None;
    public static ConverterStrategy Object;
    public static ConverterStrategy Value;
    public static ConverterStrategy Enumerable;
    public static ConverterStrategy Dictionary;
}
internal enum System.Text.Json.DataType : Enum {
    public int value__;
    public static DataType Boolean;
    public static DataType DateTime;
    public static DataType DateTimeOffset;
    public static DataType TimeSpan;
    public static DataType Base64String;
    public static DataType Guid;
}
internal enum System.Text.Json.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArrayDepthTooLarge;
    public static ExceptionResource EndOfCommentNotFound;
    public static ExceptionResource EndOfStringNotFound;
    public static ExceptionResource RequiredDigitNotFoundAfterDecimal;
    public static ExceptionResource RequiredDigitNotFoundAfterSign;
    public static ExceptionResource RequiredDigitNotFoundEndOfData;
    public static ExceptionResource ExpectedEndAfterSingleJson;
    public static ExceptionResource ExpectedEndOfDigitNotFound;
    public static ExceptionResource ExpectedFalse;
    public static ExceptionResource ExpectedNextDigitEValueNotFound;
    public static ExceptionResource ExpectedNull;
    public static ExceptionResource ExpectedSeparatorAfterPropertyNameNotFound;
    public static ExceptionResource ExpectedStartOfPropertyNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueAfterComment;
    public static ExceptionResource ExpectedStartOfValueNotFound;
    public static ExceptionResource ExpectedTrue;
    public static ExceptionResource ExpectedValueAfterPropertyNameNotFound;
    public static ExceptionResource FoundInvalidCharacter;
    public static ExceptionResource InvalidCharacterWithinString;
    public static ExceptionResource InvalidCharacterAfterEscapeWithinString;
    public static ExceptionResource InvalidHexCharacterWithinString;
    public static ExceptionResource InvalidEndOfJsonNonPrimitive;
    public static ExceptionResource MismatchedObjectArray;
    public static ExceptionResource ObjectDepthTooLarge;
    public static ExceptionResource ZeroDepthAtEnd;
    public static ExceptionResource DepthTooLarge;
    public static ExceptionResource CannotStartObjectArrayWithoutProperty;
    public static ExceptionResource CannotStartObjectArrayAfterPrimitiveOrClose;
    public static ExceptionResource CannotWriteValueWithinObject;
    public static ExceptionResource CannotWriteValueAfterPrimitiveOrClose;
    public static ExceptionResource CannotWritePropertyWithinArray;
    public static ExceptionResource ExpectedJsonTokens;
    public static ExceptionResource TrailingCommaNotAllowedBeforeArrayEnd;
    public static ExceptionResource TrailingCommaNotAllowedBeforeObjectEnd;
    public static ExceptionResource InvalidCharacterAtStartOfComment;
    public static ExceptionResource UnexpectedEndOfDataWhileReadingComment;
    public static ExceptionResource UnexpectedEndOfLineSeparator;
    public static ExceptionResource ExpectedOneCompleteToken;
    public static ExceptionResource NotEnoughData;
    public static ExceptionResource InvalidLeadingZeroInNumber;
}
internal class System.Text.Json.JsonCamelCaseNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
    private static void FixCasing(Span`1<char> chars);
}
public enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
internal static class System.Text.Json.JsonConstants : object {
    public static int MaxParameterCount;
    public static byte OpenBrace;
    public static byte CloseBrace;
    public static byte OpenBracket;
    public static byte CloseBracket;
    public static byte Space;
    public static byte CarriageReturn;
    public static byte LineFeed;
    public static byte Tab;
    public static byte ListSeparator;
    public static byte KeyValueSeperator;
    public static byte Quote;
    public static byte BackSlash;
    public static byte Slash;
    public static byte BackSpace;
    public static byte FormFeed;
    public static byte Asterisk;
    public static byte Colon;
    public static byte Period;
    public static byte Plus;
    public static byte Hyphen;
    public static byte UtcOffsetToken;
    public static byte TimePrefix;
    public static byte StartingByteOfNonStandardSeparator;
    public static int SpacesPerIndent;
    public static int MaxWriterDepth;
    public static int RemoveFlagsBitMask;
    public static int StackallocByteThreshold;
    public static int StackallocCharThreshold;
    public static int MaxExpansionFactorWhileEscaping;
    public static int MaxExpansionFactorWhileTranscoding;
    public static long ArrayPoolMaxSizeBeforeUsingNormalAlloc;
    public static int MaxUtf16RawValueLength;
    public static int MaxEscapedTokenSize;
    public static int MaxUnescapedTokenSize;
    public static int MaxBase64ValueTokenSize;
    public static int MaxCharacterTokenSize;
    public static int MaximumFormatBooleanLength;
    public static int MaximumFormatInt64Length;
    public static int MaximumFormatUInt64Length;
    public static int MaximumFormatDoubleLength;
    public static int MaximumFormatSingleLength;
    public static int MaximumFormatDecimalLength;
    public static int MaximumFormatGuidLength;
    public static int MaximumEscapedGuidLength;
    public static int MaximumFormatDateTimeLength;
    public static int MaximumFormatDateTimeOffsetLength;
    public static int MaxDateTimeUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static int DateTimeParseNumFractionDigits;
    public static int MaximumDateTimeOffsetParseLength;
    public static int MinimumDateTimeParseLength;
    public static int MaximumEscapedDateTimeOffsetParseLength;
    public static int MaximumLiteralLength;
    public static char HighSurrogateStart;
    public static char HighSurrogateEnd;
    public static char LowSurrogateStart;
    public static char LowSurrogateEnd;
    public static int UnicodePlane01StartValue;
    public static int HighSurrogateStartValue;
    public static int HighSurrogateEndValue;
    public static int LowSurrogateStartValue;
    public static int LowSurrogateEndValue;
    public static int BitShiftBy10;
    public static int UnboxedParameterCountThreshold;
    public static ReadOnlySpan`1<byte> Utf8Bom { get; }
    public static ReadOnlySpan`1<byte> TrueValue { get; }
    public static ReadOnlySpan`1<byte> FalseValue { get; }
    public static ReadOnlySpan`1<byte> NullValue { get; }
    public static ReadOnlySpan`1<byte> NaNValue { get; }
    public static ReadOnlySpan`1<byte> PositiveInfinityValue { get; }
    public static ReadOnlySpan`1<byte> NegativeInfinityValue { get; }
    public static ReadOnlySpan`1<byte> Delimiters { get; }
    public static ReadOnlySpan`1<byte> EscapableChars { get; }
    public static ReadOnlySpan`1<byte> get_Utf8Bom();
    public static ReadOnlySpan`1<byte> get_TrueValue();
    public static ReadOnlySpan`1<byte> get_FalseValue();
    public static ReadOnlySpan`1<byte> get_NullValue();
    public static ReadOnlySpan`1<byte> get_NaNValue();
    public static ReadOnlySpan`1<byte> get_PositiveInfinityValue();
    public static ReadOnlySpan`1<byte> get_NegativeInfinityValue();
    public static ReadOnlySpan`1<byte> get_Delimiters();
    public static ReadOnlySpan`1<byte> get_EscapableChars();
}
public class System.Text.Json.JsonDocument : object {
    private ReadOnlyMemory`1<byte> _utf8Json;
    private MetadataDb _parsedData;
    private Byte[] _extraRentedArrayPoolBytes;
    private bool _hasExtraRentedArrayPoolBytes;
    private PooledByteBufferWriter _extraPooledByteBufferWriter;
    private bool _hasExtraPooledByteBufferWriter;
    private ValueTuple`2<int, string> _lastIndexAndString;
    [CompilerGeneratedAttribute]
private bool <IsDisposable>k__BackingField;
    private static JsonDocument s_nullLiteral;
    private static JsonDocument s_trueLiteral;
    private static JsonDocument s_falseLiteral;
    private static int UnseekableStreamInitialRentSize;
    internal bool IsDisposable { get; }
    public JsonElement RootElement { get; }
    private JsonDocument(ReadOnlyMemory`1<byte> utf8Json, MetadataDb parsedData, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter, bool isDisposable);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposable();
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    internal JsonTokenType GetJsonTokenType(int index);
    internal int GetArrayLength(int index);
    internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex);
    internal int GetEndIndex(int index, bool includeEndElement);
    internal ReadOnlyMemory`1<byte> GetRootRawValue();
    internal ReadOnlyMemory`1<byte> GetRawValue(int index, bool includeQuotes);
    private ReadOnlyMemory`1<byte> GetPropertyRawValue(int valueIndex);
    internal string GetString(int index, JsonTokenType expectedType);
    internal bool TextEquals(int index, ReadOnlySpan`1<char> otherText, bool isPropertyName);
    internal bool TextEquals(int index, ReadOnlySpan`1<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape);
    internal string GetNameOfPropertyValue(int index);
    internal bool TryGetValue(int index, Byte[]& value);
    internal bool TryGetValue(int index, SByte& value);
    internal bool TryGetValue(int index, Byte& value);
    internal bool TryGetValue(int index, Int16& value);
    internal bool TryGetValue(int index, UInt16& value);
    internal bool TryGetValue(int index, Int32& value);
    internal bool TryGetValue(int index, UInt32& value);
    internal bool TryGetValue(int index, Int64& value);
    internal bool TryGetValue(int index, UInt64& value);
    internal bool TryGetValue(int index, Double& value);
    internal bool TryGetValue(int index, Single& value);
    internal bool TryGetValue(int index, Decimal& value);
    internal bool TryGetValue(int index, DateTime& value);
    internal bool TryGetValue(int index, DateTimeOffset& value);
    internal bool TryGetValue(int index, Guid& value);
    internal string GetRawValueAsString(int index);
    internal string GetPropertyRawValueAsString(int valueIndex);
    internal JsonElement CloneElement(int index);
    internal void WriteElementTo(int index, Utf8JsonWriter writer);
    private void WriteComplexElement(int index, Utf8JsonWriter writer);
    private ReadOnlySpan`1<byte> UnescapeString(DbRow& row, ArraySegment`1& rented);
    private static void ClearAndReturn(ArraySegment`1<byte> rented);
    private void WritePropertyName(DbRow& row, Utf8JsonWriter writer);
    private void WriteString(DbRow& row, Utf8JsonWriter writer);
    private static void Parse(ReadOnlySpan`1<byte> utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack);
    private void CheckNotDisposed();
    private void CheckExpectedType(JsonTokenType expected, JsonTokenType actual);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseRented(PooledByteBufferWriter utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(string json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCore>d__68")]
private static Task`1<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(string json, JsonDocumentOptions options);
    [NullableContextAttribute("2")]
public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    [NullableContextAttribute("1")]
public static JsonDocument ParseValue(Utf8JsonReader& reader);
    internal static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document, bool shouldThrow, bool useArrayPools);
    private static JsonDocument CreateForLiteral(JsonTokenType tokenType);
    private static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter);
    private static JsonDocument ParseUnrented(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, JsonTokenType tokenType);
    private static ArraySegment`1<byte> ReadToEnd(Stream stream);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ReadToEndAsync>d__79")]
private static ValueTask`1<ArraySegment`1<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<char> propertyName, JsonElement& value);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    [CompilerGeneratedAttribute]
internal static JsonDocument <CreateForLiteral>g__Create|75_0(Byte[] utf8Json, <>c__DisplayClass75_0& );
}
public class System.Text.Json.JsonDocumentOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    internal JsonReaderOptions GetReaderOptions();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonElement : ValueType {
    private JsonDocument _parent;
    private int _idx;
    [DebuggerBrowsableAttribute("0")]
private JsonTokenType TokenType { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement Item { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonElement(JsonDocument parent, int idx);
    private JsonTokenType get_TokenType();
    public JsonValueKind get_ValueKind();
    public JsonElement get_Item(int index);
    public int GetArrayLength();
    [NullableContextAttribute("1")]
public JsonElement GetProperty(string propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public bool TryGetProperty(string propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool GetBoolean();
    [NullableContextAttribute("2")]
public string GetString();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public bool TryGetByte(Byte& value);
    public byte GetByte();
    public bool TryGetInt16(Int16& value);
    public short GetInt16();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    public bool TryGetInt32(Int32& value);
    public int GetInt32();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    public bool TryGetInt64(Int64& value);
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool TryGetDouble(Double& value);
    public double GetDouble();
    public bool TryGetSingle(Single& value);
    public float GetSingle();
    public bool TryGetDecimal(Decimal& value);
    public decimal GetDecimal();
    public bool TryGetDateTime(DateTime& value);
    public DateTime GetDateTime();
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public DateTimeOffset GetDateTimeOffset();
    public bool TryGetGuid(Guid& value);
    public Guid GetGuid();
    internal string GetPropertyName();
    [NullableContextAttribute("1")]
public string GetRawText();
    internal ReadOnlyMemory`1<byte> GetRawValue();
    internal string GetPropertyRawText();
    [NullableContextAttribute("2")]
public bool ValueEquals(string text);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    internal bool TextEqualsHelper(ReadOnlySpan`1<byte> utf8Text, bool isPropertyName, bool shouldUnescape);
    internal bool TextEqualsHelper(ReadOnlySpan`1<char> text, bool isPropertyName);
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public JsonElement Clone();
    private void CheckValidInstance();
    private string get_DebuggerDisplay();
    public static JsonElement ParseValue(Utf8JsonReader& reader);
    internal static JsonElement ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(string json, JsonDocumentOptions options);
    public static bool TryParseValue(Utf8JsonReader& reader, Nullable`1& element);
}
[IsReadOnlyAttribute]
public class System.Text.Json.JsonEncodedText : ValueType {
    internal Byte[] _utf8Value;
    internal string _value;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    private JsonEncodedText(Byte[] utf8Value);
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    [NullableContextAttribute("1")]
public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static JsonEncodedText EncodeHelper(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public sealed virtual bool Equals(JsonEncodedText other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonException : Exception {
    internal string _message;
    [CompilerGeneratedAttribute]
private bool <AppendPathInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytePositionInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    internal bool AppendPathInformation { get; internal set; }
    public Nullable`1<long> LineNumber { get; internal set; }
    public Nullable`1<long> BytePositionInLine { get; internal set; }
    public string Path { get; internal set; }
    [NullableAttribute("1")]
public string Message { get; }
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, Exception innerException);
    public JsonException(string message);
    [NullableContextAttribute("1")]
protected JsonException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal bool get_AppendPathInformation();
    [CompilerGeneratedAttribute]
internal void set_AppendPathInformation(bool value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytePositionInLine();
    [CompilerGeneratedAttribute]
internal void set_BytePositionInLine(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    internal void SetMessage(string message);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonHelpers : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static JsonHelpers();
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey& key, TValue& value);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> GetSpan(Utf8JsonReader& reader);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound);
    public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound);
    public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound);
    public static bool IsDigit(byte value);
    [ExtensionAttribute]
public static void ReadWithVerify(Utf8JsonReader& reader);
    public static string Utf8GetString(ReadOnlySpan`1<byte> bytes);
    public static Dictionary`2<TKey, TValue> CreateDictionaryFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public static bool IsFinite(double value);
    public static bool IsFinite(float value);
    public static void ValidateInt32MaxArrayLength(UInt32 length);
    public static string FormatDateTimeOffset(DateTimeOffset value);
    public static string FormatDateTime(DateTime value);
    public static bool TryParseAsISO(ReadOnlySpan`1<char> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<char> source, DateTimeOffset& value);
    public static bool IsValidDateTimeOffsetParseLength(int length);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    private static bool TryParseDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeParseData& parseData);
    private static bool TryGetNextTwoDigits(ReadOnlySpan`1<byte> source, Int32& value);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, DateTimeOffset& value);
    private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, DateTime& value);
    public static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public static Byte[] EscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetPropertyNameSection(ReadOnlySpan`1<byte> utf8Value);
    [CompilerGeneratedAttribute]
internal static bool <TryParseDateTimeOffset>g__ParseOffset|21_0(DateTimeParseData& parseData, ReadOnlySpan`1<byte> offsetData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.JsonNamingPolicy : object {
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <CamelCase>k__BackingField;
    public static JsonNamingPolicy CamelCase { get; }
    private static JsonNamingPolicy();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_CamelCase();
    public abstract virtual string ConvertName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonProperty : ValueType {
    [CompilerGeneratedAttribute]
private JsonElement <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <_name>k__BackingField;
    public JsonElement Value { get; }
    [NullableAttribute("2")]
private string _name { get; }
    public string Name { get; }
    private string DebuggerDisplay { get; }
    internal JsonProperty(JsonElement value, string name);
    [CompilerGeneratedAttribute]
public JsonElement get_Value();
    [CompilerGeneratedAttribute]
private string get__name();
    public string get_Name();
    [NullableContextAttribute("2")]
public bool NameEquals(string text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<char> text);
    internal bool EscapedNameEquals(ReadOnlySpan`1<byte> utf8Text);
    public void WriteTo(Utf8JsonWriter writer);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.JsonPropertyDictionary`1 : object {
    private static int ListToDictionaryThreshold;
    private Dictionary`2<string, T> _propertyDictionary;
    private List`1<KeyValuePair`2<string, T>> _propertyList;
    private StringComparer _stringComparer;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private KeyCollection<T> _keyCollection;
    private ValueCollection<T> _valueCollection;
    public List`1<KeyValuePair`2<string, T>> List { get; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<T> Values { get; }
    public bool IsReadOnly { get; public set; }
    public T Item { get; public set; }
    public JsonPropertyDictionary`1(bool caseInsensitive);
    public JsonPropertyDictionary`1(bool caseInsensitive, int capacity);
    public List`1<KeyValuePair`2<string, T>> get_List();
    public void Add(string propertyName, T value);
    public void Add(KeyValuePair`2<string, T> property);
    public bool TryAdd(string propertyName, T value);
    public void Clear();
    public bool ContainsKey(string propertyName);
    public int get_Count();
    public bool Remove(string propertyName);
    public bool Contains(KeyValuePair`2<string, T> item);
    public void CopyTo(KeyValuePair`2[] array, int index);
    [IteratorStateMachineAttribute("System.Text.Json.JsonPropertyDictionary`1/<GetEnumerator>d__18")]
public IEnumerator`1<KeyValuePair`2<string, T>> GetEnumerator();
    public ICollection`1<string> get_Keys();
    public ICollection`1<T> get_Values();
    public bool TryGetValue(string propertyName, T& value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    public T get_Item(string propertyName);
    public void set_Item(string propertyName, T value);
    public T SetValue(string propertyName, T value, Action assignParent);
    private void AddValue(string propertyName, T value);
    private bool TryAddValue(string propertyName, T value);
    private void CreateDictionaryIfThresholdMet();
    private bool ContainsValue(T value);
    public Nullable`1<KeyValuePair`2<string, T>> FindValue(T value);
    private bool ContainsProperty(string propertyName);
    private int FindValueIndex(string propertyName);
    public bool TryGetPropertyValue(string propertyName, T& value);
    public bool TryRemoveProperty(string propertyName, T& existing);
    public ICollection`1<string> GetKeyCollection();
    public ICollection`1<T> GetValueCollection();
}
internal class System.Text.Json.JsonReaderException : JsonException {
    public JsonReaderException(string message, long lineNumber, long bytePositionInLine);
    private JsonReaderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonReaderHelper : object {
    private static ulong XorPowerOfTwoToHighByte;
    public static UTF8Encoding s_utf8Encoding;
    private static JsonReaderHelper();
    public static ValueTuple`2<int, int> CountNewLines(ReadOnlySpan`1<byte> data);
    [ExtensionAttribute]
internal static JsonValueKind ToValueKind(JsonTokenType tokenType);
    public static bool IsTokenTypePrimitive(JsonTokenType tokenType);
    public static bool IsHexDigit(byte nextByte);
    [ExtensionAttribute]
public static int IndexOfQuoteOrAnyControlOrBackSlash(ReadOnlySpan`1<byte> span);
    private static int IndexOfOrLessThan(Byte& searchSpace, byte value0, byte value1, byte lessThan, int length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    public static bool TryGetEscapedDateTime(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    public static bool TryGetEscapedGuid(ReadOnlySpan`1<byte> source, Guid& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Single& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Double& value);
    public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan`1<byte> utf8Source, int idx, Byte[]& bytes);
    public static string GetUnescapedString(ReadOnlySpan`1<byte> utf8Source, int idx);
    public static ReadOnlySpan`1<byte> GetUnescapedSpan(ReadOnlySpan`1<byte> utf8Source, int idx);
    public static bool UnescapeAndCompare(ReadOnlySpan`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool UnescapeAndCompare(ReadOnlySequence`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool TryDecodeBase64InPlace(Span`1<byte> utf8Unescaped, Byte[]& bytes);
    public static bool TryDecodeBase64(ReadOnlySpan`1<byte> utf8Unescaped, Byte[]& bytes);
    public static string TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped);
    internal static int GetUtf8ByteCount(ReadOnlySpan`1<char> text);
    internal static int GetUtf8FromText(ReadOnlySpan`1<char> text, Span`1<byte> dest);
    internal static string GetTextFromUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
}
public class System.Text.Json.JsonReaderOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
}
public class System.Text.Json.JsonReaderState : ValueType {
    internal long _lineNumber;
    internal long _bytePositionInLine;
    internal bool _inObject;
    internal bool _isNotPrimitive;
    internal bool _stringHasEscaping;
    internal bool _trailingCommaBeforeComment;
    internal JsonTokenType _tokenType;
    internal JsonTokenType _previousTokenType;
    internal JsonReaderOptions _readerOptions;
    internal BitStack _bitStack;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Text.Json.JsonSerializer : object {
    internal static string SerializationUnreferencedCodeMessage;
    internal static Byte[] s_idPropertyName;
    internal static Byte[] s_refPropertyName;
    internal static Byte[] s_valuesPropertyName;
    internal static JsonEncodedText s_metadataId;
    internal static JsonEncodedText s_metadataRef;
    internal static JsonEncodedText s_metadataValues;
    private static float FlushThreshold;
    private static JsonSerializer();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonDocument document, JsonSerializerOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static TValue Deserialize(JsonDocument document, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerContext context);
    private static TValue ReadDocument(JsonDocument document, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonElement element, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonElement element, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerContext context);
    private static TValue ReadUsingMetadata(JsonElement element, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonNode node, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonNode node, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerContext context);
    private static TValue ReadNode(JsonNode node, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonDocument SerializeToDocument(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerOptions options);
    public static JsonDocument SerializeToDocument(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerContext context);
    private static JsonDocument WriteDocumentUsingGeneratedSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    private static JsonDocument WriteDocumentUsingSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonElement SerializeToElement(TValue value, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerOptions options);
    public static JsonElement SerializeToElement(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerContext context);
    private static JsonElement WriteElementUsingGeneratedSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    private static JsonElement WriteElementUsingSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonNode SerializeToNode(TValue value, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerOptions options);
    public static JsonNode SerializeToNode(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerContext context);
    private static JsonNode WriteNodeUsingGeneratedSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    private static JsonNode WriteNodeUsingSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
private static JsonTypeInfo GetTypeInfo(JsonSerializerOptions options, Type runtimeType);
    private static JsonTypeInfo GetTypeInfo(JsonSerializerContext context, Type type);
    internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling);
    internal static bool ResolveMetadataForJsonObject(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal static bool ResolveMetadataForJsonArray(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    private static bool TryReadAheadMetadataAndSetState(Utf8JsonReader& reader, ReadStack& state, StackFrameObjectState nextState);
    internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan`1<byte> propertyName);
    internal static bool TryGetReferenceFromJsonElement(ReadStack& state, JsonElement element, Object& referenceValue);
    private static void ValidateValueIsCorrectType(object value, string referenceId);
    internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan`1<byte> unescapedPropertyName, ReadStack& state, JsonSerializerOptions options, Boolean& useExtensionProperty, bool createExtensionProperty);
    internal static ReadOnlySpan`1<byte> GetPropertyName(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    internal static void CreateDataExtensionProperty(object obj, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options);
    private static TValue ReadCore(JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    private static TValue ReadFromSpan(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1<int> actualByteCount);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(Stream utf8Json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions options);
    public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static TValue Deserialize(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static JsonTypeInfo CreateQueueJsonTypeInfo(JsonConverter queueConverter, JsonSerializerOptions queueOptions);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<ReadAllAsync>d__65`1")]
internal static ValueTask`1<TValue> ReadAllAsync(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    internal static TValue ReadAll(Stream utf8Json, JsonTypeInfo jsonTypeInfo);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<ReadFromStreamAsync>d__67")]
internal static ValueTask`1<ReadBufferState> ReadFromStreamAsync(Stream utf8Json, ReadBufferState bufferState, CancellationToken cancellationToken);
    internal static ReadBufferState ReadFromStream(Stream utf8Json, ReadBufferState bufferState);
    internal static TValue ContinueDeserialize(ReadBufferState& bufferState, JsonReaderState& jsonReaderState, ReadStack& readStack, JsonConverter converter, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
private static TValue ReadAllUsingOptions(Stream utf8Json, Type returnType, JsonSerializerOptions options);
    private static TValue ReadCore(JsonReaderState& readerState, bool isFinalBlock, ReadOnlySpan`1<byte> buffer, JsonSerializerOptions options, ReadStack& state, JsonConverter converterBase);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(string json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerOptions options);
    public static TValue Deserialize(string json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(string json, Type returnType, JsonSerializerContext context);
    public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerContext context);
    private static TValue ReadFromSpan(ReadOnlySpan`1<char> json, JsonTypeInfo jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerContext context);
    private static TValue Read(Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerContext context);
    private static Byte[] WriteBytesUsingGeneratedSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    private static Byte[] WriteBytesUsingSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    internal static MetadataPropertyName WriteReferenceForObject(JsonConverter jsonConverter, object currentValue, WriteStack& state, Utf8JsonWriter writer);
    internal static MetadataPropertyName WriteReferenceForCollection(JsonConverter jsonConverter, object currentValue, WriteStack& state, Utf8JsonWriter writer);
    internal static bool TryWriteReferenceForBoxedStruct(object currentValue, WriteStack& state, Utf8JsonWriter writer);
    private static bool WriteCore(JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state);
    private static void WriteUsingGeneratedSerializer(Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo);
    private static void WriteUsingSerializer(Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo);
    private static Type GetRuntimeType(TValue& value);
    private static Type GetRuntimeTypeAndValidateInputType(object value, Type inputType);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Stream utf8Json, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerContext context);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<WriteStreamAsync>d__112`1")]
private static Task WriteStreamAsync(Stream utf8Json, TValue value, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    private static void WriteStream(Stream utf8Json, TValue& value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static string Serialize(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    public static string Serialize(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static string Serialize(object value, Type inputType, JsonSerializerContext context);
    private static string WriteStringUsingGeneratedSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    private static string WriteStringUsingSerializer(TValue& value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerContext context);
    [AsyncIteratorStateMachineAttribute("System.Text.Json.JsonSerializer/<<DeserializeAsyncEnumerable>g__CreateAsyncEnumerableDeserializer|63_0>d`1")]
[CompilerGeneratedAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal static IAsyncEnumerable`1<TValue> <DeserializeAsyncEnumerable>g__CreateAsyncEnumerableDeserializer|63_0(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
}
public enum System.Text.Json.JsonSerializerDefaults : Enum {
    public int value__;
    public static JsonSerializerDefaults General;
    public static JsonSerializerDefaults Web;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonSerializerOptions : object {
    private static Dictionary`2<Type, JsonConverter> s_defaultSimpleConverters;
    private static JsonConverter[] s_defaultFactoryConverters;
    private ConcurrentDictionary`2<Type, JsonConverter> _converters;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    internal static int BufferSizeDefault;
    internal static JsonSerializerOptions s_defaultOptions;
    private ConcurrentDictionary`2<Type, JsonTypeInfo> _classes;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <_lastClass>k__BackingField;
    internal JsonSerializerContext _context;
    private Func`3<Type, JsonSerializerOptions, JsonTypeInfo> _typeInfoCreationFunc;
    private MemberAccessor _memberAccessorStrategy;
    private JsonNamingPolicy _dictionaryKeyPolicy;
    private JsonNamingPolicy _jsonPropertyNamingPolicy;
    private JsonCommentHandling _readCommentHandling;
    private ReferenceHandler _referenceHandler;
    private JavaScriptEncoder _encoder;
    private JsonIgnoreCondition _defaultIgnoreCondition;
    private JsonNumberHandling _numberHandling;
    private JsonUnknownTypeHandling _unknownTypeHandling;
    private int _defaultBufferSize;
    private int _maxDepth;
    private bool _allowTrailingCommas;
    private bool _haveTypesBeenCreated;
    private bool _ignoreNullValues;
    private bool _ignoreReadOnlyProperties;
    private bool _ignoreReadonlyFields;
    private bool _includeFields;
    private bool _propertyNameCaseInsensitive;
    private bool _writeIndented;
    [CompilerGeneratedAttribute]
private int <EffectiveMaxDepth>k__BackingField;
    internal ReferenceHandlingStrategy ReferenceHandlingStrategy;
    [CompilerGeneratedAttribute]
private bool <IsInitializedForReflectionSerializer>k__BackingField;
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; }
    private JsonTypeInfo _lastClass { get; private set; }
    public bool AllowTrailingCommas { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    [ObsoleteAttribute("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.")]
[EditorBrowsableAttribute("1")]
public bool IgnoreNullValues { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    internal int EffectiveMaxDepth { get; private set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public JsonUnknownTypeHandling UnknownTypeHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public ReferenceHandler ReferenceHandler { get; public set; }
    [NullableAttribute("1")]
internal MemberAccessor MemberAccessorStrategy { get; }
    internal bool IsInitializedForReflectionSerializer { get; internal set; }
    [NullableContextAttribute("1")]
public JsonSerializerOptions(JsonSerializerOptions options);
    public JsonSerializerOptions(JsonSerializerDefaults defaults);
    private static JsonSerializerOptions();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
private void RootBuiltInConverters();
    private static Dictionary`2<Type, JsonConverter> GetDefaultSimpleConverters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    internal JsonConverter DetermineConverter(Type parentClassType, Type runtimePropertyType, MemberInfo memberInfo);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Getting a converter for a type may require reflection which depends on unreferenced code.")]
public JsonConverter GetConverter(Type typeToConvert);
    internal JsonConverter GetConverterInternal(Type typeToConvert);
    private JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, Type classTypeAttributeIsOn, MemberInfo memberInfo);
    internal bool TryGetDefaultSimpleConverter(Type typeToConvert, JsonConverter& converter);
    private static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType, MemberInfo memberInfo);
    internal static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType);
    private static Attribute GetAttributeThatCanHaveMultiple(Type attributeType, Type classType, MemberInfo memberInfo, Object[] attributes);
    [CompilerGeneratedAttribute]
private JsonTypeInfo get__lastClass();
    [CompilerGeneratedAttribute]
private void set__lastClass(JsonTypeInfo value);
    private static void TrackOptionsInstance(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
public void AddContext();
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonNumberHandling get_NumberHandling();
    public void set_NumberHandling(JsonNumberHandling value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_EffectiveMaxDepth();
    [CompilerGeneratedAttribute]
private void set_EffectiveMaxDepth(int value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public JsonUnknownTypeHandling get_UnknownTypeHandling();
    public void set_UnknownTypeHandling(JsonUnknownTypeHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    public ReferenceHandler get_ReferenceHandler();
    public void set_ReferenceHandler(ReferenceHandler value);
    internal MemberAccessor get_MemberAccessorStrategy();
    [CompilerGeneratedAttribute]
internal bool get_IsInitializedForReflectionSerializer();
    [CompilerGeneratedAttribute]
internal void set_IsInitializedForReflectionSerializer(bool value);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal void InitializeForReflectionSerializer();
    internal JsonTypeInfo GetOrAddClass(Type type);
    internal JsonTypeInfo GetClassFromContextOrCreate(Type type);
    internal JsonTypeInfo GetOrAddClassForRootType(Type type);
    internal bool TryGetClass(Type type, JsonTypeInfo& jsonTypeInfo);
    internal bool TypeIsCached(Type type);
    internal void ClearClasses();
    internal JsonDocumentOptions GetDocumentOptions();
    internal JsonNodeOptions GetNodeOptions();
    internal JsonReaderOptions GetReaderOptions();
    internal JsonWriterOptions GetWriterOptions();
    internal void VerifyMutable();
    [CompilerGeneratedAttribute]
internal static void <GetDefaultSimpleConverters>g__Add|4_0(JsonConverter converter, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal static JsonTypeInfo <InitializeForReflectionSerializer>g__CreateJsonTypeInfo|112_0(Type type, JsonSerializerOptions options);
}
public enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
public enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
internal static class System.Text.Json.JsonWriterHelper : object {
    private static StandardFormat s_dateTimeStandardFormat;
    public static int LastAsciiCharacter;
    private static string HexFormatString;
    private static StandardFormat s_hexStandardFormat;
    private static ReadOnlySpan`1<byte> AllowList { get; }
    private static JsonWriterHelper();
    public static void WriteIndentation(Span`1<byte> buffer, int indent);
    public static void ValidateProperty(ReadOnlySpan`1<byte> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<byte> value);
    public static void ValidateBytes(ReadOnlySpan`1<byte> bytes);
    public static void ValidateDouble(double value);
    public static void ValidateSingle(float value);
    public static void ValidateProperty(ReadOnlySpan`1<char> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> bytes);
    internal static void ValidateNumber(ReadOnlySpan`1<byte> utf8FormattedNumber);
    public static void WriteDateTimeTrimmed(Span`1<byte> buffer, DateTime value, Int32& bytesWritten);
    public static void WriteDateTimeOffsetTrimmed(Span`1<byte> buffer, DateTimeOffset value, Int32& bytesWritten);
    public static void TrimDateTimeOffset(Span`1<byte> buffer, Int32& bytesWritten);
    private static ReadOnlySpan`1<byte> get_AllowList();
    private static bool NeedsEscaping(byte value);
    private static bool NeedsEscapingNoBoundsCheck(char value);
    public static int NeedsEscaping(ReadOnlySpan`1<byte> value, JavaScriptEncoder encoder);
    public static int NeedsEscaping(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape);
    private static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextBytes(byte value, Span`1<byte> destination, Int32& written);
    private static bool IsAsciiValue(byte value);
    private static bool IsAsciiValue(char value);
    private static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextChars(char value, Span`1<char> destination, Int32& written);
    public static OperationStatus ToUtf8(ReadOnlySpan`1<byte> utf16Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonWriterOptions : ValueType {
    private int _optionsMask;
    [CompilerGeneratedAttribute]
private JavaScriptEncoder <Encoder>k__BackingField;
    private static int IndentBit;
    private static int SkipValidationBit;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public bool SkipValidation { get; public set; }
    internal bool IndentedOrNotSkipValidation { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JavaScriptEncoder get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
    internal bool get_IndentedOrNotSkipValidation();
}
internal enum System.Text.Json.MetadataPropertyName : Enum {
    public int value__;
    public static MetadataPropertyName NoMetadata;
    public static MetadataPropertyName Values;
    public static MetadataPropertyName Id;
    public static MetadataPropertyName Ref;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonArray[{List.Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonArray/DebugView")]
public class System.Text.Json.Nodes.JsonArray : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private List`1<JsonNode> _list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JsonNode> List { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.IsReadOnly { get; }
    public JsonArray(Nullable`1<JsonNodeOptions> options);
    public JsonArray(JsonNodeOptions options, JsonNode[] items);
    public JsonArray(JsonNode[] items);
    internal JsonArray(JsonElement element, Nullable`1<JsonNodeOptions> options);
    private void InitializeFromArray(JsonNode[] items);
    public static JsonArray Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
public void Add(T value);
    internal List`1<JsonNode> get_List();
    internal JsonNode GetItem(int index);
    internal void SetItem(int index, JsonNode value);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    [NullableContextAttribute("1")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    private void CreateNodes();
    public sealed virtual int get_Count();
    public sealed virtual void Add(JsonNode item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonNode item);
    public sealed virtual int IndexOf(JsonNode item);
    public sealed virtual void Insert(int index, JsonNode item);
    public sealed virtual bool Remove(JsonNode item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.CopyTo(JsonNode[] array, int index);
    public sealed virtual IEnumerator`1<JsonNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.get_IsReadOnly();
    private void DetachParent(JsonNode item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Text.Json.Nodes.JsonNode : object {
    private JsonNode _parent;
    private Nullable`1<JsonNodeOptions> _options;
    public Nullable`1<JsonNodeOptions> Options { get; }
    [NullableAttribute("2")]
public JsonNode Parent { get; internal set; }
    public JsonNode Root { get; }
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    internal JsonNode(Nullable`1<JsonNodeOptions> options);
    public Nullable`1<JsonNodeOptions> get_Options();
    public JsonArray AsArray();
    public JsonObject AsObject();
    public JsonValue AsValue();
    [NullableContextAttribute("2")]
public JsonNode get_Parent();
    internal void set_Parent(JsonNode value);
    public string GetPath();
    internal abstract virtual void GetPath(List`1<string> path, JsonNode child);
    public JsonNode get_Root();
    public virtual T GetValue();
    [NullableContextAttribute("2")]
public sealed virtual JsonNode get_Item(int index);
    [NullableContextAttribute("2")]
public sealed virtual void set_Item(int index, JsonNode value);
    public sealed virtual JsonNode get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JsonNode value);
    internal void AssignParent(JsonNode parent);
    public static JsonNode op_Implicit(bool value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<bool> value);
    public static JsonNode op_Implicit(byte value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<byte> value);
    public static JsonNode op_Implicit(char value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<char> value);
    public static JsonNode op_Implicit(DateTime value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTime> value);
    public static JsonNode op_Implicit(DateTimeOffset value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JsonNode op_Implicit(decimal value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<decimal> value);
    public static JsonNode op_Implicit(double value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<double> value);
    public static JsonNode op_Implicit(Guid value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<Guid> value);
    public static JsonNode op_Implicit(short value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<short> value);
    public static JsonNode op_Implicit(int value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<int> value);
    public static JsonNode op_Implicit(long value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(sbyte value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<sbyte> value);
    public static JsonNode op_Implicit(float value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<float> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ushort value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(UInt32 value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ulong value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ulong> value);
    public static bool op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JsonNode value);
    public static byte op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JsonNode value);
    public static char op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JsonNode value);
    public static DateTime op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JsonNode value);
    public static DateTimeOffset op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JsonNode value);
    public static decimal op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JsonNode value);
    public static double op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JsonNode value);
    public static Guid op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JsonNode value);
    public static short op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JsonNode value);
    public static int op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JsonNode value);
    public static long op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JsonNode value);
    public static float op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static JsonNode Parse(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> nodeOptions);
    public static JsonNode Parse(string json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [NullableContextAttribute("0")]
public static JsonNode Parse(ReadOnlySpan`1<byte> utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public static JsonNode Parse(Stream utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public string ToJsonString(JsonSerializerOptions options);
    public virtual string ToString();
    public abstract virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
public class System.Text.Json.Nodes.JsonNodeOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PropertyNameCaseInsensitive>k__BackingField;
    public bool PropertyNameCaseInsensitive { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PropertyNameCaseInsensitive();
    [CompilerGeneratedAttribute]
public void set_PropertyNameCaseInsensitive(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonObject[{Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonObject/DebugView")]
public class System.Text.Json.Nodes.JsonObject : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private JsonPropertyDictionary`1<JsonNode> _dictionary;
    public int Count { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.IsReadOnly { get; }
    public JsonObject(Nullable`1<JsonNodeOptions> options);
    public JsonObject(IEnumerable`1<KeyValuePair`2<string, JsonNode>> properties, Nullable`1<JsonNodeOptions> options);
    internal JsonObject(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("2")]
public static JsonObject Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    public bool TryGetPropertyValue(string propertyName, JsonNode& jsonNode);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal JsonNode GetItem(string propertyName);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    internal void SetItem(string propertyName, JsonNode value);
    private void DetachParent(JsonNode item);
    public sealed virtual void Add(string propertyName, JsonNode value);
    public sealed virtual void Add(KeyValuePair`2<string, JsonNode> property);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string propertyName);
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string propertyName);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Contains(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonNode>> GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Remove(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Keys();
    private sealed virtual override ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Values();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(string propertyName, JsonNode& jsonNode);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InitializeIfRequired();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Nodes.JsonValue : JsonNode {
    internal static string CreateUnreferencedCodeMessage;
    private protected JsonValue(Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(bool value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<bool> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(byte value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<byte> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(char value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<char> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTime value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTime> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTimeOffset value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTimeOffset> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(decimal value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<decimal> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(double value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<double> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(Guid value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<Guid> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(short value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<short> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(int value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<int> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(long value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<long> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(sbyte value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<sbyte> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(float value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<float> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(string value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ushort value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ushort> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(UInt32 value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<UInt32> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ulong value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ulong> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(JsonElement value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<JsonElement> value, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
public static JsonValue Create(T value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(T value, JsonTypeInfo`1<T> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    public abstract virtual bool TryGetValue(T& value);
    private static void VerifyJsonElementIsNotArrayOrObject(JsonElement& element);
}
[DebuggerDisplayAttribute("{ToJsonString(),nq}")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonValue`1/DebugView")]
internal abstract class System.Text.Json.Nodes.JsonValue`1 : JsonValue {
    public TValue _value;
    public TValue Value { get; }
    public JsonValue`1(TValue value, Nullable`1<JsonNodeOptions> options);
    public TValue get_Value();
    public virtual T GetValue();
    public virtual bool TryGetValue(T& value);
    internal TypeToConvert ConvertJsonElement();
    internal bool TryConvertJsonElement(TypeToConvert& result);
}
internal class System.Text.Json.Nodes.JsonValueNotTrimmable`1 : JsonValue`1<TValue> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public JsonValueNotTrimmable`1(TValue value, Nullable`1<JsonNodeOptions> options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
internal class System.Text.Json.Nodes.JsonValueTrimmable`1 : JsonValue`1<TValue> {
    private JsonTypeInfo`1<TValue> _jsonTypeInfo;
    private JsonConverter`1<TValue> _converter;
    public JsonValueTrimmable`1(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    public JsonValueTrimmable`1(TValue value, JsonConverter`1<TValue> converter, Nullable`1<JsonNodeOptions> options);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
internal enum System.Text.Json.NumericType : Enum {
    public int value__;
    public static NumericType Byte;
    public static NumericType SByte;
    public static NumericType Int16;
    public static NumericType Int32;
    public static NumericType Int64;
    public static NumericType UInt16;
    public static NumericType UInt32;
    public static NumericType UInt64;
    public static NumericType Single;
    public static NumericType Double;
    public static NumericType Decimal;
}
internal class System.Text.Json.PooledByteBufferWriter : object {
    private Byte[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    public ReadOnlyMemory`1<byte> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledByteBufferWriter(int initialCapacity);
    public ReadOnlyMemory`1<byte> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    private void ClearHelper();
    public sealed virtual void Dispose();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal ValueTask WriteToStreamAsync(Stream destination, CancellationToken cancellationToken);
    internal void WriteToStream(Stream destination);
    private void CheckAndResizeBuffer(int sizeHint);
}
[DebuggerDisplayAttribute("Path:{JsonPath()} Current: ConverterStrategy.{Current.JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy}, {Current.JsonTypeInfo.Type.Name}")]
internal class System.Text.Json.ReadStack : ValueType {
    internal static Char[] SpecialCharacters;
    public ReadStackFrame Current;
    private ReadStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    private List`1<ArgumentState> _ctorArgStateCache;
    public long BytesConsumed;
    public bool ReadAhead;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public bool UseFastPath;
    public bool IsContinuation { get; }
    private static ReadStack();
    public bool get_IsContinuation();
    private void EnsurePushCapacity();
    public void Initialize(Type type, JsonSerializerOptions options, bool supportContinuation);
    internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public string JsonPath();
    private void SetConstructorArgumentState();
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendStackFrame|18_0(StringBuilder sb, ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static int <JsonPath>g__GetCount|18_1(IEnumerable enumerable);
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendPropertyName|18_2(StringBuilder sb, string propertyName);
    [CompilerGeneratedAttribute]
internal static string <JsonPath>g__GetPropertyName|18_3(ReadStackFrame& frame);
}
[DebuggerDisplayAttribute("ConverterStrategy.{JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy}, {JsonTypeInfo.Type.Name}")]
internal class System.Text.Json.ReadStackFrame : ValueType {
    public JsonPropertyInfo JsonPropertyInfo;
    public StackFramePropertyState PropertyState;
    public bool UseExtensionProperty;
    public Byte[] JsonPropertyName;
    public string JsonPropertyNameAsString;
    public object DictionaryKey;
    public int OriginalDepth;
    public JsonTokenType OriginalTokenType;
    public object ReturnValue;
    public JsonTypeInfo JsonTypeInfo;
    public StackFrameObjectState ObjectState;
    public bool ValidateEndTokenOnArray;
    public int PropertyIndex;
    public List`1<PropertyRef> PropertyRefCache;
    public int CtorArgumentStateIndex;
    public ArgumentState CtorArgumentState;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public void EndConstructorParameter();
    public void EndProperty();
    public void EndElement();
    public bool IsProcessingDictionary();
    public bool IsProcessingEnumerable();
}
[ExtensionAttribute]
internal static class System.Text.Json.Reflection.ReflectionExtensions : object {
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    public static string CreateRangeMethodName;
    private static Type s_nullableType;
    private static ReflectionExtensions();
    [ExtensionAttribute]
public static Type GetCompatibleGenericBaseClass(Type type, Type baseType, Type objectType, bool sourceGenType);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
public static Type GetCompatibleGenericInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool IsImmutableDictionaryType(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static bool IsImmutableEnumerableType(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static string GetImmutableDictionaryConstructingTypeName(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static string GetImmutableEnumerableConstructingTypeName(Type type, bool sourceGenType);
    private static bool OpenGenericTypesHaveSamePrefix(Type t1, Type t2);
    private static string GetBaseNameFromGenericType(Type genericType, bool sourceGenType);
    private static string GetBaseNameFromGenericTypeDef(Type genericTypeDef);
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsKeyValuePair(Type type, Type keyValuePairType);
    [ExtensionAttribute]
public static bool TryGetDeserializationConstructor(Type type, bool useDefaultCtorInAnnotatedStructs, ConstructorInfo& deserializationCtor);
    [ExtensionAttribute]
public static object GetDefaultValue(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool IsNullableOfT(Type type);
    [ExtensionAttribute]
public static bool CanBeNull(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFromInternal(Type type, Type from);
    private static bool HasJsonConstructorAttribute(ConstructorInfo constructorInfo);
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.Serialization.ConverterList : object {
    private List`1<JsonConverter> _list;
    private JsonSerializerOptions _options;
    public JsonConverter Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConverterList(JsonSerializerOptions options);
    public ConverterList(JsonSerializerOptions options, ConverterList source);
    public sealed virtual JsonConverter get_Item(int index);
    public sealed virtual void set_Item(int index, JsonConverter value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(JsonConverter item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonConverter item);
    public sealed virtual void CopyTo(JsonConverter[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<JsonConverter> GetEnumerator();
    public sealed virtual int IndexOf(JsonConverter item);
    public sealed virtual void Insert(int index, JsonConverter item);
    public sealed virtual bool Remove(JsonConverter item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Text.Json.Serialization.Converters.ArrayConverter`2 : IEnumerableDefaultConverter`2<TElement[], TElement> {
    internal bool CanHaveIdMetadata { get; }
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TElement[] array, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.BooleanConverter : JsonConverter`1<bool> {
    public virtual bool Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options);
    internal virtual bool ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ByteArrayConverter : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ByteConverter : JsonConverter`1<byte> {
    public virtual byte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options);
    internal virtual byte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual byte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.CharConverter : JsonConverter`1<char> {
    public virtual char Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options);
    internal virtual char ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, char value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentQueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentStackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DateTimeConverter : JsonConverter`1<DateTime> {
    public virtual DateTime Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options);
    internal virtual DateTime ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DateTimeOffsetConverter : JsonConverter`1<DateTimeOffset> {
    public virtual DateTimeOffset Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options);
    internal virtual DateTimeOffset ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DecimalConverter : JsonConverter`1<decimal> {
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
    internal virtual decimal ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual decimal ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling);
}
internal abstract class System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3 : JsonDictionaryConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveIdMetadata { get; }
    internal virtual bool get_CanHaveIdMetadata();
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DoubleConverter : JsonConverter`1<double> {
    public virtual double Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options);
    internal virtual double ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, double value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual double ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.EnumConverter`1 : JsonConverter`1<T> {
    private static TypeCode s_enumTypeCode;
    private static string s_negativeSign;
    private static string ValueSeparator;
    private EnumConverterOptions _converterOptions;
    private JsonNamingPolicy _namingPolicy;
    private ConcurrentDictionary`2<ulong, JsonEncodedText> _nameCache;
    private ConcurrentDictionary`2<ulong, JsonEncodedText> _dictionaryKeyPolicyCache;
    private static int NameCacheSizeSoftLimit;
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions);
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions);
    private static EnumConverter`1();
    public virtual bool CanConvert(Type type);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    private static ulong ConvertToUInt64(object value);
    private static bool IsValidIdentifier(string value);
    private JsonEncodedText FormatEnumValue(string value, JavaScriptEncoder encoder);
    private string FormatEnumValueToString(string value, JavaScriptEncoder encoder);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.EnumConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
    internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions);
    internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:MakeGenericType")]
private static Type GetEnumConverterType(Type enumType);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.Converters.EnumConverterOptions : Enum {
    public int value__;
    public static EnumConverterOptions AllowStrings;
    public static EnumConverterOptions AllowNumbers;
}
internal class System.Text.Json.Serialization.Converters.FSharpListConverter`2 : IEnumerableDefaultConverter`2<TList, TElement> {
    private Func`2<IEnumerable`1<TElement>, TList> _listConstructor;
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpMapConverter`3 : DictionaryDefaultConverter`3<TMap, TKey, TValue> {
    private Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TMap> _mapConstructor;
    internal bool CanHaveIdMetadata { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpOptionConverter`2 : JsonConverter`1<TOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private Func`2<TOption, TElement> _optionValueGetter;
    private Func`2<TElement, TOption> _optionConstructor;
    private ConverterStrategy _converterStrategy;
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options);
    public virtual TOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpSetConverter`2 : IEnumerableDefaultConverter`2<TSet, TElement> {
    private Func`2<IEnumerable`1<TElement>, TSet> _setConstructor;
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpTypeConverterFactory : JsonConverterFactory {
    private ObjectConverterFactory _recordConverterFactory;
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpValueOptionConverter`2 : JsonConverter`1<TValueOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private StructGetter`2<TValueOption, TElement> _optionValueGetter;
    private Func`2<TElement, TValueOption> _optionConstructor;
    private ConverterStrategy _converterStrategy;
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpValueOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TValueOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options);
    public virtual TValueOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.GuidConverter : JsonConverter`1<Guid> {
    public virtual Guid Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options);
    internal virtual Guid ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.IAsyncEnumerableOfTConverter`2 : JsonCollectionConverter`2<TAsyncEnumerable, TElement> {
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TAsyncEnumerable& value);
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ICollectionOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IDictionaryConverter`1 : JsonDictionaryConverter`3<TDictionary, string, object> {
    internal Type RuntimeType { get; }
    protected virtual void Add(string key, Object& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    internal Type RuntimeType { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverterFactory : JsonConverterFactory {
    private static IDictionaryConverter`1<IDictionary> s_converterForIDictionary;
    private static IEnumerableConverter`1<IEnumerable> s_converterForIEnumerable;
    private static IListConverter`1<IList> s_converterForIList;
    private static IEnumerableConverterFactory();
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2 : JsonCollectionConverter`2<TCollection, TElement> {
    internal bool CanHaveIdMetadata { get; }
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IListConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    internal Type RuntimeType { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveIdMetadata { get; }
    protected sealed virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool get_CanHaveIdMetadata();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverterWithReflection`3 : ImmutableDictionaryOfTKeyTValueConverter`3<TCollection, TKey, TValue> {
    internal bool RequiresDynamicMemberAccessors { get; }
    internal virtual bool get_RequiresDynamicMemberAccessors();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanHaveIdMetadata { get; }
    protected sealed virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal sealed virtual bool get_CanHaveIdMetadata();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverterWithReflection`2 : ImmutableEnumerableOfTConverter`2<TCollection, TElement> {
    internal bool RequiresDynamicMemberAccessors { get; }
    internal virtual bool get_RequiresDynamicMemberAccessors();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
}
internal class System.Text.Json.Serialization.Converters.Int16Converter : JsonConverter`1<short> {
    public virtual short Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options);
    internal virtual short ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, short value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual short ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int32Converter : JsonConverter`1<int> {
    public virtual int Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options);
    internal virtual int ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, int value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual int ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int64Converter : JsonConverter`1<long> {
    public virtual long Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options);
    internal virtual long ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, long value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual long ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.IReadOnlyDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.ISetOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.JsonArrayConverter : JsonConverter`1<JsonArray> {
    public virtual void Write(Utf8JsonWriter writer, JsonArray value, JsonSerializerOptions options);
    public virtual JsonArray Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public JsonArray ReadList(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonDocumentConverter : JsonConverter`1<JsonDocument> {
    public virtual JsonDocument Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonElementConverter : JsonConverter`1<JsonElement> {
    public virtual JsonElement Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1 : JsonResumableConverter`1<T> {
    private Func`1<JsonConverter`1<T>> _converterCreator;
    private ConverterStrategy _converterStrategy;
    private JsonConverter`1<T> _converter;
    internal JsonConverter`1<T> Converter { get; }
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    internal bool ConstructorIsParameterized { get; }
    public JsonMetadataServicesConverter`1(Func`1<JsonConverter`1<T>> converterCreator, ConverterStrategy converterStrategy);
    internal JsonConverter`1<T> get_Converter();
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    internal virtual bool get_ConstructorIsParameterized();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverter : JsonConverter`1<JsonNode> {
    private static JsonNodeConverter s_nodeConverter;
    private static JsonArrayConverter s_arrayConverter;
    private static JsonObjectConverter s_objectConverter;
    private static JsonValueConverter s_valueConverter;
    public static JsonNodeConverter Instance { get; }
    public static JsonArrayConverter ArrayConverter { get; }
    public static JsonObjectConverter ObjectConverter { get; }
    public static JsonValueConverter ValueConverter { get; }
    public static JsonNodeConverter get_Instance();
    public static JsonArrayConverter get_ArrayConverter();
    public static JsonObjectConverter get_ObjectConverter();
    public static JsonValueConverter get_ValueConverter();
    public virtual void Write(Utf8JsonWriter writer, JsonNode value, JsonSerializerOptions options);
    public virtual JsonNode Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonNode Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverterFactory : JsonConverterFactory {
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public virtual bool CanConvert(Type typeToConvert);
}
internal class System.Text.Json.Serialization.Converters.JsonObjectConverter : JsonConverter`1<JsonObject> {
    internal virtual object CreateObject(JsonSerializerOptions options);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    public virtual void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options);
    public virtual JsonObject Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public JsonObject ReadObject(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonValueConverter : JsonConverter`1<JsonValue> {
    public virtual void Write(Utf8JsonWriter writer, JsonValue value, JsonSerializerOptions options);
    public virtual JsonValue Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.KeyValuePairConverter`2 : SmallObjectWithParameterizedConstructorConverter`5<KeyValuePair`2<TKey, TValue>, TKey, TValue, object, object> {
    private static string KeyNameCLR;
    private static string ValueNameCLR;
    private static int NumProperties;
    private string _keyName;
    private string _valueName;
    private static ConstructorInfo s_constructorInfo;
    private static KeyValuePairConverter`2();
    internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
    protected virtual void EndRead(ReadStack& state);
    private bool FoundKeyProperty(string propertyName, bool caseInsensitiveMatch);
    private bool FoundValueProperty(string propertyName, bool caseInsensitiveMatch);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverter`1 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected sealed virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected sealed virtual object CreateObject(ReadStackFrame& frame);
    protected sealed virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverterWithReflection`1 : LargeObjectWithParameterizedConstructorConverter`1<T> {
    internal bool RequiresDynamicMemberAccessors { get; }
    internal virtual bool get_RequiresDynamicMemberAccessors();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
}
internal class System.Text.Json.Serialization.Converters.ListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.NullableConverter`1 : JsonConverter`1<Nullable`1<T>> {
    private JsonConverter`1<T> _converter;
    public NullableConverter`1(JsonConverter`1<T> converter);
    public virtual Nullable`1<T> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options);
    internal virtual Nullable`1<T> ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling numberHandling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, Nullable`1<T> value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.NullableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:MakeGenericType")]
private static Type GetNullableConverterType(Type valueTypeToConvert);
}
internal class System.Text.Json.Serialization.Converters.ObjectConverter : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal virtual object ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual object ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ObjectConverterFactory : JsonConverterFactory {
    private bool _useDefaultConstructorInUnannotatedStructs;
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public ObjectConverterFactory(bool useDefaultConstructorInUnannotatedStructs);
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private JsonConverter CreateKeyValuePairConverter(Type type, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1 : JsonObjectConverter`1<T> {
    internal bool CanHaveIdMetadata { get; }
    internal virtual bool get_CanHaveIdMetadata();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    protected static void ReadPropertyValue(object obj, ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty);
    protected static bool ReadAheadPropertyValue(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1 : ObjectDefaultConverter`1<T> {
    internal bool ConstructorIsParameterized { get; }
    internal sealed virtual bool get_ConstructorIsParameterized();
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    protected abstract virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
    protected abstract virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected abstract virtual object CreateObject(ReadStackFrame& frame);
    private void ReadConstructorArguments(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool ReadConstructorArgumentsWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool HandleConstructorArgumentWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private bool HandlePropertyWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    private void BeginRead(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    protected virtual void EndRead(ReadStack& state);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
}
internal class System.Text.Json.Serialization.Converters.QueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    private static QueueOfTConverter`2<TCollection, TElement> _instance;
    internal static QueueOfTConverter`2<TCollection, TElement> Instance { get; }
    internal static QueueOfTConverter`2<TCollection, TElement> get_Instance();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.SByteConverter : JsonConverter`1<sbyte> {
    public virtual sbyte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options);
    internal virtual sbyte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual sbyte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SingleConverter : JsonConverter`1<float> {
    public virtual float Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options);
    internal virtual float ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, float value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual float ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected virtual object CreateObject(ReadStackFrame& frame);
    protected virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private bool TryRead(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo, TArg& arg);
    protected virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    protected sealed virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverterWithReflection`1 : StackOrQueueConverter`1<TCollection> {
    internal bool RequiresDynamicMemberAccessors { get; }
    internal virtual bool get_RequiresDynamicMemberAccessors();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2091:UnrecognizedReflectionPattern")]
internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
}
internal class System.Text.Json.Serialization.Converters.StringConverter : JsonConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
    internal virtual string ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, string value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.TimeSpanConverter : JsonConverter`1<TimeSpan> {
    private static int MinimumTimeSpanFormatLength;
    private static int MaximumTimeSpanFormatLength;
    private static int MaximumEscapedTimeSpanFormatLength;
    public virtual TimeSpan Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UInt16Converter : JsonConverter`1<ushort> {
    public virtual ushort Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options);
    internal virtual ushort ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ushort ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt32Converter : JsonConverter`1<UInt32> {
    public virtual UInt32 Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options);
    internal virtual UInt32 ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual UInt32 ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, UInt32 value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt64Converter : JsonConverter`1<ulong> {
    public virtual ulong Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options);
    internal virtual ulong ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ulong ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverter`1 : JsonConverter`1<T> {
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UriConverter : JsonConverter`1<Uri> {
    public virtual Uri Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.VersionConverter : JsonConverter`1<Version> {
    public virtual Version Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Version value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.IAsyncEnumerableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private static Type GetAsyncEnumerableInterface(Type type);
}
[ExtensionAttribute]
internal static class System.Text.Json.Serialization.IEnumerableConverterFactoryHelpers : object {
    internal static string ImmutableConvertersUnreferencedCodeMessage;
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableEnumerableCreateRangeMethod(Type type, Type elementType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableDictionaryCreateRangeMethod(Type type, Type keyType, Type valueType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableEnumerableConstructingType(Type type);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableDictionaryConstructingType(Type type);
    [ExtensionAttribute]
public static bool IsNonGenericStackOrQueue(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2057:TypeGetType")]
private static Type GetTypeIfExists(string name);
}
internal class System.Text.Json.Serialization.IgnoreReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
}
internal class System.Text.Json.Serialization.IgnoreReferenceResolver : ReferenceResolver {
    private Stack`1<ReferenceEqualsWrapper> _stackForCycleDetection;
    internal virtual void PopReferenceForCycleDetection();
    internal virtual bool ContainsReferenceForCycleDetection(object value);
    internal virtual void PushReferenceForCycleDetection(object value);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
public interface System.Text.Json.Serialization.IJsonOnDeserialized {
    public abstract virtual void OnDeserialized();
}
public interface System.Text.Json.Serialization.IJsonOnDeserializing {
    public abstract virtual void OnDeserializing();
}
public interface System.Text.Json.Serialization.IJsonOnSerialized {
    public abstract virtual void OnSerialized();
}
public interface System.Text.Json.Serialization.IJsonOnSerializing {
    public abstract virtual void OnSerializing();
}
public abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
internal abstract class System.Text.Json.Serialization.JsonCollectionConverter`2 : JsonResumableConverter`1<TCollection> {
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    protected abstract virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected abstract virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected static JsonConverter`1<TElement> GetElementConverter(JsonTypeInfo elementTypeInfo);
    protected static JsonConverter`1<TElement> GetElementConverter(WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    protected abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
[AttributeUsageAttribute("32")]
public class System.Text.Json.Serialization.JsonConstructorAttribute : JsonAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter : object {
    [CompilerGeneratedAttribute]
private bool <CanUseDirectReadOrWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBePolymorphic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalConverter>k__BackingField;
    internal bool IsInternalConverterForNumberType;
    [CompilerGeneratedAttribute]
private bool <ConstructorIsParameterized>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresDynamicMemberAccessors>k__BackingField;
    internal ConverterStrategy ConverterStrategy { get; }
    internal bool CanUseDirectReadOrWrite { get; internal set; }
    internal bool CanHaveIdMetadata { get; }
    internal bool CanBePolymorphic { get; internal set; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    [NullableAttribute("2")]
internal Type KeyType { get; }
    internal bool IsValueType { get; internal set; }
    internal bool IsInternalConverter { get; internal set; }
    internal Type RuntimeType { get; }
    internal Type TypeToConvert { get; }
    internal bool ConstructorIsParameterized { get; }
    [NullableAttribute("2")]
internal ConstructorInfo ConstructorInfo { get; internal set; }
    internal bool RequiresDynamicMemberAccessors { get; }
    public abstract virtual bool CanConvert(Type typeToConvert);
    internal abstract virtual ConverterStrategy get_ConverterStrategy();
    [CompilerGeneratedAttribute]
internal bool get_CanUseDirectReadOrWrite();
    [CompilerGeneratedAttribute]
internal void set_CanUseDirectReadOrWrite(bool value);
    internal virtual bool get_CanHaveIdMetadata();
    [CompilerGeneratedAttribute]
internal bool get_CanBePolymorphic();
    [CompilerGeneratedAttribute]
internal void set_CanBePolymorphic(bool value);
    internal virtual object CreateObject(JsonSerializerOptions options);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal abstract virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal abstract virtual JsonParameterInfo CreateJsonParameterInfo();
    internal abstract virtual Type get_ElementType();
    internal abstract virtual Type get_KeyType();
    [CompilerGeneratedAttribute]
internal bool get_IsValueType();
    [CompilerGeneratedAttribute]
internal void set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInternalConverter();
    [CompilerGeneratedAttribute]
internal void set_IsInternalConverter(bool value);
    internal abstract virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal virtual Type get_RuntimeType();
    internal bool ShouldFlush(Utf8JsonWriter writer, WriteStack& state);
    internal abstract virtual Type get_TypeToConvert();
    internal abstract virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    [CompilerGeneratedAttribute]
internal virtual bool get_ConstructorIsParameterized();
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
internal void set_ConstructorInfo(ConstructorInfo value);
    [CompilerGeneratedAttribute]
internal virtual bool get_RequiresDynamicMemberAccessors();
    internal virtual void Initialize(JsonSerializerOptions options, JsonTypeInfo jsonTypeInfo);
    internal virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal static bool SingleValueReadWithReadAhead(ConverterStrategy converterStrategy, Utf8JsonReader& reader, ReadStack& state);
    internal static bool DoSingleValueReadWithReadAhead(Utf8JsonReader& reader, ReadStack& state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    [CompilerGeneratedAttribute]
private bool <HandleNullOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNullOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeNull>k__BackingField;
    internal ConverterStrategy ConverterStrategy { get; }
    [NullableAttribute("2")]
internal Type KeyType { get; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool HandleNullOnRead { get; private set; }
    internal bool HandleNullOnWrite { get; private set; }
    internal bool CanBeNull { get; }
    internal Type TypeToConvert { get; }
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal T ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal bool WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    public virtual bool CanConvert(Type typeToConvert);
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal sealed virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal sealed virtual JsonParameterInfo CreateJsonParameterInfo();
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnRead();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnWrite();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnWrite(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanBeNull();
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal bool TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    private static bool IsNull(T value);
    internal bool TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual Type get_TypeToConvert();
    internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, Utf8JsonReader& reader);
    internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1436")]
public class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [NullableAttribute("2")]
[DynamicallyAccessedMembersAttribute("1")]
public Type ConverterType { get; private set; }
    public JsonConverterAttribute(Type converterType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    internal ConverterStrategy ConverterStrategy { get; }
    [NullableAttribute("2")]
internal Type KeyType { get; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    internal Type TypeToConvert { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    internal virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal virtual JsonParameterInfo CreateJsonParameterInfo();
    internal sealed virtual Type get_KeyType();
    internal sealed virtual Type get_ElementType();
    internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual Type get_TypeToConvert();
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`1 : JsonResumableConverter`1<TDictionary> {
    internal ConverterStrategy ConverterStrategy { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    protected internal abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`3 : JsonDictionaryConverter`1<TDictionary> {
    protected JsonConverter`1<TKey> _keyConverter;
    protected JsonConverter`1<TValue> _valueConverter;
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    protected abstract virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_ElementType();
    internal virtual Type get_KeyType();
    protected static JsonConverter`1<T> GetConverter(JsonTypeInfo typeInfo);
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TDictionary& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
private TKey <OnTryRead>g__ReadDictionaryKey|10_0(Utf8JsonReader& reader, ReadStack& state, <>c__DisplayClass10_0& );
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <Condition>k__BackingField;
    public JsonIgnoreCondition Condition { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(JsonIgnoreCondition value);
}
public enum System.Text.Json.Serialization.JsonIgnoreCondition : Enum {
    public int value__;
    public static JsonIgnoreCondition Never;
    public static JsonIgnoreCondition Always;
    public static JsonIgnoreCondition WhenWritingDefault;
    public static JsonIgnoreCondition WhenWritingNull;
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIncludeAttribute : JsonAttribute {
}
public enum System.Text.Json.Serialization.JsonKnownNamingPolicy : Enum {
    public int value__;
    public static JsonKnownNamingPolicy Unspecified;
    public static JsonKnownNamingPolicy CamelCase;
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonNumberHandling : Enum {
    public int value__;
    public static JsonNumberHandling Strict;
    public static JsonNumberHandling AllowReadingFromString;
    public static JsonNumberHandling WriteAsString;
    public static JsonNumberHandling AllowNamedFloatingPointLiterals;
}
[AttributeUsageAttribute("396")]
public class System.Text.Json.Serialization.JsonNumberHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonNumberHandling <Handling>k__BackingField;
    public JsonNumberHandling Handling { get; }
    public JsonNumberHandlingAttribute(JsonNumberHandling handling);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_Handling();
}
internal abstract class System.Text.Json.Serialization.JsonObjectConverter`1 : JsonResumableConverter`1<T> {
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    internal sealed virtual Type get_ElementType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyOrderAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; }
    public JsonPropertyOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
}
internal abstract class System.Text.Json.Serialization.JsonResumableConverter`1 : JsonConverter`1<T> {
    public bool HandleNull { get; }
    public sealed virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public sealed virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public sealed virtual bool get_HandleNull();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSerializableAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <TypeInfoPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    public string TypeInfoPropertyName { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    [NullableContextAttribute("1")]
public JsonSerializableAttribute(Type type);
    [CompilerGeneratedAttribute]
public string get_TypeInfoPropertyName();
    [CompilerGeneratedAttribute]
public void set_TypeInfoPropertyName(string value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Text.Json.Serialization.JsonSerializerContext : object {
    private Nullable`1<bool> _canUseSerializationLogic;
    internal JsonSerializerOptions _options;
    public JsonSerializerOptions Options { get; }
    internal bool CanUseSerializationLogic { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    [NullableContextAttribute("2")]
protected JsonSerializerContext(JsonSerializerOptions options);
    public JsonSerializerOptions get_Options();
    internal bool get_CanUseSerializationLogic();
    [NullableContextAttribute("2")]
protected abstract virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type);
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonSourceGenerationMode : Enum {
    public int value__;
    public static JsonSourceGenerationMode Default;
    public static JsonSourceGenerationMode Metadata;
    public static JsonSourceGenerationMode Serialization;
}
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <DefaultIgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFields>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonKnownNamingPolicy <PropertyNamingPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteIndented>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IncludeFields { get; public set; }
    public JsonKnownNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool WriteIndented { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_DefaultIgnoreCondition();
    [CompilerGeneratedAttribute]
public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyFields();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyProperties();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeFields();
    [CompilerGeneratedAttribute]
public void set_IncludeFields(bool value);
    [CompilerGeneratedAttribute]
public JsonKnownNamingPolicy get_PropertyNamingPolicy();
    [CompilerGeneratedAttribute]
public void set_PropertyNamingPolicy(JsonKnownNamingPolicy value);
    [CompilerGeneratedAttribute]
public bool get_WriteIndented();
    [CompilerGeneratedAttribute]
public void set_WriteIndented(bool value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    [NullableContextAttribute("2")]
public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public sealed virtual bool CanConvert(Type typeToConvert);
    public sealed virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
public enum System.Text.Json.Serialization.JsonUnknownTypeHandling : Enum {
    public int value__;
    public static JsonUnknownTypeHandling JsonElement;
    public static JsonUnknownTypeHandling JsonNode;
}
internal class System.Text.Json.Serialization.Metadata.FSharpCoreReflectionProxy : object {
    public static string FSharpCoreUnreferencedCodeMessage;
    private static FSharpCoreReflectionProxy s_singletonInstance;
    private static string CompilationMappingAttributeTypeName;
    private Type _compilationMappingAttributeType;
    private MethodInfo _sourceConstructFlagsGetter;
    private Type _fsharpOptionType;
    private Type _fsharpValueOptionType;
    private Type _fsharpListType;
    private Type _fsharpSetType;
    private Type _fsharpMapType;
    private MethodInfo _fsharpListCtor;
    private MethodInfo _fsharpSetCtor;
    private MethodInfo _fsharpMapCtor;
    public static FSharpCoreReflectionProxy Instance { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public static bool IsFSharpType(Type type);
    public static FSharpCoreReflectionProxy get_Instance();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpKind DetectFSharpKind(Type type);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TFSharpOption, T> CreateFSharpOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public StructGetter`2<TFSharpValueOption, TElement> CreateFSharpValueOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpValueOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpList> CreateFSharpListConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpSet> CreateFSharpSetConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor();
    private Attribute GetFSharpCompilationMappingAttribute(Type type);
    private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute);
    private static Assembly GetFSharpCoreAssembly(Type type);
    private static TDelegate CreateDelegate(MethodInfo methodInfo);
    private TMemberInfo EnsureMemberExists(TMemberInfo memberInfo, string memberName);
}
internal abstract class System.Text.Json.Serialization.Metadata.GenericMethodHolder : object {
    public object DefaultValue { get; }
    public abstract virtual object get_DefaultValue();
    public abstract virtual bool IsDefaultValue(object value);
    public static GenericMethodHolder CreateHolder(Type type);
}
internal class System.Text.Json.Serialization.Metadata.GenericMethodHolder`1 : GenericMethodHolder {
    public object DefaultValue { get; }
    public virtual object get_DefaultValue();
    public virtual bool IsDefaultValue(object value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<TCollection> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <KeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <ElementInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, TCollection> <SerializeHandler>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<TCollection> ObjectCreator { get; public set; }
    public JsonTypeInfo KeyInfo { get; public set; }
    [NullableAttribute("1")]
public JsonTypeInfo ElementInfo { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, TCollection> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<TCollection> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<TCollection> value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_KeyInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyInfo(JsonTypeInfo value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonTypeInfo get_ElementInfo();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ElementInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, TCollection> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, TCollection> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static class System.Text.Json.Serialization.Metadata.JsonMetadataServices : object {
    private static JsonConverter`1<bool> s_booleanConverter;
    private static JsonConverter`1<Byte[]> s_byteArrayConverter;
    private static JsonConverter`1<byte> s_byteConverter;
    private static JsonConverter`1<char> s_charConverter;
    private static JsonConverter`1<DateTime> s_dateTimeConverter;
    private static JsonConverter`1<DateTimeOffset> s_dateTimeOffsetConverter;
    private static JsonConverter`1<decimal> s_decimalConverter;
    private static JsonConverter`1<double> s_doubleConverter;
    private static JsonConverter`1<Guid> s_guidConverter;
    private static JsonConverter`1<short> s_int16Converter;
    private static JsonConverter`1<int> s_int32Converter;
    private static JsonConverter`1<long> s_int64Converter;
    private static JsonConverter`1<JsonArray> s_jsonArrayConverter;
    private static JsonConverter`1<JsonElement> s_jsonElementConverter;
    private static JsonConverter`1<JsonNode> s_jsonNodeConverter;
    private static JsonConverter`1<JsonObject> s_jsonObjectConverter;
    private static JsonConverter`1<JsonValue> s_jsonValueConverter;
    private static JsonConverter`1<object> s_objectConverter;
    private static JsonConverter`1<float> s_singleConverter;
    private static JsonConverter`1<sbyte> s_sbyteConverter;
    private static JsonConverter`1<string> s_stringConverter;
    private static JsonConverter`1<TimeSpan> s_timeSpanConverter;
    private static JsonConverter`1<ushort> s_uint16Converter;
    private static JsonConverter`1<UInt32> s_uint32Converter;
    private static JsonConverter`1<ulong> s_uint64Converter;
    private static JsonConverter`1<Uri> s_uriConverter;
    private static JsonConverter`1<Version> s_versionConverter;
    public static JsonConverter`1<bool> BooleanConverter { get; }
    public static JsonConverter`1<Byte[]> ByteArrayConverter { get; }
    public static JsonConverter`1<byte> ByteConverter { get; }
    public static JsonConverter`1<char> CharConverter { get; }
    public static JsonConverter`1<DateTime> DateTimeConverter { get; }
    public static JsonConverter`1<DateTimeOffset> DateTimeOffsetConverter { get; }
    public static JsonConverter`1<decimal> DecimalConverter { get; }
    public static JsonConverter`1<double> DoubleConverter { get; }
    public static JsonConverter`1<Guid> GuidConverter { get; }
    public static JsonConverter`1<short> Int16Converter { get; }
    public static JsonConverter`1<int> Int32Converter { get; }
    public static JsonConverter`1<long> Int64Converter { get; }
    public static JsonConverter`1<JsonArray> JsonArrayConverter { get; }
    public static JsonConverter`1<JsonElement> JsonElementConverter { get; }
    public static JsonConverter`1<JsonNode> JsonNodeConverter { get; }
    public static JsonConverter`1<JsonObject> JsonObjectConverter { get; }
    public static JsonConverter`1<JsonValue> JsonValueConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<object> ObjectConverter { get; }
    public static JsonConverter`1<float> SingleConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<sbyte> SByteConverter { get; }
    public static JsonConverter`1<string> StringConverter { get; }
    public static JsonConverter`1<TimeSpan> TimeSpanConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ushort> UInt16Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<UInt32> UInt32Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ulong> UInt64Converter { get; }
    public static JsonConverter`1<Uri> UriConverter { get; }
    public static JsonConverter`1<Version> VersionConverter { get; }
    public static JsonTypeInfo`1<TElement[]> CreateArrayInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TElement[]> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIReadOnlyDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<TElement>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateISetInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateICollectionInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    private static JsonTypeInfo`1<TCollection> CreateStackOrQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonConverter`1<bool> get_BooleanConverter();
    public static JsonConverter`1<Byte[]> get_ByteArrayConverter();
    public static JsonConverter`1<byte> get_ByteConverter();
    public static JsonConverter`1<char> get_CharConverter();
    public static JsonConverter`1<DateTime> get_DateTimeConverter();
    public static JsonConverter`1<DateTimeOffset> get_DateTimeOffsetConverter();
    public static JsonConverter`1<decimal> get_DecimalConverter();
    public static JsonConverter`1<double> get_DoubleConverter();
    public static JsonConverter`1<Guid> get_GuidConverter();
    public static JsonConverter`1<short> get_Int16Converter();
    public static JsonConverter`1<int> get_Int32Converter();
    public static JsonConverter`1<long> get_Int64Converter();
    public static JsonConverter`1<JsonArray> get_JsonArrayConverter();
    public static JsonConverter`1<JsonElement> get_JsonElementConverter();
    public static JsonConverter`1<JsonNode> get_JsonNodeConverter();
    public static JsonConverter`1<JsonObject> get_JsonObjectConverter();
    public static JsonConverter`1<JsonValue> get_JsonValueConverter();
    public static JsonConverter`1<object> get_ObjectConverter();
    public static JsonConverter`1<float> get_SingleConverter();
    public static JsonConverter`1<sbyte> get_SByteConverter();
    public static JsonConverter`1<string> get_StringConverter();
    public static JsonConverter`1<TimeSpan> get_TimeSpanConverter();
    public static JsonConverter`1<ushort> get_UInt16Converter();
    public static JsonConverter`1<UInt32> get_UInt32Converter();
    public static JsonConverter`1<ulong> get_UInt64Converter();
    public static JsonConverter`1<Uri> get_UriConverter();
    public static JsonConverter`1<Version> get_VersionConverter();
    public static JsonConverter`1<T> GetUnsupportedTypeConverter();
    public static JsonConverter`1<T> GetEnumConverter(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonTypeInfo`1<T> underlyingTypeInfo);
    public static JsonPropertyInfo CreatePropertyInfo(JsonSerializerOptions options, JsonPropertyInfoValues`1<T> propertyInfo);
    public static JsonTypeInfo`1<T> CreateObjectInfo(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public static JsonTypeInfo`1<T> CreateValueInfo(JsonSerializerOptions options, JsonConverter converter);
    internal static JsonPropertyInfo CreateJsonPropertyInfoForClassInfo(Type type, JsonTypeInfo typeInfo, JsonConverter converter, JsonSerializerOptions options);
}
public class System.Text.Json.Serialization.Metadata.JsonObjectInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<T> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Object[], T> <ObjectWithParameterizedConstructorCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<JsonSerializerContext, JsonPropertyInfo[]> <PropertyMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<JsonParameterInfoValues[]> <ConstructorParameterMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, T> <SerializeHandler>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> ObjectCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], T> ObjectWithParameterizedConstructorCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropertyMetadataInitializer { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<JsonParameterInfoValues[]> ConstructorParameterMetadataInitializer { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<T> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<Object[], T> get_ObjectWithParameterizedConstructorCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectWithParameterizedConstructorCreator(Func`2<Object[], T> value);
    [CompilerGeneratedAttribute]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> get_PropertyMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyMetadataInitializer(Func`2<JsonSerializerContext, JsonPropertyInfo[]> value);
    [CompilerGeneratedAttribute]
public Func`1<JsonParameterInfoValues[]> get_ConstructorParameterMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConstructorParameterMetadataInitializer(Func`1<JsonParameterInfoValues[]> value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
}
internal abstract class System.Text.Json.Serialization.Metadata.JsonParameterInfo : object {
    private JsonTypeInfo _runtimeTypeInfo;
    [CompilerGeneratedAttribute]
private JsonConverter <ConverterBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchingPropertyCanBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    public JsonParameterInfoValues ClrInfo;
    [CompilerGeneratedAttribute]
private Type <RuntimePropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    public JsonConverter ConverterBase { get; private set; }
    private protected bool MatchingPropertyCanBeNull { get; private set; }
    public object DefaultValue { get; private protected set; }
    public bool IgnoreDefaultValuesOnRead { get; private set; }
    public JsonSerializerOptions Options { get; public set; }
    public Byte[] NameAsUtf8Bytes { get; private set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; private set; }
    public JsonTypeInfo RuntimeTypeInfo { get; public set; }
    public Type RuntimePropertyType { get; public set; }
    public bool ShouldDeserialize { get; private set; }
    [CompilerGeneratedAttribute]
public JsonConverter get_ConverterBase();
    [CompilerGeneratedAttribute]
private void set_ConverterBase(JsonConverter value);
    [CompilerGeneratedAttribute]
private protected bool get_MatchingPropertyCanBeNull();
    [CompilerGeneratedAttribute]
private void set_MatchingPropertyCanBeNull(bool value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private protected void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDefaultValuesOnRead();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnRead(bool value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
private void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
private void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public JsonTypeInfo get_RuntimeTypeInfo();
    public void set_RuntimeTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public Type get_RuntimePropertyType();
    [CompilerGeneratedAttribute]
public void set_RuntimePropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
private void set_ShouldDeserialize(bool value);
    public virtual void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
    public static JsonParameterInfo CreateIgnoredParameterPlaceholder(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, bool sourceGenMode);
}
internal class System.Text.Json.Serialization.Metadata.JsonParameterInfo`1 : JsonParameterInfo {
    [CompilerGeneratedAttribute]
private T <TypedDefaultValue>k__BackingField;
    public T TypedDefaultValue { get; private set; }
    [CompilerGeneratedAttribute]
public T get_TypedDefaultValue();
    [CompilerGeneratedAttribute]
private void set_TypedDefaultValue(T value);
    public virtual void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
    private void InitializeDefaultValue(JsonPropertyInfo matchingProperty);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.JsonParameterInfoValues : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public int Position { get; public set; }
    public bool HasDefaultValue { get; public set; }
    [NullableAttribute("2")]
public object DefaultValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParameterType(Type value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Position(int value);
    [CompilerGeneratedAttribute]
public bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasDefaultValue(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DefaultValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("MemberInfo={MemberInfo}")]
[EditorBrowsableAttribute("1")]
public abstract class System.Text.Json.Serialization.Metadata.JsonPropertyInfo : object {
    internal static JsonPropertyInfo s_missingProperty;
    private JsonTypeInfo _runtimeTypeInfo;
    internal ConverterStrategy ConverterStrategy;
    [CompilerGeneratedAttribute]
private Type <DeclaredPropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameAsString>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EscapedNameSection>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimePropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_IsExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropertyTypeCanBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonIgnoreCondition> <IgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    internal JsonConverter ConverterBase { get; internal set; }
    internal Type DeclaredPropertyType { get; internal set; }
    internal bool HasGetter { get; internal set; }
    internal bool HasSetter { get; internal set; }
    internal bool IgnoreDefaultValuesOnRead { get; private set; }
    internal bool IgnoreDefaultValuesOnWrite { get; private set; }
    internal bool IsForTypeInfo { get; internal set; }
    internal string NameAsString { get; internal set; }
    internal Byte[] NameAsUtf8Bytes { get; internal set; }
    internal Byte[] EscapedNameSection { get; internal set; }
    internal JsonSerializerOptions Options { get; internal set; }
    internal int Order { get; internal set; }
    internal Type DeclaringType { get; internal set; }
    [NullableAttribute("2")]
internal MemberInfo MemberInfo { get; private set; }
    internal JsonTypeInfo RuntimeTypeInfo { get; internal set; }
    [NullableAttribute("2")]
internal Type RuntimePropertyType { get; internal set; }
    internal bool ShouldSerialize { get; internal set; }
    internal bool ShouldDeserialize { get; internal set; }
    internal bool IsIgnored { get; internal set; }
    internal bool SrcGen_HasJsonInclude { get; internal set; }
    internal bool SrcGen_IsExtensionData { get; internal set; }
    internal bool SrcGen_IsPublic { get; internal set; }
    internal Nullable`1<JsonNumberHandling> NumberHandling { get; internal set; }
    internal bool PropertyTypeCanBeNull { get; internal set; }
    internal Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; internal set; }
    internal MemberTypes MemberType { get; internal set; }
    [NullableAttribute("2")]
internal string ClrName { get; internal set; }
    internal bool IsVirtual { get; internal set; }
    [NullableAttribute("2")]
internal object DefaultValue { get; }
    private static JsonPropertyInfo();
    internal abstract virtual JsonConverter get_ConverterBase();
    internal abstract virtual void set_ConverterBase(JsonConverter value);
    internal static JsonPropertyInfo GetPropertyPlaceholder();
    internal static JsonPropertyInfo CreateIgnoredPropertyPlaceholder(MemberInfo memberInfo, Type memberType, bool isVirtual, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
internal Type get_DeclaredPropertyType();
    [CompilerGeneratedAttribute]
internal void set_DeclaredPropertyType(Type value);
    internal virtual void GetPolicies(Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> declaringTypeNumberHandling);
    private void DeterminePropertyName();
    internal void DetermineSerializationCapabilities(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    internal void DetermineIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    internal void DetermineNumberHandlingForTypeInfo(Nullable`1<JsonNumberHandling> numberHandling);
    internal void DetermineNumberHandlingForProperty(Nullable`1<JsonNumberHandling> propertyNumberHandling, Nullable`1<JsonNumberHandling> declaringTypeNumberHandling);
    private bool NumberHandingIsApplicable();
    internal static TAttribute GetAttribute(MemberInfo memberInfo);
    internal abstract virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual object GetValueAsObject(object obj);
    [CompilerGeneratedAttribute]
internal bool get_HasGetter();
    [CompilerGeneratedAttribute]
internal void set_HasGetter(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HasSetter();
    [CompilerGeneratedAttribute]
internal void set_HasSetter(bool value);
    internal virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, ConverterStrategy runtimeClassType, MemberInfo memberInfo, bool isVirtual, JsonConverter converter, Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    internal abstract virtual void InitializeForTypeInfo(Type declaredType, JsonTypeInfo runtimeTypeInfo, JsonConverter converter, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreDefaultValuesOnRead();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreDefaultValuesOnWrite();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnWrite(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsForTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_IsForTypeInfo(bool value);
    [CompilerGeneratedAttribute]
internal string get_NameAsString();
    [CompilerGeneratedAttribute]
internal void set_NameAsString(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
internal void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_EscapedNameSection();
    [CompilerGeneratedAttribute]
internal void set_EscapedNameSection(Byte[] value);
    [CompilerGeneratedAttribute]
internal JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
internal void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
internal int get_Order();
    [CompilerGeneratedAttribute]
internal void set_Order(int value);
    internal bool ReadJsonAndAddExtensionProperty(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal bool ReadJsonExtensionDataValue(ReadStack& state, Utf8JsonReader& reader, Object& value);
    [CompilerGeneratedAttribute]
internal Type get_DeclaringType();
    [CompilerGeneratedAttribute]
internal void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
internal MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
    internal JsonTypeInfo get_RuntimeTypeInfo();
    internal void set_RuntimeTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal Type get_RuntimePropertyType();
    [CompilerGeneratedAttribute]
internal void set_RuntimePropertyType(Type value);
    internal abstract virtual void SetExtensionDictionaryAsObject(object obj, object extensionDict);
    [CompilerGeneratedAttribute]
internal bool get_ShouldSerialize();
    [CompilerGeneratedAttribute]
internal void set_ShouldSerialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
internal void set_ShouldDeserialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsIgnored();
    [CompilerGeneratedAttribute]
internal void set_IsIgnored(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_HasJsonInclude();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_IsExtensionData();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_IsExtensionData(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_IsPublic();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_IsPublic(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
internal void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
internal bool get_PropertyTypeCanBeNull();
    [CompilerGeneratedAttribute]
internal void set_PropertyTypeCanBeNull(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    [CompilerGeneratedAttribute]
internal void set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    [CompilerGeneratedAttribute]
internal MemberTypes get_MemberType();
    [CompilerGeneratedAttribute]
internal void set_MemberType(MemberTypes value);
    [CompilerGeneratedAttribute]
internal string get_ClrName();
    [CompilerGeneratedAttribute]
internal void set_ClrName(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsVirtual();
    [CompilerGeneratedAttribute]
internal void set_IsVirtual(bool value);
    internal abstract virtual object get_DefaultValue();
    [CompilerGeneratedAttribute]
private JsonConverter <ReadJsonAndAddExtensionProperty>g__GetDictionaryValueConverter|66_0(Type dictionaryValueType);
}
internal class System.Text.Json.Serialization.Metadata.JsonPropertyInfo`1 : JsonPropertyInfo {
    private bool _converterIsExternalAndPolymorphic;
    private bool _propertyTypeEqualsTypeToConvert;
    [CompilerGeneratedAttribute]
private Func`2<object, T> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, T> <Set>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    internal Func`2<object, T> Get { get; internal set; }
    internal Action`2<object, T> Set { get; internal set; }
    internal object DefaultValue { get; }
    public JsonConverter`1<T> Converter { get; internal set; }
    internal JsonConverter ConverterBase { get; internal set; }
    [CompilerGeneratedAttribute]
internal Func`2<object, T> get_Get();
    [CompilerGeneratedAttribute]
internal void set_Get(Func`2<object, T> value);
    [CompilerGeneratedAttribute]
internal Action`2<object, T> get_Set();
    [CompilerGeneratedAttribute]
internal void set_Set(Action`2<object, T> value);
    internal virtual object get_DefaultValue();
    [CompilerGeneratedAttribute]
public JsonConverter`1<T> get_Converter();
    [CompilerGeneratedAttribute]
internal void set_Converter(JsonConverter`1<T> value);
    internal virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, ConverterStrategy runtimeClassType, MemberInfo memberInfo, bool isVirtual, JsonConverter converter, Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    internal void InitializeForSourceGen(JsonSerializerOptions options, JsonPropertyInfoValues`1<T> propertyInfo);
    internal virtual void InitializeForTypeInfo(Type declaredType, JsonTypeInfo runtimeTypeInfo, JsonConverter converter, JsonSerializerOptions options);
    internal virtual JsonConverter get_ConverterBase();
    internal virtual void set_ConverterBase(JsonConverter value);
    internal virtual object GetValueAsObject(object obj);
    internal virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal virtual void SetExtensionDictionaryAsObject(object obj, object extensionDict);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <PropertyTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, T> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, T> <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonIgnoreCondition> <IgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonPropertyName>k__BackingField;
    public bool IsProperty { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsVirtual { get; public set; }
    public Type DeclaringType { get; public set; }
    public JsonTypeInfo PropertyTypeInfo { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonConverter`1<T> Converter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, T> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, T> Setter { get; public set; }
    public Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; public set; }
    public bool HasJsonInclude { get; public set; }
    public bool IsExtensionData { get; public set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public string PropertyName { get; public set; }
    [NullableAttribute("2")]
public string JsonPropertyName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_PropertyTypeInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonConverter`1<T> get_Converter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Converter(JsonConverter`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<object, T> get_Getter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Getter(Func`2<object, T> value);
    [CompilerGeneratedAttribute]
public Action`2<object, T> get_Setter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Setter(Action`2<object, T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    [CompilerGeneratedAttribute]
public bool get_HasJsonInclude();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsExtensionData(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_JsonPropertyName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_JsonPropertyName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ConverterStrategy.{ConverterStrategy}, {Type.Name}")]
public class System.Text.Json.Serialization.Metadata.JsonTypeInfo : object {
    internal static Type ObjectType;
    private static int PropertyNameKeyLength;
    private static int ParameterNameCountCacheThreshold;
    private static int PropertyNameCountCacheThreshold;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    internal JsonPropertyDictionary`1<JsonParameterInfo> ParameterCache;
    internal JsonPropertyDictionary`1<JsonPropertyInfo> PropertyCache;
    private ParameterRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _parameterRefsSorted;
    private PropertyRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _propertyRefsSorted;
    internal Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropInitFunc;
    internal Func`1<JsonParameterInfoValues[]> CtorParamInitFunc;
    internal static string JsonObjectTypeName;
    [CompilerGeneratedAttribute]
private ConstructorDelegate <CreateObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CreateObjectWithArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AddMethodDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <DataExtensionProperty>k__BackingField;
    private JsonTypeInfo _elementTypeInfo;
    [CompilerGeneratedAttribute]
private bool <HasSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    private JsonTypeInfo _keyTypeInfo;
    [CompilerGeneratedAttribute]
private Type <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <PropertyInfoForTypeInfo>k__BackingField;
    private GenericMethodHolder _genericMethods;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    internal int ParameterCount { get; private set; }
    internal ConstructorDelegate CreateObject { get; internal set; }
    internal object CreateObjectWithArgs { get; internal set; }
    internal object AddMethodDelegate { get; internal set; }
    internal JsonPropertyInfo DataExtensionProperty { get; private set; }
    internal bool HasSerialize { get; internal set; }
    internal JsonTypeInfo ElementTypeInfo { get; internal set; }
    internal Type ElementType { get; internal set; }
    internal JsonTypeInfo KeyTypeInfo { get; internal set; }
    internal Type KeyType { get; internal set; }
    [NullableAttribute("1")]
internal JsonSerializerOptions Options { get; internal set; }
    [NullableAttribute("1")]
internal Type Type { get; private set; }
    [NullableAttribute("1")]
internal JsonPropertyInfo PropertyInfoForTypeInfo { get; internal set; }
    internal bool IsObjectWithParameterizedCtor { get; }
    [NullableAttribute("1")]
internal GenericMethodHolder GenericMethods { get; }
    internal Nullable`1<JsonNumberHandling> NumberHandling { get; internal set; }
    internal JsonTypeInfo(Type type, JsonSerializerOptions options, bool dummy);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal JsonTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal JsonTypeInfo(Type type, JsonConverter converter, Type runtimeType, JsonSerializerOptions options);
    private static JsonTypeInfo();
    [CompilerGeneratedAttribute]
internal int get_ParameterCount();
    [CompilerGeneratedAttribute]
private void set_ParameterCount(int value);
    internal static JsonPropertyInfo AddProperty(MemberInfo memberInfo, Type memberType, Type parentClassType, bool isVirtual, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    internal static JsonPropertyInfo CreateProperty(Type declaredPropertyType, Type runtimePropertyType, MemberInfo memberInfo, Type parentClassType, bool isVirtual, JsonConverter converter, JsonSerializerOptions options, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, Nullable`1<JsonIgnoreCondition> ignoreCondition);
    internal static JsonPropertyInfo CreatePropertyInfoForTypeInfo(Type declaredPropertyType, Type runtimePropertyType, JsonConverter converter, Nullable`1<JsonNumberHandling> numberHandling, JsonSerializerOptions options);
    internal JsonPropertyInfo GetProperty(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    internal JsonParameterInfo GetParameter(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    private static bool IsPropertyRefEqual(PropertyRef& propertyRef, ReadOnlySpan`1<byte> propertyName, ulong key);
    private static bool IsParameterRefEqual(ParameterRef& parameterRef, ReadOnlySpan`1<byte> parameterName, ulong key);
    internal static ulong GetKey(ReadOnlySpan`1<byte> name);
    internal void UpdateSortedPropertyCache(ReadStackFrame& frame);
    internal void UpdateSortedParameterCache(ReadStackFrame& frame);
    internal void InitializePropCache();
    internal void InitializeParameterCache();
    [CompilerGeneratedAttribute]
internal ConstructorDelegate get_CreateObject();
    [CompilerGeneratedAttribute]
internal void set_CreateObject(ConstructorDelegate value);
    [CompilerGeneratedAttribute]
internal object get_CreateObjectWithArgs();
    [CompilerGeneratedAttribute]
internal void set_CreateObjectWithArgs(object value);
    [CompilerGeneratedAttribute]
internal object get_AddMethodDelegate();
    [CompilerGeneratedAttribute]
internal void set_AddMethodDelegate(object value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_DataExtensionProperty();
    [CompilerGeneratedAttribute]
private void set_DataExtensionProperty(JsonPropertyInfo value);
    [CompilerGeneratedAttribute]
internal bool get_HasSerialize();
    [CompilerGeneratedAttribute]
internal void set_HasSerialize(bool value);
    internal JsonTypeInfo get_ElementTypeInfo();
    internal void set_ElementTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal Type get_ElementType();
    [CompilerGeneratedAttribute]
internal void set_ElementType(Type value);
    internal JsonTypeInfo get_KeyTypeInfo();
    internal void set_KeyTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal Type get_KeyType();
    [CompilerGeneratedAttribute]
internal void set_KeyType(Type value);
    [CompilerGeneratedAttribute]
internal JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
internal void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
internal Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_PropertyInfoForTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_PropertyInfoForTypeInfo(JsonPropertyInfo value);
    internal bool get_IsObjectWithParameterizedCtor();
    internal GenericMethodHolder get_GenericMethods();
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
internal void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    private void CacheMember(Type declaringType, Type memberType, MemberInfo memberInfo, bool isVirtual, Nullable`1<JsonNumberHandling> typeNumberHandling, Boolean& propertyOrderSpecified, Dictionary`2& ignoredMembers);
    private void CacheMember(JsonPropertyInfo jsonPropertyInfo, JsonPropertyDictionary`1<JsonPropertyInfo> propertyCache, Dictionary`2& ignoredMembers);
    private void InitializeConstructorParameters(JsonParameterInfoValues[] jsonParameters, bool sourceGenMode);
    private static JsonParameterInfoValues[] GetParameterInfoArray(ParameterInfo[] parameters);
    private static bool PropertyIsOverridenAndIgnored(string currentMemberName, Type currentMemberType, bool currentMemberIsVirtual, Dictionary`2<string, JsonPropertyInfo> ignoredMembers);
    private void ValidateAndAssignDataExtensionProperty(JsonPropertyInfo jsonPropertyInfo);
    private bool IsValidDataExtensionProperty(JsonPropertyInfo jsonPropertyInfo);
    private static JsonParameterInfo CreateConstructorParameter(JsonParameterInfoValues parameterInfo, JsonPropertyInfo jsonPropertyInfo, bool sourceGenMode, JsonSerializerOptions options);
    private static JsonConverter GetConverter(Type type, Type parentClassType, MemberInfo memberInfo, Type& runtimeType, JsonSerializerOptions options);
    private static void ValidateType(Type type, Type parentClassType, MemberInfo memberInfo, JsonSerializerOptions options);
    private static bool IsInvalidForSerialization(Type type);
    private static bool IsByRefLike(Type type);
    private static Nullable`1<JsonNumberHandling> GetNumberHandlingForType(Type type);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1 : JsonTypeInfo {
    private Action`2<Utf8JsonWriter, T> _serialize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; private protected set; }
    internal JsonTypeInfo`1(Type type, JsonSerializerOptions options);
    public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    private protected void set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
}
internal class System.Text.Json.Serialization.Metadata.JsonTypeInfoInternal`1 : JsonTypeInfo`1<T> {
    public JsonTypeInfoInternal`1(JsonSerializerOptions options);
    public JsonTypeInfoInternal`1(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public JsonTypeInfoInternal`1(JsonSerializerOptions options, JsonCollectionInfoValues`1<T> collectionInfo, Func`1<JsonConverter`1<T>> converterCreator, object createObjectWithArgs, object addFunc);
    private void SetCreateObjectFunc(Func`1<T> createObjectFunc);
}
internal abstract class System.Text.Json.Serialization.Metadata.MemberAccessor : object {
    public abstract virtual ConstructorDelegate CreateConstructor(Type classType);
    public abstract virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public abstract virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public abstract virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public abstract virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public abstract virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.ParameterRef : ValueType {
    public ulong Key;
    public JsonParameterInfo Info;
    public Byte[] NameFromJson;
    public ParameterRef(ulong key, JsonParameterInfo info, Byte[] nameFromJson);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.PropertyRef : ValueType {
    public ulong Key;
    public JsonPropertyInfo Info;
    public Byte[] NameFromJson;
    public PropertyRef(ulong key, JsonPropertyInfo info, Byte[] nameFromJson);
}
internal class System.Text.Json.Serialization.Metadata.ReflectionEmitMemberAccessor : MemberAccessor {
    public virtual ConstructorDelegate CreateConstructor(Type type);
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor, Type parameterType1, Type parameterType2, Type parameterType3, Type parameterType4);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    private static DynamicMethod CreateAddMethodDelegate(Type collectionType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static DynamicMethod CreateImmutableEnumerableCreateRangeDelegate(Type collectionType, Type elementType, Type enumerableType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static DynamicMethod CreateImmutableDictionaryCreateRangeDelegate(Type collectionType, Type keyType, Type valueType, Type enumerableType);
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertyGetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertySetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldGetter(FieldInfo fieldInfo, Type runtimeFieldType);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldSetter(FieldInfo fieldInfo, Type runtimeFieldType);
    private static DynamicMethod CreateGetterMethod(string memberName, Type memberType);
    private static DynamicMethod CreateSetterMethod(string memberName, Type memberType);
    private static T CreateDelegate(DynamicMethod method);
}
internal class System.Text.Json.Serialization.Metadata.ReflectionMemberAccessor : MemberAccessor {
    public virtual ConstructorDelegate CreateConstructor(Type type);
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
internal class System.Text.Json.Serialization.PreserveReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
internal class System.Text.Json.Serialization.PreserveReferenceResolver : ReferenceResolver {
    private UInt32 _referenceCount;
    private Dictionary`2<string, object> _referenceIdToObjectMap;
    private Dictionary`2<object, string> _objectToReferenceIdMap;
    public PreserveReferenceResolver(bool writing);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
internal class System.Text.Json.Serialization.ReadBufferState : ValueType {
    public Byte[] Buffer;
    public int BytesInBuffer;
    public int ClearMax;
    public bool IsFirstIteration;
    public bool IsFinalBlock;
    public ReadBufferState(int defaultBufferSize);
    public sealed virtual void Dispose();
}
internal class System.Text.Json.Serialization.ReferenceEqualsWrapper : ValueType {
    private object _object;
    public ReferenceEqualsWrapper(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceEqualsWrapper obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceHandler : object {
    internal ReferenceHandlingStrategy HandlingStrategy;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <Preserve>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <IgnoreCycles>k__BackingField;
    public static ReferenceHandler Preserve { get; }
    public static ReferenceHandler IgnoreCycles { get; }
    private static ReferenceHandler();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_Preserve();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_IgnoreCycles();
    public abstract virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
public class System.Text.Json.Serialization.ReferenceHandler`1 : ReferenceHandler {
    [NullableContextAttribute("1")]
public virtual ReferenceResolver CreateResolver();
}
internal enum System.Text.Json.Serialization.ReferenceHandlingStrategy : Enum {
    public int value__;
    public static ReferenceHandlingStrategy None;
    public static ReferenceHandlingStrategy Preserve;
    public static ReferenceHandlingStrategy IgnoreCycles;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceResolver : object {
    public abstract virtual void AddReference(string referenceId, object value);
    public abstract virtual string GetReference(object value, Boolean& alreadyExists);
    public abstract virtual object ResolveReference(string referenceId);
    internal virtual void PopReferenceForCycleDetection();
    internal virtual void PushReferenceForCycleDetection(object value);
    internal virtual bool ContainsReferenceForCycleDetection(object value);
}
internal enum System.Text.Json.StackFrameObjectState : Enum {
    public byte value__;
    public static StackFrameObjectState None;
    public static StackFrameObjectState StartToken;
    public static StackFrameObjectState ReadAheadNameOrEndObject;
    public static StackFrameObjectState ReadNameOrEndObject;
    public static StackFrameObjectState ReadAheadIdValue;
    public static StackFrameObjectState ReadAheadRefValue;
    public static StackFrameObjectState ReadIdValue;
    public static StackFrameObjectState ReadRefValue;
    public static StackFrameObjectState ReadAheadRefEndObject;
    public static StackFrameObjectState ReadRefEndObject;
    public static StackFrameObjectState ReadAheadValuesName;
    public static StackFrameObjectState ReadValuesName;
    public static StackFrameObjectState ReadAheadValuesStartArray;
    public static StackFrameObjectState ReadValuesStartArray;
    public static StackFrameObjectState PropertyValue;
    public static StackFrameObjectState CreatedObject;
    public static StackFrameObjectState ReadElements;
    public static StackFrameObjectState EndToken;
    public static StackFrameObjectState EndTokenValidation;
}
internal enum System.Text.Json.StackFramePropertyState : Enum {
    public byte value__;
    public static StackFramePropertyState None;
    public static StackFramePropertyState ReadName;
    public static StackFramePropertyState Name;
    public static StackFramePropertyState ReadValue;
    public static StackFramePropertyState ReadValueIsEnd;
    public static StackFramePropertyState TryRead;
}
internal static class System.Text.Json.ThrowHelper : object {
    public static string ExceptionSourceValueToRethrowAsJsonException;
    [DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(UInt32 capacity);
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message);
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName);
    private static ArgumentException GetArgumentException(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message);
    public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueTooLarge(int tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueNotSupported();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NeedLargerSpan();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<byte> propertyName, int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(string message);
    private static InvalidOperationException GetInvalidOperationException(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth);
    private static InvalidOperationException GetInvalidOperationException(int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<char> propertyName, int currentDepth);
    public static InvalidOperationException GetInvalidOperationException_ExpectedArray(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedObject(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedNumber(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedString(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedComment(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_CannotSkipOnPartial();
    private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType);
    private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType);
    [DoesNotReturnAttribute]
public static void ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    public static JsonException GetJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    private static bool IsPrintable(byte value);
    internal static string GetPrintableString(byte value);
    private static string GetResourceString(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, string characters);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidCommentValue();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16();
    public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException);
    public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException);
    public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException);
    public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException(UInt32 capacity);
    private static string GetResourceString(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    public static FormatException GetFormatException();
    public static FormatException GetFormatException(NumericType numericType);
    public static FormatException GetFormatException(DataType dateType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedChar(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_NodeValueNotAllowed(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_NodeArrayTooSmall(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_NodeArrayIndexNegative(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DuplicateKey(string propertyName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeAlreadyHasParent();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeCycleDetected();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray();
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_NodeCollectionIsReadOnly();
    public static NotSupportedException NotSupportedException_NodeCollectionIsReadOnly();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DeserializeWrongType(Type type, object value);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ConstructorMaxOf64Parameters(Type type);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType, JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializerCycleDetected(int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowJsonException(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type type, Type parentClassType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerOptionsImmutable(JsonSerializerContext context);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameNull(Type parentType, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(Type converterType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type parentType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(string memberName, Type declaringType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(string clrPropertyName, Type propertyDeclaringType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(Type runtimePropertyType, JsonConverter jsonConverter);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotHonored(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, JsonReaderException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, Utf8JsonReader& reader, Exception ex);
    public static void AddJsonExceptionInformation(ReadStack& state, Utf8JsonReader& reader, JsonException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(WriteStack& state, Exception ex);
    public static void AddJsonExceptionInformation(WriteStack& state, JsonException ex);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, Type classType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(Type type, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(WriteStack& state, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceNotFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataMissingIdBeforeValues(ReadStack& state, ReadOnlySpan`1<byte> propertyName);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan`1<byte> propertyName, ReadStack& state, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateIdFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayInvalidProperty(ReadStack& state, Type propertyType, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(ReadStack& state, Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert);
    [DoesNotReturnAttribute]
internal static void ThrowUnexpectedMetadataException(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonSerializerOptionsAlreadyBoundToContext();
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_BuiltInConvertersNotRooted(Type type);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_NoMetadataForType(Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForType(Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MetadatInitFuncsNull();
    public static void ThrowInvalidOperationException_NoMetadataForTypeProperties(JsonSerializerContext context, Type type);
    public static void ThrowInvalidOperationException_NoMetadataForTypeCtorParams(JsonSerializerContext context, Type type);
    public static void ThrowInvalidOperationException_NoDefaultOptionsForContext(JsonSerializerContext context, Type type);
    [DoesNotReturnAttribute]
public static void ThrowMissingMemberException_MissingFSharpCoreMember(string missingFsharpCoreMember);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonReader : ValueType {
    private ReadOnlySpan`1<byte> _buffer;
    private bool _isFinalBlock;
    private bool _isInputSequence;
    private long _lineNumber;
    private long _bytePositionInLine;
    private int _consumed;
    private bool _inObject;
    private bool _isNotPrimitive;
    private JsonTokenType _tokenType;
    private JsonTokenType _previousTokenType;
    private JsonReaderOptions _readerOptions;
    private BitStack _bitStack;
    private long _totalConsumed;
    private bool _isLastSegment;
    internal bool _stringHasEscaping;
    private bool _isMultiSegment;
    private bool _trailingCommaBeforeComment;
    private SequencePosition _nextPosition;
    private SequencePosition _currentPosition;
    private ReadOnlySequence`1<byte> _sequence;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<byte> <ValueSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TokenStartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <ValueSequence>k__BackingField;
    private bool IsLastSpan { get; }
    internal ReadOnlySequence`1<byte> OriginalSequence { get; }
    internal ReadOnlySpan`1<byte> OriginalSpan { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; private set; }
    public long BytesConsumed { get; }
    public long TokenStartIndex { get; private set; }
    public int CurrentDepth { get; }
    internal bool IsInArray { get; }
    public JsonTokenType TokenType { get; }
    public bool HasValueSequence { get; private set; }
    public bool IsFinalBlock { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; private set; }
    public SequencePosition Position { get; }
    public JsonReaderState CurrentState { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [NullableAttribute("1")]
private string DebugTokenType { get; }
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    private bool get_IsLastSpan();
    internal ReadOnlySequence`1<byte> get_OriginalSequence();
    internal ReadOnlySpan`1<byte> get_OriginalSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [CompilerGeneratedAttribute]
private void set_ValueSpan(ReadOnlySpan`1<byte> value);
    public long get_BytesConsumed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TokenStartIndex();
    [CompilerGeneratedAttribute]
private void set_TokenStartIndex(long value);
    public int get_CurrentDepth();
    internal bool get_IsInArray();
    public JsonTokenType get_TokenType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValueSequence();
    [CompilerGeneratedAttribute]
private void set_HasValueSequence(bool value);
    public bool get_IsFinalBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [CompilerGeneratedAttribute]
private void set_ValueSequence(ReadOnlySequence`1<byte> value);
    public SequencePosition get_Position();
    public JsonReaderState get_CurrentState();
    public bool Read();
    public void Skip();
    private void SkipHelper();
    public bool TrySkip();
    private bool TrySkipHelper();
    public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("2")]
public bool ValueTextEquals(string text);
    private bool TextEqualsHelper(ReadOnlySpan`1<byte> otherUtf8Text);
    public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    private bool CompareToSequence(ReadOnlySpan`1<byte> other);
    private bool UnescapeAndCompare(ReadOnlySpan`1<byte> other);
    private bool UnescapeSequenceAndCompare(ReadOnlySpan`1<byte> other);
    private static bool IsTokenTypeString(JsonTokenType tokenType);
    private bool MatchNotPossible(int charTextLength);
    private bool MatchNotPossibleSequence(int charTextLength);
    private void StartObject();
    private void EndObject();
    private void StartArray();
    private void EndArray();
    private void UpdateBitStackOnEndToken();
    private bool ReadSingleSegment();
    private bool HasMoreData();
    private bool HasMoreData(ExceptionResource resource);
    private bool ReadFirstToken(byte first);
    private void SkipWhiteSpace();
    private bool ConsumeValue(byte marker);
    private bool ConsumeLiteral(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteral(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private void ThrowInvalidLiteral(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumber();
    private bool ConsumePropertyName();
    private bool ConsumeString();
    private bool ConsumeStringAndValidate(ReadOnlySpan`1<byte> data, int idx);
    private bool ValidateHexDigits(ReadOnlySpan`1<byte> data, int idx);
    private bool TryGetNumber(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSign(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeZero(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeIntegerDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeSign(ReadOnlySpan`1& data, Int32& i);
    private bool ConsumeNextTokenOrRollback(byte marker);
    private ConsumeTokenResult ConsumeNextToken(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken();
    private bool SkipAllComments(Byte& marker);
    private bool SkipAllComments(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker);
    private bool SkipComment();
    private bool SkipSingleLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private int FindLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private void ThrowOnDangerousLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private bool SkipMultiLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private bool ConsumeComment();
    private bool ConsumeSingleLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private bool ConsumeMultiLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private string get_DebuggerDisplay();
    private string get_DebugTokenType();
    private ReadOnlySpan`1<byte> GetUnescapedSpan();
    private bool ReadMultiSegment();
    private bool ValidateStateAtEndOfData();
    private bool HasMoreDataMultiSegment();
    private bool HasMoreDataMultiSegment(ExceptionResource resource);
    private bool GetNextSpan();
    private bool ReadFirstTokenMultiSegment(byte first);
    private void SkipWhiteSpaceMultiSegment();
    private bool ConsumeValueMultiSegment(byte marker);
    private bool ConsumeLiteralMultiSegment(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteralMultiSegment(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal, Int32& consumed);
    private int FindMismatch(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumberMultiSegment();
    private bool ConsumePropertyNameMultiSegment();
    private bool ConsumeStringMultiSegment();
    private bool ConsumeStringNextSegment();
    private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan`1<byte> data, int idx);
    private void RollBackState(PartialStateForRollback& state, bool isError);
    private bool TryGetNumberMultiSegment(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeZeroMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
    private bool SkipAllCommentsMultiSegment(Byte& marker);
    private bool SkipAllCommentsMultiSegment(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker);
    private bool SkipOrConsumeCommentMultiSegmentWithRollback();
    private bool SkipCommentMultiSegment(Int32& tailBytesToIgnore);
    private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& tailBytesToSkip);
    private int FindLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer);
    private PartialStateForRollback CaptureState();
    [NullableContextAttribute("2")]
public string GetString();
    [NullableContextAttribute("1")]
public string GetComment();
    public bool GetBoolean();
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    public byte GetByte();
    internal byte GetByteWithQuotes();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    internal sbyte GetSByteWithQuotes();
    public short GetInt16();
    internal short GetInt16WithQuotes();
    public int GetInt32();
    internal int GetInt32WithQuotes();
    public long GetInt64();
    internal long GetInt64WithQuotes();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    internal ushort GetUInt16WithQuotes();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    internal UInt32 GetUInt32WithQuotes();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    internal ulong GetUInt64WithQuotes();
    public float GetSingle();
    internal float GetSingleWithQuotes();
    internal float GetSingleFloatingPointConstant();
    public double GetDouble();
    internal double GetDoubleWithQuotes();
    internal double GetDoubleFloatingPointConstant();
    public decimal GetDecimal();
    internal decimal GetDecimalWithQuotes();
    public DateTime GetDateTime();
    internal DateTime GetDateTimeNoValidation();
    public DateTimeOffset GetDateTimeOffset();
    internal DateTimeOffset GetDateTimeOffsetNoValidation();
    public Guid GetGuid();
    internal Guid GetGuidNoValidation();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetByte(Byte& value);
    internal bool TryGetByteCore(Byte& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    internal bool TryGetSByteCore(SByte& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt16(Int16& value);
    internal bool TryGetInt16Core(Int16& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt32(Int32& value);
    internal bool TryGetInt32Core(Int32& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt64(Int64& value);
    internal bool TryGetInt64Core(Int64& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    internal bool TryGetUInt16Core(UInt16& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    internal bool TryGetUInt32Core(UInt32& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    internal bool TryGetUInt64Core(UInt64& value, ReadOnlySpan`1<byte> span);
    public bool TryGetSingle(Single& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetDecimal(Decimal& value);
    internal bool TryGetDecimalCore(Decimal& value, ReadOnlySpan`1<byte> span);
    public bool TryGetDateTime(DateTime& value);
    internal bool TryGetDateTimeCore(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    internal bool TryGetDateTimeOffsetCore(DateTimeOffset& value);
    public bool TryGetGuid(Guid& value);
    internal bool TryGetGuidCore(Guid& value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonWriter : object {
    private static int s_newLineLength;
    private static int DefaultGrowthSize;
    private static int InitialGrowthSize;
    private IBufferWriter`1<byte> _output;
    private Stream _stream;
    private ArrayBufferWriter`1<byte> _arrayBufferWriter;
    private Memory`1<byte> _memory;
    private bool _inObject;
    private JsonTokenType _tokenType;
    private BitStack _bitStack;
    private int _currentDepth;
    private JsonWriterOptions _options;
    [CompilerGeneratedAttribute]
private int <BytesPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCommitted>k__BackingField;
    private static Char[] s_singleLineCommentDelimiter;
    public int BytesPending { get; private set; }
    public long BytesCommitted { get; private set; }
    public JsonWriterOptions Options { get; }
    private int Indentation { get; }
    internal JsonTokenType TokenType { get; }
    public int CurrentDepth { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadOnlySpan`1<byte> SingleLineCommentDelimiterUtf8 { get; }
    [NullableContextAttribute("1")]
public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    [NullableContextAttribute("1")]
public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    private static Utf8JsonWriter();
    [CompilerGeneratedAttribute]
public int get_BytesPending();
    [CompilerGeneratedAttribute]
private void set_BytesPending(int value);
    [CompilerGeneratedAttribute]
public long get_BytesCommitted();
    [CompilerGeneratedAttribute]
private void set_BytesCommitted(long value);
    public JsonWriterOptions get_Options();
    private int get_Indentation();
    internal JsonTokenType get_TokenType();
    public int get_CurrentDepth();
    public void Reset();
    [NullableContextAttribute("1")]
public void Reset(Stream utf8Json);
    [NullableContextAttribute("1")]
public void Reset(IBufferWriter`1<byte> bufferWriter);
    private void ResetHelper();
    private void CheckNotDisposed();
    public void Flush();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<DisposeAsync>d__37")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<FlushAsync>d__38")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void WriteStartArray();
    public void WriteStartObject();
    private void WriteStart(byte token);
    private void WriteStartMinimized(byte token);
    private void WriteStartSlow(byte token);
    private void ValidateStart();
    private void WriteStartIndented(byte token);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    private void WriteStartHelper(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStartEscape(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, byte token, int firstEscapeIndexProp);
    [NullableContextAttribute("1")]
public void WriteStartArray(string propertyName);
    [NullableContextAttribute("1")]
public void WriteStartObject(string propertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    private void WriteStartEscape(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<char> propertyName, byte token, int firstEscapeIndexProp);
    public void WriteEndArray();
    public void WriteEndObject();
    private void WriteEnd(byte token);
    private void WriteEndMinimized(byte token);
    private void WriteEndSlow(byte token);
    private void ValidateEnd(byte token);
    private void WriteEndIndented(byte token);
    private void WriteNewLine(Span`1<byte> output);
    private void UpdateBitStackOnStart(byte token);
    private void Grow(int requiredSize);
    private void FirstCallToGetMemory(int requiredSize);
    private void SetFlagToAddListSeparatorBeforeNextItem();
    private string get_DebuggerDisplay();
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64ByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    internal void WritePropertyName(DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    internal void WritePropertyName(DateTimeOffset value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    internal void WritePropertyName(decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    internal void WritePropertyName(double value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    internal void WritePropertyName(float value);
    internal void WriteNumber(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    internal void WritePropertyName(Guid value);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<char> propertyName);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<byte> utf8PropertyName);
    private void ValidateDepth();
    private void ValidateWritingProperty();
    private void ValidateWritingProperty(byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void TranscodeAndWrite(ReadOnlySpan`1<char> escapedPropertyName, Span`1<byte> output);
    public void WriteNull(JsonEncodedText propertyName);
    internal void WriteNullSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteLiteralHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("1")]
public void WriteNull(string propertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    [NullableContextAttribute("1")]
public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    private void WriteLiteralEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralSection(ReadOnlySpan`1<byte> escapedPropertyNameSection, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    internal void WritePropertyName(bool value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    internal void WritePropertyName(int value);
    internal void WritePropertyName(long value);
    public void WritePropertyName(JsonEncodedText propertyName);
    internal void WritePropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WritePropertyNameHelper(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public void WritePropertyName(string propertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WritePropertyNameUnescaped(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    private void WriteStringPropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, JsonEncodedText value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("2")]
public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndex);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    internal void WritePropertyName(UInt32 value);
    internal void WritePropertyName(ulong value);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> get_SingleLineCommentDelimiterUtf8();
    [NullableContextAttribute("1")]
public void WriteCommentValue(string value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    private void WriteCommentByOptions(ReadOnlySpan`1<char> value);
    private void WriteCommentMinimized(ReadOnlySpan`1<char> value);
    private void WriteCommentIndented(ReadOnlySpan`1<char> value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(DateTime value);
    private void WriteStringValueMinimized(DateTime value);
    private void WriteStringValueIndented(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    private void WriteStringValueMinimized(DateTimeOffset value);
    private void WriteStringValueIndented(DateTimeOffset value);
    public void WriteNumberValue(decimal value);
    private void WriteNumberValueMinimized(decimal value);
    private void WriteNumberValueIndented(decimal value);
    internal void WriteNumberValueAsString(decimal value);
    public void WriteNumberValue(double value);
    private void WriteNumberValueMinimized(double value);
    private void WriteNumberValueIndented(double value);
    private static bool TryFormatDouble(double value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(double value);
    internal void WriteFloatingPointConstant(double value);
    public void WriteNumberValue(float value);
    private void WriteNumberValueMinimized(float value);
    private void WriteNumberValueIndented(float value);
    private static bool TryFormatSingle(float value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(float value);
    internal void WriteFloatingPointConstant(float value);
    internal void WriteNumberValue(ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberValueMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteNumberValueIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(Guid value);
    private void WriteStringValueMinimized(Guid value);
    private void WriteStringValueIndented(Guid value);
    private void ValidateWritingValue();
    private void Base64EncodeAndWrite(ReadOnlySpan`1<byte> bytes, Span`1<byte> output, int encodingLength);
    public void WriteNullValue();
    public void WriteBooleanValue(bool value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("1")]
public void WriteRawValue(string json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    private void TranscodeAndWriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    private void WriteRawValueCore(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    private void WriteNumberValueMinimized(long value);
    private void WriteNumberValueIndented(long value);
    internal void WriteNumberValueAsString(long value);
    public void WriteStringValue(JsonEncodedText value);
    [NullableContextAttribute("2")]
public void WriteStringValue(string value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<char> value, int firstEscapeIndexVal);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal);
    internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan`1<byte> utf8Value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    private void WriteNumberValueMinimized(ulong value);
    private void WriteNumberValueIndented(ulong value);
    internal void WriteNumberValueAsString(ulong value);
}
[DebuggerDisplayAttribute("Path:{PropertyPath()} Current: ConverterStrategy.{ConverterStrategy.JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy}, {Current.JsonTypeInfo.Type.Name}")]
internal class System.Text.Json.WriteStack : ValueType {
    public WriteStackFrame Current;
    private WriteStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    public CancellationToken CancellationToken;
    public bool SuppressFlush;
    public Task PendingTask;
    public List`1<IAsyncDisposable> CompletedAsyncDisposables;
    public int FlushThreshold;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public string BoxedStructReferenceId;
    public bool IsContinuation { get; }
    public bool get_IsContinuation();
    private void EnsurePushCapacity();
    public JsonConverter Initialize(Type type, JsonSerializerOptions options, bool supportContinuation);
    internal JsonConverter Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public void AddCompletedAsyncDisposable(IAsyncDisposable asyncDisposable);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposeCompletedAsyncDisposables>d__20")]
public ValueTask DisposeCompletedAsyncDisposables();
    public void DisposePendingDisposablesOnException();
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposePendingDisposablesOnExceptionAsync>d__22")]
public ValueTask DisposePendingDisposablesOnExceptionAsync();
    public string PropertyPath();
    [CompilerGeneratedAttribute]
internal static void <DisposePendingDisposablesOnException>g__DisposeFrame|21_0(IEnumerator collectionEnumerator, Exception& exception);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<<DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|22_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Exception> <DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|22_0(IEnumerator collectionEnumerator, IAsyncDisposable asyncDisposable, Exception exception);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendStackFrame|23_0(StringBuilder sb, WriteStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendPropertyName|23_1(StringBuilder sb, string propertyName);
}
[DebuggerDisplayAttribute("ConverterStrategy.{JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy}, {JsonTypeInfo.Type.Name}")]
internal class System.Text.Json.WriteStackFrame : ValueType {
    public IEnumerator CollectionEnumerator;
    public IAsyncDisposable AsyncDisposable;
    public bool AsyncEnumeratorIsPendingCompletion;
    public JsonPropertyInfo DeclaredJsonPropertyInfo;
    public bool IsWritingExtensionDataProperty;
    public JsonTypeInfo JsonTypeInfo;
    public int OriginalDepth;
    public bool ProcessedStartToken;
    public bool ProcessedEndToken;
    public StackFramePropertyState PropertyState;
    public int EnumeratorIndex;
    public string JsonPropertyNameAsString;
    public MetadataPropertyName MetadataPropertyName;
    private JsonPropertyInfo PolymorphicJsonPropertyInfo;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public void EndDictionaryElement();
    public void EndProperty();
    public JsonPropertyInfo GetPolymorphicJsonPropertyInfo();
    public JsonConverter InitializeReEntry(Type type, JsonSerializerOptions options);
}
