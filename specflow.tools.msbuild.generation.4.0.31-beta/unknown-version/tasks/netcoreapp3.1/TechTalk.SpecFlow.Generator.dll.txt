public class TechTalk.SpecFlow.Generator.CodeDom.CodeDomHelper : object {
    [CompilerGeneratedAttribute]
private CodeDomProviderLanguage <TargetLanguage>k__BackingField;
    public CodeDomProviderLanguage TargetLanguage { get; private set; }
    public CodeDomHelper(CodeDomProvider codeComProvider);
    public CodeDomHelper(CodeDomProviderLanguage targetLanguage);
    [CompilerGeneratedAttribute]
public CodeDomProviderLanguage get_TargetLanguage();
    [CompilerGeneratedAttribute]
private void set_TargetLanguage(CodeDomProviderLanguage value);
    public CodeTypeReference CreateNestedTypeReference(CodeTypeDeclaration baseTypeDeclaration, string nestedTypeName);
    private CodeStatement CreateCommentStatement(string comment);
    private NotImplementedException TargetLanguageNotSupportedException();
    public void BindTypeToSourceFile(CodeTypeDeclaration typeDeclaration, string fileName);
    public CodeStatement GetStartRegionStatement(string regionText);
    public CodeStatement GetEndRegionStatement();
    public CodeStatement GetDisableWarningsPragma();
    public CodeStatement GetEnableWarningsPragma();
    private Version GetCurrentSpecFlowVersion();
    public CodeTypeDeclaration CreateGeneratedTypeDeclaration(string className);
    public string GetErrorStatementString(string msg);
    public CodeAttributeDeclaration AddAttribute(CodeTypeMember codeTypeMember, string attrType);
    public CodeAttributeDeclaration AddAttribute(CodeTypeMember codeTypeMember, string attrType, Object[] attrValues);
    public CodeAttributeDeclaration AddAttribute(CodeTypeMember codeTypeMember, string attrType, CodeAttributeArgument[] attrArguments);
    public void AddAttributeForEachValue(CodeTypeMember codeTypeMember, string attrType, IEnumerable`1<TValue> attrValues);
    public CodeDomProvider CreateCodeDomProvider();
    public CodeMemberMethod CreateMethod(CodeTypeDeclaration type);
    public CodeStatement CreateDisableSourceLinePragmaStatement();
    [IteratorStateMachineAttribute("TechTalk.SpecFlow.Generator.CodeDom.CodeDomHelper/<CreateSourceLinePragmaStatement>d__24")]
public IEnumerable`1<CodeStatement> CreateSourceLinePragmaStatement(string filename, int lineNo, int colNo);
    public void MarkCodeMemberMethodAsAsync(CodeMemberMethod method);
    public bool IsVoid(CodeTypeReference codeTypeReference);
    public void MarkCodeMethodInvokeExpressionAsAwait(CodeMethodInvokeExpression expression);
    private CodeExpression GetAwaitedMethodThisTargetObject(CodeExpression thisExpression);
}
public enum TechTalk.SpecFlow.Generator.CodeDom.CodeDomProviderLanguage : Enum {
    public int value__;
    public static CodeDomProviderLanguage CSharp;
    public static CodeDomProviderLanguage VB;
    public static CodeDomProviderLanguage Other;
}
public class TechTalk.SpecFlow.Generator.CodeDom.SourceLineScope : object {
    private SpecFlowConfiguration _specFlowConfiguration;
    private CodeDomHelper _codeDomHelper;
    private List`1<CodeStatement> _statements;
    private Location _location;
    public SourceLineScope(SpecFlowConfiguration specFlowConfiguration, CodeDomHelper codeDomHelper, List`1<CodeStatement> statements, string filename, Location location);
    public sealed virtual void Dispose();
}
public class TechTalk.SpecFlow.Generator.Configuration.GeneratorConfigurationProvider : object {
    private IConfigurationLoader _configurationLoader;
    public GeneratorConfigurationProvider(IConfigurationLoader configurationLoader);
    public virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration, SpecFlowConfigurationHolder specFlowConfigurationHolder);
    public sealed virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration);
    internal virtual void UpdateConfiguration(SpecFlowProjectConfiguration configuration, ConfigurationSectionHandler specFlowConfigSection);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Generator.Configuration.GeneratorConfigurationProviderExtensions : object {
    [ExtensionAttribute]
public static SpecFlowProjectConfiguration LoadConfiguration(IGeneratorConfigurationProvider configurationProvider, SpecFlowConfigurationHolder configurationHolder);
}
public class TechTalk.SpecFlow.Generator.Configuration.GeneratorInfo : object {
    [CompilerGeneratedAttribute]
private Version <GeneratorAssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <GeneratorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratorFolder>k__BackingField;
    public Version GeneratorAssemblyVersion { get; public set; }
    public Version GeneratorVersion { get; public set; }
    public string GeneratorFolder { get; public set; }
    [CompilerGeneratedAttribute]
public Version get_GeneratorAssemblyVersion();
    [CompilerGeneratedAttribute]
public void set_GeneratorAssemblyVersion(Version value);
    [CompilerGeneratedAttribute]
public Version get_GeneratorVersion();
    [CompilerGeneratedAttribute]
public void set_GeneratorVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_GeneratorFolder();
    [CompilerGeneratedAttribute]
public void set_GeneratorFolder(string value);
}
public interface TechTalk.SpecFlow.Generator.Configuration.IGeneratorConfigurationProvider {
    public abstract virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration, SpecFlowConfigurationHolder specFlowConfigurationHolder);
    public abstract virtual SpecFlowConfiguration LoadConfiguration(SpecFlowConfiguration specFlowConfiguration);
}
public interface TechTalk.SpecFlow.Generator.Configuration.IGeneratorInfoProvider {
    public abstract virtual GeneratorInfo GetGeneratorInfo();
}
public class TechTalk.SpecFlow.Generator.Configuration.InProcGeneratorInfoProvider : object {
    public sealed virtual GeneratorInfo GetGeneratorInfo();
}
public interface TechTalk.SpecFlow.Generator.Configuration.ISpecFlowConfigurationReader {
    public abstract virtual SpecFlowConfigurationHolder ReadConfiguration();
}
public class TechTalk.SpecFlow.Generator.Configuration.SpecFlowProjectConfiguration : object {
    [CompilerGeneratedAttribute]
private SpecFlowConfiguration <SpecFlowConfiguration>k__BackingField;
    public SpecFlowConfiguration SpecFlowConfiguration { get; public set; }
    [CompilerGeneratedAttribute]
public SpecFlowConfiguration get_SpecFlowConfiguration();
    [CompilerGeneratedAttribute]
public void set_SpecFlowConfiguration(SpecFlowConfiguration value);
    protected bool Equals(SpecFlowProjectConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class TechTalk.SpecFlow.Generator.DefaultDependencyProvider : object {
    private void RegisterUnitTestGeneratorProviders(ObjectContainer container);
    public virtual void RegisterDefaults(ObjectContainer container);
}
public abstract class TechTalk.SpecFlow.Generator.ErrorHandlingTestGenerator : RemotableGeneratorClass {
    public sealed virtual TestGeneratorResult GenerateTestFile(FeatureFileInput featureFileInput, GenerationSettings settings);
    public sealed virtual Version DetectGeneratedTestVersion(FeatureFileInput featureFileInput);
    protected abstract virtual TestGeneratorResult GenerateTestFileWithExceptions(FeatureFileInput featureFileInput, GenerationSettings settings);
    protected abstract virtual Version DetectGeneratedTestVersionWithExceptions(FeatureFileInput featureFileInput);
    public virtual void Dispose();
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Generator.FeatureFileInputExtensions : object {
    [ExtensionAttribute]
public static TextReader GetFeatureFileContentReader(FeatureFileInput featureFileInput, ProjectSettings projectSettings);
    [ExtensionAttribute]
public static string GetFullPath(FeatureFileInput featureFileInput, ProjectSettings projectSettings);
    [ExtensionAttribute]
public static string GetGeneratedTestFullPath(FeatureFileInput featureFileInput, ProjectSettings projectSettings);
    [ExtensionAttribute]
public static string GetGeneratedTestContent(FeatureFileInput featureFileInput, string generatedTestFullPath);
}
public class TechTalk.SpecFlow.Generator.Generation.GeneratorConstants : object {
    public static string DEFAULT_NAMESPACE;
    public static string TEST_NAME_FORMAT;
    public static string SCENARIO_INITIALIZE_NAME;
    public static string SCENARIO_START_NAME;
    public static string SCENARIO_CLEANUP_NAME;
    public static string TEST_INITIALIZE_NAME;
    public static string TEST_CLEANUP_NAME;
    public static string TESTCLASS_INITIALIZE_NAME;
    public static string TESTCLASS_CLEANUP_NAME;
    public static string BACKGROUND_NAME;
    public static string TESTRUNNER_FIELD;
    public static string SPECFLOW_NAMESPACE;
    public static string SCENARIO_OUTLINE_EXAMPLE_TAGS_PARAMETER;
    public static string SCENARIO_TAGS_VARIABLE_NAME;
    public static string SCENARIO_ARGUMENTS_VARIABLE_NAME;
    public static string FEATURE_TAGS_VARIABLE_NAME;
}
public class TechTalk.SpecFlow.Generator.Generation.LinePragmaHandler : object {
    private SpecFlowConfiguration _specFlowConfiguration;
    private CodeDomHelper _codeDomHelper;
    public LinePragmaHandler(SpecFlowConfiguration specFlowConfiguration, CodeDomHelper codeDomHelper);
    public void AddLinePragmaInitial(CodeTypeDeclaration testType, string sourceFile);
}
public class TechTalk.SpecFlow.Generator.Generation.ScenarioDefinitionInFeatureFile : object {
    [CompilerGeneratedAttribute]
private StepsContainer <ScenarioDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private Rule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecFlowFeature <Feature>k__BackingField;
    public StepsContainer ScenarioDefinition { get; }
    public Rule Rule { get; }
    public SpecFlowFeature Feature { get; }
    public ScenarioOutline ScenarioOutline { get; }
    public Scenario Scenario { get; }
    public bool IsScenarioOutline { get; }
    public ScenarioDefinitionInFeatureFile(StepsContainer stepsContainer, SpecFlowFeature feature, Rule rule);
    [CompilerGeneratedAttribute]
public StepsContainer get_ScenarioDefinition();
    [CompilerGeneratedAttribute]
public Rule get_Rule();
    [CompilerGeneratedAttribute]
public SpecFlowFeature get_Feature();
    public ScenarioOutline get_ScenarioOutline();
    public Scenario get_Scenario();
    public bool get_IsScenarioOutline();
}
public class TechTalk.SpecFlow.Generator.Generation.ScenarioPartHelper : object {
    private SpecFlowConfiguration _specFlowConfiguration;
    private CodeDomHelper _codeDomHelper;
    private int _tableCounter;
    public ScenarioPartHelper(SpecFlowConfiguration specFlowConfiguration, CodeDomHelper codeDomHelper);
    public void SetupFeatureBackground(TestClassGenerationContext generationContext);
    public void GenerateRuleBackgroundStepsApplicableForThisScenario(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinition, List`1<CodeStatement> statementsWhenScenarioIsExecuted);
    private IEnumerable`1<CodeStatement> GenerateBackgroundStatementsForRule(TestClassGenerationContext context, Rule rule);
    public void GenerateStep(TestClassGenerationContext generationContext, List`1<CodeStatement> statements, Step gherkinStep, ParameterSubstitution paramToIdentifier);
    public CodeExpression GetStringArrayExpression(IEnumerable`1<Tag> tags);
    private SpecFlowStep AsSpecFlowStep(Step step);
    private CodeExpression GetTableArgExpression(DataTable tableArg, List`1<CodeStatement> statements, ParameterSubstitution paramToIdentifier);
    private CodeExpression GetDocStringArgExpression(DocString docString, ParameterSubstitution paramToIdentifier);
    public CodeExpression GetTestRunnerExpression();
    private CodeExpression GetStringArrayExpression(IEnumerable`1<string> items, ParameterSubstitution paramToIdentifier);
    private CodeExpression GetSubstitutedString(string text, ParameterSubstitution paramToIdentifier);
}
public class TechTalk.SpecFlow.Generator.Generation.UnitTestFeatureGenerator : object {
    private CodeDomHelper _codeDomHelper;
    private IDecoratorRegistry _decoratorRegistry;
    private ScenarioPartHelper _scenarioPartHelper;
    private SpecFlowConfiguration _specFlowConfiguration;
    private IUnitTestGeneratorProvider _testGeneratorProvider;
    private UnitTestMethodGenerator _unitTestMethodGenerator;
    private LinePragmaHandler _linePragmaHandler;
    [CompilerGeneratedAttribute]
private string <TestClassNameFormat>k__BackingField;
    public string TestClassNameFormat { get; public set; }
    public UnitTestFeatureGenerator(IUnitTestGeneratorProvider testGeneratorProvider, CodeDomHelper codeDomHelper, SpecFlowConfiguration specFlowConfiguration, IDecoratorRegistry decoratorRegistry);
    [CompilerGeneratedAttribute]
public string get_TestClassNameFormat();
    [CompilerGeneratedAttribute]
public void set_TestClassNameFormat(string value);
    public sealed virtual CodeNamespace GenerateUnitTestFixture(SpecFlowDocument document, string testClassName, string targetNamespace);
    private TestClassGenerationContext CreateTestClassStructure(CodeNamespace codeNamespace, string testClassName, SpecFlowDocument document);
    private CodeNamespace CreateNamespace(string targetNamespace);
    private void SetupScenarioCleanupMethod(TestClassGenerationContext generationContext);
    private void SetupTestClass(TestClassGenerationContext generationContext);
    private CodeMemberField DeclareTestRunnerMember(CodeTypeDeclaration type);
    private void SetupTestClassInitializeMethod(TestClassGenerationContext generationContext);
    private void SetupTestClassCleanupMethod(TestClassGenerationContext generationContext);
    private void SetupTestInitializeMethod(TestClassGenerationContext generationContext);
    private void SetupTestCleanupMethod(TestClassGenerationContext generationContext);
    private void SetupScenarioInitializeMethod(TestClassGenerationContext generationContext);
    private void SetupScenarioStartMethod(TestClassGenerationContext generationContext);
}
public class TechTalk.SpecFlow.Generator.Generation.UnitTestMethodGenerator : object {
    private static string IGNORE_TAG;
    private static string TESTRUNNER_FIELD;
    private CodeDomHelper _codeDomHelper;
    private IDecoratorRegistry _decoratorRegistry;
    private ScenarioPartHelper _scenarioPartHelper;
    private SpecFlowConfiguration _specFlowConfiguration;
    private IUnitTestGeneratorProvider _unitTestGeneratorProvider;
    public UnitTestMethodGenerator(IUnitTestGeneratorProvider unitTestGeneratorProvider, IDecoratorRegistry decoratorRegistry, CodeDomHelper codeDomHelper, ScenarioPartHelper scenarioPartHelper, SpecFlowConfiguration specFlowConfiguration);
    private IEnumerable`1<ScenarioDefinitionInFeatureFile> GetScenarioDefinitions(SpecFlowFeature feature);
    public void CreateUnitTests(SpecFlowFeature feature, TestClassGenerationContext generationContext);
    private void CreateUnitTest(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinitionInFeatureFile);
    private void GenerateScenarioOutlineTest(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinitionInFeatureFile);
    private void GenerateTest(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinitionInFeatureFile);
    private void ValidateExampleSetConsistency(ScenarioOutline scenarioOutline);
    private IEnumerable`1<string> GetNonIgnoreTags(IEnumerable`1<Tag> tags);
    private bool HasIgnoreTag(IEnumerable`1<Tag> tags);
    private void GenerateTestBody(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinitionInFeatureFile, CodeMemberMethod testMethod, CodeExpression additionalTagsExpression, ParameterSubstitution paramToIdentifier);
    private void AddVariableForTags(CodeMemberMethod testMethod, CodeExpression tagsExpression);
    private void AddVariableForArguments(CodeMemberMethod testMethod, ParameterSubstitution paramToIdentifier);
    internal void GenerateTestMethodBody(TestClassGenerationContext generationContext, ScenarioDefinitionInFeatureFile scenarioDefinition, CodeMemberMethod testMethod, ParameterSubstitution paramToIdentifier, SpecFlowFeature feature);
    internal void GenerateScenarioInitializeCall(TestClassGenerationContext generationContext, StepsContainer scenario, CodeMemberMethod testMethod);
    internal void GenerateScenarioCleanupMethodCall(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    private CodeMethodInvokeExpression CreateTestRunnerSkipScenarioCall();
    private void GenerateScenarioOutlineExamplesAsIndividualMethods(ScenarioOutline scenarioOutline, TestClassGenerationContext generationContext, CodeMemberMethod scenarioOutlineTestMethod, ParameterSubstitution paramToIdentifier);
    private void GenerateScenarioOutlineExamplesAsRowTests(TestClassGenerationContext generationContext, ScenarioOutline scenarioOutline, CodeMemberMethod scenatioOutlineTestMethod);
    private ParameterSubstitution CreateParamToIdentifierMapping(ScenarioOutline scenarioOutline);
    private bool CanUseFirstColumnAsName(IEnumerable`1<TableRow> tableBody);
    private CodeMemberMethod CreateScenarioOutlineTestMethod(TestClassGenerationContext generationContext, ScenarioOutline scenarioOutline, ParameterSubstitution paramToIdentifier);
    private void GenerateScenarioOutlineTestVariant(TestClassGenerationContext generationContext, ScenarioOutline scenarioOutline, CodeMemberMethod scenarioOutlineTestMethod, IEnumerable`1<KeyValuePair`2<string, string>> paramToIdentifier, string exampleSetTitle, string exampleSetIdentifier, TableRow row, Tag[] exampleSetTags, string variantName);
    private CodeMemberMethod CreateTestMethod(TestClassGenerationContext generationContext, StepsContainer scenario, IEnumerable`1<Tag> additionalTags, string variantName, string exampleSetIdentifier);
    private void SetupTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, StepsContainer scenarioDefinition, IEnumerable`1<Tag> additionalTags, string variantName, string exampleSetIdentifier, bool rowTest);
    private static string GetTestMethodName(StepsContainer scenario, string variantName, string exampleSetIdentifier);
    private IEnumerable`1<Tag> ConcatTags(IEnumerable`1[] tagLists);
}
public static class TechTalk.SpecFlow.Generator.GenerationTargetLanguage : object {
    public static string CSharp;
    public static string VB;
    public static string GetExtension(string programmingLanguage);
    public static CodeDomHelper CreateCodeDomHelper(string programmingLanguage);
}
public static class TechTalk.SpecFlow.Generator.GenerationTargetPlatform : object {
    public static string DotNet;
    public static string Mono;
    public static string Silverlight;
    public static string WindowsPhone;
    public static string Moonlight;
}
public class TechTalk.SpecFlow.Generator.GeneratorContainerBuilder : object {
    internal static DefaultDependencyProvider DefaultDependencyProvider;
    private static GeneratorContainerBuilder();
    public IObjectContainer CreateContainer(SpecFlowConfigurationHolder configurationHolder, ProjectSettings projectSettings, IEnumerable`1<GeneratorPluginInfo> generatorPluginInfos, IObjectContainer parentObjectContainer);
    private void LoadPlugins(ObjectContainer container, GeneratorPluginEvents generatorPluginEvents, UnitTestProviderConfiguration unitTestProviderConfiguration, IEnumerable`1<string> generatorPlugins);
    private void LoadPlugin(PluginDescriptor pluginDescriptor, IGeneratorPluginLoader pluginLoader, GeneratorPluginEvents generatorPluginEvents, UnitTestProviderConfiguration unitTestProviderConfiguration);
    private void RegisterDefaults(ObjectContainer container);
}
public class TechTalk.SpecFlow.Generator.GeneratorPluginInfo : object {
    [CompilerGeneratedAttribute]
private string <PathToGeneratorPluginAssembly>k__BackingField;
    public string PathToGeneratorPluginAssembly { get; }
    public GeneratorPluginInfo(string pathToGeneratorPluginAssembly);
    [CompilerGeneratedAttribute]
public string get_PathToGeneratorPluginAssembly();
}
public static class TechTalk.SpecFlow.Generator.Helpers.PathHelper : object {
    public static string SanitizeDirectorySeparatorChar(string path);
}
internal class TechTalk.SpecFlow.Generator.IndentProcessingWriter : TextWriter {
    private TextWriter innerWriter;
    private bool trimSpaces;
    private static Regex indentNextRe;
    public Encoding Encoding { get; }
    public IndentProcessingWriter(TextWriter innerWriter);
    private static IndentProcessingWriter();
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual Encoding get_Encoding();
    public virtual void WriteLine(string text);
    public virtual string ToString();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
public class TechTalk.SpecFlow.Generator.Interfaces.FeatureFileInput : object {
    [CompilerGeneratedAttribute]
private string <ProjectRelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureFileContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedTestProjectRelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedTestFileContent>k__BackingField;
    public string ProjectRelativePath { get; private set; }
    public string FeatureFileContent { get; public set; }
    public string CustomNamespace { get; public set; }
    public string GeneratedTestProjectRelativePath { get; public set; }
    public string GeneratedTestFileContent { get; public set; }
    public FeatureFileInput(string projectRelativePath);
    [CompilerGeneratedAttribute]
public string get_ProjectRelativePath();
    [CompilerGeneratedAttribute]
private void set_ProjectRelativePath(string value);
    [CompilerGeneratedAttribute]
public string get_FeatureFileContent();
    [CompilerGeneratedAttribute]
public void set_FeatureFileContent(string value);
    [CompilerGeneratedAttribute]
public string get_CustomNamespace();
    [CompilerGeneratedAttribute]
public void set_CustomNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_GeneratedTestProjectRelativePath();
    [CompilerGeneratedAttribute]
public void set_GeneratedTestProjectRelativePath(string value);
    [CompilerGeneratedAttribute]
public string get_GeneratedTestFileContent();
    [CompilerGeneratedAttribute]
public void set_GeneratedTestFileContent(string value);
}
public class TechTalk.SpecFlow.Generator.Interfaces.GenerationSettings : object {
    [CompilerGeneratedAttribute]
private bool <CheckUpToDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UpToDateCheckingMethod <UpToDateCheckingMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteResultToFile>k__BackingField;
    public bool CheckUpToDate { get; public set; }
    public UpToDateCheckingMethod UpToDateCheckingMethod { get; public set; }
    public bool WriteResultToFile { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CheckUpToDate();
    [CompilerGeneratedAttribute]
public void set_CheckUpToDate(bool value);
    [CompilerGeneratedAttribute]
public UpToDateCheckingMethod get_UpToDateCheckingMethod();
    [CompilerGeneratedAttribute]
public void set_UpToDateCheckingMethod(UpToDateCheckingMethod value);
    [CompilerGeneratedAttribute]
public bool get_WriteResultToFile();
    [CompilerGeneratedAttribute]
public void set_WriteResultToFile(bool value);
}
public interface TechTalk.SpecFlow.Generator.Interfaces.ITestGenerator {
    public abstract virtual TestGeneratorResult GenerateTestFile(FeatureFileInput featureFileInput, GenerationSettings settings);
    public abstract virtual Version DetectGeneratedTestVersion(FeatureFileInput featureFileInput);
    public abstract virtual string GetTestFullPath(FeatureFileInput featureFileInput);
}
public interface TechTalk.SpecFlow.Generator.Interfaces.ITestGeneratorFactory {
    public abstract virtual Version GetGeneratorVersion();
    public abstract virtual ITestGenerator CreateGenerator(ProjectSettings projectSettings, IEnumerable`1<GeneratorPluginInfo> generatorPlugins);
}
public class TechTalk.SpecFlow.Generator.Interfaces.ProjectPlatformSettings : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PlatformVersion>k__BackingField;
    public string Language { get; public set; }
    [ObsoleteAttribute("Not used anymore, will be removed with SpecFlow future versions")]
public Version LanguageVersion { get; public set; }
    [ObsoleteAttribute("Not used anymore, will be removed with SpecFlow future versions")]
public string Platform { get; public set; }
    [ObsoleteAttribute("Not used anymore, will be removed with SpecFlow future versions")]
public Version PlatformVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public Version get_LanguageVersion();
    [CompilerGeneratedAttribute]
public void set_LanguageVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public Version get_PlatformVersion();
    [CompilerGeneratedAttribute]
public void set_PlatformVersion(Version value);
}
public class TechTalk.SpecFlow.Generator.Interfaces.ProjectSettings : object {
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectPlatformSettings <ProjectPlatformSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecFlowConfigurationHolder <ConfigurationHolder>k__BackingField;
    public string ProjectName { get; public set; }
    public string AssemblyName { get; public set; }
    public string ProjectFolder { get; public set; }
    public string DefaultNamespace { get; public set; }
    public ProjectPlatformSettings ProjectPlatformSettings { get; public set; }
    public SpecFlowConfigurationHolder ConfigurationHolder { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFolder();
    [CompilerGeneratedAttribute]
public void set_ProjectFolder(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    [CompilerGeneratedAttribute]
public void set_DefaultNamespace(string value);
    [CompilerGeneratedAttribute]
public ProjectPlatformSettings get_ProjectPlatformSettings();
    [CompilerGeneratedAttribute]
public void set_ProjectPlatformSettings(ProjectPlatformSettings value);
    [CompilerGeneratedAttribute]
public SpecFlowConfigurationHolder get_ConfigurationHolder();
    [CompilerGeneratedAttribute]
public void set_ConfigurationHolder(SpecFlowConfigurationHolder value);
}
public class TechTalk.SpecFlow.Generator.Interfaces.SpecFlowConfigurationHolder : object {
    private string xmlString;
    [CompilerGeneratedAttribute]
private ConfigSource <ConfigSource>k__BackingField;
    public ConfigSource ConfigSource { get; }
    public string Content { get; }
    public bool HasConfiguration { get; }
    public SpecFlowConfigurationHolder(ConfigSource configSource, string content);
    public SpecFlowConfigurationHolder(XmlNode configXmlNode);
    [CompilerGeneratedAttribute]
public sealed virtual ConfigSource get_ConfigSource();
    public sealed virtual string get_Content();
    public sealed virtual bool get_HasConfiguration();
}
public class TechTalk.SpecFlow.Generator.Interfaces.TestGenerationError : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public int Line { get; private set; }
    public int LinePosition { get; private set; }
    public string Message { get; private set; }
    public TestGenerationError(int line, int linePosition, string message);
    public TestGenerationError(Exception exception);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    private static string GetMessage(Exception ex);
    private static string TryGetLocation(Assembly a);
}
[AttributeUsageAttribute("1")]
public class TechTalk.SpecFlow.Generator.Interfaces.TestGeneratorFactoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string Type { get; private set; }
    public TestGeneratorFactoryAttribute(string type);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
}
public class TechTalk.SpecFlow.Generator.Interfaces.TestGeneratorResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TestGenerationError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpToDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeneratedTestCode>k__BackingField;
    public IEnumerable`1<TestGenerationError> Errors { get; private set; }
    public bool IsUpToDate { get; private set; }
    public string GeneratedTestCode { get; private set; }
    public bool Success { get; }
    public TestGeneratorResult(TestGenerationError[] errors);
    public TestGeneratorResult(IEnumerable`1<TestGenerationError> errors);
    public TestGeneratorResult(string generatedTestCode, bool isUpToDate);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TestGenerationError> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IEnumerable`1<TestGenerationError> value);
    [CompilerGeneratedAttribute]
public bool get_IsUpToDate();
    [CompilerGeneratedAttribute]
private void set_IsUpToDate(bool value);
    [CompilerGeneratedAttribute]
public string get_GeneratedTestCode();
    [CompilerGeneratedAttribute]
private void set_GeneratedTestCode(string value);
    public bool get_Success();
}
public enum TechTalk.SpecFlow.Generator.Interfaces.UpToDateCheckingMethod : Enum {
    public int value__;
    public static UpToDateCheckingMethod ModificationTimeAndGeneratorVersion;
    public static UpToDateCheckingMethod FileContent;
}
public interface TechTalk.SpecFlow.Generator.ITestHeaderWriter {
    public abstract virtual Version DetectGeneratedTestVersion(string generatedTestContent);
}
public interface TechTalk.SpecFlow.Generator.ITestUpToDateChecker {
    public abstract virtual Nullable`1<bool> IsUpToDatePreliminary(FeatureFileInput featureFileInput, string generatedTestFullPath, UpToDateCheckingMethod upToDateCheckingMethod);
    public abstract virtual bool IsUpToDate(FeatureFileInput featureFileInput, string generatedTestFullPath, string generatedTestContent, UpToDateCheckingMethod upToDateCheckingMethod);
}
public class TechTalk.SpecFlow.Generator.ParameterSubstitution : List`1<KeyValuePair`2<string, string>> {
    public void Add(string parameter, string identifier);
    public bool TryGetIdentifier(string param, String& id);
}
public class TechTalk.SpecFlow.Generator.Plugins.ConfigurationDefaultsEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SpecFlowProjectConfiguration <SpecFlowProjectConfiguration>k__BackingField;
    public SpecFlowProjectConfiguration SpecFlowProjectConfiguration { get; private set; }
    public ConfigurationDefaultsEventArgs(SpecFlowProjectConfiguration specFlowProjectConfiguration);
    [CompilerGeneratedAttribute]
public SpecFlowProjectConfiguration get_SpecFlowProjectConfiguration();
    [CompilerGeneratedAttribute]
private void set_SpecFlowProjectConfiguration(SpecFlowProjectConfiguration value);
}
public class TechTalk.SpecFlow.Generator.Plugins.CustomizeDependenciesEventArgs : ObjectContainerEventArgs {
    [CompilerGeneratedAttribute]
private SpecFlowProjectConfiguration <SpecFlowProjectConfiguration>k__BackingField;
    public SpecFlowProjectConfiguration SpecFlowProjectConfiguration { get; private set; }
    public CustomizeDependenciesEventArgs(ObjectContainer objectContainer, SpecFlowProjectConfiguration specFlowProjectConfiguration);
    [CompilerGeneratedAttribute]
public SpecFlowProjectConfiguration get_SpecFlowProjectConfiguration();
    [CompilerGeneratedAttribute]
private void set_SpecFlowProjectConfiguration(SpecFlowProjectConfiguration value);
}
public class TechTalk.SpecFlow.Generator.Plugins.GeneratorPluginEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<RegisterDependenciesEventArgs> RegisterDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomizeDependenciesEventArgs> CustomizeDependencies;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConfigurationDefaultsEventArgs> ConfigurationDefaults;
    [CompilerGeneratedAttribute]
public void add_RegisterDependencies(EventHandler`1<RegisterDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RegisterDependencies(EventHandler`1<RegisterDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomizeDependencies(EventHandler`1<CustomizeDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomizeDependencies(EventHandler`1<CustomizeDependenciesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ConfigurationDefaults(EventHandler`1<ConfigurationDefaultsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConfigurationDefaults(EventHandler`1<ConfigurationDefaultsEventArgs> value);
    public void RaiseRegisterDependencies(ObjectContainer objectContainer);
    public void RaiseConfigurationDefaults(SpecFlowProjectConfiguration specFlowProjectConfiguration);
    public void RaiseCustomizeDependencies(ObjectContainer container, SpecFlowProjectConfiguration specFlowProjectConfiguration);
}
public class TechTalk.SpecFlow.Generator.Plugins.GeneratorPluginLoader : object {
    public sealed virtual IGeneratorPlugin LoadPlugin(PluginDescriptor pluginDescriptor);
}
public class TechTalk.SpecFlow.Generator.Plugins.GeneratorPluginParameters : object {
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(string value);
}
public interface TechTalk.SpecFlow.Generator.Plugins.IGeneratorPlugin {
    public abstract virtual void Initialize(GeneratorPluginEvents generatorPluginEvents, GeneratorPluginParameters generatorPluginParameters, UnitTestProviderConfiguration unitTestProviderConfiguration);
}
public interface TechTalk.SpecFlow.Generator.Plugins.IGeneratorPluginLoader {
    public abstract virtual IGeneratorPlugin LoadPlugin(PluginDescriptor pluginDescriptor);
}
public class TechTalk.SpecFlow.Generator.Plugins.RegisterDependenciesEventArgs : ObjectContainerEventArgs {
    public RegisterDependenciesEventArgs(ObjectContainer objectContainer);
}
public interface TechTalk.SpecFlow.Generator.Project.IMSBuildProjectReader {
    public abstract virtual SpecFlowProject LoadSpecFlowProjectFromMsBuild(string projectFilePath, string rootNamespace);
}
public interface TechTalk.SpecFlow.Generator.Project.IMSBuildRelativePathParser {
    public abstract virtual List`1<string> GetFiles(string projectFolder, string path);
}
public interface TechTalk.SpecFlow.Generator.Project.ISpecFlowProjectReader {
    public abstract virtual SpecFlowProject ReadSpecFlowProject(string projectFilePath, string rootNamespace);
}
public class TechTalk.SpecFlow.Generator.Project.MSBuildProjectReader : object {
    private ISpecFlowProjectReader _projectReader;
    public MSBuildProjectReader(ISpecFlowProjectReader projectReader);
    public sealed virtual SpecFlowProject LoadSpecFlowProjectFromMsBuild(string projectFilePath, string rootNamespace);
}
internal class TechTalk.SpecFlow.Generator.Project.MSBuildRelativePathParser : object {
    public sealed virtual List`1<string> GetFiles(string projectFolder, string path);
}
public class TechTalk.SpecFlow.Generator.Project.ProjectLanguageReader : object {
    public string GetLanguage(string projectFileName);
}
public class TechTalk.SpecFlow.Generator.Project.ProjectReader : object {
    private IGeneratorConfigurationProvider _configurationLoader;
    private ProjectLanguageReader _languageReader;
    public ProjectReader(IGeneratorConfigurationProvider configurationLoader, ProjectLanguageReader languageReader);
    public sealed virtual SpecFlowProject ReadSpecFlowProject(string projectFilePath, string rootNamespace);
    private SpecFlowConfigurationHolder GetSpecFlowConfigurationHolder(string projectFolder);
    private static SpecFlowConfigurationHolder GetConfigurationHolderFromFileContent(string configFileContent);
}
public class TechTalk.SpecFlow.Generator.Project.SpecFlowProject : object {
    [CompilerGeneratedAttribute]
private ProjectSettings <ProjectSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecFlowProjectConfiguration <Configuration>k__BackingField;
    public ProjectSettings ProjectSettings { get; public set; }
    public SpecFlowProjectConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectSettings get_ProjectSettings();
    [CompilerGeneratedAttribute]
public void set_ProjectSettings(ProjectSettings value);
    [CompilerGeneratedAttribute]
public SpecFlowProjectConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(SpecFlowProjectConfiguration value);
}
public abstract class TechTalk.SpecFlow.Generator.RemotableGeneratorClass : MarshalByRefObject {
    public virtual object InitializeLifetimeService();
}
public class TechTalk.SpecFlow.Generator.TestClassGenerationContext : object {
    [CompilerGeneratedAttribute]
private IUnitTestGeneratorProvider <UnitTestGeneratorProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecFlowDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeNamespace <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeTypeDeclaration <TestClass>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <TestClassInitializeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <TestClassCleanupMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <TestInitializeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <TestCleanupMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <ScenarioInitializeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <ScenarioStartMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <ScenarioCleanupMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberMethod <FeatureBackgroundMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeMemberField <TestRunnerField>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateRowTests>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <CustomData>k__BackingField;
    public IUnitTestGeneratorProvider UnitTestGeneratorProvider { get; private set; }
    public SpecFlowDocument Document { get; private set; }
    public SpecFlowFeature Feature { get; }
    public CodeNamespace Namespace { get; private set; }
    public CodeTypeDeclaration TestClass { get; private set; }
    public CodeMemberMethod TestClassInitializeMethod { get; private set; }
    public CodeMemberMethod TestClassCleanupMethod { get; private set; }
    public CodeMemberMethod TestInitializeMethod { get; private set; }
    public CodeMemberMethod TestCleanupMethod { get; private set; }
    public CodeMemberMethod ScenarioInitializeMethod { get; private set; }
    public CodeMemberMethod ScenarioStartMethod { get; private set; }
    public CodeMemberMethod ScenarioCleanupMethod { get; private set; }
    public CodeMemberMethod FeatureBackgroundMethod { get; private set; }
    public CodeMemberField TestRunnerField { get; private set; }
    public bool GenerateRowTests { get; private set; }
    public IDictionary`2<string, object> CustomData { get; private set; }
    public TestClassGenerationContext(IUnitTestGeneratorProvider unitTestGeneratorProvider, SpecFlowDocument document, CodeNamespace ns, CodeTypeDeclaration testClass, CodeMemberField testRunnerField, CodeMemberMethod testClassInitializeMethod, CodeMemberMethod testClassCleanupMethod, CodeMemberMethod testInitializeMethod, CodeMemberMethod testCleanupMethod, CodeMemberMethod scenarioInitializeMethod, CodeMemberMethod scenarioStartMethod, CodeMemberMethod scenarioCleanupMethod, CodeMemberMethod featureBackgroundMethod, bool generateRowTests);
    [CompilerGeneratedAttribute]
public IUnitTestGeneratorProvider get_UnitTestGeneratorProvider();
    [CompilerGeneratedAttribute]
private void set_UnitTestGeneratorProvider(IUnitTestGeneratorProvider value);
    [CompilerGeneratedAttribute]
public SpecFlowDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(SpecFlowDocument value);
    public SpecFlowFeature get_Feature();
    [CompilerGeneratedAttribute]
public CodeNamespace get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(CodeNamespace value);
    [CompilerGeneratedAttribute]
public CodeTypeDeclaration get_TestClass();
    [CompilerGeneratedAttribute]
private void set_TestClass(CodeTypeDeclaration value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_TestClassInitializeMethod();
    [CompilerGeneratedAttribute]
private void set_TestClassInitializeMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_TestClassCleanupMethod();
    [CompilerGeneratedAttribute]
private void set_TestClassCleanupMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_TestInitializeMethod();
    [CompilerGeneratedAttribute]
private void set_TestInitializeMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_TestCleanupMethod();
    [CompilerGeneratedAttribute]
private void set_TestCleanupMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_ScenarioInitializeMethod();
    [CompilerGeneratedAttribute]
private void set_ScenarioInitializeMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_ScenarioStartMethod();
    [CompilerGeneratedAttribute]
private void set_ScenarioStartMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_ScenarioCleanupMethod();
    [CompilerGeneratedAttribute]
private void set_ScenarioCleanupMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberMethod get_FeatureBackgroundMethod();
    [CompilerGeneratedAttribute]
private void set_FeatureBackgroundMethod(CodeMemberMethod value);
    [CompilerGeneratedAttribute]
public CodeMemberField get_TestRunnerField();
    [CompilerGeneratedAttribute]
private void set_TestRunnerField(CodeMemberField value);
    [CompilerGeneratedAttribute]
public bool get_GenerateRowTests();
    [CompilerGeneratedAttribute]
private void set_GenerateRowTests(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
private void set_CustomData(IDictionary`2<string, object> value);
}
public class TechTalk.SpecFlow.Generator.TestGenerator : ErrorHandlingTestGenerator {
    protected SpecFlowConfiguration specFlowConfiguration;
    protected ProjectSettings projectSettings;
    protected ITestHeaderWriter testHeaderWriter;
    protected ITestUpToDateChecker testUpToDateChecker;
    protected CodeDomHelper codeDomHelper;
    private IFeatureGeneratorRegistry featureGeneratorRegistry;
    private IGherkinParserFactory gherkinParserFactory;
    public TestGenerator(SpecFlowConfiguration specFlowConfiguration, ProjectSettings projectSettings, ITestHeaderWriter testHeaderWriter, ITestUpToDateChecker testUpToDateChecker, IFeatureGeneratorRegistry featureGeneratorRegistry, CodeDomHelper codeDomHelper, IGherkinParserFactory gherkinParserFactory);
    protected virtual TestGeneratorResult GenerateTestFileWithExceptions(FeatureFileInput featureFileInput, GenerationSettings settings);
    protected string GetGeneratedTestCode(FeatureFileInput featureFileInput);
    private string FixVb(string generatedTestCode);
    private string FixVBNetGlobalNamespace(string generatedTestCode);
    private string FixVBNetAsyncMethodDeclarations(string generatedTestCode);
    private CodeNamespace GenerateTestFileCode(FeatureFileInput featureFileInput);
    private SpecFlowDocumentLocation GetSpecFlowDocumentLocation(FeatureFileInput featureFileInput);
    private string GetFeatureFolderPath(string projectRelativeFilePath);
    protected virtual SpecFlowDocument ParseContent(IGherkinParser parser, TextReader contentReader, SpecFlowDocumentLocation documentLocation);
    protected string GetTargetNamespace(FeatureFileInput featureFileInput);
    public sealed virtual string GetTestFullPath(FeatureFileInput featureFileInput);
    protected virtual Version DetectGeneratedTestVersionWithExceptions(FeatureFileInput featureFileInput);
    protected void AddSpecFlowHeader(CodeDomProvider codeProvider, TextWriter outputWriter);
    protected void AddSpecFlowFooter(CodeDomProvider codeProvider, TextWriter outputWriter);
    protected Version GetCurrentSpecFlowVersion();
}
public class TechTalk.SpecFlow.Generator.TestGeneratorException : Exception {
    public TestGeneratorException(string message);
    public TestGeneratorException(string message, Exception inner);
    protected TestGeneratorException(SerializationInfo info, StreamingContext context);
}
public class TechTalk.SpecFlow.Generator.TestGeneratorFactory : RemotableGeneratorClass {
    public static Version GeneratorVersion;
    private static TestGeneratorFactory();
    public sealed virtual Version GetGeneratorVersion();
    public sealed virtual ITestGenerator CreateGenerator(ProjectSettings projectSettings, IEnumerable`1<GeneratorPluginInfo> generatorPluginInfos);
}
public class TechTalk.SpecFlow.Generator.TestHeaderWriter : object {
    private static Regex generatorVersionRe;
    private static Regex versionRe;
    private static TestHeaderWriter();
    public sealed virtual Version DetectGeneratedTestVersion(string generatedTestContent);
}
public class TechTalk.SpecFlow.Generator.TestUpToDateChecker : object {
    protected GeneratorInfo generatorInfo;
    private ITestHeaderWriter testHeaderWriter;
    private ProjectSettings projectSettings;
    public TestUpToDateChecker(ITestHeaderWriter testHeaderWriter, GeneratorInfo generatorInfo, ProjectSettings projectSettings);
    private bool IsUpToDateByModificationTimeAndGeneratorVersion(FeatureFileInput featureFileInput, string generatedTestFullPath);
    public sealed virtual Nullable`1<bool> IsUpToDatePreliminary(FeatureFileInput featureFileInput, string generatedTestFullPath, UpToDateCheckingMethod upToDateCheckingMethod);
    public sealed virtual bool IsUpToDate(FeatureFileInput featureFileInput, string generatedTestFullPath, string generatedTestContent, UpToDateCheckingMethod upToDateCheckingMethod);
}
public class TechTalk.SpecFlow.Generator.UnitTestConverter.DecoratorRegistry : object {
    private List`1<ITestMethodDecorator> testClassDecorators;
    private List`1<ITestMethodDecorator> testMethodDecorators;
    private List`1<ITestMethodTagDecorator> testClassTagDecorators;
    private List`1<ITestMethodTagDecorator> testMethodTagDecorators;
    public DecoratorRegistry(IObjectContainer objectContainer);
    private List`1<ITestMethodDecorator> ResolveDecorators(IObjectContainer objectContainer, Func`2<TDecorator, ITestMethodDecorator> selector);
    private List`1<ITestMethodTagDecorator> ResolveTagDecorators(IObjectContainer objectContainer, Func`2<TDecorator, ITestMethodTagDecorator> selector);
    public sealed virtual void DecorateTestClass(TestClassGenerationContext generationContext, List`1& unprocessedTags);
    public sealed virtual void DecorateTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<Tag> tags, List`1& unprocessedTags);
    private void Decorate(List`1<ITestMethodDecorator> decorators, List`1<ITestMethodTagDecorator> tagDecorators, TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<Tag> tags, List`1& unprocessedTags);
    private IEnumerable`1<ITestMethodDecorator> FindDecorators(List`1<ITestMethodDecorator> decorators, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    private IEnumerable`1<ITestMethodTagDecorator> FindDecorators(List`1<ITestMethodTagDecorator> decorators, string tagName, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
}
public class TechTalk.SpecFlow.Generator.UnitTestConverter.FeatureGeneratorRegistry : object {
    private List`1<IFeatureGeneratorProvider> providers;
    public FeatureGeneratorRegistry(IObjectContainer objectContainer);
    public sealed virtual IFeatureGenerator CreateGenerator(SpecFlowDocument document);
    private IFeatureGeneratorProvider FindProvider(SpecFlowDocument feature);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.IDecoratorRegistry {
    public abstract virtual void DecorateTestClass(TestClassGenerationContext generationContext, List`1& unprocessedTags);
    public abstract virtual void DecorateTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<Tag> tags, List`1& unprocessedTags);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.IFeatureGenerator {
    public abstract virtual CodeNamespace GenerateUnitTestFixture(SpecFlowDocument document, string testClassName, string targetNamespace);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.IFeatureGeneratorProvider {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool CanGenerate(SpecFlowDocument document);
    public abstract virtual IFeatureGenerator CreateGenerator(SpecFlowDocument document);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.IFeatureGeneratorRegistry {
    public abstract virtual IFeatureGenerator CreateGenerator(SpecFlowDocument document);
}
public class TechTalk.SpecFlow.Generator.UnitTestConverter.IgnoreDecorator : object {
    private static string IGNORE_TAG;
    private ITagFilterMatcher tagFilterMatcher;
    public int Priority { get; }
    public bool RemoveProcessedTags { get; }
    public bool ApplyOtherDecoratorsForProcessedTags { get; }
    public IgnoreDecorator(ITagFilterMatcher tagFilterMatcher);
    public sealed virtual int get_Priority();
    public sealed virtual bool get_RemoveProcessedTags();
    public sealed virtual bool get_ApplyOtherDecoratorsForProcessedTags();
    private bool CanDecorateFrom(string tagName);
    public sealed virtual bool CanDecorateFrom(string tagName, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public sealed virtual void DecorateFrom(string tagName, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public sealed virtual bool CanDecorateFrom(string tagName, TestClassGenerationContext generationContext);
    public sealed virtual void DecorateFrom(string tagName, TestClassGenerationContext generationContext);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.ITagFilterMatcher {
    public abstract virtual bool Match(string tagFilter, IEnumerable`1<string> tagNames);
    public abstract virtual bool MatchPrefix(string tagFilter, IEnumerable`1<string> tagNames);
    public abstract virtual bool GetTagValue(string tagFilter, IEnumerable`1<string> tagNames, String& value);
    public abstract virtual String[] GetTagValues(string tagFilter, IEnumerable`1<string> tagNames);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.ITestClassDecorator {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool CanDecorateFrom(TestClassGenerationContext generationContext);
    public abstract virtual void DecorateFrom(TestClassGenerationContext generationContext);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.ITestClassTagDecorator {
    public int Priority { get; }
    public bool RemoveProcessedTags { get; }
    public bool ApplyOtherDecoratorsForProcessedTags { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool get_RemoveProcessedTags();
    public abstract virtual bool get_ApplyOtherDecoratorsForProcessedTags();
    public abstract virtual bool CanDecorateFrom(string tagName, TestClassGenerationContext generationContext);
    public abstract virtual void DecorateFrom(string tagName, TestClassGenerationContext generationContext);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.ITestMethodDecorator {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool CanDecorateFrom(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public abstract virtual void DecorateFrom(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
}
public interface TechTalk.SpecFlow.Generator.UnitTestConverter.ITestMethodTagDecorator {
    public int Priority { get; }
    public bool RemoveProcessedTags { get; }
    public bool ApplyOtherDecoratorsForProcessedTags { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool get_RemoveProcessedTags();
    public abstract virtual bool get_ApplyOtherDecoratorsForProcessedTags();
    public abstract virtual bool CanDecorateFrom(string tagName, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public abstract virtual void DecorateFrom(string tagName, TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
}
public class TechTalk.SpecFlow.Generator.UnitTestConverter.NonParallelizableDecorator : object {
    private String[] nonParallelizableTags;
    private ITagFilterMatcher tagFilterMatcher;
    public int Priority { get; }
    public NonParallelizableDecorator(ITagFilterMatcher tagFilterMatcher, SpecFlowConfiguration generatorConfiguration);
    public sealed virtual int get_Priority();
    public sealed virtual bool CanDecorateFrom(TestClassGenerationContext generationContext);
    public sealed virtual void DecorateFrom(TestClassGenerationContext generationContext);
    private bool ProviderSupportsParallelExecution(TestClassGenerationContext generationContext);
    private bool ConfiguredTagIsPresent(IEnumerable`1<string> tagName);
}
public static class TechTalk.SpecFlow.Generator.UnitTestConverter.PriorityValues : object {
    public static int High;
    public static int Normal;
    public static int Low;
    public static int Lowest;
}
public abstract class TechTalk.SpecFlow.Generator.UnitTestConverter.TagFilteredFeatureGeneratorProvider : object {
    protected ITagFilterMatcher tagFilterMatcher;
    protected string registeredName;
    public int Priority { get; }
    protected TagFilteredFeatureGeneratorProvider(ITagFilterMatcher tagFilterMatcher, string registeredName);
    public virtual int get_Priority();
    public sealed virtual bool CanGenerate(SpecFlowDocument document);
    public abstract virtual IFeatureGenerator CreateGenerator(SpecFlowDocument document);
}
internal class TechTalk.SpecFlow.Generator.UnitTestConverter.TagFilterMatcher : object {
    private static string TAG_PREFIX_SEPARATOR;
    private static StringComparison tagComparison;
    private string GetExpectedTagName(string tagFilter);
    public sealed virtual bool Match(string tagFilter, IEnumerable`1<string> tagNames);
    public sealed virtual bool MatchPrefix(string tagFilter, IEnumerable`1<string> tagNames);
    private static string GetExpectedTagPrefix(string expectedTagName);
    private bool MatchTag(string tagName, string expectedTagName, string expectedTagPrefix);
    private bool MatchExactTag(string tagName, string expectedTagName);
    private bool MatchTagPrefix(string tagName, string expectedTagPrefix);
    private IEnumerable`1<string> GetTagValuesInternal(string tagFilter, IEnumerable`1<string> tagNames);
    private string GetValue(string expectedTagPrefix, string tagWithValue);
    public sealed virtual bool GetTagValue(string tagFilter, IEnumerable`1<string> tagNames, String& value);
    public sealed virtual String[] GetTagValues(string tagFilter, IEnumerable`1<string> tagNames);
}
[ExtensionAttribute]
public static class TechTalk.SpecFlow.Generator.UnitTestConverter.TagFilterMatcherExtensions : object {
    [ExtensionAttribute]
public static bool Match(ITagFilterMatcher tagFilterMatcher, string tagFilter, string tagName);
    [ExtensionAttribute]
public static bool MatchPrefix(ITagFilterMatcher tagFilterMatcher, string tagFilter, SpecFlowDocument document);
    [ExtensionAttribute]
public static bool GetTagValue(ITagFilterMatcher tagFilterMatcher, string tagFilter, SpecFlowDocument document, String& value);
}
public class TechTalk.SpecFlow.Generator.UnitTestConverter.UnitTestFeatureGeneratorProvider : object {
    private UnitTestFeatureGenerator _unitTestFeatureGenerator;
    public int Priority { get; }
    public UnitTestFeatureGeneratorProvider(UnitTestFeatureGenerator unitTestFeatureGenerator);
    public sealed virtual int get_Priority();
    public sealed virtual bool CanGenerate(SpecFlowDocument document);
    public sealed virtual IFeatureGenerator CreateGenerator(SpecFlowDocument document);
}
public interface TechTalk.SpecFlow.Generator.UnitTestProvider.IUnitTestGeneratorProvider {
    public abstract virtual UnitTestGeneratorTraits GetTraits();
    public abstract virtual void SetTestClass(TestClassGenerationContext generationContext, string featureTitle, string featureDescription);
    public abstract virtual void SetTestClassCategories(TestClassGenerationContext generationContext, IEnumerable`1<string> featureCategories);
    public abstract virtual void SetTestClassIgnore(TestClassGenerationContext generationContext);
    public abstract virtual void FinalizeTestClass(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestClassNonParallelizable(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestClassInitializeMethod(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestClassCleanupMethod(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestInitializeMethod(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestCleanupMethod(TestClassGenerationContext generationContext);
    public abstract virtual void SetTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string friendlyTestName);
    public abstract virtual void SetTestMethodCategories(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> scenarioCategories);
    public abstract virtual void SetTestMethodIgnore(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public abstract virtual void SetRowTest(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle);
    public abstract virtual void SetRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> arguments, IEnumerable`1<string> tags, bool isIgnored);
    public abstract virtual void SetTestMethodAsRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle, string exampleSetName, string variantName, IEnumerable`1<KeyValuePair`2<string, string>> arguments);
    public abstract virtual void MarkCodeMethodInvokeExpressionAsAwait(CodeMethodInvokeExpression expression);
    public abstract virtual CodeExpression GetTestWorkerIdExpression();
}
public class TechTalk.SpecFlow.Generator.UnitTestProvider.MsTestGeneratorProvider : object {
    protected internal static string TESTFIXTURE_ATTR;
    protected internal static string TEST_ATTR;
    protected internal static string PROPERTY_ATTR;
    protected internal static string TESTFIXTURESETUP_ATTR;
    protected internal static string TESTFIXTURETEARDOWN_ATTR;
    protected internal static string TESTSETUP_ATTR;
    protected internal static string TESTTEARDOWN_ATTR;
    protected internal static string IGNORE_ATTR;
    protected internal static string DESCRIPTION_ATTR;
    protected internal static string FEATURE_TITILE_PROPERTY_NAME;
    protected internal static string TESTCONTEXT_TYPE;
    protected internal static string TESTCONTEXT_FIELD_NAME;
    protected internal static string TESTCONTEXT_PROPERTY_NAME;
    [CompilerGeneratedAttribute]
private CodeDomHelper <CodeDomHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateParallelCodeForFeature>k__BackingField;
    protected CodeDomHelper CodeDomHelper { get; protected set; }
    public bool GenerateParallelCodeForFeature { get; public set; }
    public MsTestGeneratorProvider(CodeDomHelper codeDomHelper);
    [CompilerGeneratedAttribute]
protected CodeDomHelper get_CodeDomHelper();
    [CompilerGeneratedAttribute]
protected void set_CodeDomHelper(CodeDomHelper value);
    public virtual UnitTestGeneratorTraits GetTraits();
    [CompilerGeneratedAttribute]
public bool get_GenerateParallelCodeForFeature();
    [CompilerGeneratedAttribute]
public void set_GenerateParallelCodeForFeature(bool value);
    private void SetProperty(CodeTypeMember codeTypeMember, string name, string value);
    public virtual void SetTestClass(TestClassGenerationContext generationContext, string featureTitle, string featureDescription);
    public virtual void SetTestClassCategories(TestClassGenerationContext generationContext, IEnumerable`1<string> featureCategories);
    public sealed virtual void SetTestClassIgnore(TestClassGenerationContext generationContext);
    public virtual void FinalizeTestClass(TestClassGenerationContext generationContext);
    public virtual void SetTestClassNonParallelizable(TestClassGenerationContext generationContext);
    public virtual void SetTestClassInitializeMethod(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestClassCleanupMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestInitializeMethod(TestClassGenerationContext generationContext);
    protected virtual void FixTestRunOrderingIssue(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestCleanupMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string friendlyTestName);
    public virtual void SetTestMethodCategories(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> scenarioCategories);
    public sealed virtual void SetTestMethodIgnore(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public virtual void SetRowTest(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle);
    public virtual void SetRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> arguments, IEnumerable`1<string> tags, bool isIgnored);
    public virtual void SetTestMethodAsRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle, string exampleSetName, string variantName, IEnumerable`1<KeyValuePair`2<string, string>> arguments);
    public sealed virtual void MarkCodeMethodInvokeExpressionAsAwait(CodeMethodInvokeExpression expression);
    public sealed virtual CodeExpression GetTestWorkerIdExpression();
}
public class TechTalk.SpecFlow.Generator.UnitTestProvider.MsTestV2GeneratorProvider : MsTestGeneratorProvider {
    protected internal static string DONOTPARALLELIZE_ATTR;
    protected internal static string DONOTPARALLELIZE_TAG;
    protected internal static string CATEGORY_ATTR;
    protected internal static string OWNER_ATTR;
    protected internal static string WORKITEM_ATTR;
    protected internal static string DEPLOYMENTITEM_ATTR;
    protected internal static string OWNER_TAG;
    protected internal static string WORKITEM_TAG;
    protected internal static string DEPLOYMENTITEM_TAG;
    public MsTestV2GeneratorProvider(CodeDomHelper codeDomHelper);
    public virtual UnitTestGeneratorTraits GetTraits();
    public virtual void SetTestClass(TestClassGenerationContext generationContext, string featureTitle, string featureDescription);
    public virtual void SetTestClassCategories(TestClassGenerationContext generationContext, IEnumerable`1<string> featureCategories);
    public virtual void SetTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string friendlyTestName);
    public virtual void SetTestMethodCategories(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> scenarioCategories);
    public virtual void SetTestClassNonParallelizable(TestClassGenerationContext generationContext);
    private IEnumerable`1<string> GetNonMSTestSpecificTags(IEnumerable`1<string> tags);
}
public class TechTalk.SpecFlow.Generator.UnitTestProvider.NUnit3TestGeneratorProvider : object {
    protected internal static string TESTFIXTURESETUP_ATTR_NUNIT3;
    protected internal static string TESTFIXTURETEARDOWN_ATTR_NUNIT3;
    protected internal static string NONPARALLELIZABLE_ATTR;
    protected internal static string TESTFIXTURE_ATTR;
    protected internal static string TEST_ATTR;
    protected internal static string ROW_ATTR;
    protected internal static string CATEGORY_ATTR;
    protected internal static string TESTSETUP_ATTR;
    protected internal static string TESTTEARDOWN_ATTR;
    protected internal static string IGNORE_ATTR;
    protected internal static string DESCRIPTION_ATTR;
    protected internal static string TESTCONTEXT_TYPE;
    protected internal static string TESTCONTEXT_INSTANCE;
    protected internal static string TESTCONTEXT_WORKERID_PROPERTY;
    [CompilerGeneratedAttribute]
private CodeDomHelper <CodeDomHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateParallelCodeForFeature>k__BackingField;
    protected CodeDomHelper CodeDomHelper { get; protected set; }
    public bool GenerateParallelCodeForFeature { get; public set; }
    public NUnit3TestGeneratorProvider(CodeDomHelper codeDomHelper);
    [CompilerGeneratedAttribute]
protected CodeDomHelper get_CodeDomHelper();
    [CompilerGeneratedAttribute]
protected void set_CodeDomHelper(CodeDomHelper value);
    [CompilerGeneratedAttribute]
public bool get_GenerateParallelCodeForFeature();
    [CompilerGeneratedAttribute]
public void set_GenerateParallelCodeForFeature(bool value);
    public virtual UnitTestGeneratorTraits GetTraits();
    public virtual void SetTestClassIgnore(TestClassGenerationContext generationContext);
    public virtual void SetTestMethodIgnore(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public virtual void SetTestClassInitializeMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestClassCleanupMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestClassNonParallelizable(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestClass(TestClassGenerationContext generationContext, string featureTitle, string featureDescription);
    public sealed virtual void SetTestClassCategories(TestClassGenerationContext generationContext, IEnumerable`1<string> featureCategories);
    public virtual void FinalizeTestClass(TestClassGenerationContext generationContext);
    private CodeExpression GetTestContextExpression();
    public sealed virtual void SetTestInitializeMethod(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestCleanupMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string friendlyTestName);
    public virtual void SetTestMethodCategories(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> scenarioCategories);
    public virtual void SetRowTest(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle);
    public sealed virtual void SetRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> arguments, IEnumerable`1<string> tags, bool isIgnored);
    public sealed virtual void SetTestMethodAsRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle, string exampleSetName, string variantName, IEnumerable`1<KeyValuePair`2<string, string>> arguments);
    public sealed virtual void MarkCodeMethodInvokeExpressionAsAwait(CodeMethodInvokeExpression expression);
    public sealed virtual CodeExpression GetTestWorkerIdExpression();
}
[FlagsAttribute]
public enum TechTalk.SpecFlow.Generator.UnitTestProvider.UnitTestGeneratorTraits : Enum {
    public int value__;
    public static UnitTestGeneratorTraits None;
    public static UnitTestGeneratorTraits RowTests;
    public static UnitTestGeneratorTraits ParallelExecution;
}
public class TechTalk.SpecFlow.Generator.UnitTestProvider.XUnit2TestGeneratorProvider : object {
    private CodeTypeDeclaration _currentFixtureDataTypeDeclaration;
    private CodeTypeReference _objectCodeTypeReference;
    protected internal static string THEORY_ATTRIBUTE;
    protected internal static string INLINEDATA_ATTRIBUTE;
    protected internal static string ICLASSFIXTURE_INTERFACE;
    protected internal static string COLLECTION_ATTRIBUTE;
    protected internal static string OUTPUT_INTERFACE;
    protected internal static string OUTPUT_INTERFACE_PARAMETER_NAME;
    protected internal static string OUTPUT_INTERFACE_FIELD_NAME;
    protected internal static string FIXTUREDATA_PARAMETER_NAME;
    protected internal static string COLLECTION_DEF;
    protected internal static string COLLECTION_TAG;
    protected internal static string FEATURE_TITLE_PROPERTY_NAME;
    protected internal static string DESCRIPTION_PROPERTY_NAME;
    protected internal static string FACT_ATTRIBUTE;
    protected internal static string FACT_ATTRIBUTE_SKIP_PROPERTY_NAME;
    protected internal static string THEORY_ATTRIBUTE_SKIP_PROPERTY_NAME;
    protected internal static string SKIP_REASON;
    protected internal static string TRAIT_ATTRIBUTE;
    protected internal static string CATEGORY_PROPERTY_NAME;
    protected internal static string IGNORE_TEST_CLASS;
    protected internal static string NONPARALLELIZABLE_COLLECTION_NAME;
    protected internal static string IASYNCLIFETIME_INTERFACE;
    protected internal static string XUNITPARALLELWORKERTRACKER_INSTANCE;
    [CompilerGeneratedAttribute]
private CodeDomHelper <CodeDomHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateParallelCodeForFeature>k__BackingField;
    public bool ImplementInterfaceExplicit { get; }
    protected CodeDomHelper CodeDomHelper { get; protected set; }
    public bool GenerateParallelCodeForFeature { get; public set; }
    public XUnit2TestGeneratorProvider(CodeDomHelper codeDomHelper);
    public virtual void SetTestClass(TestClassGenerationContext generationContext, string featureTitle, string featureDescription);
    public virtual UnitTestGeneratorTraits GetTraits();
    protected virtual CodeTypeReference CreateFixtureInterface(TestClassGenerationContext generationContext, CodeTypeReference fixtureDataType);
    public virtual bool get_ImplementInterfaceExplicit();
    [CompilerGeneratedAttribute]
protected CodeDomHelper get_CodeDomHelper();
    [CompilerGeneratedAttribute]
protected void set_CodeDomHelper(CodeDomHelper value);
    [CompilerGeneratedAttribute]
public bool get_GenerateParallelCodeForFeature();
    [CompilerGeneratedAttribute]
public void set_GenerateParallelCodeForFeature(bool value);
    public virtual void SetRowTest(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle);
    public virtual void SetRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> arguments, IEnumerable`1<string> tags, bool isIgnored);
    protected virtual void SetTestConstructor(TestClassGenerationContext generationContext, CodeConstructor constructor);
    protected virtual void SetTestInitializeMethod(TestClassGenerationContext generationContext, CodeMemberMethod method);
    public virtual void SetTestMethodIgnore(TestClassGenerationContext generationContext, CodeMemberMethod testMethod);
    public virtual void SetTestClassCategories(TestClassGenerationContext generationContext, IEnumerable`1<string> featureCategories);
    public void SetTestClassCollection(TestClassGenerationContext generationContext, string collection);
    public virtual void SetTestClassNonParallelizable(TestClassGenerationContext generationContext);
    public virtual void FinalizeTestClass(TestClassGenerationContext generationContext);
    protected virtual void IgnoreFeature(TestClassGenerationContext generationContext);
    protected virtual bool IsTestMethodAlreadyIgnored(CodeMemberMethod testMethod);
    public sealed virtual void SetTestClassInitializeMethod(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestClassCleanupMethod(TestClassGenerationContext generationContext);
    public virtual void SetTestMethod(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string friendlyTestName);
    public virtual void SetTestMethodCategories(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, IEnumerable`1<string> scenarioCategories);
    public sealed virtual void SetTestInitializeMethod(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestCleanupMethod(TestClassGenerationContext generationContext);
    public sealed virtual void SetTestClassIgnore(TestClassGenerationContext generationContext);
    protected void SetProperty(CodeTypeMember codeTypeMember, string name, string value);
    protected void SetDescription(CodeTypeMember codeTypeMember, string description);
    protected bool IsTestMethodAlreadyIgnored(CodeMemberMethod testMethod, string factAttributeName, string theoryAttributeName);
    public sealed virtual void SetTestMethodAsRow(TestClassGenerationContext generationContext, CodeMemberMethod testMethod, string scenarioTitle, string exampleSetName, string variantName, IEnumerable`1<KeyValuePair`2<string, string>> arguments);
    public sealed virtual void MarkCodeMethodInvokeExpressionAsAwait(CodeMethodInvokeExpression expression);
    public sealed virtual CodeExpression GetTestWorkerIdExpression();
}
public class TechTalk.SpecFlow.Tracing.TextWriterTraceListener : object {
    private TextWriter textWriter;
    private string toolMessagePrefix;
    public TextWriterTraceListener(TextWriter textWriter);
    public TextWriterTraceListener(TextWriter textWriter, string toolMessagePrefix);
    public sealed virtual void WriteTestOutput(string message);
    public sealed virtual void WriteToolOutput(string message);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.107.25444")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
