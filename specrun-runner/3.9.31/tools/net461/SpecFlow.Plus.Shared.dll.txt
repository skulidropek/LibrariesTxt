public class FullFramework.RegistryLicenseReaderService : object {
    public sealed virtual FSharpOption`1<StorageLicenseInfo> ReadLicense();
}
public class FullFramework.RegistryLicenseRemovalService : object {
    public sealed virtual bool RemoveLicense();
}
public class FullFramework.RegistryLicenseWriterService : object {
    public sealed virtual bool WriteLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.CommonContainerBuilder : object {
    public static IObjectContainer Create();
    public static IObjectContainer Register(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterTypeSingleInstance(IObjectContainer objectContainer, string name);
    [ExtensionAttribute]
public static IObjectContainer RegisterFileNameService(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterSystemRandomNumberGenerator(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterLogger(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterThreadFactory(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterLoggerConfiguration(IObjectContainer objectContainer, LoggingConfig loggingConfig);
    [ExtensionAttribute]
public static IObjectContainer RegisterRealTimeService(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterConsoleOutput(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterConsoleTestLogger(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterLicenseServices(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterAnalyticsServices(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterActivationServices(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterCurrentThreadService(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterReleaseDateService(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterFileSystemService(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterDateTimeOutputFormatter(IObjectContainer self);
    [ExtensionAttribute]
public static IObjectContainer RegisterDefaultConsoleOutputConfiguration(IObjectContainer self);
}
public static class SpecFlow.Plus.Shared.Constants : object {
    public static string WindowsLicenseKeyFilePath;
    public static string UnixLicenseKeyFilePath;
    public static string LicenseRegistryPath;
    public static string LicenseIssuedToValueName;
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("SpecFlow.Plus.Shared.Extensions.EnumerableExtensions/<AsInfinitelyRepeatedEnumerable>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AsInfinitelyRepeatedEnumerable(T value);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool HasItems(IEnumerable`1<T> enumerable);
    [IteratorStateMachineAttribute("SpecFlow.Plus.Shared.Extensions.EnumerableExtensions/<Append>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> enumerable, T valueToAppend);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.FSharpExtensions.ChoiceExtensions : object {
    [ExtensionAttribute]
public static bool IsValue(FSharpChoice`2<TValue, Error`1<TErrorDescription>> choice);
    [ExtensionAttribute]
public static bool IsValue(FSharpChoice`2<TValue, Error`1<TErrorDescription>> choice, TValue& value);
    [ExtensionAttribute]
public static TValue GetValueChoice(FSharpChoice`2<TValue, Error`1<TErrorDescription>> choice);
    [ExtensionAttribute]
public static bool IsError(FSharpChoice`2<TValue, Error`1<TErrorDescription>> choice);
    [ExtensionAttribute]
public static bool IsError(FSharpChoice`2<TValue, Error`1<TErrorDescription>> choice, TErrorDescription& errorDescription);
    [ExtensionAttribute]
public static FSharpChoice`2<TValue, Error`1<TErrorDescription>> AsErrorChoice(TErrorDescription errorDescription);
    [ExtensionAttribute]
public static FSharpChoice`2<TValue, Error`1<TErrorDescription>> AsValueChoice(TValue value);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.FSharpExtensions.OptionExtensions : object {
    [ExtensionAttribute]
public static bool IsSome(FSharpOption`1<T> option);
    [ExtensionAttribute]
public static bool IsNone(FSharpOption`1<T> option);
    [ExtensionAttribute]
public static FSharpOption`1<T> AsFSharpOption(T value);
    [ExtensionAttribute]
public static T ValueIfNone(FSharpOption`1<T> option, T value);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetSomes(IEnumerable`1<FSharpOption`1<T>> options);
    [ExtensionAttribute]
public static T DefaultIfNone(FSharpOption`1<T> option);
    [ExtensionAttribute]
public static string EmptyIfNone(FSharpOption`1<string> option);
    [ExtensionAttribute]
public static IEnumerable`1<FSharpOption`1<T>> AsOptionEnumerable(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static IEnumerable`1<TTarget> MapSomes(IEnumerable`1<TSource> source, IMapper`2<TSource, TTarget> mapper);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.MapperExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<FSharpOption`1<TTarget>> Map(IMapper`2<TSource, TTarget> mapper, IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TTarget> MapAndGetSomes(IMapper`2<TSource, TTarget> mapper, IEnumerable`1<TSource> source);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.ParameterValidationExtensions : object {
    [ExtensionAttribute]
public static void ThrowIfNull(object parameter, string parameterName);
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsNotNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsNotNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static string StripWhitespaces(string value);
    [ExtensionAttribute]
public static String[] SplitByString(string value, string separator, StringSplitOptions options);
}
public class SpecFlow.Plus.Shared.Models.Error`1 : object {
    [CompilerGeneratedAttribute]
private T <Description>k__BackingField;
    public T Description { get; }
    public Error`1(T description);
    [CompilerGeneratedAttribute]
public T get_Description();
}
public interface SpecFlow.Plus.Shared.Models.IUriCleaner {
    public abstract virtual string StripSchema(string uri);
    public abstract virtual string ConvertSlashes(string actualUri);
}
public class SpecFlow.Plus.Shared.Models.LicenseInfo : object {
    [CompilerGeneratedAttribute]
private string <LicenseKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuedTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ValidUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CanUpgradeUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseType <LicenseType>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <LicenseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresActivation>k__BackingField;
    public string LicenseKey { get; }
    public string IssuedTo { get; }
    public Nullable`1<DateTime> ValidUntil { get; }
    public Nullable`1<DateTime> CanUpgradeUntil { get; }
    public LicenseType LicenseType { get; }
    public byte LicenseVersion { get; }
    public bool RequiresActivation { get; }
    public LicenseInfo(string licenseKey, string issuedTo, byte licenseVersion, bool requiresActivation, Nullable`1<DateTime> validUntil, Nullable`1<DateTime> canUpgradeUntil, LicenseType licenseType);
    [CompilerGeneratedAttribute]
public string get_LicenseKey();
    [CompilerGeneratedAttribute]
public string get_IssuedTo();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ValidUntil();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CanUpgradeUntil();
    [CompilerGeneratedAttribute]
public LicenseType get_LicenseType();
    [CompilerGeneratedAttribute]
public byte get_LicenseVersion();
    [CompilerGeneratedAttribute]
public bool get_RequiresActivation();
}
public enum SpecFlow.Plus.Shared.Models.LicenseType : Enum {
    public byte value__;
    public static LicenseType SpecFlowPlusSeatLicense;
    public static LicenseType SpecFlowPlusProjectLicense;
    public static LicenseType SpecFlowPlusOemLicense;
}
public class SpecFlow.Plus.Shared.Models.LicenseValidationInfo : object {
    [CompilerGeneratedAttribute]
private FSharpOption`1<LicenseInfo> <LicenseInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmbeddedMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValidTestAssemblyPaths>k__BackingField;
    public FSharpOption`1<LicenseInfo> LicenseInfo { get; }
    public bool IsEmbeddedMode { get; }
    public bool HasValidTestAssemblyPaths { get; }
    public LicenseValidationInfo(FSharpOption`1<LicenseInfo> licenseInfo);
    public LicenseValidationInfo(FSharpOption`1<LicenseInfo> licenseInfo, bool isEmbeddedMode, bool hasValidTestAssemblyPaths);
    [CompilerGeneratedAttribute]
public FSharpOption`1<LicenseInfo> get_LicenseInfo();
    [CompilerGeneratedAttribute]
public bool get_IsEmbeddedMode();
    [CompilerGeneratedAttribute]
public bool get_HasValidTestAssemblyPaths();
}
public class SpecFlow.Plus.Shared.Models.StorageLicenseInfo : object {
    [CompilerGeneratedAttribute]
private string <LicenseKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuedTo>k__BackingField;
    public string LicenseKey { get; }
    public string IssuedTo { get; }
    public StorageLicenseInfo(string licenseKey, string issuedTo);
    [CompilerGeneratedAttribute]
public string get_LicenseKey();
    [CompilerGeneratedAttribute]
public string get_IssuedTo();
}
public class SpecFlow.Plus.Shared.Models.Validation.BuildServerLicenseResult : ValidateLicenseResult {
}
public class SpecFlow.Plus.Shared.Models.Validation.ContainerLicenseResult : ValidateLicenseResult {
}
public class SpecFlow.Plus.Shared.Models.Validation.EvalModeLicenseResult : ValidateLicenseResult {
}
public class SpecFlow.Plus.Shared.Models.Validation.ExpiredValidateLicenseResult : InvalidLicenseResult {
    [CompilerGeneratedAttribute]
private DateTime <ExpiredSince>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CanUpgradeUntil>k__BackingField;
    public DateTime ExpiredSince { get; }
    public Nullable`1<DateTime> CanUpgradeUntil { get; }
    public ExpiredValidateLicenseResult(string licenseKey, string issuedTo, DateTime expiredSince, Nullable`1<DateTime> canUpgradeUntil);
    [CompilerGeneratedAttribute]
public DateTime get_ExpiredSince();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CanUpgradeUntil();
}
public abstract class SpecFlow.Plus.Shared.Models.Validation.InvalidLicenseResult : ValidateLicenseResult {
    [CompilerGeneratedAttribute]
private string <IssuedTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseKey>k__BackingField;
    public string IssuedTo { get; }
    public string LicenseKey { get; }
    protected InvalidLicenseResult(string licenseKey, string issuedTo);
    [CompilerGeneratedAttribute]
public string get_IssuedTo();
    [CompilerGeneratedAttribute]
public string get_LicenseKey();
}
public class SpecFlow.Plus.Shared.Models.Validation.InvalidProjectLicenseResult : InvalidLicenseResult {
    public InvalidProjectLicenseResult(string licenseKey, string issuedTo);
}
public class SpecFlow.Plus.Shared.Models.Validation.OemLicenseNotInEmbeddedModeResult : InvalidLicenseResult {
    public OemLicenseNotInEmbeddedModeResult(string licenseKey, string issuedTo);
}
public class SpecFlow.Plus.Shared.Models.Validation.UpgradeExpiredLicenseResult : InvalidLicenseResult {
    [CompilerGeneratedAttribute]
private DateTime <ExpiredSince>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <UpgradeExpiredSince>k__BackingField;
    public DateTime ExpiredSince { get; }
    public DateTime UpgradeExpiredSince { get; }
    public UpgradeExpiredLicenseResult(string licenseKey, string issuedTo, DateTime expiredSince, DateTime upgradeExpiredSince);
    [CompilerGeneratedAttribute]
public DateTime get_ExpiredSince();
    [CompilerGeneratedAttribute]
public DateTime get_UpgradeExpiredSince();
}
public abstract class SpecFlow.Plus.Shared.Models.Validation.ValidateLicenseResult : object {
}
public class SpecFlow.Plus.Shared.Models.Validation.ValidLicenseForProjectResult : ValidLicenseResult {
    [CompilerGeneratedAttribute]
private string <IssuedToProject>k__BackingField;
    public string IssuedToProject { get; }
    public ValidLicenseForProjectResult(string licenseKey, string issuedToProject, Nullable`1<DateTime> validUntil);
    [CompilerGeneratedAttribute]
public string get_IssuedToProject();
}
public class SpecFlow.Plus.Shared.Models.Validation.ValidLicenseForUserResult : ValidateLicenseResult {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ValidUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuedTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseKey>k__BackingField;
    public Nullable`1<DateTime> ValidUntil { get; }
    public string IssuedTo { get; }
    public string LicenseKey { get; }
    public ValidLicenseForUserResult(string licenseKey, string issuedTo, Nullable`1<DateTime> validUntil);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ValidUntil();
    [CompilerGeneratedAttribute]
public string get_IssuedTo();
    [CompilerGeneratedAttribute]
public string get_LicenseKey();
}
public abstract class SpecFlow.Plus.Shared.Models.Validation.ValidLicenseResult : ValidateLicenseResult {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ValidUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseKey>k__BackingField;
    public Nullable`1<DateTime> ValidUntil { get; }
    public string LicenseKey { get; }
    protected ValidLicenseResult(string licenseKey, Nullable`1<DateTime> validUntil);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ValidUntil();
    [CompilerGeneratedAttribute]
public string get_LicenseKey();
}
public class SpecFlow.Plus.Shared.Models.Validation.ValidOemLicenseResult : ValidLicenseResult {
    [CompilerGeneratedAttribute]
private string <IssuedTo>k__BackingField;
    public string IssuedTo { get; }
    public ValidOemLicenseResult(string licenseKey, string issuedTo, Nullable`1<DateTime> validUntil);
    [CompilerGeneratedAttribute]
public string get_IssuedTo();
}
public class SpecFlow.Plus.Shared.ResultModel.ExceptionFailure : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionFailure(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    public virtual string ToString();
}
public class SpecFlow.Plus.Shared.ResultModel.ExceptionFailure`1 : ExceptionFailure {
    public ExceptionFailure`1(Exception exception);
}
public class SpecFlow.Plus.Shared.ResultModel.Failure : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public Failure(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    public virtual string ToString();
}
public class SpecFlow.Plus.Shared.ResultModel.Failure`1 : Failure {
    public Failure`1(string description);
}
public interface SpecFlow.Plus.Shared.ResultModel.IFailure {
}
public interface SpecFlow.Plus.Shared.ResultModel.IFailure`1 {
}
public interface SpecFlow.Plus.Shared.ResultModel.IResult {
}
public interface SpecFlow.Plus.Shared.ResultModel.IResult`1 {
}
public interface SpecFlow.Plus.Shared.ResultModel.ISuccess {
}
public interface SpecFlow.Plus.Shared.ResultModel.ISuccess`1 {
    public T Result { get; }
    public abstract virtual T get_Result();
}
public static class SpecFlow.Plus.Shared.ResultModel.Result : object {
    public static ISuccess Success();
    public static IFailure Failure(string description);
    public static IFailure Failure(Exception exception);
    public static IFailure Failure(string description, IFailure innerFailure);
    public static IFailure Failure(Exception exception, IFailure innerFailure);
    public static IFailure Failure(Exception[] exceptions);
}
public static class SpecFlow.Plus.Shared.ResultModel.Result`1 : object {
    public static ISuccess`1<T> Success(T value);
    public static IFailure`1<T> Failure(string description);
    public static IFailure`1<T> Failure(Exception exception);
    public static IFailure`1<T> Failure(string description, IFailure innerFailure);
    public static IFailure`1<T> Failure(Exception exception, IFailure innerFailure);
    public static IFailure`1<T> Failure(Exception[] exceptions);
}
public class SpecFlow.Plus.Shared.ResultModel.Success : object {
}
public class SpecFlow.Plus.Shared.ResultModel.Success`1 : Success {
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public T Result { get; }
    public Success`1(T result);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Result();
}
public class SpecFlow.Plus.Shared.ResultModel.WrappedExceptionFailure : ExceptionFailure {
    [CompilerGeneratedAttribute]
private IFailure <InnerFailure>k__BackingField;
    public IFailure InnerFailure { get; }
    public WrappedExceptionFailure(Exception exception, IFailure innerFailure);
    [CompilerGeneratedAttribute]
public IFailure get_InnerFailure();
    public string GetStringOfInnerFailure();
    public virtual string ToString();
}
public class SpecFlow.Plus.Shared.ResultModel.WrappedExceptionFailure`1 : WrappedExceptionFailure {
    public WrappedExceptionFailure`1(Exception exception, IFailure innerFailure);
}
public class SpecFlow.Plus.Shared.ResultModel.WrappedFailure : Failure {
    [CompilerGeneratedAttribute]
private IFailure <InnerFailure>k__BackingField;
    public IFailure InnerFailure { get; }
    public WrappedFailure(string description, IFailure innerFailure);
    [CompilerGeneratedAttribute]
public IFailure get_InnerFailure();
    public string GetStringOfInnerFailure();
    public virtual string ToString();
}
public class SpecFlow.Plus.Shared.ResultModel.WrappedFailure`1 : WrappedFailure {
    public WrappedFailure`1(string description, IFailure innerFailure);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationConfiguration : object {
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformBaseUrl>k__BackingField;
    public string ProductName { get; public set; }
    public string PlatformBaseUrl { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PlatformBaseUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PlatformBaseUrl(string value);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationData : object {
    [CompilerGeneratedAttribute]
private Guid <UserEnvironmentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActivationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    public Guid UserEnvironmentId { get; public set; }
    public string ActivationToken { get; public set; }
    public string UserName { get; public set; }
    public string MachineName { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_UserEnvironmentId();
    [CompilerGeneratedAttribute]
public void set_UserEnvironmentId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ActivationToken();
    [CompilerGeneratedAttribute]
public void set_ActivationToken(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationDataStore : object {
    private static string DirectoryName;
    public static string FileName;
    private IFileSystemService _fileSystemService;
    private IEnvironment _environment;
    private ILogger _logger;
    public ActivationDataStore(IFileSystemService fileSystemService, IEnvironment environment, ILogger logger);
    public sealed virtual ActivationData Load();
    private FSharpOption`1<string> LoadFromFile();
    private ActivationData Parse(string content);
    private FSharpOption`1<string> GetFilePath();
    public sealed virtual void Save(ActivationData activationData);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationDataValidator : object {
    private IActivationTokenReader _activationTokenReader;
    public ActivationDataValidator(IActivationTokenReader activationTokenReader);
    public sealed virtual IResult Validate(ActivationData activationData, ProductInstanceId productInstanceId);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationException : Exception {
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationService : object {
    private IActivationDataStore _activationDataStore;
    private ILegacyLicenseValidationFacade _legacyLicenseValidationFacade;
    private IActivationDataValidator _activationDataValidator;
    private IActivationPlatformClient _platformClient;
    private IProductInstanceIdBuilder _productInstanceIdBuilder;
    private IEnvironment _environment;
    private ILogger _logger;
    private IAnalyticsTransmitter _analyticsTransmitter;
    public ActivationService(IActivationDataStore activationDataStore, IActivationDataValidator activationDataValidator, ILegacyLicenseValidationFacade legacyLicenseValidationFacade, IActivationPlatformClient platformClient, IProductInstanceIdBuilder productInstanceIdBuilder, IEnvironment environment, ILogger logger, IAnalyticsTransmitter analyticsTransmitter);
    public sealed virtual ActivationValidationResult Validate();
    private ActivationValidationResult NeedsActivation(ProductInstanceId productInstanceId, LegacyLicenseValidationResult legacyLicenseValidationResult);
    private ActivationValidationResult ValidateActivationData(ActivationData activationData, ProductInstanceId productInstanceId);
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationValidationResult : object {
    [CompilerGeneratedAttribute]
private ActivationValidationResultType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyLicenseValidationResult <LegacyLicenseValidationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ActivationUri>k__BackingField;
    public ActivationValidationResultType Type { get; public set; }
    public bool Success { get; }
    public LegacyLicenseValidationResult LegacyLicenseValidationResult { get; public set; }
    public Uri ActivationUri { get; public set; }
    [CompilerGeneratedAttribute]
public ActivationValidationResultType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ActivationValidationResultType value);
    public bool get_Success();
    [CompilerGeneratedAttribute]
public LegacyLicenseValidationResult get_LegacyLicenseValidationResult();
    [CompilerGeneratedAttribute]
public void set_LegacyLicenseValidationResult(LegacyLicenseValidationResult value);
    [CompilerGeneratedAttribute]
public Uri get_ActivationUri();
    [CompilerGeneratedAttribute]
public void set_ActivationUri(Uri value);
    public static ActivationValidationResult ValidLegacyLicense(LegacyLicenseValidationResult legacyLicenseValidationResult);
    public static ActivationValidationResult InvalidActivationToken();
    public static ActivationValidationResult NeedsActivation(LegacyLicenseValidationResult legacyLicenseValidationResult, Uri activationUri);
    public static ActivationValidationResult Activated();
}
public class SpecFlow.Plus.Shared.Services.Activation.ActivationValidationResultOutput : object {
    private IValidateLicenseResultOutput _licenseValidationResultOutput;
    private ILogger _logger;
    private static string Separator;
    private static string Header;
    public ActivationValidationResultOutput(IValidateLicenseResultOutput licenseValidationResultOutput, ILogger logger);
    public sealed virtual void Write(ActivationValidationResult validationResult);
    private void WriteActivationMainTextWithActivationUrl(Uri activationUri);
    private void WriteActivationLicenseExpiredHint();
    private void WriteActivationBuildAgentHint();
    private void WriteActivationHeader();
    private void WriteActivationFooter();
}
public enum SpecFlow.Plus.Shared.Services.Activation.ActivationValidationResultType : Enum {
    public int value__;
    public static ActivationValidationResultType Activated;
    public static ActivationValidationResultType NeedsActivation;
    public static ActivationValidationResultType ValidLegacyLicense;
    public static ActivationValidationResultType InvalidActivationToken;
}
public interface SpecFlow.Plus.Shared.Services.Activation.IActivationConfiguration {
    public string ProductName { get; }
    public string PlatformBaseUrl { get; public set; }
    public abstract virtual string get_ProductName();
    public abstract virtual string get_PlatformBaseUrl();
    public abstract virtual void set_PlatformBaseUrl(string value);
}
public interface SpecFlow.Plus.Shared.Services.Activation.IActivationDataStore {
    public abstract virtual ActivationData Load();
    public abstract virtual void Save(ActivationData activationData);
}
public interface SpecFlow.Plus.Shared.Services.Activation.IActivationDataValidator {
    public abstract virtual IResult Validate(ActivationData activationData, ProductInstanceId productInstanceId);
}
public interface SpecFlow.Plus.Shared.Services.Activation.IActivationService {
    public abstract virtual ActivationValidationResult Validate();
}
public interface SpecFlow.Plus.Shared.Services.Activation.IActivationValidationResultOutput {
    public abstract virtual void Write(ActivationValidationResult activationResult);
}
public interface SpecFlow.Plus.Shared.Services.Activation.ILegacyLicenseValidationFacade {
    public abstract virtual LegacyLicenseValidationResult ValidateLegacyLicenseForExecution();
}
public interface SpecFlow.Plus.Shared.Services.Activation.IProductInstanceIdBuilder {
    public abstract virtual ProductInstanceId Build(Guid userEnvironmentId);
}
public class SpecFlow.Plus.Shared.Services.Activation.LegacyLicenseValidationFacade : object {
    private ILicenseService _licenseService;
    private ILicenseValidationService _licenseValidationService;
    public LegacyLicenseValidationFacade(ILicenseService licenseService, ILicenseValidationService licenseValidationService);
    public sealed virtual LegacyLicenseValidationResult ValidateLegacyLicenseForExecution();
    private static bool CalculateSuccess(ValidateLicenseResult validateLicenseResult);
}
public class SpecFlow.Plus.Shared.Services.Activation.LegacyLicenseValidationResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLegacyLicense>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidateLicenseResult <LegacyResult>k__BackingField;
    public bool Success { get; public set; }
    public bool HasLegacyLicense { get; public set; }
    public ValidateLicenseResult LegacyResult { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasLegacyLicense();
    [CompilerGeneratedAttribute]
public void set_HasLegacyLicense(bool value);
    [CompilerGeneratedAttribute]
public ValidateLicenseResult get_LegacyResult();
    [CompilerGeneratedAttribute]
public void set_LegacyResult(ValidateLicenseResult value);
}
public class SpecFlow.Plus.Shared.Services.Activation.Platform.ActivationPlatformClient : object {
    private IActivationPlatformUrlBuilder _activationPlatformUrlBuilder;
    private IHttpClientProvider _httpClientProvider;
    private IAnalyticsTransmitter _analyticsTransmitter;
    public ActivationPlatformClient(IActivationPlatformUrlBuilder activationPlatformUrlBuilder, IHttpClientProvider httpClientProvider, IAnalyticsTransmitter analyticsTransmitter);
    public sealed virtual string FetchActivationToken(ProductInstanceId productInstanceId);
    public sealed virtual Uri BuildActivationUri(ProductInstanceId productInstanceId, bool hasLegacyLicense);
}
public class SpecFlow.Plus.Shared.Services.Activation.Platform.ActivationPlatformUrlBuilder : object {
    private IActivationConfiguration _activationConfigurationObject;
    public ActivationPlatformUrlBuilder(IActivationConfiguration activationConfigurationObject);
    public sealed virtual Uri BuildActivationUri(ProductInstanceId productInstanceId, ActivationState activationState);
    public sealed virtual Uri BuildFetchUri(ProductInstanceId productInstanceId);
}
public enum SpecFlow.Plus.Shared.Services.Activation.Platform.ActivationState : Enum {
    public int value__;
    public static ActivationState NotActivatedYet;
    public static ActivationState LicenseExpired;
}
public interface SpecFlow.Plus.Shared.Services.Activation.Platform.IActivationPlatformClient {
    public abstract virtual string FetchActivationToken(ProductInstanceId productInstanceId);
    public abstract virtual Uri BuildActivationUri(ProductInstanceId productInstanceId, bool hasLegacyLicense);
}
public interface SpecFlow.Plus.Shared.Services.Activation.Platform.IActivationPlatformUrlBuilder {
    public abstract virtual Uri BuildActivationUri(ProductInstanceId productInstanceId, ActivationState activationState);
    public abstract virtual Uri BuildFetchUri(ProductInstanceId productInstanceId);
}
public class SpecFlow.Plus.Shared.Services.Activation.ProductInstanceId : object {
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <LegacyValues>k__BackingField;
    public string ProductName { get; public set; }
    public string CurrentValue { get; public set; }
    public List`1<string> LegacyValues { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentValue();
    [CompilerGeneratedAttribute]
public void set_CurrentValue(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_LegacyValues();
    [CompilerGeneratedAttribute]
public void set_LegacyValues(List`1<string> value);
}
public class SpecFlow.Plus.Shared.Services.Activation.ProductInstanceIdBuilder : object {
    private IEnvironment _environment;
    private IActivationConfiguration _activationConfiguration;
    public ProductInstanceIdBuilder(IEnvironment environment, IActivationConfiguration activationConfiguration);
    public sealed virtual ProductInstanceId Build(Guid userEnvironmentId);
    private static string BuildPrefix(Guid userEnvironmentId);
    private string BuildCurrentPostfix();
    private string BuildLegacyPostfix();
    private string BuildPostfix(string machineName, string userName);
}
public class SpecFlow.Plus.Shared.Services.Activation.Token.ActivationTokenData : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountTelemetryId>k__BackingField;
    public int Version { get; public set; }
    public string ProductName { get; public set; }
    public string ProductInstanceId { get; public set; }
    public string AccountTelemetryId { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public string get_ProductInstanceId();
    [CompilerGeneratedAttribute]
public void set_ProductInstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_AccountTelemetryId();
    [CompilerGeneratedAttribute]
public void set_AccountTelemetryId(string value);
}
public class SpecFlow.Plus.Shared.Services.Activation.Token.ActivationTokenJwtValidator : object {
    private ILogger _logger;
    public ActivationTokenJwtValidator(ILogger logger);
    public sealed virtual JwtSecurityToken Validate(string token);
    private static RSA LoadRsa();
}
public class SpecFlow.Plus.Shared.Services.Activation.Token.ActivationTokenReader : object {
    private IActivationTokenJwtValidator _activationTokenJwtValidator;
    public ActivationTokenReader(IActivationTokenJwtValidator activationTokenJwtValidator);
    public sealed virtual ActivationTokenData Read(string token);
    private ActivationTokenData BuildTokenData(JwtSecurityToken jwtSecurityToken);
    private T GetClaimValue(JwtSecurityToken jwtSecurityToken, string claimType);
}
public interface SpecFlow.Plus.Shared.Services.Activation.Token.IActivationTokenJwtValidator {
    public abstract virtual JwtSecurityToken Validate(string token);
}
public interface SpecFlow.Plus.Shared.Services.Activation.Token.IActivationTokenReader {
    public abstract virtual ActivationTokenData Read(string token);
}
[ExtensionAttribute]
internal static class SpecFlow.Plus.Shared.Services.Activation.Token.RSAKeyExtensions : object {
    [ExtensionAttribute]
public static void FromXmlString(RSA rsa, string xmlString);
    [ExtensionAttribute]
public static string ToXmlString(RSA rsa, bool includePrivateParameters);
}
public class SpecFlow.Plus.Shared.Services.Analytics.AnalyticsTransmitter : object {
    private IAnalyticsTransmitterSink _analyticsTransmitterSink;
    private IActivationTokenReader _activationTokenReader;
    private IActivationDataStore _activationDataStore;
    private ISpecFlowUserIdStore _specFlowUserIdStore;
    private IEnvironment _environment;
    private IExecutionEnvironment _executionEnvironment;
    private ILogger _logger;
    private IVersionInfoProvider _versionInfoProvider;
    public AnalyticsTransmitter(IAnalyticsTransmitterSink analyticsTransmitterSink, IActivationTokenReader activationTokenReader, IActivationDataStore activationDataStore, ISpecFlowUserIdStore specFlowUserIdStore, IEnvironment environment, IExecutionEnvironment executionEnvironment, ILogger logger, IVersionInfoProvider versionInfoProvider);
    private string GetAccountTelemetryId();
    private void AddVersionNumberProperty(IAnalyticsEvent analyticsEvent);
    private void AddEnviromentProperties(IAnalyticsEvent analyticsEvent);
    public sealed virtual IResult TransmitActivationEvent(ProductInstanceId productInstanceId, IAnalyticsEvent analyticsEvent);
    [AsyncStateMachineAttribute("SpecFlow.Plus.Shared.Services.Analytics.AnalyticsTransmitter/<TransmitRuntimeEvent>d__13")]
public sealed virtual Task`1<IResult> TransmitRuntimeEvent(IAnalyticsEvent runtimeEvent);
}
public class SpecFlow.Plus.Shared.Services.Analytics.AppInsightsConfiguration : object {
    [CompilerGeneratedAttribute]
private string <InstrumentationKey>k__BackingField;
    public string InstrumentationKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_InstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_InstrumentationKey(string value);
}
public class SpecFlow.Plus.Shared.Services.Analytics.AppInsightsEventTelemetry : object {
    [CompilerGeneratedAttribute]
private string <DataTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstrumentationKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryData <TelemetryData>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <TelemetryTags>k__BackingField;
    private static string DefaultValue;
    [JsonPropertyAttribute("name")]
public string DataTypeName { get; public set; }
    [JsonPropertyAttribute("time")]
public string EventDateTime { get; public set; }
    [JsonPropertyAttribute("iKey")]
public string InstrumentationKey { get; public set; }
    [JsonPropertyAttribute("data")]
public TelemetryData TelemetryData { get; public set; }
    [JsonPropertyAttribute("tags")]
public Dictionary`2<string, string> TelemetryTags { get; public set; }
    public AppInsightsEventTelemetry(string userId, string instrumentationKey, IAnalyticsEvent analyticsEvent);
    [CompilerGeneratedAttribute]
public string get_DataTypeName();
    [CompilerGeneratedAttribute]
public void set_DataTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_EventDateTime();
    [CompilerGeneratedAttribute]
public void set_EventDateTime(string value);
    [CompilerGeneratedAttribute]
public string get_InstrumentationKey();
    [CompilerGeneratedAttribute]
public void set_InstrumentationKey(string value);
    [CompilerGeneratedAttribute]
public TelemetryData get_TelemetryData();
    [CompilerGeneratedAttribute]
public void set_TelemetryData(TelemetryData value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_TelemetryTags();
    [CompilerGeneratedAttribute]
public void set_TelemetryTags(Dictionary`2<string, string> value);
    private string GetOSPlatform();
}
public class SpecFlow.Plus.Shared.Services.Analytics.GenericEvent : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public string EventName { get; }
    public Dictionary`2<string, string> Properties { get; }
    public GenericEvent(string eventName, Dictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventName();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Properties();
}
public class SpecFlow.Plus.Shared.Services.Analytics.HttpClientAnalyticsTransmitterSink : object {
    private Uri _appInsightsDataCollectionEndPoint;
    private IHttpClientProvider _httpClientProvider;
    private AppInsightsConfiguration _appInsightsConfiguration;
    private ILogger _logger;
    public HttpClientAnalyticsTransmitterSink(IHttpClientProvider httpClientProvider, AppInsightsConfiguration appInsightsConfiguration, ILogger logger);
    [AsyncStateMachineAttribute("SpecFlow.Plus.Shared.Services.Analytics.HttpClientAnalyticsTransmitterSink/<TransmitEvent>d__5")]
public sealed virtual Task`1<IResult> TransmitEvent(IAnalyticsEvent analyticsEvent, string userId);
    [AsyncStateMachineAttribute("SpecFlow.Plus.Shared.Services.Analytics.HttpClientAnalyticsTransmitterSink/<TransmitEventAsync>d__6")]
private Task TransmitEventAsync(IAnalyticsEvent analyticsEvent, string userId);
}
public interface SpecFlow.Plus.Shared.Services.Analytics.IAnalyticsEvent {
    public string EventName { get; }
    public Dictionary`2<string, string> Properties { get; }
    public abstract virtual string get_EventName();
    public abstract virtual Dictionary`2<string, string> get_Properties();
}
public interface SpecFlow.Plus.Shared.Services.Analytics.IAnalyticsTransmitter {
    public abstract virtual IResult TransmitActivationEvent(ProductInstanceId productInstanceId, IAnalyticsEvent analyticsEvent);
    public abstract virtual Task`1<IResult> TransmitRuntimeEvent(IAnalyticsEvent runtimeEvent);
}
public interface SpecFlow.Plus.Shared.Services.Analytics.IAnalyticsTransmitterSink {
    public abstract virtual Task`1<IResult> TransmitEvent(IAnalyticsEvent analyticsEvent, string userId);
}
public interface SpecFlow.Plus.Shared.Services.Analytics.SpecFlowUserId.ISpecFlowUserIdStore {
    public abstract virtual string GetUserId();
}
public class SpecFlow.Plus.Shared.Services.Analytics.SpecFlowUserId.SpecFlowUserIdStore : object {
    private static string appDataFolder;
    public static string UserIdFilePath;
    private Lazy`1<string> _lazyUniqueUserId;
    private IFileSystemService _fileService;
    public SpecFlowUserIdStore(IFileSystemService fileService);
    private static SpecFlowUserIdStore();
    public sealed virtual string GetUserId();
    private string FetchAndPersistUserId();
    private string GenerateAndPersistUserId();
    private void PersistUserId(string userId);
    private bool IsValidGuid(string guid);
}
public class SpecFlow.Plus.Shared.Services.Analytics.TelemetryData : object {
    [CompilerGeneratedAttribute]
private string <ItemTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryDataItem <TelemetryDataItem>k__BackingField;
    [JsonPropertyAttribute("baseType")]
public string ItemTypeName { get; public set; }
    [JsonPropertyAttribute("baseData")]
public TelemetryDataItem TelemetryDataItem { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ItemTypeName();
    [CompilerGeneratedAttribute]
public void set_ItemTypeName(string value);
    [CompilerGeneratedAttribute]
public TelemetryDataItem get_TelemetryDataItem();
    [CompilerGeneratedAttribute]
public void set_TelemetryDataItem(TelemetryDataItem value);
}
public class SpecFlow.Plus.Shared.Services.Analytics.TelemetryDataItem : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [JsonPropertyAttribute("ver")]
public string EndPointSchemaVersion { get; }
    [JsonPropertyAttribute("name")]
public string EventName { get; public set; }
    [JsonPropertyAttribute("properties")]
public Dictionary`2<string, string> Properties { get; public set; }
    public string get_EndPointSchemaVersion();
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
}
public class SpecFlow.Plus.Shared.Services.Configuration.ConsoleOutputConfiguration : object {
    [CompilerGeneratedAttribute]
private ConsoleColor <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <DefaultColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <ErrorColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <WarningColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <InfoColor>k__BackingField;
    [CompilerGeneratedAttribute]
private FSharpOption`1<Encoding> <ConsoleOutputEncoding>k__BackingField;
    public ConsoleColor BackgroundColor { get; }
    public ConsoleColor DefaultColor { get; }
    public ConsoleColor ErrorColor { get; }
    public ConsoleColor WarningColor { get; }
    public ConsoleColor InfoColor { get; }
    public FSharpOption`1<Encoding> ConsoleOutputEncoding { get; }
    public ConsoleOutputConfiguration(ConsoleColor backgroundColor, ConsoleColor defaultColor, ConsoleColor errorColor, ConsoleColor warningColor, ConsoleColor infoColor, FSharpOption`1<Encoding> consoleOutputEncoding);
    [CompilerGeneratedAttribute]
public ConsoleColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public ConsoleColor get_DefaultColor();
    [CompilerGeneratedAttribute]
public ConsoleColor get_ErrorColor();
    [CompilerGeneratedAttribute]
public ConsoleColor get_WarningColor();
    [CompilerGeneratedAttribute]
public ConsoleColor get_InfoColor();
    [CompilerGeneratedAttribute]
public FSharpOption`1<Encoding> get_ConsoleOutputEncoding();
}
public class SpecFlow.Plus.Shared.Services.DateTimeOutputFormatter : object {
    public sealed virtual string ToString(DateTime value);
}
public class SpecFlow.Plus.Shared.Services.Http.HttpClientProvider : object {
    private static HttpClient Client;
    public static string SpecflowPlusUseProxyCredentials;
    private ILogger _logger;
    private static bool UseProxyCredentials { get; }
    private static HttpClientProvider();
    public HttpClientProvider(ILogger logger);
    private static bool get_UseProxyCredentials();
    public sealed virtual HttpResultString GetString(Uri requestUri);
    [AsyncStateMachineAttribute("SpecFlow.Plus.Shared.Services.Http.HttpClientProvider/<GetStringAsync>d__8")]
private Task`1<HttpResultString> GetStringAsync(Uri requestUri);
    public sealed virtual HttpResultString PostString(Uri requestUri, string content);
    [AsyncStateMachineAttribute("SpecFlow.Plus.Shared.Services.Http.HttpClientProvider/<PostStringAsync>d__10")]
public sealed virtual Task`1<HttpResultString> PostStringAsync(Uri requestUri, string content);
}
public class SpecFlow.Plus.Shared.Services.Http.HttpResultString : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public bool Success { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
public interface SpecFlow.Plus.Shared.Services.Http.IHttpClientProvider {
    public abstract virtual HttpResultString GetString(Uri requestUri);
    public abstract virtual HttpResultString PostString(Uri requestUri, string content);
    public abstract virtual Task`1<HttpResultString> PostStringAsync(Uri requestUri, string content);
}
public interface SpecFlow.Plus.Shared.Services.IAssemblyFolderHelper {
    public abstract virtual string GetTestAssemblyFolder(Assembly assembly);
}
public interface SpecFlow.Plus.Shared.Services.ICurrentThreadService {
    public abstract virtual bool SetNameIfNull(string name);
    public abstract virtual string GetName();
}
public interface SpecFlow.Plus.Shared.Services.IEnvironment {
    public bool Is64BitProcess { get; }
    public Version Version { get; }
    public string DotNetCoreVersion { get; }
    public bool IsRunningInContainer { get; }
    public string CurrentDirectory { get; public set; }
    public string ProgramFilesPath { get; }
    public PlatformID Platform { get; }
    public string MachineName { get; }
    public string MachineNameLowerCase { get; }
    public string UserName { get; }
    public string UserNameLowerCase { get; }
    public string LocalAppDataPath { get; }
    public abstract virtual bool get_Is64BitProcess();
    public abstract virtual Version get_Version();
    public abstract virtual string get_DotNetCoreVersion();
    public abstract virtual bool get_IsRunningInContainer();
    public abstract virtual string GetEnvironmentVariable(string variable);
    public abstract virtual string get_CurrentDirectory();
    public abstract virtual void set_CurrentDirectory(string value);
    public abstract virtual void SetProcessScopeVariable(string name, string value);
    public abstract virtual string get_ProgramFilesPath();
    public abstract virtual PlatformID get_Platform();
    public abstract virtual string get_MachineName();
    public abstract virtual string get_MachineNameLowerCase();
    public abstract virtual string get_UserName();
    public abstract virtual string get_UserNameLowerCase();
    public abstract virtual string get_LocalAppDataPath();
}
public interface SpecFlow.Plus.Shared.Services.IFileNameService {
    public abstract virtual IEnumerable`1<string> GetNumberedFileNames(string fileNamePattern, int startNumber);
    public abstract virtual IEnumerable`1<string> GetNumberedFileNames(string fileNamePattern, int startNumber, int count);
    public abstract virtual FSharpOption`1<string> GetParentDirectory(FSharpOption`1<string> fileName);
    public abstract virtual FSharpOption`1<string> GetFileName(FSharpOption`1<string> filePath);
    public abstract virtual FSharpOption`1<string> GetFileNameWithoutExtension(FSharpOption`1<string> fileName);
    public abstract virtual FSharpOption`1<string> GetFileExtension(FSharpOption`1<string> fileName);
    public abstract virtual FSharpOption`1<string> ReplaceExtension(FSharpOption`1<string> fileName, FSharpOption`1<string> extension);
}
public interface SpecFlow.Plus.Shared.Services.IFileSystemService {
    public abstract virtual bool FileExists(string filePath);
    public abstract virtual bool FileExists(FSharpOption`1<string> filePathOption);
    public abstract virtual FSharpOption`1<IEnumerable`1<string>> ReadLinesFromFile(string filePath);
    public abstract virtual FSharpOption`1<string> ReadStringFromFile(FSharpOption`1<string> filePath);
    public abstract virtual FSharpOption`1<string> ReadStringFromFile(FSharpOption`1<string> filePath, FSharpOption`1<Encoding> encoding);
    public abstract virtual bool WriteLinesToFile(string filePath, IEnumerable`1<string> lines);
    public abstract virtual bool WriteStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> content);
    public abstract virtual bool ForceWriteStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> content);
    public abstract virtual bool AppendStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> contentToAppend);
    public abstract virtual FSharpOption`1<string> GetParentFolder(string path);
    public abstract virtual FSharpOption`1<string> GetParentFolder(FSharpOption`1<string> pathOption);
    public abstract virtual bool CreateFolder(string path);
    public abstract virtual bool FolderExists(string path);
    public abstract virtual void DeleteFolder(string path);
    public abstract virtual bool CreateFolder(FSharpOption`1<string> pathOption);
    public abstract virtual bool FolderExists(FSharpOption`1<string> pathOption);
    public abstract virtual bool DeleteFolder(FSharpOption`1<string> pathOption);
    public abstract virtual string ResolveEnvironmentVariables(string source);
    public abstract virtual FSharpOption`1<string> ResolveEnvironmentVariables(FSharpOption`1<string> source);
    public abstract virtual bool DeleteFile(string filePath);
    public abstract virtual bool CopyFileToFolder(FSharpOption`1<string> sourceFilePath, FSharpOption`1<string> destinationFolderPath);
    public abstract virtual bool IsValidPath(FSharpOption`1<string> pathOption);
    public abstract virtual FSharpOption`1<Stream> CreateWriteStreamForFile(FSharpOption`1<string> filePathOption);
    public abstract virtual FSharpOption`1<string> CombinePaths(IEnumerable`1<FSharpOption`1<string>> paths);
    public abstract virtual FSharpOption`1<string> CombinePaths(FSharpOption`1[] paths);
    public abstract virtual FSharpOption`1<string> GetFullPath(FSharpOption`1<string> relativePath);
    public abstract virtual FSharpOption`1<string> GetFirstAvailableFileName(string fileNamePattern, int startNumber);
    public abstract virtual FSharpOption`1<string> GetFirstAvailableFileName(string fileNamePattern, int startNumber, int count);
    public abstract virtual IEnumerable`1<FileInfo> GetFilesInDirectory(string directoryPath);
    public abstract virtual IEnumerable`1<string> GetFullNamesOfFilesInDirectory(string directoryPath, string searchPattern);
    public abstract virtual string GetTempFileName();
}
public interface SpecFlow.Plus.Shared.Services.IJsonSerializer {
    public abstract virtual FSharpOption`1<T> Deserialize(FSharpOption`1<TextReader> source);
    public abstract virtual bool Serialize(T value, FSharpOption`1<TextWriter> target);
}
public interface SpecFlow.Plus.Shared.Services.IMapper`2 {
    public abstract virtual FSharpOption`1<TTo> Map(TFrom source);
}
public class SpecFlow.Plus.Shared.Services.Implementations.AssemblyFolderHelper : object {
    private IUriCleaner _uriCleaner;
    public AssemblyFolderHelper(IUriCleaner uriCleaner);
    public sealed virtual string GetTestAssemblyFolder(Assembly assembly);
}
public class SpecFlow.Plus.Shared.Services.Implementations.ConsoleOutputService : object {
    private static object SyncLock;
    private ConsoleOutputConfiguration _consoleOutputConfiguration;
    private ConsoleColor _resetForegroundColor;
    private ConsoleColor _resetBackgroundColor;
    public ConsoleOutputService(ConsoleOutputConfiguration consoleOutputConfiguration);
    private static ConsoleOutputService();
    public sealed virtual void Write(string value);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string value);
    public sealed virtual void WriteErrorLine(string value);
    public sealed virtual void WriteWarningLine(string value);
    public sealed virtual void WriteInfoLine(string value);
    private void WriteSync(string value, ConsoleColor bg, ConsoleColor fg);
    private void WriteLineSync(string value, ConsoleColor bg, ConsoleColor fg);
    private void SetColors(ConsoleColor background, ConsoleColor foreground);
    private void ResetColors();
}
public class SpecFlow.Plus.Shared.Services.Implementations.CurrentThreadService : object {
    public sealed virtual bool SetNameIfNull(string name);
    public sealed virtual string GetName();
}
[ExtensionAttribute]
public static class SpecFlow.Plus.Shared.Services.Implementations.DSACryptoServiceProviderExtensions : object {
    [ExtensionAttribute]
public static void ImportParametersFromXmlString(DSACryptoServiceProvider dsaCryptoServiceProvider, string xmlString);
    private static int ConvertByteArrayToInt(Byte[] input);
}
public class SpecFlow.Plus.Shared.Services.Implementations.DualLicenseRemovalService`2 : object {
    private T1 _first;
    private T2 _second;
    public DualLicenseRemovalService`2(T1 first, T2 second);
    public sealed virtual bool RemoveLicense();
}
public class SpecFlow.Plus.Shared.Services.Implementations.DualLicenseWriterService`2 : object {
    private T1 _first;
    private T2 _second;
    public DualLicenseWriterService`2(T1 first, T2 second);
    public sealed virtual bool WriteLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
public class SpecFlow.Plus.Shared.Services.Implementations.EnvironmentFacade : object {
    public bool Is64BitProcess { get; }
    public Version Version { get; }
    public string DotNetCoreVersion { get; }
    public bool IsRunningInContainer { get; }
    public string ProgramFilesPath { get; }
    public string CurrentDirectory { get; public set; }
    public PlatformID Platform { get; }
    public string MachineName { get; }
    public string MachineNameLowerCase { get; }
    public string UserName { get; }
    public string UserNameLowerCase { get; }
    public string LocalAppDataPath { get; }
    public sealed virtual bool get_Is64BitProcess();
    public sealed virtual Version get_Version();
    public sealed virtual string get_DotNetCoreVersion();
    public sealed virtual string GetEnvironmentVariable(string variable);
    public sealed virtual bool get_IsRunningInContainer();
    public sealed virtual string get_ProgramFilesPath();
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual void set_CurrentDirectory(string value);
    public sealed virtual void SetProcessScopeVariable(string name, string value);
    public static string GetNetCoreVersion();
    public sealed virtual PlatformID get_Platform();
    public sealed virtual string get_MachineName();
    public sealed virtual string get_MachineNameLowerCase();
    public sealed virtual string get_UserName();
    public sealed virtual string get_UserNameLowerCase();
    public sealed virtual string get_LocalAppDataPath();
}
public class SpecFlow.Plus.Shared.Services.Implementations.ExecutionEnvironment : object {
    private IEnvironment _environment;
    [CompilerGeneratedAttribute]
private bool <RunsInBuildServer>k__BackingField;
    public bool RunsInBuildServer { get; }
    public bool RunsInContainer { get; }
    public ExecutionEnvironment(IEnvironment environment);
    private bool CalculateRunsInBuildServer();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RunsInBuildServer();
    public sealed virtual bool get_RunsInContainer();
}
public class SpecFlow.Plus.Shared.Services.Implementations.FallbackLicenseReaderService`2 : object {
    private TPrimary _primary;
    private TFallback _fallback;
    public FallbackLicenseReaderService`2(TPrimary primary, TFallback fallback);
    public sealed virtual FSharpOption`1<StorageLicenseInfo> ReadLicense();
}
public class SpecFlow.Plus.Shared.Services.Implementations.FileLicenseReaderService : object {
    private ILicenseFileProvider _licenseFileProvider;
    public FileLicenseReaderService(ILicenseFileProvider licenseFileProvider);
    public sealed virtual FSharpOption`1<StorageLicenseInfo> ReadLicense();
    public FSharpOption`1<StorageLicenseInfo> GetStorageLicenseInfoFromTextLines(IResult`1<IEnumerable`1<string>> textLinesResult);
}
public class SpecFlow.Plus.Shared.Services.Implementations.FileLicenseRemovalService : object {
    private ILicenseFileProvider _licenseFileProvider;
    public FileLicenseRemovalService(ILicenseFileProvider licenseFileProvider);
    public sealed virtual bool RemoveLicense();
}
public class SpecFlow.Plus.Shared.Services.Implementations.FileLicenseWriterService : object {
    private ILicenseFileProvider _licenseFileProvider;
    public FileLicenseWriterService(ILicenseFileProvider licenseFileProvider);
    public sealed virtual bool WriteLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
public class SpecFlow.Plus.Shared.Services.Implementations.FileNameService : object {
    public sealed virtual IEnumerable`1<string> GetNumberedFileNames(string fileNamePattern, int startNumber);
    public sealed virtual IEnumerable`1<string> GetNumberedFileNames(string fileNamePattern, int startNumber, int count);
    public sealed virtual FSharpOption`1<string> GetParentDirectory(FSharpOption`1<string> fileName);
    public sealed virtual FSharpOption`1<string> GetFileName(FSharpOption`1<string> filePath);
    public sealed virtual FSharpOption`1<string> GetFileNameWithoutExtension(FSharpOption`1<string> fileName);
    public sealed virtual FSharpOption`1<string> GetFileExtension(FSharpOption`1<string> fileName);
    public sealed virtual FSharpOption`1<string> ReplaceExtension(FSharpOption`1<string> fileName, FSharpOption`1<string> extension);
}
public class SpecFlow.Plus.Shared.Services.Implementations.FileSystemService : object {
    private IFileNameService _fileNameService;
    public FileSystemService(IFileNameService fileNameService);
    public sealed virtual bool FileExists(string filePath);
    public sealed virtual bool FileExists(FSharpOption`1<string> filePathOption);
    public sealed virtual FSharpOption`1<IEnumerable`1<string>> ReadLinesFromFile(string filePath);
    public sealed virtual FSharpOption`1<string> ReadStringFromFile(FSharpOption`1<string> filePath);
    public sealed virtual FSharpOption`1<string> ReadStringFromFile(FSharpOption`1<string> filePath, FSharpOption`1<Encoding> encoding);
    public sealed virtual bool WriteLinesToFile(string filePath, IEnumerable`1<string> lines);
    public sealed virtual bool WriteStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> content);
    public sealed virtual bool ForceWriteStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> content);
    public sealed virtual bool AppendStringToFile(FSharpOption`1<string> filePath, FSharpOption`1<string> contentToAppend);
    public sealed virtual FSharpOption`1<string> GetParentFolder(string path);
    public sealed virtual FSharpOption`1<string> GetParentFolder(FSharpOption`1<string> pathOption);
    public sealed virtual bool CreateFolder(string path);
    public sealed virtual bool FolderExists(string path);
    public sealed virtual void DeleteFolder(string path);
    public sealed virtual bool CreateFolder(FSharpOption`1<string> pathOption);
    public sealed virtual bool FolderExists(FSharpOption`1<string> pathOption);
    public sealed virtual bool DeleteFolder(FSharpOption`1<string> pathOption);
    public sealed virtual string ResolveEnvironmentVariables(string source);
    public sealed virtual FSharpOption`1<string> ResolveEnvironmentVariables(FSharpOption`1<string> source);
    public sealed virtual bool DeleteFile(string filePath);
    public sealed virtual bool CopyFileToFolder(FSharpOption`1<string> sourceFilePath, FSharpOption`1<string> destinationFolderPath);
    public sealed virtual FSharpOption`1<string> GetFirstAvailableFileName(string fileNamePattern, int startNumber);
    public sealed virtual FSharpOption`1<string> GetFirstAvailableFileName(string fileNamePattern, int startNumber, int count);
    [IteratorStateMachineAttribute("SpecFlow.Plus.Shared.Services.Implementations.FileSystemService/<GetFilesInDirectory>d__25")]
public sealed virtual IEnumerable`1<FileInfo> GetFilesInDirectory(string directoryPath);
    [IteratorStateMachineAttribute("SpecFlow.Plus.Shared.Services.Implementations.FileSystemService/<GetFullNamesOfFilesInDirectory>d__26")]
public sealed virtual IEnumerable`1<string> GetFullNamesOfFilesInDirectory(string directoryPath, string searchPattern);
    public sealed virtual bool IsValidPath(FSharpOption`1<string> pathOption);
    public sealed virtual FSharpOption`1<Stream> CreateWriteStreamForFile(FSharpOption`1<string> filePathOption);
    public sealed virtual FSharpOption`1<string> CombinePaths(IEnumerable`1<FSharpOption`1<string>> paths);
    public sealed virtual FSharpOption`1<string> CombinePaths(FSharpOption`1[] paths);
    public sealed virtual FSharpOption`1<string> GetFullPath(FSharpOption`1<string> relativePath);
    public sealed virtual string GetTempFileName();
    [CompilerGeneratedAttribute]
private bool <GetFirstAvailableFileName>b__24_0(string filePath);
}
public interface SpecFlow.Plus.Shared.Services.Implementations.IExecutionEnvironment {
    public bool RunsInBuildServer { get; }
    public bool RunsInContainer { get; }
    public abstract virtual bool get_RunsInBuildServer();
    public abstract virtual bool get_RunsInContainer();
}
public class SpecFlow.Plus.Shared.Services.Implementations.InvalidLicenseException : Exception {
    public InvalidLicenseException(string message);
    public InvalidLicenseException(string message, Exception inner);
    protected InvalidLicenseException(SerializationInfo info, StreamingContext context);
}
public class SpecFlow.Plus.Shared.Services.Implementations.LicenseDeserializationService : object {
    private ILicenseKeyFormatValidator _licenseKeyFormatValidator;
    private DateTime magicDate;
    public LicenseDeserializationService(ILicenseKeyFormatValidator licenseKeyFormatValidator);
    private static DSACryptoServiceProvider ReadCryptoProvider();
    private static DSACryptoServiceProvider GetCryptoProvider(LicenseType licenseType, byte licenseVersion);
    private LicenseType GetLicenseType(Byte[] data);
    private static byte GetLicenseVersion(Byte[] data);
    public bool ValidateSpecLogLicense(string licenseKey, string issuedTo);
    private Nullable`1<DateTime> DeserializeDate(ushort days);
    private FSharpOption`1<LicenseInfo> Deserialize(string licenseKey, string issuedTo);
    public sealed virtual FSharpOption`1<LicenseInfo> DeserializeLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
public class SpecFlow.Plus.Shared.Services.Implementations.LicenseService : object {
    private ILicenseReaderService _licenseReaderService;
    private ILicenseDeserializationService _licenseDeserializationService;
    private ILicenseWriterService _licenseWriterService;
    private ILicenseRemovalService _licenseRemovalService;
    public LicenseService(ILicenseReaderService licenseReaderService, ILicenseDeserializationService licenseDeserializationService, ILicenseWriterService licenseWriterService, ILicenseRemovalService licenseRemovalService);
    public sealed virtual FSharpOption`1<LicenseInfo> GetLicense();
    public sealed virtual bool SetLicense(StorageLicenseInfo storageLicenseInfo);
    public sealed virtual bool RemoveLicense();
}
public class SpecFlow.Plus.Shared.Services.Implementations.LicenseValidationService : object {
    private ITimeService _timeService;
    private IReleaseDateService _releaseDateService;
    private IExecutionEnvironment _executionEnvironment;
    public LicenseValidationService(ITimeService timeService, IReleaseDateService releaseDateService, IExecutionEnvironment executionEnvironment);
    public sealed virtual ValidateLicenseResult ValidateLicenseForExecution(LicenseValidationInfo licenseValidationInfo);
}
internal class SpecFlow.Plus.Shared.Services.Implementations.LicensingResources : object {
    private static Lazy`1<ResourceManager> resourceManager;
    private static ResourceManager ResourceManager { get; }
    internal static string BuildVersion { get; }
    internal static string LicensePublicKey2012 { get; }
    private static LicensingResources();
    private static ResourceManager get_ResourceManager();
    internal static string get_BuildVersion();
    internal static string get_LicensePublicKey2012();
}
public class SpecFlow.Plus.Shared.Services.Implementations.RealTimeService : object {
    public sealed virtual DateTime GetToday();
    public sealed virtual DateTime GetNow();
}
public class SpecFlow.Plus.Shared.Services.Implementations.ReleaseDateService : object {
    public sealed virtual DateTime Get();
}
public class SpecFlow.Plus.Shared.Services.Implementations.SystemRandomNumberGenerator : object {
    private Random _random;
    public SystemRandomNumberGenerator(Random random);
    public sealed virtual int Get(int min, int max);
}
public class SpecFlow.Plus.Shared.Services.Implementations.UnixUriCleaner : object {
    public sealed virtual string StripSchema(string uriString);
    public sealed virtual string ConvertSlashes(string actualUri);
}
public class SpecFlow.Plus.Shared.Services.Implementations.ValidateLicenseResultOutput : object {
    private IOutputService _outputService;
    private IOutputFormatter`1<DateTime> _dateTimeFormatter;
    public ValidateLicenseResultOutput(IOutputService outputService, IOutputFormatter`1<DateTime> dateTimeFormatter);
    public sealed virtual void Write(ValidateLicenseResult validateLicenseResult);
    public string GetDateString(Nullable`1<DateTime> value, string nullReplacement);
}
public class SpecFlow.Plus.Shared.Services.Implementations.WindowsUriCleaner : object {
    public sealed virtual string StripSchema(string uriString);
    public sealed virtual string ConvertSlashes(string actualUri);
}
public interface SpecFlow.Plus.Shared.Services.IOutputFormatter`1 {
    public abstract virtual string ToString(T value);
}
public interface SpecFlow.Plus.Shared.Services.IOutputService {
    public abstract virtual void Write(string value);
    public abstract virtual void WriteLine();
    public abstract virtual void WriteLine(string value);
    public abstract virtual void WriteErrorLine(string value);
    public abstract virtual void WriteWarningLine(string value);
    public abstract virtual void WriteInfoLine(string value);
}
public interface SpecFlow.Plus.Shared.Services.IProgramAboutOutput {
    public abstract virtual void WriteAbout();
}
public interface SpecFlow.Plus.Shared.Services.IProgramInfoService {
    public abstract virtual DateTime GetReleaseDate();
    public abstract virtual string GetSemanticVersion();
    public abstract virtual Version GetAssemblyVersion();
    public abstract virtual string GetCopyright();
}
public interface SpecFlow.Plus.Shared.Services.IRandomNumberGenerator {
    public abstract virtual int Get(int min, int max);
}
public interface SpecFlow.Plus.Shared.Services.IReleaseDateService {
    public abstract virtual DateTime Get();
}
public interface SpecFlow.Plus.Shared.Services.ITestLoggerFactory {
    public abstract virtual FSharpOption`1<ITestLogger> GetFileLoggerForPath(string path);
}
public interface SpecFlow.Plus.Shared.Services.ITimeService {
    public abstract virtual DateTime GetToday();
    public abstract virtual DateTime GetNow();
}
public interface SpecFlow.Plus.Shared.Services.IValidateLicenseResultOutput {
    public abstract virtual void Write(ValidateLicenseResult validateLicenseResult);
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseDeserializationService {
    public abstract virtual FSharpOption`1<LicenseInfo> DeserializeLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseFileProvider {
    public abstract virtual IResult`1<IEnumerable`1<string>> GetLicenseFile();
    public abstract virtual IResult WriteLicenseFile(IEnumerable`1<string> content);
    public abstract virtual IResult DeleteLicenseFile();
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseKeyFormatValidator {
    public abstract virtual bool Validate(string licenseKey);
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseMigrationService {
    public abstract virtual bool Migrate();
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseReaderService {
    public abstract virtual FSharpOption`1<StorageLicenseInfo> ReadLicense();
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseRemovalService {
    public abstract virtual bool RemoveLicense();
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseService {
    public abstract virtual FSharpOption`1<LicenseInfo> GetLicense();
    public abstract virtual bool SetLicense(StorageLicenseInfo storageLicenseInfo);
    public abstract virtual bool RemoveLicense();
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseValidationService {
    public abstract virtual ValidateLicenseResult ValidateLicenseForExecution(LicenseValidationInfo licenseValidationInfo);
}
public interface SpecFlow.Plus.Shared.Services.Licensing.ILicenseWriterService {
    public abstract virtual bool WriteLicense(FSharpOption`1<StorageLicenseInfo> storageLicenseInfo);
}
public class SpecFlow.Plus.Shared.Services.Licensing.LicenseFileProvider : object {
    private IFileSystemService _fileSystemService;
    private IRuntimeInformationProvider _runtimeInformationProvider;
    public LicenseFileProvider(IFileSystemService fileSystemService, IRuntimeInformationProvider runtimeInformationProvider);
    public sealed virtual IResult`1<IEnumerable`1<string>> GetLicenseFile();
    public sealed virtual IResult WriteLicenseFile(IEnumerable`1<string> content);
    public sealed virtual IResult DeleteLicenseFile();
    public string GetLicenseKeyFilePath();
}
public class SpecFlow.Plus.Shared.Services.Licensing.LicenseKeyFormatValidator : object {
    public sealed virtual bool Validate(string licenseKey);
    public bool TryGetLicenseDataFromBase64String(string licenseKey, Byte[]& data);
    public bool IsBooleanRepresentation(byte value);
    public bool HasHeaderMinimumLength(int dataLength);
}
public class SpecFlow.Plus.Shared.Services.Logging.ConsoleLogger : TestLogger {
    private IOutputService _outputService;
    public ConsoleLogger(ITimeService timeService, IOutputService outputService);
    public virtual void Log(LogEntry logEntry, string threadName);
    public virtual void LogInternal(string message);
}
public interface SpecFlow.Plus.Shared.Services.Logging.ILogger {
    public abstract virtual void Info(string message);
    public abstract virtual void Debug(string message);
    public abstract virtual void Error(string message);
    public abstract virtual bool AttachTestLogger(ITestLogger testLogger);
    public abstract virtual bool DetachTestLogger(ITestLogger testLogger);
    public abstract virtual void Flush();
}
public interface SpecFlow.Plus.Shared.Services.Logging.ILoggingConfig {
    public bool DebugLogging { get; }
    public abstract virtual bool get_DebugLogging();
}
public interface SpecFlow.Plus.Shared.Services.Logging.ITestLogger {
    public abstract virtual void Log(string message);
    public abstract virtual void Log(LogEntry logEntry, string threadName);
    public abstract virtual void Flush();
}
public class SpecFlow.Plus.Shared.Services.Logging.LogEntry : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private LogType <Type>k__BackingField;
    public DateTime Timestamp { get; }
    public string Message { get; }
    public LogType Type { get; }
    public LogEntry(DateTime timestamp, string message, LogType type);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public LogType get_Type();
}
public class SpecFlow.Plus.Shared.Services.Logging.Logger : object {
    private ILoggingConfig _loggingConfig;
    private ITimeService _timeService;
    private ICurrentThreadService _currentThreadService;
    private List`1<LogEntry> _logEntries;
    private List`1<ITestLogger> _testLoggers;
    public Logger(ILoggingConfig loggingConfig, ITimeService timeService, ICurrentThreadService currentThreadService);
    public void Log(LogType logType, string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Error(string message);
    public sealed virtual bool AttachTestLogger(ITestLogger testLogger);
    public sealed virtual bool DetachTestLogger(ITestLogger testLogger);
    public sealed virtual void Flush();
    public void FlushAllExistingEntriesToTestLogger(ITestLogger testLogger);
    private IEnumerable`1<LogEntry> CopyList(List`1<LogEntry> logEntries);
    public void SendEntryToTestLogger(ITestLogger testLogger, LogEntry logEntry);
    public string GetCurrentThreadName();
}
public class SpecFlow.Plus.Shared.Services.Logging.LoggingConfig : object {
    public static string SpecflowPlusDebugLogging;
    public bool DebugLogging { get; }
    public sealed virtual bool get_DebugLogging();
}
public enum SpecFlow.Plus.Shared.Services.Logging.LogType : Enum {
    public int value__;
    public static LogType Debug;
    public static LogType Info;
    public static LogType Error;
}
public abstract class SpecFlow.Plus.Shared.Services.Logging.TestLogger : object {
    private ITimeService _timeService;
    private bool _isDisposed;
    protected TestLogger(ITimeService timeService);
    public sealed virtual void Log(string message);
    public virtual void Log(LogEntry logEntry, string threadName);
    public abstract virtual void LogInternal(string message);
    public virtual void Flush();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public interface SpecFlow.Plus.Shared.Services.Runtime.IRuntimeInformationProvider {
    public abstract virtual bool IsOperatingSystemUnixoid();
    public abstract virtual bool IsOperatingSystemWindows();
}
public class SpecFlow.Plus.Shared.Services.Runtime.RuntimeInformationProvider : object {
    public sealed virtual bool IsOperatingSystemUnixoid();
    public sealed virtual bool IsOperatingSystemWindows();
}
public class SpecFlow.Plus.Shared.Services.Versioning.DefaultVersionInfoProvider : object {
    public sealed virtual string GetVersion();
}
public interface SpecFlow.Plus.Shared.Services.Versioning.IVersionInfoProvider {
    public abstract virtual string GetVersion();
}
public static class SpecFlow.Plus.Shared.Threading.AsyncHelper : object {
    private static TaskFactory _myTaskFactory;
    private static AsyncHelper();
    public static TResult RunSync(Func`1<Task`1<TResult>> func);
    public static void RunSync(Func`1<Task> func);
}
public interface SpecFlow.Plus.Shared.Threading.IThreadApartmentStateFetcher {
    public abstract virtual ApartmentState GetCurrentThreadApartmentState();
}
public interface SpecFlow.Plus.Shared.Threading.IThreadApartmentStateModifier {
    public abstract virtual void SetThreadApartmentState(Thread thread, ApartmentState apartmentState);
}
public interface SpecFlow.Plus.Shared.Threading.IThreadFactory {
    public abstract virtual Thread CreateThreadWithNameAndApartmentState(string name, ApartmentState apartmentState, ThreadStart threadStart);
    public abstract virtual Thread CreateThreadWithName(string name, ThreadStart threadStart);
    public abstract virtual Thread CreateThreadWithApartmentState(ApartmentState apartmentState, ThreadStart threadStart);
    public abstract virtual Thread CreateThread(ThreadStart threadStart);
    public abstract virtual Thread CreateBackgroundThread(ThreadStart threadStart);
}
public class SpecFlow.Plus.Shared.Threading.NetCoreThreadApartmentStateModifier : object {
    private IRuntimeInformationProvider _runtimeInformationProvider;
    public NetCoreThreadApartmentStateModifier(IRuntimeInformationProvider runtimeInformationProvider);
    public sealed virtual void SetThreadApartmentState(Thread thread, ApartmentState apartmentState);
}
public class SpecFlow.Plus.Shared.Threading.NetFxThreadApartmentStateModifier : object {
    public sealed virtual void SetThreadApartmentState(Thread thread, ApartmentState apartmentState);
}
public class SpecFlow.Plus.Shared.Threading.ThreadApartmentStateFetcher : object {
    public sealed virtual ApartmentState GetCurrentThreadApartmentState();
}
public class SpecFlow.Plus.Shared.Threading.ThreadFactory : object {
    private ILogger _logger;
    private IThreadApartmentStateModifier _threadApartmentStateModifier;
    public ThreadFactory(ILogger logger, IThreadApartmentStateModifier threadApartmentStateModifier);
    public sealed virtual Thread CreateThreadWithNameAndApartmentState(string name, ApartmentState apartmentState, ThreadStart threadStart);
    public sealed virtual Thread CreateThreadWithName(string name, ThreadStart threadStart);
    public sealed virtual Thread CreateThreadWithApartmentState(ApartmentState apartmentState, ThreadStart threadStart);
    public sealed virtual Thread CreateThread(ThreadStart threadStart);
    public sealed virtual Thread CreateBackgroundThread(ThreadStart threadStart);
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
