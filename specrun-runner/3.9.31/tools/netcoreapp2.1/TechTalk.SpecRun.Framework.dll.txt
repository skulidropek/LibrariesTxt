public class TechTalk.SpecRun.Framework.AsyncTestThreadRunner : object {
    private ApartmentState _apartmentState;
    private IThreadFactory _threadFactory;
    private CountdownEvent _countdownEvent;
    private ITestLogger _logger;
    private TestThread _testThread;
    private CancellationTokenSource _cancellationTokenSource;
    private Thread _thread;
    [CompilerGeneratedAttribute]
private Exception <TestThreadError>k__BackingField;
    public Exception TestThreadError { get; private set; }
    public AsyncTestThreadRunner(TestThread testThread, ITestLogger logger, ApartmentState apartmentState, IThreadFactory threadFactory, CountdownEvent countdownEvent);
    [CompilerGeneratedAttribute]
public Exception get_TestThreadError();
    [CompilerGeneratedAttribute]
private void set_TestThreadError(Exception value);
    public sealed virtual void Dispose();
    public void RunSync(TestExecutionManager executionManager, CancellationToken cancellationToken);
    public void Run(TestExecutionManager executionManager);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Configuration.TestProfileExtensions : object {
    [ExtensionAttribute]
public static TargetConfiguration GetTarget(TestProfile testProfile, string targetName);
    [ExtensionAttribute]
public static IEnumerable`1<ExecutionModelSettings> GetExecutionModelSettings(TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.Configuration.TestRunExecutionConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <BuildServerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmbeddedMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReportFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestRunTracer <TestRunTracer>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestDebuggingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutionEnviroment>k__BackingField;
    public bool BuildServerMode { get; public set; }
    public bool EmbeddedMode { get; public set; }
    public string ReportFilePath { get; public set; }
    public ITestRunTracer TestRunTracer { get; public set; }
    public ITestLogger Logger { get; public set; }
    public bool TestDebuggingMode { get; public set; }
    public string ExecutionEnviroment { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_BuildServerMode();
    [CompilerGeneratedAttribute]
public void set_BuildServerMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmbeddedMode();
    [CompilerGeneratedAttribute]
public void set_EmbeddedMode(bool value);
    [CompilerGeneratedAttribute]
public string get_ReportFilePath();
    [CompilerGeneratedAttribute]
public void set_ReportFilePath(string value);
    [CompilerGeneratedAttribute]
public ITestRunTracer get_TestRunTracer();
    [CompilerGeneratedAttribute]
public void set_TestRunTracer(ITestRunTracer value);
    [CompilerGeneratedAttribute]
public ITestLogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ITestLogger value);
    [CompilerGeneratedAttribute]
public bool get_TestDebuggingMode();
    [CompilerGeneratedAttribute]
public void set_TestDebuggingMode(bool value);
    [CompilerGeneratedAttribute]
public string get_ExecutionEnviroment();
    [CompilerGeneratedAttribute]
public void set_ExecutionEnviroment(string value);
}
public class TechTalk.SpecRun.Framework.DefaultExecutionContainerBuilder : object {
    public virtual IObjectContainer CreateContainer(TestProfile testProfile, TestRunExecutionConfiguration executionConfiguration, IObjectContainer parentObjectContainer);
}
[XmlTypeAttribute("ConfigFileTransformation")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.ConfigFileTransformationStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformationFileContent>k__BackingField;
    [XmlAttributeAttribute("configFile")]
public string ConfigFilePath { get; public set; }
    [XmlElementAttribute("Transformation")]
public string TransformationFileContent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
public void set_ConfigFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_TransformationFileContent();
    [CompilerGeneratedAttribute]
public void set_TransformationFileContent(string value);
    private string GetConfigFilePath(DeploymentContext deploymentContext);
    protected virtual string ConfigFileBackupPath(string configFilePath);
    private static string GetKey(string configFilePath);
    private void Backup(string configFilePath, DeploymentContext deploymentContext);
    private void RestoreFromBackup(string configFilePath, DeploymentContext deploymentContext);
    public virtual void Apply(DeploymentContext deploymentContext);
    protected virtual string ResolveParameters(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("CopyFiles")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.CopyFilesStep : DeploymentTransformationStep {
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("CopyFile")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.CopyFileStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <SourceFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteOnRestore>k__BackingField;
    [XmlAttributeAttribute("source")]
public string SourceFileName { get; public set; }
    [XmlAttributeAttribute("target")]
public string TargetFileName { get; public set; }
    [XmlAttributeAttribute("targetFolder")]
public string TargetFolder { get; public set; }
    [XmlAttributeAttribute("deleteOnRestore")]
public bool DeleteOnRestore { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceFileName();
    [CompilerGeneratedAttribute]
public void set_SourceFileName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFileName();
    [CompilerGeneratedAttribute]
public void set_TargetFileName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFolder();
    [CompilerGeneratedAttribute]
public void set_TargetFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_DeleteOnRestore();
    [CompilerGeneratedAttribute]
public void set_DeleteOnRestore(bool value);
    public virtual void Apply(DeploymentContext deploymentContext);
    private string GetDestPath(DeploymentContext deploymentContext, string sourcePath);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("CopyFolder")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.CopyFolderStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <SourceFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteFolderOnRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteFolderOnApply>k__BackingField;
    [XmlAttributeAttribute("source")]
public string SourceFolder { get; public set; }
    [XmlAttributeAttribute("target")]
public string TargetFolder { get; public set; }
    [XmlAttributeAttribute("deleteFolderOnRestore")]
public bool DeleteFolderOnRestore { get; public set; }
    [XmlAttributeAttribute("deleteFolderOnApply")]
public bool DeleteFolderOnApply { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceFolder();
    [CompilerGeneratedAttribute]
public void set_SourceFolder(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFolder();
    [CompilerGeneratedAttribute]
public void set_TargetFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_DeleteFolderOnRestore();
    [CompilerGeneratedAttribute]
public void set_DeleteFolderOnRestore(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteFolderOnApply();
    [CompilerGeneratedAttribute]
public void set_DeleteFolderOnApply(bool value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("Custom")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.CustomDeploymentStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    private IDeploymentTransformationStep customDeploymentStep;
    [XmlAttributeAttribute("type")]
public string TypeName { get; public set; }
    [XmlAttributeAttribute("arguments")]
public string Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    private void EnsureCustomDeploymentStep(DeploymentContext deploymentContext);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
public class TechTalk.SpecRun.Framework.DeploymentSteps.DeleteFolderStep : DeploymentTransformationStep {
    private IFileSystemService _fileSystemService;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptionIfFolderDoesNotExist>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public bool ThrowExceptionIfFolderDoesNotExist { get; public set; }
    public string Path { get; public set; }
    public DeleteFolderStep(IFileSystemService fileSystemService);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptionIfFolderDoesNotExist();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptionIfFolderDoesNotExist(bool value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
public class TechTalk.SpecRun.Framework.DeploymentSteps.DeploymentContext : object {
    private TestProfile testProfile;
    private IFileSystemService _fileSystemService;
    [CompilerGeneratedAttribute]
private ITestLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestThreadId>k__BackingField;
    private IAssemblyReference testAssembly;
    private string customTestAssemblyConfigFilePath;
    [CompilerGeneratedAttribute]
private string <BaseFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseFolderRelativeTestAssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, object> <CustomData>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <CustomEnvironmentVariables>k__BackingField;
    private static Regex parameterRe;
    private static Dictionary`2<string, Func`2<DeploymentContext, string>> parameterResolvers;
    public ITestLogger Logger { get; private set; }
    public string TestTarget { get; private set; }
    public int TestThreadId { get; private set; }
    public IAssemblyReference TestAssembly { get; private set; }
    public string BaseFolder { get; public set; }
    public string OriginalBaseFolder { get; }
    public string OutputFolder { get; }
    public string UniqueId { get; }
    public string BaseFolderRelativeTestAssemblyPath { get; public set; }
    public Dictionary`2<object, object> CustomData { get; private set; }
    public Dictionary`2<string, string> CustomEnvironmentVariables { get; }
    public string TestAssemblyFullPath { get; }
    public string CustomTestAssemblyConfigFilePath { get; public set; }
    public string TestAssemblyConfigFilePath { get; }
    public bool IsGlobalContext { get; }
    public DeploymentContext(TestProfile testProfile, IFileSystemService fileSystemService, ITestLogger logger, int testThreadId, IAssemblyReference testAssembly, string testTarget);
    public DeploymentContext(TestProfile testProfile, IFileSystemService fileSystemService, ITestLogger logger);
    private static DeploymentContext();
    [CompilerGeneratedAttribute]
public ITestLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ITestLogger value);
    [CompilerGeneratedAttribute]
public string get_TestTarget();
    [CompilerGeneratedAttribute]
private void set_TestTarget(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TestThreadId();
    [CompilerGeneratedAttribute]
private void set_TestThreadId(int value);
    public IAssemblyReference get_TestAssembly();
    private void set_TestAssembly(IAssemblyReference value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BaseFolder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BaseFolder(string value);
    public string get_OriginalBaseFolder();
    public string get_OutputFolder();
    public string get_UniqueId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BaseFolderRelativeTestAssemblyPath();
    [CompilerGeneratedAttribute]
public void set_BaseFolderRelativeTestAssemblyPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<object, object> get_CustomData();
    [CompilerGeneratedAttribute]
private void set_CustomData(Dictionary`2<object, object> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomEnvironmentVariables();
    public string get_TestAssemblyFullPath();
    public string get_CustomTestAssemblyConfigFilePath();
    public void set_CustomTestAssemblyConfigFilePath(string value);
    public string get_TestAssemblyConfigFilePath();
    public bool get_IsGlobalContext();
    private static void EnsureNonGlobalContext(DeploymentContext context);
    public sealed virtual string ResolveParameters(string text);
    private string Evaluator(Match match);
    public sealed virtual string GetFullPath(string path);
    public void Apply(DeploymentTransformationSteps steps, ITestRunTracerBroker tracerBroker);
    private DeploymentTransformationStep GetStep(DeploymentTransformationStepConfiguration stepConfiguration);
    public void Restore(DeploymentTransformationSteps steps, ITestRunTracerBroker tracerBroker);
}
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.ConfigFileTransformationStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.RelocateStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.RelocateConfigurationFileStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.CopyFolderStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.CustomDeploymentStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.IISExpressStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.CopyFileStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.CopyFilesStep")]
[XmlIncludeAttribute("TechTalk.SpecRun.Framework.DeploymentSteps.DeleteFolderStep")]
public abstract class TechTalk.SpecRun.Framework.DeploymentSteps.DeploymentTransformationStep : object {
    public abstract virtual void Apply(DeploymentContext deploymentContext);
    public abstract virtual void Restore(DeploymentContext deploymentContext);
    public virtual string ToString(DeploymentContext deploymentContext);
    public virtual string ToString();
}
[XmlTypeAttribute("EnvironmentVariable")]
internal class TechTalk.SpecRun.Framework.DeploymentSteps.EnvironmentVariableDeploymentStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [XmlAttributeAttribute("variable")]
public string Variable { get; public set; }
    [XmlAttributeAttribute("value")]
public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
public class TechTalk.SpecRun.Framework.DeploymentSteps.IISExpressManager : object {
    private int port;
    private string webAppPath;
    private string iisExpressPath;
    private bool useShellExecute;
    private ITestLogger logger;
    private ManualResetEvent iisExpressStarted;
    private Process iisProcess;
    public int ProcessId { get; }
    public IISExpressManager(string webAppPath, int port, string iisExpressPath, bool useShellExecute, ITestLogger logger);
    public int get_ProcessId();
    public void Start();
    private void StopProcessDirect();
    public void StopIisExpressShellExecute();
    public void Stop();
    private void StartIisExpressInternal();
    public void WaitForStart();
}
[XmlTypeAttribute("IISExpress")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.IISExpressStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <IISExpressPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebAppFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseShellExecute>k__BackingField;
    [XmlAttributeAttribute("iisExpressPath")]
public string IISExpressPath { get; public set; }
    [XmlAttributeAttribute("webAppFolder")]
public string WebAppFolder { get; public set; }
    [XmlAttributeAttribute("port")]
public string Port { get; public set; }
    [XmlAttributeAttribute("useShellExecute")]
public bool UseShellExecute { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IISExpressPath();
    [CompilerGeneratedAttribute]
public void set_IISExpressPath(string value);
    [CompilerGeneratedAttribute]
public string get_WebAppFolder();
    [CompilerGeneratedAttribute]
public void set_WebAppFolder(string value);
    [CompilerGeneratedAttribute]
public string get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(string value);
    [CompilerGeneratedAttribute]
public bool get_UseShellExecute();
    [CompilerGeneratedAttribute]
public void set_UseShellExecute(bool value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("RelocateConfigurationFile")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.RelocateConfigurationFileStep : DeploymentTransformationStep {
    [CompilerGeneratedAttribute]
private string <TargetFileName>k__BackingField;
    [XmlAttributeAttribute("target")]
public string TargetFileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetFileName();
    [CompilerGeneratedAttribute]
public void set_TargetFileName(string value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
}
[XmlTypeAttribute("Relocate")]
public class TechTalk.SpecRun.Framework.DeploymentSteps.RelocateStep : DeploymentTransformationStep {
    private CopyFolderStep copyFolderStep;
    [XmlAttributeAttribute("targetFolder")]
public string TargetFolder { get; public set; }
    [XmlAttributeAttribute("deleteFolderOnRestore")]
public bool DeleteFolderOnRestore { get; public set; }
    public string get_TargetFolder();
    public void set_TargetFolder(string value);
    public bool get_DeleteFolderOnRestore();
    public void set_DeleteFolderOnRestore(bool value);
    public virtual void Apply(DeploymentContext deploymentContext);
    public virtual void Restore(DeploymentContext deploymentContext);
    public virtual string ToString(DeploymentContext deploymentContext);
}
public class TechTalk.SpecRun.Framework.Execution.DisabledExecutionResultPublisher : object {
    private ILogger _logger;
    public DisabledExecutionResultPublisher(ILogger logger);
    public sealed virtual void PublishResults(TestRunResult result);
}
public class TechTalk.SpecRun.Framework.Execution.EffectiveExecutionModelSettingsCalculator : object {
    private ICurrentExecutionModelSettings _currentExecutionModelSettings;
    public EffectiveExecutionModelSettingsCalculator(ICurrentExecutionModelSettings currentExecutionModelSettings);
    public sealed virtual ExecutionModelSettings Calculate(TestEnvironmentSettings environmentSettings, HostSettings host);
}
public class TechTalk.SpecRun.Framework.Execution.ExecutionEngine : object {
    private ITestRunResultReporter _testRunResultReporter;
    private ILogger _logger;
    private ITestLogger _testLogger;
    private IExecutionResultPublisher _executionResultPublisher;
    private IActivationService _activationService;
    private IActivationValidationResultOutput _activationValidationResultOutput;
    private IAnalyticsTransmitter _analyticsTransmitter;
    public ExecutionEngine(ITestRunResultReporter testRunResultReporter, ILogger logger, ITestLogger testLogger, IExecutionResultPublisher executionResultPublisher, IActivationService activationService, IActivationValidationResultOutput activationValidationResultOutput, IAnalyticsTransmitter analyticsTransmitter);
    public sealed virtual TestRunResult ExecuteTestSuite(TestProfile testProfile, TestRunExecutionConfiguration executionConfiguration, IObjectContainer parentObjectContainer, IExecutionContainerBuilder containerBuilder);
    public sealed virtual void TraceSummary(TestRunResult result, TestRunExecutionConfiguration executionConfiguration);
}
public interface TechTalk.SpecRun.Framework.Execution.IEffectiveExecutionModelSettingsCalculator {
    public abstract virtual ExecutionModelSettings Calculate(TestEnvironmentSettings environmentSettings, HostSettings host);
}
public interface TechTalk.SpecRun.Framework.Execution.IExecutionContainerBuilder {
    public abstract virtual IObjectContainer CreateContainer(TestProfile testProfile, TestRunExecutionConfiguration executionConfiguration, IObjectContainer parentObjectContainer);
}
public interface TechTalk.SpecRun.Framework.Execution.IExecutionEngine {
    public abstract virtual TestRunResult ExecuteTestSuite(TestProfile testProfile, TestRunExecutionConfiguration executionConfiguration, IObjectContainer parentObjectContainer, IExecutionContainerBuilder containerBuilder);
    public abstract virtual void TraceSummary(TestRunResult result, TestRunExecutionConfiguration executionConfiguration);
}
public interface TechTalk.SpecRun.Framework.Execution.IExecutionResultPublisher {
    public abstract virtual void PublishResults(TestRunResult result);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.EnsureExecutorProcessResult : object {
    [CompilerGeneratedAttribute]
private ExecutorProcessInfo <ExecutorProcessInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewProcess>k__BackingField;
    public ExecutorProcessInfo ExecutorProcessInfo { get; }
    public bool IsNewProcess { get; }
    public EnsureExecutorProcessResult(ExecutorProcessInfo executorProcessInfo, bool isNewProcess);
    [CompilerGeneratedAttribute]
public ExecutorProcessInfo get_ExecutorProcessInfo();
    [CompilerGeneratedAttribute]
public bool get_IsNewProcess();
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.ExecutorProcessInfo : object {
    private StringWriter _stdOutWriter;
    private StringWriter _stdErrWriter;
    [CompilerGeneratedAttribute]
private ProcessStartInfo <ProcessStartInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStopped>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UsageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExitEventBeenTriggered>k__BackingField;
    public ProcessStartInfo ProcessStartInfo { get; }
    public Process Process { get; private set; }
    public bool IsStopped { get; private set; }
    public int UsageCount { get; private set; }
    public bool HasExitEventBeenTriggered { get; private set; }
    public ExecutorProcessInfo(ProcessStartInfo processStartInfo);
    [CompilerGeneratedAttribute]
public ProcessStartInfo get_ProcessStartInfo();
    [CompilerGeneratedAttribute]
public Process get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(Process value);
    [CompilerGeneratedAttribute]
public bool get_IsStopped();
    [CompilerGeneratedAttribute]
private void set_IsStopped(bool value);
    [CompilerGeneratedAttribute]
public int get_UsageCount();
    [CompilerGeneratedAttribute]
private void set_UsageCount(int value);
    [CompilerGeneratedAttribute]
public bool get_HasExitEventBeenTriggered();
    [CompilerGeneratedAttribute]
private void set_HasExitEventBeenTriggered(bool value);
    public string GetStdOut();
    public string GetStdErr();
    public void WriteStdOut(string toWrite);
    public void WriteStdErr(string toWrite);
    public void UseProcess(Process process);
    public void IncreaseUsageCount();
    public void DecreaseUsageCount();
    public void StopProcess();
    [CompilerGeneratedAttribute]
private void <UseProcess>b__26_0(object _, DataReceivedEventArgs e);
    [CompilerGeneratedAttribute]
private void <UseProcess>b__26_1(object _, DataReceivedEventArgs e);
    [CompilerGeneratedAttribute]
private void <UseProcess>b__26_2(object _, EventArgs e);
}
public interface TechTalk.SpecRun.Framework.Execution.OutOfProc.IOutProcExecutorManager {
    public IOutProcExecutorProcessInfoProvider ProcessInfoProvider { get; public set; }
    public abstract virtual IOutProcExecutorProcessInfoProvider get_ProcessInfoProvider();
    public abstract virtual void set_ProcessInfoProvider(IOutProcExecutorProcessInfoProvider value);
    public abstract virtual void EnsureStopUnusedProcess(ExecutionModelSettings executionModelSettings);
    public abstract virtual void StartProcess(ExecutorProcessInfo executorProcessInfo);
    public abstract virtual bool HasExecutorForExecutionModelSettings(ExecutionModelSettings executionModelSettings, ExecutorProcessInfo& executorProcessInfo);
    public abstract virtual EnsureExecutorProcessResult EnsureExecutorProcess(ExecutionModelSettings executionModelSettings, ushort callbackPort, ushort loggerPort);
}
public interface TechTalk.SpecRun.Framework.Execution.OutOfProc.IOutProcExecutorProcessInfoProvider {
    public abstract virtual TestProcessInfo GetProcessInfo(ExecutorProcessStartInfo executorProcessStartInfo);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.OutProcExecutorManager : object {
    private ITestLogger _logger;
    [CompilerGeneratedAttribute]
private IOutProcExecutorProcessInfoProvider <ProcessInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TestDebuggingMode>k__BackingField;
    private Dictionary`2<ExecutionModelSettings, ExecutorProcessInfo> _executorProcessInfos;
    private object _executorProcessInfosSyncRoot;
    public IOutProcExecutorProcessInfoProvider ProcessInfoProvider { get; public set; }
    public bool TestDebuggingMode { get; public set; }
    public OutProcExecutorManager(ITestLogger logger, TestRunExecutionConfiguration executionConfiguration, IOutProcExecutorProcessInfoProvider outProcExecutorProcessInfoProvider);
    [CompilerGeneratedAttribute]
public sealed virtual IOutProcExecutorProcessInfoProvider get_ProcessInfoProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProcessInfoProvider(IOutProcExecutorProcessInfoProvider value);
    [CompilerGeneratedAttribute]
public bool get_TestDebuggingMode();
    [CompilerGeneratedAttribute]
public void set_TestDebuggingMode(bool value);
    public sealed virtual bool HasExecutorForExecutionModelSettings(ExecutionModelSettings executionModelSettings, ExecutorProcessInfo& executorProcessInfo);
    public sealed virtual EnsureExecutorProcessResult EnsureExecutorProcess(ExecutionModelSettings executionModelSettings, ushort callbackPort, ushort loggerPort);
    protected virtual ExecutorProcessStartInfo GetExecutorProcessStartInfo(ExecutionModelSettings executionModelSettings, ushort callbackPort, ushort loggerPort);
    private ExecutorProcessInfo CreateExecutorProcess(ExecutionModelSettings executionModelSettings, ushort callbackPort, ushort loggerPort);
    public virtual void StartProcess(ExecutorProcessInfo executorProcessInfo);
    public sealed virtual void EnsureStopUnusedProcess(ExecutionModelSettings executionModelSettings);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.OutProcExecutorProcessInfoProvider : object {
    private IAssemblyFolderHelper _assemblyFolderHelper;
    private IFileSystemService _fileSystemService;
    private IEnvironment _environment;
    private ILogger _logger;
    private static String[] ResolveExtensions;
    public OutProcExecutorProcessInfoProvider(IAssemblyFolderHelper assemblyFolderHelper, IFileSystemService fileSystemService, IEnvironment environment, ILogger logger);
    private static OutProcExecutorProcessInfoProvider();
    public sealed virtual TestProcessInfo GetProcessInfo(ExecutorProcessStartInfo executorProcessStartInfo);
    public string GetWorkingDirectoryForClrVersion(ClrVersion clrVersion, string executorFolder);
    public string GetTestAdapterSubFolder(ClrVersion clrVersion);
    public string GetNetCoreExecutorFileName(Platform platform, ClrVersion clrVersion);
    public string GetExecutorFileName(Platform platform, ClrVersion clrVersion);
    private TestProcessInfo GetTestProcessInfo(ClrVersion clrVersion, Platform platform, string executorFolder, string argumentsString, bool useShellExecute, bool resolveExecutorFullPath);
    private string ResolveExecutorFullPath(string executorFileName);
    private string GetPlatformString(Platform platform);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.StreamJsonRPC.OutOfProcessExecutorWatchDog : object {
    private ITestLogger _testLogger;
    private Process _process;
    private StringBuilder _stdErrorWriter;
    private StringBuilder _stdOutWriter;
    private bool _isRunning;
    private bool _isDisposed;
    public OutOfProcessExecutorWatchDog(ITestLogger testLogger, Process process);
    private void _process_OutputDataReceived(object sender, DataReceivedEventArgs e);
    private void _process_ErrorDataReceived(object sender, DataReceivedEventArgs e);
    [AsyncStateMachineAttribute("TechTalk.SpecRun.Framework.Execution.OutOfProc.StreamJsonRPC.OutOfProcessExecutorWatchDog/<Start>d__9")]
public Task Start();
    public bool CheckProcess();
    public void Stop();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class TechTalk.SpecRun.Framework.Execution.OutOfProc.StreamJsonRPC.OutOfProcessTestAssemblyExecutorClient : object {
    private IRpcClient _rpcClient;
    public OutOfProcessTestAssemblyExecutorClient(IRpcClient rpcClient);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(int threadId, RemoteAssemblyReference assemblyReference, string testAssemblyFullPath, string testAssemblyConfigFilePath, ApartmentState apartmentState, TestExecutionConfiguration testExecutionConfiguration, string target);
    public sealed virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    [CompilerGeneratedAttribute]
private Task <DeInitialize>b__5_0();
}
internal class TechTalk.SpecRun.Framework.Execution.OutOfProc.StreamJsonRPC.OutOfProcessTestAssemblyExecutorHost : object {
    private ExecutionModelSettings _executionModelSettings;
    private IServerFactory _serverFactory;
    private IClientFactory _clientFactory;
    private IOutProcExecutorManager _outProcExecutorManager;
    private ITestLogger _logger;
    private OutOfProcessExecutorWatchDog _watchDog;
    private bool _isDisposed;
    private RemoteExecutor _remoteExecutor;
    public OutOfProcessTestAssemblyExecutorHost(ExecutionModelSettings executionModelSettings, IServerFactory serverFactory, IClientFactory clientFactory, IOutProcExecutorManager outProcExecutorManager, ITestLogger logger);
    public sealed virtual void Initialize(int threadId, ITestExecutionManager executionManager, IAssemblyReference testAssembly, ITestLogger currentLogger, string testAssemblyFullPath, string testAssemblyConfigFilePath, TestExecutionConfiguration testExecutionConfiguration, string target);
    public sealed virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void WaitForEndpoint(ITestExecutionManager executionManager, Process process, Action`1<int> action);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProc.StreamJsonRPC.RemoteExecutor : object {
    private IClientFactory _clientFactory;
    private ITestLogger _logger;
    private ManualResetEventSlim _readyEvent;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IRpcServer <CallbackRpcServer>k__BackingField;
    [CompilerGeneratedAttribute]
private IRpcServer <LoggerRpcServer>k__BackingField;
    [CompilerGeneratedAttribute]
private IRpcClient <ExecutorClient>k__BackingField;
    [CompilerGeneratedAttribute]
private IOutOfProcessTestAssemblyExecutor <OutOfProcessTestAssemblyExecutorClient>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <RemoteExecutorPort>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LocalCallbackPort>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LocalLoggerPort>k__BackingField;
    public IRpcServer CallbackRpcServer { get; }
    public IRpcServer LoggerRpcServer { get; }
    public IRpcClient ExecutorClient { get; private set; }
    public IOutOfProcessTestAssemblyExecutor OutOfProcessTestAssemblyExecutorClient { get; private set; }
    public ushort RemoteExecutorPort { get; private set; }
    public ushort LocalCallbackPort { get; }
    public ushort LocalLoggerPort { get; }
    public RemoteExecutor(ITestExecutionManager testExecutionManager, IServerFactory serverFactory, IClientFactory clientFactory, ITestLogger currentLogger, ITestLogger logger);
    [CompilerGeneratedAttribute]
public IRpcServer get_CallbackRpcServer();
    [CompilerGeneratedAttribute]
public IRpcServer get_LoggerRpcServer();
    [CompilerGeneratedAttribute]
public IRpcClient get_ExecutorClient();
    [CompilerGeneratedAttribute]
private void set_ExecutorClient(IRpcClient value);
    [CompilerGeneratedAttribute]
public IOutOfProcessTestAssemblyExecutor get_OutOfProcessTestAssemblyExecutorClient();
    [CompilerGeneratedAttribute]
private void set_OutOfProcessTestAssemblyExecutorClient(IOutOfProcessTestAssemblyExecutor value);
    [CompilerGeneratedAttribute]
public ushort get_RemoteExecutorPort();
    [CompilerGeneratedAttribute]
private void set_RemoteExecutorPort(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_LocalCallbackPort();
    [CompilerGeneratedAttribute]
public ushort get_LocalLoggerPort();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public bool WaitUntilReady();
    private void OnPortReceived(ushort port);
    public void SetupExecutorClient(ushort remoteExecutorPort);
    public TestThreadState RunTests(TestThreadState testThreadState);
    private void Dispose(bool disposing);
    public void DeInitialize();
}
internal class TechTalk.SpecRun.Framework.Filtering.FilterExpressionParser : object {
    private static Regex testPathRe;
    private Regex tokenizerRe;
    private static FilterExpressionParser();
    public sealed virtual FilterItem Parse(string filterExpression);
    private void HotfixTestPath(String& filterExpression);
    private string MaskParenthesis(string value);
    private List`1<Token> ConvertToRpn(string filterExpression, IEnumerable`1<Token> tokens);
    private FilterItem GenerateFilterItem(List`1<Token> rpn);
    private IEnumerable`1<Token> GetTokens(string filterExpression);
    [CompilerGeneratedAttribute]
private string <HotfixTestPath>b__2_0(Match match);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.FrameworkContainerRegistrations : object {
    [ExtensionAttribute]
public static IObjectContainer RegisterFrameworkRegistrations(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterTestProfilePreparer(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterTestLoggerFactory(IObjectContainer objectContainer);
}
public class TechTalk.SpecRun.Framework.FrameworkDependent.FrameworkInformation : object {
    public FrameworkVersion CurrentFramework { get; }
    public sealed virtual FrameworkVersion get_CurrentFramework();
}
public interface TechTalk.SpecRun.Framework.FrameworkDependent.IFrameworkInformation {
    public FrameworkVersion CurrentFramework { get; }
    public abstract virtual FrameworkVersion get_CurrentFramework();
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Infrastructure.Extensions.ExecutionContainerExtensions : object {
    [ExtensionAttribute]
public static IObjectContainer RegisterTestAssemblyExecutorFactory(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterGherkinKeywordLookup(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterFrameworkInformation(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterTestSuiteProvider(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterTestSuiteRunner(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterSharedAppDomainHolder(IObjectContainer container);
    [ExtensionAttribute]
public static IObjectContainer RegisterDtoMappers(IObjectContainer container);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Infrastructure.Extensions.NetStandardExecutionContainerExtensions : object {
    [ExtensionAttribute]
public static IObjectContainer RegisterAppDomainManager(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterExecutionResultPublisher(IObjectContainer objectContainer);
    [ExtensionAttribute]
public static IObjectContainer RegisterReporting(IObjectContainer objectContainer);
}
public interface TechTalk.SpecRun.Framework.ITestExecutionConfigurationFactory {
    public abstract virtual TestExecutionConfiguration BuildFromTestProfile(TestProfile testProfile);
}
public interface TechTalk.SpecRun.Framework.ITestSuiteRunner {
    public TestProfile TestProfile { get; }
    public abstract virtual TestProfile get_TestProfile();
    public abstract virtual FSharpOption`1<TestRunResult> Run();
}
public interface TechTalk.SpecRun.Framework.ITestThreadExecutorFactory {
    public abstract virtual IResult`1<ITestAssemblyExecutor> BuildTestThreadExecutor(ExecutionModelSettings executionModelSettings, DeploymentContext deploymentContext, ITestThreadLogger testThreadLogger);
}
public interface TechTalk.SpecRun.Framework.ITestThreadFactory {
    public abstract virtual TestThread BuildTestThreadWithIdAndTestLogger(int threadId, ITestLogger testLogger);
}
public interface TechTalk.SpecRun.Framework.ITestThreadLogger {
    public abstract virtual ITestLogger GetTestLogger();
    public abstract virtual void Log(string message);
}
public interface TechTalk.SpecRun.Framework.ITestThreadLoggerFactory {
    public abstract virtual ITestThreadLogger BuildFromTestLoggerAndTestThreadId(ITestLogger testLogger, int testThreadId);
}
public class TechTalk.SpecRun.Framework.Logging.AsyncTestRunTracerBroker : object {
    private ITestRunTracer baseTracer;
    private TaskQueue taskQueue;
    private bool reportCancellations;
    private bool cancelling;
    [CompilerGeneratedAttribute]
private Action OnClientCancel;
    public AsyncTestRunTracerBroker(ITestRunTracer baseTracer);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnClientCancel(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnClientCancel(Action value);
    public sealed virtual void SendTestRunStarted(TestSuite testSuite, TestProfile testProfile);
    public sealed virtual void SendTestRunFinished(TestRunResult testRunResult);
    public sealed virtual void SendTestThreadStarted(TestThreadResult testThreadResult);
    public sealed virtual void SendTestThreadFinished(TestThreadResult testThreadResult);
    public sealed virtual void SendTestStarted(TestItemExecutionResult testItemExecutionResult);
    public sealed virtual void SendTestFinished(TestItemExecutionResult testItemExecutionResult);
    public sealed virtual void StopReportingCancellations();
    public sealed virtual void SendTraceMessage(int testThreadId, string message);
    private Action GetCancelHandlingAction(Action action);
    private void EvaluateCancelling();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0();
}
public class TechTalk.SpecRun.Framework.Logging.ConsoleRedirector : object {
    private TextWriter oldConsoleOut;
    private TextWriter oldConsoleError;
    private LoggerTextWriter loggerWriter;
    public ConsoleRedirector(ITestLogger logger);
    public sealed virtual void Dispose();
}
public class TechTalk.SpecRun.Framework.Logging.CustomFileLoggerTextWriterFactoryConfiguration : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; }
    public CustomFileLoggerTextWriterFactoryConfiguration(string fileName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
}
public class TechTalk.SpecRun.Framework.Logging.FileLogger : TestLogger {
    private TaskQueue _taskQueue;
    private TextWriter _writer;
    private bool _isDisposed;
    public FileLogger(IFileLoggerTextWriterFactory fileLoggerTextWriterFactory, ITimeService timeService);
    public virtual void LogInternal(string message);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
public class TechTalk.SpecRun.Framework.Logging.FileLoggerTextWriterFactory : object {
    private IFileLoggerTextWriterFactoryConfiguration _configuration;
    private IFileSystemService _fileSystemService;
    public FileLoggerTextWriterFactory(IFileLoggerTextWriterFactoryConfiguration configuration, IFileSystemService fileSystemService);
    public sealed virtual FSharpOption`1<TextWriter> GetTextWriter();
}
public interface TechTalk.SpecRun.Framework.Logging.IFileLoggerTextWriterFactory {
    public abstract virtual FSharpOption`1<TextWriter> GetTextWriter();
}
public interface TechTalk.SpecRun.Framework.Logging.IFileLoggerTextWriterFactoryConfiguration {
    public string FileName { get; }
    public abstract virtual string get_FileName();
}
public interface TechTalk.SpecRun.Framework.Logging.ITestRunTracer {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnClientCancel(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnClientCancel(Action value);
    public abstract virtual void TestRunStarted(TestSuite testSuite, TestProfile testProfile);
    public abstract virtual void TestRunFinished(TestRunResult testRunResult);
    public abstract virtual void TestThreadStarted(TestThreadResult testThreadResult);
    public abstract virtual void TestThreadFinished(TestThreadResult testThreadResult);
    public abstract virtual void TestStarted(TestItemExecutionResult testItemExecutionResult);
    public abstract virtual void TestFinished(TestItemExecutionResult testItemExecutionResult);
    public abstract virtual void StopReportingCancellations();
    public abstract virtual void TraceMessage(int testThreadId, string message);
    public abstract virtual void TraceError(int testThreadId, string message);
}
public interface TechTalk.SpecRun.Framework.Logging.ITestRunTracerBroker {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnClientCancel(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnClientCancel(Action value);
    public abstract virtual void SendTestRunStarted(TestSuite testSuite, TestProfile testProfile);
    public abstract virtual void SendTestRunFinished(TestRunResult testRunResult);
    public abstract virtual void SendTestThreadStarted(TestThreadResult testThreadResult);
    public abstract virtual void SendTestThreadFinished(TestThreadResult testThreadResult);
    public abstract virtual void SendTestStarted(TestItemExecutionResult testItemExecutionResult);
    public abstract virtual void SendTestFinished(TestItemExecutionResult testItemExecutionResult);
    public abstract virtual void StopReportingCancellations();
    public abstract virtual void SendTraceMessage(int testThreadId, string message);
}
internal class TechTalk.SpecRun.Framework.Logging.LoggerTextWriter : TextWriter {
    private StringBuilder buffer;
    private ITestLogger testLogger;
    public Encoding Encoding { get; }
    public LoggerTextWriter(ITestLogger testLogger);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    protected virtual void Dispose(bool disposing);
}
public class TechTalk.SpecRun.Framework.Logging.NullLogger : TestLogger {
    public NullLogger(ITimeService timeService);
    public virtual void LogInternal(string message);
    public virtual void Log(LogEntry logEntry, string currentThread);
}
public class TechTalk.SpecRun.Framework.Logging.NullTracer : object {
    public sealed virtual void add_OnClientCancel(Action value);
    public sealed virtual void remove_OnClientCancel(Action value);
    public sealed virtual void TestRunStarted(TestSuite testSuite, TestProfile testProfile);
    public sealed virtual void TestRunFinished(TestRunResult testRunResult);
    public sealed virtual void TestThreadStarted(TestThreadResult testThreadResult);
    public sealed virtual void TestThreadFinished(TestThreadResult testThreadResult);
    public sealed virtual void TestStarted(TestItemExecutionResult testItemExecutionResult);
    public sealed virtual void TestFinished(TestItemExecutionResult testItemExecutionResult);
    public sealed virtual void StopReportingCancellations();
    public sealed virtual void TraceMessage(int testThreadId, string message);
    public sealed virtual void TraceError(int testThreadId, string message);
}
internal class TechTalk.SpecRun.Framework.Logging.TaskQueue : object {
    private Queue`1<TaskSignal> _tasksQueue;
    private SemaphoreSlim _tasksCountSemaphore;
    private AutoResetEvent _completionSignal;
    private bool _shouldCancel;
    private bool _isDisposed;
    private Task _consumerTask;
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void ConsumerTask();
    [IteratorStateMachineAttribute("TechTalk.SpecRun.Framework.Logging.TaskQueue/<TasksQueue>d__9")]
public IEnumerable`1<Action> TasksQueue();
    public void Start();
    public void EnqueueTask(Action task);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Logging.TestRunTracerBrokerExtensions : object {
    [ExtensionAttribute]
public static void SendTraceMessage(ITestRunTracerBroker tracerBroker, string message);
    [ExtensionAttribute]
public static void SendTraceMessage(ITestRunTracerBroker tracerBroker, string messageFormat, Object[] args);
    [ExtensionAttribute]
public static void SendTraceMessage(ITestRunTracerBroker tracerBroker, int testThreadId, string messageFormat, Object[] args);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Logging.TestRunTracerExtensions : object {
    [ExtensionAttribute]
public static void TraceMessage(ITestRunTracer tracer, string message);
    [ExtensionAttribute]
public static void TraceError(ITestRunTracer tracer, string message);
    [ExtensionAttribute]
public static void TraceMessage(ITestRunTracer tracer, string messageFormat, Object[] args);
}
public class TechTalk.SpecRun.Framework.ProfileLicenseManager : LicenseService {
    private ILicenseDeserializationService _licenseDeserializationService;
    public ProfileLicenseManager(ILicenseReaderService licenseReaderService, ILicenseDeserializationService licenseDeserializationService, ILicenseWriterService licenseWriterService, ILicenseRemovalService licenseRemovalService);
    public FSharpOption`1<LicenseInfo> GetProfileLicense(TestProfile testProfile);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TechTalk.SpecRun.Framework.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BuildVersion { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BuildVersion();
}
public class TechTalk.SpecRun.Framework.Remoting.ReflectionWrapper : DynamicObject {
    private object innerObject;
    private bool returnNullOnUnknown;
    public ReflectionWrapper(object innerObject, bool returnNullOnUnknown);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
}
public class TechTalk.SpecRun.Framework.Remoting.RemoteDomainInitializerForTestCollectionBuilding : object {
    [RunsInTestAssemblyAppDomainAttribute]
private static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args);
}
public class TechTalk.SpecRun.Framework.Reporting.ReportOutput : object {
    [CompilerGeneratedAttribute]
private string <ReportPathAndFileName>k__BackingField;
    public string ReportPathAndFileName { get; }
    public ReportOutput(string reportPathAndFileName);
    [CompilerGeneratedAttribute]
public string get_ReportPathAndFileName();
}
public interface TechTalk.SpecRun.Framework.Results.Dtos.ITestNodeValueDto {
    public int Id { get; public set; }
    public TestNodeType TestNodeType { get; public set; }
    public abstract virtual int get_Id();
    public abstract virtual void set_Id(int value);
    public abstract virtual TestNodeType get_TestNodeType();
    public abstract virtual void set_TestNodeType(TestNodeType value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.ReportOutputDto : object {
    [CompilerGeneratedAttribute]
private string <ReportPathAndFileName>k__BackingField;
    public string ReportPathAndFileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ReportPathAndFileName();
    [CompilerGeneratedAttribute]
public void set_ReportPathAndFileName(string value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestItemDto : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private TestNodeType <TestNodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IgnoreReason>k__BackingField;
    public int Id { get; public set; }
    public TestNodeType TestNodeType { get; public set; }
    public bool IsIgnored { get; public set; }
    public string IgnoreReason { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TestNodeType get_TestNodeType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TestNodeType(TestNodeType value);
    [CompilerGeneratedAttribute]
public bool get_IsIgnored();
    [CompilerGeneratedAttribute]
public void set_IsIgnored(bool value);
    [CompilerGeneratedAttribute]
public string get_IgnoreReason();
    [CompilerGeneratedAttribute]
public void set_IgnoreReason(string value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestItemExecutionResultDto : object {
    [CompilerGeneratedAttribute]
private int <TestItemExecutionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScheduleOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TestNodeResultDto <Result>k__BackingField;
    public int TestItemExecutionIndex { get; public set; }
    public int ThreadId { get; public set; }
    public int ScheduleOrder { get; public set; }
    public int ExecutionOrder { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public TestNodeResultDto Result { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TestItemExecutionIndex();
    [CompilerGeneratedAttribute]
public void set_TestItemExecutionIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_ScheduleOrder();
    [CompilerGeneratedAttribute]
public void set_ScheduleOrder(int value);
    [CompilerGeneratedAttribute]
public int get_ExecutionOrder();
    [CompilerGeneratedAttribute]
public void set_ExecutionOrder(int value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public TestNodeResultDto get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(TestNodeResultDto value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestItemResultDto : object {
    [CompilerGeneratedAttribute]
private List`1<TestItemExecutionResultDto> <TestItemExecutionResultDtos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestNodeId>k__BackingField;
    public List`1<TestItemExecutionResultDto> TestItemExecutionResultDtos { get; public set; }
    public int TestNodeId { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TestItemExecutionResultDto> get_TestItemExecutionResultDtos();
    [CompilerGeneratedAttribute]
public void set_TestItemExecutionResultDtos(List`1<TestItemExecutionResultDto> value);
    [CompilerGeneratedAttribute]
public int get_TestNodeId();
    [CompilerGeneratedAttribute]
public void set_TestNodeId(int value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestNodeDto : object {
    [CompilerGeneratedAttribute]
private string <TestNodeClrType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestNodeValueDtoId>k__BackingField;
    [JsonPropertyAttribute("$testNodeType")]
public string TestNodeClrType { get; public set; }
    public int TestNodeValueDtoId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TestNodeClrType();
    [CompilerGeneratedAttribute]
public void set_TestNodeClrType(string value);
    [CompilerGeneratedAttribute]
public int get_TestNodeValueDtoId();
    [CompilerGeneratedAttribute]
public void set_TestNodeValueDtoId(int value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestNodeResultDto : object {
    [CompilerGeneratedAttribute]
private TestNodeResultType <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TraceEventDto> <TraceEvents>k__BackingField;
    public TestNodeResultType ResultType { get; public set; }
    public List`1<TraceEventDto> TraceEvents { get; public set; }
    [CompilerGeneratedAttribute]
public TestNodeResultType get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(TestNodeResultType value);
    [CompilerGeneratedAttribute]
public List`1<TraceEventDto> get_TraceEvents();
    [CompilerGeneratedAttribute]
public void set_TraceEvents(List`1<TraceEventDto> value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestRunResultDto : object {
    [CompilerGeneratedAttribute]
private TestProfile <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TestSuite <TestSuite>k__BackingField;
    [CompilerGeneratedAttribute]
private TestRunResultSummaryDto <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TestItemResultDto> <Tests>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TestThreadResultDto> <TestThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildServerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReportOutputDto> <Reports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentReportPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReportFileNameParameter>k__BackingField;
    public TestProfile Configuration { get; public set; }
    [JsonConverterAttribute("TechTalk.SpecRun.Framework.TestSuiteStructure.TestNodeJsonConverter")]
public TestSuite TestSuite { get; public set; }
    public TestRunResultSummaryDto Summary { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public List`1<TestItemResultDto> Tests { get; public set; }
    public List`1<TestThreadResultDto> TestThreads { get; public set; }
    public bool EvaluationMode { get; public set; }
    public bool BuildServerMode { get; public set; }
    public List`1<ReportOutputDto> Reports { get; public set; }
    public string CurrentReportPath { get; public set; }
    public string CurrentCulture { get; public set; }
    public string ReportFileNameParameter { get; public set; }
    [CompilerGeneratedAttribute]
public TestProfile get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(TestProfile value);
    [CompilerGeneratedAttribute]
public TestSuite get_TestSuite();
    [CompilerGeneratedAttribute]
public void set_TestSuite(TestSuite value);
    [CompilerGeneratedAttribute]
public TestRunResultSummaryDto get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(TestRunResultSummaryDto value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public List`1<TestItemResultDto> get_Tests();
    [CompilerGeneratedAttribute]
public void set_Tests(List`1<TestItemResultDto> value);
    [CompilerGeneratedAttribute]
public List`1<TestThreadResultDto> get_TestThreads();
    [CompilerGeneratedAttribute]
public void set_TestThreads(List`1<TestThreadResultDto> value);
    [CompilerGeneratedAttribute]
public bool get_EvaluationMode();
    [CompilerGeneratedAttribute]
public void set_EvaluationMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_BuildServerMode();
    [CompilerGeneratedAttribute]
public void set_BuildServerMode(bool value);
    [CompilerGeneratedAttribute]
public List`1<ReportOutputDto> get_Reports();
    [CompilerGeneratedAttribute]
public void set_Reports(List`1<ReportOutputDto> value);
    [CompilerGeneratedAttribute]
public string get_CurrentReportPath();
    [CompilerGeneratedAttribute]
public void set_CurrentReportPath(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentCulture();
    [CompilerGeneratedAttribute]
public void set_CurrentCulture(string value);
    [CompilerGeneratedAttribute]
public string get_ReportFileNameParameter();
    [CompilerGeneratedAttribute]
public void set_ReportFileNameParameter(string value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestRunResultSummaryDto : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<TestNodeResultType, int> <ResultCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <FrameworkErrorException>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<TestNodeResultType, int> <TestExecutionResultCounts>k__BackingField;
    public Dictionary`2<TestNodeResultType, int> ResultCounts { get; public set; }
    public Exception FrameworkErrorException { get; public set; }
    public Dictionary`2<TestNodeResultType, int> TestExecutionResultCounts { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<TestNodeResultType, int> get_ResultCounts();
    [CompilerGeneratedAttribute]
public void set_ResultCounts(Dictionary`2<TestNodeResultType, int> value);
    [CompilerGeneratedAttribute]
public Exception get_FrameworkErrorException();
    [CompilerGeneratedAttribute]
public void set_FrameworkErrorException(Exception value);
    [CompilerGeneratedAttribute]
public Dictionary`2<TestNodeResultType, int> get_TestExecutionResultCounts();
    [CompilerGeneratedAttribute]
public void set_TestExecutionResultCounts(Dictionary`2<TestNodeResultType, int> value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TestThreadResultDto : object {
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <TestThreadError>k__BackingField;
    public int ThreadId { get; public set; }
    public string MachineName { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public Exception TestThreadError { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public Exception get_TestThreadError();
    [CompilerGeneratedAttribute]
public void set_TestThreadError(Exception value);
}
public class TechTalk.SpecRun.Framework.Results.Dtos.TraceEventDto : object {
    [CompilerGeneratedAttribute]
private int <TestNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceEventType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TestNodeResultType <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BusinessMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TechMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceEventStepBindingInformation <StepBindingInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    public int TestNodeId { get; public set; }
    public TraceEventType Type { get; public set; }
    public TestNodeResultType ResultType { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public string BusinessMessages { get; public set; }
    public string TechMessages { get; public set; }
    public TraceEventStepBindingInformation StepBindingInformation { get; public set; }
    public string Error { get; public set; }
    public string StackTrace { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TestNodeId();
    [CompilerGeneratedAttribute]
public void set_TestNodeId(int value);
    [CompilerGeneratedAttribute]
public TraceEventType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TraceEventType value);
    [CompilerGeneratedAttribute]
public TestNodeResultType get_ResultType();
    [CompilerGeneratedAttribute]
public void set_ResultType(TestNodeResultType value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_BusinessMessages();
    [CompilerGeneratedAttribute]
public void set_BusinessMessages(string value);
    [CompilerGeneratedAttribute]
public string get_TechMessages();
    [CompilerGeneratedAttribute]
public void set_TechMessages(string value);
    [CompilerGeneratedAttribute]
public TraceEventStepBindingInformation get_StepBindingInformation();
    [CompilerGeneratedAttribute]
public void set_StepBindingInformation(TraceEventStepBindingInformation value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(string value);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.ReportOutputDtoMapper : object {
    public sealed virtual FSharpOption`1<ReportOutputDto> Map(ReportOutput source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestItemExecutionResultDtoMapper : object {
    private IMapper`2<TestNodeResult, TestNodeResultDto> _testNodeResultDtoMapper;
    public TestItemExecutionResultDtoMapper(IMapper`2<TestNodeResult, TestNodeResultDto> testNodeResultDtoMapper);
    public sealed virtual FSharpOption`1<TestItemExecutionResultDto> Map(TestItemExecutionResult source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestItemResultDtoMapper : object {
    private IMapper`2<TestItemExecutionResult, TestItemExecutionResultDto> _testItemExecutionResultDtoMapper;
    public TestItemResultDtoMapper(IMapper`2<TestItemExecutionResult, TestItemExecutionResultDto> testItemExecutionResultDtoMapper);
    public sealed virtual FSharpOption`1<TestItemResultDto> Map(TestItemResult source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestNodeDtoMapper : object {
    public sealed virtual FSharpOption`1<TestNodeDto> Map(TestNode source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestNodeResultDtoMapper : object {
    private IMapper`2<TraceEvent, TraceEventDto> _traceEventDtoMapper;
    public TestNodeResultDtoMapper(IMapper`2<TraceEvent, TraceEventDto> traceEventDtoMapper);
    public sealed virtual FSharpOption`1<TestNodeResultDto> Map(TestNodeResult source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestRunResultDtoMapper : object {
    private IMapper`2<TestRunResultSummary, TestRunResultSummaryDto> _testRunResultSummaryDtoMapper;
    private IMapper`2<ReportOutput, ReportOutputDto> _reportOutputDtoMapper;
    private IMapper`2<TestThreadResult, TestThreadResultDto> _testThreadResultDtoMapper;
    private IMapper`2<TestItemResult, TestItemResultDto> _testItemResultDtoMapper;
    public TestRunResultDtoMapper(IMapper`2<TestRunResultSummary, TestRunResultSummaryDto> testRunResultSummaryDtoMapper, IMapper`2<ReportOutput, ReportOutputDto> reportOutputDtoMapper, IMapper`2<TestThreadResult, TestThreadResultDto> testThreadResultDtoMapper, IMapper`2<TestItemResult, TestItemResultDto> testItemResultDtoMapper);
    public sealed virtual FSharpOption`1<TestRunResultDto> Map(TestRunResult source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestRunResultSummaryDtoMapper : object {
    public sealed virtual FSharpOption`1<TestRunResultSummaryDto> Map(TestRunResultSummary source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TestThreadResultDtoMapper : object {
    public sealed virtual FSharpOption`1<TestThreadResultDto> Map(TestThreadResult source);
}
public class TechTalk.SpecRun.Framework.Results.Serialization.TraceEventDtoMapper : object {
    public sealed virtual FSharpOption`1<TraceEventDto> Map(TraceEvent source);
}
public class TechTalk.SpecRun.Framework.Results.TestCollectionResultSummary : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<TestNodeResultType, int> <ResultCounts>k__BackingField;
    private Dictionary`2<TestNodeResultType, string> _resultFormat;
    [CompilerGeneratedAttribute]
private Dictionary`2<TestNodeResultType, int> <TestExecutionResultCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <FrameworkErrorException>k__BackingField;
    public Dictionary`2<TestNodeResultType, int> ResultCounts { get; }
    public Dictionary`2<TestNodeResultType, int> TestExecutionResultCounts { get; }
    public int Total { get; }
    public int TotalExecutions { get; }
    public int Succeeded { get; }
    public int Ignored { get; }
    public int Pending { get; }
    public int NothingToRun { get; }
    public int Skipped { get; }
    public int Inconclusive { get; }
    public int CleanupFailed { get; }
    public int Failed { get; }
    public int RandomlyFailed { get; }
    public int InitializationFailed { get; }
    public int FrameworkError { get; }
    public int TotalSucceeded { get; }
    public int TotalIgnored { get; }
    public int TotalPending { get; }
    public int TotalWarning { get; }
    public int TotalFailure { get; }
    public int TotalSucceededScenarios { get; }
    public int TotalPendingScenarios { get; }
    public int TotalWarningScenarios { get; }
    public int TotalFailureScenarios { get; }
    public int TotalIgnoredScenarios { get; }
    public int TotalSkippedScenarios { get; }
    public Exception FrameworkErrorException { get; public set; }
    public TestNodeResultType ConcludedResult { get; }
    public TestNodeResultTypeGroup ConcludedResultGroup { get; }
    public string TotalMessage { get; }
    public string ConcludedResultMessage { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<TestNodeResultType, int> get_ResultCounts();
    [CompilerGeneratedAttribute]
public Dictionary`2<TestNodeResultType, int> get_TestExecutionResultCounts();
    public void IncreaseTestExecutionResult(TestNodeResultType resultType);
    public void IncreaseResult(TestNodeResultType resultType);
    public int get_Total();
    public int get_TotalExecutions();
    public int get_Succeeded();
    public int get_Ignored();
    public int get_Pending();
    public int get_NothingToRun();
    public int get_Skipped();
    public int get_Inconclusive();
    public int get_CleanupFailed();
    public int get_Failed();
    public int get_RandomlyFailed();
    public int get_InitializationFailed();
    public int get_FrameworkError();
    public int get_TotalSucceeded();
    public int get_TotalIgnored();
    public int get_TotalPending();
    public int get_TotalWarning();
    public int get_TotalFailure();
    public int get_TotalSucceededScenarios();
    public int get_TotalPendingScenarios();
    public int get_TotalWarningScenarios();
    public int get_TotalFailureScenarios();
    public int get_TotalIgnoredScenarios();
    public int get_TotalSkippedScenarios();
    [CompilerGeneratedAttribute]
public Exception get_FrameworkErrorException();
    [CompilerGeneratedAttribute]
public void set_FrameworkErrorException(Exception value);
    public TestNodeResultType get_ConcludedResult();
    public TestNodeResultTypeGroup get_ConcludedResultGroup();
    private string GetTextIfNotZero(TestNodeResultType resultType);
    public string GetText(TestNodeResultType resultType);
    private string GetDetailsForGroup(TestNodeResultTypeGroup resultTypeGroup, TestNodeResultType[] excludedTypes);
    public string get_TotalMessage();
    public string get_ConcludedResultMessage();
}
public class TechTalk.SpecRun.Framework.Results.TestItemExecutionResult : object {
    [CompilerGeneratedAttribute]
private int <TestItemExecutionIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScheduleOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private TimePeriod <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TestNodeResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private TestItemResult <TestItemResult>k__BackingField;
    public int TestItemExecutionIndex { get; public set; }
    public int ThreadId { get; public set; }
    public int ScheduleOrder { get; public set; }
    public int ExecutionOrder { get; public set; }
    public TimePeriod ExecutionTime { get; public set; }
    public TestNodeResult Result { get; public set; }
    [JsonIgnoreAttribute]
public TestItemResult TestItemResult { get; public set; }
    [JsonIgnoreAttribute]
public Nullable`1<TimeSpan> ActExecutionTime { get; }
    [JsonIgnoreAttribute]
public TestNodeResultType ResultType { get; }
    [JsonIgnoreAttribute]
public bool IsExecuted { get; }
    [JsonIgnoreAttribute]
public string ExecutionTitle { get; }
    public TestItemExecutionResult(TestItemResult testItemResult, int scheduleOrder, int testItemExecutionIndex);
    [CompilerGeneratedAttribute]
public int get_TestItemExecutionIndex();
    [CompilerGeneratedAttribute]
public void set_TestItemExecutionIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public int get_ScheduleOrder();
    [CompilerGeneratedAttribute]
public void set_ScheduleOrder(int value);
    [CompilerGeneratedAttribute]
public int get_ExecutionOrder();
    [CompilerGeneratedAttribute]
public void set_ExecutionOrder(int value);
    [CompilerGeneratedAttribute]
public TimePeriod get_ExecutionTime();
    [CompilerGeneratedAttribute]
public void set_ExecutionTime(TimePeriod value);
    [CompilerGeneratedAttribute]
public TestNodeResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(TestNodeResult value);
    [CompilerGeneratedAttribute]
public TestItemResult get_TestItemResult();
    [CompilerGeneratedAttribute]
public void set_TestItemResult(TestItemResult value);
    public Nullable`1<TimeSpan> get_ActExecutionTime();
    public TestNodeResultType get_ResultType();
    public bool get_IsExecuted();
    public string get_ExecutionTitle();
}
[JsonConverterAttribute("TechTalk.SpecRun.Framework.Results.TestItemResultJsonConverter")]
public class TechTalk.SpecRun.Framework.Results.TestItemResult : object {
    [JsonPropertyAttribute]
private List`1<TestItemExecutionResult> _executions;
    [CompilerGeneratedAttribute]
private TestItem <TestNode>k__BackingField;
    [JsonConverterAttribute("TechTalk.SpecRun.Framework.TestSuiteStructure.TestNodeJsonConverter")]
public TestItem TestNode { get; }
    [JsonIgnoreAttribute]
public TimeSpan ExecutionTime { get; }
    [JsonIgnoreAttribute]
public TestNodeResultType Result { get; }
    [JsonIgnoreAttribute]
public string Error { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<string> ParentTitles { get; }
    [JsonIgnoreAttribute]
public int Id { get; }
    [JsonIgnoreAttribute]
public string Title { get; }
    [JsonIgnoreAttribute]
public string Description { get; }
    [JsonIgnoreAttribute]
public TestNodeType TestNodeType { get; }
    [JsonIgnoreAttribute]
public IEnumerable`1<TestItemExecutionResult> Executions { get; }
    public TestItemResult(TestItem testItem);
    public TestItemResult(TestItem testItem, IEnumerable`1<TestItemExecutionResult> executionResults);
    [CompilerGeneratedAttribute]
public TestItem get_TestNode();
    public TimeSpan get_ExecutionTime();
    public TestNodeResultType get_Result();
    public string get_Error();
    public IEnumerable`1<string> get_ParentTitles();
    public int get_Id();
    public string get_Title();
    public string get_Description();
    public TestNodeType get_TestNodeType();
    public IEnumerable`1<TestItemExecutionResult> get_Executions();
    public TestNodeResultType GetIntermediateResult();
    private string GetCumulatedError();
    public TestNodeResultType CalculateTestItemResult();
    public bool IsRandomlyFailed(IList`1<TestNodeResultType> executionResults);
    public TestItemExecutionResult AddExecutionResult(int scheduleOrder);
    public TestItemExecutionResult LastExecutionResult();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(TestItemExecutionResult execution);
}
public class TechTalk.SpecRun.Framework.Results.TestItemResultJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Results.TestNodeResultTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsAtLeast(TestNodeResultType resultType, TestNodeResultTypeGroup groupMask);
    [ExtensionAttribute]
public static bool IsInGroup(TestNodeResultType resultType, TestNodeResultTypeGroup groupMask);
    [ExtensionAttribute]
public static TestNodeResultTypeGroup GetGroup(TestNodeResultType resultType);
    [ExtensionAttribute]
public static IEnumerable`1<TestNodeResultType> GetMembers(TestNodeResultTypeGroup resultTypeGroup);
}
public class TechTalk.SpecRun.Framework.Results.TestRunResult : object {
    [CompilerGeneratedAttribute]
private TestProfile <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TestSuite <TestSuite>k__BackingField;
    [CompilerGeneratedAttribute]
private TestRunResultSummary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private TimePeriod <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TestItemResult> <Tests>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TestThreadResult> <TestThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildServerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReportOutput> <Reports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentReportPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReportFileNameParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private FSharpOption`1<string> <CurrentCulture>k__BackingField;
    public TestProfile Configuration { get; public set; }
    [JsonConverterAttribute("TechTalk.SpecRun.Framework.TestSuiteStructure.TestNodeJsonConverter")]
public TestSuite TestSuite { get; public set; }
    public TestRunResultSummary Summary { get; public set; }
    public TimePeriod ExecutionTime { get; public set; }
    public List`1<TestItemResult> Tests { get; public set; }
    public List`1<TestThreadResult> TestThreads { get; public set; }
    public bool EvaluationMode { get; public set; }
    public bool BuildServerMode { get; public set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<TestItemExecutionResult> TestExecutionResults { get; }
    public List`1<ReportOutput> Reports { get; public set; }
    public string CurrentReportPath { get; public set; }
    public string ReportFileNameParameter { get; public set; }
    [JsonIgnoreAttribute]
public Exception FrameworkError { get; }
    public FSharpOption`1<string> CurrentCulture { get; public set; }
    public TestRunResult(TestRunResultSummary summary, TestProfile configuration, TestSuite testSuite);
    [CompilerGeneratedAttribute]
public TestProfile get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(TestProfile value);
    [CompilerGeneratedAttribute]
public TestSuite get_TestSuite();
    [CompilerGeneratedAttribute]
public void set_TestSuite(TestSuite value);
    [CompilerGeneratedAttribute]
public TestRunResultSummary get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(TestRunResultSummary value);
    [CompilerGeneratedAttribute]
public TimePeriod get_ExecutionTime();
    [CompilerGeneratedAttribute]
public void set_ExecutionTime(TimePeriod value);
    [CompilerGeneratedAttribute]
public List`1<TestItemResult> get_Tests();
    [CompilerGeneratedAttribute]
public void set_Tests(List`1<TestItemResult> value);
    [CompilerGeneratedAttribute]
public List`1<TestThreadResult> get_TestThreads();
    [CompilerGeneratedAttribute]
public void set_TestThreads(List`1<TestThreadResult> value);
    [CompilerGeneratedAttribute]
public bool get_EvaluationMode();
    [CompilerGeneratedAttribute]
public void set_EvaluationMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_BuildServerMode();
    [CompilerGeneratedAttribute]
public void set_BuildServerMode(bool value);
    public IEnumerable`1<TestItemExecutionResult> get_TestExecutionResults();
    [CompilerGeneratedAttribute]
public List`1<ReportOutput> get_Reports();
    [CompilerGeneratedAttribute]
public void set_Reports(List`1<ReportOutput> value);
    [CompilerGeneratedAttribute]
public string get_CurrentReportPath();
    [CompilerGeneratedAttribute]
public void set_CurrentReportPath(string value);
    [CompilerGeneratedAttribute]
public string get_ReportFileNameParameter();
    [CompilerGeneratedAttribute]
public void set_ReportFileNameParameter(string value);
    public Exception get_FrameworkError();
    [CompilerGeneratedAttribute]
public FSharpOption`1<string> get_CurrentCulture();
    [CompilerGeneratedAttribute]
public void set_CurrentCulture(FSharpOption`1<string> value);
}
public class TechTalk.SpecRun.Framework.Results.TestRunResultSummary : TestCollectionResultSummary {
}
public class TechTalk.SpecRun.Framework.Results.TestThreadResult : object {
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private TimePeriod <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <TestThreadError>k__BackingField;
    public int ThreadId { get; }
    public string MachineName { get; }
    public TimePeriod ExecutionTime { get; }
    public Exception TestThreadError { get; public set; }
    public TestThreadResult(int threadId, DateTime startTime, string machineName);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public TimePeriod get_ExecutionTime();
    [CompilerGeneratedAttribute]
public Exception get_TestThreadError();
    [CompilerGeneratedAttribute]
public void set_TestThreadError(Exception value);
}
public class TechTalk.SpecRun.Framework.Results.TimePeriod : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    [JsonIgnoreAttribute]
public TimeSpan Duration { get; }
    [JsonIgnoreAttribute]
public double DurationMilliseconds { get; }
    [JsonIgnoreAttribute]
public double DurationSeconds { get; }
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    public TimeSpan get_Duration();
    public double get_DurationMilliseconds();
    public double get_DurationSeconds();
}
public class TechTalk.SpecRun.Framework.Services.BashCommandLineArgumentBuilder : object {
    private IList`1<string> _argumentsList;
    public sealed virtual ICommandLineArgumentBuilder AppendArgument(string argument);
    public sealed virtual string BuildArgumentsString();
}
public class TechTalk.SpecRun.Framework.Services.CommandLineArgumentBuilderFactory : object {
    private IRuntimeInformationProvider _runtimeInformationProvider;
    public CommandLineArgumentBuilderFactory(IRuntimeInformationProvider runtimeInformationProvider);
    public sealed virtual ICommandLineArgumentBuilder BuildForCurrentOperatingSystem();
}
public class TechTalk.SpecRun.Framework.Services.DisabledTestRunResultReporter : object {
    private ILogger _logger;
    public DisabledTestRunResultReporter(ILogger logger);
    public sealed virtual bool Report(TestRunResult testRunResult, TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.Services.ExternalProcessTestRunResultReporter : object {
    private IFileSystemService _fileSystemService;
    private IMapper`2<TestRunResult, TestRunResultDto> _testRunResultDtoMapper;
    private IJsonSerializer _jsonSerializer;
    private ILogger _logger;
    private IReportingProgramStartInfoProvider _reportingProgramStartInfoProvider;
    public ExternalProcessTestRunResultReporter(IFileSystemService fileSystemService, IMapper`2<TestRunResult, TestRunResultDto> testRunResultDtoMapper, IJsonSerializer jsonSerializer, ILogger logger, IReportingProgramStartInfoProvider reportingProgramStartInfoProvider);
    public FSharpOption`1<string> GetWorkingDirectoryOfTestAssemblies(IEnumerable`1<string> testAssemblyPaths);
    public sealed virtual bool Report(TestRunResult result, TestProfile testProfile);
}
public interface TechTalk.SpecRun.Framework.Services.ICommandLineArgumentBuilder {
    public abstract virtual ICommandLineArgumentBuilder AppendArgument(string argument);
    public abstract virtual string BuildArgumentsString();
}
public interface TechTalk.SpecRun.Framework.Services.ICommandLineArgumentBuilderFactory {
    public abstract virtual ICommandLineArgumentBuilder BuildForCurrentOperatingSystem();
}
public interface TechTalk.SpecRun.Framework.Services.IReportingExePathProvider {
    public abstract virtual FSharpOption`1<string> GetPathToReportingExe(string baseFolder);
}
public interface TechTalk.SpecRun.Framework.Services.IReportingProgramStartInfoProvider {
    public abstract virtual FSharpOption`1<ProcessStartInfo> GetProcessStartInfo(string workingDirectory, string baseFolder, string tempFilePath);
}
public interface TechTalk.SpecRun.Framework.Services.IShouldDebugChildProcessesRule {
    public abstract virtual bool ShouldDebugChildProcesses();
}
public interface TechTalk.SpecRun.Framework.Services.ITestProfilePreparer {
    public abstract virtual void PrepareTestProfile(TestProfile testProfile);
}
public interface TechTalk.SpecRun.Framework.Services.ITestRunResultReporter {
    public abstract virtual bool Report(TestRunResult testRunResult, TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.Services.MonoReportingProgramStartInfoProvider : object {
    private IReportingExePathProvider _reportingExePathProvider;
    private ICommandLineArgumentBuilderFactory _commandLineArgumentBuilderFactory;
    private IShouldDebugChildProcessesRule _shouldDebugChildProcessesRule;
    private ILogger _logger;
    private IFileSystemService _fileSystemService;
    public MonoReportingProgramStartInfoProvider(IReportingExePathProvider reportingExePathProvider, ICommandLineArgumentBuilderFactory commandLineArgumentBuilderFactory, IShouldDebugChildProcessesRule shouldDebugChildProcessesRule, ILogger logger, IFileSystemService fileSystemService);
    public sealed virtual FSharpOption`1<ProcessStartInfo> GetProcessStartInfo(string workingDirectory, string baseFolder, string tempFilePath);
}
public class TechTalk.SpecRun.Framework.Services.NetFxReportingProgramStartInfoProvider : object {
    private IReportingExePathProvider _reportingExePathProvider;
    private ICommandLineArgumentBuilderFactory _commandLineArgumentBuilderFactory;
    private IShouldDebugChildProcessesRule _shouldDebugChildProcessesRule;
    private ILogger _logger;
    private IFileSystemService _fileSystemService;
    public NetFxReportingProgramStartInfoProvider(IReportingExePathProvider reportingExePathProvider, ICommandLineArgumentBuilderFactory commandLineArgumentBuilderFactory, IShouldDebugChildProcessesRule shouldDebugChildProcessesRule, ILogger logger, IFileSystemService fileSystemService);
    public sealed virtual FSharpOption`1<ProcessStartInfo> GetProcessStartInfo(string workingDirectory, string baseFolder, string tempFilePath);
}
public class TechTalk.SpecRun.Framework.Services.ReportingExePathProvider : object {
    private static string ReportingExeName;
    private IFileSystemService _fileSystemService;
    public ReportingExePathProvider(IFileSystemService fileSystemService);
    public sealed virtual FSharpOption`1<string> GetPathToReportingExe(string baseFolder);
}
public class TechTalk.SpecRun.Framework.Services.ShouldDebugChildProcessesRule : object {
    public sealed virtual bool ShouldDebugChildProcesses();
}
public class TechTalk.SpecRun.Framework.Services.TestLoggerFactory : object {
    private IFileSystemService _fileSystemService;
    private ITimeService _timeService;
    public TestLoggerFactory(IFileSystemService fileSystemService, ITimeService timeService);
    public sealed virtual FSharpOption`1<ITestLogger> GetFileLoggerForPath(string path);
}
public class TechTalk.SpecRun.Framework.Services.TestProfilePreparer : object {
    private IEffectiveExecutionModelSettingsCalculator _effectiveExecutionModelSettingsCalculator;
    public TestProfilePreparer(IEffectiveExecutionModelSettingsCalculator effectiveExecutionModelSettingsCalculator);
    public sealed virtual void PrepareTestProfile(TestProfile testProfile);
    public void ResolveTestProfileSettings(TestProfile testProfile);
    public string CalcOutputFolder(TestProfile testProfile);
    public void ResolveTargets(TestProfile testProfile);
    public void ResolveTestThreadConfiguration(TestProfile testProfile);
    public void AddMissingThreadConfigurations(TestProfile testProfile);
    public void ValidateTestProfile(TestProfile testProfile);
    public void ResolveFilterExpressions(TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.Services.WindowsCommandLineArgumentBuilder : object {
    private IList`1<string> _argumentsList;
    public sealed virtual ICommandLineArgumentBuilder AppendArgument(string argument);
    public sealed virtual string BuildArgumentsString();
}
public class TechTalk.SpecRun.Framework.SpecFlow.GherkinKeywordLookup : object {
    public sealed virtual FSharpOption`1<string> GetKeyWord(string cultureName, GherkinKeyWord gherkinKeyWord);
    public sealed virtual FSharpOption`1<GherkinKeyWord> GetKeyWord(string cultureName, string text);
}
public interface TechTalk.SpecRun.Framework.SpecFlow.IGherkinKeywordLookup {
    public abstract virtual FSharpOption`1<string> GetKeyWord(string cultureName, GherkinKeyWord gherkinKeyWord);
    public abstract virtual FSharpOption`1<GherkinKeyWord> GetKeyWord(string cultureName, string text);
}
public class TechTalk.SpecRun.Framework.TestExecutionConfigurationFactory : object {
    public sealed virtual TestExecutionConfiguration BuildFromTestProfile(TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.TestExecutionManager : RemotableObject {
    private ITestLogger _logger;
    private object _synchRoot;
    private Dictionary`2<int, TestItemResult> _testResults;
    private TestRunResultSummary _testRunResultSummary;
    private ITestScheduler _testScheduler;
    private TestSuite _testSuite;
    private Dictionary`2<int, TestThreadResult> _testThreadResults;
    private ITimeService _timeService;
    private TraceEventFactory _traceEventFactory;
    private ITestRunTracerBroker _tracerBroker;
    private bool _cancelled;
    private int _failedTestCount;
    private int _testExecutionCounter;
    private int _testScheduleCounter;
    [CompilerGeneratedAttribute]
private TestProfile <Profile>k__BackingField;
    public TestProfile Profile { get; }
    public TestExecutionManager(TestSuite testSuite, ITestScheduler testScheduler, ITestLogger logger, ITimeService timeService, TestProfile testProfile, ITestRunTracerBroker tracerBroker, TraceEventFactory traceEventFactory);
    [CompilerGeneratedAttribute]
public TestProfile get_Profile();
    public sealed virtual TestExecutionId GetNextTest(int threadId);
    public sealed virtual void RegisterTestItemStart(TestExecutionId testExecutionId, int threadId);
    public sealed virtual void RegisterTestItemPreliminaryResult(TestExecutionId testExecutionId, int threadId, TestNodeResultType preliminaryTestResult);
    public sealed virtual void RegisterTestItemResult(TestExecutionId testExecutionId, TestNodeResult testNodeResult);
    public sealed virtual void RegisterThreadStart(int threadId, string machineName);
    public sealed virtual void RegisterThreadFinish(int threadId, Exception testThreadError);
    public sealed virtual void ThreadCancelled(int threadId);
    public sealed virtual bool GetIsCancelled();
    public TestItem GetTestItem(int testId);
    public TestNode GetTestNode(int nodeId);
    public sealed virtual TestSuite GetTestSuite();
    private void OnClientCancel();
    private bool HandleSkipped(Nullable`1<int> testId);
    private int RegisterTestItemScheduled(int testId, int threadId);
    private TestItemExecutionResult GetCurrentResult(TestExecutionId testExecutionId);
    private bool IsFirstExecution(TestItemExecutionResult testResult);
    private bool ShouldRetry(TestNodeResultType testResult);
    private bool EvaluateCancelling(TestExecutionId testExecutionId, TestNodeResultType preliminaryTestResult);
    public TestRunResult GetResult(TestProfile configuration);
    private void ProcessNotExecutedTests();
    private void RegisterNotExecutedTest(int testId, int executionIndex, TestNodeResultType resultType, TraceEvent[] traceEvents);
    private void CompleteTestAsSkipped(TestItemExecutionResult testItemExecutionResult);
    private void IgnoreTest(TestItem testItem);
}
public class TechTalk.SpecRun.Framework.TestProcessInfo : object {
    [CompilerGeneratedAttribute]
private string <ExecutorPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseShellExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    public string ExecutorPath { get; public set; }
    public string Arguments { get; public set; }
    public bool UseShellExecute { get; public set; }
    public Dictionary`2<string, string> EnvironmentVariables { get; private set; }
    public string WorkingDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExecutorPath();
    [CompilerGeneratedAttribute]
public void set_ExecutorPath(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public bool get_UseShellExecute();
    [CompilerGeneratedAttribute]
public void set_UseShellExecute(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
private void set_EnvironmentVariables(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
}
public abstract class TechTalk.SpecRun.Framework.TestSchedulers.EnumeratorBasedTestScheduler : object {
    private List`1<TestThreadConfiguration> _testThreadConfigurations;
    protected ITestLogger Logger;
    private PostponingEnumerator`1<TestItem> _enumerator;
    private RescheduleTestEnumerator _rescheduleTestEnumerator;
    protected EnumeratorBasedTestScheduler(List`1<TestThreadConfiguration> testThreadConfigurations, ITestLogger logger);
    private void EnsureEnumerator();
    protected abstract virtual IEnumerable`1<TestItem> GetEnumerable();
    public sealed virtual Nullable`1<int> GetNextTest(int threadId);
    private TestItem HandleTestThreadAffinity(int threadId, TestItem testItem);
    private bool PostPoneTestItem(int threadId, TestItem testItem);
    private bool IsRunningInParallel(int threadId);
    private List`1<MatchResultForTestThread> TestItemMatchesAnyOtherTestThread(TestThreadConfiguration[] otherThreads, TestItem testItem);
    private bool EvaluateHowToMatch(bool hasFilter);
    private MatchResult TestItemMatchesCurrentTestThread(TestThreadConfiguration testThreadConfig, TestItem testItem);
    private MatchResult GetMatchResult(bool match, bool matchUnspecified);
    public virtual void ReSchedule(TestItem testItem, int count, int threadId);
}
public interface TechTalk.SpecRun.Framework.TestSchedulers.IRandomizer {
    public abstract virtual List`1<T> Shuffle(IEnumerable`1<T> source);
}
public interface TechTalk.SpecRun.Framework.TestSchedulers.ITestScheduler {
    public abstract virtual Nullable`1<int> GetNextTest(int threadId);
    public abstract virtual void ReSchedule(TestItem testItem, int count, int threadId);
}
public class TechTalk.SpecRun.Framework.TestSchedulers.PostponingEnumerator`1 : object {
    private T current;
    private IEnumerator`1<T> innerEnumerator;
    private Queue`1<T> postponedItems;
    private Queue`1<T> reScheduledItems;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public PostponingEnumerator`1(IEnumerator`1<T> innerEnumerator);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public bool MoveNext(bool resetPostponed);
    public bool Postpone();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class TechTalk.SpecRun.Framework.TestSchedulers.Randomizer : object {
    private Random rnd;
    public sealed virtual List`1<T> Shuffle(IEnumerable`1<T> source);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<int, T> <Shuffle>b__1_0(T t);
}
public class TechTalk.SpecRun.Framework.TestSchedulers.RandomTestScheduler : EnumeratorBasedTestScheduler {
    private IRandomizer randomizer;
    private IEnumerable`1<TestItem> randomizedTestEnumerable;
    public RandomTestScheduler(TestSuite testSuite, List`1<TestThreadConfiguration> testThreadConfigurations, ITestLogger logger);
    internal static IEnumerable`1<TestItem> RandomizeTestItems(IEnumerable`1<TestItem> sequence, List`1<TestThreadConfiguration> testThreadConfigurations, IRandomizer randomizer);
    private static bool IsThreadBound(TestItem testItem, List`1<TestThreadConfiguration> list);
    protected virtual IEnumerable`1<TestItem> GetEnumerable();
}
internal class TechTalk.SpecRun.Framework.TestSchedulers.RescheduleTestEnumerator : object {
    private ITestLogger _logger;
    private IEnumerator`1<TestItem> _normalItems;
    private Queue`1<TestItem> _rescheduledItems;
    [CompilerGeneratedAttribute]
private TestItem <Current>k__BackingField;
    public TestItem Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public RescheduleTestEnumerator(ITestLogger logger, IEnumerator`1<TestItem> normalItems);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual TestItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(TestItem value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public void ReSchedule(TestItem testItem, int count);
}
public class TechTalk.SpecRun.Framework.TestSchedulers.SequentialTestScheduler : EnumeratorBasedTestScheduler {
    private TestSuite testSuite;
    public SequentialTestScheduler(TestSuite testSuite, List`1<TestThreadConfiguration> testThreadConfigurations, ITestLogger logger);
    protected virtual IEnumerable`1<TestItem> GetEnumerable();
}
[RunsInTestAssemblyAppDomainAttribute]
public class TechTalk.SpecRun.Framework.TestSuiteProviders.AssemblyMethodFinder : object {
    private IReferenceFactory _referenceFactory;
    private ITaskExecutorFactory _taskExecutorFactory;
    public AssemblyMethodFinder(IReferenceFactory referenceFactory, ITaskExecutorFactory taskExecutorFactory);
    public sealed virtual IEnumerable`1<ITaskExecutor> GetAssemblyInitializeMethods(IAssemblyReference assemblyReference);
    public sealed virtual IEnumerable`1<ITaskExecutor> GetAssemblyCleanupMethods(IAssemblyReference assemblyReference);
}
[RunsInTestAssemblyAppDomainAttribute]
public class TechTalk.SpecRun.Framework.TestSuiteProviders.AssemblyNUnitTestCollectionProvider : RemotableObject {
    public TestAssemblyCollection BuildTestCollectionFromAssembly(Assembly testAssembly, FilterItem filterPredicate, INodeIdProvider& nodeIdProvider, TestCollection parentCollection);
    private StaticOrInstanceMethodExecutor GetExecutor(IMethodReference testMethod, TestItem testItem);
    private static StaticOrInstanceMethodExecutor GetExecutor(IMethodReference testMethod, TestItem testItem, IExpectedException expectedException, Object[] arguments, bool hasExpectedResult, object expectedResult);
    private static string GetFormattedArg(object a);
    private void SetIgnore(TestItem testItem, NUnitIgnoreAttribute ignoreAttribute);
    private TAttr GetAttribute(MethodInfo methodInfo);
    private IEnumerable`1<TAttr> GetAttributes(MethodInfo methodInfo);
    private TAttr GetAttribute(Type type);
    private IEnumerable`1<TAttr> GetAttributes(Type type);
    private IEnumerable`1<IMethodReference> GetMethodsWith(ITypeReference type);
}
[RunsInTestAssemblyAppDomainAttribute]
public class TechTalk.SpecRun.Framework.TestSuiteProviders.AssemblySpecRunTestCollectionProvider : RemotableObject {
    public TestAssemblyCollection BuildTestCollectionFromAssembly(Assembly testAssembly, INodeIdProvider& nodeIdProvider, FilterItem filterPredicate, TestCollection parentCollection);
    internal TestAssemblyCollection BuildTestCollectionFromAssembly(Assembly testAssembly, IReferenceFactory referenceFactory, ITaskExecutorFactory taskExecutorFactory, ITestHierarchyFactory testHierarchyFactory, IAssemblyMethodFinder assemblyMethodFinder, FilterItem filterPredicate, TestCollection parentCollection);
    public TestCollection BuildFeatureCollection(TestAssemblyCollection testAssemblyCollection, ITaskExecutorFactory taskExecutorFactory, ITestHierarchyFactory testHierarchyFactory, ITypeReference featureTypeRef, FilterItem filterPredicate, IAssemblyReference assemblyRef);
    public IEnumerable`1<TestItem> BuildScenarios(ITypeReference featureTypeRef, TestCollection featureCollection, ITaskExecutorFactory taskExecutorFactory, ITestHierarchyFactory testHierarchyFactory, IAssemblyReference assemblyRef);
    public Func`2<TestItem, bool> GetFilterMatchPredicate(FilterItem filterPredicate);
    public TestItem BuildScenarioTestItem(TestCollection featureCollection, ITaskExecutorFactory taskExecutorFactory, ITestHierarchyFactory testHierarchyFactory, IAssemblyReference assemblyRef, IMethodReference scenarioMethod, IMethodReference scenarioCleanupMethod);
}
[AttributeUsageAttribute("4")]
internal class TechTalk.SpecRun.Framework.TestSuiteProviders.AttributeWrapperAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string FullName { get; private set; }
    public AttributeWrapperAttribute(string fullName);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.TestSuiteProviders.Extensions.TestDiscoveryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodReference> GetMethodsWithAttribute(ITypeReference type);
    [ExtensionAttribute]
public static TAttr GetAttributeOrNull(MethodInfo methodInfo);
    [ExtensionAttribute]
public static TAttr GetAttributeOrNull(Type type);
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.FileTestAssemblyLoader : object {
    private string _fileName;
    public FileTestAssemblyLoader(string fileName);
    public sealed virtual IResult`1<Assembly> LoadAssembly();
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.IAssemblyMethodFinder {
    public abstract virtual IEnumerable`1<ITaskExecutor> GetAssemblyInitializeMethods(IAssemblyReference assemblyReference);
    public abstract virtual IEnumerable`1<ITaskExecutor> GetAssemblyCleanupMethods(IAssemblyReference assemblyReference);
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.INodeIdProvider {
    public abstract virtual int GetNextId();
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.IReferenceFactory {
    public abstract virtual IAssemblyReference BuildAssemblyReference(Assembly assembly);
    public abstract virtual ITypeReference BuildTypeReference(IAssemblyReference assemblyReference, Type type);
    public abstract virtual IMethodReference BuildMethodReference(ITypeReference typeReference, MethodInfo methodInfo);
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.ITaskExecutorFactory {
    public abstract virtual ITaskExecutor BuildChainedTaskExecutor(ITaskExecutor[] taskExecutors);
    public abstract virtual ITaskExecutor BuildInstanceMethodExecutor(IMethodReference methodReference);
    public abstract virtual ITaskExecutor BuildStaticMethodExecutor(IMethodReference methodReference);
    public abstract virtual ITaskExecutor BuildTestInstanceInitializer(ITypeReference testType);
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.ITestAssemblyLoader {
    public abstract virtual IResult`1<Assembly> LoadAssembly();
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.ITestHierarchyFactory {
    public abstract virtual TestAssemblyCollection BuildTestAssemblyCollection(TestCollection parentCollection);
    public abstract virtual TestCollection BuildFeatureTestCollection(TestAssemblyCollection parentTestNode, string title, string description, IEnumerable`1<string> tags, string sourceFile, int sourceLine, FSharpOption`1<string> ignoreMessage);
    public abstract virtual TestItem BuildScenarioTestItem(TestCollection parentFeatureTestCollection, string title, string description, IEnumerable`1<string> tags, int sourceLine, FSharpOption`1<string> ignoreMessage);
}
public interface TechTalk.SpecRun.Framework.TestSuiteProviders.ITestSuiteProvider {
    public abstract virtual TestSuite GetTestSuite(TestProfile testProfile);
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.NodeIdProvider : object {
    private int counter;
    public sealed virtual int GetNextId();
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.RemoteReferenceFactory : object {
    public sealed virtual IAssemblyReference BuildAssemblyReference(Assembly assembly);
    public sealed virtual ITypeReference BuildTypeReference(IAssemblyReference assemblyReference, Type type);
    public sealed virtual IMethodReference BuildMethodReference(ITypeReference typeReference, MethodInfo methodInfo);
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.TaskExecutorFactory : object {
    public sealed virtual ITaskExecutor BuildChainedTaskExecutor(ITaskExecutor[] taskExecutors);
    public sealed virtual ITaskExecutor BuildInstanceMethodExecutor(IMethodReference methodReference);
    public sealed virtual ITaskExecutor BuildStaticMethodExecutor(IMethodReference methodReference);
    public sealed virtual ITaskExecutor BuildTestInstanceInitializer(ITypeReference testType);
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.TestHierarchyFactory : object {
    private INodeIdProvider _nodeIdProvider;
    public TestHierarchyFactory(INodeIdProvider nodeIdProvider);
    public sealed virtual TestAssemblyCollection BuildTestAssemblyCollection(TestCollection parentCollection);
    public sealed virtual TestCollection BuildFeatureTestCollection(TestAssemblyCollection parentTestNode, string title, string description, IEnumerable`1<string> tags, string sourceFile, int sourceLine, FSharpOption`1<string> ignoreMessage);
    public sealed virtual TestItem BuildScenarioTestItem(TestCollection parentFeatureTestCollection, string title, string description, IEnumerable`1<string> tags, int sourceLine, FSharpOption`1<string> ignoreMessage);
}
public class TechTalk.SpecRun.Framework.TestSuiteProviders.TestSuiteProvider : object {
    private ITestLogger _testLogger;
    private ILogger _logger;
    private IAnalyticsTransmitter _analyticsTransmitter;
    private IAppDomainManager _appDomainManager;
    public TestSuiteProvider(IAppDomainManager appDomainManager, ITestLogger testLogger, ILogger logger, IAnalyticsTransmitter analyticsTransmitter);
    public sealed virtual TestSuite GetTestSuite(TestProfile testProfile);
    private void DumpTestSuite(TestSuite testSuite);
    private IEnumerable`1<TestAssemblyCollection> BuildTestCollectionFromAssembly(string testAssemblyPath, FilterItem filterPredicate, INodeIdProvider& nodeIdProvider, TestCollection parentCollection);
    private TestAssemblyCollection TryCollectSpecFlowPlusRunnerTests(ILoadedAssemblyReference appDomainRef, Assembly testAssembly, FilterItem filterPredicate, INodeIdProvider& nodeIdProvider, TestCollection parentCollection);
    private TestAssemblyCollection TryCollectNUnitTests(ILoadedAssemblyReference appDomainRef, Assembly testAssembly, FilterItem filterPredicate, INodeIdProvider& nodeIdProvider, TestCollection parentCollection);
}
public class TechTalk.SpecRun.Framework.TestSuiteRunner : object {
    private ITestSuiteProvider _testSuiteProvider;
    private ITestLogger _testLogger;
    private ITestRunTracerBroker _tracerBroker;
    private ITimeService _timeService;
    private TraceEventFactory _traceEventFactory;
    private TestSuite _testSuite;
    private List`1<TestThread> _testRunThreads;
    private ITestScheduler _testScheduler;
    private ISharedAppDomainHolder _sharedAppDomainHolder;
    private IFileSystemService _fileSystemService;
    private ILogger _logger;
    private IThreadFactory _threadFactory;
    private ITestThreadFactory _testThreadFactory;
    private IThreadApartmentStateFetcher _threadApartmentStateFetcher;
    private ICanRunMultipleTestThreadsRule _canRunMultipleTestThreadsRule;
    [CompilerGeneratedAttribute]
private TestProfile <TestProfile>k__BackingField;
    public TestProfile TestProfile { get; }
    public TestSuiteRunner(ITestSuiteProvider testSuiteProvider, ITestLogger testLogger, ITimeService timeService, ITestRunTracer testRunTracer, TraceEventFactory traceEventFactory, TestProfile testProfile, ISharedAppDomainHolder sharedAppDomainHolder, IFileSystemService fileSystemService, ILogger logger, IThreadFactory threadFactory, ITestThreadFactory testThreadFactory, IThreadApartmentStateFetcher threadApartmentStateFetcher, ICanRunMultipleTestThreadsRule canRunMultipleTestThreadsRule);
    [CompilerGeneratedAttribute]
public sealed virtual TestProfile get_TestProfile();
    public sealed virtual FSharpOption`1<TestRunResult> Run();
    private TestRunResult CreateFrameworkErrorResult();
    private Exception RunTestThreads(TestExecutionManager executionManager);
    private DeploymentContext ApplyDeploymentTransformations();
    private void RestoreDeploymentTransformations(DeploymentContext deploymentContext);
    private ITestScheduler CreateTestScheduler();
    private List`1<TestThread> DefineTestRunThreads();
    private TestThread CreateTestThread(int threadId);
}
public class TechTalk.SpecRun.Framework.TestThread : object {
    private ITestLogger _logger;
    private ITestRunTracerBroker _tracerBroker;
    private IFileSystemService _fileSystemService;
    private ITestThreadLogger _testThreadLogger;
    private ITestThreadExecutorFactory _testThreadExecutorFactory;
    private ITestExecutionConfigurationFactory _testExecutionConfigurationFactory;
    private Dictionary`2<TestThreadExecutorKey, TestThreadExecutorInfo> _testThreadExecutors;
    private TestSuite _testSuite;
    private ITestExecutionManager _executionManager;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private TestProfile <TestProfile>k__BackingField;
    public int ThreadId { get; private set; }
    public TestProfile TestProfile { get; private set; }
    public TestThreadConfiguration TestThreadConfiguration { get; }
    public TestSuite TestSuite { get; }
    public TestThread(IFileSystemService fileSystemService, ITestLogger logger, ITestRunTracerBroker tracerBroker, ITestThreadLogger testThreadLogger, ITestThreadExecutorFactory testThreadExecutorFactory, ITestExecutionConfigurationFactory testExecutionConfigurationFactory);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
private void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public TestProfile get_TestProfile();
    [CompilerGeneratedAttribute]
private void set_TestProfile(TestProfile value);
    public TestThreadConfiguration get_TestThreadConfiguration();
    public TestSuite get_TestSuite();
    public void Initialize(int threadId, TestProfile testProfile);
    public void Run(ITestExecutionManager executionManagerForRun, CancellationToken cancellationToken);
    internal void RunNonEmptyTestSuite(CancellationToken cancellationToken, TestThreadState testThreadState);
    private ITestAssemblyExecutor GetThreadExecutorForTestItem(TestItem testItem);
    private ITestAssemblyExecutor GetThreadExecutor(IAssemblyReference testAssembly, ExecutionModelSettings executionModelSettings, string testTarget);
    private TestThreadExecutorInfo InitializeTestThreadExecutor(IAssemblyReference testAssembly, ExecutionModelSettings executionModelSettings, string testTarget);
    private TestThreadExecutorInfo UnpackTestThreadExecutorInfoResult(IResult`1<TestThreadExecutorInfo> testThreadExecutorInfoResult);
    private IResult`1<TestThreadExecutorInfo> InitializeExecutor(ITestAssemblyExecutor executor, DeploymentContext deploymentContext, IAssemblyReference testAssembly);
    private DeploymentContext GetDeploymentContext(IAssemblyReference testAssembly, string testTarget);
    private TestItem GetTestItem(Nullable`1<int> testId);
    private void PerformThreadCleanup();
    [CompilerGeneratedAttribute]
private bool <get_TestThreadConfiguration>b__19_0(TestThreadConfiguration ttc);
}
public class TechTalk.SpecRun.Framework.TestThreadExecutorFactory : object {
    private IAppDomainManager _appDomainManager;
    private ISharedAppDomainHolder _sharedAppDomainHolder;
    private IOutProcExecutorManager _outProcExecutorManager;
    private ITestThreadLogger _testThreadLogger;
    public TestThreadExecutorFactory(IAppDomainManager appDomainManager, ISharedAppDomainHolder sharedAppDomainHolder, IOutProcExecutorManager outProcExecutorManager, ITestThreadLogger testThreadLogger);
    public sealed virtual IResult`1<ITestAssemblyExecutor> BuildTestThreadExecutor(ExecutionModelSettings executionModelSettings, DeploymentContext deploymentContext, ITestThreadLogger testThreadLogger);
    private TestExecutionConfiguration CreateTestExecutionConfiguration(TestProfile testProfile);
    private IResult`1<ITestAssemblyExecutor> CreateSharedAppDomainTestThreadExecutor(DeploymentContext deploymentContext);
    private IResult`1<ITestAssemblyExecutor> CreateOutProcTestThreadExecutor(ExecutionModelSettings executionModelSettings, DeploymentContext deploymentContext, ITestThreadLogger testThreadLogger);
    private IResult`1<ITestAssemblyExecutor> CreateInProcAppDomainTestThreadExecutor(DeploymentContext deploymentContext);
    private IOutProcExecutorManager GetOutProcExecutorManager(DeploymentContext deploymentContext, ExecutionModelSettings executionModelSettings);
}
public class TechTalk.SpecRun.Framework.TestThreadFactory : object {
    private ITestThreadLoggerFactory _testThreadLoggerFactory;
    private IAppDomainManager _appDomainManager;
    private ISharedAppDomainHolder _sharedAppDomainHolder;
    private IOutProcExecutorManager _outProcExecutorManager;
    private IFileSystemService _fileSystemService;
    private ITestRunTracerBroker _tracerBroker;
    private ITestExecutionConfigurationFactory _testExecutionConfigurationFactory;
    public TestThreadFactory(ITestThreadLoggerFactory testThreadLoggerFactory, IAppDomainManager appDomainManager, ISharedAppDomainHolder sharedAppDomainHolder, IOutProcExecutorManager outProcExecutorManager, IFileSystemService fileSystemService, ITestRunTracerBroker tracerBroker, ITestExecutionConfigurationFactory testExecutionConfigurationFactory);
    public sealed virtual TestThread BuildTestThreadWithIdAndTestLogger(int threadId, ITestLogger testLogger);
}
public class TechTalk.SpecRun.Framework.TestThreadLogger : object {
    private ITestLogger _testLogger;
    private int _testThreadId;
    public TestThreadLogger(ITestLogger testLogger, int testThreadId);
    public sealed virtual ITestLogger GetTestLogger();
    public sealed virtual void Log(string message);
}
public class TechTalk.SpecRun.Framework.TestThreadLoggerFactory : object {
    public sealed virtual ITestThreadLogger BuildFromTestLoggerAndTestThreadId(ITestLogger testLogger, int testThreadId);
}
public interface TechTalk.SpecRun.Framework.TestThreads.ICanRunMultipleTestThreadsRule {
    public abstract virtual bool CanRunMultipleTestThreads();
}
public class TechTalk.SpecRun.Framework.TestThreads.NetCoreCanRunMultipleTestThreadsRule : object {
    private IRuntimeInformationProvider _runtimeInformationProvider;
    private IThreadApartmentStateFetcher _threadApartmentStateFetcher;
    public NetCoreCanRunMultipleTestThreadsRule(IRuntimeInformationProvider runtimeInformationProvider, IThreadApartmentStateFetcher threadApartmentStateFetcher);
    public sealed virtual bool CanRunMultipleTestThreads();
}
public class TechTalk.SpecRun.Framework.TestThreads.NetFxCanRunMultipleTestThreadsRule : object {
    private IThreadApartmentStateFetcher _threadApartmentStateFetcher;
    public NetFxCanRunMultipleTestThreadsRule(IThreadApartmentStateFetcher threadApartmentStateFetcher);
    public sealed virtual bool CanRunMultipleTestThreads();
}
public class TechTalk.SpecRun.Framework.Tracing.TraceEventFactory : object {
    private ITimeService timeService;
    public TraceEventFactory(ITimeService timeService);
    private TraceEvent GetEmptyEvent(int testId);
    public TraceEvent GetFrameworkErrorEvent(int testId, Exception exception);
    public TraceEvent GetIgnoreEvent(int testId, string ignoreReason);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Utils.AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetResource(Type type, string relativePath);
    [ExtensionAttribute]
public static string GetResource(Assembly assembly, string relativePath, string defaultNamespace);
}
public class TechTalk.SpecRun.Framework.Versioning.RunnerVersionInfoProvider : object {
    public sealed virtual string GetVersion();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
