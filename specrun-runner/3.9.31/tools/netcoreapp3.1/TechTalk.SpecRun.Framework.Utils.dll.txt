[ExtensionAttribute]
internal static class DictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(IDictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool Contains(IDictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> newValue);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TValue> values, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TInput> inputValues, Func`2<TInput, TKey> keySelector, Func`2<TInput, TValue> valueSelector, IEqualityComparer`1<TKey> comparer);
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.ApplicationEnvironment : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationBasePath>k__BackingField;
    public static string ApplicationBasePath { get; }
    private static ApplicationEnvironment();
    [CompilerGeneratedAttribute]
public static string get_ApplicationBasePath();
    private static string GetApplicationBasePath();
}
internal class Internal.Microsoft.DotNet.PlatformAbstractions.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.NativeMethods : object {
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.PlatformApis : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    private static string GetDarwinVersion();
    public static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
    private static Platform DetermineOSPlatform();
}
internal enum Internal.Microsoft.DotNet.PlatformAbstractions.Platform : Enum {
    public int value__;
    public static Platform Unknown;
    public static Platform Windows;
    public static Platform Linux;
    public static Platform Darwin;
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment : object {
    private static string OverrideEnvironmentVariableName;
    [CompilerGeneratedAttribute]
private static Platform <OperatingSystemPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeArchitecture>k__BackingField;
    public static Platform OperatingSystemPlatform { get; }
    public static string OperatingSystemVersion { get; }
    public static string OperatingSystem { get; }
    public static string RuntimeArchitecture { get; }
    private static RuntimeEnvironment();
    [CompilerGeneratedAttribute]
public static Platform get_OperatingSystemPlatform();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystem();
    [CompilerGeneratedAttribute]
public static string get_RuntimeArchitecture();
    private static string GetArch();
    public static string GetRuntimeIdentifier();
    private static string GetRIDArch();
    private static string GetRIDVersion();
    private static string GetWindowsProductVersion();
    private static string GetRIDOS();
}
internal static class Internal.Microsoft.Extensions.DependencyModel.ApplicationEnvironment : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationBasePath>k__BackingField;
    public static string ApplicationBasePath { get; }
    private static ApplicationEnvironment();
    [CompilerGeneratedAttribute]
public static string get_ApplicationBasePath();
    private static string GetApplicationBasePath();
}
public class Internal.Microsoft.Extensions.DependencyModel.CompilationLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICompilationAssemblyResolver <DefaultResolver>k__BackingField;
    public IReadOnlyList`1<string> Assemblies { get; }
    internal static ICompilationAssemblyResolver DefaultResolver { get; }
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    private static CompilationLibrary();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
internal static ICompilationAssemblyResolver get_DefaultResolver();
    public IEnumerable`1<string> ResolveReferencePaths();
    public IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver[] customResolvers);
    private IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1<string> assemblies);
}
public class Internal.Microsoft.Extensions.DependencyModel.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EmitEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompilationOptions <Default>k__BackingField;
    public IReadOnlyList`1<string> Defines { get; }
    public string LanguageVersion { get; }
    public string Platform { get; }
    public Nullable`1<bool> AllowUnsafe { get; }
    public Nullable`1<bool> WarningsAsErrors { get; }
    public Nullable`1<bool> Optimize { get; }
    public string KeyFile { get; }
    public Nullable`1<bool> DelaySign { get; }
    public Nullable`1<bool> PublicSign { get; }
    public string DebugType { get; }
    public Nullable`1<bool> EmitEntryPoint { get; }
    public Nullable`1<bool> GenerateXmlDocumentation { get; }
    public static CompilationOptions Default { get; }
    public CompilationOptions(IEnumerable`1<string> defines, string languageVersion, string platform, Nullable`1<bool> allowUnsafe, Nullable`1<bool> warningsAsErrors, Nullable`1<bool> optimize, string keyFile, Nullable`1<bool> delaySign, Nullable`1<bool> publicSign, string debugType, Nullable`1<bool> emitEntryPoint, Nullable`1<bool> generateXmlDocumentation);
    private static CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafe();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublicSign();
    [CompilerGeneratedAttribute]
public string get_DebugType();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EmitEntryPoint();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateXmlDocumentation();
    [CompilerGeneratedAttribute]
public static CompilationOptions get_Default();
}
public class Internal.Microsoft.Extensions.DependencyModel.Dependency : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public Dependency(string name, string version);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    public bool Equals(Dependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Internal.Microsoft.Extensions.DependencyModel.DependencyContext : object {
    private static Lazy`1<DependencyContext> _defaultContext;
    [CompilerGeneratedAttribute]
private TargetInfo <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompilationLibrary> <CompileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeLibrary> <RuntimeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeFallbacks> <RuntimeGraph>k__BackingField;
    public static DependencyContext Default { get; }
    public TargetInfo Target { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList`1<CompilationLibrary> CompileLibraries { get; }
    public IReadOnlyList`1<RuntimeLibrary> RuntimeLibraries { get; }
    public IReadOnlyList`1<RuntimeFallbacks> RuntimeGraph { get; }
    public DependencyContext(TargetInfo target, CompilationOptions compilationOptions, IEnumerable`1<CompilationLibrary> compileLibraries, IEnumerable`1<RuntimeLibrary> runtimeLibraries, IEnumerable`1<RuntimeFallbacks> runtimeGraph);
    private static DependencyContext();
    public static DependencyContext get_Default();
    [CompilerGeneratedAttribute]
public TargetInfo get_Target();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompilationLibrary> get_CompileLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeLibrary> get_RuntimeLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeFallbacks> get_RuntimeGraph();
    public DependencyContext Merge(DependencyContext other);
    private static DependencyContext LoadDefault();
    public static DependencyContext Load(Assembly assembly);
}
[ExtensionAttribute]
public static class Internal.Microsoft.Extensions.DependencyModel.DependencyContextExtensions : object {
    private static string NativeImageSufix;
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetDefaultNativeRuntimeFileAssets(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetRuntimeNativeRuntimeFileAssets(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetDefaultNativeRuntimeFileAssets(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetRuntimeNativeRuntimeFileAssets(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    private static AssemblyName GetAssemblyName(string assetPath);
    private static IEnumerable`1<string> ResolveAssets(DependencyContext context, string runtimeIdentifier, IEnumerable`1<RuntimeAssetGroup> assets);
    private static IEnumerable`1<RuntimeFile> ResolveRuntimeFiles(DependencyContext context, string runtimeIdentifier, IEnumerable`1<RuntimeAssetGroup> assets);
    private static IEnumerable`1<string> SelectAssets(IEnumerable`1<string> rids, IEnumerable`1<RuntimeAssetGroup> groups);
    private static IEnumerable`1<RuntimeFile> SelectRuntimeFiles(IEnumerable`1<string> rids, IEnumerable`1<RuntimeAssetGroup> groups);
}
public class Internal.Microsoft.Extensions.DependencyModel.DependencyContextJsonReader : object {
    private IDictionary`2<string, string> _stringPool;
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private DependencyContext ReadCore(UnifiedJsonReader reader);
    private static Target SelectRuntimeTarget(List`1<Target> targets, string runtimeTargetName);
    private static bool IsRuntimeTarget(string name);
    private static void ReadRuntimeTarget(UnifiedJsonReader& reader, String& runtimeTargetName, String& runtimeSignature);
    private static CompilationOptions ReadCompilationOptions(UnifiedJsonReader& reader);
    private List`1<Target> ReadTargets(UnifiedJsonReader& reader);
    private Target ReadTarget(UnifiedJsonReader& reader, string targetName);
    private TargetLibrary ReadTargetLibrary(UnifiedJsonReader& reader, string targetLibraryName);
    private IEnumerable`1<Dependency> ReadTargetLibraryDependencies(UnifiedJsonReader& reader);
    private static List`1<string> ReadPropertyNames(UnifiedJsonReader& reader);
    private static List`1<RuntimeFile> ReadRuntimeFiles(UnifiedJsonReader& reader);
    private List`1<RuntimeTargetEntryStub> ReadTargetLibraryRuntimeTargets(UnifiedJsonReader& reader);
    private List`1<ResourceAssembly> ReadTargetLibraryResources(UnifiedJsonReader& reader);
    private Dictionary`2<string, LibraryStub> ReadLibraries(UnifiedJsonReader& reader);
    private LibraryStub ReadOneLibrary(UnifiedJsonReader& reader);
    private static List`1<RuntimeFallbacks> ReadRuntimes(UnifiedJsonReader& reader);
    private IEnumerable`1<Library> CreateLibraries(IEnumerable`1<TargetLibrary> libraries, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private Library CreateLibrary(TargetLibrary targetLibrary, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private string Pool(string s);
    public sealed virtual DependencyContext Read(Stream stream);
    private DependencyContext Read(JsonTextReader jsonReader);
}
public class Internal.Microsoft.Extensions.DependencyModel.DependencyContextLoader : object {
    private static string DepsJsonExtension;
    private string _entryPointDepsLocation;
    private IEnumerable`1<string> _nonEntryPointDepsPaths;
    private IFileSystem _fileSystem;
    private Func`1<IDependencyContextReader> _jsonReaderFactory;
    [CompilerGeneratedAttribute]
private static DependencyContextLoader <Default>k__BackingField;
    public static DependencyContextLoader Default { get; }
    internal DependencyContextLoader(string entryPointDepsLocation, IEnumerable`1<string> nonEntryPointDepsPaths, IFileSystem fileSystem, Func`1<IDependencyContextReader> jsonReaderFactory);
    private static DependencyContextLoader();
    [CompilerGeneratedAttribute]
public static DependencyContextLoader get_Default();
    private static bool IsEntryAssembly(Assembly assembly);
    private static Stream GetResourceStream(Assembly assembly, string name);
    public DependencyContext Load(Assembly assembly);
    private DependencyContext LoadEntryAssemblyContext(IDependencyContextReader reader);
    private DependencyContext LoadContext(IDependencyContextReader reader, string location);
    private DependencyContext LoadAssemblyContext(Assembly assembly, IDependencyContextReader reader);
    private string GetDepsJsonPath(Assembly assembly);
    private static string GetNormalizedCodeBasePath(Assembly assembly);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextPaths : object {
    private static string DepsFilesProperty;
    private static string FxDepsFileProperty;
    [CompilerGeneratedAttribute]
private static DependencyContextPaths <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonApplicationPaths>k__BackingField;
    public static DependencyContextPaths Current { get; }
    public string Application { get; }
    public string SharedRuntime { get; }
    public IEnumerable`1<string> NonApplicationPaths { get; }
    public DependencyContextPaths(string application, string sharedRuntime, IEnumerable`1<string> nonApplicationPaths);
    private static DependencyContextPaths();
    [CompilerGeneratedAttribute]
public static DependencyContextPaths get_Current();
    [CompilerGeneratedAttribute]
public string get_Application();
    [CompilerGeneratedAttribute]
public string get_SharedRuntime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonApplicationPaths();
    private static DependencyContextPaths GetCurrent();
    internal static DependencyContextPaths Create(string depsFiles, string sharedRuntime);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextStrings : object {
    internal static char VersionSeparator;
    internal static string CompileTimeAssembliesKey;
    internal static string RuntimeAssembliesKey;
    internal static string NativeLibrariesKey;
    internal static string RuntimeTargetPropertyName;
    internal static string LibrariesPropertyName;
    internal static string TargetsPropertyName;
    internal static string DependenciesPropertyName;
    internal static string Sha512PropertyName;
    internal static string PathPropertyName;
    internal static string HashPathPropertyName;
    internal static string RuntimeStoreManifestPropertyName;
    internal static string TypePropertyName;
    internal static string ServiceablePropertyName;
    internal static string CompilationOptionsPropertName;
    internal static string DefinesPropertyName;
    internal static string LanguageVersionPropertyName;
    internal static string PlatformPropertyName;
    internal static string AllowUnsafePropertyName;
    internal static string WarningsAsErrorsPropertyName;
    internal static string OptimizePropertyName;
    internal static string KeyFilePropertyName;
    internal static string DelaySignPropertyName;
    internal static string PublicSignPropertyName;
    internal static string DebugTypePropertyName;
    internal static string EmitEntryPointPropertyName;
    internal static string GenerateXmlDocumentationPropertyName;
    internal static string PortablePropertyName;
    internal static string RuntimeTargetNamePropertyName;
    internal static string RuntimeTargetSignaturePropertyName;
    internal static string RuntimesPropertyName;
    internal static string RuntimeTargetsPropertyName;
    internal static string RidPropertyName;
    internal static string AssetTypePropertyName;
    internal static string RuntimeAssetType;
    internal static string NativeAssetType;
    internal static string ResourceAssembliesPropertyName;
    internal static string LocalePropertyName;
    internal static string CompilationOnlyPropertyName;
    internal static string AssemblyVersionPropertyName;
    internal static string FileVersionPropertyName;
}
internal class Internal.Microsoft.Extensions.DependencyModel.DirectoryWrapper : object {
    public sealed virtual bool Exists(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.EnvironmentWrapper : object {
    public static IEnvironment Default;
    private static EnvironmentWrapper();
    public sealed virtual string GetEnvironmentVariable(string name);
    public sealed virtual bool IsWindows();
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileSystemWrapper : object {
    [CompilerGeneratedAttribute]
private static IFileSystem <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectory <Directory>k__BackingField;
    public static IFileSystem Default { get; }
    public IFile File { get; }
    public IDirectory Directory { get; }
    private static FileSystemWrapper();
    [CompilerGeneratedAttribute]
public static IFileSystem get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_File();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public sealed virtual void CreateEmptyFile(string path);
}
public interface Internal.Microsoft.Extensions.DependencyModel.IDependencyContextReader {
    public abstract virtual DependencyContext Read(Stream stream);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDirectory {
    public abstract virtual bool Exists(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IEnvironment {
    public abstract virtual string GetEnvironmentVariable(string name);
    public abstract virtual bool IsWindows();
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public abstract virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFileSystem {
    public IFile File { get; }
    public IDirectory Directory { get; }
    public abstract virtual IFile get_File();
    public abstract virtual IDirectory get_Directory();
}
public class Internal.Microsoft.Extensions.DependencyModel.Library : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Dependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeStoreManifestName>k__BackingField;
    public string Type { get; }
    public string Name { get; }
    public string Version { get; }
    public string Hash { get; }
    public IReadOnlyList`1<Dependency> Dependencies { get; }
    public bool Serviceable { get; }
    public string Path { get; }
    public string HashPath { get; }
    public string RuntimeStoreManifestName { get; }
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Dependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_HashPath();
    [CompilerGeneratedAttribute]
public string get_RuntimeStoreManifestName();
}
public class Internal.Microsoft.Extensions.DependencyModel.Resolution.AppBaseCompilationAssemblyResolver : object {
    private static string RefsDirectoryName;
    private IFileSystem _fileSystem;
    private string _basePath;
    private DependencyContextPaths _dependencyContextPaths;
    public AppBaseCompilationAssemblyResolver(string basePath);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem, string basePath, DependencyContextPaths dependencyContextPaths);
    private static AppBaseCompilationAssemblyResolver();
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
public class Internal.Microsoft.Extensions.DependencyModel.Resolution.CompositeCompilationAssemblyResolver : object {
    private ICompilationAssemblyResolver[] _resolvers;
    public CompositeCompilationAssemblyResolver(ICompilationAssemblyResolver[] resolvers);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
public class Internal.Microsoft.Extensions.DependencyModel.Resolution.DotNetReferenceAssembliesPathResolver : object {
    public static string DotNetReferenceAssembliesPathEnv;
    private static DotNetReferenceAssembliesPathResolver();
    internal static string Resolve(IEnvironment environment, IFileSystem fileSystem);
    public static string Resolve();
    private static string GetDefaultDotNetReferenceAssembliesPath(IFileSystem fileSystem);
}
public interface Internal.Microsoft.Extensions.DependencyModel.Resolution.ICompilationAssemblyResolver {
    public abstract virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
public class Internal.Microsoft.Extensions.DependencyModel.Resolution.PackageCompilationAssemblyResolver : object {
    private IFileSystem _fileSystem;
    private String[] _nugetPackageDirectories;
    public PackageCompilationAssemblyResolver(string nugetPackageDirectory);
    internal PackageCompilationAssemblyResolver(IEnvironment environment, IFileSystem fileSystem);
    internal PackageCompilationAssemblyResolver(IFileSystem fileSystem, String[] nugetPackageDirectories);
    internal static String[] GetDefaultProbeDirectories(IEnvironment environment);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private static bool TryResolveFromPackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, IEnumerable`1& results);
}
public class Internal.Microsoft.Extensions.DependencyModel.Resolution.ReferenceAssemblyPathResolver : object {
    private IFileSystem _fileSystem;
    private string _defaultReferenceAssembliesPath;
    private String[] _fallbackSearchPaths;
    public ReferenceAssemblyPathResolver(string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, IEnvironment environment);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveReferenceAssembly(string path, String& fullPath);
    internal static String[] GetFallbackSearchPaths(IFileSystem fileSystem, IEnvironment environment);
    internal static string GetDefaultReferenceAssembliesPath(IFileSystem fileSystem, IEnvironment environment);
}
internal static class Internal.Microsoft.Extensions.DependencyModel.Resolution.ResolverUtils : object {
    internal static bool TryResolvePackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, String& packagePath);
    internal static bool TryResolveAssemblyFile(IFileSystem fileSystem, string basePath, string assemblyPath, String& fullName);
}
public class Internal.Microsoft.Extensions.DependencyModel.ResourceAssembly : object {
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Locale { get; public set; }
    public string Path { get; public set; }
    public ResourceAssembly(string path, string locale);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
public class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssembly : object {
    private static string NativeImageSufix;
    private string _assemblyName;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public AssemblyName Name { get; }
    public string Path { get; }
    public RuntimeAssembly(string assemblyName, string path);
    public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public static RuntimeAssembly Create(string path);
}
public class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssetGroup : object {
    private IReadOnlyList`1<string> _assetPaths;
    private IReadOnlyList`1<RuntimeFile> _runtimeFiles;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    public string Runtime { get; }
    public IReadOnlyList`1<string> AssetPaths { get; }
    public IReadOnlyList`1<RuntimeFile> RuntimeFiles { get; }
    public RuntimeAssetGroup(string runtime, String[] assetPaths);
    public RuntimeAssetGroup(string runtime, IEnumerable`1<string> assetPaths);
    public RuntimeAssetGroup(string runtime, IEnumerable`1<RuntimeFile> runtimeFiles);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    public IReadOnlyList`1<string> get_AssetPaths();
    public IReadOnlyList`1<RuntimeFile> get_RuntimeFiles();
}
public class Internal.Microsoft.Extensions.DependencyModel.RuntimeFallbacks : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Fallbacks>k__BackingField;
    public string Runtime { get; public set; }
    public IReadOnlyList`1<string> Fallbacks { get; public set; }
    public RuntimeFallbacks(string runtime, String[] fallbacks);
    public RuntimeFallbacks(string runtime, IEnumerable`1<string> fallbacks);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Fallbacks();
    [CompilerGeneratedAttribute]
public void set_Fallbacks(IReadOnlyList`1<string> value);
}
public class Internal.Microsoft.Extensions.DependencyModel.RuntimeFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileVersion>k__BackingField;
    public string Path { get; }
    public string AssemblyVersion { get; }
    public string FileVersion { get; }
    public RuntimeFile(string path, string assemblyVersion, string fileVersion);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public string get_FileVersion();
}
public class Internal.Microsoft.Extensions.DependencyModel.RuntimeLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <RuntimeAssemblyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <NativeLibraryGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ResourceAssembly> <ResourceAssemblies>k__BackingField;
    public IReadOnlyList`1<RuntimeAssetGroup> RuntimeAssemblyGroups { get; }
    public IReadOnlyList`1<RuntimeAssetGroup> NativeLibraryGroups { get; }
    public IReadOnlyList`1<ResourceAssembly> ResourceAssemblies { get; }
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_RuntimeAssemblyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_NativeLibraryGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ResourceAssembly> get_ResourceAssemblies();
}
public class Internal.Microsoft.Extensions.DependencyModel.TargetInfo : object {
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    public string Framework { get; }
    public string Runtime { get; }
    public string RuntimeSignature { get; }
    public bool IsPortable { get; }
    public TargetInfo(string framework, string runtime, string runtimeSignature, bool isPortable);
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public string get_RuntimeSignature();
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Internal.Microsoft.Extensions.DependencyModel.UnifiedJsonReader : ValueType {
    private JsonTextReader _reader;
    public UnifiedJsonReader(JsonTextReader reader);
    public bool Read();
    public string GetStringValue();
    public bool IsTokenTypeProperty();
    public bool TryReadStringProperty(String& name, String& value);
    public void ReadStartObject();
    public void CheckStartObject();
    public void CheckEndObject();
    public String[] ReadStringArray();
    public void Skip();
    public string ReadAsString();
    public Nullable`1<bool> ReadAsNullableBoolean();
    public bool ReadAsBoolean(bool defaultValue);
    private static Exception CreateUnexpectedException(JsonTextReader reader, string expected);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static RuntimeAssetGroup GetDefaultGroup(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static RuntimeAssetGroup GetRuntimeGroup(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static RuntimeAssetGroup GetGroup(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultAssets(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeAssets(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static IEnumerable`1<string> GetAssets(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetDefaultRuntimeFileAssets(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<RuntimeFile> GetRuntimeFileAssets(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static IEnumerable`1<RuntimeFile> GetRuntimeFiles(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public static class TechTalk.SpecRun.Framework.AssemblyResolver : object {
    internal static void Hook(String[] folders);
    private static bool IsGeneratedXmlSerializersFile(string assemblyName);
    private static bool IsResourcesFile(string assemblyName);
    private static bool IsNoDotNetAssemblyFile(string assemblyName);
    private static string GetAssemblyFileOrDefault(string directory, AssemblyName assemblyName);
    private static bool IsDemandedAssemblyFile(AssemblyName assemblyName, string file);
}
public static class TechTalk.SpecRun.Framework.Constants : object {
    public static string Version;
}
public class TechTalk.SpecRun.Framework.CurrentExecutionModelSettings : object {
    private IEnvironment _environment;
    public CurrentExecutionModelSettings(IEnvironment environment);
    public sealed virtual ExecutionModelSettings GetCurrent();
}
public class TechTalk.SpecRun.Framework.CurrentNetCoreFrameworkPathProvider : object {
    private IFileNameService _fileNameService;
    public CurrentNetCoreFrameworkPathProvider(IFileNameService fileNameService);
    public sealed virtual string GetCurrentNetCoreFrameworkPath();
}
public static class TechTalk.SpecRun.Framework.DebuggerUtils : object {
    public static bool WaitForDebuggerToAttach();
}
public class TechTalk.SpecRun.Framework.DirectoryAccess : object {
    public sealed virtual bool Exists(string directory);
    public sealed virtual IEnumerable`1<string> GetSubDirectories(string pathOfParent);
}
public class TechTalk.SpecRun.Framework.Execution.ExecutorMainLoopMutex : object {
    private AutoResetEvent _appCloseEvent;
    public void BlockAtMutex();
    public void ReleaseMutex();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object sender, ConsoleCancelEventArgs eventArgs);
}
public class TechTalk.SpecRun.Framework.Execution.InProcess.InProcAppDomainTestAssemblyExecutor : object {
    public static string TestAssemblyExecutorTypeName;
    private AssemblyLoadContext _assemblyLoadContext;
    private ITestExecutionManager _testExecutionManagerHost;
    private ITestAssemblyExecutor _executor;
    private ITestLogger _testLogger;
    public InProcAppDomainTestAssemblyExecutor(AssemblyLoadContext assemblyLoadContext);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(int threadId, ITestExecutionManager executionManager, IAssemblyReference assemblyReference, ITestLogger testLogger, string testAssemblyFullPath, string testAssemblyConfigFilePath, TestExecutionConfiguration testExecutionConfiguration, string target);
    public sealed virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
}
public class TechTalk.SpecRun.Framework.Execution.InProcess.InProcAppDomainTestAssemblyExecutorHost : object {
    private IAppDomainManager _appDomainManager;
    private ILoadedAssemblyReference _appDomainRef;
    private ITestAssemblyExecutor _executor;
    private RemotableTestExecutionManagerHost _executionManagerHost;
    private RemotableLoggerHost _loggerHost;
    public InProcAppDomainTestAssemblyExecutorHost(IAppDomainManager appDomainManager);
    public virtual void Initialize(int threadId, ITestExecutionManager executionManager, IAssemblyReference testAssembly, ITestLogger logger, string testAssemblyFullPath, string testAssemblyConfigFilePath, TestExecutionConfiguration testExecutionConfiguration, string target);
    public virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    public virtual void Dispose();
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.ExecutorProcessStartInfo : object {
    [CompilerGeneratedAttribute]
private ClrVersion <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CallbackPort>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LoggerPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpecRunUniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetProbingDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveExecutorFullPath>k__BackingField;
    public ClrVersion ClrVersion { get; public set; }
    public Platform Platform { get; public set; }
    public ushort CallbackPort { get; public set; }
    public ushort LoggerPort { get; public set; }
    public string SpecRunUniqueId { get; public set; }
    public string NuGetProbingDirectories { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool IsDebugMode { get; public set; }
    public bool ResolveExecutorFullPath { get; public set; }
    [CompilerGeneratedAttribute]
public ClrVersion get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(ClrVersion value);
    [CompilerGeneratedAttribute]
public Platform get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(Platform value);
    [CompilerGeneratedAttribute]
public ushort get_CallbackPort();
    [CompilerGeneratedAttribute]
public void set_CallbackPort(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_LoggerPort();
    [CompilerGeneratedAttribute]
public void set_LoggerPort(ushort value);
    [CompilerGeneratedAttribute]
public string get_SpecRunUniqueId();
    [CompilerGeneratedAttribute]
public void set_SpecRunUniqueId(string value);
    [CompilerGeneratedAttribute]
public string get_NuGetProbingDirectories();
    [CompilerGeneratedAttribute]
public void set_NuGetProbingDirectories(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_IsDebugMode();
    [CompilerGeneratedAttribute]
public void set_IsDebugMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResolveExecutorFullPath();
    [CompilerGeneratedAttribute]
public void set_ResolveExecutorFullPath(bool value);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.ExternalExecutorPortInfo : object {
    [CompilerGeneratedAttribute]
private ushort <LoggerPort>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CallbackPort>k__BackingField;
    public ushort LoggerPort { get; }
    public ushort CallbackPort { get; }
    public ExternalExecutorPortInfo(ushort loggerPort, ushort callbackPort);
    [CompilerGeneratedAttribute]
public ushort get_LoggerPort();
    [CompilerGeneratedAttribute]
public ushort get_CallbackPort();
}
public interface TechTalk.SpecRun.Framework.Execution.OutOfProcess.IClientFactory {
    public abstract virtual IRpcClient CreateClientToOutOfProcessExecutor(ushort serverPort, Action`1<string> logAction);
    public abstract virtual IRpcClient CreateCallbackClient(ushort serverPort, Action`1<string> logAction);
    public abstract virtual IRpcClient CreateLoggerClient(ushort serverPort, Action`1<string> logAction);
}
public interface TechTalk.SpecRun.Framework.Execution.OutOfProcess.IRunnerPortInfoProvider {
    public ushort CallbackPort { get; }
    public ushort LoggerPort { get; }
    public abstract virtual ushort get_CallbackPort();
    public abstract virtual ushort get_LoggerPort();
}
public interface TechTalk.SpecRun.Framework.Execution.OutOfProcess.IServerFactory {
    public abstract virtual IRpcServer CreateLoggerServer(ITestLogger currentLogger, UInt16& port);
    public abstract virtual IRpcServer CreateCallbackServer(IOutOfProcessTestAssemblyExecutorCallback outOfProcessTestAssemblyExecutorCallback, UInt16& port);
    public abstract virtual IRpcServer CreateExecutorServer(OutOfProcessTestAssemblyExecutorReceiver outOfProcessTestAssemblyExecutorReceiver, UInt16& serverPort);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessLoggerClient : TestLogger {
    private IRpcClient _rpcClient;
    public OutOfProcessLoggerClient(IRpcClient rpcClient, ITimeService timeService);
    public virtual void LogInternal(string message);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessLoggerReceiver : object {
    private ITestLogger _testLogger;
    public OutOfProcessLoggerReceiver(ITestLogger testLogger);
    public sealed virtual void Log(string message);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessTestAssemblyExecutor : object {
    private ITestExecutionManager _executionManager;
    private ITestLogger _logger;
    private ITestAssemblyExecutorFactory _testAssemblyExecutorFactory;
    private IThreadFactory _threadFactory;
    private ExecutorMainLoopMutex _executorMainLoopMutex;
    private ApartmentState _apartmentStateForRun;
    private ITestAssemblyExecutor _outProcExecutor;
    private bool _isDisposed;
    public OutOfProcessTestAssemblyExecutor(ITestExecutionManager executionManager, ITestLogger logger, ITestAssemblyExecutorFactory testAssemblyExecutorFactory, IThreadFactory threadFactory, ExecutorMainLoopMutex executorMainLoopMutex);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Initialize(int threadId, RemoteAssemblyReference assemblyReference, string testAssemblyFullPath, string testAssemblyConfigFilePath, ApartmentState apartmentState, TestExecutionConfiguration testExecutionConfiguration, string target);
    public sealed virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    protected virtual ITestAssemblyExecutor CreateTestAssemblyExecutor(ITestLogger logger, string testAssemblyFullPath);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessTestAssemblyExecutorCallback : object {
    private ITestExecutionManager _executionManager;
    private Action`1<ushort> _executorPortReceivedCallback;
    public OutOfProcessTestAssemblyExecutorCallback(ITestExecutionManager executionManager, Action`1<ushort> executorPortReceivedCallback);
    public sealed virtual TestExecutionId GetNextTest(int threadId);
    public sealed virtual TestSuite GetTestSuite();
    public sealed virtual void PostExecutorPort(ushort port);
    public sealed virtual void RegisterTestItemStart(TestExecutionId testExecutionId, int threadId);
    public sealed virtual void RegisterTestItemPreliminaryResult(TestExecutionId testExecutionId, int threadId, TestNodeResultType preliminaryTestResult);
    public sealed virtual void RegisterThreadStart(int threadId, string machineName);
    public sealed virtual void RegisterTestItemResult(TestExecutionId testExecutionId, TestNodeResult testNodeResult);
    public sealed virtual void RegisterThreadFinish(int threadId);
    public sealed virtual void ThreadCancelled(int threadId);
    public sealed virtual bool GetIsCancelled();
    public void Dispose();
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessTestAssemblyExecutorCallbackClient : object {
    private IRpcClient _rpcClient;
    public OutOfProcessTestAssemblyExecutorCallbackClient(IRpcClient rpcClient);
    public void Log(string message);
    public sealed virtual TestExecutionId GetNextTest(int threadId);
    public sealed virtual TestSuite GetTestSuite();
    public sealed virtual void PostExecutorPort(ushort port);
    public sealed virtual void RegisterTestItemStart(TestExecutionId testExecutionId, int threadId);
    public sealed virtual void RegisterTestItemPreliminaryResult(TestExecutionId testExecutionId, int threadId, TestNodeResultType preliminaryTestResult);
    public sealed virtual void RegisterTestItemResult(TestExecutionId testExecutionId, TestNodeResult testNodeResult);
    public sealed virtual void RegisterThreadStart(int threadId, string machineName);
    public sealed virtual void RegisterThreadFinish(int threadId);
    public sealed virtual void ThreadCancelled(int threadId);
    public sealed virtual bool GetIsCancelled();
    [CompilerGeneratedAttribute]
private Task`1<TestSuite> <GetTestSuite>b__4_0();
    [CompilerGeneratedAttribute]
private Task`1<bool> <GetIsCancelled>b__12_0();
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.OutOfProcessTestAssemblyExecutorReceiver : object {
    private OutOfProcessTestAssemblyExecutor _outOfProcessTestAssemblyExecutor;
    private OutOfProcessLoggerClient _outOfProcessLoggerClient;
    private ITestAssemblyExecutorFactory _testAssemblyExecutorFactory;
    private IThreadFactory _threadFactory;
    private TestAssemblyExecutorCallbackSink _callbackSink;
    private ExecutorMainLoopMutex _executorMainLoopMutex;
    public OutOfProcessTestAssemblyExecutorReceiver(OutOfProcessLoggerClient outOfProcessLoggerClient, ITestAssemblyExecutorFactory testAssemblyExecutorFactory, IThreadFactory threadFactory, TestAssemblyExecutorCallbackSink callbackSink, ExecutorMainLoopMutex executorMainLoopMutex);
    public sealed virtual void Initialize(int threadId, RemoteAssemblyReference assemblyReference, string testAssemblyFullPath, string testAssemblyConfigFilePath, ApartmentState apartmentState, TestExecutionConfiguration testExecutionConfiguration, string target);
    public sealed virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    public sealed virtual void Dispose();
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.TcpClientFactory : object {
    private IRpcClientFactory _rpcClientFactory;
    public TcpClientFactory(IRpcClientFactory rpcClientFactory);
    public sealed virtual IRpcClient CreateClientToOutOfProcessExecutor(ushort serverPort, Action`1<string> logAction);
    public sealed virtual IRpcClient CreateCallbackClient(ushort serverPort, Action`1<string> logAction);
    public sealed virtual IRpcClient CreateLoggerClient(ushort serverPort, Action`1<string> logAction);
}
public class TechTalk.SpecRun.Framework.Execution.OutOfProcess.TcpServerFactory : object {
    private static ushort MinPortToSearch;
    private static ushort MaxPortToSearch;
    private static int Retries;
    private IRpcServerFactory _rpcServerFactory;
    private IPortFinder _portFinder;
    private ITestLogger _testLogger;
    public TcpServerFactory(IRpcServerFactory rpcServerFactory, IPortFinder portFinder, ITestLogger testLogger);
    public ushort GetFirstFreePort();
    public IResult`1<TResult> UntilSuccessOrRetryLimit(Func`1<IResult`1<TResult>> func, int retries);
    public IResult`1<IRpcServer> TryCreateTcpRpcServerFor(object target, Action`1<string> logAction, UInt16& port);
    public sealed virtual IRpcServer CreateLoggerServer(ITestLogger currentLogger, UInt16& port);
    public sealed virtual IRpcServer CreateCallbackServer(IOutOfProcessTestAssemblyExecutorCallback outOfProcessTestAssemblyExecutorCallback, UInt16& port);
    public sealed virtual IRpcServer CreateExecutorServer(OutOfProcessTestAssemblyExecutorReceiver outOfProcessTestAssemblyExecutorReceiver, UInt16& serverPort);
}
public interface TechTalk.SpecRun.Framework.Execution.SharedAppDomain.ISharedAppDomainHolder {
    public abstract virtual ILoadedAssemblyReference GetAppDomain(IAppDomainManager appDomainManager, string testAssemblyFullPath, string testAsseblyConfigFilePath);
    public abstract virtual void ReleaseAppDomainForThread();
    public abstract virtual void ReleaseAppDomain();
}
public class TechTalk.SpecRun.Framework.Execution.SharedAppDomain.SharedAppDomainHolder : object {
    private ILoadedAssemblyReference _appDomainRef;
    private object _appDomainLock;
    private int _refCount;
    public sealed virtual ILoadedAssemblyReference GetAppDomain(IAppDomainManager appDomainManager, string testAssemblyFullPath, string testAsseblyConfigFilePath);
    public sealed virtual void ReleaseAppDomainForThread();
    public sealed virtual void ReleaseAppDomain();
}
public class TechTalk.SpecRun.Framework.Execution.SharedAppDomain.SharedAppDomainTestAssemblyExecutorHost : object {
    private IAppDomainManager _appDomainManager;
    private ISharedAppDomainHolder _sharedAppDomainHolder;
    private ITestAssemblyExecutor _executor;
    private RemotableTestExecutionManagerHost _executionManagerHost;
    private RemotableLoggerHost _loggerHost;
    public SharedAppDomainTestAssemblyExecutorHost(IAppDomainManager appDomainManager, ISharedAppDomainHolder sharedAppDomainHolder);
    public virtual void Initialize(int threadId, ITestExecutionManager executionManager, IAssemblyReference testAssembly, ITestLogger logger, string testAssemblyFullPath, string testAssemblyConfigFilePath, TestExecutionConfiguration testExecutionConfiguration, string target);
    public virtual TestThreadState RunTests(TestThreadState testThreadState);
    public sealed virtual void DeInitialize();
    public virtual void Dispose();
}
internal class TechTalk.SpecRun.Framework.FrameworkDependent.AssemblyHelper : AssemblyLoadContext {
    private DependencyContextAssemblyCache assemblyCache;
    private ITestLogger _logger;
    public AssemblyHelper(string assemblyFileName, ITestLogger logger);
    public sealed virtual void Dispose();
    protected virtual Assembly Load(AssemblyName assemblyName);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    private Assembly OnResolving(AssemblyLoadContext context, AssemblyName name);
    [CompilerGeneratedAttribute]
private IntPtr <LoadUnmanagedDll>b__5_0(string path);
    [CompilerGeneratedAttribute]
private Assembly <OnResolving>b__6_0(string path);
}
public class TechTalk.SpecRun.Framework.FrameworkDependent.AssemblyLoadContextFactory : object {
    private ITestLogger _logger;
    public AssemblyLoadContextFactory(ITestLogger logger);
    public sealed virtual AssemblyLoadContext Create(string testAssemblyFullPath, ITestLogger logger);
}
internal class TechTalk.SpecRun.Framework.FrameworkDependent.DependencyContextAssemblyCache : object {
    private static RuntimeFallbacks AnyAndBase;
    private static String[] ManagedAssemblyExtensions;
    private static Tuple`2<string, Assembly> ManagedAssemblyNotFound;
    private static Regex RuntimeIdRegex;
    private IAdditionalProbingDirectoriesProvider _additionalProbingDirectoriesProvider;
    private string _assemblyFolder;
    private XunitPackageCompilationAssemblyResolver _assemblyResolver;
    private string currentRuntimeIdentifier;
    private DependencyContext _dependencyContext;
    private Lazy`1<string> fallbackRuntimeIdentifier;
    private IFileSystem _fileSystem;
    private Dictionary`2<string, Assembly> managedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> _managedAssemblyMap;
    private Platform operatingSystemPlatform;
    private String[] unmanagedDllFormats;
    private Dictionary`2<string, string> unmanagedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> unmanagedAssemblyMap;
    private ITestLogger _logger;
    private static Regex TfmRegex;
    private static string DefaultTfm;
    public DependencyContextAssemblyCache(string assemblyFolder, DependencyContext dependencyContext, IAdditionalProbingDirectoriesProvider additionalProbingDirectoriesProvider, ITestLogger logger, Nullable`1<Platform> operatingSystemPlatform, string currentRuntimeIdentifier, IFileSystem fileSystem);
    private static DependencyContextAssemblyCache();
    private List`1<string> GetCompatibleRuntimes(DependencyContext dependencyContext);
    private RuntimeFallbacks GetFallbacks(IReadOnlyList`1<RuntimeFallbacks> runtimeGraph);
    private string GetFallbackRuntime(string runtime);
    [IteratorStateMachineAttribute("TechTalk.SpecRun.Framework.FrameworkDependent.DependencyContextAssemblyCache/<GetUnmanagedDllFormats>d__22")]
private IEnumerable`1<string> GetUnmanagedDllFormats();
    public Assembly LoadManagedDll(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public IntPtr LoadUnmanagedLibrary(string unmanagedLibraryName, Func`2<string, IntPtr> unmanagedAssemblyLoader);
    public FSharpOption`1<ValueTuple`2<string, Assembly>> ResolveManagedAssemblyCompileLibraries(string assemblyName, string packagesRootFolder, Func`2<string, Assembly> managedAssemblyLoader);
    public FSharpOption`1<ValueTuple`2<string, Assembly>> ResolveManagedAssemblyFromFolder(string assemblyName, string folder, Func`2<string, Assembly> managedAssemblyLoader);
    public FSharpOption`1<ValueTuple`2<string, Assembly>> ResolveManagedAssemblyFromDepsJson(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public FSharpOption`1<ValueTuple`2<string, Assembly>> ResolveManagedAssemblyFromSharedFrameworks(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    [IteratorStateMachineAttribute("TechTalk.SpecRun.Framework.FrameworkDependent.DependencyContextAssemblyCache/<GetNETCoreSdkSharedFrameworkPaths>d__29")]
public IEnumerable`1<string> GetNETCoreSdkSharedFrameworkPaths(string originalPath, string sdkVersion);
    public FSharpOption`1<string> GetNETCoreSdkVersionFromPath(string path);
    private string GetTfm();
    private Tuple`2<string, Assembly> ResolveManagedAssembly(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public string ResolveUnmanagedLibrary(string unmanagedLibraryName);
    [CompilerGeneratedAttribute]
private string <.ctor>b__18_0();
    [CompilerGeneratedAttribute]
private bool <GetFallbacks>b__20_0(RuntimeFallbacks x);
    [CompilerGeneratedAttribute]
private bool <GetFallbacks>b__20_1(RuntimeFallbacks x);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.FrameworkDependent.DotNetCore.Remoting.AssemblyResolution.TargetFrameworkExtensions : object {
    private static Regex TfmRegex;
    public static string DefaultTfm;
    private static TargetFrameworkExtensions();
    [ExtensionAttribute]
public static string AsTfm(string targetFramework);
}
public interface TechTalk.SpecRun.Framework.FrameworkDependent.IAdditionalProbingDirectoriesProvider {
    public abstract virtual IEnumerable`1<string> GetProbingDirectories();
}
public interface TechTalk.SpecRun.Framework.FrameworkDependent.IAssemblyLoadContextFactory {
    public abstract virtual AssemblyLoadContext Create(string testAssemblyFullPath, ITestLogger logger);
}
public interface TechTalk.SpecRun.Framework.FrameworkDependent.ITestAssemblyExecutorFactory {
    public abstract virtual ITestAssemblyExecutor Create(ITestLogger logger, string testAssemblyFullPath);
}
internal class TechTalk.SpecRun.Framework.FrameworkDependent.Remoting.AssemblyLoadContextReference : object {
    private AssemblyLoadContext _assemblyLoadContext;
    public AssemblyLoadContextReference(AssemblyLoadContext assemblyLoadContext);
    public sealed virtual T CreateObjectFromAssembly(Object[] args);
    public sealed virtual T CreateObject();
    public sealed virtual T CreateObject(Object[] args);
    public sealed virtual object CreateObjectOfTypeFromAssembly(string assemblyName, string typeFullName);
    public sealed virtual T CreateObjectOfType(string assemblyName, string typeFullName);
    public sealed virtual void Dispose();
}
public class TechTalk.SpecRun.Framework.FrameworkDependent.SpecFlowPlusAdditionalProbingDirectoriesProvider : object {
    public sealed virtual IEnumerable`1<string> GetProbingDirectories();
}
public class TechTalk.SpecRun.Framework.FrameworkDependent.TestAssemblyExecutorFactory : object {
    private IAssemblyLoadContextFactory _assemblyLoadContextFactory;
    public TestAssemblyExecutorFactory(IAssemblyLoadContextFactory assemblyLoadContextFactory);
    public sealed virtual ITestAssemblyExecutor Create(ITestLogger logger, string testAssemblyFullPath);
}
internal class TechTalk.SpecRun.Framework.FrameworkDependent.XunitPackageCompilationAssemblyResolver : object {
    private IFileSystem fileSystem;
    private List`1<string> nugetPackageDirectories;
    public XunitPackageCompilationAssemblyResolver(IFileSystem fileSystem);
    private static List`1<string> GetDefaultProbeDirectories();
    private static List`1<string> GetDefaultProbeDirectories(Platform osPlatform);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveFromPackagePath(CompilationLibrary library, string basePath, IEnumerable`1& results);
}
public interface TechTalk.SpecRun.Framework.ICurrentNetCoreFrameworkPathProvider {
    public abstract virtual string GetCurrentNetCoreFrameworkPath();
}
public interface TechTalk.SpecRun.Framework.IDirectoryAccess {
    public abstract virtual bool Exists(string directory);
    public abstract virtual IEnumerable`1<string> GetSubDirectories(string pathOfParent);
}
public interface TechTalk.SpecRun.Framework.INetCoreFrameworkVersionProvider {
    public abstract virtual string GetFullVersion();
    public abstract virtual string GetMajorMinorPatchVersion();
}
public interface TechTalk.SpecRun.Framework.INetCoreSharedFrameworkRootPathProvider {
    public abstract virtual string GetSharedFrameworksRootPath();
}
public interface TechTalk.SpecRun.Framework.INetCoreSharedFrameworksPathProvider {
    public abstract virtual IEnumerable`1<string> GetNetCoreSdkSharedFrameworkPaths(string frameworkVersion);
}
public interface TechTalk.SpecRun.Framework.IPathCombiner {
    public abstract virtual FSharpOption`1<string> CombinePaths(IEnumerable`1<string> paths);
    public abstract virtual FSharpOption`1<string> CombinePaths(String[] paths);
}
public static class TechTalk.SpecRun.Framework.JsonConverters : object {
    public static void AttachUsedConverters(JsonRpc jsonRpc);
}
[ExtensionAttribute]
public static class TechTalk.SpecRun.Framework.Logging.LoggerExtensions : object {
    [ExtensionAttribute]
public static void Log(ITestLogger logger, string messageFormat, object arg0, Object[] restArgs);
}
public class TechTalk.SpecRun.Framework.NetCoreFrameworkVersionProvider : object {
    private ICurrentNetCoreFrameworkPathProvider _currentNetCoreFrameworkPathProvider;
    public NetCoreFrameworkVersionProvider(ICurrentNetCoreFrameworkPathProvider currentNetCoreFrameworkPathProvider);
    public sealed virtual string GetFullVersion();
    public sealed virtual string GetMajorMinorPatchVersion();
}
public class TechTalk.SpecRun.Framework.NetCoreSharedFrameworkRootPathProvider : object {
    private ICurrentNetCoreFrameworkPathProvider _currentNetCoreFrameworkPathProvider;
    private IPathCombiner _pathCombiner;
    public NetCoreSharedFrameworkRootPathProvider(ICurrentNetCoreFrameworkPathProvider currentNetCoreFrameworkPathProvider, IPathCombiner pathCombiner);
    public sealed virtual string GetSharedFrameworksRootPath();
}
public class TechTalk.SpecRun.Framework.NetCoreSharedFrameworksPathProvider : object {
    private IDirectoryAccess _directoryAccess;
    private IFileNameService _fileNameService;
    private INetCoreSharedFrameworkRootPathProvider _netCoreSharedFrameworkRootPathProvider;
    private IPathCombiner _pathCombiner;
    public NetCoreSharedFrameworksPathProvider(IDirectoryAccess directoryAccess, IFileNameService fileNameService, INetCoreSharedFrameworkRootPathProvider netCoreSharedFrameworkRootPathProvider, IPathCombiner pathCombiner);
    [IteratorStateMachineAttribute("TechTalk.SpecRun.Framework.NetCoreSharedFrameworksPathProvider/<GetNetCoreSdkSharedFrameworkPaths>d__5")]
public sealed virtual IEnumerable`1<string> GetNetCoreSdkSharedFrameworkPaths(string frameworkVersion);
}
public class TechTalk.SpecRun.Framework.PathCombiner : object {
    public sealed virtual FSharpOption`1<string> CombinePaths(IEnumerable`1<string> paths);
    public sealed virtual FSharpOption`1<string> CombinePaths(String[] paths);
}
public class TechTalk.SpecRun.Framework.ProcessHelper : object {
    private static TimeSpan _timeout;
    private static int _timeOutInMilliseconds;
    [CompilerGeneratedAttribute]
private string <ConsoleOutput>k__BackingField;
    public string ConsoleOutput { get; private set; }
    private static ProcessHelper();
    [CompilerGeneratedAttribute]
public string get_ConsoleOutput();
    [CompilerGeneratedAttribute]
private void set_ConsoleOutput(string value);
    public string GetParametersString(String[] arguments);
    public ProcessResult RunProcess(ProcessStartInfo processStartInfo);
    public ProcessResult RunProcess(string workingDirectory, string executablePath, String[] arguments);
    private ProcessStartInfo CreateProcessStartInfo(string workingDirectory, string executablePath, string parameters);
}
public class TechTalk.SpecRun.Framework.ProcessResult : object {
    [CompilerGeneratedAttribute]
private string <StdOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CombinedOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    public string StdOutput { get; }
    public string StdError { get; }
    public string CombinedOutput { get; }
    public int ExitCode { get; }
    public ProcessResult(int exitCode, string stdOutput, string stdError, string combinedOutput);
    [CompilerGeneratedAttribute]
public string get_StdOutput();
    [CompilerGeneratedAttribute]
public string get_StdError();
    [CompilerGeneratedAttribute]
public string get_CombinedOutput();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
}
public class TechTalk.SpecRun.Framework.Remoting.AssemblyLoadContextManager : object {
    private IAssemblyLoadContextFactory _assemblyLoadContextFactory;
    public AssemblyLoadContextManager(IAssemblyLoadContextFactory assemblyLoadContextFactory);
    public sealed virtual ILoadedAssemblyReference CreateAppDomainFor(string assemblyPath, bool useConfig, string customConfigFilePath);
}
public interface TechTalk.SpecRun.Framework.Remoting.IAppDomainManager {
    public abstract virtual ILoadedAssemblyReference CreateAppDomainFor(string assemblyPath, bool useConfig, string customConfigFilePath);
}
public interface TechTalk.SpecRun.Framework.Remoting.ILoadedAssemblyReference {
    public abstract virtual T CreateObjectFromAssembly(Object[] args);
    public abstract virtual T CreateObject();
    public abstract virtual T CreateObject(Object[] args);
    public abstract virtual object CreateObjectOfTypeFromAssembly(string assemblyName, string typeFullName);
    public abstract virtual T CreateObjectOfType(string assemblyName, string typeFullName);
}
public class TechTalk.SpecRun.Framework.Remoting.RemoteDomainInitializer : object {
    private static List`1<Type> Types;
    private static RemoteDomainInitializer();
    [RunsInTestAssemblyAppDomainAttribute]
private static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args);
    private static Assembly GetAssembly(ResolveEventArgs args, Type type);
}
public class TechTalk.SpecRun.Framework.Services.EnvironmentPreparer : object {
    private IFileSystemService _fileSystemService;
    private IEnvironment _environment;
    private ILogger _logger;
    public EnvironmentPreparer(IFileSystemService fileSystemService, IEnvironment environment, ILogger logger);
    public sealed virtual void InitializeEnvironment(string outputFolder, string uniqueId);
}
public interface TechTalk.SpecRun.Framework.Services.IEnvironmentPreparer {
    public abstract virtual void InitializeEnvironment(string outputFolder, string uniqueId);
}
public static class TechTalk.SpecRun.Framework.Services.KnownEnvironmentVariableNames : object {
    public static string SpecRunOutputFolder;
    public static string SpecRunUniqueId;
}
public static class TechTalk.SpecRun.Framework.SpecRunMessageUtils : object {
    private static void SendMessage(string command, string argsFormat, Object[] argsArgs);
    public static void SendInfoVersionMessage();
    public static void SendDebugProcessMessage(int pid);
    public static void SendDebugReadyMessage();
    public static void SendDebugSkipMessage();
}
public class TechTalk.SpecRun.Framework.SubfolderAssemblyResolver : object {
    public static void Enable();
    public static string GetTestAdapterSubFolder(ClrVersion clrVersion);
}
public class TechTalk.SpecRun.Framework.TestAssemblyExecutorCallbackSink : object {
    private IOutOfProcessTestAssemblyExecutorCallback _callback;
    public TestAssemblyExecutorCallbackSink(IOutOfProcessTestAssemblyExecutorCallback callback);
    public sealed virtual TestExecutionId GetNextTest(int threadId);
    public sealed virtual void RegisterTestItemStart(TestExecutionId testExecutionId, int threadId);
    public sealed virtual void RegisterTestItemPreliminaryResult(TestExecutionId testExecutionId, int threadId, TestNodeResultType preliminaryTestResult);
    public sealed virtual void RegisterTestItemResult(TestExecutionId testExecutionId, TestNodeResult testNodeResult);
    public sealed virtual void RegisterThreadStart(int threadId, string machineName);
    public sealed virtual void RegisterThreadFinish(int threadId, Exception testThreadError);
    public sealed virtual void ThreadCancelled(int threadId);
    public sealed virtual bool GetIsCancelled();
    public sealed virtual TestSuite GetTestSuite();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[DefaultMemberAttribute("Item")]
internal class Xunit.JsonArray : JsonValue {
    private JsonValue[] _array;
    public int Length { get; }
    public JsonValue Item { get; }
    public JsonArray(JsonValue[] array, int line, int column);
    public int get_Length();
    public JsonValue get_Item(int index);
}
internal class Xunit.JsonBoolean : JsonValue {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; private set; }
    public JsonBoolean(JsonToken token);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(bool value);
    public static bool op_Implicit(JsonBoolean jsonBoolean);
}
internal class Xunit.JsonBuffer : object {
    public static string ValueNull;
    public static string ValueTrue;
    public static string ValueFalse;
    private StringBuilder _buffer;
    private StringBuilder _codePointBuffer;
    private TextReader _reader;
    private JsonToken _token;
    private int _line;
    private int _column;
    public JsonBuffer(TextReader reader);
    public JsonToken Read();
    private int ReadNextChar();
    private string ReadNumber(int firstRead);
    private void ReadLiteral(string literal);
    private string ReadString();
    private static bool IsWhitespace(int value);
}
internal static class Xunit.JsonDeserializer : object {
    public static JsonValue Deserialize(TextReader reader);
    private static JsonValue DeserializeInternal(JsonToken next, JsonBuffer buffer);
    private static JsonArray DeserializeArray(JsonToken head, JsonBuffer buffer);
    private static JsonObject DeserializeObject(JsonToken head, JsonBuffer buffer);
}
internal class Xunit.JsonDeserializerException : Exception {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonDeserializerException(string message, Exception innerException, int line, int column);
    public JsonDeserializerException(string message, int line, int column);
    public JsonDeserializerException(string message, JsonToken nextToken);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal static class Xunit.JsonDeserializerResource : object {
    internal static string JSON_OpenString { get; }
    internal static string JSON_InvalidEnd { get; }
    internal static string Format_IllegalCharacter(int value);
    internal static string Format_IllegalTrailingCharacterAfterLiteral(int value, string literal);
    internal static string Format_UnrecognizedLiteral(string literal);
    internal static string Format_DuplicateObjectMemberName(string memberName);
    internal static string Format_InvalidFloatNumberFormat(string raw);
    internal static string Format_FloatNumberOverflow(string raw);
    internal static string Format_InvalidSyntax(string syntaxName, string issue);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, char unexpected);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, string unexpected);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, string expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation1, char expectation2);
    internal static string Format_InvalidTokenExpectation(string tokenValue, string expectation);
    internal static string Format_InvalidUnicode(string unicode);
    internal static string Format_UnfinishedJSON(string nextTokenValue);
    internal static string get_JSON_OpenString();
    internal static string get_JSON_InvalidEnd();
}
internal class Xunit.JsonNull : JsonValue {
    public JsonNull(int line, int column);
}
internal class Xunit.JsonNumber : JsonValue {
    private string _raw;
    private double _double;
    public double Double { get; }
    public string Raw { get; }
    public JsonNumber(JsonToken token);
    public double get_Double();
    public string get_Raw();
}
internal class Xunit.JsonObject : JsonValue {
    private IDictionary`2<string, JsonValue> _data;
    public ICollection`1<string> Keys { get; }
    public JsonObject(IDictionary`2<string, JsonValue> data, int line, int column);
    public ICollection`1<string> get_Keys();
    public JsonValue Value(string key);
    public JsonObject ValueAsJsonObject(string key);
    public JsonString ValueAsString(string key);
    public int ValueAsInt(string key);
    public bool ValueAsBoolean(string key, bool defaultValue);
    public Nullable`1<bool> ValueAsNullableBoolean(string key);
    public String[] ValueAsStringArray(string key);
}
internal class Xunit.JsonString : JsonValue {
    private string _value;
    public string Value { get; }
    public JsonString(string value, int line, int column);
    public string get_Value();
    public virtual string ToString();
    public static string op_Implicit(JsonString instance);
}
internal class Xunit.JsonToken : ValueType {
    public JsonTokenType Type;
    public string Value;
    public int Line;
    public int Column;
}
internal enum Xunit.JsonTokenType : Enum {
    public int value__;
    public static JsonTokenType LeftCurlyBracket;
    public static JsonTokenType LeftSquareBracket;
    public static JsonTokenType RightCurlyBracket;
    public static JsonTokenType RightSquareBracket;
    public static JsonTokenType Colon;
    public static JsonTokenType Comma;
    public static JsonTokenType Null;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Number;
    public static JsonTokenType String;
    public static JsonTokenType EOF;
}
internal class Xunit.JsonValue : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonValue(int line, int column);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
