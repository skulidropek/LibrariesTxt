public enum StackExchange.Redis.Aggregate : Enum {
    public int value__;
    public static Aggregate Sum;
    public static Aggregate Min;
    public static Aggregate Max;
}
public enum StackExchange.Redis.Bitwise : Enum {
    public int value__;
    public static Bitwise And;
    public static Bitwise Or;
    public static Bitwise Xor;
    public static Bitwise Not;
}
[FlagsAttribute]
public enum StackExchange.Redis.ClientFlags : Enum {
    public long value__;
    public static ClientFlags None;
    public static ClientFlags SlaveMonitor;
    public static ClientFlags Slave;
    public static ClientFlags Master;
    public static ClientFlags Transaction;
    public static ClientFlags Blocked;
    public static ClientFlags TransactionDoomed;
    public static ClientFlags Closing;
    public static ClientFlags Unblocked;
    public static ClientFlags CloseASAP;
}
public class StackExchange.Redis.ClientInfo : object {
    internal static ResultProcessor`1<ClientInfo[]> Processor;
    [CompilerGeneratedAttribute]
private EndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AgeSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlagsRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PatternSubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransactionCommandLength>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public EndPoint Address { get; private set; }
    public int AgeSeconds { get; private set; }
    public int Database { get; private set; }
    public ClientFlags Flags { get; private set; }
    public string FlagsRaw { get; private set; }
    public string Host { get; }
    public int IdleSeconds { get; private set; }
    public string LastCommand { get; private set; }
    public string Name { get; private set; }
    public int PatternSubscriptionCount { get; private set; }
    public int Port { get; }
    public string Raw { get; private set; }
    public int SubscriptionCount { get; private set; }
    public int TransactionCommandLength { get; private set; }
    public long Id { get; private set; }
    public ClientType ClientType { get; }
    private static ClientInfo();
    [CompilerGeneratedAttribute]
public EndPoint get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(EndPoint value);
    [CompilerGeneratedAttribute]
public int get_AgeSeconds();
    [CompilerGeneratedAttribute]
private void set_AgeSeconds(int value);
    [CompilerGeneratedAttribute]
public int get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(int value);
    [CompilerGeneratedAttribute]
public ClientFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ClientFlags value);
    [CompilerGeneratedAttribute]
public string get_FlagsRaw();
    [CompilerGeneratedAttribute]
private void set_FlagsRaw(string value);
    public string get_Host();
    [CompilerGeneratedAttribute]
public int get_IdleSeconds();
    [CompilerGeneratedAttribute]
private void set_IdleSeconds(int value);
    [CompilerGeneratedAttribute]
public string get_LastCommand();
    [CompilerGeneratedAttribute]
private void set_LastCommand(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_PatternSubscriptionCount();
    [CompilerGeneratedAttribute]
private void set_PatternSubscriptionCount(int value);
    public int get_Port();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [CompilerGeneratedAttribute]
private void set_Raw(string value);
    [CompilerGeneratedAttribute]
public int get_SubscriptionCount();
    [CompilerGeneratedAttribute]
private void set_SubscriptionCount(int value);
    [CompilerGeneratedAttribute]
public int get_TransactionCommandLength();
    [CompilerGeneratedAttribute]
private void set_TransactionCommandLength(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    public virtual string ToString();
    public ClientType get_ClientType();
    internal static ClientInfo[] Parse(string input);
    private static void AddFlag(ClientFlags& value, string raw, ClientFlags toAdd, char token);
}
public enum StackExchange.Redis.ClientType : Enum {
    public int value__;
    public static ClientType Normal;
    public static ClientType Slave;
    public static ClientType PubSub;
}
[DefaultMemberAttribute("Item")]
public class StackExchange.Redis.ClusterConfiguration : object {
    private Dictionary`2<EndPoint, ClusterNode> nodeLookup;
    private ServerSelectionStrategy serverSelectionStrategy;
    [CompilerGeneratedAttribute]
private EndPoint <Origin>k__BackingField;
    public ICollection`1<ClusterNode> Nodes { get; }
    public EndPoint Origin { get; }
    public ClusterNode Item { get; }
    internal ClusterNode Item { get; }
    internal ClusterConfiguration(ServerSelectionStrategy serverSelectionStrategy, string nodes, EndPoint origin);
    public ICollection`1<ClusterNode> get_Nodes();
    [CompilerGeneratedAttribute]
public EndPoint get_Origin();
    public ClusterNode get_Item(EndPoint endpoint);
    internal ClusterNode get_Item(string nodeId);
    public ClusterNode GetBySlot(int slot);
    public ClusterNode GetBySlot(RedisKey key);
}
public class StackExchange.Redis.ClusterNode : object {
    private static ClusterNode Dummy;
    private static IList`1<ClusterNode> NoNodes;
    private static IList`1<SlotRange> NoSlots;
    private ClusterConfiguration configuration;
    private IList`1<ClusterNode> children;
    private ClusterNode parent;
    private string toString;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMyself>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSlave>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNoAddr>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SlotRange> <Slots>k__BackingField;
    public IList`1<ClusterNode> Children { get; }
    public EndPoint EndPoint { get; }
    public bool IsMyself { get; }
    public bool IsSlave { get; }
    public bool IsNoAddr { get; }
    public bool IsConnected { get; }
    public string NodeId { get; }
    public ClusterNode Parent { get; }
    public string ParentNodeId { get; }
    public string Raw { get; }
    public IList`1<SlotRange> Slots { get; }
    internal ClusterNode(ClusterConfiguration configuration, string raw, EndPoint origin);
    private static ClusterNode();
    public IList`1<ClusterNode> get_Children();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public bool get_IsMyself();
    [CompilerGeneratedAttribute]
public bool get_IsSlave();
    [CompilerGeneratedAttribute]
public bool get_IsNoAddr();
    [CompilerGeneratedAttribute]
public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public string get_NodeId();
    public ClusterNode get_Parent();
    [CompilerGeneratedAttribute]
public string get_ParentNodeId();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [CompilerGeneratedAttribute]
public IList`1<SlotRange> get_Slots();
    public sealed virtual int CompareTo(ClusterNode other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClusterNode node);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool ServesSlot(int hashSlot);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
[FlagsAttribute]
public enum StackExchange.Redis.CommandFlags : Enum {
    public int value__;
    public static CommandFlags None;
    public static CommandFlags HighPriority;
    public static CommandFlags FireAndForget;
    public static CommandFlags PreferMaster;
    public static CommandFlags DemandMaster;
    public static CommandFlags PreferSlave;
    public static CommandFlags DemandSlave;
    public static CommandFlags NoRedirect;
    public static CommandFlags NoScriptCache;
}
public class StackExchange.Redis.CommandMap : object {
    private Byte[][] map;
    [CompilerGeneratedAttribute]
private static CommandMap <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <Twemproxy>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <SSDB>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <Sentinel>k__BackingField;
    private static Hashtable _unknownCommands;
    public static CommandMap Default { get; }
    public static CommandMap Twemproxy { get; }
    public static CommandMap SSDB { get; }
    public static CommandMap Sentinel { get; }
    internal CommandMap(Byte[][] map);
    private static CommandMap();
    [CompilerGeneratedAttribute]
public static CommandMap get_Default();
    [CompilerGeneratedAttribute]
public static CommandMap get_Twemproxy();
    [CompilerGeneratedAttribute]
public static CommandMap get_SSDB();
    [CompilerGeneratedAttribute]
public static CommandMap get_Sentinel();
    public static CommandMap Create(Dictionary`2<string, string> overrides);
    public static CommandMap Create(HashSet`1<string> commands, bool available);
    public virtual string ToString();
    internal void AppendDeltas(StringBuilder sb);
    internal void AssertAvailable(RedisCommand command);
    internal Byte[] GetBytes(RedisCommand command);
    internal Byte[] GetBytes(string command);
    internal bool IsAvailable(RedisCommand command);
    private static CommandMap CreateImpl(Dictionary`2<string, string> caseInsensitiveOverrides, HashSet`1<RedisCommand> exclusions);
}
public enum StackExchange.Redis.CommandStatus : Enum {
    public int value__;
    public static CommandStatus Unknown;
    public static CommandStatus WaitingToBeSent;
    public static CommandStatus Sent;
}
public class StackExchange.Redis.CommandTrace : object {
    internal static ResultProcessor`1<CommandTrace[]> Processor;
    [CompilerGeneratedAttribute]
private RedisValue[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniqueId>k__BackingField;
    public RedisValue[] Arguments { get; private set; }
    public TimeSpan Duration { get; private set; }
    public DateTime Time { get; private set; }
    public long UniqueId { get; private set; }
    internal CommandTrace(long uniqueId, long time, long duration, RedisValue[] arguments);
    private static CommandTrace();
    [CompilerGeneratedAttribute]
public RedisValue[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(RedisValue[] value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
private void set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public long get_UniqueId();
    [CompilerGeneratedAttribute]
private void set_UniqueId(long value);
    public string GetHelpUrl();
}
internal static class StackExchange.Redis.CompletedTask`1 : object {
    private static Task`1<T> default;
    private static CompletedTask`1();
    public static Task`1<T> Default(object asyncState);
    public static Task`1<T> FromResult(T value, object asyncState);
}
internal class StackExchange.Redis.CompletionManager : object {
    private static WaitCallback processAsyncCompletionQueue;
    private static WaitCallback anyOrderCompletionHandler;
    private Queue`1<ICompletable> asyncCompletionQueue;
    private ConnectionMultiplexer multiplexer;
    private string name;
    private int activeAsyncWorkerThread;
    private long completedSync;
    private long completedAsync;
    private long failedAsync;
    public CompletionManager(ConnectionMultiplexer multiplexer, string name);
    private static CompletionManager();
    public void CompleteSyncOrAsync(ICompletable operation);
    internal void GetCounters(ConnectionCounters counters);
    internal int GetOutstandingCount();
    internal void GetStormLog(StringBuilder sb);
    private static void AnyOrderCompletionHandler(object state);
    private static void ProcessAsyncCompletionQueue(object state);
    private void ProcessAsyncCompletionQueueImpl();
    private bool SpinWait();
}
public enum StackExchange.Redis.CompletionType : Enum {
    public int value__;
    public static CompletionType Any;
    public static CompletionType Sync;
    public static CompletionType Async;
}
internal class StackExchange.Redis.ConcurrentProfileStorageCollection : object {
    internal static int AllocationCount;
    private static int PoolSize;
    private static ConcurrentProfileStorageCollection[] Pool;
    private ProfileStorage modreq(System.Runtime.CompilerServices.IsVolatile) Head;
    private static ConcurrentProfileStorageCollection();
    internal static int CountInPool();
    public void Add(ProfileStorage command);
    public ProfiledCommandEnumerable EnumerateAndReturnForReuse();
    public void ReturnForReuse();
    public static ConcurrentProfileStorageCollection GetOrCreate();
}
public abstract class StackExchange.Redis.Condition : object {
    internal abstract virtual Condition MapKeys(Func`2<RedisKey, RedisKey> map);
    public static Condition HashEqual(RedisKey key, RedisValue hashField, RedisValue value);
    public static Condition HashExists(RedisKey key, RedisValue hashField);
    public static Condition HashNotEqual(RedisKey key, RedisValue hashField, RedisValue value);
    public static Condition HashNotExists(RedisKey key, RedisValue hashField);
    public static Condition KeyExists(RedisKey key);
    public static Condition KeyNotExists(RedisKey key);
    public static Condition ListIndexEqual(RedisKey key, long index, RedisValue value);
    public static Condition ListIndexExists(RedisKey key, long index);
    public static Condition ListIndexNotEqual(RedisKey key, long index, RedisValue value);
    public static Condition ListIndexNotExists(RedisKey key, long index);
    public static Condition StringEqual(RedisKey key, RedisValue value);
    public static Condition StringNotEqual(RedisKey key, RedisValue value);
    public static Condition HashLengthEqual(RedisKey key, long length);
    public static Condition HashLengthLessThan(RedisKey key, long length);
    public static Condition HashLengthGreaterThan(RedisKey key, long length);
    public static Condition StringLengthEqual(RedisKey key, long length);
    public static Condition StringLengthLessThan(RedisKey key, long length);
    public static Condition StringLengthGreaterThan(RedisKey key, long length);
    public static Condition ListLengthEqual(RedisKey key, long length);
    public static Condition ListLengthLessThan(RedisKey key, long length);
    public static Condition ListLengthGreaterThan(RedisKey key, long length);
    public static Condition SetLengthEqual(RedisKey key, long length);
    public static Condition SetLengthLessThan(RedisKey key, long length);
    public static Condition SetLengthGreaterThan(RedisKey key, long length);
    public static Condition SortedSetLengthEqual(RedisKey key, long length);
    public static Condition SortedSetLengthLessThan(RedisKey key, long length);
    public static Condition SortedSetLengthGreaterThan(RedisKey key, long length);
    internal abstract virtual void CheckCommands(CommandMap commandMap);
    internal abstract virtual IEnumerable`1<Message> CreateMessages(int db, ResultBox resultBox);
    internal abstract virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    internal abstract virtual bool TryValidate(RawResult result, Boolean& value);
}
public class StackExchange.Redis.ConditionResult : object {
    internal Condition Condition;
    private ResultBox`1<bool> resultBox;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) wasSatisfied;
    public bool WasSatisfied { get; }
    internal ConditionResult(Condition condition);
    public bool get_WasSatisfied();
    internal IEnumerable`1<Message> CreateMessages(int db);
    internal ResultBox`1<bool> GetBox();
    internal bool UnwrapBox();
}
public class StackExchange.Redis.ConfigurationOptions : object {
    internal static string DefaultTieBreaker;
    internal static string DefaultConfigurationChannel;
    private EndPointCollection endpoints;
    private Nullable`1<bool> allowAdmin;
    private Nullable`1<bool> abortOnConnectFail;
    private Nullable`1<bool> highPrioritySocketThreads;
    private Nullable`1<bool> resolveDns;
    private Nullable`1<bool> ssl;
    private string clientName;
    private string serviceName;
    private string password;
    private string tieBreaker;
    private string sslHost;
    private string configChannel;
    private CommandMap commandMap;
    private Version defaultVersion;
    private Nullable`1<int> keepAlive;
    private Nullable`1<int> syncTimeout;
    private Nullable`1<int> connectTimeout;
    private Nullable`1<int> responseTimeout;
    private Nullable`1<int> writeBuffer;
    private Nullable`1<int> connectRetry;
    private Nullable`1<int> configCheckSeconds;
    private Nullable`1<int> defaultDatabase;
    private Nullable`1<Proxy> proxy;
    private IReconnectRetryPolicy reconnectRetryPolicy;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback CertificateSelection;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback CertificateValidation;
    [CompilerGeneratedAttribute]
private Nullable`1<SslProtocols> <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisChannel <ChannelPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketManager <SocketManager>k__BackingField;
    public bool AbortOnConnectFail { get; public set; }
    public bool AllowAdmin { get; public set; }
    [ObsoleteAttribute("Please use .Ssl instead of .UseSsl")]
[EditorBrowsableAttribute("1")]
public bool UseSsl { get; public set; }
    public bool Ssl { get; public set; }
    public Nullable`1<SslProtocols> SslProtocols { get; public set; }
    public RedisChannel ChannelPrefix { get; public set; }
    public string ClientName { get; public set; }
    public int ConnectRetry { get; public set; }
    public CommandMap CommandMap { get; public set; }
    public string ConfigurationChannel { get; public set; }
    public int ConnectTimeout { get; public set; }
    public IReconnectRetryPolicy ReconnectRetryPolicy { get; public set; }
    public Version DefaultVersion { get; public set; }
    public EndPointCollection EndPoints { get; }
    public bool HighPrioritySocketThreads { get; public set; }
    public int KeepAlive { get; public set; }
    public string Password { get; public set; }
    public Proxy Proxy { get; public set; }
    public bool ResolveDns { get; public set; }
    public string ServiceName { get; public set; }
    public SocketManager SocketManager { get; public set; }
    public string SslHost { get; public set; }
    public int SyncTimeout { get; public set; }
    public int ResponseTimeout { get; public set; }
    public string TieBreaker { get; public set; }
    public int WriteBuffer { get; public set; }
    public Nullable`1<int> DefaultDatabase { get; public set; }
    internal LocalCertificateSelectionCallback CertificateSelectionCallback { get; private set; }
    internal RemoteCertificateValidationCallback CertificateValidationCallback { get; private set; }
    public int ConfigCheckSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public void add_CertificateSelection(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public void remove_CertificateSelection(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public void add_CertificateValidation(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public void remove_CertificateValidation(RemoteCertificateValidationCallback value);
    public bool get_AbortOnConnectFail();
    public void set_AbortOnConnectFail(bool value);
    public bool get_AllowAdmin();
    public void set_AllowAdmin(bool value);
    public bool get_UseSsl();
    public void set_UseSsl(bool value);
    public bool get_Ssl();
    public void set_Ssl(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<SslProtocols> get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(Nullable`1<SslProtocols> value);
    [CompilerGeneratedAttribute]
public RedisChannel get_ChannelPrefix();
    [CompilerGeneratedAttribute]
public void set_ChannelPrefix(RedisChannel value);
    public string get_ClientName();
    public void set_ClientName(string value);
    public int get_ConnectRetry();
    public void set_ConnectRetry(int value);
    public CommandMap get_CommandMap();
    public void set_CommandMap(CommandMap value);
    public string get_ConfigurationChannel();
    public void set_ConfigurationChannel(string value);
    public int get_ConnectTimeout();
    public void set_ConnectTimeout(int value);
    public IReconnectRetryPolicy get_ReconnectRetryPolicy();
    public void set_ReconnectRetryPolicy(IReconnectRetryPolicy value);
    public Version get_DefaultVersion();
    public void set_DefaultVersion(Version value);
    public EndPointCollection get_EndPoints();
    public bool get_HighPrioritySocketThreads();
    public void set_HighPrioritySocketThreads(bool value);
    public int get_KeepAlive();
    public void set_KeepAlive(int value);
    public string get_Password();
    public void set_Password(string value);
    public Proxy get_Proxy();
    public void set_Proxy(Proxy value);
    public bool get_ResolveDns();
    public void set_ResolveDns(bool value);
    public string get_ServiceName();
    public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public SocketManager get_SocketManager();
    [CompilerGeneratedAttribute]
public void set_SocketManager(SocketManager value);
    public string get_SslHost();
    public void set_SslHost(string value);
    public int get_SyncTimeout();
    public void set_SyncTimeout(int value);
    public int get_ResponseTimeout();
    public void set_ResponseTimeout(int value);
    public string get_TieBreaker();
    public void set_TieBreaker(string value);
    public int get_WriteBuffer();
    public void set_WriteBuffer(int value);
    public Nullable`1<int> get_DefaultDatabase();
    public void set_DefaultDatabase(Nullable`1<int> value);
    internal LocalCertificateSelectionCallback get_CertificateSelectionCallback();
    private void set_CertificateSelectionCallback(LocalCertificateSelectionCallback value);
    internal RemoteCertificateValidationCallback get_CertificateValidationCallback();
    private void set_CertificateValidationCallback(RemoteCertificateValidationCallback value);
    public int get_ConfigCheckSeconds();
    public void set_ConfigCheckSeconds(int value);
    public static ConfigurationOptions Parse(string configuration);
    public static ConfigurationOptions Parse(string configuration, bool ignoreUnknown);
    public ConfigurationOptions Clone();
    public void SetDefaultPorts();
    public virtual string ToString();
    public string ToString(bool includePassword);
    internal bool HasDnsEndPoints();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConfigurationOptions/<ResolveEndPointsAsync>d__132")]
internal Task ResolveEndPointsAsync(ConnectionMultiplexer multiplexer, TextWriter log);
    private static void Append(StringBuilder sb, object value);
    private static void Append(StringBuilder sb, string prefix, object value);
    private void Clear();
    private void DoParse(string configuration, bool ignoreUnknown);
    private bool GetDefaultAbortOnConnectFailSetting();
    private bool IsAzureEndpoint();
    private string InferSslHostFromEndpoints();
}
public class StackExchange.Redis.ConnectionCounters : object {
    [CompilerGeneratedAttribute]
private long <CompletedAsynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompletedSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FailedAsynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NonPreferredEndpointCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PendingUnsentItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponsesAwaitingAsyncCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SentItemsAwaitingResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SocketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriterCount>k__BackingField;
    public long CompletedAsynchronously { get; internal set; }
    public long CompletedSynchronously { get; internal set; }
    public ConnectionType ConnectionType { get; }
    public long FailedAsynchronously { get; internal set; }
    public bool IsEmpty { get; }
    public long NonPreferredEndpointCount { get; internal set; }
    public long OperationCount { get; internal set; }
    public int PendingUnsentItems { get; internal set; }
    public int ResponsesAwaitingAsyncCompletion { get; internal set; }
    public int SentItemsAwaitingResponse { get; internal set; }
    public long SocketCount { get; internal set; }
    public long Subscriptions { get; internal set; }
    public int TotalOutstanding { get; }
    public int WriterCount { get; internal set; }
    internal ConnectionCounters(ConnectionType connectionType);
    [CompilerGeneratedAttribute]
public long get_CompletedAsynchronously();
    [CompilerGeneratedAttribute]
internal void set_CompletedAsynchronously(long value);
    [CompilerGeneratedAttribute]
public long get_CompletedSynchronously();
    [CompilerGeneratedAttribute]
internal void set_CompletedSynchronously(long value);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [CompilerGeneratedAttribute]
public long get_FailedAsynchronously();
    [CompilerGeneratedAttribute]
internal void set_FailedAsynchronously(long value);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public long get_NonPreferredEndpointCount();
    [CompilerGeneratedAttribute]
internal void set_NonPreferredEndpointCount(long value);
    [CompilerGeneratedAttribute]
public long get_OperationCount();
    [CompilerGeneratedAttribute]
internal void set_OperationCount(long value);
    [CompilerGeneratedAttribute]
public int get_PendingUnsentItems();
    [CompilerGeneratedAttribute]
internal void set_PendingUnsentItems(int value);
    [CompilerGeneratedAttribute]
public int get_ResponsesAwaitingAsyncCompletion();
    [CompilerGeneratedAttribute]
internal void set_ResponsesAwaitingAsyncCompletion(int value);
    [CompilerGeneratedAttribute]
public int get_SentItemsAwaitingResponse();
    [CompilerGeneratedAttribute]
internal void set_SentItemsAwaitingResponse(int value);
    [CompilerGeneratedAttribute]
public long get_SocketCount();
    [CompilerGeneratedAttribute]
internal void set_SocketCount(long value);
    [CompilerGeneratedAttribute]
public long get_Subscriptions();
    [CompilerGeneratedAttribute]
internal void set_Subscriptions(long value);
    public int get_TotalOutstanding();
    [CompilerGeneratedAttribute]
public int get_WriterCount();
    [CompilerGeneratedAttribute]
internal void set_WriterCount(int value);
    public virtual string ToString();
    internal void Add(ConnectionCounters other);
    internal bool Any();
    internal void Append(StringBuilder sb);
}
public class StackExchange.Redis.ConnectionFailedEventArgs : EventArgs {
    private EventHandler`1<ConnectionFailedEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionFailureType <FailureType>k__BackingField;
    public ConnectionType ConnectionType { get; }
    public EndPoint EndPoint { get; }
    public Exception Exception { get; }
    public ConnectionFailureType FailureType { get; }
    internal ConnectionFailedEventArgs(EventHandler`1<ConnectionFailedEventArgs> handler, object sender, EndPoint endPoint, ConnectionType connectionType, ConnectionFailureType failureType, Exception exception);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public ConnectionFailureType get_FailureType();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
public enum StackExchange.Redis.ConnectionFailureType : Enum {
    public int value__;
    public static ConnectionFailureType None;
    public static ConnectionFailureType UnableToResolvePhysicalConnection;
    public static ConnectionFailureType SocketFailure;
    public static ConnectionFailureType AuthenticationFailure;
    public static ConnectionFailureType ProtocolFailure;
    public static ConnectionFailureType InternalFailure;
    public static ConnectionFailureType SocketClosed;
    public static ConnectionFailureType ConnectionDisposed;
    public static ConnectionFailureType Loading;
    public static ConnectionFailureType UnableToConnect;
}
public class StackExchange.Redis.ConnectionMultiplexer : object {
    private static string timeoutHelpLink;
    private static TaskFactory _factory;
    private static string defaultClientName;
    [CompilerGeneratedAttribute]
private EventHandler`1<RedisErrorEventArgs> ErrorMessage;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionFailedEventArgs> ConnectionFailed;
    [CompilerGeneratedAttribute]
private EventHandler`1<InternalErrorEventArgs> InternalError;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionFailedEventArgs> ConnectionRestored;
    [CompilerGeneratedAttribute]
private EventHandler`1<EndPointEventArgs> ConfigurationChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<EndPointEventArgs> ConfigurationChangedBroadcast;
    private int timeoutMilliseconds;
    private ConfigurationOptions configuration;
    [CompilerGeneratedAttribute]
private EventHandler`1<HashSlotMovedEventArgs> HashSlotMoved;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isDisposed;
    private string failureMessage;
    private Hashtable servers;
    private ServerEndPoint[] modreq(System.Runtime.CompilerServices.IsVolatile) serverSnapshot;
    private static ServerEndPoint[] NilServers;
    internal CommandMap CommandMap;
    internal static int MillisecondsPerHeartbeat;
    private static TimerCallback heartbeat;
    private int _activeHeartbeatErrors;
    private int lastHeartbeatTicks;
    private static int lastGlobalHeartbeatTicks;
    [CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    private static int MaxCachedDatabaseInstance;
    private IDatabase dbCacheZero;
    private IDatabase[] dbCacheLow;
    private CompletionManager unprocessableCompletionManager;
    private string activeConfigCause;
    private Timer pulse;
    private ServerSelectionStrategy serverSelectionStrategy;
    internal Byte[] ConfigurationChangedChannel;
    internal Byte[] UniqueId;
    [CompilerGeneratedAttribute]
private bool <PreserveAsyncOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDetailInExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePerformanceCountersInExceptions>k__BackingField;
    private int haveStormLog;
    private int stormLogThreshold;
    private string stormLogSnapshot;
    private long syncTimeouts;
    private long fireAndForgets;
    private IProfiler profiler;
    internal ProfileContextTracker profiledCommands;
    private SocketManager socketManager;
    private bool ownsSocketManager;
    private Dictionary`2<RedisChannel, Subscription> subscriptions;
    public static TaskFactory Factory { get; public set; }
    public string ClientName { get; }
    public string Configuration { get; }
    private object LogSyncLock { get; }
    public int TimeoutMilliseconds { get; }
    internal bool IsDisposed { get; }
    internal long LastHeartbeatSecondsAgo { get; }
    internal Exception LastException { get; internal set; }
    internal static long LastGlobalHeartbeatSecondsAgo { get; }
    internal CompletionManager UnprocessableCompletionManager { get; }
    public long OperationCount { get; }
    public bool PreserveAsyncOrder { get; public set; }
    public bool IsConnected { get; }
    internal ConfigurationOptions RawConfig { get; }
    internal ServerSelectionStrategy ServerSelectionStrategy { get; }
    public bool IncludeDetailInExceptions { get; public set; }
    public bool IncludePerformanceCountersInExceptions { get; public set; }
    public int StormLogThreshold { get; public set; }
    internal SocketManager SocketManager { get; }
    private ConnectionMultiplexer(ConfigurationOptions configuration);
    private static ConnectionMultiplexer();
    public static TaskFactory get_Factory();
    public static void set_Factory(TaskFactory value);
    public sealed virtual ServerCounters GetCounters();
    public sealed virtual string get_ClientName();
    private static string GetDefaultClientName();
    internal static string TryGetAzureRoleInstanceIdNoThrow();
    public sealed virtual string get_Configuration();
    internal void OnConnectionFailed(EndPoint endpoint, ConnectionType connectionType, ConnectionFailureType failureType, Exception exception, bool reconfigure);
    internal void OnInternalError(Exception exception, EndPoint endpoint, ConnectionType connectionType, string origin);
    internal void OnConnectionRestored(EndPoint endpoint, ConnectionType connectionType);
    private void OnEndpointChanged(EndPoint endpoint, EventHandler`1<EndPointEventArgs> handler);
    internal void OnConfigurationChanged(EndPoint endpoint);
    internal void OnConfigurationChangedBroadcast(EndPoint endpoint);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    internal void OnErrorMessage(EndPoint endpoint, string message);
    private static void Write(ZipArchive zip, string name, Task task, Action`2<T, StreamWriter> callback);
    public void ExportConfiguration(Stream destination, ExportOptions options);
    internal void MakeMaster(ServerEndPoint server, ReplicationChangeOptions options, TextWriter log);
    private object get_LogSyncLock();
    internal void LogLocked(TextWriter log, string line);
    internal void LogLocked(TextWriter log, string line, object arg);
    internal void LogLocked(TextWriter log, string line, object arg0, object arg1);
    internal void LogLocked(TextWriter log, string line, object arg0, object arg1, object arg2);
    internal void LogLocked(TextWriter log, string line, Object[] args);
    internal void CheckMessage(Message message);
    private static void WriteNormalizingLineEndings(string source, StreamWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    public sealed virtual int get_TimeoutMilliseconds();
    public sealed virtual EndPoint[] GetEndPoints(bool configuredOnly);
    internal bool TryResend(int hashSlot, Message message, EndPoint endpoint, bool isMoved);
    public sealed virtual void Wait(Task task);
    public sealed virtual T Wait(Task`1<T> task);
    public sealed virtual void WaitAll(Task[] tasks);
    private bool WaitAllIgnoreErrors(Task[] tasks);
    private static bool WaitAllIgnoreErrors(Task[] tasks, int timeout);
    private static bool AllComplete(Task[] tasks);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<WaitAllIgnoreErrorsAsync>d__62")]
private Task`1<bool> WaitAllIgnoreErrorsAsync(Task[] tasks, int timeoutMilliseconds, TextWriter log);
    [CompilerGeneratedAttribute]
public sealed virtual void add_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    internal void OnHashSlotMoved(int hashSlot, EndPoint old, EndPoint new);
    public sealed virtual int HashSlot(RedisKey key);
    internal ServerEndPoint AnyConnected(ServerType serverType, UInt32 startOffset, RedisCommand command, CommandFlags flags);
    internal bool get_IsDisposed();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ConnectAsync>d__72")]
public static Task`1<ConnectionMultiplexer> ConnectAsync(string configuration, TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ConnectAsync>d__73")]
public static Task`1<ConnectionMultiplexer> ConnectAsync(ConfigurationOptions configuration, TextWriter log);
    private static ConnectionMultiplexer CreateMultiplexer(object configuration);
    public static ConnectionMultiplexer Connect(string configuration, TextWriter log);
    public static ConnectionMultiplexer Connect(ConfigurationOptions configuration, TextWriter log);
    private static ConnectionMultiplexer ConnectImpl(Func`1<ConnectionMultiplexer> multiplexerFactory, TextWriter log);
    internal ServerEndPoint GetServerEndPoint(EndPoint endpoint);
    private void OnCreateReaderWriter(ConfigurationOptions configuration);
    private void OnHeartbeat();
    internal long get_LastHeartbeatSecondsAgo();
    [CompilerGeneratedAttribute]
internal Exception get_LastException();
    [CompilerGeneratedAttribute]
internal void set_LastException(Exception value);
    internal static long get_LastGlobalHeartbeatSecondsAgo();
    internal CompletionManager get_UnprocessableCompletionManager();
    public sealed virtual ISubscriber GetSubscriber(object asyncState);
    public sealed virtual IDatabase GetDatabase(int db, object asyncState);
    private IDatabase GetCachedDatabaseInstance(int db);
    public sealed virtual IServer GetServer(string host, int port, object asyncState);
    public sealed virtual IServer GetServer(string hostAndPort, object asyncState);
    public sealed virtual IServer GetServer(IPAddress host, int port);
    public sealed virtual IServer GetServer(EndPoint endpoint, object asyncState);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(bool condition, string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal static void TraceWithoutContext(string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal static void TraceWithoutContext(bool condition, string message, string category);
    public sealed virtual long get_OperationCount();
    internal bool ReconfigureIfNeeded(EndPoint blame, bool fromBroadcast, string cause, bool publishReconfigure, CommandFlags flags);
    public sealed virtual Task`1<bool> ConfigureAsync(TextWriter log);
    public sealed virtual bool Configure(TextWriter log);
    internal int SyncConnectTimeout(bool forConnect);
    public sealed virtual string GetStatus();
    public sealed virtual void GetStatus(TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ReconfigureAsync>d__128")]
internal Task`1<bool> ReconfigureAsync(bool first, bool reconfigureAll, TextWriter log, EndPoint blame, string cause, bool publishReconfigure, CommandFlags publishReconfigureFlags);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<GetEndpointsFromClusterNodes>d__129")]
private Task`1<EndPointCollection> GetEndpointsFromClusterNodes(ServerEndPoint server, TextWriter log);
    private void ResetAllNonConnected();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<NominatePreferredMaster>d__132")]
private Task`1<ServerEndPoint> NominatePreferredMaster(TextWriter log, ServerEndPoint[] servers, bool useTieBreakers, Task`1[] tieBreakers, List`1<ServerEndPoint> masters);
    private ServerEndPoint SelectServerByElection(ServerEndPoint[] servers, string endpoint, TextWriter log);
    private static string DeDotifyHost(string input);
    internal void UpdateClusterRange(ClusterConfiguration configuration);
    internal ServerEndPoint[] GetServerSnapshot();
    internal ServerEndPoint SelectServer(Message message);
    internal ServerEndPoint SelectServer(int db, RedisCommand command, CommandFlags flags, RedisKey key);
    private bool TryPushMessageToBridge(Message message, ResultProcessor`1<T> processor, ResultBox`1<T> resultBox, ServerEndPoint& server);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreserveAsyncOrder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreserveAsyncOrder(bool value);
    public sealed virtual bool get_IsConnected();
    internal ConfigurationOptions get_RawConfig();
    internal ServerSelectionStrategy get_ServerSelectionStrategy();
    public sealed virtual void Close(bool allowCommandsToComplete);
    private void OnCloseReaderWriter();
    private void DisposeAndClearServers();
    private Task[] QuitAllServers();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<CloseAsync>d__159")]
public sealed virtual Task CloseAsync(bool allowCommandsToComplete);
    public sealed virtual void Dispose();
    internal Task`1<T> ExecuteAsyncImpl(Message message, ResultProcessor`1<T> processor, object state, ServerEndPoint server);
    internal static void ThrowFailed(TaskCompletionSource`1<T> source, Exception unthrownException);
    internal T ExecuteSyncImpl(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeDetailInExceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeDetailInExceptions(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludePerformanceCountersInExceptions();
    [CompilerGeneratedAttribute]
public void set_IncludePerformanceCountersInExceptions(bool value);
    public sealed virtual int get_StormLogThreshold();
    public sealed virtual void set_StormLogThreshold(int value);
    public sealed virtual string GetStormLog();
    public sealed virtual void ResetStormLog();
    public sealed virtual long PublishReconfigure(CommandFlags flags);
    private long PublishReconfigureImpl(CommandFlags flags);
    public sealed virtual Task`1<long> PublishReconfigureAsync(CommandFlags flags);
    public sealed virtual void RegisterProfiler(IProfiler profiler);
    public sealed virtual void BeginProfiling(object forContext);
    public sealed virtual ProfiledCommandEnumerable FinishProfiling(object forContext, bool allowCleanupSweep);
    internal SocketManager get_SocketManager();
    internal void RequestWrite(PhysicalBridge bridge, bool forced);
    internal static bool TryCompleteHandler(EventHandler`1<T> handler, object sender, T args, bool isAsync);
    internal Task AddSubscription(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags, object asyncState);
    internal ServerEndPoint GetSubscribedServer(RedisChannel channel);
    internal void OnMessage(RedisChannel subscription, RedisChannel channel, RedisValue payload);
    internal Task RemoveAllSubscriptions(CommandFlags flags, object asyncState);
    internal Task RemoveSubscription(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags, object asyncState);
    internal void ResendSubscriptions(ServerEndPoint server);
    internal bool SubscriberConnected(RedisChannel channel);
    internal long ValidateSubscriptions();
}
public enum StackExchange.Redis.ConnectionType : Enum {
    public int value__;
    public static ConnectionType None;
    public static ConnectionType Interactive;
    public static ConnectionType Subscription;
}
public static class StackExchange.Redis.ConvertHelper : object {
    public static TOutput[] ConvertAll(TInput[] source, Func`2<TInput, TOutput> selector);
}
public class StackExchange.Redis.EndPointCollection : Collection`1<EndPoint> {
    public EndPointCollection(IList`1<EndPoint> endpoints);
    public static string ToString(EndPoint endpoint);
    public static EndPoint TryParse(string endpoint);
    public void Add(string hostAndPort);
    public void Add(string host, int port);
    public void Add(IPAddress host, int port);
    protected virtual void InsertItem(int index, EndPoint item);
    protected virtual void SetItem(int index, EndPoint item);
    internal void SetDefaultPorts(int defaultPort);
}
public class StackExchange.Redis.EndPointEventArgs : EventArgs {
    private EventHandler`1<EndPointEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    public EndPoint EndPoint { get; }
    internal EndPointEventArgs(EventHandler`1<EndPointEventArgs> handler, object sender, EndPoint endpoint);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
internal static class StackExchange.Redis.ExceptionFactory : object {
    private static string DataCommandKey;
    private static string DataServerKey;
    private static string DataServerEndpoint;
    private static string DataConnectionState;
    private static string DataLastFailure;
    private static string DataLastInnerException;
    private static string DataSentStatusKey;
    internal static Exception AdminModeNotEnabled(bool includeDetail, RedisCommand command, Message message, ServerEndPoint server);
    internal static Exception CommandDisabled(bool includeDetail, RedisCommand command, Message message, ServerEndPoint server);
    internal static Exception TooManyArgs(bool includeDetail, string command, Message message, ServerEndPoint server, int required);
    internal static Exception CommandDisabled(bool includeDetail, string command, Message message, ServerEndPoint server);
    internal static Exception ConnectionFailure(bool includeDetail, ConnectionFailureType failureType, string message, ServerEndPoint server);
    internal static Exception DatabaseNotRequired(bool includeDetail, RedisCommand command);
    internal static Exception DatabaseOutfRange(bool includeDetail, int targetDatabase, Message message, ServerEndPoint server);
    internal static Exception DatabaseRequired(bool includeDetail, RedisCommand command);
    internal static Exception MasterOnly(bool includeDetail, RedisCommand command, Message message, ServerEndPoint server);
    internal static Exception MultiSlot(bool includeDetail, Message message);
    internal static string GetInnerMostExceptionMessage(Exception e);
    internal static Exception NoConnectionAvailable(bool includeDetail, bool includePerformanceCounters, RedisCommand command, Message message, ServerEndPoint server, ServerEndPoint[] serverSnapshot);
    internal static Exception PopulateInnerExceptions(ServerEndPoint[] serverSnapshot);
    internal static Exception NotSupported(bool includeDetail, RedisCommand command);
    internal static Exception NoCursor(RedisCommand command);
    internal static Exception Timeout(bool includeDetail, string errorMessage, Message message, ServerEndPoint server);
    private static void AddDetail(Exception exception, Message message, ServerEndPoint server, string label);
    private static string GetLabel(bool includeDetail, RedisCommand command, Message message);
    private static string GetLabel(bool includeDetail, string command, Message message);
    internal static Exception UnableToConnect(bool abortOnConnect, string failureMessage);
    internal static Exception BeganProfilingWithDuplicateContext(object forContext);
    internal static Exception FinishedProfilingWithInvalidContext(object forContext);
}
[FlagsAttribute]
public enum StackExchange.Redis.Exclude : Enum {
    public int value__;
    public static Exclude None;
    public static Exclude Start;
    public static Exclude Stop;
    public static Exclude Both;
}
public class StackExchange.Redis.ExponentialRetry : object {
    private int deltaBackOffMilliseconds;
    private int maxDeltaBackOffMilliseconds;
    [ThreadStaticAttribute]
private static Random r;
    public ExponentialRetry(int deltaBackOffMilliseconds);
    public ExponentialRetry(int deltaBackOffMilliseconds, int maxDeltaBackOffMilliseconds);
    public sealed virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
[FlagsAttribute]
public enum StackExchange.Redis.ExportOptions : Enum {
    public int value__;
    public static ExportOptions None;
    public static ExportOptions Info;
    public static ExportOptions Config;
    public static ExportOptions Client;
    public static ExportOptions Cluster;
    public static ExportOptions All;
}
[ExtensionAttribute]
public static class StackExchange.Redis.ExtensionMethods : object {
    private static String[] nix;
    private static ExtensionMethods();
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(HashEntry[] hash);
    [ExtensionAttribute]
public static Dictionary`2<RedisValue, RedisValue> ToDictionary(HashEntry[] hash);
    [ExtensionAttribute]
public static Dictionary`2<string, double> ToStringDictionary(SortedSetEntry[] sortedSet);
    [ExtensionAttribute]
public static Dictionary`2<RedisValue, double> ToDictionary(SortedSetEntry[] sortedSet);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static Dictionary`2<RedisKey, RedisValue> ToDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static String[] ToStringArray(RedisValue[] values);
    [ExtensionAttribute]
internal static void AuthenticateAsClient(SslStream ssl, string host, Nullable`1<SslProtocols> allowedProtocols);
    private static void AuthenticateAsClientUsingDefaultProtocols(SslStream ssl, string host);
}
internal static class StackExchange.Redis.Format : object {
    public static int ParseInt32(string s);
    public static long ParseInt64(string s);
    public static string ToString(int value);
    public static bool TryParseBoolean(string s, Boolean& value);
    public static bool TryParseInt32(string s, Int32& value);
    internal static EndPoint ParseEndPoint(string host, int port);
    internal static EndPoint TryParseEndPoint(string host, string port);
    internal static string ToString(long value);
    internal static string ToString(double value);
    internal static string ToString(object value);
    internal static string ToString(EndPoint endpoint);
    internal static string ToStringHostOnly(EndPoint endpoint);
    internal static bool TryGetHostPort(EndPoint endpoint, String& host, Int32& port);
    internal static bool TryParseDouble(string s, Double& value);
    internal static EndPoint TryParseEndPoint(string endpoint);
}
public class StackExchange.Redis.GeoEntry : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private GeoPosition <Position>k__BackingField;
    public RedisValue Member { get; }
    public GeoPosition Position { get; }
    public double Longitude { get; }
    public double Latitude { get; }
    public GeoEntry(double longitude, double latitude, RedisValue member);
    [CompilerGeneratedAttribute]
public RedisValue get_Member();
    [CompilerGeneratedAttribute]
public GeoPosition get_Position();
    public double get_Longitude();
    public double get_Latitude();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GeoEntry value);
    public static bool op_Equality(GeoEntry x, GeoEntry y);
    public static bool op_Inequality(GeoEntry x, GeoEntry y);
}
public class StackExchange.Redis.GeoPosition : ValueType {
    [CompilerGeneratedAttribute]
private double <Latitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Longitude>k__BackingField;
    public double Latitude { get; }
    public double Longitude { get; }
    public GeoPosition(double longitude, double latitude);
    internal static string GetRedisUnit(GeoUnit unit);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public double get_Longitude();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GeoPosition value);
    public static bool op_Equality(GeoPosition x, GeoPosition y);
    public static bool op_Inequality(GeoPosition x, GeoPosition y);
}
[FlagsAttribute]
public enum StackExchange.Redis.GeoRadiusOptions : Enum {
    public int value__;
    public static GeoRadiusOptions None;
    public static GeoRadiusOptions WithCoordinates;
    public static GeoRadiusOptions WithDistance;
    public static GeoRadiusOptions WithGeoHash;
    public static GeoRadiusOptions Default;
}
public class StackExchange.Redis.GeoRadiusResult : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<GeoPosition> <Position>k__BackingField;
    public RedisValue Member { get; }
    public Nullable`1<double> Distance { get; }
    public Nullable`1<long> Hash { get; }
    public Nullable`1<GeoPosition> Position { get; }
    internal GeoRadiusResult(RedisValue member, Nullable`1<double> distance, Nullable`1<long> hash, Nullable`1<GeoPosition> position);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public RedisValue get_Member();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Distance();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Hash();
    [CompilerGeneratedAttribute]
public Nullable`1<GeoPosition> get_Position();
}
public enum StackExchange.Redis.GeoUnit : Enum {
    public int value__;
    public static GeoUnit Meters;
    public static GeoUnit Kilometers;
    public static GeoUnit Miles;
    public static GeoUnit Feet;
}
public class StackExchange.Redis.HashEntry : ValueType {
    internal RedisValue name;
    internal RedisValue value;
    public RedisValue Name { get; }
    public RedisValue Value { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Name", "False")]
public RedisValue Key { get; }
    public HashEntry(RedisValue name, RedisValue value);
    public RedisValue get_Name();
    public RedisValue get_Value();
    public RedisValue get_Key();
    public static KeyValuePair`2<RedisValue, RedisValue> op_Implicit(HashEntry value);
    public static HashEntry op_Implicit(KeyValuePair`2<RedisValue, RedisValue> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashEntry value);
    public static bool op_Equality(HashEntry x, HashEntry y);
    public static bool op_Inequality(HashEntry x, HashEntry y);
}
public class StackExchange.Redis.HashSlotMovedEventArgs : EventArgs {
    private object sender;
    private EventHandler`1<HashSlotMovedEventArgs> handler;
    [CompilerGeneratedAttribute]
private int <HashSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <OldEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <NewEndPoint>k__BackingField;
    public int HashSlot { get; }
    public EndPoint OldEndPoint { get; }
    public EndPoint NewEndPoint { get; }
    internal HashSlotMovedEventArgs(EventHandler`1<HashSlotMovedEventArgs> handler, object sender, int hashSlot, EndPoint old, EndPoint new);
    [CompilerGeneratedAttribute]
public int get_HashSlot();
    [CompilerGeneratedAttribute]
public EndPoint get_OldEndPoint();
    [CompilerGeneratedAttribute]
public EndPoint get_NewEndPoint();
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
}
public interface StackExchange.Redis.IBatch {
    public abstract virtual void Execute();
}
internal interface StackExchange.Redis.ICompletable {
    public abstract virtual void AppendStormLog(StringBuilder sb);
    public abstract virtual bool TryComplete(bool isAsync);
}
public interface StackExchange.Redis.IConnectionMultiplexer {
    public string ClientName { get; }
    public string Configuration { get; }
    public int TimeoutMilliseconds { get; }
    public long OperationCount { get; }
    public bool PreserveAsyncOrder { get; public set; }
    public bool IsConnected { get; }
    public bool IncludeDetailInExceptions { get; public set; }
    public int StormLogThreshold { get; public set; }
    public abstract virtual string get_ClientName();
    public abstract virtual string get_Configuration();
    public abstract virtual int get_TimeoutMilliseconds();
    public abstract virtual long get_OperationCount();
    public abstract virtual bool get_PreserveAsyncOrder();
    public abstract virtual void set_PreserveAsyncOrder(bool value);
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool get_IncludeDetailInExceptions();
    public abstract virtual void set_IncludeDetailInExceptions(bool value);
    public abstract virtual int get_StormLogThreshold();
    public abstract virtual void set_StormLogThreshold(int value);
    public abstract virtual void RegisterProfiler(IProfiler profiler);
    public abstract virtual void BeginProfiling(object forContext);
    public abstract virtual ProfiledCommandEnumerable FinishProfiling(object forContext, bool allowCleanupSweep);
    public abstract virtual ServerCounters GetCounters();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    public abstract virtual EndPoint[] GetEndPoints(bool configuredOnly);
    public abstract virtual void Wait(Task task);
    public abstract virtual T Wait(Task`1<T> task);
    public abstract virtual void WaitAll(Task[] tasks);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    public abstract virtual int HashSlot(RedisKey key);
    public abstract virtual ISubscriber GetSubscriber(object asyncState);
    public abstract virtual IDatabase GetDatabase(int db, object asyncState);
    public abstract virtual IServer GetServer(string host, int port, object asyncState);
    public abstract virtual IServer GetServer(string hostAndPort, object asyncState);
    public abstract virtual IServer GetServer(IPAddress host, int port);
    public abstract virtual IServer GetServer(EndPoint endpoint, object asyncState);
    public abstract virtual Task`1<bool> ConfigureAsync(TextWriter log);
    public abstract virtual bool Configure(TextWriter log);
    public abstract virtual string GetStatus();
    public abstract virtual void GetStatus(TextWriter log);
    public abstract virtual string ToString();
    public abstract virtual void Close(bool allowCommandsToComplete);
    public abstract virtual Task CloseAsync(bool allowCommandsToComplete);
    public abstract virtual void Dispose();
    public abstract virtual string GetStormLog();
    public abstract virtual void ResetStormLog();
    public abstract virtual long PublishReconfigure(CommandFlags flags);
    public abstract virtual Task`1<long> PublishReconfigureAsync(CommandFlags flags);
}
public interface StackExchange.Redis.IDatabase {
    public int Database { get; }
    public abstract virtual int get_Database();
    public abstract virtual IBatch CreateBatch(object asyncState);
    public abstract virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public abstract virtual ITransaction CreateTransaction(object asyncState);
    public abstract virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public abstract virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public abstract virtual bool GeoAdd(RedisKey key, GeoEntry value, CommandFlags flags);
    public abstract virtual long GeoAdd(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public abstract virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public abstract virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public abstract virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public abstract virtual long HashLength(RedisKey key, CommandFlags flags);
    public abstract virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public abstract virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public abstract virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public abstract virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public abstract virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public abstract virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public abstract virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    public abstract virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public abstract virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public abstract virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public abstract virtual RedisKey KeyRandom(CommandFlags flags);
    public abstract virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public abstract virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public abstract virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public abstract virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public abstract virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual long ListLength(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public abstract virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public abstract virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public abstract virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public abstract virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual RedisResult Execute(string command, Object[] args);
    public abstract virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    public abstract virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public abstract virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long SetLength(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public abstract virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public abstract virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public abstract virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public abstract virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public abstract virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public abstract virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public abstract virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public abstract virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public abstract virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public abstract virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public abstract virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public abstract virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public abstract virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public abstract virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public abstract virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    public abstract virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public abstract virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public abstract virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public abstract virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public abstract virtual long StringLength(RedisKey key, CommandFlags flags);
    public abstract virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public abstract virtual bool StringSetBit(RedisKey key, long offset, bool bit, CommandFlags flags);
    public abstract virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
}
public interface StackExchange.Redis.IDatabaseAsync {
    public abstract virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public abstract virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public abstract virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public abstract virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public abstract virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public abstract virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public abstract virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public abstract virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public abstract virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public abstract virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public abstract virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public abstract virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public abstract virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public abstract virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool bit, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
}
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("64")]
internal class StackExchange.Redis.IgnoreNamePrefixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IgnoreEntireMethod>k__BackingField;
    public bool IgnoreEntireMethod { get; private set; }
    public IgnoreNamePrefixAttribute(bool ignoreEntireMethod);
    [CompilerGeneratedAttribute]
public bool get_IgnoreEntireMethod();
    [CompilerGeneratedAttribute]
private void set_IgnoreEntireMethod(bool value);
}
internal interface StackExchange.Redis.IMultiMessage {
    public abstract virtual IEnumerable`1<Message> GetMessages(PhysicalConnection connection);
}
public class StackExchange.Redis.InternalErrorEventArgs : EventArgs {
    private EventHandler`1<InternalErrorEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    public ConnectionType ConnectionType { get; }
    public EndPoint EndPoint { get; }
    public Exception Exception { get; }
    public string Origin { get; }
    internal InternalErrorEventArgs(EventHandler`1<InternalErrorEventArgs> handler, object sender, EndPoint endpoint, ConnectionType connectionType, Exception exception, string origin);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Origin();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
public interface StackExchange.Redis.IProfiledCommand {
    public EndPoint EndPoint { get; }
    public int Db { get; }
    public string Command { get; }
    public CommandFlags Flags { get; }
    public DateTime CommandCreated { get; }
    public TimeSpan CreationToEnqueued { get; }
    public TimeSpan EnqueuedToSending { get; }
    public TimeSpan SentToResponse { get; }
    public TimeSpan ResponseToCompletion { get; }
    public TimeSpan ElapsedTime { get; }
    public IProfiledCommand RetransmissionOf { get; }
    public Nullable`1<RetransmissionReasonType> RetransmissionReason { get; }
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual int get_Db();
    public abstract virtual string get_Command();
    public abstract virtual CommandFlags get_Flags();
    public abstract virtual DateTime get_CommandCreated();
    public abstract virtual TimeSpan get_CreationToEnqueued();
    public abstract virtual TimeSpan get_EnqueuedToSending();
    public abstract virtual TimeSpan get_SentToResponse();
    public abstract virtual TimeSpan get_ResponseToCompletion();
    public abstract virtual TimeSpan get_ElapsedTime();
    public abstract virtual IProfiledCommand get_RetransmissionOf();
    public abstract virtual Nullable`1<RetransmissionReasonType> get_RetransmissionReason();
}
public interface StackExchange.Redis.IProfiler {
    public abstract virtual object GetContext();
}
public interface StackExchange.Redis.IReconnectRetryPolicy {
    public abstract virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
public interface StackExchange.Redis.IRedis {
    public abstract virtual TimeSpan Ping(CommandFlags flags);
}
public interface StackExchange.Redis.IRedisAsync {
    public ConnectionMultiplexer Multiplexer { get; }
    public abstract virtual ConnectionMultiplexer get_Multiplexer();
    public abstract virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public abstract virtual bool TryWait(Task task);
    public abstract virtual void Wait(Task task);
    public abstract virtual T Wait(Task`1<T> task);
    public abstract virtual void WaitAll(Task[] tasks);
}
public interface StackExchange.Redis.IScanningCursor {
    public long Cursor { get; }
    public int PageSize { get; }
    public int PageOffset { get; }
    public abstract virtual long get_Cursor();
    public abstract virtual int get_PageSize();
    public abstract virtual int get_PageOffset();
}
public interface StackExchange.Redis.IServer {
    public ClusterConfiguration ClusterConfiguration { get; }
    public EndPoint EndPoint { get; }
    public RedisFeatures Features { get; }
    public bool IsConnected { get; }
    public bool IsSlave { get; }
    public bool AllowSlaveWrites { get; public set; }
    public ServerType ServerType { get; }
    public Version Version { get; }
    public abstract virtual ClusterConfiguration get_ClusterConfiguration();
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual RedisFeatures get_Features();
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool get_IsSlave();
    public abstract virtual bool get_AllowSlaveWrites();
    public abstract virtual void set_AllowSlaveWrites(bool value);
    public abstract virtual ServerType get_ServerType();
    public abstract virtual Version get_Version();
    public abstract virtual void ClientKill(EndPoint endpoint, CommandFlags flags);
    public abstract virtual Task ClientKillAsync(EndPoint endpoint, CommandFlags flags);
    public abstract virtual long ClientKill(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public abstract virtual Task`1<long> ClientKillAsync(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public abstract virtual ClientInfo[] ClientList(CommandFlags flags);
    public abstract virtual Task`1<ClientInfo[]> ClientListAsync(CommandFlags flags);
    public abstract virtual ClusterConfiguration ClusterNodes(CommandFlags flags);
    public abstract virtual Task`1<ClusterConfiguration> ClusterNodesAsync(CommandFlags flags);
    public abstract virtual string ClusterNodesRaw(CommandFlags flags);
    public abstract virtual Task`1<string> ClusterNodesRawAsync(CommandFlags flags);
    public abstract virtual KeyValuePair`2[] ConfigGet(RedisValue pattern, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[]> ConfigGetAsync(RedisValue pattern, CommandFlags flags);
    public abstract virtual void ConfigResetStatistics(CommandFlags flags);
    public abstract virtual Task ConfigResetStatisticsAsync(CommandFlags flags);
    public abstract virtual void ConfigRewrite(CommandFlags flags);
    public abstract virtual Task ConfigRewriteAsync(CommandFlags flags);
    public abstract virtual void ConfigSet(RedisValue setting, RedisValue value, CommandFlags flags);
    public abstract virtual Task ConfigSetAsync(RedisValue setting, RedisValue value, CommandFlags flags);
    public abstract virtual long DatabaseSize(int database, CommandFlags flags);
    public abstract virtual Task`1<long> DatabaseSizeAsync(int database, CommandFlags flags);
    public abstract virtual RedisValue Echo(RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> EchoAsync(RedisValue message, CommandFlags flags);
    public abstract virtual void FlushAllDatabases(CommandFlags flags);
    public abstract virtual Task FlushAllDatabasesAsync(CommandFlags flags);
    public abstract virtual void FlushDatabase(int database, CommandFlags flags);
    public abstract virtual Task FlushDatabaseAsync(int database, CommandFlags flags);
    public abstract virtual ServerCounters GetCounters();
    public abstract virtual IGrouping`2[] Info(RedisValue section, CommandFlags flags);
    public abstract virtual Task`1<IGrouping`2[]> InfoAsync(RedisValue section, CommandFlags flags);
    public abstract virtual string InfoRaw(RedisValue section, CommandFlags flags);
    public abstract virtual Task`1<string> InfoRawAsync(RedisValue section, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisKey> Keys(int database, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisKey> Keys(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual DateTime LastSave(CommandFlags flags);
    public abstract virtual Task`1<DateTime> LastSaveAsync(CommandFlags flags);
    public abstract virtual void MakeMaster(ReplicationChangeOptions options, TextWriter log);
    public abstract virtual void Save(SaveType type, CommandFlags flags);
    public abstract virtual Task SaveAsync(SaveType type, CommandFlags flags);
    public abstract virtual bool ScriptExists(string script, CommandFlags flags);
    public abstract virtual bool ScriptExists(Byte[] sha1, CommandFlags flags);
    public abstract virtual Task`1<bool> ScriptExistsAsync(string script, CommandFlags flags);
    public abstract virtual Task`1<bool> ScriptExistsAsync(Byte[] sha1, CommandFlags flags);
    public abstract virtual void ScriptFlush(CommandFlags flags);
    public abstract virtual Task ScriptFlushAsync(CommandFlags flags);
    public abstract virtual Byte[] ScriptLoad(string script, CommandFlags flags);
    public abstract virtual LoadedLuaScript ScriptLoad(LuaScript script, CommandFlags flags);
    public abstract virtual Task`1<Byte[]> ScriptLoadAsync(string script, CommandFlags flags);
    public abstract virtual Task`1<LoadedLuaScript> ScriptLoadAsync(LuaScript script, CommandFlags flags);
    public abstract virtual void Shutdown(ShutdownMode shutdownMode, CommandFlags flags);
    public abstract virtual void SlaveOf(EndPoint master, CommandFlags flags);
    public abstract virtual Task SlaveOfAsync(EndPoint master, CommandFlags flags);
    public abstract virtual CommandTrace[] SlowlogGet(int count, CommandFlags flags);
    public abstract virtual Task`1<CommandTrace[]> SlowlogGetAsync(int count, CommandFlags flags);
    public abstract virtual void SlowlogReset(CommandFlags flags);
    public abstract virtual Task SlowlogResetAsync(CommandFlags flags);
    public abstract virtual RedisChannel[] SubscriptionChannels(RedisChannel pattern, CommandFlags flags);
    public abstract virtual Task`1<RedisChannel[]> SubscriptionChannelsAsync(RedisChannel pattern, CommandFlags flags);
    public abstract virtual long SubscriptionPatternCount(CommandFlags flags);
    public abstract virtual Task`1<long> SubscriptionPatternCountAsync(CommandFlags flags);
    public abstract virtual long SubscriptionSubscriberCount(RedisChannel channel, CommandFlags flags);
    public abstract virtual Task`1<long> SubscriptionSubscriberCountAsync(RedisChannel channel, CommandFlags flags);
    public abstract virtual DateTime Time(CommandFlags flags);
    public abstract virtual Task`1<DateTime> TimeAsync(CommandFlags flags);
    public abstract virtual EndPoint SentinelGetMasterAddressByName(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> SentinelGetMasterAddressByNameAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[] SentinelMaster(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[]> SentinelMasterAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[][] SentinelMasters(CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[][]> SentinelMastersAsync(CommandFlags flags);
    public abstract virtual KeyValuePair`2[][] SentinelSlaves(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[][]> SentinelSlavesAsync(string serviceName, CommandFlags flags);
    public abstract virtual void SentinelFailover(string serviceName, CommandFlags flags);
    public abstract virtual Task SentinelFailoverAsync(string serviceName, CommandFlags flags);
}
internal interface StackExchange.Redis.ISocketCallback {
    public bool IsDataAvailable { get; }
    public abstract virtual SocketMode Connected(Stream stream, TextWriter log);
    public abstract virtual void Error();
    public abstract virtual void OnHeartbeat();
    public abstract virtual void Read();
    public abstract virtual void StartReading();
    public abstract virtual void CheckForStaleConnection(ManagerState& state);
    public abstract virtual bool get_IsDataAvailable();
}
public interface StackExchange.Redis.ISubscriber {
    public abstract virtual EndPoint IdentifyEndpoint(RedisChannel channel, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisChannel channel, CommandFlags flags);
    public abstract virtual bool IsConnected(RedisChannel channel);
    public abstract virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual void Subscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual Task SubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual EndPoint SubscribedEndpoint(RedisChannel channel);
    public abstract virtual void Unsubscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual void UnsubscribeAll(CommandFlags flags);
    public abstract virtual Task UnsubscribeAllAsync(CommandFlags flags);
    public abstract virtual Task UnsubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
}
public interface StackExchange.Redis.ITransaction {
    public abstract virtual ConditionResult AddCondition(Condition condition);
    public abstract virtual bool Execute(CommandFlags flags);
    public abstract virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
}
internal class StackExchange.Redis.KeyspaceIsolation.BatchWrapper : WrapperBase`1<IBatch> {
    public BatchWrapper(IBatch inner, Byte[] prefix);
    public sealed virtual void Execute();
}
[ExtensionAttribute]
public static class StackExchange.Redis.KeyspaceIsolation.DatabaseExtensions : object {
    [ExtensionAttribute]
public static IDatabase WithKeyPrefix(IDatabase database, RedisKey keyPrefix);
}
internal class StackExchange.Redis.KeyspaceIsolation.DatabaseWrapper : WrapperBase`1<IDatabase> {
    public int Database { get; }
    public DatabaseWrapper(IDatabase inner, Byte[] prefix);
    public sealed virtual IBatch CreateBatch(object asyncState);
    public sealed virtual ITransaction CreateTransaction(object asyncState);
    public sealed virtual int get_Database();
    public sealed virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual long GeoAdd(RedisKey key, GeoEntry[] geoEntries, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, GeoEntry geoEntry, CommandFlags flags);
    public sealed virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue value0, RedisValue value1, GeoUnit unit, CommandFlags flags);
    public sealed virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public sealed virtual long HashLength(RedisKey key, CommandFlags flags);
    public sealed virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    public sealed virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public sealed virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public sealed virtual RedisKey KeyRandom(CommandFlags flags);
    public sealed virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public sealed virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public sealed virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public sealed virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual RedisResult Execute(string command, Object[] args);
    public sealed virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public sealed virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    public sealed virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public sealed virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual long StringLength(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual bool StringSetBit(RedisKey key, long offset, bool bit, CommandFlags flags);
    public sealed virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual TimeSpan Ping(CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
}
internal class StackExchange.Redis.KeyspaceIsolation.TransactionWrapper : WrapperBase`1<ITransaction> {
    public TransactionWrapper(ITransaction inner, Byte[] prefix);
    public sealed virtual ConditionResult AddCondition(Condition condition);
    public sealed virtual bool Execute(CommandFlags flags);
    public sealed virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
    public sealed virtual void Execute();
}
internal class StackExchange.Redis.KeyspaceIsolation.WrapperBase`1 : object {
    [CompilerGeneratedAttribute]
private TInner <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Prefix>k__BackingField;
    private Func`2<RedisKey, RedisKey> mapFunction;
    public ConnectionMultiplexer Multiplexer { get; }
    internal TInner Inner { get; }
    internal Byte[] Prefix { get; }
    internal WrapperBase`1(TInner inner, Byte[] keyPrefix);
    public sealed virtual ConnectionMultiplexer get_Multiplexer();
    [CompilerGeneratedAttribute]
internal TInner get_Inner();
    [CompilerGeneratedAttribute]
internal Byte[] get_Prefix();
    public sealed virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public sealed virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public sealed virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool bit, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public sealed virtual bool TryWait(Task task);
    public sealed virtual TResult Wait(Task`1<TResult> task);
    public sealed virtual void Wait(Task task);
    public sealed virtual void WaitAll(Task[] tasks);
    protected internal RedisKey ToInner(RedisKey outer);
    protected RedisKey ToInnerOrDefault(RedisKey outer);
    protected ICollection`1<object> ToInner(ICollection`1<object> args);
    protected RedisKey[] ToInner(RedisKey[] outer);
    protected KeyValuePair`2<RedisKey, RedisValue> ToInner(KeyValuePair`2<RedisKey, RedisValue> outer);
    protected KeyValuePair`2[] ToInner(KeyValuePair`2[] outer);
    protected RedisValue ToInner(RedisValue outer);
    protected RedisValue SortByToInner(RedisValue outer);
    protected RedisValue SortGetToInner(RedisValue outer);
    protected RedisValue[] SortGetToInner(RedisValue[] outer);
    protected RedisChannel ToInner(RedisChannel outer);
    protected Func`2<RedisKey, RedisKey> GetMapFunction();
}
public class StackExchange.Redis.LinearRetry : object {
    private int maxRetryElapsedTimeAllowedMilliseconds;
    public LinearRetry(int maxRetryElapsedTimeAllowedMilliseconds);
    public sealed virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
public class StackExchange.Redis.LoadedLuaScript : object {
    [CompilerGeneratedAttribute]
private Byte[] <Hash>k__BackingField;
    internal LuaScript Original;
    public string OriginalScript { get; }
    public string ExecutableScript { get; }
    public Byte[] Hash { get; private set; }
    internal LoadedLuaScript(LuaScript original, Byte[] hash);
    public string get_OriginalScript();
    public string get_ExecutableScript();
    [CompilerGeneratedAttribute]
public Byte[] get_Hash();
    [CompilerGeneratedAttribute]
private void set_Hash(Byte[] value);
    public RedisResult Evaluate(IDatabase db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public Task`1<RedisResult> EvaluateAsync(IDatabaseAsync db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
}
internal class StackExchange.Redis.LoggingMessage : Message {
    public TextWriter log;
    private Message tail;
    public string CommandAndKey { get; }
    public TextWriter Log { get; }
    private LoggingMessage(TextWriter log, Message tail);
    public static Message Create(TextWriter log, Message tail);
    public virtual string get_CommandAndKey();
    public virtual void AppendStormLog(StringBuilder sb);
    public virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    internal virtual void WriteImpl(PhysicalConnection physical);
    public TextWriter get_Log();
}
public class StackExchange.Redis.LuaScript : object {
    private static ConcurrentDictionary`2<string, WeakReference> Cache;
    [CompilerGeneratedAttribute]
private string <OriginalScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutableScript>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    private Hashtable ParameterMappers;
    public string OriginalScript { get; private set; }
    public string ExecutableScript { get; private set; }
    internal String[] Arguments { get; private set; }
    private bool HasArguments { get; }
    internal LuaScript(string originalScript, string executableScript, String[] arguments);
    private static LuaScript();
    [CompilerGeneratedAttribute]
public string get_OriginalScript();
    [CompilerGeneratedAttribute]
private void set_OriginalScript(string value);
    [CompilerGeneratedAttribute]
public string get_ExecutableScript();
    [CompilerGeneratedAttribute]
private void set_ExecutableScript(string value);
    [CompilerGeneratedAttribute]
internal String[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(String[] value);
    private bool get_HasArguments();
    protected virtual override void Finalize();
    public static void PurgeCache();
    public static int GetCachedScriptCount();
    public static LuaScript Prepare(string script);
    internal void ExtractParameters(object ps, Nullable`1<RedisKey> keyPrefix, RedisKey[]& keys, RedisValue[]& args);
    public RedisResult Evaluate(IDatabase db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public Task`1<RedisResult> EvaluateAsync(IDatabaseAsync db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public LoadedLuaScript Load(IServer server, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.LuaScript/<LoadAsync>d__25")]
public Task`1<LoadedLuaScript> LoadAsync(IServer server, CommandFlags flags);
}
internal abstract class StackExchange.Redis.Message : object {
    public static Message[] EmptyArray;
    public int Db;
    internal static CommandFlags InternalCallFlag;
    protected RedisCommand command;
    private static CommandFlags AskingFlag;
    private static CommandFlags ScriptUnavailableFlag;
    private static CommandFlags MaskMasterServerPreference;
    private static CommandFlags UserSelectableFlags;
    private CommandFlags flags;
    private ResultBox resultBox;
    private ResultProcessor resultProcessor;
    private ProfileStorage performance;
    internal DateTime createdDateTime;
    internal long createdTimestamp;
    [CompilerGeneratedAttribute]
private CommandStatus <Status>k__BackingField;
    internal CommandFlags FlagsRaw { get; internal set; }
    internal CommandStatus Status { get; private set; }
    public RedisCommand Command { get; }
    public string CommandAndKey { get; }
    public CommandFlags Flags { get; }
    public bool IsAdmin { get; }
    public bool IsAsking { get; }
    internal bool IsScriptUnavailable { get; }
    public bool IsFireAndForget { get; }
    public bool IsHighPriority { get; }
    public bool IsInternalCall { get; }
    public ResultBox ResultBox { get; }
    protected Message(int db, CommandFlags flags, RedisCommand command);
    private static Message();
    internal CommandFlags get_FlagsRaw();
    internal void set_FlagsRaw(CommandFlags value);
    internal void SetMasterOnly();
    internal void SetProfileStorage(ProfileStorage storage);
    internal void PrepareToResend(ServerEndPoint resendTo, bool isMoved);
    [CompilerGeneratedAttribute]
internal CommandStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(CommandStatus value);
    public RedisCommand get_Command();
    public virtual string get_CommandAndKey();
    public CommandFlags get_Flags();
    public bool get_IsAdmin();
    public bool get_IsAsking();
    internal bool get_IsScriptUnavailable();
    internal void SetScriptUnavailable();
    public bool get_IsFireAndForget();
    public bool get_IsHighPriority();
    public bool get_IsInternalCall();
    public ResultBox get_ResultBox();
    public static Message Create(int db, CommandFlags flags, RedisCommand command);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key0, RedisKey key1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key0, RedisKey key1, RedisValue value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key0, RedisKey key1, RedisKey key2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisValue value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisChannel channel);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisChannel channel, RedisValue value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value, RedisChannel channel);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisValue value0, RedisValue value1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisValue value0, RedisValue value1, RedisValue value2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, GeoEntry[] values);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisValue value0, RedisValue value1, RedisValue value2, RedisValue value3);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value0, RedisValue value1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value, RedisKey key);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value0, RedisValue value1, RedisValue value2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue value0, RedisValue value1, RedisValue value2, RedisValue value3, RedisValue value4);
    public static Message CreateInSlot(int db, int slot, CommandFlags flags, RedisCommand command, RedisValue[] values);
    public static bool IsMasterOnly(RedisCommand command);
    public virtual void AppendStormLog(StringBuilder sb);
    public virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    public bool IsMasterOnly();
    public void SetInternalCall();
    public virtual string ToString();
    public void SetResponseReceived();
    public sealed virtual bool TryComplete(bool isAsync);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisKey[] keys);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, IList`1<RedisKey> keys);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, IList`1<RedisValue> values);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key, RedisValue[] values);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey key0, RedisValue[] values, RedisKey key1);
    internal static CommandFlags GetMasterSlaveFlags(CommandFlags flags);
    internal static bool RequiresDatabase(RedisCommand command);
    internal static CommandFlags SetMasterSlaveFlags(CommandFlags everything, CommandFlags masterSlave);
    internal void Cancel();
    internal bool ComputeResult(PhysicalConnection connection, RawResult result);
    internal void Fail(ConnectionFailureType failure, Exception innerException);
    internal void SetEnqueued();
    internal void SetRequestSent();
    internal void SetAsking(bool value);
    internal void SetNoRedirect();
    internal void SetPreferMaster();
    internal void SetPreferSlave();
    internal void SetSource(ResultProcessor resultProcessor, ResultBox resultBox);
    internal void SetSource(ResultBox`1<T> resultBox, ResultProcessor`1<T> resultProcessor);
    internal abstract virtual void WriteImpl(PhysicalConnection physical);
    internal void WriteTo(PhysicalConnection physical);
}
internal class StackExchange.Redis.MessageCompletable : object {
    private RedisChannel channel;
    private Action`2<RedisChannel, RedisValue> handler;
    private RedisValue message;
    public MessageCompletable(RedisChannel channel, RedisValue message, Action`2<RedisChannel, RedisValue> handler);
    public virtual string ToString();
    public sealed virtual bool TryComplete(bool isAsync);
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
}
internal class StackExchange.Redis.MessageQueue : object {
    private Queue`1<Message> regular;
    private Queue`1<Message> high;
    public object SyncLock { get; }
    public object get_SyncLock();
    public Message Dequeue();
    public Message DequeueUnsentPing(Int32& queueLength);
    public bool Push(Message message);
    internal bool Any();
    internal int Count();
    internal Message[] DequeueAll();
    internal void GetStormLog(StringBuilder sb);
}
[FlagsAttribute]
public enum StackExchange.Redis.MigrateOptions : Enum {
    public int value__;
    public static MigrateOptions None;
    public static MigrateOptions Copy;
    public static MigrateOptions Replace;
}
public enum StackExchange.Redis.Order : Enum {
    public int value__;
    public static Order Ascending;
    public static Order Descending;
}
internal class StackExchange.Redis.PhysicalBridge : object {
    internal string Name;
    internal int inWriteQueue;
    private static int ProfileLogSamples;
    private static double ProfileLogSeconds;
    private static Message ReusableAskingCommand;
    private CompletionManager completionManager;
    private Int64[] profileLog;
    private MessageQueue queue;
    private int activeWriters;
    private int beating;
    private int failConnectCount;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isDisposed;
    private long nonPreferredEndpointCount;
    private long operationCount;
    private long socketCount;
    private PhysicalConnection modreq(System.Runtime.CompilerServices.IsVolatile) physical;
    private long profileLastLog;
    private int profileLogIndex;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) reportNextFailure;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) reconfigureNextFailure;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) state;
    [CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionMultiplexer <Multiplexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerEndPoint <ServerEndPoint>k__BackingField;
    private int connectStartTicks;
    private long connectTimeoutRetryCount;
    public Exception LastException { get; private set; }
    public ConnectionType ConnectionType { get; }
    public bool IsConnected { get; }
    public ConnectionMultiplexer Multiplexer { get; }
    public ServerEndPoint ServerEndPoint { get; }
    public long SubscriptionCount { get; }
    internal State ConnectionState { get; }
    internal bool IsBeating { get; }
    internal long OperationCount { get; }
    public PhysicalBridge(ServerEndPoint serverEndPoint, ConnectionType type);
    private static PhysicalBridge();
    [CompilerGeneratedAttribute]
public Exception get_LastException();
    [CompilerGeneratedAttribute]
private void set_LastException(Exception value);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public ConnectionMultiplexer get_Multiplexer();
    [CompilerGeneratedAttribute]
public ServerEndPoint get_ServerEndPoint();
    public long get_SubscriptionCount();
    internal State get_ConnectionState();
    internal bool get_IsBeating();
    internal long get_OperationCount();
    public void CompleteSyncOrAsync(ICompletable operation);
    public sealed virtual void Dispose();
    public void ReportNextFailure();
    public virtual string ToString();
    public void TryConnect(TextWriter log);
    public bool TryEnqueue(Message message, bool isSlave);
    internal void AppendProfile(StringBuilder sb);
    internal bool ConfirmRemoveFromWriteQueue();
    internal void GetCounters(ConnectionCounters counters);
    internal int GetOutstandingCount(Int32& inst, Int32& qu, Int32& qs, Int32& qc, Int32& wr, Int32& wq, Int32& in, Int32& ar);
    internal int GetPendingCount();
    internal string GetStormLog();
    internal void IncrementOpCount();
    internal void KeepAlive();
    internal void OnConnected(PhysicalConnection connection, TextWriter log);
    internal void ResetNonConnected();
    internal void OnConnectionFailed(PhysicalConnection connection, ConnectionFailureType failureType, Exception innerException);
    internal void OnDisconnected(ConnectionFailureType failureType, PhysicalConnection connection, Boolean& isCurrent, State& oldState);
    internal void OnFullyEstablished(PhysicalConnection connection);
    internal void OnHeartbeat(bool ifConnectedOnly);
    internal void RemovePhysical(PhysicalConnection connection);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(string message);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(bool condition, string message);
    internal bool TryEnqueue(List`1<Message> messages, bool isSlave);
    internal bool WriteMessageDirect(PhysicalConnection tmp, Message next);
    internal WriteResult WriteQueue(int maxWork);
    private void AbortUnsent();
    private State ChangeState(State newState);
    private bool ChangeState(State oldState, State newState);
    private PhysicalConnection GetConnection(TextWriter log);
    private void LogNonPreferred(CommandFlags flags, bool isSlave);
    private void OnInternalError(Exception exception, string origin);
    private void SelectDatabase(PhysicalConnection connection, Message message);
    private bool WriteMessageToServer(PhysicalConnection connection, Message message);
}
internal class StackExchange.Redis.PhysicalConnection : object {
    internal Byte[] ChannelPrefix;
    private static int DefaultRedisDatabaseCount;
    private static Byte[] Crlf;
    private Action`1<Task`1<int>> endRead;
    private static Byte[] message;
    private static Byte[] pmessage;
    private static Message[] ReusableChangeDatabaseCommands;
    private static Message ReusableReadOnlyCommand;
    private static Message ReusableReadWriteCommand;
    private static int totalCount;
    private ConnectionType connectionType;
    private Queue`1<Message> outstanding;
    private string physicalName;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) currentDatabase;
    private ReadMode currentReadMode;
    private int failureReported;
    private Byte[] ioBuffer;
    private int ioBufferBytes;
    private int lastWriteTickCount;
    private int lastReadTickCount;
    private int lastBeatTickCount;
    private int firstUnansweredWriteTickCount;
    private Stream netStream;
    private Stream outStream;
    private SocketToken socketToken;
    [CompilerGeneratedAttribute]
private PhysicalBridge <Bridge>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionMultiplexer <Multiplexer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransactionActive>k__BackingField;
    internal static int REDIS_MAX_ARGS;
    private static int ScratchSize;
    private static int Scratch_CharsPerBlock;
    private Byte[] outScratch;
    private Encoder outEncoder;
    private int haveReader;
    public PhysicalBridge Bridge { get; }
    public long LastWriteSecondsAgo { get; }
    public ConnectionMultiplexer Multiplexer { get; }
    public long SubscriptionCount { get; public set; }
    public bool TransactionActive { get; internal set; }
    private bool StackExchange.Redis.ISocketCallback.IsDataAvailable { get; }
    public PhysicalConnection(PhysicalBridge bridge);
    private static PhysicalConnection();
    private static Action`1<Task`1<int>> EndReadFactory(PhysicalConnection physical);
    public void BeginConnect(TextWriter log);
    [CompilerGeneratedAttribute]
public PhysicalBridge get_Bridge();
    public long get_LastWriteSecondsAgo();
    [CompilerGeneratedAttribute]
public ConnectionMultiplexer get_Multiplexer();
    [CompilerGeneratedAttribute]
public long get_SubscriptionCount();
    [CompilerGeneratedAttribute]
public void set_SubscriptionCount(long value);
    [CompilerGeneratedAttribute]
public bool get_TransactionActive();
    [CompilerGeneratedAttribute]
internal void set_TransactionActive(bool value);
    public sealed virtual void Dispose();
    public void Flush();
    public void RecordConnectionFailed(ConnectionFailureType failureType, Exception innerException, string origin);
    public void RecordConnectionFailed(ConnectionFailureType failureType, ManagerState& managerState, Exception innerException, string origin);
    public virtual string ToString();
    internal static void IdentifyFailureType(Exception exception, ConnectionFailureType& failureType);
    internal void Enqueue(Message next);
    internal void GetCounters(ConnectionCounters counters);
    internal Message GetReadModeCommand(bool isMasterOnly);
    internal Message GetSelectDatabaseCommand(int targetDatabase, Message message);
    internal static Message GetSelectDatabaseCommand(int targetDatabase);
    internal int GetSentAwaitingResponseCount();
    internal void GetStormLog(StringBuilder sb);
    internal void OnHeartbeat();
    internal void OnInternalError(Exception exception, string origin);
    internal void SetUnknownDatabase();
    internal void Write(RedisKey key);
    internal void Write(RedisChannel channel);
    internal void Write(RedisValue value);
    internal void WriteHeader(RedisCommand command, int arguments);
    internal void WriteHeader(string command, int arguments);
    private static void WriteRaw(Stream stream, long value, bool withLengthPrefix);
    private static void WriteUnified(Stream stream, Byte[] value);
    internal void WriteAsHex(Byte[] value);
    internal static byte ToHexNibble(int value);
    private void WriteUnified(Stream stream, Byte[] prefix, string value);
    private void WriteRaw(Stream stream, string value, int encodedLength);
    private static void WriteUnified(Stream stream, Byte[] prefix, Byte[] value);
    private static void WriteUnified(Stream stream, long value);
    private void BeginReading();
    internal int GetAvailableInboundBytes(Int32& activeReaders);
    private static LocalCertificateSelectionCallback GetAmbientCertificateCallback();
    private sealed virtual override SocketMode StackExchange.Redis.ISocketCallback.Connected(Stream stream, TextWriter log);
    private bool EndReading(Task`1<int> result);
    private int EnsureSpaceAndComputeBytesToRead();
    private sealed virtual override void StackExchange.Redis.ISocketCallback.Error();
    private void MatchResult(RawResult result);
    private sealed virtual override void StackExchange.Redis.ISocketCallback.OnHeartbeat();
    private int ProcessBuffer(Byte[] underlying, Int32& offset, Int32& count);
    private bool ProcessReadBytes(int bytesRead);
    private sealed virtual override void StackExchange.Redis.ISocketCallback.Read();
    private sealed virtual override bool StackExchange.Redis.ISocketCallback.get_IsDataAvailable();
    private RawResult ReadArray(Byte[] buffer, Int32& offset, Int32& count);
    private RawResult ReadBulkString(Byte[] buffer, Int32& offset, Int32& count);
    private RawResult ReadLineTerminatedString(ResultType type, Byte[] buffer, Int32& offset, Int32& count);
    private sealed virtual override void StackExchange.Redis.ISocketCallback.StartReading();
    private RawResult TryParseResult(Byte[] buffer, Int32& offset, Int32& count);
    public sealed virtual void CheckForStaleConnection(ManagerState& managerState);
}
internal class StackExchange.Redis.ProfileContextTracker : object {
    private long lastCleanupSweep;
    private ConcurrentDictionary`2<ProfileContextCell, ConcurrentProfileStorageCollection> profiledCommands;
    public int ContextCount { get; }
    public int get_ContextCount();
    public bool TryCreate(object ctx);
    public bool TryGetValue(object ctx, ConcurrentProfileStorageCollection& val);
    public bool TryRemove(object ctx, ProfiledCommandEnumerable& commands);
    public bool TryCleanup();
}
public class StackExchange.Redis.ProfiledCommandEnumerable : ValueType {
    private ProfileStorage Head;
    internal ProfiledCommandEnumerable(ProfileStorage head);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<IProfiledCommand> System.Collections.Generic.IEnumerable<StackExchange.Redis.IProfiledCommand>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class StackExchange.Redis.ProfileStorage : object {
    [CompilerGeneratedAttribute]
private Nullable`1<RetransmissionReasonType> <RetransmissionReason>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfileStorage <NextElement>k__BackingField;
    private Message Message;
    private ServerEndPoint Server;
    private ProfileStorage OriginalProfiling;
    private DateTime MessageCreatedDateTime;
    private long MessageCreatedTimeStamp;
    private long EnqueuedTimeStamp;
    private long RequestSentTimeStamp;
    private long ResponseReceivedTimeStamp;
    private long CompletedTimeStamp;
    private ConcurrentProfileStorageCollection PushToWhenFinished;
    public EndPoint EndPoint { get; }
    public int Db { get; }
    public string Command { get; }
    public CommandFlags Flags { get; }
    public DateTime CommandCreated { get; }
    public TimeSpan CreationToEnqueued { get; }
    public TimeSpan EnqueuedToSending { get; }
    public TimeSpan SentToResponse { get; }
    public TimeSpan ResponseToCompletion { get; }
    public TimeSpan ElapsedTime { get; }
    public IProfiledCommand RetransmissionOf { get; }
    public Nullable`1<RetransmissionReasonType> RetransmissionReason { get; }
    public ProfileStorage NextElement { get; public set; }
    private ProfileStorage(ConcurrentProfileStorageCollection pushTo, ServerEndPoint server, ProfileStorage resentFor, Nullable`1<RetransmissionReasonType> reason);
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual int get_Db();
    public sealed virtual string get_Command();
    public sealed virtual CommandFlags get_Flags();
    public sealed virtual DateTime get_CommandCreated();
    public sealed virtual TimeSpan get_CreationToEnqueued();
    public sealed virtual TimeSpan get_EnqueuedToSending();
    public sealed virtual TimeSpan get_SentToResponse();
    public sealed virtual TimeSpan get_ResponseToCompletion();
    public sealed virtual TimeSpan get_ElapsedTime();
    public sealed virtual IProfiledCommand get_RetransmissionOf();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<RetransmissionReasonType> get_RetransmissionReason();
    [CompilerGeneratedAttribute]
public ProfileStorage get_NextElement();
    [CompilerGeneratedAttribute]
public void set_NextElement(ProfileStorage value);
    public static ProfileStorage NewWithContext(ConcurrentProfileStorageCollection pushTo, ServerEndPoint server);
    public static ProfileStorage NewAttachedToSameContext(ProfileStorage resentFor, ServerEndPoint server, bool isMoved);
    public void SetMessage(Message msg);
    public void SetEnqueued();
    public void SetRequestSent();
    public void SetResponseReceived();
    public void SetCompleted();
    public virtual string ToString();
}
public enum StackExchange.Redis.Proxy : Enum {
    public int value__;
    public static Proxy None;
    public static Proxy Twemproxy;
}
internal class StackExchange.Redis.RawResult : ValueType {
    public static RawResult EmptyArray;
    public static RawResult Nil;
    private static Byte[] emptyBlob;
    private int offset;
    private int count;
    private Array arr;
    [CompilerGeneratedAttribute]
private ResultType <Type>k__BackingField;
    private static String[] NilStrings;
    public bool HasValue { get; }
    public bool IsError { get; }
    public ResultType Type { get; }
    internal bool IsNull { get; }
    public RawResult(ResultType resultType, Byte[] buffer, int offset, int count);
    public RawResult(RawResult[] arr);
    private static RawResult();
    public bool get_HasValue();
    public bool get_IsError();
    [CompilerGeneratedAttribute]
public ResultType get_Type();
    internal bool get_IsNull();
    public virtual string ToString();
    internal RedisChannel AsRedisChannel(Byte[] channelPrefix, PatternMode mode);
    internal RedisKey AsRedisKey();
    internal RedisValue AsRedisValue();
    internal bool IsEqual(Byte[] expected);
    internal bool AssertStarts(Byte[] expected);
    internal Byte[] GetBlob();
    internal bool GetBoolean();
    internal RawResult[] GetItems();
    internal RedisKey[] GetItemsAsKeys();
    internal RedisValue[] GetItemsAsValues();
    internal String[] GetItemsAsStrings();
    internal Nullable`1<GeoPosition> GetItemsAsGeoPosition();
    internal Nullable`1[] GetItemsAsGeoPositionArray();
    internal RawResult[] GetItemsAsRawResults();
    internal RawResult[] GetArrayOfRawResults();
    internal string GetString();
    internal bool TryGetDouble(Double& val);
    internal bool TryGetInt64(Int64& value);
}
internal abstract class StackExchange.Redis.RedisBase : object {
    internal static DateTime UnixEpoch;
    internal ConnectionMultiplexer multiplexer;
    protected object asyncState;
    private ConnectionMultiplexer StackExchange.Redis.IRedisAsync.Multiplexer { get; }
    internal RedisBase(ConnectionMultiplexer multiplexer, object asyncState);
    private static RedisBase();
    private sealed virtual override ConnectionMultiplexer StackExchange.Redis.IRedisAsync.get_Multiplexer();
    public virtual TimeSpan Ping(CommandFlags flags);
    public virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public void Quit(CommandFlags flags);
    public Task QuitAsync(CommandFlags flags);
    public virtual string ToString();
    public sealed virtual bool TryWait(Task task);
    public sealed virtual void Wait(Task task);
    public sealed virtual T Wait(Task`1<T> task);
    public sealed virtual void WaitAll(Task[] tasks);
    internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual RedisFeatures GetFeatures(int db, RedisKey key, CommandFlags flags, ServerEndPoint& server);
    protected void WhenAlwaysOrExists(When when);
    protected void WhenAlwaysOrExistsOrNotExists(When when);
    protected void WhenAlwaysOrNotExists(When when);
    private TimerMessage GetTimerMessage(CommandFlags flags);
}
internal class StackExchange.Redis.RedisBatch : RedisDatabase {
    private List`1<Message> pending;
    public RedisBatch(RedisDatabase wrapped, object asyncState);
    public sealed virtual void Execute();
    internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    private void FailNoServer(List`1<Message> messages);
}
public class StackExchange.Redis.RedisChannel : ValueType {
    internal static RedisChannel[] EmptyArray;
    private Byte[] value;
    internal bool IsPatternBased;
    public bool IsNullOrEmpty { get; }
    internal bool IsNull { get; }
    internal Byte[] Value { get; }
    public RedisChannel(Byte[] value, PatternMode mode);
    public RedisChannel(string value, PatternMode mode);
    private RedisChannel(Byte[] value, bool isPatternBased);
    private static RedisChannel();
    private static bool DeterminePatternBased(Byte[] value, PatternMode mode);
    public bool get_IsNullOrEmpty();
    internal bool get_IsNull();
    internal Byte[] get_Value();
    public static bool op_Inequality(RedisChannel x, RedisChannel y);
    public static bool op_Inequality(string x, RedisChannel y);
    public static bool op_Inequality(Byte[] x, RedisChannel y);
    public static bool op_Inequality(RedisChannel x, string y);
    public static bool op_Inequality(RedisChannel x, Byte[] y);
    public static bool op_Equality(RedisChannel x, RedisChannel y);
    public static bool op_Equality(string x, RedisChannel y);
    public static bool op_Equality(Byte[] x, RedisChannel y);
    public static bool op_Equality(RedisChannel x, string y);
    public static bool op_Equality(RedisChannel x, Byte[] y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisChannel other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static bool AssertStarts(Byte[] value, Byte[] expected);
    internal void AssertNotNull();
    internal RedisChannel Clone();
    public static RedisChannel op_Implicit(string key);
    public static RedisChannel op_Implicit(Byte[] key);
    public static Byte[] op_Implicit(RedisChannel key);
    public static string op_Implicit(RedisChannel key);
}
internal enum StackExchange.Redis.RedisCommand : Enum {
    public int value__;
    public static RedisCommand APPEND;
    public static RedisCommand ASKING;
    public static RedisCommand AUTH;
    public static RedisCommand BGREWRITEAOF;
    public static RedisCommand BGSAVE;
    public static RedisCommand BITCOUNT;
    public static RedisCommand BITOP;
    public static RedisCommand BITPOS;
    public static RedisCommand BLPOP;
    public static RedisCommand BRPOP;
    public static RedisCommand BRPOPLPUSH;
    public static RedisCommand CLIENT;
    public static RedisCommand CLUSTER;
    public static RedisCommand CONFIG;
    public static RedisCommand DBSIZE;
    public static RedisCommand DEBUG;
    public static RedisCommand DECR;
    public static RedisCommand DECRBY;
    public static RedisCommand DEL;
    public static RedisCommand DISCARD;
    public static RedisCommand DUMP;
    public static RedisCommand ECHO;
    public static RedisCommand EVAL;
    public static RedisCommand EVALSHA;
    public static RedisCommand EXEC;
    public static RedisCommand EXISTS;
    public static RedisCommand EXPIRE;
    public static RedisCommand EXPIREAT;
    public static RedisCommand FLUSHALL;
    public static RedisCommand FLUSHDB;
    public static RedisCommand GEOADD;
    public static RedisCommand GEODIST;
    public static RedisCommand GEOHASH;
    public static RedisCommand GEOPOS;
    public static RedisCommand GEORADIUS;
    public static RedisCommand GEORADIUSBYMEMBER;
    public static RedisCommand GET;
    public static RedisCommand GETBIT;
    public static RedisCommand GETRANGE;
    public static RedisCommand GETSET;
    public static RedisCommand HDEL;
    public static RedisCommand HEXISTS;
    public static RedisCommand HGET;
    public static RedisCommand HGETALL;
    public static RedisCommand HINCRBY;
    public static RedisCommand HINCRBYFLOAT;
    public static RedisCommand HKEYS;
    public static RedisCommand HLEN;
    public static RedisCommand HMGET;
    public static RedisCommand HMSET;
    public static RedisCommand HSCAN;
    public static RedisCommand HSET;
    public static RedisCommand HSETNX;
    public static RedisCommand HVALS;
    public static RedisCommand INCR;
    public static RedisCommand INCRBY;
    public static RedisCommand INCRBYFLOAT;
    public static RedisCommand INFO;
    public static RedisCommand KEYS;
    public static RedisCommand LASTSAVE;
    public static RedisCommand LINDEX;
    public static RedisCommand LINSERT;
    public static RedisCommand LLEN;
    public static RedisCommand LPOP;
    public static RedisCommand LPUSH;
    public static RedisCommand LPUSHX;
    public static RedisCommand LRANGE;
    public static RedisCommand LREM;
    public static RedisCommand LSET;
    public static RedisCommand LTRIM;
    public static RedisCommand MGET;
    public static RedisCommand MIGRATE;
    public static RedisCommand MONITOR;
    public static RedisCommand MOVE;
    public static RedisCommand MSET;
    public static RedisCommand MSETNX;
    public static RedisCommand MULTI;
    public static RedisCommand OBJECT;
    public static RedisCommand PERSIST;
    public static RedisCommand PEXPIRE;
    public static RedisCommand PEXPIREAT;
    public static RedisCommand PFADD;
    public static RedisCommand PFCOUNT;
    public static RedisCommand PFMERGE;
    public static RedisCommand PING;
    public static RedisCommand PSETEX;
    public static RedisCommand PSUBSCRIBE;
    public static RedisCommand PTTL;
    public static RedisCommand PUBLISH;
    public static RedisCommand PUBSUB;
    public static RedisCommand PUNSUBSCRIBE;
    public static RedisCommand QUIT;
    public static RedisCommand RANDOMKEY;
    public static RedisCommand READONLY;
    public static RedisCommand READWRITE;
    public static RedisCommand RENAME;
    public static RedisCommand RENAMENX;
    public static RedisCommand RESTORE;
    public static RedisCommand RPOP;
    public static RedisCommand RPOPLPUSH;
    public static RedisCommand RPUSH;
    public static RedisCommand RPUSHX;
    public static RedisCommand SADD;
    public static RedisCommand SAVE;
    public static RedisCommand SCAN;
    public static RedisCommand SCARD;
    public static RedisCommand SCRIPT;
    public static RedisCommand SDIFF;
    public static RedisCommand SDIFFSTORE;
    public static RedisCommand SELECT;
    public static RedisCommand SENTINEL;
    public static RedisCommand SET;
    public static RedisCommand SETBIT;
    public static RedisCommand SETEX;
    public static RedisCommand SETNX;
    public static RedisCommand SETRANGE;
    public static RedisCommand SHUTDOWN;
    public static RedisCommand SINTER;
    public static RedisCommand SINTERSTORE;
    public static RedisCommand SISMEMBER;
    public static RedisCommand SLAVEOF;
    public static RedisCommand SLOWLOG;
    public static RedisCommand SMEMBERS;
    public static RedisCommand SMOVE;
    public static RedisCommand SORT;
    public static RedisCommand SPOP;
    public static RedisCommand SRANDMEMBER;
    public static RedisCommand SREM;
    public static RedisCommand STRLEN;
    public static RedisCommand SUBSCRIBE;
    public static RedisCommand SUNION;
    public static RedisCommand SUNIONSTORE;
    public static RedisCommand SSCAN;
    public static RedisCommand SYNC;
    public static RedisCommand TIME;
    public static RedisCommand TTL;
    public static RedisCommand TYPE;
    public static RedisCommand UNSUBSCRIBE;
    public static RedisCommand UNWATCH;
    public static RedisCommand WATCH;
    public static RedisCommand ZADD;
    public static RedisCommand ZCARD;
    public static RedisCommand ZCOUNT;
    public static RedisCommand ZINCRBY;
    public static RedisCommand ZINTERSTORE;
    public static RedisCommand ZLEXCOUNT;
    public static RedisCommand ZRANGE;
    public static RedisCommand ZRANGEBYLEX;
    public static RedisCommand ZRANGEBYSCORE;
    public static RedisCommand ZRANK;
    public static RedisCommand ZREM;
    public static RedisCommand ZREMRANGEBYLEX;
    public static RedisCommand ZREMRANGEBYRANK;
    public static RedisCommand ZREMRANGEBYSCORE;
    public static RedisCommand ZREVRANGE;
    public static RedisCommand ZREVRANGEBYSCORE;
    public static RedisCommand ZREVRANK;
    public static RedisCommand ZSCAN;
    public static RedisCommand ZSCORE;
    public static RedisCommand ZUNIONSTORE;
    public static RedisCommand UNKNOWN;
}
public class StackExchange.Redis.RedisCommandException : Exception {
    internal RedisCommandException(string message);
    internal RedisCommandException(string message, Exception innerException);
}
public class StackExchange.Redis.RedisConnectionException : RedisException {
    [CompilerGeneratedAttribute]
private ConnectionFailureType <FailureType>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandStatus <CommandStatus>k__BackingField;
    public ConnectionFailureType FailureType { get; }
    public CommandStatus CommandStatus { get; }
    internal RedisConnectionException(ConnectionFailureType failureType, string message);
    internal RedisConnectionException(ConnectionFailureType failureType, string message, Exception innerException);
    internal RedisConnectionException(ConnectionFailureType failureType, string message, Exception innerException, CommandStatus commandStatus);
    [CompilerGeneratedAttribute]
public ConnectionFailureType get_FailureType();
    [CompilerGeneratedAttribute]
public CommandStatus get_CommandStatus();
}
internal class StackExchange.Redis.RedisDatabase : RedisBase {
    [CompilerGeneratedAttribute]
private int <Database>k__BackingField;
    private static RedisValue WITHCOORD;
    private static RedisValue WITHDIST;
    private static RedisValue WITHHASH;
    private static RedisValue COUNT;
    private static RedisValue ASC;
    private static RedisValue DESC;
    public object AsyncState { get; }
    public int Database { get; }
    internal RedisDatabase(ConnectionMultiplexer multiplexer, int db, object asyncState);
    private static RedisDatabase();
    public object get_AsyncState();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Database();
    public sealed virtual IBatch CreateBatch(object asyncState);
    public sealed virtual ITransaction CreateTransaction(object asyncState);
    private ITransaction CreateTransactionIfAvailable(object asyncState);
    public sealed virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual long GeoAdd(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue value0, RedisValue value1, GeoUnit unit, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue value0, RedisValue value1, GeoUnit unit, CommandFlags flags);
    public sealed virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    private Message GetGeoRadiusMessage(RedisKey key, Nullable`1<RedisValue> member, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long HashLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public Task`1<bool> HashSetIfNotExistsAsync(RedisKey key, RedisValue hashField, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public sealed virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisKey KeyRandom(CommandFlags flags);
    public sealed virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public sealed virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public sealed virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult Execute(string command, Object[] args);
    public sealed virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool value, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool value, long start, long end, CommandFlags flags);
    public sealed virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual bool StringSetBit(RedisKey key, long offset, bool value, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool value, CommandFlags flags);
    public sealed virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    private Message GetExpiryMessage(RedisKey key, CommandFlags flags, Nullable`1<TimeSpan> expiry, ServerEndPoint& server);
    private Message GetExpiryMessage(RedisKey key, CommandFlags flags, Nullable`1<DateTime> expiry, ServerEndPoint& server);
    private Message GetHashSetMessage(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    private ITransaction GetLockExtendTransaction(RedisKey key, RedisValue value, TimeSpan expiry);
    private ITransaction GetLockReleaseTransaction(RedisKey key, RedisValue value);
    private RedisValue GetLexRange(RedisValue value, Exclude exclude, bool isStart);
    private RedisValue GetRange(double value, Exclude exclude, bool isStart);
    private Message GetRestoreMessage(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    private Message GetSortedSetAddMessage(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    private Message GetSortedSetAddMessage(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    private Message GetSortedSetAddMessage(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    private Message GetSortedSetCombineAndStoreCommandMessage(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    private Message GetSortedSetLengthMessage(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    private Message GetSortedSetRangeByScoreMessage(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags, bool withScores);
    private Message GetSortedSetRemoveRangeByScoreMessage(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    private Message GetStringBitOperationMessage(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    private Message GetStringBitOperationMessage(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    private Message GetStringGetWithExpiryMessage(RedisKey key, CommandFlags flags, ResultProcessor`1& processor, ServerEndPoint& server);
    private Message GetStringSetMessage(KeyValuePair`2[] values, When when, CommandFlags flags);
    private Message GetStringSetMessage(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    private Message IncrMessage(RedisKey key, long value, CommandFlags flags);
    private RedisCommand SetOperationCommand(SetOperation operation, bool store);
    private IEnumerable`1<T> TryScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags, RedisCommand command, ResultProcessor`1<ScanResult<T>> processor);
    private Message GetLexMessage(RedisCommand command, RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
}
public class StackExchange.Redis.RedisErrorEventArgs : EventArgs {
    private EventHandler`1<RedisErrorEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public EndPoint EndPoint { get; }
    public string Message { get; }
    internal RedisErrorEventArgs(EventHandler`1<RedisErrorEventArgs> handler, object sender, EndPoint endpoint, string message);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public string get_Message();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
public class StackExchange.Redis.RedisException : Exception {
    internal RedisException(string message);
    internal RedisException(string message, Exception innerException);
}
public class StackExchange.Redis.RedisFeatures : ValueType {
    internal static Version v2_0_0;
    internal static Version v2_1_0;
    internal static Version v2_1_1;
    internal static Version v2_1_2;
    internal static Version v2_1_3;
    internal static Version v2_1_8;
    internal static Version v2_2_0;
    internal static Version v2_4_0;
    internal static Version v2_5_7;
    internal static Version v2_5_10;
    internal static Version v2_5_14;
    internal static Version v2_6_0;
    internal static Version v2_6_5;
    internal static Version v2_6_9;
    internal static Version v2_6_12;
    internal static Version v2_8_0;
    internal static Version v2_8_12;
    internal static Version v2_8_18;
    internal static Version v2_9_5;
    internal static Version v3_0_0;
    internal static Version v3_2_0;
    private Version version;
    public bool BitwiseOperations { get; }
    public bool ClientName { get; }
    public bool ExecAbort { get; }
    public bool ExpireOverwrite { get; }
    public bool HashVaradicDelete { get; }
    public bool IncrementFloat { get; }
    public bool InfoSections { get; }
    public bool ListInsert { get; }
    public bool MillisecondExpiry { get; }
    public bool MultipleRandom { get; }
    public bool Persist { get; }
    public bool PushIfNotExists { get; }
    public bool Scan { get; }
    public bool Scripting { get; }
    public bool SetConditional { get; }
    public bool SetVaradicAddRemove { get; }
    public bool StringLength { get; }
    public bool StringSetRange { get; }
    public bool Time { get; }
    public bool ScriptingDatabaseSafe { get; }
    public bool HyperLogLogCountSlaveSafe { get; }
    public bool Geo { get; }
    public Version Version { get; }
    public RedisFeatures(Version version);
    private static RedisFeatures();
    public bool get_BitwiseOperations();
    public bool get_ClientName();
    public bool get_ExecAbort();
    public bool get_ExpireOverwrite();
    public bool get_HashVaradicDelete();
    public bool get_IncrementFloat();
    public bool get_InfoSections();
    public bool get_ListInsert();
    public bool get_MillisecondExpiry();
    public bool get_MultipleRandom();
    public bool get_Persist();
    public bool get_PushIfNotExists();
    public bool get_Scan();
    public bool get_Scripting();
    public bool get_SetConditional();
    public bool get_SetVaradicAddRemove();
    public bool get_StringLength();
    public bool get_StringSetRange();
    public bool get_Time();
    public bool get_ScriptingDatabaseSafe();
    public bool get_HyperLogLogCountSlaveSafe();
    public bool get_Geo();
    public Version get_Version();
    public virtual string ToString();
}
public class StackExchange.Redis.RedisKey : ValueType {
    internal static RedisKey[] EmptyArray;
    private Byte[] keyPrefix;
    private object keyValue;
    internal bool IsNull { get; }
    internal bool IsEmpty { get; }
    internal Byte[] KeyPrefix { get; }
    internal object KeyValue { get; }
    internal RedisKey(Byte[] keyPrefix, object keyValue);
    private static RedisKey();
    internal RedisKey AsPrefix();
    internal bool get_IsNull();
    internal bool get_IsEmpty();
    internal Byte[] get_KeyPrefix();
    internal object get_KeyValue();
    public static bool op_Inequality(RedisKey x, RedisKey y);
    public static bool op_Inequality(string x, RedisKey y);
    public static bool op_Inequality(Byte[] x, RedisKey y);
    public static bool op_Inequality(RedisKey x, string y);
    public static bool op_Inequality(RedisKey x, Byte[] y);
    public static bool op_Equality(RedisKey x, RedisKey y);
    public static bool op_Equality(string x, RedisKey y);
    public static bool op_Equality(Byte[] x, RedisKey y);
    public static bool op_Equality(RedisKey x, string y);
    public static bool op_Equality(RedisKey x, Byte[] y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisKey other);
    private static bool CompositeEquals(Byte[] keyPrefix0, object keyValue0, Byte[] keyPrefix1, object keyValue1);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal RedisValue AsRedisValue();
    internal void AssertNotNull();
    public static RedisKey op_Implicit(string key);
    public static RedisKey op_Implicit(Byte[] key);
    public static Byte[] op_Implicit(RedisKey key);
    public static string op_Implicit(RedisKey key);
    [ObsoleteAttribute]
public static RedisKey op_Addition(RedisKey x, RedisKey y);
    internal static RedisKey WithPrefix(Byte[] prefix, RedisKey value);
    internal static Byte[] ConcatenateBytes(Byte[] a, object b, Byte[] c);
    public RedisKey Prepend(RedisKey p);
    public RedisKey Append(RedisKey p);
}
internal static class StackExchange.Redis.RedisLiterals : object {
    public static RedisValue ADDR;
    public static RedisValue AFTER;
    public static RedisValue AGGREGATE;
    public static RedisValue ALPHA;
    public static RedisValue AND;
    public static RedisValue BEFORE;
    public static RedisValue BY;
    public static RedisValue CHANNELS;
    public static RedisValue COPY;
    public static RedisValue COUNT;
    public static RedisValue DESC;
    public static RedisValue EX;
    public static RedisValue EXISTS;
    public static RedisValue FLUSH;
    public static RedisValue GET;
    public static RedisValue GETNAME;
    public static RedisValue ID;
    public static RedisValue KILL;
    public static RedisValue LIMIT;
    public static RedisValue LIST;
    public static RedisValue LOAD;
    public static RedisValue MATCH;
    public static RedisValue MAX;
    public static RedisValue MIN;
    public static RedisValue NODES;
    public static RedisValue NOSAVE;
    public static RedisValue NOT;
    public static RedisValue NUMPAT;
    public static RedisValue NUMSUB;
    public static RedisValue NX;
    public static RedisValue OBJECT;
    public static RedisValue OR;
    public static RedisValue PAUSE;
    public static RedisValue PING;
    public static RedisValue PX;
    public static RedisValue REPLACE;
    public static RedisValue RESET;
    public static RedisValue RESETSTAT;
    public static RedisValue REWRITE;
    public static RedisValue SAVE;
    public static RedisValue SEGFAULT;
    public static RedisValue SET;
    public static RedisValue SETNAME;
    public static RedisValue SKIPME;
    public static RedisValue STORE;
    public static RedisValue TYPE;
    public static RedisValue WEIGHTS;
    public static RedisValue WITHSCORES;
    public static RedisValue XOR;
    public static RedisValue XX;
    public static RedisValue MASTERS;
    public static RedisValue MASTER;
    public static RedisValue SLAVES;
    public static RedisValue GETMASTERADDRBYNAME;
    public static RedisValue FAILOVER;
    public static RedisValue MONITOR;
    public static RedisValue REMOVE;
    public static RedisValue databases;
    public static RedisValue no;
    public static RedisValue normal;
    public static RedisValue pubsub;
    public static RedisValue replication;
    public static RedisValue server;
    public static RedisValue slave;
    public static RedisValue slave_read_only;
    public static RedisValue timeout;
    public static RedisValue yes;
    public static RedisValue MinusSymbol;
    public static RedisValue PlusSumbol;
    public static RedisValue Wildcard;
    public static Byte[] BytesOK;
    public static Byte[] BytesPONG;
    public static Byte[] BytesBackgroundSavingStarted;
    public static Byte[] ByteWildcard;
    private static RedisLiterals();
    internal static RedisValue Get(Bitwise operation);
}
public abstract class StackExchange.Redis.RedisResult : object {
    public bool IsNull { get; }
    public static RedisResult Create(RedisValue value);
    internal static RedisResult TryCreate(PhysicalConnection connection, RawResult result);
    public abstract virtual bool get_IsNull();
    public static string op_Explicit(RedisResult result);
    public static Byte[] op_Explicit(RedisResult result);
    public static double op_Explicit(RedisResult result);
    public static long op_Explicit(RedisResult result);
    public static int op_Explicit(RedisResult result);
    public static bool op_Explicit(RedisResult result);
    public static RedisValue op_Explicit(RedisResult result);
    public static RedisKey op_Explicit(RedisResult result);
    public static Nullable`1<double> op_Explicit(RedisResult result);
    public static Nullable`1<long> op_Explicit(RedisResult result);
    public static Nullable`1<int> op_Explicit(RedisResult result);
    public static Nullable`1<bool> op_Explicit(RedisResult result);
    public static String[] op_Explicit(RedisResult result);
    public static Byte[][] op_Explicit(RedisResult result);
    public static Double[] op_Explicit(RedisResult result);
    public static Int64[] op_Explicit(RedisResult result);
    public static Int32[] op_Explicit(RedisResult result);
    public static Boolean[] op_Explicit(RedisResult result);
    public static RedisValue[] op_Explicit(RedisResult result);
    public static RedisKey[] op_Explicit(RedisResult result);
    public static RedisResult[] op_Explicit(RedisResult result);
    internal abstract virtual bool AsBoolean();
    internal abstract virtual Boolean[] AsBooleanArray();
    internal abstract virtual Byte[] AsByteArray();
    internal abstract virtual Byte[][] AsByteArrayArray();
    internal abstract virtual double AsDouble();
    internal abstract virtual Double[] AsDoubleArray();
    internal abstract virtual int AsInt32();
    internal abstract virtual Int32[] AsInt32Array();
    internal abstract virtual long AsInt64();
    internal abstract virtual Int64[] AsInt64Array();
    internal abstract virtual Nullable`1<bool> AsNullableBoolean();
    internal abstract virtual Nullable`1<double> AsNullableDouble();
    internal abstract virtual Nullable`1<int> AsNullableInt32();
    internal abstract virtual Nullable`1<long> AsNullableInt64();
    internal abstract virtual RedisKey AsRedisKey();
    internal abstract virtual RedisKey[] AsRedisKeyArray();
    internal abstract virtual RedisResult[] AsRedisResultArray();
    internal abstract virtual RedisValue AsRedisValue();
    internal abstract virtual RedisValue[] AsRedisValueArray();
    internal abstract virtual string AsString();
    internal abstract virtual String[] AsStringArray();
}
internal class StackExchange.Redis.RedisServer : RedisBase {
    private ServerEndPoint server;
    public ClusterConfiguration ClusterConfiguration { get; }
    public EndPoint EndPoint { get; }
    public RedisFeatures Features { get; }
    public bool IsConnected { get; }
    public bool IsSlave { get; }
    public bool AllowSlaveWrites { get; public set; }
    public ServerType ServerType { get; }
    public Version Version { get; }
    internal RedisServer(ConnectionMultiplexer multiplexer, ServerEndPoint server, object asyncState);
    public sealed virtual ClusterConfiguration get_ClusterConfiguration();
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual RedisFeatures get_Features();
    public sealed virtual bool get_IsConnected();
    public sealed virtual bool get_IsSlave();
    public sealed virtual bool get_AllowSlaveWrites();
    public sealed virtual void set_AllowSlaveWrites(bool value);
    public sealed virtual ServerType get_ServerType();
    public sealed virtual Version get_Version();
    public sealed virtual void ClientKill(EndPoint endpoint, CommandFlags flags);
    public sealed virtual Task ClientKillAsync(EndPoint endpoint, CommandFlags flags);
    public sealed virtual long ClientKill(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public sealed virtual Task`1<long> ClientKillAsync(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    private Message GetClientKillMessage(EndPoint endpoint, Nullable`1<long> id, Nullable`1<ClientType> clientType, bool skipMe, CommandFlags flags);
    public sealed virtual ClientInfo[] ClientList(CommandFlags flags);
    public sealed virtual Task`1<ClientInfo[]> ClientListAsync(CommandFlags flags);
    public sealed virtual ClusterConfiguration ClusterNodes(CommandFlags flags);
    public sealed virtual Task`1<ClusterConfiguration> ClusterNodesAsync(CommandFlags flags);
    public sealed virtual string ClusterNodesRaw(CommandFlags flags);
    public sealed virtual Task`1<string> ClusterNodesRawAsync(CommandFlags flags);
    public sealed virtual KeyValuePair`2[] ConfigGet(RedisValue pattern, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[]> ConfigGetAsync(RedisValue pattern, CommandFlags flags);
    public sealed virtual void ConfigResetStatistics(CommandFlags flags);
    public sealed virtual Task ConfigResetStatisticsAsync(CommandFlags flags);
    public sealed virtual void ConfigRewrite(CommandFlags flags);
    public sealed virtual Task ConfigRewriteAsync(CommandFlags flags);
    public sealed virtual void ConfigSet(RedisValue setting, RedisValue value, CommandFlags flags);
    public sealed virtual Task ConfigSetAsync(RedisValue setting, RedisValue value, CommandFlags flags);
    public sealed virtual long DatabaseSize(int database, CommandFlags flags);
    public sealed virtual Task`1<long> DatabaseSizeAsync(int database, CommandFlags flags);
    public sealed virtual RedisValue Echo(RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> EchoAsync(RedisValue message, CommandFlags flags);
    public sealed virtual void FlushAllDatabases(CommandFlags flags);
    public sealed virtual Task FlushAllDatabasesAsync(CommandFlags flags);
    public sealed virtual void FlushDatabase(int database, CommandFlags flags);
    public sealed virtual Task FlushDatabaseAsync(int database, CommandFlags flags);
    public sealed virtual ServerCounters GetCounters();
    public sealed virtual IGrouping`2[] Info(RedisValue section, CommandFlags flags);
    public sealed virtual Task`1<IGrouping`2[]> InfoAsync(RedisValue section, CommandFlags flags);
    public sealed virtual string InfoRaw(RedisValue section, CommandFlags flags);
    public sealed virtual Task`1<string> InfoRawAsync(RedisValue section, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisKey> StackExchange.Redis.IServer.Keys(int database, RedisValue pattern, int pageSize, CommandFlags flags);
    public sealed virtual IEnumerable`1<RedisKey> Keys(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual DateTime LastSave(CommandFlags flags);
    public sealed virtual Task`1<DateTime> LastSaveAsync(CommandFlags flags);
    public sealed virtual void MakeMaster(ReplicationChangeOptions options, TextWriter log);
    public sealed virtual void Save(SaveType type, CommandFlags flags);
    public sealed virtual Task SaveAsync(SaveType type, CommandFlags flags);
    public sealed virtual bool ScriptExists(string script, CommandFlags flags);
    public sealed virtual bool ScriptExists(Byte[] sha1, CommandFlags flags);
    public sealed virtual Task`1<bool> ScriptExistsAsync(string script, CommandFlags flags);
    public sealed virtual Task`1<bool> ScriptExistsAsync(Byte[] sha1, CommandFlags flags);
    public sealed virtual void ScriptFlush(CommandFlags flags);
    public sealed virtual Task ScriptFlushAsync(CommandFlags flags);
    public sealed virtual Byte[] ScriptLoad(string script, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> ScriptLoadAsync(string script, CommandFlags flags);
    public sealed virtual LoadedLuaScript ScriptLoad(LuaScript script, CommandFlags flags);
    public sealed virtual Task`1<LoadedLuaScript> ScriptLoadAsync(LuaScript script, CommandFlags flags);
    public sealed virtual void Shutdown(ShutdownMode shutdownMode, CommandFlags flags);
    public sealed virtual CommandTrace[] SlowlogGet(int count, CommandFlags flags);
    public sealed virtual Task`1<CommandTrace[]> SlowlogGetAsync(int count, CommandFlags flags);
    public sealed virtual void SlowlogReset(CommandFlags flags);
    public sealed virtual Task SlowlogResetAsync(CommandFlags flags);
    public RedisValue StringGet(int db, RedisKey key, CommandFlags flags);
    public Task`1<RedisValue> StringGetAsync(int db, RedisKey key, CommandFlags flags);
    public sealed virtual RedisChannel[] SubscriptionChannels(RedisChannel pattern, CommandFlags flags);
    public sealed virtual Task`1<RedisChannel[]> SubscriptionChannelsAsync(RedisChannel pattern, CommandFlags flags);
    public sealed virtual long SubscriptionPatternCount(CommandFlags flags);
    public sealed virtual Task`1<long> SubscriptionPatternCountAsync(CommandFlags flags);
    public sealed virtual long SubscriptionSubscriberCount(RedisChannel channel, CommandFlags flags);
    public sealed virtual Task`1<long> SubscriptionSubscriberCountAsync(RedisChannel channel, CommandFlags flags);
    public sealed virtual DateTime Time(CommandFlags flags);
    public sealed virtual Task`1<DateTime> TimeAsync(CommandFlags flags);
    internal static Message CreateSlaveOfMessage(EndPoint endpoint, CommandFlags flags);
    internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual RedisFeatures GetFeatures(int db, RedisKey key, CommandFlags flags, ServerEndPoint& server);
    public sealed virtual void SlaveOf(EndPoint endpoint, CommandFlags flags);
    public sealed virtual Task SlaveOfAsync(EndPoint endpoint, CommandFlags flags);
    private void FixFlags(Message message, ServerEndPoint server);
    private Message GetSaveMessage(SaveType type, CommandFlags flags);
    private ResultProcessor`1<bool> GetSaveResultProcessor(SaveType type);
    public sealed virtual EndPoint SentinelGetMasterAddressByName(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> SentinelGetMasterAddressByNameAsync(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[] SentinelMaster(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[]> SentinelMasterAsync(string serviceName, CommandFlags flags);
    public sealed virtual void SentinelFailover(string serviceName, CommandFlags flags);
    public sealed virtual Task SentinelFailoverAsync(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[][] SentinelMasters(CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[][]> SentinelMastersAsync(CommandFlags flags);
    public sealed virtual KeyValuePair`2[][] SentinelSlaves(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[][]> SentinelSlavesAsync(string serviceName, CommandFlags flags);
}
public class StackExchange.Redis.RedisServerException : RedisException {
    internal RedisServerException(string message);
}
internal class StackExchange.Redis.RedisSubscriber : RedisBase {
    internal RedisSubscriber(ConnectionMultiplexer multiplexer, object asyncState);
    public sealed virtual EndPoint IdentifyEndpoint(RedisChannel channel, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisChannel channel, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisChannel channel);
    public virtual TimeSpan Ping(CommandFlags flags);
    public virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual void Subscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public sealed virtual Task SubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public sealed virtual EndPoint SubscribedEndpoint(RedisChannel channel);
    public sealed virtual void Unsubscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public sealed virtual void UnsubscribeAll(CommandFlags flags);
    public sealed virtual Task UnsubscribeAllAsync(CommandFlags flags);
    public sealed virtual Task UnsubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
}
public class StackExchange.Redis.RedisTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private CommandStatus <Commandstatus>k__BackingField;
    public CommandStatus Commandstatus { get; }
    internal RedisTimeoutException(string message, CommandStatus commandStatus);
    [CompilerGeneratedAttribute]
public CommandStatus get_Commandstatus();
}
internal class StackExchange.Redis.RedisTransaction : RedisDatabase {
    private List`1<ConditionResult> conditions;
    private List`1<QueuedMessage> pending;
    public RedisTransaction(RedisDatabase wrapped, object asyncState);
    public sealed virtual ConditionResult AddCondition(Condition condition);
    public sealed virtual void Execute();
    public sealed virtual bool Execute(CommandFlags flags);
    public sealed virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
    internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    private Message CreateMessage(CommandFlags flags, ResultProcessor`1& processor);
}
public enum StackExchange.Redis.RedisType : Enum {
    public int value__;
    public static RedisType None;
    public static RedisType String;
    public static RedisType List;
    public static RedisType Set;
    public static RedisType SortedSet;
    public static RedisType Hash;
    public static RedisType Unknown;
}
public class StackExchange.Redis.RedisValue : ValueType {
    internal static RedisValue[] EmptyArray;
    private static Byte[] EmptyByteArr;
    private static Byte[] IntegerSentinel;
    private Byte[] valueBlob;
    private long valueInt64;
    [CompilerGeneratedAttribute]
private static RedisValue <EmptyString>k__BackingField;
    [CompilerGeneratedAttribute]
private static RedisValue <Null>k__BackingField;
    public static RedisValue EmptyString { get; }
    public static RedisValue Null { get; }
    public bool IsInteger { get; }
    public bool IsNull { get; }
    public bool IsNullOrEmpty { get; }
    public bool HasValue { get; }
    private RedisValue(long valueInt64, Byte[] valueBlob);
    private static RedisValue();
    [CompilerGeneratedAttribute]
public static RedisValue get_EmptyString();
    [CompilerGeneratedAttribute]
public static RedisValue get_Null();
    public bool get_IsInteger();
    public bool get_IsNull();
    public bool get_IsNullOrEmpty();
    public bool get_HasValue();
    public static bool op_Inequality(RedisValue x, RedisValue y);
    public static bool op_Equality(RedisValue x, RedisValue y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisValue other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static bool Equals(Byte[] x, Byte[] y);
    internal static int GetHashCode(Byte[] value);
    internal static bool TryParseInt64(Byte[] value, int offset, int count, Int64& result);
    internal void AssertNotNull();
    private CompareType ResolveType(Int64& i64, Double& r8);
    public sealed virtual int CompareTo(RedisValue other);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public static RedisValue op_Implicit(int value);
    public static RedisValue op_Implicit(Nullable`1<int> value);
    public static RedisValue op_Implicit(long value);
    public static RedisValue op_Implicit(Nullable`1<long> value);
    public static RedisValue op_Implicit(double value);
    public static RedisValue op_Implicit(Nullable`1<double> value);
    public static RedisValue op_Implicit(string value);
    public static RedisValue op_Implicit(Byte[] value);
    internal static RedisValue Parse(object obj);
    public static RedisValue op_Implicit(bool value);
    public static RedisValue op_Implicit(Nullable`1<bool> value);
    public static bool op_Explicit(RedisValue value);
    public static int op_Explicit(RedisValue value);
    public static long op_Explicit(RedisValue value);
    public static double op_Explicit(RedisValue value);
    private static bool TryParseDouble(Byte[] blob, Double& value);
    public static Nullable`1<double> op_Explicit(RedisValue value);
    public static Nullable`1<long> op_Explicit(RedisValue value);
    public static Nullable`1<int> op_Explicit(RedisValue value);
    public static Nullable`1<bool> op_Explicit(RedisValue value);
    public static string op_Implicit(RedisValue value);
    public static Byte[] op_Implicit(RedisValue value);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public bool TryParse(Int64& val);
    public bool TryParse(Int32& val);
    public bool TryParse(Double& val);
}
public class StackExchange.Redis.RedisValueWithExpiry : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Expiry>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <Value>k__BackingField;
    public Nullable`1<TimeSpan> Expiry { get; }
    public RedisValue Value { get; }
    internal RedisValueWithExpiry(RedisValue value, Nullable`1<TimeSpan> expiry);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Expiry();
    [CompilerGeneratedAttribute]
public RedisValue get_Value();
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ReflectionExtensions : object {
    private static Dictionary`2<Type, TypeCode> typeCodeLookup;
    private static ReflectionExtensions();
    [ExtensionAttribute]
internal static TypeCode GetTypeCode(Type type);
}
public enum StackExchange.Redis.ReplicationChangeOptions : Enum {
    public int value__;
    public static ReplicationChangeOptions None;
    public static ReplicationChangeOptions SetTiebreaker;
    public static ReplicationChangeOptions Broadcast;
    public static ReplicationChangeOptions EnslaveSubordinates;
    public static ReplicationChangeOptions All;
}
internal abstract class StackExchange.Redis.ResultBox : object {
    protected Exception exception;
    public void SetException(Exception exception);
    public abstract virtual bool TryComplete(bool isAsync);
    [ConditionalAttribute("DEBUG")]
protected static void IncrementAllocationCount();
}
internal class StackExchange.Redis.ResultBox`1 : ResultBox {
    private static ResultBox`1[] store;
    private object stateOrCompletionSource;
    private T value;
    public object AsyncState { get; }
    public ResultBox`1(object stateOrCompletionSource);
    private static ResultBox`1();
    public object get_AsyncState();
    public static ResultBox`1<T> Get(object stateOrCompletionSource);
    public static void UnwrapAndRecycle(ResultBox`1<T> box, bool recycle, T& value, Exception& exception);
    public void SetResult(T value);
    public virtual bool TryComplete(bool isAsync);
    private void Reset(object stateOrCompletionSource);
}
internal abstract class StackExchange.Redis.ResultProcessor : object {
    public static ResultProcessor`1<bool> Boolean;
    public static ResultProcessor`1<bool> DemandOK;
    public static ResultProcessor`1<bool> DemandPONG;
    public static ResultProcessor`1<bool> DemandZeroOrOne;
    public static ResultProcessor`1<bool> AutoConfigure;
    public static ResultProcessor`1<bool> TrackSubscriptions;
    public static ResultProcessor`1<bool> Tracer;
    public static ResultProcessor`1<bool> EstablishConnection;
    public static ResultProcessor`1<bool> BackgroundSaveStarted;
    public static ResultProcessor`1<Byte[]> ByteArray;
    public static ResultProcessor`1<Byte[]> ScriptLoad;
    public static ResultProcessor`1<ClusterConfiguration> ClusterNodes;
    public static ResultProcessor`1<EndPoint> ConnectionIdentity;
    public static ResultProcessor`1<DateTime> DateTime;
    public static ResultProcessor`1<double> Double;
    public static ResultProcessor`1<IGrouping`2[]> Info;
    public static ResultProcessor`1<long> Int64;
    public static ResultProcessor`1<long> PubSubNumSub;
    public static ResultProcessor`1<Nullable`1<double>> NullableDouble;
    public static ResultProcessor`1<Nullable`1<long>> NullableInt64;
    public static ResultProcessor`1<RedisChannel[]> RedisChannelArrayLiteral;
    public static ResultProcessor`1<RedisKey> RedisKey;
    public static ResultProcessor`1<RedisKey[]> RedisKeyArray;
    public static ResultProcessor`1<RedisType> RedisType;
    public static ResultProcessor`1<RedisValue> RedisValue;
    public static ResultProcessor`1<RedisValue[]> RedisValueArray;
    public static ResultProcessor`1<String[]> StringArray;
    public static ResultProcessor`1<Nullable`1[]> RedisGeoPositionArray;
    public static ResultProcessor`1<Nullable`1<GeoPosition>> RedisGeoPosition;
    public static ResultProcessor`1<TimeSpan> ResponseTimer;
    public static ResultProcessor`1<RedisResult> ScriptResult;
    public static SortedSetEntryArrayProcessor SortedSetWithScores;
    public static ResultProcessor`1<string> String;
    public static ResultProcessor`1<string> ClusterNodesRaw;
    public static ResultProcessor`1<EndPoint> SentinelMasterEndpoint;
    public static ResultProcessor`1<KeyValuePair`2[][]> SentinelArrayOfArrays;
    public static ResultProcessor`1<KeyValuePair`2[]> StringPairInterleaved;
    public static TimeSpanProcessor TimeSpanFromMilliseconds;
    public static TimeSpanProcessor TimeSpanFromSeconds;
    public static HashEntryArrayProcessor HashEntryArray;
    private static Byte[] MOVED;
    private static Byte[] ASK;
    private static ResultProcessor();
    public static ResultProcessor`1<GeoRadiusResult[]> GeoRadiusArray(GeoRadiusOptions options);
    public void ConnectionFail(Message message, ConnectionFailureType fail, Exception innerException);
    public void ConnectionFail(Message message, ConnectionFailureType fail, string errorMessage);
    public void ServerFail(Message message, string errorMessage);
    public void SetException(Message message, Exception ex);
    public virtual bool SetResult(PhysicalConnection connection, Message message, RawResult result);
    protected abstract virtual bool SetResultCore(PhysicalConnection connection, Message message, RawResult result);
    private void UnexpectedResponse(Message message, RawResult result);
}
internal abstract class StackExchange.Redis.ResultProcessor`1 : ResultProcessor {
    protected void SetResult(Message message, T value);
}
internal enum StackExchange.Redis.ResultType : Enum {
    public byte value__;
    public static ResultType None;
    public static ResultType SimpleString;
    public static ResultType Error;
    public static ResultType Integer;
    public static ResultType BulkString;
    public static ResultType MultiBulk;
}
public enum StackExchange.Redis.RetransmissionReasonType : Enum {
    public int value__;
    public static RetransmissionReasonType None;
    public static RetransmissionReasonType Ask;
    public static RetransmissionReasonType Moved;
}
public enum StackExchange.Redis.SaveType : Enum {
    public int value__;
    public static SaveType BackgroundRewriteAppendOnlyFile;
    public static SaveType BackgroundSave;
    [ObsoleteAttribute("Saving on the foreground can cause significant blocking; use with extreme caution")]
public static SaveType ForegroundSave;
}
internal class StackExchange.Redis.ScriptParameterMapper : object {
    private static Regex ParameterExtractor;
    private static MethodInfo RedisValue_FromInt;
    private static MethodInfo RedisValue_FromNullableInt;
    private static MethodInfo RedisValue_FromLong;
    private static MethodInfo RedisValue_FromNullableLong;
    private static MethodInfo RedisValue_FromDouble;
    private static MethodInfo RedisValue_FromNullableDouble;
    private static MethodInfo RedisValue_FromString;
    private static MethodInfo RedisValue_FromByteArray;
    private static MethodInfo RedisValue_FromBool;
    private static MethodInfo RedisValue_FromNullableBool;
    private static MethodInfo RedisKey_AsRedisValue;
    private static HashSet`1<Type> ConvertableTypes;
    private static ScriptParameterMapper();
    private static String[] ExtractParameters(string script);
    private static string MakeOrdinalScriptWithoutKeys(string rawScript, String[] args);
    private static void LoadMember(ILGenerator il, MemberInfo member);
    private static void ConvertToRedisValue(MemberInfo member, ILGenerator il, LocalBuilder needsPrefixBool, LocalBuilder& redisKeyLoc);
    public static LuaScript PrepareScript(string script);
    public static bool IsValidParameterHash(Type t, LuaScript script, String& missingMember, String& badTypeMember);
    private static void PrefixIfNeeded(ILGenerator il, LocalBuilder needsPrefixBool, LocalBuilder& redisKeyLoc);
    public static Func`3<object, Nullable`1<RedisKey>, ScriptParameters> GetParameterExtractor(Type t, LuaScript script);
}
public class StackExchange.Redis.ServerCounters : object {
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Interactive>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Subscription>k__BackingField;
    public EndPoint EndPoint { get; }
    public ConnectionCounters Interactive { get; }
    public ConnectionCounters Other { get; }
    public ConnectionCounters Subscription { get; }
    public long TotalOutstanding { get; }
    internal ServerCounters(EndPoint endpoint);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Interactive();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Other();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Subscription();
    public long get_TotalOutstanding();
    public virtual string ToString();
    internal void Add(ServerCounters other);
}
internal class StackExchange.Redis.ServerEndPoint : object {
    internal ServerEndPoint modreq(System.Runtime.CompilerServices.IsVolatile) Master;
    internal ServerEndPoint[] modreq(System.Runtime.CompilerServices.IsVolatile) Slaves;
    private static Regex nameSanitizer;
    private static ServerEndPoint[] NoSlaves;
    private EndPoint endpoint;
    private Hashtable knownScripts;
    private ConnectionMultiplexer multiplexer;
    private int databases;
    private int writeEverySeconds;
    private PhysicalBridge interactive;
    private PhysicalBridge subscription;
    private bool isDisposed;
    private ServerType serverType;
    private bool slaveReadOnly;
    private bool isSlave;
    private UnselectableFlags modreq(System.Runtime.CompilerServices.IsVolatile) unselectableReasons;
    private Version version;
    [CompilerGeneratedAttribute]
private ClusterConfiguration <ClusterConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSlaveWrites>k__BackingField;
    private int _nextReplicaOffset;
    private string runId;
    private EndPoint masterEndPoint;
    private int lastInfoReplicationCheckTicks;
    private int _heartBeatActive;
    public ClusterConfiguration ClusterConfiguration { get; private set; }
    public int Databases { get; public set; }
    public EndPoint EndPoint { get; }
    public bool HasDatabases { get; }
    public bool IsConnected { get; }
    internal Exception LastException { get; }
    internal State ConnectionState { get; }
    public bool IsSlave { get; public set; }
    public long OperationCount { get; }
    public bool RequiresReadMode { get; }
    public ServerType ServerType { get; public set; }
    public bool SlaveReadOnly { get; public set; }
    public bool AllowSlaveWrites { get; public set; }
    public Version Version { get; public set; }
    public int WriteEverySeconds { get; public set; }
    internal ConnectionMultiplexer Multiplexer { get; }
    internal string RunId { get; internal set; }
    internal int LastInfoReplicationCheckSecondsAgo { get; }
    public EndPoint MasterEndPoint { get; public set; }
    public ServerEndPoint(ConnectionMultiplexer multiplexer, EndPoint endpoint, TextWriter log);
    private static ServerEndPoint();
    internal void ResetNonConnected();
    [CompilerGeneratedAttribute]
public ClusterConfiguration get_ClusterConfiguration();
    [CompilerGeneratedAttribute]
private void set_ClusterConfiguration(ClusterConfiguration value);
    public int get_Databases();
    public void set_Databases(int value);
    public EndPoint get_EndPoint();
    public bool get_HasDatabases();
    public bool get_IsConnected();
    internal Exception get_LastException();
    internal State get_ConnectionState();
    public bool get_IsSlave();
    public void set_IsSlave(bool value);
    public long get_OperationCount();
    public bool get_RequiresReadMode();
    public ServerType get_ServerType();
    public void set_ServerType(ServerType value);
    public bool get_SlaveReadOnly();
    public void set_SlaveReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowSlaveWrites();
    [CompilerGeneratedAttribute]
public void set_AllowSlaveWrites(bool value);
    public Version get_Version();
    public void set_Version(Version value);
    public int get_WriteEverySeconds();
    public void set_WriteEverySeconds(int value);
    internal ConnectionMultiplexer get_Multiplexer();
    public void ClearUnselectable(UnselectableFlags flags);
    public sealed virtual void Dispose();
    public PhysicalBridge GetBridge(ConnectionType type, bool create, TextWriter log);
    public PhysicalBridge GetBridge(RedisCommand command, bool create);
    public RedisFeatures GetFeatures();
    public void SetClusterConfiguration(ClusterConfiguration configuration);
    public void SetUnselectable(UnselectableFlags flags);
    public virtual string ToString();
    public bool TryEnqueue(Message message);
    internal void Activate(ConnectionType type, TextWriter log);
    internal void AddScript(string script, Byte[] hash);
    internal void AutoConfigure(PhysicalConnection connection);
    internal UInt32 NextReplicaOffset();
    internal Task Close();
    internal void FlushScriptCache();
    internal string get_RunId();
    internal void set_RunId(string value);
    internal ServerCounters GetCounters();
    internal int GetOutstandingCount(RedisCommand command, Int32& inst, Int32& qu, Int32& qs, Int32& qc, Int32& wr, Int32& wq, Int32& in, Int32& ar);
    internal string GetProfile();
    internal Byte[] GetScriptHash(string script, RedisCommand command);
    internal string GetStormLog(RedisCommand command);
    internal Message GetTracerMessage(bool assertIdentity);
    internal bool IsSelectable(RedisCommand command);
    internal void OnEstablishing(PhysicalConnection connection, TextWriter log);
    internal void OnFullyEstablished(PhysicalConnection connection);
    internal int get_LastInfoReplicationCheckSecondsAgo();
    public EndPoint get_MasterEndPoint();
    public void set_MasterEndPoint(EndPoint value);
    internal bool CheckInfoReplication();
    internal void OnHeartbeat();
    internal Task`1<T> QueueDirectAsync(Message message, ResultProcessor`1<T> processor, object asyncState, PhysicalBridge bridge);
    internal void QueueDirectFireAndForget(Message message, ResultProcessor`1<T> processor, PhysicalBridge bridge);
    internal void ReportNextFailure();
    internal Task`1<bool> SendTracer(TextWriter log);
    internal string Summary();
    internal void WriteDirectOrQueueFireAndForget(PhysicalConnection connection, Message message, ResultProcessor`1<T> processor);
    private PhysicalBridge CreateBridge(ConnectionType type, TextWriter log);
    private void Handshake(PhysicalConnection connection, TextWriter log);
    private void SetConfig(T& field, T value, string caller);
    [CompilerGeneratedAttribute]
private bool <SetClusterConfiguration>b__66_0(ClusterNode x);
}
internal class StackExchange.Redis.ServerSelectionStrategy : object {
    public static int NoSlot;
    public static int MultipleSlots;
    private static int RedisClusterSlotCount;
    private static UInt16[] crc16tab;
    private ConnectionMultiplexer multiplexer;
    private int anyStartOffset;
    private ServerEndPoint[] map;
    private ServerType serverType;
    public ServerType ServerType { get; public set; }
    internal int TotalSlots { get; }
    public ServerSelectionStrategy(ConnectionMultiplexer multiplexer);
    private static ServerSelectionStrategy();
    public ServerType get_ServerType();
    public void set_ServerType(ServerType value);
    internal int get_TotalSlots();
    public int HashSlot(RedisKey key);
    public ServerEndPoint Select(Message message);
    public ServerEndPoint Select(int db, RedisCommand command, RedisKey key, CommandFlags flags);
    public bool TryResend(int hashSlot, Message message, EndPoint endpoint, bool isMoved);
    internal int CombineSlot(int oldSlot, int newSlot);
    internal int CombineSlot(int oldSlot, RedisKey key);
    internal int CountCoveredSlots();
    internal void UpdateClusterRange(int fromInclusive, int toInclusive, ServerEndPoint server);
    private static int IndexOf(Byte* ptr, byte value, int start, int end);
    private ServerEndPoint Any(RedisCommand command, CommandFlags flags);
    private ServerEndPoint FindMaster(ServerEndPoint endpoint, RedisCommand command);
    private ServerEndPoint FindSlave(ServerEndPoint endpoint, RedisCommand command);
    private ServerEndPoint[] MapForMutation();
    private ServerEndPoint Select(int slot, RedisCommand command, CommandFlags flags);
}
public enum StackExchange.Redis.ServerType : Enum {
    public int value__;
    public static ServerType Standalone;
    public static ServerType Sentinel;
    public static ServerType Cluster;
    public static ServerType Twemproxy;
}
public enum StackExchange.Redis.SetOperation : Enum {
    public int value__;
    public static SetOperation Union;
    public static SetOperation Intersect;
    public static SetOperation Difference;
}
public enum StackExchange.Redis.ShutdownMode : Enum {
    public int value__;
    public static ShutdownMode Default;
    public static ShutdownMode Never;
    public static ShutdownMode Always;
}
public class StackExchange.Redis.SlotRange : ValueType {
    private short from;
    private short to;
    public int From { get; }
    public int To { get; }
    public SlotRange(int from, int to);
    private SlotRange(short from, short to);
    public int get_From();
    public int get_To();
    public static bool op_Inequality(SlotRange x, SlotRange y);
    public static bool op_Equality(SlotRange x, SlotRange y);
    public static bool TryParse(string range, SlotRange& value);
    public sealed virtual int CompareTo(SlotRange other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SlotRange range);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool Includes(int hashSlot);
    private static bool TryParseInt16(string s, int offset, int count, Int16& value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
public class StackExchange.Redis.SocketManager : object {
    private static ParameterizedThreadStart writeAllQueues;
    private static WaitCallback writeOneQueue;
    private string name;
    private Queue`1<PhysicalBridge> writeQueue;
    private bool isDisposed;
    private bool useHighPrioritySocketThreads;
    internal static SocketMode DefaultSocketMode;
    public string Name { get; }
    public SocketManager(string name);
    public SocketManager(string name, bool useHighPrioritySocketThreads);
    private static SocketManager();
    public string get_Name();
    public sealed virtual void Dispose();
    internal SocketToken BeginConnect(EndPoint endpoint, ISocketCallback callback, ConnectionMultiplexer multiplexer, TextWriter log);
    internal void SetFastLoopbackOption(Socket socket);
    internal void RequestWrite(PhysicalBridge bridge, bool forced);
    internal void Shutdown(SocketToken token);
    private void EndConnectImpl(IAsyncResult ar, ConnectionMultiplexer multiplexer, TextWriter log, Tuple`2<Socket, ISocketCallback> tuple);
    private void Shutdown(Socket socket);
    private void WriteAllQueues();
    private void WriteOneQueue();
    private void OnAddRead(Socket socket, ISocketCallback callback);
}
internal enum StackExchange.Redis.SocketMode : Enum {
    public int value__;
    public static SocketMode Abort;
    public static SocketMode Poll;
    public static SocketMode Async;
}
internal class StackExchange.Redis.SocketToken : ValueType {
    internal Socket Socket;
    public int Available { get; }
    public bool HasValue { get; }
    public SocketToken(Socket socket);
    public int get_Available();
    public bool get_HasValue();
}
public class StackExchange.Redis.SortedSetEntry : ValueType {
    internal RedisValue element;
    internal double score;
    public RedisValue Element { get; }
    public double Score { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Score", "False")]
public double Value { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Element", "False")]
public RedisValue Key { get; }
    public SortedSetEntry(RedisValue element, double score);
    public RedisValue get_Element();
    public double get_Score();
    public double get_Value();
    public RedisValue get_Key();
    public static KeyValuePair`2<RedisValue, double> op_Implicit(SortedSetEntry value);
    public static SortedSetEntry op_Implicit(KeyValuePair`2<RedisValue, double> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortedSetEntry value);
    public sealed virtual int CompareTo(SortedSetEntry value);
    public sealed virtual int CompareTo(object value);
    public static bool op_Equality(SortedSetEntry x, SortedSetEntry y);
    public static bool op_Inequality(SortedSetEntry x, SortedSetEntry y);
}
public enum StackExchange.Redis.SortType : Enum {
    public int value__;
    public static SortType Numeric;
    public static SortType Alphabetic;
}
internal class StackExchange.Redis.StringSplits : object {
    public static Char[] Space;
    public static Char[] Comma;
    private static StringSplits();
}
[ExtensionAttribute]
internal static class StackExchange.Redis.TaskExtensions : object {
    private static Action`1<Task> observeErrors;
    private static TaskExtensions();
    [ExtensionAttribute]
private static void ObverveErrors(Task task);
    [ExtensionAttribute]
public static Task ObserveErrors(Task task);
    [ExtensionAttribute]
public static Task`1<T> ObserveErrors(Task`1<T> task);
    [ExtensionAttribute]
public static ConfiguredTaskAwaitable ForAwait(Task task);
    [ExtensionAttribute]
public static ConfiguredTaskAwaitable`1<T> ForAwait(Task`1<T> task);
}
internal static class StackExchange.Redis.TaskSource : object {
    public static Func`2<Task, bool> IsSyncSafe;
    private static TaskSource();
    public static TaskCompletionSource`1<T> Create(object asyncState);
    public static TaskCompletionSource`1<T> CreateDenyExecSync(object asyncState);
}
[FlagsAttribute]
internal enum StackExchange.Redis.UnselectableFlags : Enum {
    public int value__;
    public static UnselectableFlags None;
    public static UnselectableFlags RedundantMaster;
    public static UnselectableFlags DidNotRespond;
    public static UnselectableFlags ServerType;
}
internal static class StackExchange.Redis.VolatileWrapper : object {
    public static int Read(Int32& location);
    public static void Write(Int32& address, int value);
}
public enum StackExchange.Redis.When : Enum {
    public int value__;
    public static When Always;
    public static When Exists;
    public static When NotExists;
}
internal enum StackExchange.Redis.WriteResult : Enum {
    public int value__;
    public static WriteResult QueueEmptyAfterWrite;
    public static WriteResult NothingToDo;
    public static WriteResult MoreWork;
    public static WriteResult CompetingWriter;
    public static WriteResult NoConnection;
}
