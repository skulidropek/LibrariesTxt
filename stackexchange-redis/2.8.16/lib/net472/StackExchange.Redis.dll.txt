[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public enum StackExchange.Redis.Aggregate : Enum {
    public int value__;
    public static Aggregate Sum;
    public static Aggregate Min;
    public static Aggregate Max;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class StackExchange.Redis.ArrayResultProcessor`1 : ResultProcessor`1<T[]> {
    protected virtual bool SetResultCore(PhysicalConnection connection, Message message, RawResult& modreq(System.Runtime.InteropServices.InAttribute) result);
    protected abstract virtual bool TryParse(RawResult& modreq(System.Runtime.InteropServices.InAttribute) raw, T& parsed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.BacklogPolicy : object {
    [CompilerGeneratedAttribute]
private static BacklogPolicy <FailFast>k__BackingField;
    [CompilerGeneratedAttribute]
private static BacklogPolicy <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QueueWhileDisconnected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AbortPendingOnConnectionFailure>k__BackingField;
    public static BacklogPolicy FailFast { get; }
    public static BacklogPolicy Default { get; }
    public bool QueueWhileDisconnected { get; public set; }
    public bool AbortPendingOnConnectionFailure { get; public set; }
    private static BacklogPolicy();
    [CompilerGeneratedAttribute]
public static BacklogPolicy get_FailFast();
    [CompilerGeneratedAttribute]
public static BacklogPolicy get_Default();
    [CompilerGeneratedAttribute]
public bool get_QueueWhileDisconnected();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QueueWhileDisconnected(bool value);
    [CompilerGeneratedAttribute]
public bool get_AbortPendingOnConnectionFailure();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AbortPendingOnConnectionFailure(bool value);
}
public enum StackExchange.Redis.Bitwise : Enum {
    public int value__;
    public static Bitwise And;
    public static Bitwise Or;
    public static Bitwise Xor;
    public static Bitwise Not;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class StackExchange.Redis.BufferReader : ValueType {
    private long _totalConsumed;
    [CompilerGeneratedAttribute]
private int <OffsetThisSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingThisSpan>k__BackingField;
    private Enumerator<byte> _iterator;
    private ReadOnlySpan`1<byte> _current;
    private ReadOnlySequence`1<byte> _buffer;
    private SequencePosition _lastSnapshotPosition;
    private long _lastSnapshotBytes;
    public int OffsetThisSpan { get; private set; }
    public int RemainingThisSpan { get; private set; }
    public long TotalConsumed { get; }
    public ReadOnlySpan`1<byte> OversizedSpan { get; }
    public ReadOnlySpan`1<byte> SlicedSpan { get; }
    public bool IsEmpty { get; }
    public BufferReader(ReadOnlySequence`1& buffer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_OffsetThisSpan();
    [CompilerGeneratedAttribute]
private void set_OffsetThisSpan(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RemainingThisSpan();
    [CompilerGeneratedAttribute]
private void set_RemainingThisSpan(int value);
    public long get_TotalConsumed();
    public ReadOnlySpan`1<byte> get_OversizedSpan();
    public ReadOnlySpan`1<byte> get_SlicedSpan();
    public bool get_IsEmpty();
    private bool FetchNextSegment();
    public ConsumeResult TryConsumeCRLF();
    public bool TryConsume(int count);
    private SequencePosition SnapshotPosition();
    public ReadOnlySequence`1<byte> ConsumeAsBuffer(int count);
    public ReadOnlySequence`1<byte> ConsumeToEnd();
    public bool TryConsumeAsBuffer(int count, ReadOnlySequence`1& buffer);
    public void Consume(int count);
    internal static int FindNext(BufferReader reader, byte value);
    internal static int FindNextCrLf(BufferReader reader);
    public int ConsumeByte();
    public int PeekByte();
    public ReadOnlySequence`1<byte> SliceFromCurrent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.ChannelMessage : ValueType {
    private ChannelMessageQueue _queue;
    [CompilerGeneratedAttribute]
private RedisChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <Message>k__BackingField;
    public RedisChannel SubscriptionChannel { get; }
    public RedisChannel Channel { get; }
    public RedisValue Message { get; }
    internal ChannelMessage(ChannelMessageQueue queue, RedisChannel& channel, RedisValue& value);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public RedisChannel get_SubscriptionChannel();
    [CompilerGeneratedAttribute]
public RedisChannel get_Channel();
    [CompilerGeneratedAttribute]
public RedisValue get_Message();
    public static bool op_Equality(ChannelMessage left, ChannelMessage right);
    public static bool op_Inequality(ChannelMessage left, ChannelMessage right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ChannelMessageQueue : object {
    private Channel`1<ChannelMessage> _queue;
    [CompilerGeneratedAttribute]
private RedisChannel <Channel>k__BackingField;
    [NullableAttribute("2")]
private RedisSubscriber _parent;
    private static UnboundedChannelOptions s_ChannelOptions;
    [NullableAttribute("2")]
private Delegate _onMessageHandler;
    [NullableAttribute("2")]
private ChannelMessageQueue _next;
    public RedisChannel Channel { get; }
    public Task Completion { get; }
    internal ChannelMessageQueue(RedisChannel& redisChannel, RedisSubscriber parent);
    private static ChannelMessageQueue();
    [CompilerGeneratedAttribute]
public RedisChannel get_Channel();
    [NullableContextAttribute("2")]
public virtual string ToString();
    public Task get_Completion();
    private void Write(RedisChannel& channel, RedisValue& value);
    [NullableContextAttribute("0")]
public ValueTask`1<ChannelMessage> ReadAsync(CancellationToken cancellationToken);
    public bool TryRead(ChannelMessage& item);
    public bool TryGetCount(Int32& count);
    private void AssertOnMessage(Delegate handler);
    public void OnMessage(Action`1<ChannelMessage> handler);
    [AsyncStateMachineAttribute("StackExchange.Redis.ChannelMessageQueue/<OnMessageSyncImpl>d__17")]
private Task OnMessageSyncImpl();
    internal static void Combine(ChannelMessageQueue& head, ChannelMessageQueue queue);
    public void OnMessage(Func`2<ChannelMessage, Task> handler);
    internal static void Remove(ChannelMessageQueue& head, ChannelMessageQueue queue);
    [NullableContextAttribute("2")]
internal static int Count(ChannelMessageQueue& head);
    internal static void WriteAll(ChannelMessageQueue& head, RedisChannel& channel, RedisValue& message);
    [AsyncStateMachineAttribute("StackExchange.Redis.ChannelMessageQueue/<OnMessageAsyncImpl>d__24")]
private Task OnMessageAsyncImpl();
    [NullableContextAttribute("2")]
internal static void MarkAllCompleted(ChannelMessageQueue& head);
    [NullableContextAttribute("2")]
private void MarkCompleted(Exception error);
    [NullableContextAttribute("2")]
internal void UnsubscribeImpl(Exception error, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.ChannelMessageQueue/<UnsubscribeAsyncImpl>d__28")]
internal Task UnsubscribeAsyncImpl(Exception error, CommandFlags flags);
    public void Unsubscribe(CommandFlags flags);
    public Task UnsubscribeAsync(CommandFlags flags);
    [AsyncIteratorStateMachineAttribute("StackExchange.Redis.ChannelMessageQueue/<GetAsyncEnumerator>d__31")]
public sealed virtual IAsyncEnumerator`1<ChannelMessage> GetAsyncEnumerator(CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum StackExchange.Redis.ClientFlags : Enum {
    public long value__;
    public static ClientFlags None;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use ReplicaMonitor instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ClientFlags SlaveMonitor;
    public static ClientFlags ReplicaMonitor;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use Replica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ClientFlags Slave;
    public static ClientFlags Replica;
    public static ClientFlags Master;
    public static ClientFlags Transaction;
    public static ClientFlags Blocked;
    public static ClientFlags TransactionDoomed;
    public static ClientFlags Closing;
    public static ClientFlags Unblocked;
    public static ClientFlags CloseASAP;
    public static ClientFlags PubSubSubscriber;
    public static ClientFlags ReadOnlyCluster;
    public static ClientFlags UnixDomainSocket;
    public static ClientFlags KeysTracking;
    public static ClientFlags TrackingTargetInvalid;
    public static ClientFlags BroadcastTracking;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.ClientInfo : object {
    [NullableAttribute("1")]
internal static ResultProcessor`1<ClientInfo[]> Processor;
    [CompilerGeneratedAttribute]
private EndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AgeSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlagsRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PatternSubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransactionCommandLength>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryVersion>k__BackingField;
    public EndPoint Address { get; private set; }
    public int AgeSeconds { get; private set; }
    public int Database { get; private set; }
    public ClientFlags Flags { get; private set; }
    public string FlagsRaw { get; private set; }
    public string Host { get; }
    public int IdleSeconds { get; private set; }
    public string LastCommand { get; private set; }
    public string Name { get; private set; }
    public int PatternSubscriptionCount { get; private set; }
    public int Port { get; }
    public string Raw { get; private set; }
    public int SubscriptionCount { get; private set; }
    public int TransactionCommandLength { get; private set; }
    public long Id { get; private set; }
    public ClientType ClientType { get; }
    public string ProtocolVersion { get; private set; }
    public Nullable`1<RedisProtocol> Protocol { get; }
    public string LibraryName { get; private set; }
    public string LibraryVersion { get; private set; }
    private static ClientInfo();
    [CompilerGeneratedAttribute]
public EndPoint get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(EndPoint value);
    [CompilerGeneratedAttribute]
public int get_AgeSeconds();
    [CompilerGeneratedAttribute]
private void set_AgeSeconds(int value);
    [CompilerGeneratedAttribute]
public int get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(int value);
    [CompilerGeneratedAttribute]
public ClientFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ClientFlags value);
    [CompilerGeneratedAttribute]
public string get_FlagsRaw();
    [CompilerGeneratedAttribute]
private void set_FlagsRaw(string value);
    public string get_Host();
    [CompilerGeneratedAttribute]
public int get_IdleSeconds();
    [CompilerGeneratedAttribute]
private void set_IdleSeconds(int value);
    [CompilerGeneratedAttribute]
public string get_LastCommand();
    [CompilerGeneratedAttribute]
private void set_LastCommand(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_PatternSubscriptionCount();
    [CompilerGeneratedAttribute]
private void set_PatternSubscriptionCount(int value);
    public int get_Port();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [CompilerGeneratedAttribute]
private void set_Raw(string value);
    [CompilerGeneratedAttribute]
public int get_SubscriptionCount();
    [CompilerGeneratedAttribute]
private void set_SubscriptionCount(int value);
    [CompilerGeneratedAttribute]
public int get_TransactionCommandLength();
    [CompilerGeneratedAttribute]
private void set_TransactionCommandLength(int value);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public ClientType get_ClientType();
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(string value);
    public Nullable`1<RedisProtocol> get_Protocol();
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
private void set_LibraryName(string value);
    [CompilerGeneratedAttribute]
public string get_LibraryVersion();
    [CompilerGeneratedAttribute]
private void set_LibraryVersion(string value);
    internal static bool TryParse(string input, ClientInfo[]& clientList);
    [NullableContextAttribute("1")]
private static void AddFlag(ClientFlags& value, string raw, ClientFlags toAdd, char token);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.ClientKillFilter : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ClientType> <ClientType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <ServerEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SkipMe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxAgeInSeconds>k__BackingField;
    public Nullable`1<long> Id { get; private set; }
    public Nullable`1<ClientType> ClientType { get; private set; }
    public string Username { get; private set; }
    public EndPoint Endpoint { get; private set; }
    public EndPoint ServerEndpoint { get; private set; }
    public Nullable`1<bool> SkipMe { get; private set; }
    public Nullable`1<long> MaxAgeInSeconds { get; private set; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ClientType> get_ClientType();
    [CompilerGeneratedAttribute]
private void set_ClientType(Nullable`1<ClientType> value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
private void set_Username(string value);
    [CompilerGeneratedAttribute]
public EndPoint get_Endpoint();
    [CompilerGeneratedAttribute]
private void set_Endpoint(EndPoint value);
    [CompilerGeneratedAttribute]
public EndPoint get_ServerEndpoint();
    [CompilerGeneratedAttribute]
private void set_ServerEndpoint(EndPoint value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SkipMe();
    [CompilerGeneratedAttribute]
private void set_SkipMe(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxAgeInSeconds();
    [CompilerGeneratedAttribute]
private void set_MaxAgeInSeconds(Nullable`1<long> value);
    [NullableContextAttribute("1")]
public ClientKillFilter WithId(Nullable`1<long> id);
    [NullableContextAttribute("1")]
public ClientKillFilter WithClientType(Nullable`1<ClientType> clientType);
    [NullableContextAttribute("1")]
public ClientKillFilter WithUsername(string username);
    [NullableContextAttribute("1")]
public ClientKillFilter WithEndpoint(EndPoint endpoint);
    [NullableContextAttribute("1")]
public ClientKillFilter WithServerEndpoint(EndPoint serverEndpoint);
    [NullableContextAttribute("1")]
public ClientKillFilter WithSkipMe(Nullable`1<bool> skipMe);
    [NullableContextAttribute("1")]
public ClientKillFilter WithMaxAgeInSeconds(Nullable`1<long> maxAgeInSeconds);
    [NullableContextAttribute("1")]
internal List`1<RedisValue> ToList(bool withReplicaCommands);
}
public enum StackExchange.Redis.ClientType : Enum {
    public int value__;
    public static ClientType Normal;
    public static ClientType Replica;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use Replica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ClientType Slave;
    public static ClientType PubSub;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class StackExchange.Redis.ClusterConfiguration : object {
    private Dictionary`2<EndPoint, ClusterNode> nodeLookup;
    private ServerSelectionStrategy serverSelectionStrategy;
    [CompilerGeneratedAttribute]
private EndPoint <Origin>k__BackingField;
    public ICollection`1<ClusterNode> Nodes { get; }
    public EndPoint Origin { get; }
    [NullableAttribute("2")]
public ClusterNode Item { get; }
    [NullableAttribute("2")]
internal ClusterNode Item { get; }
    internal ClusterConfiguration(ServerSelectionStrategy serverSelectionStrategy, string nodes, EndPoint origin);
    public ICollection`1<ClusterNode> get_Nodes();
    [CompilerGeneratedAttribute]
public EndPoint get_Origin();
    public ClusterNode get_Item(EndPoint endpoint);
    internal ClusterNode get_Item(string nodeId);
    [NullableContextAttribute("2")]
public ClusterNode GetBySlot(int slot);
    [NullableContextAttribute("2")]
public ClusterNode GetBySlot(RedisKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ClusterNode : object {
    private ClusterConfiguration configuration;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ClusterNode> children;
    [NullableAttribute("2")]
private ClusterNode parent;
    [NullableAttribute("2")]
private string toString;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPossiblyFail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMyself>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReplica>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNoAddr>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ParentNodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SlotRange> <Slots>k__BackingField;
    public IList`1<ClusterNode> Children { get; }
    [NullableAttribute("2")]
public EndPoint EndPoint { get; }
    public bool IsFail { get; }
    public bool IsPossiblyFail { get; }
    public bool IsMyself { get; }
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use IsReplica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool IsSlave { get; }
    public bool IsReplica { get; }
    public bool IsNoAddr { get; }
    public bool IsConnected { get; }
    public string NodeId { get; }
    [NullableAttribute("2")]
public ClusterNode Parent { get; }
    [NullableAttribute("2")]
public string ParentNodeId { get; }
    public string Raw { get; }
    public IList`1<SlotRange> Slots { get; }
    internal ClusterNode(ClusterConfiguration configuration, string raw, EndPoint origin);
    public IList`1<ClusterNode> get_Children();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public bool get_IsFail();
    [CompilerGeneratedAttribute]
public bool get_IsPossiblyFail();
    [CompilerGeneratedAttribute]
public bool get_IsMyself();
    public bool get_IsSlave();
    [CompilerGeneratedAttribute]
public bool get_IsReplica();
    [CompilerGeneratedAttribute]
public bool get_IsNoAddr();
    [CompilerGeneratedAttribute]
public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public string get_NodeId();
    [NullableContextAttribute("2")]
public ClusterNode get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ParentNodeId();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [CompilerGeneratedAttribute]
public IList`1<SlotRange> get_Slots();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(ClusterNode other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ClusterNode other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool ServesSlot(int hashSlot);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class StackExchange.Redis.CommandBytes : ValueType {
    private ulong _0;
    private ulong _1;
    private ulong _2;
    private ulong _3;
    private static int ChunkLength;
    public static int MaxLength;
    [NullableAttribute("1")]
private static Encoding Encoding { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public byte Item { get; }
    [NullableContextAttribute("2")]
public CommandBytes(string value);
    public CommandBytes(ReadOnlySpan`1<byte> value);
    public CommandBytes(ReadOnlySequence`1& value);
    [NullableContextAttribute("1")]
private static Encoding get_Encoding();
    [NullableContextAttribute("1")]
internal static CommandBytes TrimToFit(string value);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<StackExchange.Redis.CommandBytes>.Equals(CommandBytes other);
    public bool Equals(CommandBytes& other);
    [NullableContextAttribute("1")]
public static CommandBytes op_Implicit(string value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public int get_Length();
    public bool get_IsEmpty();
    public void CopyTo(Span`1<byte> target);
    public byte get_Item(int index);
    private int UpperCasify(int len, Byte* bPtr);
    private static int UpperCasifyUnicode(int oldLen, Byte* bPtr);
    private static byte ToUpperInvariantAscii(byte b);
    [NullableContextAttribute("1")]
internal Byte[] ToArray();
}
[FlagsAttribute]
public enum StackExchange.Redis.CommandFlags : Enum {
    public int value__;
    public static CommandFlags None;
    [ObsoleteAttribute("From 2.0, this flag is not used, this will be removed in 3.0.", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static CommandFlags HighPriority;
    public static CommandFlags FireAndForget;
    public static CommandFlags PreferMaster;
    public static CommandFlags DemandMaster;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use PreferReplica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static CommandFlags PreferSlave;
    public static CommandFlags PreferReplica;
    public static CommandFlags DemandReplica;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use DemandReplica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static CommandFlags DemandSlave;
    public static CommandFlags NoRedirect;
    public static CommandFlags NoScriptCache;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.CommandMap : object {
    private CommandBytes[] map;
    [CompilerGeneratedAttribute]
private static CommandMap <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <Twemproxy>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <Envoyproxy>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <SSDB>k__BackingField;
    [CompilerGeneratedAttribute]
private static CommandMap <Sentinel>k__BackingField;
    public static CommandMap Default { get; }
    public static CommandMap Twemproxy { get; }
    public static CommandMap Envoyproxy { get; }
    public static CommandMap SSDB { get; }
    public static CommandMap Sentinel { get; }
    internal CommandMap(CommandBytes[] map);
    private static CommandMap();
    [CompilerGeneratedAttribute]
public static CommandMap get_Default();
    [CompilerGeneratedAttribute]
public static CommandMap get_Twemproxy();
    [CompilerGeneratedAttribute]
public static CommandMap get_Envoyproxy();
    [CompilerGeneratedAttribute]
public static CommandMap get_SSDB();
    [CompilerGeneratedAttribute]
public static CommandMap get_Sentinel();
    public static CommandMap Create(Dictionary`2<string, string> overrides);
    public static CommandMap Create(HashSet`1<string> commands, bool available);
    public virtual string ToString();
    internal void AppendDeltas(StringBuilder sb);
    internal void AssertAvailable(RedisCommand command);
    internal CommandBytes GetBytes(RedisCommand command);
    internal CommandBytes GetBytes(string command);
    internal bool IsAvailable(RedisCommand command);
    private static CommandMap CreateImpl(Dictionary`2<string, string> caseInsensitiveOverrides, HashSet`1<RedisCommand> exclusions);
}
public enum StackExchange.Redis.CommandStatus : Enum {
    public int value__;
    public static CommandStatus Unknown;
    public static CommandStatus WaitingToBeSent;
    public static CommandStatus Sent;
    public static CommandStatus WaitingInBacklog;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.CommandTrace : object {
    internal static ResultProcessor`1<CommandTrace[]> Processor;
    [CompilerGeneratedAttribute]
private RedisValue[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniqueId>k__BackingField;
    public RedisValue[] Arguments { get; }
    public TimeSpan Duration { get; }
    public DateTime Time { get; }
    public long UniqueId { get; }
    internal CommandTrace(long uniqueId, long time, long duration, RedisValue[] arguments);
    private static CommandTrace();
    [CompilerGeneratedAttribute]
public RedisValue[] get_Arguments();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
public long get_UniqueId();
    [NullableContextAttribute("2")]
public string GetHelpUrl();
}
internal static class StackExchange.Redis.CommonReplies : object {
    public static CommandBytes ASK;
    public static CommandBytes authFail_trimmed;
    public static CommandBytes backgroundSavingStarted_trimmed;
    public static CommandBytes backgroundSavingAOFStarted_trimmed;
    public static CommandBytes databases;
    public static CommandBytes loading;
    public static CommandBytes MOVED;
    public static CommandBytes NOAUTH;
    public static CommandBytes NOSCRIPT;
    public static CommandBytes no;
    public static CommandBytes OK;
    public static CommandBytes one;
    public static CommandBytes PONG;
    public static CommandBytes QUEUED;
    public static CommandBytes READONLY;
    public static CommandBytes replica_read_only;
    public static CommandBytes slave_read_only;
    public static CommandBytes timeout;
    public static CommandBytes wildcard;
    public static CommandBytes WRONGPASS;
    public static CommandBytes yes;
    public static CommandBytes zero;
    public static CommandBytes length;
    public static CommandBytes radixTreeKeys;
    public static CommandBytes radixTreeNodes;
    public static CommandBytes groups;
    public static CommandBytes lastGeneratedId;
    public static CommandBytes firstEntry;
    public static CommandBytes lastEntry;
    public static CommandBytes version;
    public static CommandBytes proto;
    public static CommandBytes role;
    public static CommandBytes mode;
    public static CommandBytes id;
    private static CommonReplies();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.CompletedTask`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Task`1<T> defaultTask;
    private static CompletedTask`1();
    public static Task`1<T> Default(object asyncState);
    public static Task`1<T> FromResult(T value, object asyncState);
    [NullableContextAttribute("1")]
public static Task`1<T> FromDefault(T value, object asyncState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class StackExchange.Redis.Condition : object {
    internal abstract virtual Condition MapKeys(Func`2<RedisKey, RedisKey> map);
    public static Condition HashEqual(RedisKey key, RedisValue hashField, RedisValue value);
    public static Condition HashExists(RedisKey key, RedisValue hashField);
    public static Condition HashNotEqual(RedisKey key, RedisValue hashField, RedisValue value);
    public static Condition HashNotExists(RedisKey key, RedisValue hashField);
    public static Condition KeyExists(RedisKey key);
    public static Condition KeyNotExists(RedisKey key);
    public static Condition ListIndexEqual(RedisKey key, long index, RedisValue value);
    public static Condition ListIndexExists(RedisKey key, long index);
    public static Condition ListIndexNotEqual(RedisKey key, long index, RedisValue value);
    public static Condition ListIndexNotExists(RedisKey key, long index);
    public static Condition StringEqual(RedisKey key, RedisValue value);
    public static Condition StringNotEqual(RedisKey key, RedisValue value);
    public static Condition HashLengthEqual(RedisKey key, long length);
    public static Condition HashLengthLessThan(RedisKey key, long length);
    public static Condition HashLengthGreaterThan(RedisKey key, long length);
    public static Condition StringLengthEqual(RedisKey key, long length);
    public static Condition StringLengthLessThan(RedisKey key, long length);
    public static Condition StringLengthGreaterThan(RedisKey key, long length);
    public static Condition ListLengthEqual(RedisKey key, long length);
    public static Condition ListLengthLessThan(RedisKey key, long length);
    public static Condition ListLengthGreaterThan(RedisKey key, long length);
    public static Condition SetLengthEqual(RedisKey key, long length);
    public static Condition SetLengthLessThan(RedisKey key, long length);
    public static Condition SetLengthGreaterThan(RedisKey key, long length);
    public static Condition SetContains(RedisKey key, RedisValue member);
    public static Condition SetNotContains(RedisKey key, RedisValue member);
    public static Condition SortedSetLengthEqual(RedisKey key, long length);
    public static Condition SortedSetLengthEqual(RedisKey key, long length, double min, double max);
    public static Condition SortedSetLengthLessThan(RedisKey key, long length);
    public static Condition SortedSetLengthLessThan(RedisKey key, long length, double min, double max);
    public static Condition SortedSetLengthGreaterThan(RedisKey key, long length);
    public static Condition SortedSetLengthGreaterThan(RedisKey key, long length, double min, double max);
    public static Condition SortedSetContains(RedisKey key, RedisValue member);
    public static Condition SortedSetNotContains(RedisKey key, RedisValue member);
    public static Condition SortedSetEqual(RedisKey key, RedisValue member, RedisValue score);
    public static Condition SortedSetNotEqual(RedisKey key, RedisValue member, RedisValue score);
    public static Condition SortedSetScoreExists(RedisKey key, RedisValue score);
    public static Condition SortedSetScoreNotExists(RedisKey key, RedisValue score);
    public static Condition SortedSetScoreExists(RedisKey key, RedisValue score, RedisValue count);
    public static Condition SortedSetScoreNotExists(RedisKey key, RedisValue score, RedisValue count);
    public static Condition StreamLengthEqual(RedisKey key, long length);
    public static Condition StreamLengthLessThan(RedisKey key, long length);
    public static Condition StreamLengthGreaterThan(RedisKey key, long length);
    internal abstract virtual void CheckCommands(CommandMap commandMap);
    internal abstract virtual IEnumerable`1<Message> CreateMessages(int db, IResultBox resultBox);
    internal abstract virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    internal abstract virtual bool TryValidate(RawResult& modreq(System.Runtime.InteropServices.InAttribute) result, Boolean& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ConditionResult : object {
    internal Condition Condition;
    [NullableAttribute("2")]
private IResultBox`1<bool> resultBox;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) wasSatisfied;
    public bool WasSatisfied { get; }
    internal ConditionResult(Condition condition);
    public bool get_WasSatisfied();
    internal IEnumerable`1<Message> CreateMessages(int db);
    [NullableContextAttribute("2")]
internal IResultBox`1<bool> GetBox();
    internal bool UnwrapBox();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.Configuration.AzureOptionsProvider : DefaultOptionsProvider {
    private static String[] azureRedisDomains;
    public bool AbortOnConnectFail { get; }
    public Version DefaultVersion { get; }
    private static AzureOptionsProvider();
    public virtual bool get_AbortOnConnectFail();
    public virtual Version get_DefaultVersion();
    public virtual bool IsMatch(EndPoint endpoint);
    public virtual Task AfterConnectAsync(ConnectionMultiplexer muxer, Action`1<string> log);
    public virtual bool GetDefaultSsl(EndPointCollection endPoints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.Configuration.DefaultOptionsProvider : object {
    private static List`1<DefaultOptionsProvider> BuiltInProviders;
    [CompilerGeneratedAttribute]
private static LinkedList`1<DefaultOptionsProvider> <KnownProviders>k__BackingField;
    [NullableAttribute("2")]
private string defaultClientName;
    private static LinkedList`1<DefaultOptionsProvider> KnownProviders { get; private set; }
    public bool AbortOnConnectFail { get; }
    public bool AllowAdmin { get; }
    public BacklogPolicy BacklogPolicy { get; }
    public bool CheckCertificateRevocation { get; }
    public bool HighIntegrity { get; }
    public int ConnectRetry { get; }
    public Nullable`1<TimeSpan> ConnectTimeout { get; }
    [NullableAttribute("2")]
public CommandMap CommandMap { get; }
    public string ConfigurationChannel { get; }
    public Version DefaultVersion { get; }
    public TimeSpan HeartbeatInterval { get; }
    public bool HeartbeatConsistencyChecks { get; }
    public bool IncludeDetailInExceptions { get; }
    public bool IncludePerformanceCountersInExceptions { get; }
    public TimeSpan KeepAliveInterval { get; }
    [NullableAttribute("2")]
public ILoggerFactory LoggerFactory { get; }
    public Proxy Proxy { get; }
    [NullableAttribute("2")]
public IReconnectRetryPolicy ReconnectRetryPolicy { get; }
    public bool ResolveDns { get; }
    public TimeSpan SyncTimeout { get; }
    public string TieBreaker { get; }
    public TimeSpan ConfigCheckInterval { get; }
    [NullableAttribute("2")]
public string User { get; }
    [NullableAttribute("2")]
public string Password { get; }
    public string ClientName { get; }
    public string LibraryName { get; }
    protected static string LibraryVersion { get; }
    protected static string ComputerName { get; }
    public bool SetClientLibrary { get; }
    private static DefaultOptionsProvider();
    [CompilerGeneratedAttribute]
private static LinkedList`1<DefaultOptionsProvider> get_KnownProviders();
    [CompilerGeneratedAttribute]
private static void set_KnownProviders(LinkedList`1<DefaultOptionsProvider> value);
    public static void AddProvider(DefaultOptionsProvider provider);
    public virtual bool IsMatch(EndPoint endpoint);
    public static DefaultOptionsProvider GetProvider(EndPointCollection endpoints);
    public static DefaultOptionsProvider GetProvider(EndPoint endpoint);
    public virtual bool get_AbortOnConnectFail();
    public virtual bool get_AllowAdmin();
    public virtual BacklogPolicy get_BacklogPolicy();
    public virtual bool get_CheckCertificateRevocation();
    public virtual bool get_HighIntegrity();
    public virtual int get_ConnectRetry();
    public virtual Nullable`1<TimeSpan> get_ConnectTimeout();
    [NullableContextAttribute("2")]
public virtual CommandMap get_CommandMap();
    public virtual string get_ConfigurationChannel();
    public virtual Version get_DefaultVersion();
    public virtual TimeSpan get_HeartbeatInterval();
    public virtual bool get_HeartbeatConsistencyChecks();
    public virtual bool get_IncludeDetailInExceptions();
    public virtual bool get_IncludePerformanceCountersInExceptions();
    public virtual TimeSpan get_KeepAliveInterval();
    [NullableContextAttribute("2")]
public virtual ILoggerFactory get_LoggerFactory();
    public virtual Proxy get_Proxy();
    [NullableContextAttribute("2")]
public virtual IReconnectRetryPolicy get_ReconnectRetryPolicy();
    public virtual bool get_ResolveDns();
    public virtual TimeSpan get_SyncTimeout();
    public virtual string get_TieBreaker();
    public virtual TimeSpan get_ConfigCheckInterval();
    [NullableContextAttribute("2")]
public virtual string get_User();
    [NullableContextAttribute("2")]
public virtual string get_Password();
    public string get_ClientName();
    protected virtual string GetDefaultClientName();
    public virtual string get_LibraryName();
    protected static string get_LibraryVersion();
    protected static string get_ComputerName();
    public virtual bool get_SetClientLibrary();
    [NullableContextAttribute("2")]
internal static string TryGetAzureRoleInstanceIdNoThrow();
    public virtual Task AfterConnectAsync(ConnectionMultiplexer multiplexer, Action`1<string> log);
    public virtual bool GetDefaultSsl(EndPointCollection endPoints);
    public virtual string GetSslHostFromEndpoints(EndPointCollection endPoints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This API is experimental, has security and performance implications, and may change without notice", "False")]
public abstract class StackExchange.Redis.Configuration.LoggingTunnel : Tunnel {
    private ConfigurationOptions _options;
    private bool _ssl;
    [NullableAttribute("2")]
private Tunnel _tail;
    private static CommandBytes message;
    private static CommandBytes pmessage;
    private static CommandBytes smessage;
    [NullableContextAttribute("2")]
protected LoggingTunnel(ConfigurationOptions options, Tunnel tail);
    private static LoggingTunnel();
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<ReplayAsync>d__3")]
public static Task`1<long> ReplayAsync(Stream out, Stream in, Action`2<RedisResult, RedisResult> pair);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<ReplayAsync>d__4")]
public static Task`1<long> ReplayAsync(string path, Action`2<RedisResult, RedisResult> pair);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<ReadOneAsync>d__5")]
private static ValueTask`1<ContextualRedisResult> ReadOneAsync(PipeReader input, Arena`1<RawResult> arena, bool isInbound);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<ValidateAsync>d__6")]
public static Task`1<long> ValidateAsync(string path);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<ValidateAsync>d__7")]
public static Task`1<long> ValidateAsync(Stream stream);
    [NullableContextAttribute("0")]
private static void ProcessBuffer(Arena`1<RawResult> arena, ReadOnlySequence`1& buffer, Int64& position, Int32& messageCount);
    [NullableContextAttribute("0")]
private static ContextualRedisResult ProcessBuffer(Arena`1<RawResult> arena, ReadOnlySequence`1& buffer, bool isInbound);
    public static void LogToDirectory(ConfigurationOptions options, string path);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<BeforeAuthenticateAsync>d__17")]
public virtual ValueTask`1<Stream> BeforeAuthenticateAsync(EndPoint endpoint, ConnectionType connectionType, Socket socket, CancellationToken cancellationToken);
    protected abstract virtual Stream Log(Stream stream, EndPoint endpoint, ConnectionType connectionType);
    public virtual ValueTask BeforeSocketConnectAsync(EndPoint endPoint, ConnectionType connectionType, Socket socket, CancellationToken cancellationToken);
    public virtual ValueTask`1<EndPoint> GetSocketConnectEndpointAsync(EndPoint endpoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("StackExchange.Redis.Configuration.LoggingTunnel/<TlsHandshakeAsync>d__21")]
private Task`1<Stream> TlsHandshakeAsync(Stream stream, EndPoint endpoint);
    public static string DefaultFormatCommand(RedisResult value);
    public static string DefaultFormatResponse(RedisResult value);
    [CompilerGeneratedAttribute]
internal static bool <ProcessBuffer>g__IsArrayOutOfBand|10_0(RawResult& result);
    [CompilerGeneratedAttribute]
internal static bool <DefaultFormatCommand>g__IsSimple|22_0(RedisResult value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class StackExchange.Redis.Configuration.Tunnel : object {
    internal bool IsInbuilt { get; }
    public virtual ValueTask`1<EndPoint> GetSocketConnectEndpointAsync(EndPoint endpoint, CancellationToken cancellationToken);
    internal virtual bool get_IsInbuilt();
    public virtual ValueTask BeforeSocketConnectAsync(EndPoint endPoint, ConnectionType connectionType, Socket socket, CancellationToken cancellationToken);
    public virtual ValueTask`1<Stream> BeforeAuthenticateAsync(EndPoint endpoint, ConnectionType connectionType, Socket socket, CancellationToken cancellationToken);
    public static Tunnel HttpProxy(EndPoint proxy);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.ConfigurationOptions : object {
    private DefaultOptionsProvider defaultOptions;
    private Nullable`1<bool> allowAdmin;
    private Nullable`1<bool> abortOnConnectFail;
    private Nullable`1<bool> resolveDns;
    private Nullable`1<bool> ssl;
    private Nullable`1<bool> checkCertificateRevocation;
    private Nullable`1<bool> heartbeatConsistencyChecks;
    private Nullable`1<bool> includeDetailInExceptions;
    private Nullable`1<bool> includePerformanceCountersInExceptions;
    private Nullable`1<bool> setClientLibrary;
    private Nullable`1<bool> highIntegrity;
    private string tieBreaker;
    private string sslHost;
    private string configChannel;
    private string user;
    private string password;
    private Nullable`1<TimeSpan> heartbeatInterval;
    private CommandMap commandMap;
    private Version defaultVersion;
    private Nullable`1<int> keepAlive;
    private Nullable`1<int> asyncTimeout;
    private Nullable`1<int> syncTimeout;
    private Nullable`1<int> connectTimeout;
    private Nullable`1<int> responseTimeout;
    private Nullable`1<int> connectRetry;
    private Nullable`1<int> configCheckSeconds;
    private Nullable`1<Proxy> proxy;
    private IReconnectRetryPolicy reconnectRetryPolicy;
    private BacklogPolicy backlogPolicy;
    private ILoggerFactory loggerFactory;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback CertificateSelection;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback CertificateValidation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`3<EndPoint, ConnectionType, Socket> <BeforeSocketConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisChannel <ChannelPrefix>k__BackingField;
    [NullableAttribute("1")]
private static Oid _serverAuthOid;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DefaultDatabase>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private EndPointCollection <EndPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketManager <SocketManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SslProtocols> <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private Tunnel <Tunnel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RedisProtocol> <Protocol>k__BackingField;
    [NullableAttribute("1")]
public DefaultOptionsProvider Defaults { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`3<EndPoint, ConnectionType, Socket> BeforeSocketConnect { get; public set; }
    [NullableAttribute("1")]
internal Func`3<ConnectionMultiplexer, Action`1<string>, Task> AfterConnectAsync { get; }
    public bool AbortOnConnectFail { get; public set; }
    public bool AllowAdmin { get; public set; }
    public int AsyncTimeout { get; public set; }
    [ObsoleteAttribute("Please use .Ssl instead of .UseSsl, will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool UseSsl { get; public set; }
    public bool SetClientLibrary { get; public set; }
    public string LibraryName { get; public set; }
    public RedisChannel ChannelPrefix { get; public set; }
    public bool CheckCertificateRevocation { get; public set; }
    public bool HighIntegrity { get; public set; }
    public string ClientName { get; public set; }
    public int ConnectRetry { get; public set; }
    [NullableAttribute("1")]
public CommandMap CommandMap { get; public set; }
    [NullableAttribute("1")]
public string ConfigurationChannel { get; public set; }
    public int ConnectTimeout { get; public set; }
    public Nullable`1<int> DefaultDatabase { get; public set; }
    [NullableAttribute("1")]
public Version DefaultVersion { get; public set; }
    [NullableAttribute("1")]
public EndPointCollection EndPoints { get; public set; }
    public bool HeartbeatConsistencyChecks { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    [ObsoleteAttribute("This setting no longer has any effect, please use SocketManagerOptions.UseHighPrioritySocketThreads instead - this setting will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool HighPrioritySocketThreads { get; public set; }
    public bool IncludeDetailInExceptions { get; public set; }
    public bool IncludePerformanceCountersInExceptions { get; public set; }
    public int KeepAlive { get; public set; }
    public ILoggerFactory LoggerFactory { get; public set; }
    public string User { get; public set; }
    public string Password { get; public set; }
    [ObsoleteAttribute("Not supported; if you require ordered pub/sub, please see ChannelMessageQueue - this will be removed in 3.0.", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool PreserveAsyncOrder { get; public set; }
    public Proxy Proxy { get; public set; }
    [NullableAttribute("1")]
public IReconnectRetryPolicy ReconnectRetryPolicy { get; public set; }
    [NullableAttribute("1")]
public BacklogPolicy BacklogPolicy { get; public set; }
    public bool ResolveDns { get; public set; }
    [ObsoleteAttribute("This setting no longer has any effect, and should not be used - will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public int ResponseTimeout { get; public set; }
    public string ServiceName { get; public set; }
    public SocketManager SocketManager { get; public set; }
    public bool Ssl { get; public set; }
    public string SslHost { get; public set; }
    public Nullable`1<SslProtocols> SslProtocols { get; public set; }
    public int SyncTimeout { get; public set; }
    [NullableAttribute("1")]
public string TieBreaker { get; public set; }
    [ObsoleteAttribute("This setting no longer has any effect, and should not be used - will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public int WriteBuffer { get; public set; }
    internal LocalCertificateSelectionCallback CertificateSelectionCallback { get; private set; }
    internal RemoteCertificateValidationCallback CertificateValidationCallback { get; private set; }
    public int ConfigCheckSeconds { get; public set; }
    internal bool IsSentinel { get; }
    public Tunnel Tunnel { get; public set; }
    public Nullable`1<RedisProtocol> Protocol { get; public set; }
    private static ConfigurationOptions();
    [CompilerGeneratedAttribute]
public void add_CertificateSelection(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public void remove_CertificateSelection(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public void add_CertificateValidation(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public void remove_CertificateValidation(RemoteCertificateValidationCallback value);
    [NullableContextAttribute("1")]
public DefaultOptionsProvider get_Defaults();
    [NullableContextAttribute("1")]
public void set_Defaults(DefaultOptionsProvider value);
    [CompilerGeneratedAttribute]
public Action`3<EndPoint, ConnectionType, Socket> get_BeforeSocketConnect();
    [CompilerGeneratedAttribute]
public void set_BeforeSocketConnect(Action`3<EndPoint, ConnectionType, Socket> value);
    [NullableContextAttribute("1")]
internal Func`3<ConnectionMultiplexer, Action`1<string>, Task> get_AfterConnectAsync();
    public bool get_AbortOnConnectFail();
    public void set_AbortOnConnectFail(bool value);
    public bool get_AllowAdmin();
    public void set_AllowAdmin(bool value);
    public int get_AsyncTimeout();
    public void set_AsyncTimeout(int value);
    public bool get_UseSsl();
    public void set_UseSsl(bool value);
    public bool get_SetClientLibrary();
    public void set_SetClientLibrary(bool value);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public void set_LibraryName(string value);
    [CompilerGeneratedAttribute]
public RedisChannel get_ChannelPrefix();
    [CompilerGeneratedAttribute]
public void set_ChannelPrefix(RedisChannel value);
    public bool get_CheckCertificateRevocation();
    public void set_CheckCertificateRevocation(bool value);
    public bool get_HighIntegrity();
    public void set_HighIntegrity(bool value);
    [NullableContextAttribute("1")]
public void TrustIssuer(string issuerCertificatePath);
    [NullableContextAttribute("1")]
public void TrustIssuer(X509Certificate2 issuer);
    [NullableContextAttribute("1")]
internal static RemoteCertificateValidationCallback TrustIssuerCallback(string issuerCertificatePath);
    [NullableContextAttribute("1")]
private static RemoteCertificateValidationCallback TrustIssuerCallback(X509Certificate2 issuer);
    [NullableContextAttribute("1")]
private static bool CheckTrustedIssuer(X509Certificate2 certificateToValidate, X509Chain chainToValidate, X509Certificate2 authority);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    public int get_ConnectRetry();
    public void set_ConnectRetry(int value);
    [NullableContextAttribute("1")]
public CommandMap get_CommandMap();
    [NullableContextAttribute("1")]
public void set_CommandMap(CommandMap value);
    [NullableContextAttribute("1")]
internal CommandMap GetCommandMap(Nullable`1<ServerType> serverType);
    [NullableContextAttribute("1")]
public string get_ConfigurationChannel();
    [NullableContextAttribute("1")]
public void set_ConfigurationChannel(string value);
    public int get_ConnectTimeout();
    public void set_ConnectTimeout(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DefaultDatabase();
    [CompilerGeneratedAttribute]
public void set_DefaultDatabase(Nullable`1<int> value);
    [NullableContextAttribute("1")]
public Version get_DefaultVersion();
    [NullableContextAttribute("1")]
public void set_DefaultVersion(Version value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public EndPointCollection get_EndPoints();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndPoints(EndPointCollection value);
    public bool get_HeartbeatConsistencyChecks();
    public void set_HeartbeatConsistencyChecks(bool value);
    public TimeSpan get_HeartbeatInterval();
    public void set_HeartbeatInterval(TimeSpan value);
    public bool get_HighPrioritySocketThreads();
    public void set_HighPrioritySocketThreads(bool value);
    public bool get_IncludeDetailInExceptions();
    public void set_IncludeDetailInExceptions(bool value);
    public bool get_IncludePerformanceCountersInExceptions();
    public void set_IncludePerformanceCountersInExceptions(bool value);
    public int get_KeepAlive();
    public void set_KeepAlive(int value);
    public ILoggerFactory get_LoggerFactory();
    public void set_LoggerFactory(ILoggerFactory value);
    public string get_User();
    public void set_User(string value);
    public string get_Password();
    public void set_Password(string value);
    public bool get_PreserveAsyncOrder();
    public void set_PreserveAsyncOrder(bool value);
    public Proxy get_Proxy();
    public void set_Proxy(Proxy value);
    [NullableContextAttribute("1")]
public IReconnectRetryPolicy get_ReconnectRetryPolicy();
    [NullableContextAttribute("1")]
public void set_ReconnectRetryPolicy(IReconnectRetryPolicy value);
    [NullableContextAttribute("1")]
public BacklogPolicy get_BacklogPolicy();
    [NullableContextAttribute("1")]
public void set_BacklogPolicy(BacklogPolicy value);
    public bool get_ResolveDns();
    public void set_ResolveDns(bool value);
    public int get_ResponseTimeout();
    public void set_ResponseTimeout(int value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public SocketManager get_SocketManager();
    [CompilerGeneratedAttribute]
public void set_SocketManager(SocketManager value);
    public bool get_Ssl();
    public void set_Ssl(bool value);
    public string get_SslHost();
    public void set_SslHost(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SslProtocols> get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(Nullable`1<SslProtocols> value);
    public int get_SyncTimeout();
    public void set_SyncTimeout(int value);
    [NullableContextAttribute("1")]
public string get_TieBreaker();
    [NullableContextAttribute("1")]
public void set_TieBreaker(string value);
    public int get_WriteBuffer();
    public void set_WriteBuffer(int value);
    internal LocalCertificateSelectionCallback get_CertificateSelectionCallback();
    private void set_CertificateSelectionCallback(LocalCertificateSelectionCallback value);
    internal RemoteCertificateValidationCallback get_CertificateValidationCallback();
    private void set_CertificateValidationCallback(RemoteCertificateValidationCallback value);
    public int get_ConfigCheckSeconds();
    public void set_ConfigCheckSeconds(int value);
    [NullableContextAttribute("1")]
public static ConfigurationOptions Parse(string configuration);
    [NullableContextAttribute("1")]
public static ConfigurationOptions Parse(string configuration, bool ignoreUnknown);
    [NullableContextAttribute("1")]
public ConfigurationOptions Clone();
    [NullableContextAttribute("1")]
public ConfigurationOptions Apply(Action`1<ConfigurationOptions> configure);
    public void SetDefaultPorts();
    internal bool get_IsSentinel();
    internal bool TryGetTieBreaker(RedisKey& tieBreaker);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(bool includePassword);
    [NullableContextAttribute("1")]
private static void Append(StringBuilder sb, object value);
    [NullableContextAttribute("1")]
private static void Append(StringBuilder sb, string prefix, object value);
    private void Clear();
    [NullableContextAttribute("1")]
private sealed virtual override object System.ICloneable.Clone();
    [NullableContextAttribute("1")]
private ConfigurationOptions DoParse(string configuration, bool ignoreUnknown);
    [CompilerGeneratedAttribute]
public Tunnel get_Tunnel();
    [CompilerGeneratedAttribute]
public void set_Tunnel(Tunnel value);
    [CompilerGeneratedAttribute]
public Nullable`1<RedisProtocol> get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(Nullable`1<RedisProtocol> value);
    internal bool TryResp3();
    internal static bool TryParseRedisProtocol(string value, RedisProtocol& protocol);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__FormatProtocol|199_0(Nullable`1<RedisProtocol> protocol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ConnectionCounters : object {
    [CompilerGeneratedAttribute]
private long <CompletedAsynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompletedSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FailedAsynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NonPreferredEndpointCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PendingUnsentItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponsesAwaitingAsyncCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SentItemsAwaitingResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SocketCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriterCount>k__BackingField;
    public long CompletedAsynchronously { get; internal set; }
    public long CompletedSynchronously { get; internal set; }
    public ConnectionType ConnectionType { get; }
    public long FailedAsynchronously { get; internal set; }
    public bool IsEmpty { get; }
    public long NonPreferredEndpointCount { get; internal set; }
    public long OperationCount { get; internal set; }
    public int PendingUnsentItems { get; internal set; }
    public int ResponsesAwaitingAsyncCompletion { get; internal set; }
    public int SentItemsAwaitingResponse { get; internal set; }
    public long SocketCount { get; internal set; }
    public long Subscriptions { get; internal set; }
    public int TotalOutstanding { get; }
    public int WriterCount { get; internal set; }
    internal ConnectionCounters(ConnectionType connectionType);
    [CompilerGeneratedAttribute]
public long get_CompletedAsynchronously();
    [CompilerGeneratedAttribute]
internal void set_CompletedAsynchronously(long value);
    [CompilerGeneratedAttribute]
public long get_CompletedSynchronously();
    [CompilerGeneratedAttribute]
internal void set_CompletedSynchronously(long value);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [CompilerGeneratedAttribute]
public long get_FailedAsynchronously();
    [CompilerGeneratedAttribute]
internal void set_FailedAsynchronously(long value);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public long get_NonPreferredEndpointCount();
    [CompilerGeneratedAttribute]
internal void set_NonPreferredEndpointCount(long value);
    [CompilerGeneratedAttribute]
public long get_OperationCount();
    [CompilerGeneratedAttribute]
internal void set_OperationCount(long value);
    [CompilerGeneratedAttribute]
public int get_PendingUnsentItems();
    [CompilerGeneratedAttribute]
internal void set_PendingUnsentItems(int value);
    [CompilerGeneratedAttribute]
public int get_ResponsesAwaitingAsyncCompletion();
    [CompilerGeneratedAttribute]
internal void set_ResponsesAwaitingAsyncCompletion(int value);
    [CompilerGeneratedAttribute]
public int get_SentItemsAwaitingResponse();
    [CompilerGeneratedAttribute]
internal void set_SentItemsAwaitingResponse(int value);
    [CompilerGeneratedAttribute]
public long get_SocketCount();
    [CompilerGeneratedAttribute]
internal void set_SocketCount(long value);
    [CompilerGeneratedAttribute]
public long get_Subscriptions();
    [CompilerGeneratedAttribute]
internal void set_Subscriptions(long value);
    public int get_TotalOutstanding();
    [CompilerGeneratedAttribute]
public int get_WriterCount();
    [CompilerGeneratedAttribute]
internal void set_WriterCount(int value);
    public virtual string ToString();
    internal void Add(ConnectionCounters other);
    internal bool Any();
    internal void Append(StringBuilder sb);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.ConnectionFailedEventArgs : EventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<ConnectionFailedEventArgs> handler;
    [NullableAttribute("1")]
private object sender;
    [NullableAttribute("1")]
private string _physicalName;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionFailureType <FailureType>k__BackingField;
    public ConnectionType ConnectionType { get; }
    public EndPoint EndPoint { get; }
    public Exception Exception { get; }
    public ConnectionFailureType FailureType { get; }
    internal ConnectionFailedEventArgs(EventHandler`1<ConnectionFailedEventArgs> handler, object sender, EndPoint endPoint, ConnectionType connectionType, ConnectionFailureType failureType, Exception exception, string physicalName);
    [NullableContextAttribute("1")]
public ConnectionFailedEventArgs(object sender, EndPoint endPoint, ConnectionType connectionType, ConnectionFailureType failureType, Exception exception, string physicalName);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public ConnectionFailureType get_FailureType();
    [NullableContextAttribute("1")]
private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum StackExchange.Redis.ConnectionFailureType : Enum {
    public int value__;
    public static ConnectionFailureType None;
    public static ConnectionFailureType UnableToResolvePhysicalConnection;
    public static ConnectionFailureType SocketFailure;
    public static ConnectionFailureType AuthenticationFailure;
    public static ConnectionFailureType ProtocolFailure;
    public static ConnectionFailureType InternalFailure;
    public static ConnectionFailureType SocketClosed;
    public static ConnectionFailureType ConnectionDisposed;
    public static ConnectionFailureType Loading;
    public static ConnectionFailureType UnableToConnect;
    public static ConnectionFailureType ResponseIntegrityFailure;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ConnectionMultiplexer : object {
    [NullableAttribute("2")]
internal Byte[] ConfigurationChangedChannel;
    internal Byte[] UniqueId;
    internal int _connectAttemptCount;
    internal int _connectCompletedCount;
    internal int _connectionCloseCount;
    internal long syncOps;
    internal long asyncOps;
    private long syncTimeouts;
    private long fireAndForgets;
    private long asyncTimeouts;
    [NullableAttribute("2")]
private string failureMessage;
    [NullableAttribute("2")]
private string activeConfigCause;
    [NullableAttribute("2")]
private TimerToken pulse;
    private Hashtable servers;
    private ServerSnapshot modreq(System.Runtime.CompilerServices.IsVolatile) _serverSnapshot;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ILogger`1<ConnectionMultiplexer> <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandMap <CommandMap>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPointCollection <EndPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationOptions <RawConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerSelectionStrategy <ServerSelectionStrategy>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    private int lastReconfigiureTicks;
    private int _activeHeartbeatErrors;
    private int lastHeartbeatTicks;
    private static int lastGlobalHeartbeatTicks;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <AuthException>k__BackingField;
    private static int MaxCachedDatabaseInstance;
    [NullableAttribute("2")]
private IDatabase dbCacheZero;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDatabase[] dbCacheLow;
    private static int _collectedWithoutDispose;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) AllowConnect;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IgnoreConnect;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ConnectionFailedEventArgs> ConnectionFailed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<InternalErrorEventArgs> InternalError;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ConnectionFailedEventArgs> ConnectionRestored;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<EndPointEventArgs> ConfigurationChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<EndPointEventArgs> ConfigurationChangedBroadcast;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ServerMaintenanceEvent> ServerMaintenanceEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<HashSlotMovedEventArgs> HashSlotMoved;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<RedisErrorEventArgs> ErrorMessage;
    private static string NoContent;
    private static FeatureFlags s_featureFlags;
    private HashSet`1<string> _libraryNameSuffixHash;
    private string _libraryNameSuffixCombined;
    [NullableAttribute("2")]
private Func`1<ProfilingSession> _profilingSessionProvider;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SocketManager <SocketManager>k__BackingField;
    [NullableAttribute("2")]
internal EndPoint currentSentinelPrimaryEndPoint;
    [NullableAttribute("2")]
internal Timer sentinelPrimaryReconnectTimer;
    internal Dictionary`2<string, ConnectionMultiplexer> sentinelConnectionChildren;
    [NullableAttribute("2")]
internal ConnectionMultiplexer sentinelConnection;
    internal int haveStormLog;
    [NullableAttribute("2")]
internal string stormLogSnapshot;
    [CompilerGeneratedAttribute]
private int <StormLogThreshold>k__BackingField;
    private static WaitCallback s_CompleteAsWorker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`3<string, Exception, string> MessageFaulted;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action`1<bool> Closing;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<string> PreTransactionExec;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<string> TransactionLog;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<string> InfoMessage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<EndPoint, ConnectionType> Connecting;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<EndPoint, ConnectionType> Resurrecting;
    [NullableAttribute("2")]
private RedisSubscriber _defaultSubscriber;
    private ConcurrentDictionary`2<RedisChannel, Subscription> subscriptions;
    [ObsoleteAttribute("No longer used, will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static TaskFactory Factory { get; public set; }
    [ObsoleteAttribute("Not supported; if you require ordered pub/sub, please see ChannelMessageQueue, will be removed in 3.0", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool PreserveAsyncOrder { get; public set; }
    internal bool IsDisposed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ILogger`1<ConnectionMultiplexer> Logger { get; }
    internal CommandMap CommandMap { get; }
    internal EndPointCollection EndPoints { get; }
    internal ConfigurationOptions RawConfig { get; }
    internal ServerSelectionStrategy ServerSelectionStrategy { get; }
    private ServerSelectionStrategy StackExchange.Redis.IInternalConnectionMultiplexer.ServerSelectionStrategy { get; }
    private ConnectionMultiplexer StackExchange.Redis.IInternalConnectionMultiplexer.UnderlyingMultiplexer { get; }
    [NullableAttribute("2")]
internal Exception LastException { get; internal set; }
    private ConfigurationOptions StackExchange.Redis.IInternalConnectionMultiplexer.RawConfig { get; }
    internal long LastReconfigureSecondsAgo { get; }
    internal long LastHeartbeatSecondsAgo { get; }
    internal static long LastGlobalHeartbeatSecondsAgo { get; }
    [ObsoleteAttribute("Please use ConfigurationOptions.IncludeDetailInExceptions instead - this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool IncludeDetailInExceptions { get; public set; }
    [ObsoleteAttribute("Please use ConfigurationOptions.IncludePerformanceCountersInExceptions instead - this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool IncludePerformanceCountersInExceptions { get; public set; }
    public int TimeoutMilliseconds { get; }
    internal int AsyncTimeoutMilliseconds { get; }
    public string ClientName { get; }
    public string Configuration { get; }
    public bool IsConnected { get; }
    public bool IsConnecting { get; }
    [NullableAttribute("2")]
internal Exception AuthException { get; private set; }
    public long OperationCount { get; }
    internal static int CollectedWithoutDispose { get; }
    private bool StackExchange.Redis.IInternalConnectionMultiplexer.AllowConnect { get; private set; }
    private bool StackExchange.Redis.IInternalConnectionMultiplexer.IgnoreConnect { get; private set; }
    internal static bool PreventThreadTheft { get; }
    [NullableAttribute("2")]
internal SocketManager SocketManager { get; private set; }
    public int StormLogThreshold { get; public set; }
    private RedisSubscriber DefaultSubscriber { get; }
    private static ConnectionMultiplexer();
    private ConnectionMultiplexer(ConfigurationOptions configuration, Nullable`1<ServerType> serverType, EndPointCollection endpoints);
    public static TaskFactory get_Factory();
    public static void set_Factory(TaskFactory value);
    public sealed virtual bool get_PreserveAsyncOrder();
    public sealed virtual void set_PreserveAsyncOrder(bool value);
    internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
internal ILogger`1<ConnectionMultiplexer> get_Logger();
    [CompilerGeneratedAttribute]
internal CommandMap get_CommandMap();
    [CompilerGeneratedAttribute]
internal EndPointCollection get_EndPoints();
    [CompilerGeneratedAttribute]
internal ConfigurationOptions get_RawConfig();
    [CompilerGeneratedAttribute]
internal ServerSelectionStrategy get_ServerSelectionStrategy();
    private sealed virtual override ServerSelectionStrategy StackExchange.Redis.IInternalConnectionMultiplexer.get_ServerSelectionStrategy();
    private sealed virtual override ConnectionMultiplexer StackExchange.Redis.IInternalConnectionMultiplexer.get_UnderlyingMultiplexer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Exception get_LastException();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_LastException(Exception value);
    private sealed virtual override ConfigurationOptions StackExchange.Redis.IInternalConnectionMultiplexer.get_RawConfig();
    internal long get_LastReconfigureSecondsAgo();
    internal long get_LastHeartbeatSecondsAgo();
    internal static long get_LastGlobalHeartbeatSecondsAgo();
    public sealed virtual bool get_IncludeDetailInExceptions();
    public sealed virtual void set_IncludeDetailInExceptions(bool value);
    public bool get_IncludePerformanceCountersInExceptions();
    public void set_IncludePerformanceCountersInExceptions(bool value);
    public sealed virtual int get_TimeoutMilliseconds();
    internal int get_AsyncTimeoutMilliseconds();
    public sealed virtual string get_ClientName();
    public sealed virtual string get_Configuration();
    public sealed virtual bool get_IsConnected();
    public sealed virtual bool get_IsConnecting();
    private static ConnectionMultiplexer CreateMultiplexer(ConfigurationOptions configuration, ILogger log, Nullable`1<ServerType> serverType, EventHandler`1& connectHandler, EndPointCollection endpoints);
    public sealed virtual ServerCounters GetCounters();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<MakePrimaryAsync>d__81")]
internal Task MakePrimaryAsync(ServerEndPoint server, ReplicationChangeOptions options, TextWriter writer);
    internal void CheckMessage(Message message);
    internal bool TryResend(int hashSlot, Message message, EndPoint endpoint, bool isMoved);
    public sealed virtual void Wait(Task task);
    public sealed virtual T Wait(Task`1<T> task);
    private static bool IsSingle(AggregateException aex);
    public sealed virtual void WaitAll(Task[] tasks);
    private bool WaitAllIgnoreErrors(Task[] tasks);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<WaitAllIgnoreErrorsAsync>d__89")]
private static Task`1<bool> WaitAllIgnoreErrorsAsync(string name, Task[] tasks, int timeoutMilliseconds, ILogger log, string caller, int callerLineNumber);
    private static bool AllComplete(Task[] tasks);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Exception get_AuthException();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_AuthException(Exception value);
    internal void SetAuthSuspect(Exception authException);
    public static Task`1<ConnectionMultiplexer> ConnectAsync(string configuration, TextWriter log);
    public static Task`1<ConnectionMultiplexer> ConnectAsync(string configuration, Action`1<ConfigurationOptions> configure, TextWriter log);
    public static Task`1<ConnectionMultiplexer> ConnectAsync(ConfigurationOptions configuration, TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ConnectImplAsync>d__99")]
private static Task`1<ConnectionMultiplexer> ConnectImplAsync(ConfigurationOptions configuration, TextWriter writer, Nullable`1<ServerType> serverType);
    [NullableContextAttribute("2")]
private static void Validate(ConfigurationOptions config);
    public static ConnectionMultiplexer Connect(string configuration, TextWriter log);
    public static ConnectionMultiplexer Connect(string configuration, Action`1<ConfigurationOptions> configure, TextWriter log);
    public static ConnectionMultiplexer Connect(ConfigurationOptions configuration, TextWriter log);
    private static ConnectionMultiplexer ConnectImpl(ConfigurationOptions configuration, TextWriter writer, Nullable`1<ServerType> serverType, EndPointCollection endpoints);
    private sealed virtual override ReadOnlySpan`1<ServerEndPoint> StackExchange.Redis.IInternalConnectionMultiplexer.GetServerSnapshot();
    internal ReadOnlySpan`1<ServerEndPoint> GetServerSnapshot();
    private sealed virtual override ServerEndPoint StackExchange.Redis.IInternalConnectionMultiplexer.GetServerEndPoint(EndPoint endpoint);
    [NullableContextAttribute("2")]
internal ServerEndPoint GetServerEndPoint(EndPoint endpoint, ILogger log, bool activate);
    internal void Root();
    private void OnHeartbeat();
    public sealed virtual ISubscriber GetSubscriber(object asyncState);
    internal int ApplyDefaultDatabase(int db);
    public sealed virtual IDatabase GetDatabase(int db, object asyncState);
    private IDatabase GetCachedDatabaseInstance(int db);
    public sealed virtual int HashSlot(RedisKey key);
    [NullableContextAttribute("2")]
internal ServerEndPoint AnyServer(ServerType serverType, UInt32 startOffset, RedisCommand command, CommandFlags flags, bool allowDisconnected);
    public sealed virtual IServer GetServer(string host, int port, object asyncState);
    public sealed virtual IServer GetServer(string hostAndPort, object asyncState);
    public sealed virtual IServer GetServer(IPAddress host, int port);
    [NullableContextAttribute("2")]
public sealed virtual IServer GetServer(EndPoint endpoint, object asyncState);
    public sealed virtual IServer[] GetServers();
    public sealed virtual int GetHashSlot(RedisKey key);
    public sealed virtual long get_OperationCount();
    [NullableContextAttribute("2")]
public sealed virtual bool Configure(TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ConfigureAsync>d__131")]
public sealed virtual Task`1<bool> ConfigureAsync(TextWriter log);
    internal int SyncConnectTimeout(bool forConnect);
    public sealed virtual string GetStatus();
    public sealed virtual void GetStatus(TextWriter log);
    [NullableContextAttribute("2")]
internal void GetStatus(ILogger log);
    [NullableContextAttribute("2")]
private void ActivateAllServers(ILogger log);
    internal bool ReconfigureIfNeeded(EndPoint blame, bool fromBroadcast, string cause, bool publishReconfigure, CommandFlags flags);
    public Task`1<bool> ReconfigureAsync(string reason);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<ReconfigureAsync>d__139")]
internal Task`1<bool> ReconfigureAsync(bool first, bool reconfigureAll, ILogger log, EndPoint blame, string cause, bool publishReconfigure, CommandFlags publishReconfigureFlags);
    public sealed virtual EndPoint[] GetEndPoints(bool configuredOnly);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<GetEndpointsFromClusterNodes>d__141")]
private Task`1<EndPointCollection> GetEndpointsFromClusterNodes(ServerEndPoint server, ILogger log);
    private void ResetAllNonConnected();
    private static ServerEndPoint NominatePreferredPrimary(ILogger log, ServerEndPoint[] servers, bool useTieBreakers, List`1<ServerEndPoint> primaries);
    private static ServerEndPoint SelectServerByElection(ServerEndPoint[] servers, string endpoint, ILogger log);
    private static string DeDotifyHost(string input);
    internal void UpdateClusterRange(ClusterConfiguration configuration);
    [NullableContextAttribute("2")]
internal ServerEndPoint SelectServer(Message message);
    [NullableContextAttribute("2")]
internal ServerEndPoint SelectServer(RedisCommand command, CommandFlags flags, RedisKey& key);
    [NullableContextAttribute("2")]
internal ServerEndPoint SelectServer(RedisCommand command, CommandFlags flags, RedisChannel& channel);
    [NullableContextAttribute("2")]
private bool PrepareToPushMessageToBridge(Message message, ResultProcessor`1<T> processor, IResultBox`1<T> resultBox, ServerEndPoint& server);
    [NullableContextAttribute("2")]
private ValueTask`1<WriteResult> TryPushMessageToBridgeAsync(Message message, ResultProcessor`1<T> processor, IResultBox`1<T> resultBox, ServerEndPoint& server);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("prefer async")]
private WriteResult TryPushMessageToBridgeSync(Message message, ResultProcessor`1<T> processor, IResultBox`1<T> resultBox, ServerEndPoint& server);
    public virtual string ToString();
    internal Exception GetException(WriteResult result, Message message, ServerEndPoint server, PhysicalBridge bridge);
    internal static void ThrowFailed(TaskCompletionSource`1<T> source, Exception unthrownException);
    [NullableContextAttribute("2")]
internal T ExecuteSyncImpl(Message message, ResultProcessor`1<T> processor, ServerEndPoint server, T defaultValue);
    [NullableContextAttribute("2")]
internal Task`1<T> ExecuteAsyncImpl(Message message, ResultProcessor`1<T> processor, object state, ServerEndPoint server, T defaultValue);
    [NullableContextAttribute("2")]
internal Task`1<T> ExecuteAsyncImpl(Message message, ResultProcessor`1<T> processor, object state, ServerEndPoint server);
    internal void OnAsyncTimeout();
    public sealed virtual long PublishReconfigure(CommandFlags flags);
    private long PublishReconfigureImpl(CommandFlags flags);
    public sealed virtual Task`1<long> PublishReconfigureAsync(CommandFlags flags);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<DisposeAsync>d__164")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Close(bool allowCommandsToComplete);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<CloseAsync>d__166")]
public sealed virtual Task CloseAsync(bool allowCommandsToComplete);
    private void DisposeAndClearServers();
    private Task[] QuitAllServers();
    private sealed virtual override Nullable`1<long> StackExchange.Redis.IInternalConnectionMultiplexer.GetConnectionId(EndPoint endpoint, ConnectionType type);
    internal static int get_CollectedWithoutDispose();
    protected virtual override void Finalize();
    private sealed virtual override bool StackExchange.Redis.IInternalConnectionMultiplexer.get_AllowConnect();
    private sealed virtual override void StackExchange.Redis.IInternalConnectionMultiplexer.set_AllowConnect(bool value);
    private sealed virtual override bool StackExchange.Redis.IInternalConnectionMultiplexer.get_IgnoreConnect();
    private sealed virtual override void StackExchange.Redis.IInternalConnectionMultiplexer.set_IgnoreConnect(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    internal void OnConnectionFailed(EndPoint endpoint, ConnectionType connectionType, ConnectionFailureType failureType, Exception exception, bool reconfigure, string physicalName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [NullableContextAttribute("2")]
internal void OnInternalError(Exception exception, EndPoint endpoint, ConnectionType connectionType, string origin);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    internal void OnConnectionRestored(EndPoint endpoint, ConnectionType connectionType, string physicalName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    internal void OnConfigurationChanged(EndPoint endpoint);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    internal void OnConfigurationChangedBroadcast(EndPoint endpoint);
    private void OnEndpointChanged(EndPoint endpoint, EventHandler`1<EndPointEventArgs> handler);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ServerMaintenanceEvent(EventHandler`1<ServerMaintenanceEvent> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ServerMaintenanceEvent(EventHandler`1<ServerMaintenanceEvent> value);
    internal void OnServerMaintenanceEvent(ServerMaintenanceEvent e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    internal void OnHashSlotMoved(int hashSlot, EndPoint old, EndPoint new);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    internal void OnErrorMessage(EndPoint endpoint, string message);
    public sealed virtual void ExportConfiguration(Stream destination, ExportOptions options);
    private static void Write(ZipArchive zip, string name, Task task, Action`2<T, StreamWriter> callback);
    private static void WriteNormalizingLineEndings(string source, StreamWriter writer);
    private static void SetAutodetectFeatureFlags();
    [EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public static void SetFeatureFlag(string flag, bool enabled);
    [EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public static bool GetFeatureFlag(string flag);
    internal static bool get_PreventThreadTheft();
    public sealed virtual void AddLibraryNameSuffix(string suffix);
    internal string GetFullLibraryName();
    public sealed virtual void RegisterProfiler(Func`1<ProfilingSession> profilingSessionProvider);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SocketManager get_SocketManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SocketManager(SocketManager value);
    [MemberNotNullAttribute("SocketManager")]
private void OnCreateReaderWriter(ConfigurationOptions configuration);
    private void OnCloseReaderWriter();
    [NullableContextAttribute("2")]
internal void InitializeSentinel(ILogger log);
    public static ConnectionMultiplexer SentinelConnect(string configuration, TextWriter log);
    public static Task`1<ConnectionMultiplexer> SentinelConnectAsync(string configuration, TextWriter log);
    public static ConnectionMultiplexer SentinelConnect(ConfigurationOptions configuration, TextWriter log);
    public static Task`1<ConnectionMultiplexer> SentinelConnectAsync(ConfigurationOptions configuration, TextWriter log);
    private static ConnectionMultiplexer SentinelPrimaryConnect(ConfigurationOptions configuration, TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<SentinelPrimaryConnectAsync>d__248")]
private static Task`1<ConnectionMultiplexer> SentinelPrimaryConnectAsync(ConfigurationOptions configuration, TextWriter writer);
    public ConnectionMultiplexer GetSentinelMasterConnection(ConfigurationOptions config, TextWriter log);
    internal void OnManagedConnectionRestored(object sender, ConnectionFailedEventArgs e);
    internal void OnManagedConnectionFailed(object sender, ConnectionFailedEventArgs e);
    internal EndPoint GetConfiguredPrimaryForService(string serviceName);
    internal EndPoint[] GetReplicasForService(string serviceName);
    [NullableContextAttribute("2")]
internal void SwitchPrimary(EndPoint switchBlame, ConnectionMultiplexer connection, TextWriter writer);
    internal void UpdateSentinelAddressList(string serviceName);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StormLogThreshold();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StormLogThreshold(int value);
    [NullableContextAttribute("2")]
public sealed virtual string GetStormLog();
    public sealed virtual void ResetStormLog();
    internal static void CompleteAsWorker(ICompletable completable);
    internal static bool TryCompleteHandler(EventHandler`1<T> handler, object sender, T args, bool isAsync);
    [CompilerGeneratedAttribute]
internal void add_MessageFaulted(Action`3<string, Exception, string> value);
    [CompilerGeneratedAttribute]
internal void remove_MessageFaulted(Action`3<string, Exception, string> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void add_Closing(Action`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void remove_Closing(Action`1<bool> value);
    [CompilerGeneratedAttribute]
internal void add_PreTransactionExec(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_PreTransactionExec(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void add_TransactionLog(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_TransactionLog(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void add_InfoMessage(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_InfoMessage(Action`1<string> value);
    [CompilerGeneratedAttribute]
internal void add_Connecting(Action`2<EndPoint, ConnectionType> value);
    [CompilerGeneratedAttribute]
internal void remove_Connecting(Action`2<EndPoint, ConnectionType> value);
    [CompilerGeneratedAttribute]
internal void add_Resurrecting(Action`2<EndPoint, ConnectionType> value);
    [CompilerGeneratedAttribute]
internal void remove_Resurrecting(Action`2<EndPoint, ConnectionType> value);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(bool condition, string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal static void TraceWithoutContext(string message, string category);
    [ConditionalAttribute("VERBOSE")]
internal static void TraceWithoutContext(bool condition, string message, string category);
    [NullableContextAttribute("2")]
[ConditionalAttribute("VERBOSE")]
internal void OnMessageFaulted(Message msg, Exception fault, string origin, string path, int lineNumber);
    [ConditionalAttribute("VERBOSE")]
internal void OnInfoMessage(string message);
    [ConditionalAttribute("VERBOSE")]
internal void OnClosing(bool complete);
    [ConditionalAttribute("VERBOSE")]
internal void OnConnecting(EndPoint endpoint, ConnectionType connectionType);
    [ConditionalAttribute("VERBOSE")]
internal void OnResurrecting(EndPoint endpoint, ConnectionType connectionType);
    [ConditionalAttribute("VERBOSE")]
internal void OnPreTransactionExec(Message message);
    [ConditionalAttribute("VERBOSE")]
internal void OnTransactionLog(string message);
    private RedisSubscriber get_DefaultSubscriber();
    internal ConcurrentDictionary`2<RedisChannel, Subscription> GetSubscriptions();
    private sealed virtual override ConcurrentDictionary`2<RedisChannel, Subscription> StackExchange.Redis.IInternalConnectionMultiplexer.GetSubscriptions();
    internal int GetSubscriptionsCount();
    private sealed virtual override int StackExchange.Redis.IInternalConnectionMultiplexer.GetSubscriptionsCount();
    internal Subscription GetOrAddSubscription(RedisChannel& channel, CommandFlags flags);
    [NullableContextAttribute("2")]
internal bool TryGetSubscription(RedisChannel& channel, Subscription& sub);
    [NullableContextAttribute("2")]
internal bool TryRemoveSubscription(RedisChannel& channel, Subscription& sub);
    internal bool GetSubscriberCounts(RedisChannel& channel, Int32& handlers, Int32& queues);
    [NullableContextAttribute("2")]
internal ServerEndPoint GetSubscribedServer(RedisChannel& channel);
    internal void OnMessage(RedisChannel& subscription, RedisChannel& channel, RedisValue& payload);
    [NullableContextAttribute("0")]
internal void OnMessage(RedisChannel& subscription, RedisChannel& channel, Sequence`1<RawResult> payload);
    internal void UpdateSubscriptions();
    internal long EnsureSubscriptions(CommandFlags flags);
    [CompilerGeneratedAttribute]
internal static void <WaitAllIgnoreErrorsAsync>g__LogWithThreadPoolStats|89_0(ILogger log, string message, Int32& busyWorkerCount);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<<ExecuteAsyncImpl>g__ExecuteAsyncImpl_Awaited|157_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task`1<T> <ExecuteAsyncImpl>g__ExecuteAsyncImpl_Awaited|157_0(ConnectionMultiplexer this, ValueTask`1<WriteResult> write, TaskCompletionSource`1<T> tcs, Message message, ServerEndPoint server, T defaultValue);
    [AsyncStateMachineAttribute("StackExchange.Redis.ConnectionMultiplexer/<<ExecuteAsyncImpl>g__ExecuteAsyncImpl_Awaited|158_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task`1<T> <ExecuteAsyncImpl>g__ExecuteAsyncImpl_Awaited|158_0(ConnectionMultiplexer this, ValueTask`1<WriteResult> write, TaskCompletionSource`1<T> tcs, Message message, ServerEndPoint server);
}
public enum StackExchange.Redis.ConnectionType : Enum {
    public int value__;
    public static ConnectionType None;
    public static ConnectionType Interactive;
    public static ConnectionType Subscription;
}
internal enum StackExchange.Redis.ConsumeResult : Enum {
    public int value__;
    public static ConsumeResult Failure;
    public static ConsumeResult Success;
    public static ConsumeResult NeedMoreData;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class StackExchange.Redis.CursorEnumerable`1 : object {
    private RedisBase redis;
    [NullableAttribute("2")]
private ServerEndPoint server;
    private protected int db;
    private protected CommandFlags flags;
    private protected int pageSize;
    private protected int initialOffset;
    private protected RedisValue initialCursor;
    [NullableAttribute("2")]
private IScanningCursor modreq(System.Runtime.CompilerServices.IsVolatile) activeCursor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ResultProcessor`1<ScanResult<T>> Processor { get; }
    private long StackExchange.Redis.IScanningCursor.Cursor { get; }
    private int StackExchange.Redis.IScanningCursor.PageSize { get; }
    private int StackExchange.Redis.IScanningCursor.PageOffset { get; }
    private protected CursorEnumerable`1(RedisBase redis, ServerEndPoint server, int db, int pageSize, RedisValue& cursor, int pageOffset, CommandFlags flags);
    public Enumerator<T> GetEnumerator();
    public Enumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IAsyncEnumerator`1<T> System.Collections.Generic.IAsyncEnumerable<T>.GetAsyncEnumerator(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private protected abstract virtual Message CreateMessage(RedisValue& modreq(System.Runtime.InteropServices.InAttribute) cursor);
    private protected abstract virtual ResultProcessor`1<ScanResult<T>> get_Processor();
    private protected virtual Task`1<ScanResult<T>> GetNextPageAsync(IScanningCursor obj, RedisValue cursor, Message& message);
    private sealed virtual override long StackExchange.Redis.IScanningCursor.get_Cursor();
    private sealed virtual override int StackExchange.Redis.IScanningCursor.get_PageSize();
    private sealed virtual override int StackExchange.Redis.IScanningCursor.get_PageOffset();
    internal static CursorEnumerable`1<T> From(RedisBase redis, ServerEndPoint server, Task`1<T[]> pending, int pageOffset);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class StackExchange.Redis.EndPointCollection : Collection`1<EndPoint> {
    public EndPointCollection(IList`1<EndPoint> endpoints);
    public static string ToString(EndPoint endpoint);
    public static EndPoint TryParse(string endpoint);
    public void Add(string hostAndPort);
    public void Add(string host, int port);
    public void Add(IPAddress host, int port);
    public bool TryAdd(EndPoint endpoint);
    protected virtual void InsertItem(int index, EndPoint item);
    protected virtual void SetItem(int index, EndPoint item);
    internal void SetDefaultPorts(Nullable`1<ServerType> serverType, bool ssl);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<EndPoint> System.Collections.Generic.IEnumerable<System.Net.EndPoint>.GetEnumerator();
    [IteratorStateMachineAttribute("StackExchange.Redis.EndPointCollection/<GetEnumerator>d__14")]
public IEnumerator`1<EndPoint> GetEnumerator();
    internal bool HasDnsEndPoints();
    [AsyncStateMachineAttribute("StackExchange.Redis.EndPointCollection/<ResolveEndPointsAsync>d__16")]
internal Task ResolveEndPointsAsync(ConnectionMultiplexer multiplexer, ILogger log);
    internal EndPointCollection Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.EndPointEventArgs : EventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<EndPointEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    public EndPoint EndPoint { get; }
    internal EndPointEventArgs(EventHandler`1<EndPointEventArgs> handler, object sender, EndPoint endpoint);
    public EndPointEventArgs(object sender, EndPoint endpoint);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.ExceptionFactory : object {
    private static string DataCommandKey;
    private static string DataSentStatusKey;
    private static string DataServerKey;
    private static string TimeoutHelpLink;
    [NullableContextAttribute("2")]
internal static Exception AdminModeNotEnabled(bool includeDetail, RedisCommand command, Message message, ServerEndPoint server);
    internal static Exception CommandDisabled(RedisCommand command);
    internal static Exception CommandDisabled(string command);
    internal static Exception TooManyArgs(string command, int argCount);
    internal static Exception ConnectionFailure(bool includeDetail, ConnectionFailureType failureType, string message, ServerEndPoint server);
    internal static Exception DatabaseNotRequired(bool includeDetail, RedisCommand command);
    internal static Exception DatabaseOutfRange(bool includeDetail, int targetDatabase, Message message, ServerEndPoint server);
    internal static Exception DatabaseRequired(bool includeDetail, RedisCommand command);
    [NullableContextAttribute("2")]
internal static Exception PrimaryOnly(bool includeDetail, RedisCommand command, Message message, ServerEndPoint server);
    internal static Exception MultiSlot(bool includeDetail, Message message);
    internal static string GetInnerMostExceptionMessage(Exception e);
    internal static Exception NoConnectionAvailable(ConnectionMultiplexer multiplexer, Message message, ServerEndPoint server, ReadOnlySpan`1<ServerEndPoint> serverSnapshot, RedisCommand command);
    [NullableContextAttribute("2")]
internal static Exception PopulateInnerExceptions(ReadOnlySpan`1<ServerEndPoint> serverSnapshot);
    internal static Exception NotSupported(bool includeDetail, RedisCommand command);
    internal static Exception NoCursor(RedisCommand command);
    [NullableContextAttribute("2")]
private static void Add(List`1<Tuple`2<string, string>> data, StringBuilder sb, string lk, string sk, string v);
    internal static Exception Timeout(ConnectionMultiplexer multiplexer, string baseErrorMessage, Message message, ServerEndPoint server, Nullable`1<WriteResult> result, PhysicalBridge bridge);
    private static void CopyDataToException(List`1<Tuple`2<string, string>> data, Exception ex);
    private static void AddCommonDetail(List`1<Tuple`2<string, string>> data, StringBuilder sb, Message message, ConnectionMultiplexer multiplexer, ServerEndPoint server);
    [NullableContextAttribute("2")]
private static void AddExceptionDetail(Exception exception, Message message, ServerEndPoint server, string label);
    private static string GetLabel(bool includeDetail, RedisCommand command, Message message);
    internal static Exception UnableToConnect(ConnectionMultiplexer muxer, string failureMessage);
}
[FlagsAttribute]
public enum StackExchange.Redis.Exclude : Enum {
    public int value__;
    public static Exclude None;
    public static Exclude Start;
    public static Exclude Stop;
    public static Exclude Both;
}
public enum StackExchange.Redis.ExpireResult : Enum {
    public int value__;
    public static ExpireResult Due;
    public static ExpireResult Success;
    public static ExpireResult ConditionNotMet;
    public static ExpireResult NoSuchField;
}
public enum StackExchange.Redis.ExpireWhen : Enum {
    public int value__;
    public static ExpireWhen Always;
    public static ExpireWhen GreaterThanCurrentExpiry;
    public static ExpireWhen HasExpiry;
    public static ExpireWhen HasNoExpiry;
    public static ExpireWhen LessThanCurrentExpiry;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ExpiryOptionExtensions : object {
    [ExtensionAttribute]
internal static RedisValue ToLiteral(ExpireWhen op);
}
public class StackExchange.Redis.ExponentialRetry : object {
    private int deltaBackOffMilliseconds;
    private int maxDeltaBackOffMilliseconds;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Random r;
    public ExponentialRetry(int deltaBackOffMilliseconds);
    public ExponentialRetry(int deltaBackOffMilliseconds, int maxDeltaBackOffMilliseconds);
    public sealed virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
[FlagsAttribute]
public enum StackExchange.Redis.ExportOptions : Enum {
    public int value__;
    public static ExportOptions None;
    public static ExportOptions Info;
    public static ExportOptions Config;
    public static ExportOptions Client;
    public static ExportOptions Cluster;
    public static ExportOptions All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class StackExchange.Redis.ExtensionMethods : object {
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> CRLF { get; }
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(HashEntry[] hash);
    [ExtensionAttribute]
public static Dictionary`2<RedisValue, RedisValue> ToDictionary(HashEntry[] hash);
    [ExtensionAttribute]
public static Dictionary`2<string, double> ToStringDictionary(SortedSetEntry[] sortedSet);
    [ExtensionAttribute]
public static Dictionary`2<RedisValue, double> ToDictionary(SortedSetEntry[] sortedSet);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToStringDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static Dictionary`2<RedisKey, RedisValue> ToDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToDictionary(KeyValuePair`2[] pairs);
    [ExtensionAttribute]
public static RedisValue[] ToRedisValueArray(String[] values);
    [ExtensionAttribute]
public static String[] ToStringArray(RedisValue[] values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void AuthenticateAsClient(SslStream ssl, string host, Nullable`1<SslProtocols> allowedProtocols, bool checkCertificateRevocation);
    [NullableContextAttribute("1")]
private static void AuthenticateAsClientUsingDefaultProtocols(SslStream ssl, string host);
    [ExtensionAttribute]
public static Stream AsStream(Lease`1<byte> bytes, bool ownsLease);
    [ExtensionAttribute]
public static string DecodeString(Lease`1<byte> bytes, Encoding encoding);
    [ExtensionAttribute]
public static Lease`1<char> DecodeLease(Lease`1<byte> bytes, Encoding encoding);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int VectorSafeIndexOf(ReadOnlySpan`1<byte> span, byte value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int VectorSafeIndexOfCRLF(ReadOnlySpan`1<byte> span);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_CRLF();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static T[] ToArray(RawResult& result, Projection`2<RawResult, T> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static TTo[] ToArray(RawResult& result, Projection`3<RawResult, TState, TTo> selector, TState& state);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class StackExchange.Redis.ExtensionMethodsInternal : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(string s);
    [ExtensionAttribute]
internal static bool IsNullOrWhiteSpace(string s);
    [ExtensionAttribute]
internal static bool TryDequeue(Queue`1<T> queue, T& result);
    [ExtensionAttribute]
internal static bool TryPeek(Queue`1<T> queue, T& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.Format : object {
    internal static int MaxInt32TextLen;
    internal static int MaxInt64TextLen;
    public static int ParseInt32(string s);
    public static long ParseInt64(string s);
    public static string ToString(int value);
    public static bool TryParseBoolean(string s, Boolean& value);
    public static bool TryParseInt32(string s, Int32& value);
    internal static EndPoint ParseEndPoint(string host, int port);
    [NullableContextAttribute("2")]
internal static bool TryParseEndPoint(string host, string port, EndPoint& endpoint);
    internal static string ToString(long value);
    internal static string ToString(ulong value);
    internal static string ToString(double value);
    [NullableContextAttribute("2")]
internal static string ToString(object value);
    internal static string ToString(EndPoint endpoint);
    internal static string ToStringHostOnly(EndPoint endpoint);
    [NullableContextAttribute("2")]
internal static bool TryGetHostPort(EndPoint endpoint, String& host, Nullable`1& port);
    [NullableContextAttribute("2")]
internal static bool TryParseDouble(string s, Double& value);
    internal static bool TryParseUInt64(string s, UInt64& value);
    [NullableContextAttribute("0")]
internal static bool TryParseUInt64(ReadOnlySpan`1<byte> s, UInt64& value);
    [NullableContextAttribute("0")]
internal static bool TryParseInt64(ReadOnlySpan`1<byte> s, Int64& value);
    internal static bool CouldBeInteger(string s);
    [NullableContextAttribute("0")]
internal static bool CouldBeInteger(ReadOnlySpan`1<byte> s);
    internal static bool TryParseInt64(string s, Int64& value);
    [NullableContextAttribute("0")]
internal static bool TryParseDouble(ReadOnlySpan`1<byte> s, Double& value);
    private static bool CaseInsensitiveASCIIEqual(string xLowerCase, string y);
    [NullableContextAttribute("0")]
private static bool CaseInsensitiveASCIIEqual(string xLowerCase, ReadOnlySpan`1<byte> y);
    [NullableContextAttribute("2")]
internal static bool TryParseEndPoint(string addressWithPort, EndPoint& endpoint);
    [NullableContextAttribute("0")]
internal static string GetString(ReadOnlySequence`1<byte> buffer);
    [NullableContextAttribute("0")]
internal static string GetString(ReadOnlySpan`1<byte> span);
    [DoesNotReturnAttribute]
private static void ThrowFormatFailed();
    internal static int MeasureDouble(double value);
    [NullableContextAttribute("0")]
internal static int FormatDouble(double value, Span`1<byte> destination);
    internal static int MeasureInt64(long value);
    [NullableContextAttribute("0")]
internal static int FormatInt64(long value, Span`1<byte> destination);
    internal static int MeasureUInt64(ulong value);
    [NullableContextAttribute("0")]
internal static int FormatUInt64(ulong value, Span`1<byte> destination);
    [NullableContextAttribute("0")]
internal static int FormatInt32(int value, Span`1<byte> destination);
    [NullableContextAttribute("0")]
internal static bool TryParseVersion(ReadOnlySpan`1<char> input, Version& version);
    [NullableContextAttribute("2")]
internal static bool TryParseVersion(string input, Version& version);
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.GeoEntry : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private GeoPosition <Position>k__BackingField;
    public RedisValue Member { get; }
    public GeoPosition Position { get; }
    public double Longitude { get; }
    public double Latitude { get; }
    public GeoEntry(double longitude, double latitude, RedisValue member);
    [CompilerGeneratedAttribute]
public RedisValue get_Member();
    [CompilerGeneratedAttribute]
public GeoPosition get_Position();
    public double get_Longitude();
    public double get_Latitude();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GeoEntry other);
    public static bool op_Equality(GeoEntry x, GeoEntry y);
    public static bool op_Inequality(GeoEntry x, GeoEntry y);
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.GeoPosition : ValueType {
    [CompilerGeneratedAttribute]
private double <Latitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Longitude>k__BackingField;
    public double Latitude { get; }
    public double Longitude { get; }
    public GeoPosition(double longitude, double latitude);
    [NullableContextAttribute("1")]
internal static string GetRedisUnit(GeoUnit unit);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GeoPosition other);
    public static bool op_Equality(GeoPosition x, GeoPosition y);
    public static bool op_Inequality(GeoPosition x, GeoPosition y);
}
[FlagsAttribute]
public enum StackExchange.Redis.GeoRadiusOptions : Enum {
    public int value__;
    public static GeoRadiusOptions None;
    public static GeoRadiusOptions WithCoordinates;
    public static GeoRadiusOptions WithDistance;
    public static GeoRadiusOptions WithGeoHash;
    public static GeoRadiusOptions Default;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.GeoRadiusOptionsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void AddArgs(GeoRadiusOptions options, List`1<RedisValue> values);
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.GeoRadiusResult : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<GeoPosition> <Position>k__BackingField;
    public RedisValue Member { get; }
    public Nullable`1<double> Distance { get; }
    public Nullable`1<long> Hash { get; }
    public Nullable`1<GeoPosition> Position { get; }
    public GeoRadiusResult(RedisValue& member, Nullable`1<double> distance, Nullable`1<long> hash, Nullable`1<GeoPosition> position);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public RedisValue get_Member();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Distance();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Hash();
    [CompilerGeneratedAttribute]
public Nullable`1<GeoPosition> get_Position();
}
public class StackExchange.Redis.GeoSearchBox : GeoSearchShape {
    private double _height;
    private double _width;
    internal int ArgCount { get; }
    public GeoSearchBox(double height, double width, GeoUnit unit);
    internal virtual int get_ArgCount();
    [NullableContextAttribute("1")]
internal virtual void AddArgs(List`1<RedisValue> args);
}
public class StackExchange.Redis.GeoSearchCircle : GeoSearchShape {
    private double _radius;
    internal int ArgCount { get; }
    public GeoSearchCircle(double radius, GeoUnit unit);
    internal virtual int get_ArgCount();
    [NullableContextAttribute("1")]
internal virtual void AddArgs(List`1<RedisValue> args);
}
public abstract class StackExchange.Redis.GeoSearchShape : object {
    [CompilerGeneratedAttribute]
private GeoUnit <Unit>k__BackingField;
    protected GeoUnit Unit { get; }
    internal int ArgCount { get; }
    public GeoSearchShape(GeoUnit unit);
    [CompilerGeneratedAttribute]
protected GeoUnit get_Unit();
    internal abstract virtual int get_ArgCount();
    [NullableContextAttribute("1")]
internal abstract virtual void AddArgs(List`1<RedisValue> args);
}
public enum StackExchange.Redis.GeoUnit : Enum {
    public int value__;
    public static GeoUnit Meters;
    public static GeoUnit Kilometers;
    public static GeoUnit Miles;
    public static GeoUnit Feet;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.GeoUnitExtensions : object {
    [ExtensionAttribute]
internal static RedisValue ToLiteral(GeoUnit unit);
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.HashEntry : ValueType {
    internal RedisValue name;
    internal RedisValue value;
    public RedisValue Name { get; }
    public RedisValue Value { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Name", "False")]
public RedisValue Key { get; }
    public HashEntry(RedisValue name, RedisValue value);
    public RedisValue get_Name();
    public RedisValue get_Value();
    public RedisValue get_Key();
    public static KeyValuePair`2<RedisValue, RedisValue> op_Implicit(HashEntry value);
    public static HashEntry op_Implicit(KeyValuePair`2<RedisValue, RedisValue> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashEntry other);
    public static bool op_Equality(HashEntry x, HashEntry y);
    public static bool op_Inequality(HashEntry x, HashEntry y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.HashSlotMovedEventArgs : EventArgs {
    private object sender;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<HashSlotMovedEventArgs> handler;
    [CompilerGeneratedAttribute]
private int <HashSlot>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EndPoint <OldEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <NewEndPoint>k__BackingField;
    public int HashSlot { get; }
    [NullableAttribute("2")]
public EndPoint OldEndPoint { get; }
    public EndPoint NewEndPoint { get; }
    internal HashSlotMovedEventArgs(EventHandler`1<HashSlotMovedEventArgs> handler, object sender, int hashSlot, EndPoint old, EndPoint new);
    public HashSlotMovedEventArgs(object sender, int hashSlot, EndPoint old, EndPoint new);
    [CompilerGeneratedAttribute]
public int get_HashSlot();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EndPoint get_OldEndPoint();
    [CompilerGeneratedAttribute]
public EndPoint get_NewEndPoint();
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
}
public interface StackExchange.Redis.IBatch {
    public abstract virtual void Execute();
}
[NullableContextAttribute("1")]
internal interface StackExchange.Redis.ICompletable {
    public abstract virtual void AppendStormLog(StringBuilder sb);
    public abstract virtual bool TryComplete(bool isAsync);
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.IConnectionMultiplexer {
    public string ClientName { get; }
    public string Configuration { get; }
    public int TimeoutMilliseconds { get; }
    public long OperationCount { get; }
    [ObsoleteAttribute("Not supported; if you require ordered pub/sub, please see ChannelMessageQueue", "False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool PreserveAsyncOrder { get; public set; }
    public bool IsConnected { get; }
    public bool IsConnecting { get; }
    [ObsoleteAttribute("Please use ConfigurationOptions.IncludeDetailInExceptions instead - this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool IncludeDetailInExceptions { get; public set; }
    public int StormLogThreshold { get; public set; }
    public abstract virtual string get_ClientName();
    public abstract virtual string get_Configuration();
    public abstract virtual int get_TimeoutMilliseconds();
    public abstract virtual long get_OperationCount();
    public abstract virtual bool get_PreserveAsyncOrder();
    public abstract virtual void set_PreserveAsyncOrder(bool value);
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool get_IsConnecting();
    public abstract virtual bool get_IncludeDetailInExceptions();
    public abstract virtual void set_IncludeDetailInExceptions(bool value);
    public abstract virtual int get_StormLogThreshold();
    public abstract virtual void set_StormLogThreshold(int value);
    public abstract virtual void RegisterProfiler(Func`1<ProfilingSession> profilingSessionProvider);
    public abstract virtual ServerCounters GetCounters();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorMessage(EventHandler`1<RedisErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionFailed(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InternalError(EventHandler`1<InternalErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConnectionRestored(EventHandler`1<ConnectionFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationChanged(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationChangedBroadcast(EventHandler`1<EndPointEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ServerMaintenanceEvent(EventHandler`1<ServerMaintenanceEvent> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ServerMaintenanceEvent(EventHandler`1<ServerMaintenanceEvent> value);
    public abstract virtual EndPoint[] GetEndPoints(bool configuredOnly);
    public abstract virtual void Wait(Task task);
    public abstract virtual T Wait(Task`1<T> task);
    public abstract virtual void WaitAll(Task[] tasks);
    [CompilerGeneratedAttribute]
public abstract virtual void add_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_HashSlotMoved(EventHandler`1<HashSlotMovedEventArgs> value);
    public abstract virtual int HashSlot(RedisKey key);
    public abstract virtual ISubscriber GetSubscriber(object asyncState);
    public abstract virtual IDatabase GetDatabase(int db, object asyncState);
    public abstract virtual IServer GetServer(string host, int port, object asyncState);
    public abstract virtual IServer GetServer(string hostAndPort, object asyncState);
    public abstract virtual IServer GetServer(IPAddress host, int port);
    public abstract virtual IServer GetServer(EndPoint endpoint, object asyncState);
    public abstract virtual IServer[] GetServers();
    public abstract virtual Task`1<bool> ConfigureAsync(TextWriter log);
    [NullableContextAttribute("2")]
public abstract virtual bool Configure(TextWriter log);
    public abstract virtual string GetStatus();
    public abstract virtual void GetStatus(TextWriter log);
    public abstract virtual string ToString();
    public abstract virtual void Close(bool allowCommandsToComplete);
    public abstract virtual Task CloseAsync(bool allowCommandsToComplete);
    [NullableContextAttribute("2")]
public abstract virtual string GetStormLog();
    public abstract virtual void ResetStormLog();
    public abstract virtual long PublishReconfigure(CommandFlags flags);
    public abstract virtual Task`1<long> PublishReconfigureAsync(CommandFlags flags);
    public abstract virtual int GetHashSlot(RedisKey key);
    public abstract virtual void ExportConfiguration(Stream destination, ExportOptions options);
    public abstract virtual void AddLibraryNameSuffix(string suffix);
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.IDatabase {
    public int Database { get; }
    public abstract virtual int get_Database();
    public abstract virtual IBatch CreateBatch(object asyncState);
    public abstract virtual ITransaction CreateTransaction(object asyncState);
    public abstract virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public abstract virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public abstract virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public abstract virtual bool GeoAdd(RedisKey key, GeoEntry value, CommandFlags flags);
    public abstract virtual long GeoAdd(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public abstract virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public abstract virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoSearch(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual GeoRadiusResult[] GeoSearch(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public abstract virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public abstract virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual Int64[] HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual PersistResult[] HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Int64[] HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual Lease`1<byte> HashGetLease(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public abstract virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public abstract virtual long HashLength(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue HashRandomField(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] HashRandomFields(RedisKey key, long count, CommandFlags flags);
    public abstract virtual HashEntry[] HashRandomFieldsWithValues(RedisKey key, long count, CommandFlags flags);
    public abstract virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<HashEntry> HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisValue> HashScanNoValues(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public abstract virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public abstract virtual long HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public abstract virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public abstract virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public abstract virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyCopy(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public abstract virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    public abstract virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string KeyEncoding(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public abstract virtual long KeyExists(RedisKey[] keys, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public abstract virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual Nullable`1<DateTime> KeyExpireTime(RedisKey key, CommandFlags flags);
    public abstract virtual Nullable`1<long> KeyFrequency(RedisKey key, CommandFlags flags);
    public abstract virtual Nullable`1<TimeSpan> KeyIdleTime(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public abstract virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public abstract virtual RedisKey KeyRandom(CommandFlags flags);
    public abstract virtual Nullable`1<long> KeyRefCount(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public abstract virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public abstract virtual bool KeyTouch(RedisKey key, CommandFlags flags);
    public abstract virtual long KeyTouch(RedisKey[] keys, CommandFlags flags);
    public abstract virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public abstract virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] ListLeftPop(RedisKey key, long count, CommandFlags flags);
    public abstract virtual ListPopResult ListLeftPop(RedisKey[] keys, long count, CommandFlags flags);
    public abstract virtual long ListPosition(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public abstract virtual Int64[] ListPositions(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public abstract virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual long ListLeftPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public abstract virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual long ListLength(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue ListMove(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public abstract virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public abstract virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] ListRightPop(RedisKey key, long count, CommandFlags flags);
    public abstract virtual ListPopResult ListRightPop(RedisKey[] keys, long count, CommandFlags flags);
    public abstract virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public abstract virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual long ListRightPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public abstract virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public abstract virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public abstract virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual RedisResult Execute(string command, Object[] args);
    public abstract virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    [EditorBrowsableAttribute("1")]
public abstract virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluateReadOnly(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisResult ScriptEvaluateReadOnly(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public abstract virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Boolean[] SetContains(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual long SetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public abstract virtual long SetLength(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public abstract virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SetPop(RedisKey key, long count, CommandFlags flags);
    public abstract virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public abstract virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisValue> SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public abstract virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public abstract virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetCombine(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetCombineWithScores(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public abstract virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual long SortedSetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public abstract virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public abstract virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual RedisValue SortedSetRandomMember(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetRandomMembersWithScores(RedisKey key, long count, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual long SortedSetRangeAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public abstract virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public abstract virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public abstract virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<SortedSetEntry> SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Nullable`1[] SortedSetScores(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Nullable`1<SortedSetEntry> SortedSetPop(RedisKey key, Order order, CommandFlags flags);
    public abstract virtual SortedSetEntry[] SortedSetPop(RedisKey key, long count, Order order, CommandFlags flags);
    public abstract virtual SortedSetPopResult SortedSetPop(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public abstract virtual bool SortedSetUpdate(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public abstract virtual long SortedSetUpdate(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public abstract virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public abstract virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual RedisValue StreamAdd(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual RedisValue StreamAdd(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual StreamAutoClaimResult StreamAutoClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual StreamAutoClaimIdsOnlyResult StreamAutoClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual StreamEntry[] StreamClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual RedisValue[] StreamClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual bool StreamConsumerGroupSetPosition(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public abstract virtual StreamConsumerInfo[] StreamConsumerInfo(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public abstract virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public abstract virtual long StreamDelete(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual long StreamDeleteConsumer(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public abstract virtual bool StreamDeleteConsumerGroup(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual StreamGroupInfo[] StreamGroupInfo(RedisKey key, CommandFlags flags);
    public abstract virtual StreamInfo StreamInfo(RedisKey key, CommandFlags flags);
    public abstract virtual long StreamLength(RedisKey key, CommandFlags flags);
    public abstract virtual StreamPendingInfo StreamPending(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual StreamPendingMessageInfo[] StreamPendingMessages(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public abstract virtual StreamEntry[] StreamRange(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public abstract virtual StreamEntry[] StreamRead(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual RedisStream[] StreamRead(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public abstract virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public abstract virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public abstract virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public abstract virtual long StreamTrim(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual long StringBitCount(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public abstract virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public abstract virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public abstract virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public abstract virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public abstract virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual Lease`1<byte> StringGetLease(RedisKey key, CommandFlags flags);
    public abstract virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public abstract virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual RedisValue StringGetSetExpiry(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual RedisValue StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags);
    public abstract virtual RedisValue StringGetDelete(RedisKey key, CommandFlags flags);
    public abstract virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public abstract virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public abstract virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public abstract virtual long StringLength(RedisKey key, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string StringLongestCommonSubsequence(RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual long StringLongestCommonSubsequenceLength(RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual LCSMatchResult StringLongestCommonSubsequenceWithMatches(RedisKey first, RedisKey second, long minLength, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public abstract virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public abstract virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public abstract virtual bool StringSetBit(RedisKey key, long offset, bool bit, CommandFlags flags);
    public abstract virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.IDatabaseAsync {
    public abstract virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public abstract virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public abstract virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public abstract virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public abstract virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public abstract virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public abstract virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public abstract virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual Task`1<Int64[]> HashFieldGetExpireDateTimeAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<PersistResult[]> HashFieldPersistAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<Int64[]> HashFieldGetTimeToLiveAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<Lease`1<byte>> HashGetLeaseAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public abstract virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> HashRandomFieldAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashRandomFieldsAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<HashEntry[]> HashRandomFieldsWithValuesAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual IAsyncEnumerable`1<HashEntry> HashScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual IAsyncEnumerable`1<RedisValue> HashScanNoValuesAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public abstract virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<long> HashStringLengthAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyCopyAsync(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<string> KeyEncodingAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> KeyExistsAsync(RedisKey[] keys, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, ExpireWhen when, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<DateTime>> KeyExpireTimeAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<long>> KeyFrequencyAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<TimeSpan>> KeyIdleTimeAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<long>> KeyRefCountAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public abstract virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> KeyTouchAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> KeyTouchAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public abstract virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> ListLeftPopAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<ListPopResult> ListLeftPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public abstract virtual Task`1<long> ListPositionAsync(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public abstract virtual Task`1<Int64[]> ListPositionsAsync(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public abstract virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListMoveAsync(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> ListRightPopAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<ListPopResult> ListRightPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public abstract virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public abstract virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public abstract virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    [EditorBrowsableAttribute("1")]
public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<Boolean[]> SetContainsAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual Task`1<long> SetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public abstract virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetPopAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public abstract virtual IAsyncEnumerable`1<RedisValue> SetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public abstract virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetCombineAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetCombineWithScoresAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public abstract virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> SortedSetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetRandomMembersWithScoresAsync(RedisKey key, long count, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRangeAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public abstract virtual IAsyncEnumerable`1<SortedSetEntry> SortedSetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1[]> SortedSetScoresAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public abstract virtual Task`1<bool> SortedSetUpdateAsync(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public abstract virtual Task`1<long> SortedSetUpdateAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public abstract virtual Task`1<Nullable`1<SortedSetEntry>> SortedSetPopAsync(RedisKey key, Order order, CommandFlags flags);
    public abstract virtual Task`1<SortedSetEntry[]> SortedSetPopAsync(RedisKey key, long count, Order order, CommandFlags flags);
    public abstract virtual Task`1<SortedSetPopResult> SortedSetPopAsync(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public abstract virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public abstract virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual Task`1<StreamAutoClaimResult> StreamAutoClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual Task`1<StreamAutoClaimIdsOnlyResult> StreamAutoClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual Task`1<StreamEntry[]> StreamClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> StreamClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual Task`1<bool> StreamConsumerGroupSetPositionAsync(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public abstract virtual Task`1<StreamConsumerInfo[]> StreamConsumerInfoAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public abstract virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public abstract virtual Task`1<long> StreamDeleteAsync(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public abstract virtual Task`1<long> StreamDeleteConsumerAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public abstract virtual Task`1<bool> StreamDeleteConsumerGroupAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual Task`1<StreamGroupInfo[]> StreamGroupInfoAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<StreamInfo> StreamInfoAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> StreamLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<StreamPendingInfo> StreamPendingAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public abstract virtual Task`1<StreamPendingMessageInfo[]> StreamPendingMessagesAsync(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public abstract virtual Task`1<StreamEntry[]> StreamRangeAsync(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public abstract virtual Task`1<StreamEntry[]> StreamReadAsync(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual Task`1<RedisStream[]> StreamReadAsync(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public abstract virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public abstract virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public abstract virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public abstract virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public abstract virtual Task`1<long> StreamTrimAsync(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public abstract virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public abstract virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public abstract virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public abstract virtual Task`1<Lease`1<byte>> StringGetLeaseAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, DateTime expiry, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringGetDeleteAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public abstract virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public abstract virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public abstract virtual Task`1<string> StringLongestCommonSubsequenceAsync(RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<long> StringLongestCommonSubsequenceLengthAsync(RedisKey first, RedisKey second, CommandFlags flags);
    public abstract virtual Task`1<LCSMatchResult> StringLongestCommonSubsequenceWithMatchesAsync(RedisKey first, RedisKey second, long minLength, CommandFlags flags);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public abstract virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool bit, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
}
[NullableContextAttribute("1")]
internal interface StackExchange.Redis.IInternalConnectionMultiplexer {
    public bool AllowConnect { get; public set; }
    public bool IgnoreConnect { get; public set; }
    public ConfigurationOptions RawConfig { get; }
    public ServerSelectionStrategy ServerSelectionStrategy { get; }
    public ConnectionMultiplexer UnderlyingMultiplexer { get; }
    public abstract virtual bool get_AllowConnect();
    public abstract virtual void set_AllowConnect(bool value);
    public abstract virtual bool get_IgnoreConnect();
    public abstract virtual void set_IgnoreConnect(bool value);
    public abstract virtual ReadOnlySpan`1<ServerEndPoint> GetServerSnapshot();
    public abstract virtual ServerEndPoint GetServerEndPoint(EndPoint endpoint);
    public abstract virtual ConfigurationOptions get_RawConfig();
    public abstract virtual Nullable`1<long> GetConnectionId(EndPoint endPoint, ConnectionType type);
    public abstract virtual ServerSelectionStrategy get_ServerSelectionStrategy();
    public abstract virtual int GetSubscriptionsCount();
    public abstract virtual ConcurrentDictionary`2<RedisChannel, Subscription> GetSubscriptions();
    public abstract virtual ConnectionMultiplexer get_UnderlyingMultiplexer();
}
[NullableContextAttribute("1")]
internal interface StackExchange.Redis.IMultiMessage {
    public abstract virtual IEnumerable`1<Message> GetMessages(PhysicalConnection connection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.InternalErrorEventArgs : EventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<InternalErrorEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    public ConnectionType ConnectionType { get; }
    [NullableAttribute("2")]
public EndPoint EndPoint { get; }
    public Exception Exception { get; }
    [NullableAttribute("2")]
public string Origin { get; }
    internal InternalErrorEventArgs(EventHandler`1<InternalErrorEventArgs> handler, object sender, EndPoint endpoint, ConnectionType connectionType, Exception exception, string origin);
    public InternalErrorEventArgs(object sender, EndPoint endpoint, ConnectionType connectionType, Exception exception, string origin);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Origin();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
public interface StackExchange.Redis.IReconnectRetryPolicy {
    public abstract virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
public interface StackExchange.Redis.IRedis {
    public abstract virtual TimeSpan Ping(CommandFlags flags);
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.IRedisAsync {
    public IConnectionMultiplexer Multiplexer { get; }
    public abstract virtual IConnectionMultiplexer get_Multiplexer();
    public abstract virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public abstract virtual bool TryWait(Task task);
    public abstract virtual void Wait(Task task);
    public abstract virtual T Wait(Task`1<T> task);
    public abstract virtual void WaitAll(Task[] tasks);
}
[NullableContextAttribute("1")]
internal interface StackExchange.Redis.IResultBox {
    public bool IsAsync { get; }
    public bool IsFaulted { get; }
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsFaulted();
    public abstract virtual void SetException(Exception ex);
    public abstract virtual void ActivateContinuations();
    public abstract virtual void Cancel();
}
[NullableContextAttribute("2")]
internal interface StackExchange.Redis.IResultBox`1 {
    public abstract virtual T GetResult(Exception& ex, bool canRecycle);
    [NullableContextAttribute("1")]
public abstract virtual void SetResult(T value);
}
public interface StackExchange.Redis.IScanningCursor {
    public long Cursor { get; }
    public int PageSize { get; }
    public int PageOffset { get; }
    public abstract virtual long get_Cursor();
    public abstract virtual int get_PageSize();
    public abstract virtual int get_PageOffset();
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.IServer {
    [NullableAttribute("2")]
public ClusterConfiguration ClusterConfiguration { get; }
    public EndPoint EndPoint { get; }
    public RedisFeatures Features { get; }
    public bool IsConnected { get; }
    public RedisProtocol Protocol { get; }
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use IsReplica instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool IsSlave { get; }
    public bool IsReplica { get; }
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use AllowReplicaWrites instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool AllowSlaveWrites { get; public set; }
    public bool AllowReplicaWrites { get; public set; }
    public ServerType ServerType { get; }
    public Version Version { get; }
    public int DatabaseCount { get; }
    [NullableContextAttribute("2")]
public abstract virtual ClusterConfiguration get_ClusterConfiguration();
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual RedisFeatures get_Features();
    public abstract virtual bool get_IsConnected();
    public abstract virtual RedisProtocol get_Protocol();
    public abstract virtual bool get_IsSlave();
    public abstract virtual bool get_IsReplica();
    public abstract virtual bool get_AllowSlaveWrites();
    public abstract virtual void set_AllowSlaveWrites(bool value);
    public abstract virtual bool get_AllowReplicaWrites();
    public abstract virtual void set_AllowReplicaWrites(bool value);
    public abstract virtual ServerType get_ServerType();
    public abstract virtual Version get_Version();
    public abstract virtual int get_DatabaseCount();
    public abstract virtual void ClientKill(EndPoint endpoint, CommandFlags flags);
    public abstract virtual Task ClientKillAsync(EndPoint endpoint, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual long ClientKill(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public abstract virtual Task`1<long> ClientKillAsync(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public abstract virtual long ClientKill(ClientKillFilter filter, CommandFlags flags);
    public abstract virtual Task`1<long> ClientKillAsync(ClientKillFilter filter, CommandFlags flags);
    public abstract virtual ClientInfo[] ClientList(CommandFlags flags);
    public abstract virtual Task`1<ClientInfo[]> ClientListAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual ClusterConfiguration ClusterNodes(CommandFlags flags);
    public abstract virtual Task`1<ClusterConfiguration> ClusterNodesAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string ClusterNodesRaw(CommandFlags flags);
    public abstract virtual Task`1<string> ClusterNodesRawAsync(CommandFlags flags);
    public abstract virtual KeyValuePair`2[] ConfigGet(RedisValue pattern, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[]> ConfigGetAsync(RedisValue pattern, CommandFlags flags);
    public abstract virtual void ConfigResetStatistics(CommandFlags flags);
    public abstract virtual Task ConfigResetStatisticsAsync(CommandFlags flags);
    public abstract virtual void ConfigRewrite(CommandFlags flags);
    public abstract virtual Task ConfigRewriteAsync(CommandFlags flags);
    public abstract virtual void ConfigSet(RedisValue setting, RedisValue value, CommandFlags flags);
    public abstract virtual Task ConfigSetAsync(RedisValue setting, RedisValue value, CommandFlags flags);
    public abstract virtual long CommandCount(CommandFlags flags);
    public abstract virtual Task`1<long> CommandCountAsync(CommandFlags flags);
    public abstract virtual RedisKey[] CommandGetKeys(RedisValue[] command, CommandFlags flags);
    public abstract virtual Task`1<RedisKey[]> CommandGetKeysAsync(RedisValue[] command, CommandFlags flags);
    public abstract virtual String[] CommandList(Nullable`1<RedisValue> moduleName, Nullable`1<RedisValue> category, Nullable`1<RedisValue> pattern, CommandFlags flags);
    public abstract virtual Task`1<String[]> CommandListAsync(Nullable`1<RedisValue> moduleName, Nullable`1<RedisValue> category, Nullable`1<RedisValue> pattern, CommandFlags flags);
    public abstract virtual long DatabaseSize(int database, CommandFlags flags);
    public abstract virtual Task`1<long> DatabaseSizeAsync(int database, CommandFlags flags);
    public abstract virtual RedisValue Echo(RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<RedisValue> EchoAsync(RedisValue message, CommandFlags flags);
    public abstract virtual RedisResult Execute(string command, Object[] args);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public abstract virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public abstract virtual void FlushAllDatabases(CommandFlags flags);
    public abstract virtual Task FlushAllDatabasesAsync(CommandFlags flags);
    public abstract virtual void FlushDatabase(int database, CommandFlags flags);
    public abstract virtual Task FlushDatabaseAsync(int database, CommandFlags flags);
    public abstract virtual ServerCounters GetCounters();
    public abstract virtual IGrouping`2[] Info(RedisValue section, CommandFlags flags);
    public abstract virtual Task`1<IGrouping`2[]> InfoAsync(RedisValue section, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string InfoRaw(RedisValue section, CommandFlags flags);
    public abstract virtual Task`1<string> InfoRawAsync(RedisValue section, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisKey> Keys(int database, RedisValue pattern, int pageSize, CommandFlags flags);
    public abstract virtual IEnumerable`1<RedisKey> Keys(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual IAsyncEnumerable`1<RedisKey> KeysAsync(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public abstract virtual DateTime LastSave(CommandFlags flags);
    public abstract virtual Task`1<DateTime> LastSaveAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Please use MakePrimaryAsync, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void MakeMaster(ReplicationChangeOptions options, TextWriter log);
    public abstract virtual Task MakePrimaryAsync(ReplicationChangeOptions options, TextWriter log);
    public abstract virtual Role Role(CommandFlags flags);
    public abstract virtual Task`1<Role> RoleAsync(CommandFlags flags);
    public abstract virtual void Save(SaveType type, CommandFlags flags);
    public abstract virtual Task SaveAsync(SaveType type, CommandFlags flags);
    public abstract virtual bool ScriptExists(string script, CommandFlags flags);
    public abstract virtual Task`1<bool> ScriptExistsAsync(string script, CommandFlags flags);
    public abstract virtual bool ScriptExists(Byte[] sha1, CommandFlags flags);
    public abstract virtual Task`1<bool> ScriptExistsAsync(Byte[] sha1, CommandFlags flags);
    public abstract virtual void ScriptFlush(CommandFlags flags);
    public abstract virtual Task ScriptFlushAsync(CommandFlags flags);
    public abstract virtual Byte[] ScriptLoad(string script, CommandFlags flags);
    public abstract virtual Task`1<Byte[]> ScriptLoadAsync(string script, CommandFlags flags);
    public abstract virtual LoadedLuaScript ScriptLoad(LuaScript script, CommandFlags flags);
    public abstract virtual Task`1<LoadedLuaScript> ScriptLoadAsync(LuaScript script, CommandFlags flags);
    public abstract virtual void Shutdown(ShutdownMode shutdownMode, CommandFlags flags);
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use ReplicaOfAsync instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void SlaveOf(EndPoint master, CommandFlags flags);
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use ReplicaOfAsync instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task SlaveOfAsync(EndPoint master, CommandFlags flags);
    [ObsoleteAttribute("Please use ReplicaOfAsync, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void ReplicaOf(EndPoint master, CommandFlags flags);
    public abstract virtual Task ReplicaOfAsync(EndPoint master, CommandFlags flags);
    public abstract virtual CommandTrace[] SlowlogGet(int count, CommandFlags flags);
    public abstract virtual Task`1<CommandTrace[]> SlowlogGetAsync(int count, CommandFlags flags);
    public abstract virtual void SlowlogReset(CommandFlags flags);
    public abstract virtual Task SlowlogResetAsync(CommandFlags flags);
    public abstract virtual RedisChannel[] SubscriptionChannels(RedisChannel pattern, CommandFlags flags);
    public abstract virtual Task`1<RedisChannel[]> SubscriptionChannelsAsync(RedisChannel pattern, CommandFlags flags);
    public abstract virtual long SubscriptionPatternCount(CommandFlags flags);
    public abstract virtual Task`1<long> SubscriptionPatternCountAsync(CommandFlags flags);
    public abstract virtual long SubscriptionSubscriberCount(RedisChannel channel, CommandFlags flags);
    public abstract virtual Task`1<long> SubscriptionSubscriberCountAsync(RedisChannel channel, CommandFlags flags);
    public abstract virtual void SwapDatabases(int first, int second, CommandFlags flags);
    public abstract virtual Task SwapDatabasesAsync(int first, int second, CommandFlags flags);
    public abstract virtual DateTime Time(CommandFlags flags);
    public abstract virtual Task`1<DateTime> TimeAsync(CommandFlags flags);
    public abstract virtual string LatencyDoctor(CommandFlags flags);
    public abstract virtual Task`1<string> LatencyDoctorAsync(CommandFlags flags);
    public abstract virtual long LatencyReset(String[] eventNames, CommandFlags flags);
    public abstract virtual Task`1<long> LatencyResetAsync(String[] eventNames, CommandFlags flags);
    public abstract virtual LatencyHistoryEntry[] LatencyHistory(string eventName, CommandFlags flags);
    public abstract virtual Task`1<LatencyHistoryEntry[]> LatencyHistoryAsync(string eventName, CommandFlags flags);
    public abstract virtual LatencyLatestEntry[] LatencyLatest(CommandFlags flags);
    public abstract virtual Task`1<LatencyLatestEntry[]> LatencyLatestAsync(CommandFlags flags);
    public abstract virtual string MemoryDoctor(CommandFlags flags);
    public abstract virtual Task`1<string> MemoryDoctorAsync(CommandFlags flags);
    public abstract virtual void MemoryPurge(CommandFlags flags);
    public abstract virtual Task MemoryPurgeAsync(CommandFlags flags);
    public abstract virtual RedisResult MemoryStats(CommandFlags flags);
    public abstract virtual Task`1<RedisResult> MemoryStatsAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual string MemoryAllocatorStats(CommandFlags flags);
    public abstract virtual Task`1<string> MemoryAllocatorStatsAsync(CommandFlags flags);
    public abstract virtual EndPoint SentinelGetMasterAddressByName(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> SentinelGetMasterAddressByNameAsync(string serviceName, CommandFlags flags);
    public abstract virtual EndPoint[] SentinelGetSentinelAddresses(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<EndPoint[]> SentinelGetSentinelAddressesAsync(string serviceName, CommandFlags flags);
    public abstract virtual EndPoint[] SentinelGetReplicaAddresses(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<EndPoint[]> SentinelGetReplicaAddressesAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[] SentinelMaster(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[]> SentinelMasterAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[][] SentinelMasters(CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[][]> SentinelMastersAsync(CommandFlags flags);
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use SentinelReplicas instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual KeyValuePair`2[][] SentinelSlaves(string serviceName, CommandFlags flags);
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use SentinelReplicasAsync instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<KeyValuePair`2[][]> SentinelSlavesAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[][] SentinelReplicas(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[][]> SentinelReplicasAsync(string serviceName, CommandFlags flags);
    public abstract virtual void SentinelFailover(string serviceName, CommandFlags flags);
    public abstract virtual Task SentinelFailoverAsync(string serviceName, CommandFlags flags);
    public abstract virtual KeyValuePair`2[][] SentinelSentinels(string serviceName, CommandFlags flags);
    public abstract virtual Task`1<KeyValuePair`2[][]> SentinelSentinelsAsync(string serviceName, CommandFlags flags);
}
[ExtensionAttribute]
internal static class StackExchange.Redis.IServerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void SimulateConnectionFailure(IServer server, SimulatedFailureType failureType);
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.ISubscriber {
    [NullableContextAttribute("2")]
public abstract virtual EndPoint IdentifyEndpoint(RedisChannel channel, CommandFlags flags);
    public abstract virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisChannel channel, CommandFlags flags);
    public abstract virtual bool IsConnected(RedisChannel channel);
    public abstract virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public abstract virtual void Subscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual Task SubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual ChannelMessageQueue Subscribe(RedisChannel channel, CommandFlags flags);
    public abstract virtual Task`1<ChannelMessageQueue> SubscribeAsync(RedisChannel channel, CommandFlags flags);
    [NullableContextAttribute("2")]
public abstract virtual EndPoint SubscribedEndpoint(RedisChannel channel);
    [NullableContextAttribute("2")]
public abstract virtual void Unsubscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual Task UnsubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public abstract virtual void UnsubscribeAll(CommandFlags flags);
    public abstract virtual Task UnsubscribeAllAsync(CommandFlags flags);
}
public interface StackExchange.Redis.ITransaction {
    [NullableContextAttribute("1")]
public abstract virtual ConditionResult AddCondition(Condition condition);
    public abstract virtual bool Execute(CommandFlags flags);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
}
[ExtensionAttribute]
public static class StackExchange.Redis.KeyspaceIsolation.DatabaseExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IDatabase WithKeyPrefix(IDatabase database, RedisKey keyPrefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.KeyspaceIsolation.KeyPrefixed`1 : object {
    [CompilerGeneratedAttribute]
private TInner <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Prefix>k__BackingField;
    [NullableAttribute("2")]
private Func`2<RedisKey, RedisKey> mapFunction;
    public IConnectionMultiplexer Multiplexer { get; }
    internal TInner Inner { get; }
    internal Byte[] Prefix { get; }
    internal KeyPrefixed`1(TInner inner, Byte[] keyPrefix);
    public sealed virtual IConnectionMultiplexer get_Multiplexer();
    [CompilerGeneratedAttribute]
internal TInner get_Inner();
    [CompilerGeneratedAttribute]
internal Byte[] get_Prefix();
    public sealed virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public sealed virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> HashFieldGetExpireDateTimeAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<PersistResult[]> HashFieldPersistAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> HashFieldGetTimeToLiveAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<Lease`1<byte>> HashGetLeaseAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashRandomFieldAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashRandomFieldsAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashRandomFieldsWithValuesAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual IAsyncEnumerable`1<HashEntry> HashScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual IAsyncEnumerable`1<RedisValue> HashScanNoValuesAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> HashStringLengthAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyCopyAsync(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public sealed virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<string> KeyEncodingAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyExistsAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<DateTime>> KeyExpireTimeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> KeyFrequencyAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyIdleTimeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> KeyRefCountAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListLeftPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<ListPopResult> ListLeftPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual Task`1<long> ListPositionAsync(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> ListPositionsAsync(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListMoveAsync(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRightPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<ListPopResult> ListRightPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<string> StringLongestCommonSubsequenceAsync(RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> StringLongestCommonSubsequenceLengthAsync(RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<LCSMatchResult> StringLongestCommonSubsequenceWithMatchesAsync(RedisKey first, RedisKey second, long minLength, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<Boolean[]> SetContainsAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual IAsyncEnumerable`1<RedisValue> SetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen updateWhen, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, SortedSetWhen updateWhen, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetCombineAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetCombineWithScoresAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SortedSetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRandomMembersWithScoresAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRangeAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> SortedSetScoresAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual IAsyncEnumerable`1<SortedSetEntry> SortedSetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetUpdateAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen updateWhen, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetUpdateAsync(RedisKey key, RedisValue member, double score, SortedSetWhen updateWhen, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<SortedSetEntry>> SortedSetPopAsync(RedisKey key, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetPopAsync(RedisKey key, long count, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetPopResult> SortedSetPopAsync(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public sealed virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public sealed virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<StreamAutoClaimResult> StreamAutoClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamAutoClaimIdsOnlyResult> StreamAutoClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StreamClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamConsumerGroupSetPositionAsync(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public sealed virtual Task`1<StreamInfo> StreamInfoAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<StreamGroupInfo[]> StreamGroupInfoAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<StreamConsumerInfo[]> StreamConsumerInfoAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<long> StreamLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> StreamDeleteAsync(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<long> StreamDeleteConsumerAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamDeleteConsumerGroupAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<StreamPendingInfo> StreamPendingAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<StreamPendingMessageInfo[]> StreamPendingMessagesAsync(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamRangeAsync(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadAsync(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadAsync(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public sealed virtual Task`1<long> StreamTrimAsync(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, DateTime expiry, CommandFlags flags);
    public sealed virtual Task`1<Lease`1<byte>> StringGetLeaseAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool bit, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public sealed virtual Task`1<long> KeyTouchAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyTouchAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool TryWait(Task task);
    public sealed virtual TResult Wait(Task`1<TResult> task);
    public sealed virtual void Wait(Task task);
    public sealed virtual void WaitAll(Task[] tasks);
    protected internal RedisKey ToInner(RedisKey outer);
    protected RedisKey ToInnerOrDefault(RedisKey outer);
    protected ICollection`1<object> ToInner(ICollection`1<object> args);
    [NullableContextAttribute("2")]
protected RedisKey[] ToInner(RedisKey[] outer);
    [NullableContextAttribute("0")]
protected KeyValuePair`2<RedisKey, RedisValue> ToInner(KeyValuePair`2<RedisKey, RedisValue> outer);
    protected KeyValuePair`2[] ToInner(KeyValuePair`2[] outer);
    protected RedisValue ToInner(RedisValue outer);
    protected RedisValue SortByToInner(RedisValue outer);
    protected RedisValue SortGetToInner(RedisValue outer);
    [NullableContextAttribute("2")]
protected RedisValue[] SortGetToInner(RedisValue[] outer);
    protected RedisChannel ToInner(RedisChannel outer);
    protected Func`2<RedisKey, RedisKey> GetMapFunction();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class StackExchange.Redis.KeyspaceIsolation.KeyPrefixedBatch : KeyPrefixed`1<IBatch> {
    [NullableContextAttribute("1")]
public KeyPrefixedBatch(IBatch inner, Byte[] prefix);
    public sealed virtual void Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class StackExchange.Redis.KeyspaceIsolation.KeyPrefixedDatabase : KeyPrefixed`1<IDatabase> {
    public int Database { get; }
    public KeyPrefixedDatabase(IDatabase inner, Byte[] prefix);
    public sealed virtual IBatch CreateBatch(object asyncState);
    public sealed virtual ITransaction CreateTransaction(object asyncState);
    public sealed virtual int get_Database();
    public sealed virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual long GeoAdd(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public sealed virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoSearch(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoSearch(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Int64[] HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual PersistResult[] HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Int64[] HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual Lease`1<byte> HashGetLease(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public sealed virtual long HashLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue HashRandomField(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] HashRandomFields(RedisKey key, long count, CommandFlags flags);
    public sealed virtual HashEntry[] HashRandomFieldsWithValues(RedisKey key, long count, CommandFlags flags);
    public sealed virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyCopy(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public sealed virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string KeyEncoding(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyExists(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Nullable`1<DateTime> KeyExpireTime(RedisKey key, CommandFlags flags);
    public sealed virtual Nullable`1<long> KeyFrequency(RedisKey key, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyIdleTime(RedisKey key, CommandFlags flags);
    public sealed virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public sealed virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public sealed virtual RedisKey KeyRandom(CommandFlags flags);
    public sealed virtual Nullable`1<long> KeyRefCount(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public sealed virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public sealed virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListLeftPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual ListPopResult ListLeftPop(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual long ListPosition(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Int64[] ListPositions(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListMove(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public sealed virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListRightPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual ListPopResult ListRightPop(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public sealed virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string StringLongestCommonSubsequence(RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long StringLongestCommonSubsequenceLength(RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual LCSMatchResult StringLongestCommonSubsequenceWithMatches(RedisKey first, RedisKey second, long minLength, CommandFlags flags);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual RedisResult Execute(string command, Object[] args);
    public sealed virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluateReadOnly(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluateReadOnly(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Boolean[] SetContains(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long SetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual long SetLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public sealed virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetCombine(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetCombineWithScores(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual long SortedSetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue SortedSetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRandomMembersWithScores(RedisKey key, long count, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual long SortedSetRangeAndStore(RedisKey destinationKey, RedisKey sourceKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] SortedSetScores(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual long SortedSetUpdate(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual bool SortedSetUpdate(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual Nullable`1<SortedSetEntry> SortedSetPop(RedisKey key, Order order, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetPop(RedisKey key, long count, Order order, CommandFlags flags);
    public sealed virtual SortedSetPopResult SortedSetPop(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public sealed virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public sealed virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual RedisValue StreamAdd(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual RedisValue StreamAdd(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual StreamAutoClaimResult StreamAutoClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamAutoClaimIdsOnlyResult StreamAutoClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual RedisValue[] StreamClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual bool StreamConsumerGroupSetPosition(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public sealed virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public sealed virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public sealed virtual StreamInfo StreamInfo(RedisKey key, CommandFlags flags);
    public sealed virtual StreamGroupInfo[] StreamGroupInfo(RedisKey key, CommandFlags flags);
    public sealed virtual StreamConsumerInfo[] StreamConsumerInfo(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual long StreamLength(RedisKey key, CommandFlags flags);
    public sealed virtual long StreamDelete(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual long StreamDeleteConsumer(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public sealed virtual bool StreamDeleteConsumerGroup(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual StreamPendingInfo StreamPending(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual StreamPendingMessageInfo[] StreamPendingMessages(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamRange(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamRead(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual RedisStream[] StreamRead(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public sealed virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public sealed virtual long StreamTrim(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    public sealed virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue StringGetSetExpiry(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual RedisValue StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual Lease`1<byte> StringGetLease(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue StringGetDelete(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public sealed virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual long StringLength(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual bool StringSetBit(RedisKey key, long offset, bool bit, CommandFlags flags);
    public sealed virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual TimeSpan Ping(CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.HashScanNoValues(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual bool KeyTouch(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyTouch(RedisKey[] keys, CommandFlags flags);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class StackExchange.Redis.KeyspaceIsolation.KeyPrefixedTransaction : KeyPrefixed`1<ITransaction> {
    [NullableContextAttribute("1")]
public KeyPrefixedTransaction(ITransaction inner, Byte[] prefix);
    [NullableContextAttribute("1")]
public sealed virtual ConditionResult AddCondition(Condition condition);
    public sealed virtual bool Execute(CommandFlags flags);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
    public sealed virtual void Execute();
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.LatencyHistoryEntry : ValueType {
    [NullableAttribute("1")]
internal static ResultProcessor`1<LatencyHistoryEntry[]> ToArray;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DurationMilliseconds>k__BackingField;
    public DateTime Timestamp { get; }
    public int DurationMilliseconds { get; }
    internal LatencyHistoryEntry(long timestamp, long duration);
    private static LatencyHistoryEntry();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public int get_DurationMilliseconds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.LatencyLatestEntry : ValueType {
    internal static ResultProcessor`1<LatencyLatestEntry[]> ToArray;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DurationMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDurationMilliseconds>k__BackingField;
    public string EventName { get; }
    public DateTime Timestamp { get; }
    public int DurationMilliseconds { get; }
    public int MaxDurationMilliseconds { get; }
    internal LatencyLatestEntry(string eventName, long timestamp, long duration, long maxDuration);
    private static LatencyLatestEntry();
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public int get_DurationMilliseconds();
    [CompilerGeneratedAttribute]
public int get_MaxDurationMilliseconds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.LCSMatchResult : ValueType {
    [CompilerGeneratedAttribute]
private static LCSMatchResult <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private LCSMatch[] <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LongestMatchLength>k__BackingField;
    internal static LCSMatchResult Null { get; }
    public bool IsEmpty { get; }
    public LCSMatch[] Matches { get; }
    public long LongestMatchLength { get; }
    internal LCSMatchResult(LCSMatch[] matches, long matchLength);
    private static LCSMatchResult();
    [CompilerGeneratedAttribute]
internal static LCSMatchResult get_Null();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public LCSMatch[] get_Matches();
    [CompilerGeneratedAttribute]
public long get_LongestMatchLength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.Lease`1 : object {
    [CompilerGeneratedAttribute]
private static Lease`1<T> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] _arr;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public static Lease`1<T> Empty { get; }
    public int Length { get; }
    private T[] Array { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ArraySegment`1<T> ArraySegment { get; }
    private Lease`1(T[] arr, int length);
    private static Lease`1();
    [CompilerGeneratedAttribute]
public static Lease`1<T> get_Empty();
    [CompilerGeneratedAttribute]
public int get_Length();
    public static Lease`1<T> Create(int length, bool clear);
    public sealed virtual void Dispose();
    private static T[] ThrowDisposed();
    private T[] get_Array();
    public sealed virtual Memory`1<T> get_Memory();
    public Span`1<T> get_Span();
    public ArraySegment`1<T> get_ArraySegment();
}
public class StackExchange.Redis.LinearRetry : object {
    private int maxRetryElapsedTimeAllowedMilliseconds;
    public LinearRetry(int maxRetryElapsedTimeAllowedMilliseconds);
    public sealed virtual bool ShouldRetry(long currentRetryCount, int timeElapsedMillisecondsSinceLastRetry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.ListPopResult : ValueType {
    [CompilerGeneratedAttribute]
private static ListPopResult <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue[] <Values>k__BackingField;
    public static ListPopResult Null { get; }
    public bool IsNull { get; }
    public RedisKey Key { get; }
    public RedisValue[] Values { get; }
    internal ListPopResult(RedisKey key, RedisValue[] values);
    private static ListPopResult();
    [CompilerGeneratedAttribute]
public static ListPopResult get_Null();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
public RedisKey get_Key();
    [CompilerGeneratedAttribute]
public RedisValue[] get_Values();
}
public enum StackExchange.Redis.ListSide : Enum {
    public int value__;
    public static ListSide Left;
    public static ListSide Right;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ListSideExtensions : object {
    [ExtensionAttribute]
internal static RedisValue ToLiteral(ListSide side);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.LoadedLuaScript : object {
    [CompilerGeneratedAttribute]
private Byte[] <Hash>k__BackingField;
    internal LuaScript Original;
    public string OriginalScript { get; }
    public string ExecutableScript { get; }
    [EditorBrowsableAttribute("1")]
public Byte[] Hash { get; }
    internal LoadedLuaScript(LuaScript original, Byte[] hash);
    public string get_OriginalScript();
    public string get_ExecutableScript();
    [CompilerGeneratedAttribute]
public Byte[] get_Hash();
    public RedisResult Evaluate(IDatabase db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public Task`1<RedisResult> EvaluateAsync(IDatabaseAsync db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.LoggingMessage : Message {
    public ILogger log;
    private Message tail;
    public string CommandAndKey { get; }
    public int ArgCount { get; }
    public ILogger Log { get; }
    private LoggingMessage(ILogger log, Message tail);
    public static Message Create(ILogger log, Message tail);
    public virtual string get_CommandAndKey();
    public virtual void AppendStormLog(StringBuilder sb);
    public virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    protected virtual void WriteImpl(PhysicalConnection physical);
    public virtual int get_ArgCount();
    public ILogger get_Log();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.LuaScript : object {
    private static ConcurrentDictionary`2<string, WeakReference> Cache;
    [CompilerGeneratedAttribute]
private string <OriginalScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutableScript>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [NullableAttribute("2")]
private Hashtable ParameterMappers;
    public string OriginalScript { get; }
    public string ExecutableScript { get; }
    internal String[] Arguments { get; }
    private bool HasArguments { get; }
    internal LuaScript(string originalScript, string executableScript, String[] arguments);
    private static LuaScript();
    [CompilerGeneratedAttribute]
public string get_OriginalScript();
    [CompilerGeneratedAttribute]
public string get_ExecutableScript();
    [CompilerGeneratedAttribute]
internal String[] get_Arguments();
    private bool get_HasArguments();
    protected virtual override void Finalize();
    public static void PurgeCache();
    public static int GetCachedScriptCount();
    public static LuaScript Prepare(string script);
    [NullableContextAttribute("2")]
internal void ExtractParameters(object ps, Nullable`1<RedisKey> keyPrefix, RedisKey[]& keys, RedisValue[]& args);
    public RedisResult Evaluate(IDatabase db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public Task`1<RedisResult> EvaluateAsync(IDatabaseAsync db, object ps, Nullable`1<RedisKey> withKeyPrefix, CommandFlags flags);
    public LoadedLuaScript Load(IServer server, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.LuaScript/<LoadAsync>d__22")]
public Task`1<LoadedLuaScript> LoadAsync(IServer server, CommandFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.Maintenance.AzureMaintenanceEvent : ServerMaintenanceEvent {
    private static string PubSubChannelName;
    [CompilerGeneratedAttribute]
private string <NotificationTypeString>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureNotificationType <NotificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReplica>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPAddress <IPAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SslPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NonSslPort>k__BackingField;
    public string NotificationTypeString { get; }
    public AzureNotificationType NotificationType { get; }
    public bool IsReplica { get; }
    [NullableAttribute("2")]
public IPAddress IPAddress { get; }
    public int SslPort { get; }
    public int NonSslPort { get; }
    [NullableContextAttribute("2")]
internal AzureMaintenanceEvent(string azureEvent);
    [AsyncStateMachineAttribute("StackExchange.Redis.Maintenance.AzureMaintenanceEvent/<AddListenerAsync>d__2")]
internal static Task AddListenerAsync(ConnectionMultiplexer multiplexer, Action`1<string> log);
    [CompilerGeneratedAttribute]
public string get_NotificationTypeString();
    [CompilerGeneratedAttribute]
public AzureNotificationType get_NotificationType();
    [CompilerGeneratedAttribute]
public bool get_IsReplica();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPAddress get_IPAddress();
    [CompilerGeneratedAttribute]
public int get_SslPort();
    [CompilerGeneratedAttribute]
public int get_NonSslPort();
    private static AzureNotificationType ParseNotificationType(string typeString);
}
public enum StackExchange.Redis.Maintenance.AzureNotificationType : Enum {
    public int value__;
    public static AzureNotificationType Unknown;
    public static AzureNotificationType NodeMaintenanceScheduled;
    public static AzureNotificationType NodeMaintenanceStarting;
    public static AzureNotificationType NodeMaintenanceStart;
    public static AzureNotificationType NodeMaintenanceEnded;
    public static AzureNotificationType NodeMaintenanceFailoverComplete;
    public static AzureNotificationType NodeMaintenanceScaleComplete;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.Maintenance.ServerMaintenanceEvent : object {
    [CompilerGeneratedAttribute]
private string <RawMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ReceivedTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartTimeUtc>k__BackingField;
    public string RawMessage { get; protected set; }
    public DateTime ReceivedTimeUtc { get; }
    public Nullable`1<DateTime> StartTimeUtc { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_RawMessage();
    [CompilerGeneratedAttribute]
protected void set_RawMessage(string value);
    [CompilerGeneratedAttribute]
public DateTime get_ReceivedTimeUtc();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartTimeUtc();
    [CompilerGeneratedAttribute]
protected void set_StartTimeUtc(Nullable`1<DateTime> value);
    public virtual string ToString();
    [NullableContextAttribute("1")]
protected void NotifyMultiplexer(ConnectionMultiplexer multiplexer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class StackExchange.Redis.Message : object {
    public int Db;
    private UInt32 _highIntegrityToken;
    internal static CommandFlags InternalCallFlag;
    protected RedisCommand command;
    private static CommandFlags AskingFlag;
    private static CommandFlags ScriptUnavailableFlag;
    private static CommandFlags DemandSubscriptionConnection;
    private static CommandFlags MaskPrimaryServerPreference;
    private static CommandFlags UserSelectableFlags;
    [NullableAttribute("2")]
private IResultBox resultBox;
    [NullableAttribute("2")]
private ResultProcessor resultProcessor;
    [NullableAttribute("2")]
private ProfiledCommand performance;
    internal DateTime CreatedDateTime;
    internal long CreatedTimestamp;
    [CompilerGeneratedAttribute]
private CommandFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandStatus <Status>k__BackingField;
    [NullableAttribute("2")]
private PhysicalConnection _enqueuedTo;
    private long _queuedStampReceived;
    private long _queuedStampSent;
    private int _writeTickCount;
    public CommandFlags Flags { get; internal set; }
    internal CommandStatus Status { get; private set; }
    public RedisCommand Command { get; }
    public string CommandAndKey { get; }
    public bool IsAdmin { get; }
    public bool IsAsking { get; }
    public bool IsHighIntegrity { get; }
    public UInt32 HighIntegrityToken { get; }
    internal bool IsScriptUnavailable { get; }
    public bool IsFireAndForget { get; }
    public bool IsInternalCall { get; }
    [NullableAttribute("2")]
public IResultBox ResultBox { get; }
    public int ArgCount { get; }
    internal bool ResultBoxIsAsync { get; }
    internal bool IsBacklogged { get; }
    internal bool IsForSubscriptionBridge { get; }
    public string CommandString { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> ChecksumTemplate { get; }
    protected Message(int db, CommandFlags flags, RedisCommand command);
    internal void SetPrimaryOnly();
    internal void SetProfileStorage(ProfiledCommand storage);
    internal void PrepareToResend(ServerEndPoint resendTo, bool isMoved);
    [CompilerGeneratedAttribute]
public CommandFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(CommandFlags value);
    [CompilerGeneratedAttribute]
internal CommandStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(CommandStatus value);
    public RedisCommand get_Command();
    public virtual string get_CommandAndKey();
    public bool get_IsAdmin();
    public bool get_IsAsking();
    public bool get_IsHighIntegrity();
    public UInt32 get_HighIntegrityToken();
    internal void WithHighIntegrity(UInt32 value);
    internal bool get_IsScriptUnavailable();
    internal void SetScriptUnavailable();
    public bool get_IsFireAndForget();
    public bool get_IsInternalCall();
    [NullableContextAttribute("2")]
public IResultBox get_ResultBox();
    public abstract virtual int get_ArgCount();
    public static Message Create(int db, CommandFlags flags, RedisCommand command);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisKey& key2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisChannel& channel);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisChannel& channel, RedisValue& value);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value, RedisChannel& channel);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1, RedisValue& value2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, GeoEntry[] values);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4, RedisValue& value5);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4, RedisValue& value5, RedisValue& value6);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value0, RedisValue& value1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value, RedisKey& key);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value0, RedisValue& value1, RedisValue& value2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1, RedisValue& value2);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4, RedisValue& value5);
    public static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue& value0, RedisValue& value1, RedisValue& value2, RedisValue& value3, RedisValue& value4, RedisValue& value5, RedisValue& value6);
    public static Message CreateInSlot(int db, int slot, CommandFlags flags, RedisCommand command, RedisValue[] values);
    public bool IsPrimaryOnly();
    public virtual void AppendStormLog(StringBuilder sb);
    public virtual int GetHashSlot(ServerSelectionStrategy serverSelectionStrategy);
    public void SetInternalCall();
    public virtual string ToString();
    public string ToStringCommandOnly();
    public void SetResponseReceived();
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
    public void Complete();
    internal bool get_ResultBoxIsAsync();
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisKey[] keys);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, IList`1<RedisKey> keys);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, IList`1<RedisValue> values);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key, RedisValue[] values);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisKey& key1, RedisValue[] values);
    internal static Message Create(int db, CommandFlags flags, RedisCommand command, RedisKey& key0, RedisValue[] values, RedisKey& key1);
    internal static CommandFlags GetPrimaryReplicaFlags(CommandFlags flags);
    internal static bool RequiresDatabase(RedisCommand command);
    internal static CommandFlags SetPrimaryReplicaFlags(CommandFlags everything, CommandFlags primaryReplica);
    internal void Cancel();
    internal bool ComputeResult(PhysicalConnection connection, RawResult& result);
    [NullableContextAttribute("2")]
internal void Fail(ConnectionFailureType failure, Exception innerException, string annotation, ConnectionMultiplexer muxer);
    internal virtual void SetExceptionAndComplete(Exception exception, PhysicalBridge bridge);
    internal bool TrySetResult(T value);
    [NullableContextAttribute("2")]
internal void SetEnqueued(PhysicalConnection connection);
    [NullableContextAttribute("2")]
internal void TryGetHeadMessages(Message& now, Message& next);
    internal bool TryGetPhysicalState(WriteStatus& ws, ReadStatus& rs, Int64& sentDelta, Int64& receivedDelta);
    internal bool get_IsBacklogged();
    internal void SetBacklogged();
    internal void SetRequestSent();
    internal void SetWriteTime();
    public int GetWriteTime();
    internal bool get_IsForSubscriptionBridge();
    public virtual string get_CommandString();
    internal void SetForSubscriptionBridge();
    internal bool HasTimedOut(int now, int timeoutMilliseconds, Int32& millisecondsTaken);
    internal void SetAsking(bool value);
    internal void SetNoRedirect();
    internal void SetPreferPrimary();
    internal void SetPreferReplica();
    [NullableContextAttribute("2")]
internal void SetSource(ResultProcessor resultProcessor, IResultBox resultBox);
    internal void SetSource(IResultBox`1<T> resultBox, ResultProcessor`1<T> resultProcessor);
    protected abstract virtual void WriteImpl(PhysicalConnection physical);
    internal void WriteTo(PhysicalConnection physical);
    [NullableContextAttribute("0")]
private static ReadOnlySpan`1<byte> get_ChecksumTemplate();
    internal void WriteHighIntegrityChecksumRequest(PhysicalConnection physical);
    [NullableContextAttribute("2")]
internal static Message CreateHello(int protocolVersion, string username, string password, string clientName, CommandFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.MessageCompletable : object {
    private RedisChannel channel;
    private Action`2<RedisChannel, RedisValue> handler;
    private RedisValue message;
    public MessageCompletable(RedisChannel channel, RedisValue message, Action`2<RedisChannel, RedisValue> handler);
    [NullableContextAttribute("2")]
public virtual string ToString();
    public sealed virtual bool TryComplete(bool isAsync);
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
}
[FlagsAttribute]
public enum StackExchange.Redis.MigrateOptions : Enum {
    public int value__;
    public static MigrateOptions None;
    public static MigrateOptions Copy;
    public static MigrateOptions Replace;
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.NameValueEntry : ValueType {
    internal RedisValue name;
    internal RedisValue value;
    public RedisValue Name { get; }
    public RedisValue Value { get; }
    public NameValueEntry(RedisValue name, RedisValue value);
    public RedisValue get_Name();
    public RedisValue get_Value();
    public static KeyValuePair`2<RedisValue, RedisValue> op_Implicit(NameValueEntry value);
    public static NameValueEntry op_Implicit(KeyValuePair`2<RedisValue, RedisValue> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NameValueEntry other);
    public static bool op_Equality(NameValueEntry x, NameValueEntry y);
    public static bool op_Inequality(NameValueEntry x, NameValueEntry y);
}
internal class StackExchange.Redis.NothingDisposable : object {
    [NullableAttribute("1")]
public static NothingDisposable Instance;
    private static NothingDisposable();
    public sealed virtual void Dispose();
}
public enum StackExchange.Redis.Order : Enum {
    public int value__;
    public static Order Ascending;
    public static Order Descending;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.OrderExtensions : object {
    [ExtensionAttribute]
internal static RedisValue ToLiteral(Order order);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.PerfCounterHelper : object {
    internal static string GetThreadPoolAndCPUSummary();
    internal static int GetThreadPoolStats(String& iocp, String& worker, String& workItems);
}
public enum StackExchange.Redis.PersistResult : Enum {
    public int value__;
    public static PersistResult Success;
    public static PersistResult ConditionNotMet;
    public static PersistResult NoSuchField;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.PhysicalBridge : object {
    internal string Name;
    private static int ProfileLogSamples;
    private static double ProfileLogSeconds;
    private static Message ReusableAskingCommand;
    private Int64[] profileLog;
    private ConcurrentQueue`1<Message> _backlog;
    private int _backlogProcessorIsRunning;
    private int _backlogCurrentEnqueued;
    private long _backlogTotalEnqueued;
    private int activeWriters;
    private int beating;
    private int failConnectCount;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isDisposed;
    private long nonPreferredEndpointCount;
    private long operationCount;
    private long socketCount;
    [NullableAttribute("2")]
private PhysicalConnection modreq(System.Runtime.CompilerServices.IsVolatile) physical;
    private long profileLastLog;
    private int profileLogIndex;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) reportNextFailure;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) reconfigureNextFailure;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private MutexSlim _singleWriterMutex;
    private UInt32 _nextHighIntegrityToken;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ConnectedAt>k__BackingField;
    private int TimeoutMilliseconds;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionMultiplexer <Multiplexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerEndPoint <ServerEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisCommand <LastCommand>k__BackingField;
    private int connectStartTicks;
    private long connectTimeoutRetryCount;
    [NullableAttribute("2")]
private Message _activeMessage;
    private BacklogStatus modreq(System.Runtime.CompilerServices.IsVolatile) _backlogStatus;
    private AutoResetEvent _backlogAutoReset;
    private bool BacklogHasItems { get; }
    internal Nullable`1<long> ConnectionId { get; }
    [NullableAttribute("2")]
internal string PhysicalName { get; }
    public Nullable`1<DateTime> ConnectedAt { get; private set; }
    [NullableAttribute("2")]
public Exception LastException { get; private set; }
    public ConnectionType ConnectionType { get; }
    public bool IsConnected { get; }
    public bool IsConnecting { get; }
    public ConnectionMultiplexer Multiplexer { get; }
    public ServerEndPoint ServerEndPoint { get; }
    public long SubscriptionCount { get; }
    internal State ConnectionState { get; }
    internal bool IsBeating { get; }
    internal long OperationCount { get; }
    public RedisCommand LastCommand { get; private set; }
    public Nullable`1<RedisProtocol> Protocol { get; }
    public PhysicalBridge(ServerEndPoint serverEndPoint, ConnectionType type, int timeoutMilliseconds);
    private static PhysicalBridge();
    private bool get_BacklogHasItems();
    internal Nullable`1<long> get_ConnectionId();
    [NullableContextAttribute("2")]
internal string get_PhysicalName();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ConnectedAt();
    [CompilerGeneratedAttribute]
private void set_ConnectedAt(Nullable`1<DateTime> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_LastException();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_LastException(Exception value);
    [CompilerGeneratedAttribute]
public ConnectionType get_ConnectionType();
    public bool get_IsConnected();
    public bool get_IsConnecting();
    [CompilerGeneratedAttribute]
public ConnectionMultiplexer get_Multiplexer();
    [CompilerGeneratedAttribute]
public ServerEndPoint get_ServerEndPoint();
    public long get_SubscriptionCount();
    internal State get_ConnectionState();
    internal bool get_IsBeating();
    internal long get_OperationCount();
    [CompilerGeneratedAttribute]
public RedisCommand get_LastCommand();
    [CompilerGeneratedAttribute]
private void set_LastCommand(RedisCommand value);
    public Nullable`1<RedisProtocol> get_Protocol();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public void ReportNextFailure();
    public virtual string ToString();
    private WriteResult QueueOrFailMessage(Message message);
    private WriteResult FailDueToNoConnection(Message message);
    [ObsoleteAttribute("prefer async")]
public WriteResult TryWriteSync(Message message, bool isReplica);
    [NullableContextAttribute("0")]
public ValueTask`1<WriteResult> TryWriteAsync(Message message, bool isReplica, bool bypassBacklog);
    internal void AppendProfile(StringBuilder sb);
    internal void GetCounters(ConnectionCounters counters);
    internal BridgeStatus GetStatus();
    internal string GetStormLog();
    internal void IncrementOpCount();
    internal void KeepAlive(bool forceRun);
    [AsyncStateMachineAttribute("StackExchange.Redis.PhysicalBridge/<OnConnectedAsync>d__83")]
internal Task OnConnectedAsync(PhysicalConnection connection, ILogger log);
    internal void ResetNonConnected();
    internal void OnConnectionFailed(PhysicalConnection connection, ConnectionFailureType failureType, Exception innerException, bool wasRequested);
    [NullableContextAttribute("2")]
internal void OnDisconnected(ConnectionFailureType failureType, PhysicalConnection connection, Boolean& isCurrent, State& oldState);
    private void AbandonPendingBacklog(Exception ex);
    internal void OnFullyEstablished(PhysicalConnection connection, string source);
    internal void OnHeartbeat(bool ifConnectedOnly);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(string message);
    [ConditionalAttribute("VERBOSE")]
internal void Trace(bool condition, string message);
    internal bool TryEnqueue(List`1<Message> messages, bool isReplica);
    private WriteResult WriteMessageInsideLock(PhysicalConnection physical, Message message);
    [ObsoleteAttribute("prefer async")]
internal WriteResult WriteMessageTakingWriteLockSync(PhysicalConnection physical, Message message);
    private bool TryPushToBacklog(Message message, bool onlyIfExists, bool bypassBacklog);
    private void BacklogEnqueue(Message message);
    [NullableContextAttribute("2")]
private bool BacklogTryDequeue(Message& message);
    private void StartBacklogProcessor();
    private void CheckBacklogForTimeouts();
    private void ProcessBacklog();
    private void ProcessBridgeBacklog();
    public bool HasPendingCallerFacingItems();
    private WriteResult TimedOutBeforeWrite(Message message);
    internal ValueTask`1<WriteResult> WriteMessageTakingWriteLockAsync(PhysicalConnection physical, Message message, bool bypassBacklog);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.PhysicalBridge/<WriteMessageTakingWriteLockAsync_Awaited>d__111")]
private ValueTask`1<WriteResult> WriteMessageTakingWriteLockAsync_Awaited(ValueTask`1<LockToken> pending, PhysicalConnection physical, Message message);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.PhysicalBridge/<CompleteWriteAndReleaseLockAsync>d__112")]
private ValueTask`1<WriteResult> CompleteWriteAndReleaseLockAsync(LockToken lockToken, ValueTask`1<WriteResult> flush, Message message);
    private WriteResult HandleWriteException(Message message, Exception ex);
    private void UnmarkActiveMessage(Message message);
    private State ChangeState(State newState);
    private bool ChangeState(State oldState, State newState);
    [NullableContextAttribute("2")]
public PhysicalConnection TryConnect(ILogger log);
    private void LogNonPreferred(CommandFlags flags, bool isReplica);
    private void OnInternalError(Exception exception, string origin);
    private void SelectDatabaseInsideWriteLock(PhysicalConnection connection, Message message);
    private WriteResult WriteMessageToServerInsideWriteLock(PhysicalConnection connection, Message message);
    private UInt32 NextHighIntegrityTokenInsideLock();
    internal void SimulateConnectionFailure(SimulatedFailureType failureType);
    internal Nullable`1<RedisCommand> GetActiveMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.PhysicalConnection : object {
    [NullableAttribute("2")]
internal Byte[] ChannelPrefix;
    private static int DefaultRedisDatabaseCount;
    private static CommandBytes message;
    private static CommandBytes pmessage;
    private static Message[] ReusableChangeDatabaseCommands;
    private static Message ReusableReadOnlyCommand;
    private static Message ReusableReadWriteCommand;
    private static int totalCount;
    private ConnectionType connectionType;
    private Queue`1<Message> _writtenAwaitingResponse;
    [NullableAttribute("2")]
private Message _awaitingToken;
    private string _physicalName;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) currentDatabase;
    private ReadMode currentReadMode;
    private int failureReported;
    private int lastWriteTickCount;
    private int lastReadTickCount;
    private int lastBeatTickCount;
    private long bytesLastResult;
    private long bytesInBuffer;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ConnectionId>k__BackingField;
    [NullableAttribute("2")]
private IDuplexPipe _ioPipe;
    [NullableAttribute("2")]
private Socket _socket;
    [CompilerGeneratedAttribute]
private bool <MultiDatabasesOverride>k__BackingField;
    private WeakReference _bridge;
    [CompilerGeneratedAttribute]
private long <SubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransactionActive>k__BackingField;
    private RedisProtocol _protocol;
    private WriteStatus modreq(System.Runtime.CompilerServices.IsVolatile) _writeStatus;
    internal static int REDIS_MAX_ARGS;
    [NullableAttribute("2")]
private CancellationTokenSource _reusableFlushSyncTokenSource;
    [NullableAttribute("0")]
private static ReadOnlyMemory`1<byte> NullBulkString;
    [NullableAttribute("0")]
private static ReadOnlyMemory`1<byte> EmptyBulkString;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Encoder s_PerThreadEncoder;
    [NullableAttribute("2")]
private Message modreq(System.Runtime.CompilerServices.IsVolatile) _activeMessage;
    private static ArenaOptions s_arenaOptions;
    private Arena`1<RawResult> _arena;
    private ReadStatus modreq(System.Runtime.CompilerServices.IsVolatile) _readStatus;
    internal Nullable`1<long> ConnectionId { get; internal set; }
    internal bool HasOutputPipe { get; }
    [NullableAttribute("2")]
internal Socket VolatileSocket { get; }
    internal bool MultiDatabasesOverride { get; internal set; }
    [NullableAttribute("2")]
public PhysicalBridge BridgeCouldBeNull { get; }
    public long LastReadSecondsAgo { get; }
    public long LastWriteSecondsAgo { get; }
    private bool IncludeDetailInExceptions { get; }
    public long SubscriptionCount { get; public set; }
    public bool TransactionActive { get; internal set; }
    public Nullable`1<RedisProtocol> Protocol { get; }
    public PhysicalConnection(PhysicalBridge bridge);
    private static PhysicalConnection();
    [CompilerGeneratedAttribute]
internal Nullable`1<long> get_ConnectionId();
    [CompilerGeneratedAttribute]
internal void set_ConnectionId(Nullable`1<long> value);
    internal void GetBytes(Int64& sent, Int64& received);
    internal bool get_HasOutputPipe();
    [NullableContextAttribute("2")]
internal Socket get_VolatileSocket();
    [CompilerGeneratedAttribute]
internal bool get_MultiDatabasesOverride();
    [CompilerGeneratedAttribute]
internal void set_MultiDatabasesOverride(bool value);
    [AsyncStateMachineAttribute("StackExchange.Redis.PhysicalConnection/<BeginConnectAsync>d__36")]
internal Task BeginConnectAsync(ILogger log);
    private static CancellationTokenSource ConfigureTimeout(SocketAwaitableEventArgs args, int timeoutMilliseconds);
    [NullableContextAttribute("2")]
public PhysicalBridge get_BridgeCouldBeNull();
    public long get_LastReadSecondsAgo();
    public long get_LastWriteSecondsAgo();
    private bool get_IncludeDetailInExceptions();
    [ConditionalAttribute("VERBOSE")]
internal void Trace(string message);
    [CompilerGeneratedAttribute]
public long get_SubscriptionCount();
    [CompilerGeneratedAttribute]
public void set_SubscriptionCount(long value);
    [CompilerGeneratedAttribute]
public bool get_TransactionActive();
    [CompilerGeneratedAttribute]
internal void set_TransactionActive(bool value);
    public Nullable`1<RedisProtocol> get_Protocol();
    internal void SetProtocol(RedisProtocol value);
    internal void Shutdown();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.PhysicalConnection/<AwaitedFlush>d__63")]
private Task AwaitedFlush(ValueTask`1<FlushResult> flush);
    internal void UpdateLastWriteTime();
    public Task FlushAsync();
    internal void SimulateConnectionFailure(SimulatedFailureType failureType);
    private bool IsRequestedShutdown(PipeShutdownKind kind);
    [NullableContextAttribute("2")]
public void RecordConnectionFailed(ConnectionFailureType failureType, Exception innerException, string origin, bool isInitialConnect, IDuplexPipe connectingPipe);
    [NullableContextAttribute("2")]
private void RecordMessageFailed(Message next, Exception ex, string origin, PhysicalBridge bridge);
    internal bool IsIdle();
    internal void SetIdle();
    internal void SetWriting();
    internal WriteStatus GetWriteStatus();
    public virtual string ToString();
    [NullableContextAttribute("2")]
internal static void IdentifyFailureType(Exception exception, ConnectionFailureType& failureType);
    internal void EnqueueInsideWriteLock(Message next);
    internal void GetCounters(ConnectionCounters counters);
    [NullableContextAttribute("2")]
internal Message GetReadModeCommand(bool isPrimaryOnly);
    internal Message GetSelectDatabaseCommand(int targetDatabase, Message message);
    internal static Message GetSelectDatabaseCommand(int targetDatabase);
    internal int GetSentAwaitingResponseCount();
    internal void GetStormLog(StringBuilder sb);
    internal int OnBridgeHeartbeat();
    internal void OnInternalError(Exception exception, string origin);
    internal void SetUnknownDatabase();
    internal void Write(RedisKey& key);
    internal void Write(RedisChannel& channel);
    internal void WriteBulkString(RedisValue& value);
    [NullableContextAttribute("2")]
internal static void WriteBulkString(RedisValue& value, PipeWriter maybeNullWriter);
    internal void WriteHeader(RedisCommand command, int arguments, CommandBytes commandBytes);
    [NullableContextAttribute("0")]
internal void WriteRaw(ReadOnlySpan`1<byte> bytes);
    internal void RecordQuit();
    internal static void WriteMultiBulkHeader(PipeWriter output, long count);
    [NullableContextAttribute("0")]
internal static int WriteCrlf(Span`1<byte> span, int offset);
    internal static void WriteCrlf(PipeWriter writer);
    [NullableContextAttribute("0")]
internal static int WriteRaw(Span`1<byte> span, long value, bool withLengthPrefix, int offset);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.PhysicalConnection/<FlushAsync_Awaited>d__100")]
private ValueTask`1<WriteResult> FlushAsync_Awaited(PhysicalConnection connection, ValueTask`1<FlushResult> flush, bool throwOnFailure);
    [ObsoleteAttribute("this is an anti-pattern; work to reduce reliance on this is in progress")]
internal WriteResult FlushSync(bool throwOnFailure, int millisecondsTimeout);
    [NullableContextAttribute("0")]
internal ValueTask`1<WriteResult> FlushAsync(bool throwOnFailure, CancellationToken cancellationToken);
    private static void WriteUnifiedBlob(PipeWriter writer, Byte[] value);
    [NullableContextAttribute("0")]
private static void WriteUnifiedSpan(PipeWriter writer, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("0")]
private static int AppendToSpanCommand(Span`1<byte> span, CommandBytes& value, int offset);
    [NullableContextAttribute("0")]
private static int AppendToSpan(Span`1<byte> span, ReadOnlySpan`1<byte> value, int offset);
    internal void WriteSha1AsHex(Byte[] value);
    internal static byte ToHexNibble(int value);
    [NullableContextAttribute("2")]
internal static void WriteUnifiedPrefixedString(PipeWriter maybeNullWriter, Byte[] prefix, string value);
    internal static Encoder GetPerThreadEncoder();
    internal static void WriteRaw(PipeWriter writer, string value, int expectedLength);
    [NullableContextAttribute("2")]
private static void WriteUnifiedPrefixedBlob(PipeWriter maybeNullWriter, Byte[] prefix, Byte[] value);
    private static void WriteUnifiedInt64(PipeWriter writer, long value);
    private static void WriteUnifiedUInt64(PipeWriter writer, ulong value);
    internal static void WriteInteger(PipeWriter writer, long value);
    public ConnectionStatus GetStatus();
    [NullableContextAttribute("2")]
internal static RemoteCertificateValidationCallback GetAmbientIssuerCertificateCallback();
    [NullableContextAttribute("2")]
internal static LocalCertificateSelectionCallback GetAmbientClientCertificateCallback();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("StackExchange.Redis.PhysicalConnection/<ConnectedAsync>d__124")]
internal ValueTask`1<bool> ConnectedAsync(Socket socket, ILogger log, SocketManager manager);
    private void MatchResult(RawResult& result);
    [NullableContextAttribute("2")]
internal void GetHeadMessages(Message& now, Message& next);
    private void OnDebugAbort();
    internal void UpdateLastReadTime();
    [AsyncStateMachineAttribute("StackExchange.Redis.PhysicalConnection/<ReadFromPipe>d__133")]
private Task ReadFromPipe();
    [NullableContextAttribute("0")]
private int ProcessBuffer(ReadOnlySequence`1& buffer);
    private static ResultFlags AsNull(ResultFlags flags);
    [NullableContextAttribute("0")]
private static RawResult ReadArray(ResultType resultType, ResultFlags flags, Arena`1<RawResult> arena, ReadOnlySequence`1& buffer, BufferReader& reader, bool includeDetailInExceptions, ServerEndPoint server);
    [NullableContextAttribute("2")]
private static RawResult ReadBulkString(ResultType type, ResultFlags flags, BufferReader& reader, bool includeDetailInExceptions, ServerEndPoint server);
    private static RawResult ReadLineTerminatedString(ResultType type, ResultFlags flags, BufferReader& reader);
    internal ReadStatus GetReadStatus();
    internal void StartReading();
    [NullableContextAttribute("0")]
internal static RawResult TryParseResult(bool isResp3, Arena`1<RawResult> arena, ReadOnlySequence`1& buffer, BufferReader& reader, bool includeDetilInExceptions, PhysicalConnection connection, bool allowInlineProtocol);
    [NullableContextAttribute("0")]
private static RawResult TryParseResult(ResultFlags flags, Arena`1<RawResult> arena, ReadOnlySequence`1& buffer, BufferReader& reader, bool includeDetilInExceptions, ServerEndPoint server, bool allowInlineProtocol);
    private static RawResult ParseInlineProtocol(ResultFlags flags, Arena`1<RawResult> arena, RawResult& line);
    internal bool HasPendingCallerFacingItems();
    [CompilerGeneratedAttribute]
internal static void <RecordConnectionFailed>g__AddData|68_1(string lk, string sk, string v, <>c__DisplayClass68_0& );
    [CompilerGeneratedAttribute]
internal static bool <RecordConnectionFailed>g__TryDequeueLocked|68_0(Queue`1<Message> queue, Message& message);
    [CompilerGeneratedAttribute]
internal static void <FlushSync>g__ThrowTimeout|102_0();
    [CompilerGeneratedAttribute]
internal static bool <MatchResult>g__ProcessHighIntegrityResponseToken|125_0(Message message, RawResult& result, PhysicalBridge bridge);
    [CompilerGeneratedAttribute]
internal static bool <MatchResult>g__TryGetPubSubPayload|125_1(RawResult& value, RedisValue& parsed, bool allowArraySingleton);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <MatchResult>g__TryGetMultiPubSubPayload|125_2(RawResult& value, Sequence`1& parsed);
}
internal enum StackExchange.Redis.PositionKind : Enum {
    public int value__;
    public static PositionKind Beginning;
    public static PositionKind Explicit;
    public static PositionKind New;
}
[NullableContextAttribute("1")]
public interface StackExchange.Redis.Profiling.IProfiledCommand {
    public EndPoint EndPoint { get; }
    public int Db { get; }
    public string Command { get; }
    public CommandFlags Flags { get; }
    public DateTime CommandCreated { get; }
    public TimeSpan CreationToEnqueued { get; }
    public TimeSpan EnqueuedToSending { get; }
    public TimeSpan SentToResponse { get; }
    public TimeSpan ResponseToCompletion { get; }
    public TimeSpan ElapsedTime { get; }
    [NullableAttribute("2")]
public IProfiledCommand RetransmissionOf { get; }
    public Nullable`1<RetransmissionReasonType> RetransmissionReason { get; }
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual int get_Db();
    public abstract virtual string get_Command();
    public abstract virtual CommandFlags get_Flags();
    public abstract virtual DateTime get_CommandCreated();
    public abstract virtual TimeSpan get_CreationToEnqueued();
    public abstract virtual TimeSpan get_EnqueuedToSending();
    public abstract virtual TimeSpan get_SentToResponse();
    public abstract virtual TimeSpan get_ResponseToCompletion();
    public abstract virtual TimeSpan get_ElapsedTime();
    [NullableContextAttribute("2")]
public abstract virtual IProfiledCommand get_RetransmissionOf();
    public abstract virtual Nullable`1<RetransmissionReasonType> get_RetransmissionReason();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.Profiling.ProfiledCommand : object {
    private static double TimestampToTicks;
    [CompilerGeneratedAttribute]
private DateTime <CommandCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RetransmissionReasonType> <RetransmissionReason>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ProfiledCommand <NextElement>k__BackingField;
    [NullableAttribute("2")]
private Message Message;
    private ServerEndPoint Server;
    [NullableAttribute("2")]
private ProfiledCommand OriginalProfiling;
    private long MessageCreatedTimeStamp;
    private long EnqueuedTimeStamp;
    private long RequestSentTimeStamp;
    private long ResponseReceivedTimeStamp;
    private long CompletedTimeStamp;
    private Nullable`1<ConnectionType> ConnectionType;
    private ProfilingSession PushToWhenFinished;
    public EndPoint EndPoint { get; }
    public int Db { get; }
    public string Command { get; }
    public CommandFlags Flags { get; }
    public DateTime CommandCreated { get; private set; }
    public TimeSpan CreationToEnqueued { get; }
    public TimeSpan EnqueuedToSending { get; }
    public TimeSpan SentToResponse { get; }
    public TimeSpan ResponseToCompletion { get; }
    public TimeSpan ElapsedTime { get; }
    [NullableAttribute("2")]
public IProfiledCommand RetransmissionOf { get; }
    public Nullable`1<RetransmissionReasonType> RetransmissionReason { get; }
    [NullableAttribute("2")]
public ProfiledCommand NextElement { get; public set; }
    private ProfiledCommand(ProfilingSession pushTo, ServerEndPoint server, ProfiledCommand resentFor, Nullable`1<RetransmissionReasonType> reason);
    private static ProfiledCommand();
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual int get_Db();
    public sealed virtual string get_Command();
    public sealed virtual CommandFlags get_Flags();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CommandCreated();
    [CompilerGeneratedAttribute]
private void set_CommandCreated(DateTime value);
    public sealed virtual TimeSpan get_CreationToEnqueued();
    public sealed virtual TimeSpan get_EnqueuedToSending();
    public sealed virtual TimeSpan get_SentToResponse();
    public sealed virtual TimeSpan get_ResponseToCompletion();
    public sealed virtual TimeSpan get_ElapsedTime();
    private static TimeSpan GetElapsedTime(long timestampDelta);
    [NullableContextAttribute("2")]
public sealed virtual IProfiledCommand get_RetransmissionOf();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<RetransmissionReasonType> get_RetransmissionReason();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ProfiledCommand get_NextElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NextElement(ProfiledCommand value);
    public static ProfiledCommand NewWithContext(ProfilingSession pushTo, ServerEndPoint server);
    public static ProfiledCommand NewAttachedToSameContext(ProfiledCommand resentFor, ServerEndPoint server, bool isMoved);
    [MemberNotNullAttribute("Message")]
public void SetMessage(Message msg);
    public void SetEnqueued(Nullable`1<ConnectionType> connType);
    public void SetRequestSent();
    public void SetResponseReceived();
    private static void SetTimestamp(Int64& field);
    public void SetCompleted();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.Profiling.ProfiledCommandEnumerable : ValueType {
    [NullableAttribute("2")]
private ProfiledCommand _head;
    private int _count;
    [NullableContextAttribute("2")]
internal ProfiledCommandEnumerable(int count, ProfiledCommand head);
    public int Count();
    public int Count(Func`2<IProfiledCommand, bool> predicate);
    public IProfiledCommand[] ToArray();
    public List`1<IProfiledCommand> ToList();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<IProfiledCommand> System.Collections.Generic.IEnumerable<StackExchange.Redis.Profiling.IProfiledCommand>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class StackExchange.Redis.Profiling.ProfilingSession : object {
    [CompilerGeneratedAttribute]
private object <UserToken>k__BackingField;
    private object _untypedHead;
    public object UserToken { get; }
    public ProfilingSession(object userToken);
    [CompilerGeneratedAttribute]
public object get_UserToken();
    [NullableContextAttribute("1")]
internal void Add(ProfiledCommand command);
    public ProfiledCommandEnumerable FinishProfiling();
}
public enum StackExchange.Redis.Proxy : Enum {
    public int value__;
    public static Proxy None;
    public static Proxy Twemproxy;
    public static Proxy Envoyproxy;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ProxyExtensions : object {
    [ExtensionAttribute]
internal static bool SupportsDatabases(Proxy proxy);
    [ExtensionAttribute]
internal static bool SupportsPubSub(Proxy proxy);
    [ExtensionAttribute]
internal static bool SupportsServerApi(Proxy proxy);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class StackExchange.Redis.RawResult : ValueType {
    private ReadOnlySequence`1<byte> _payload;
    internal static RawResult Nil;
    private Sequence _items;
    private ResultType _resultType;
    private ResultFlags _flags;
    internal RawResult& Item { get; }
    internal int ItemsCount { get; }
    internal ReadOnlySequence`1<byte> Payload { get; }
    public bool IsError { get; }
    public ResultType Resp3Type { get; }
    public ResultType Resp2TypeBulkString { get; }
    public ResultType Resp2TypeArray { get; }
    internal bool IsNull { get; }
    public bool HasValue { get; }
    public bool IsResp3 { get; }
    public RawResult(ResultType resultType, ReadOnlySequence`1& payload, ResultFlags flags);
    public RawResult(ResultType resultType, Sequence`1<RawResult> items, ResultFlags flags);
    private static RawResult();
    internal RawResult& get_Item(int index);
    internal int get_ItemsCount();
    internal ReadOnlySequence`1<byte> get_Payload();
    private static void ThrowInvalidType(ResultType resultType);
    public bool get_IsError();
    public ResultType get_Resp3Type();
    public ResultType get_Resp2TypeBulkString();
    public ResultType get_Resp2TypeArray();
    internal bool get_IsNull();
    public bool get_HasValue();
    public bool get_IsResp3();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Tokenizer GetInlineTokenizer();
    [NullableContextAttribute("2")]
internal RedisChannel AsRedisChannel(Byte[] channelPrefix, PatternMode mode);
    internal RedisKey AsRedisKey();
    internal RedisValue AsRedisValue();
    [NullableContextAttribute("2")]
internal Lease`1<byte> AsLease();
    internal bool IsEqual(CommandBytes& expected);
    [NullableContextAttribute("2")]
internal bool IsEqual(Byte[] expected);
    internal bool StartsWith(CommandBytes& expected);
    [NullableContextAttribute("1")]
internal bool StartsWith(Byte[] expected);
    [NullableContextAttribute("2")]
internal Byte[] GetBlob();
    internal bool GetBoolean();
    internal Sequence`1<RawResult> GetItems();
    [NullableContextAttribute("2")]
internal Nullable`1[] GetItemsAsDoubles();
    [NullableContextAttribute("2")]
internal RedisKey[] GetItemsAsKeys();
    [NullableContextAttribute("2")]
internal RedisValue[] GetItemsAsValues();
    [NullableContextAttribute("2")]
internal String[] GetItemsAsStrings();
    internal String[] GetItemsAsStringsNotNullable();
    [NullableContextAttribute("2")]
internal Boolean[] GetItemsAsBooleans();
    internal Nullable`1<GeoPosition> GetItemsAsGeoPosition();
    [NullableContextAttribute("2")]
internal SortedSetEntry[] GetItemsAsSortedSetEntryArray();
    private static SortedSetEntry AsSortedSetEntry(Sequence`1& elements);
    private static GeoPosition AsGeoPosition(Sequence`1& coords);
    [NullableContextAttribute("2")]
internal Nullable`1[] GetItemsAsGeoPositionArray();
    [NullableContextAttribute("2")]
internal string GetString();
    internal string GetString(ReadOnlySpan`1& verbatimPrefix);
    internal bool TryGetDouble(Double& val);
    internal bool TryGetInt64(Int64& value);
    internal bool Is(char value);
    [CompilerGeneratedAttribute]
internal static void <GetString>g__Throw|55_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetString>g__GetVerbatimString|55_1(string value, ReadOnlySpan`1& type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class StackExchange.Redis.RedisBase : object {
    internal static DateTime UnixEpoch;
    internal ConnectionMultiplexer multiplexer;
    [NullableAttribute("2")]
protected object asyncState;
    private IConnectionMultiplexer StackExchange.Redis.IRedisAsync.Multiplexer { get; }
    internal RedisBase(ConnectionMultiplexer multiplexer, object asyncState);
    private static RedisBase();
    private sealed virtual override IConnectionMultiplexer StackExchange.Redis.IRedisAsync.get_Multiplexer();
    public virtual TimeSpan Ping(CommandFlags flags);
    public virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    public virtual string ToString();
    public sealed virtual bool TryWait(Task task);
    public sealed virtual void Wait(Task task);
    public sealed virtual T Wait(Task`1<T> task);
    public sealed virtual void WaitAll(Task[] tasks);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, T defaultValue, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server, T defaultValue);
    [NullableContextAttribute("2")]
internal virtual RedisFeatures GetFeatures(RedisKey& modreq(System.Runtime.InteropServices.InAttribute) key, CommandFlags flags, RedisCommand command, ServerEndPoint& server);
    protected static void WhenAlwaysOrExists(When when);
    protected static void WhenAlwaysOrExistsOrNotExists(When when);
    protected static void WhenAlwaysOrNotExists(When when);
    private TimerMessage GetTimerMessage(CommandFlags flags);
}
internal class StackExchange.Redis.RedisBatch : RedisDatabase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Message> pending;
    [NullableContextAttribute("1")]
public RedisBatch(RedisDatabase wrapped, object asyncState);
    public sealed virtual void Execute();
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, T defaultValue, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server, T defaultValue);
    [NullableContextAttribute("1")]
private static void FailNoServer(ConnectionMultiplexer muxer, List`1<Message> messages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisChannel : ValueType {
    [NullableAttribute("2")]
internal Byte[] Value;
    internal bool _isPatternBased;
    private static PatternMode s_DefaultPatternMode;
    public bool IsNullOrEmpty { get; }
    public bool IsPattern { get; }
    internal bool IsNull { get; }
    public static bool UseImplicitAutoPattern { get; public set; }
    [NullableContextAttribute("2")]
public RedisChannel(Byte[] value, PatternMode mode);
    public RedisChannel(string value, PatternMode mode);
    [NullableContextAttribute("2")]
private RedisChannel(Byte[] value, bool isPatternBased);
    public bool get_IsNullOrEmpty();
    public bool get_IsPattern();
    internal bool get_IsNull();
    public static bool get_UseImplicitAutoPattern();
    public static void set_UseImplicitAutoPattern(bool value);
    public static RedisChannel Literal(string value);
    public static RedisChannel Literal(Byte[] value);
    public static RedisChannel Pattern(string value);
    public static RedisChannel Pattern(Byte[] value);
    [NullableContextAttribute("2")]
private static bool DeterminePatternBased(Byte[] value, PatternMode mode);
    public static bool op_Inequality(RedisChannel x, RedisChannel y);
    public static bool op_Inequality(string x, RedisChannel y);
    public static bool op_Inequality(Byte[] x, RedisChannel y);
    public static bool op_Inequality(RedisChannel x, string y);
    public static bool op_Inequality(RedisChannel x, Byte[] y);
    public static bool op_Equality(RedisChannel x, RedisChannel y);
    public static bool op_Equality(string x, RedisChannel y);
    public static bool op_Equality(Byte[] x, RedisChannel y);
    public static bool op_Equality(RedisChannel x, string y);
    public static bool op_Equality(RedisChannel x, Byte[] y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisChannel other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static bool AssertStarts(Byte[] value, Byte[] expected);
    internal void AssertNotNull();
    internal RedisChannel Clone();
    [ObsoleteAttribute("It is preferable to explicitly specify a PatternMode, or use the Literal/Pattern methods", "False")]
public static RedisChannel op_Implicit(string key);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("It is preferable to explicitly specify a PatternMode, or use the Literal/Pattern methods", "False")]
public static RedisChannel op_Implicit(Byte[] key);
    [NullableContextAttribute("2")]
public static Byte[] op_Implicit(RedisChannel key);
    [NullableContextAttribute("2")]
public static string op_Implicit(RedisChannel key);
}
internal enum StackExchange.Redis.RedisCommand : Enum {
    public int value__;
    public static RedisCommand NONE;
    public static RedisCommand APPEND;
    public static RedisCommand ASKING;
    public static RedisCommand AUTH;
    public static RedisCommand BGREWRITEAOF;
    public static RedisCommand BGSAVE;
    public static RedisCommand BITCOUNT;
    public static RedisCommand BITOP;
    public static RedisCommand BITPOS;
    public static RedisCommand BLPOP;
    public static RedisCommand BRPOP;
    public static RedisCommand BRPOPLPUSH;
    public static RedisCommand CLIENT;
    public static RedisCommand CLUSTER;
    public static RedisCommand CONFIG;
    public static RedisCommand COPY;
    public static RedisCommand COMMAND;
    public static RedisCommand DBSIZE;
    public static RedisCommand DEBUG;
    public static RedisCommand DECR;
    public static RedisCommand DECRBY;
    public static RedisCommand DEL;
    public static RedisCommand DISCARD;
    public static RedisCommand DUMP;
    public static RedisCommand ECHO;
    public static RedisCommand EVAL;
    public static RedisCommand EVALSHA;
    public static RedisCommand EVAL_RO;
    public static RedisCommand EVALSHA_RO;
    public static RedisCommand EXEC;
    public static RedisCommand EXISTS;
    public static RedisCommand EXPIRE;
    public static RedisCommand EXPIREAT;
    public static RedisCommand EXPIRETIME;
    public static RedisCommand FLUSHALL;
    public static RedisCommand FLUSHDB;
    public static RedisCommand GEOADD;
    public static RedisCommand GEODIST;
    public static RedisCommand GEOHASH;
    public static RedisCommand GEOPOS;
    public static RedisCommand GEORADIUS;
    public static RedisCommand GEORADIUSBYMEMBER;
    public static RedisCommand GEOSEARCH;
    public static RedisCommand GEOSEARCHSTORE;
    public static RedisCommand GET;
    public static RedisCommand GETBIT;
    public static RedisCommand GETDEL;
    public static RedisCommand GETEX;
    public static RedisCommand GETRANGE;
    public static RedisCommand GETSET;
    public static RedisCommand HDEL;
    public static RedisCommand HELLO;
    public static RedisCommand HEXISTS;
    public static RedisCommand HEXPIRE;
    public static RedisCommand HEXPIREAT;
    public static RedisCommand HEXPIRETIME;
    public static RedisCommand HGET;
    public static RedisCommand HGETALL;
    public static RedisCommand HINCRBY;
    public static RedisCommand HINCRBYFLOAT;
    public static RedisCommand HKEYS;
    public static RedisCommand HLEN;
    public static RedisCommand HMGET;
    public static RedisCommand HMSET;
    public static RedisCommand HPERSIST;
    public static RedisCommand HPEXPIRE;
    public static RedisCommand HPEXPIREAT;
    public static RedisCommand HPEXPIRETIME;
    public static RedisCommand HPTTL;
    public static RedisCommand HRANDFIELD;
    public static RedisCommand HSCAN;
    public static RedisCommand HSET;
    public static RedisCommand HSETNX;
    public static RedisCommand HSTRLEN;
    public static RedisCommand HVALS;
    public static RedisCommand INCR;
    public static RedisCommand INCRBY;
    public static RedisCommand INCRBYFLOAT;
    public static RedisCommand INFO;
    public static RedisCommand KEYS;
    public static RedisCommand LASTSAVE;
    public static RedisCommand LATENCY;
    public static RedisCommand LCS;
    public static RedisCommand LINDEX;
    public static RedisCommand LINSERT;
    public static RedisCommand LLEN;
    public static RedisCommand LMOVE;
    public static RedisCommand LMPOP;
    public static RedisCommand LPOP;
    public static RedisCommand LPOS;
    public static RedisCommand LPUSH;
    public static RedisCommand LPUSHX;
    public static RedisCommand LRANGE;
    public static RedisCommand LREM;
    public static RedisCommand LSET;
    public static RedisCommand LTRIM;
    public static RedisCommand MEMORY;
    public static RedisCommand MGET;
    public static RedisCommand MIGRATE;
    public static RedisCommand MONITOR;
    public static RedisCommand MOVE;
    public static RedisCommand MSET;
    public static RedisCommand MSETNX;
    public static RedisCommand MULTI;
    public static RedisCommand OBJECT;
    public static RedisCommand PERSIST;
    public static RedisCommand PEXPIRE;
    public static RedisCommand PEXPIREAT;
    public static RedisCommand PEXPIRETIME;
    public static RedisCommand PFADD;
    public static RedisCommand PFCOUNT;
    public static RedisCommand PFMERGE;
    public static RedisCommand PING;
    public static RedisCommand PSETEX;
    public static RedisCommand PSUBSCRIBE;
    public static RedisCommand PTTL;
    public static RedisCommand PUBLISH;
    public static RedisCommand PUBSUB;
    public static RedisCommand PUNSUBSCRIBE;
    public static RedisCommand QUIT;
    public static RedisCommand RANDOMKEY;
    public static RedisCommand READONLY;
    public static RedisCommand READWRITE;
    public static RedisCommand RENAME;
    public static RedisCommand RENAMENX;
    public static RedisCommand REPLICAOF;
    public static RedisCommand RESTORE;
    public static RedisCommand ROLE;
    public static RedisCommand RPOP;
    public static RedisCommand RPOPLPUSH;
    public static RedisCommand RPUSH;
    public static RedisCommand RPUSHX;
    public static RedisCommand SADD;
    public static RedisCommand SAVE;
    public static RedisCommand SCAN;
    public static RedisCommand SCARD;
    public static RedisCommand SCRIPT;
    public static RedisCommand SDIFF;
    public static RedisCommand SDIFFSTORE;
    public static RedisCommand SELECT;
    public static RedisCommand SENTINEL;
    public static RedisCommand SET;
    public static RedisCommand SETBIT;
    public static RedisCommand SETEX;
    public static RedisCommand SETNX;
    public static RedisCommand SETRANGE;
    public static RedisCommand SHUTDOWN;
    public static RedisCommand SINTER;
    public static RedisCommand SINTERCARD;
    public static RedisCommand SINTERSTORE;
    public static RedisCommand SISMEMBER;
    public static RedisCommand SLAVEOF;
    public static RedisCommand SLOWLOG;
    public static RedisCommand SMEMBERS;
    public static RedisCommand SMISMEMBER;
    public static RedisCommand SMOVE;
    public static RedisCommand SORT;
    public static RedisCommand SORT_RO;
    public static RedisCommand SPOP;
    public static RedisCommand SRANDMEMBER;
    public static RedisCommand SREM;
    public static RedisCommand STRLEN;
    public static RedisCommand SUBSCRIBE;
    public static RedisCommand SUNION;
    public static RedisCommand SUNIONSTORE;
    public static RedisCommand SSCAN;
    public static RedisCommand SWAPDB;
    public static RedisCommand SYNC;
    public static RedisCommand TIME;
    public static RedisCommand TOUCH;
    public static RedisCommand TTL;
    public static RedisCommand TYPE;
    public static RedisCommand UNLINK;
    public static RedisCommand UNSUBSCRIBE;
    public static RedisCommand UNWATCH;
    public static RedisCommand WATCH;
    public static RedisCommand XACK;
    public static RedisCommand XADD;
    public static RedisCommand XAUTOCLAIM;
    public static RedisCommand XCLAIM;
    public static RedisCommand XDEL;
    public static RedisCommand XGROUP;
    public static RedisCommand XINFO;
    public static RedisCommand XLEN;
    public static RedisCommand XPENDING;
    public static RedisCommand XRANGE;
    public static RedisCommand XREAD;
    public static RedisCommand XREADGROUP;
    public static RedisCommand XREVRANGE;
    public static RedisCommand XTRIM;
    public static RedisCommand ZADD;
    public static RedisCommand ZCARD;
    public static RedisCommand ZCOUNT;
    public static RedisCommand ZDIFF;
    public static RedisCommand ZDIFFSTORE;
    public static RedisCommand ZINCRBY;
    public static RedisCommand ZINTER;
    public static RedisCommand ZINTERCARD;
    public static RedisCommand ZINTERSTORE;
    public static RedisCommand ZLEXCOUNT;
    public static RedisCommand ZMPOP;
    public static RedisCommand ZMSCORE;
    public static RedisCommand ZPOPMAX;
    public static RedisCommand ZPOPMIN;
    public static RedisCommand ZRANDMEMBER;
    public static RedisCommand ZRANGE;
    public static RedisCommand ZRANGEBYLEX;
    public static RedisCommand ZRANGEBYSCORE;
    public static RedisCommand ZRANGESTORE;
    public static RedisCommand ZRANK;
    public static RedisCommand ZREM;
    public static RedisCommand ZREMRANGEBYLEX;
    public static RedisCommand ZREMRANGEBYRANK;
    public static RedisCommand ZREMRANGEBYSCORE;
    public static RedisCommand ZREVRANGE;
    public static RedisCommand ZREVRANGEBYLEX;
    public static RedisCommand ZREVRANGEBYSCORE;
    public static RedisCommand ZREVRANK;
    public static RedisCommand ZSCAN;
    public static RedisCommand ZSCORE;
    public static RedisCommand ZUNION;
    public static RedisCommand ZUNIONSTORE;
    public static RedisCommand UNKNOWN;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisCommandException : Exception {
    public RedisCommandException(string message);
    public RedisCommandException(string message, Exception innerException);
    private RedisCommandException(SerializationInfo info, StreamingContext ctx);
}
[ExtensionAttribute]
internal static class StackExchange.Redis.RedisCommandExtensions : object {
    [ExtensionAttribute]
internal static bool IsPrimaryOnly(RedisCommand command);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisConnectionException : RedisException {
    [CompilerGeneratedAttribute]
private ConnectionFailureType <FailureType>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandStatus <CommandStatus>k__BackingField;
    public ConnectionFailureType FailureType { get; }
    public CommandStatus CommandStatus { get; }
    public RedisConnectionException(ConnectionFailureType failureType, string message);
    public RedisConnectionException(ConnectionFailureType failureType, string message, Exception innerException);
    public RedisConnectionException(ConnectionFailureType failureType, string message, Exception innerException, CommandStatus commandStatus);
    private RedisConnectionException(SerializationInfo info, StreamingContext ctx);
    [CompilerGeneratedAttribute]
public ConnectionFailureType get_FailureType();
    [CompilerGeneratedAttribute]
public CommandStatus get_CommandStatus();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.RedisDatabase : RedisBase {
    [CompilerGeneratedAttribute]
private int <Database>k__BackingField;
    [NullableAttribute("2")]
public object AsyncState { get; }
    public int Database { get; }
    internal RedisDatabase(ConnectionMultiplexer multiplexer, int db, object asyncState);
    [NullableContextAttribute("2")]
public object get_AsyncState();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Database();
    public sealed virtual IBatch CreateBatch(object asyncState);
    public sealed virtual ITransaction CreateTransaction(object asyncState);
    [NullableContextAttribute("2")]
private ITransaction CreateTransactionIfAvailable(object asyncState);
    public sealed virtual RedisValue DebugObject(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> DebugObjectAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags);
    public sealed virtual bool GeoAdd(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoAddAsync(RedisKey key, GeoEntry value, CommandFlags flags);
    public sealed virtual long GeoAdd(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> GeoAddAsync(RedisKey key, GeoEntry[] values, CommandFlags flags);
    public sealed virtual bool GeoRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<bool> GeoRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1<double> GeoDistance(RedisKey key, RedisValue member1, RedisValue member2, GeoUnit unit, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> GeoDistanceAsync(RedisKey key, RedisValue value0, RedisValue value1, GeoUnit unit, CommandFlags flags);
    public sealed virtual String[] GeoHash(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<String[]> GeoHashAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string GeoHash(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<string> GeoHashAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] GeoPosition(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> GeoPositionAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Nullable`1<GeoPosition> GeoPosition(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<GeoPosition>> GeoPositionAsync(RedisKey key, RedisValue member, CommandFlags flags);
    private Message GetGeoSearchMessage(RedisKey& sourceKey, RedisKey& destinationKey, Nullable`1<RedisValue> member, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, bool storeDistances, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    private Message GetGeoRadiusMessage(RedisKey& key, Nullable`1<RedisValue> member, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, RedisValue member, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoRadiusAsync(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit, int count, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoSearch(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual GeoRadiusResult[] GeoSearch(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual Task`1<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, GeoRadiusOptions options, CommandFlags flags);
    public sealed virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual long GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual Task`1<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count, bool demandClosest, Nullable`1<Order> order, bool storeDistances, CommandFlags flags);
    public sealed virtual long HashDecrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual double HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashDecrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual bool HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual long HashDelete(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<long> HashDeleteAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual bool HashExists(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<bool> HashExistsAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual ExpireResult[] HashFieldExpire(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, TimeSpan expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when, CommandFlags flags);
    private T HashFieldExpireExecute(RedisKey key, long milliseconds, ExpireWhen when, Func`2<bool, RedisCommand> getCmd, CustomExecutor`2<T, TProcessor> executor, TProcessor processor, CommandFlags flags, RedisValue[] hashFields);
    private static RedisCommand PickExpireCommandByPrecision(bool useSeconds);
    private static RedisCommand PickExpireAtCommandByPrecision(bool useSeconds);
    private T HashFieldExecute(RedisCommand cmd, RedisKey key, CustomExecutor`2<T, TProcessor> executor, TProcessor processor, CommandFlags flags, RedisValue[] hashFields);
    private T[] SyncCustomArrExecutor(Message msg, TProcessor processor);
    private Task`1<T[]> AsyncCustomArrExecutor(Message msg, TProcessor processor);
    public sealed virtual Int64[] HashFieldGetExpireDateTime(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> HashFieldGetExpireDateTimeAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual PersistResult[] HashFieldPersist(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<PersistResult[]> HashFieldPersistAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Int64[] HashFieldGetTimeToLive(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> HashFieldGetTimeToLiveAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual RedisValue HashGet(RedisKey key, RedisValue hashField, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual Lease`1<byte> HashGetLease(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual RedisValue[] HashGet(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual HashEntry[] HashGetAll(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashGetAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<Lease`1<byte>> HashGetLeaseAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashGetAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags);
    public sealed virtual long HashIncrement(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual double HashIncrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual Task`1<long> HashIncrementAsync(RedisKey key, RedisValue hashField, long value, CommandFlags flags);
    public sealed virtual Task`1<double> HashIncrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags);
    public sealed virtual RedisValue[] HashKeys(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashKeysAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long HashLength(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue HashRandomField(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] HashRandomFields(RedisKey key, long count, CommandFlags flags);
    public sealed virtual HashEntry[] HashRandomFieldsWithValues(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<long> HashLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> HashRandomFieldAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashRandomFieldsAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<HashEntry[]> HashRandomFieldsWithValuesAsync(RedisKey key, long count, CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<HashEntry> StackExchange.Redis.IDatabase.HashScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IAsyncEnumerable`1<HashEntry> StackExchange.Redis.IDatabaseAsync.HashScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private CursorEnumerable`1<HashEntry> HashScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.HashScanNoValues(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IAsyncEnumerable`1<RedisValue> StackExchange.Redis.IDatabaseAsync.HashScanNoValuesAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private CursorEnumerable`1<RedisValue> HashScanNoValuesAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual bool HashSet(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual void HashSet(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public sealed virtual long HashStringLength(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task`1<bool> HashSetAsync(RedisKey key, RedisValue hashField, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> HashStringLengthAsync(RedisKey key, RedisValue hashField, CommandFlags flags);
    public sealed virtual Task HashSetAsync(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    public Task`1<bool> HashSetIfNotExistsAsync(RedisKey key, RedisValue hashField, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue[] HashValues(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> HashValuesAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool HyperLogLogAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> HyperLogLogAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey key, CommandFlags flags);
    public sealed virtual long HyperLogLogLength(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual void HyperLogLogMerge(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task HyperLogLogMergeAsync(RedisKey destination, RedisKey[] sourceKeys, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual EndPoint IdentifyEndpoint(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyCopy(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyCopyAsync(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    public sealed virtual bool KeyDelete(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyDelete(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyDeleteAsync(RedisKey[] keys, CommandFlags flags);
    [NullableContextAttribute("2")]
private RedisCommand GetDeleteCommand(RedisKey key, CommandFlags flags, ServerEndPoint& server);
    [NullableContextAttribute("2")]
public sealed virtual Byte[] KeyDump(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> KeyDumpAsync(RedisKey key, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string KeyEncoding(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<string> KeyEncodingAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyExists(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyExists(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExistsAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyExistsAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual bool KeyExpire(RedisKey key, Nullable`1<DateTime> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<TimeSpan> expiry, ExpireWhen when, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyExpireAsync(RedisKey key, Nullable`1<DateTime> expire, ExpireWhen when, CommandFlags flags);
    public sealed virtual Nullable`1<DateTime> KeyExpireTime(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<DateTime>> KeyExpireTimeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Nullable`1<long> KeyFrequency(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> KeyFrequencyAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyIdleTime(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyIdleTimeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual void KeyMigrate(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual Task KeyMigrateAsync(RedisKey key, EndPoint toServer, int toDatabase, int timeoutMilliseconds, MigrateOptions migrateOptions, CommandFlags flags);
    public sealed virtual bool KeyMove(RedisKey key, int database, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyMoveAsync(RedisKey key, int database, CommandFlags flags);
    public sealed virtual bool KeyPersist(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyPersistAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisKey KeyRandom(CommandFlags flags);
    public sealed virtual Task`1<RedisKey> KeyRandomAsync(CommandFlags flags);
    public sealed virtual Nullable`1<long> KeyRefCount(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> KeyRefCountAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool KeyRename(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyRenameAsync(RedisKey key, RedisKey newKey, When when, CommandFlags flags);
    public sealed virtual void KeyRestore(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task KeyRestoreAsync(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Nullable`1<TimeSpan> KeyTimeToLive(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<TimeSpan>> KeyTimeToLiveAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisType KeyType(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisType> KeyTypeAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListGetByIndex(RedisKey key, long index, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListGetByIndexAsync(RedisKey key, long index, CommandFlags flags);
    public sealed virtual long ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertAfterAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual long ListInsertBefore(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> ListInsertBeforeAsync(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue ListLeftPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListLeftPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual ListPopResult ListLeftPop(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual long ListPosition(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Int64[] ListPositions(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListLeftPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListLeftPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<ListPopResult> ListLeftPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual Task`1<long> ListPositionAsync(RedisKey key, RedisValue element, long rank, long maxLength, CommandFlags flags);
    public sealed virtual Task`1<Int64[]> ListPositionsAsync(RedisKey key, RedisValue element, long count, long rank, long maxLength, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual long ListLeftPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListLeftPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long ListLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> ListLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue ListMove(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListMoveAsync(RedisKey sourceKey, RedisKey destinationKey, ListSide sourceSide, ListSide destinationSide, CommandFlags flags);
    public sealed virtual RedisValue[] ListRange(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRangeAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long ListRemove(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual Task`1<long> ListRemoveAsync(RedisKey key, RedisValue value, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPop(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] ListRightPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual ListPopResult ListRightPop(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> ListRightPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<ListPopResult> ListRightPopAsync(RedisKey[] keys, long count, CommandFlags flags);
    public sealed virtual RedisValue ListRightPopLeftPush(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> ListRightPopLeftPushAsync(RedisKey source, RedisKey destination, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual long ListRightPush(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue value, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> ListRightPushAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual void ListSetByIndex(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual Task ListSetByIndexAsync(RedisKey key, long index, RedisValue value, CommandFlags flags);
    public sealed virtual void ListTrim(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task ListTrimAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual bool LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual RedisValue LockQuery(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool LockRelease(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual bool LockTake(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    public sealed virtual Task`1<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string StringLongestCommonSubsequence(RedisKey key1, RedisKey key2, CommandFlags flags);
    public sealed virtual Task`1<string> StringLongestCommonSubsequenceAsync(RedisKey key1, RedisKey key2, CommandFlags flags);
    public sealed virtual long StringLongestCommonSubsequenceLength(RedisKey key1, RedisKey key2, CommandFlags flags);
    public sealed virtual Task`1<long> StringLongestCommonSubsequenceLengthAsync(RedisKey key1, RedisKey key2, CommandFlags flags);
    public sealed virtual LCSMatchResult StringLongestCommonSubsequenceWithMatches(RedisKey key1, RedisKey key2, long minSubMatchLength, CommandFlags flags);
    public sealed virtual Task`1<LCSMatchResult> StringLongestCommonSubsequenceWithMatchesAsync(RedisKey key1, RedisKey key2, long minSubMatchLength, CommandFlags flags);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual RedisResult Execute(string command, Object[] args);
    public sealed virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluate(LoadedLuaScript script, object parameters, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.RedisDatabase/<ScriptEvaluateAsync>d__243")]
public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LuaScript script, object parameters, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateAsync(LoadedLuaScript script, object parameters, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluateReadOnly(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisResult ScriptEvaluateReadOnly(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(string script, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ScriptEvaluateReadOnlyAsync(Byte[] hash, RedisKey[] keys, RedisValue[] values, CommandFlags flags);
    public sealed virtual bool SetAdd(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetAdd(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual RedisValue[] SetCombine(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long SetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> SetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Boolean[] SetContains(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<Boolean[]> SetContainsAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual long SetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual Task`1<long> SetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual long SetLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> SetLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetMembers(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetMembersAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool SetMove(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<bool> SetMoveAsync(RedisKey source, RedisKey destination, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue SetPop(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetPopAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetPop(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetPopAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual RedisValue SetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual bool SetRemove(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long SetRemove(RedisKey key, RedisValue[] values, CommandFlags flags);
    public sealed virtual Task`1<bool> SetRemoveAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> SetRemoveAsync(RedisKey key, RedisValue[] values, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisValue> StackExchange.Redis.IDatabase.SetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IAsyncEnumerable`1<RedisValue> StackExchange.Redis.IDatabaseAsync.SetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private CursorEnumerable`1<RedisValue> SetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual RedisValue[] Sort(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual long SortAndStore(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<long> SortAndStoreAsync(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortAsync(RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual bool SortedSetAdd(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual bool SortedSetUpdate(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual long SortedSetAdd(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual long SortedSetUpdate(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetAddAsync(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetUpdateAsync(RedisKey key, RedisValue member, double score, SortedSetWhen when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetAddAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetUpdateAsync(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetCombine(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetCombineAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetCombineWithScores(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetCombineWithScoresAsync(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual long SortedSetCombineAndStore(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey first, RedisKey second, Aggregate aggregate, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetCombineAndStoreAsync(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    public sealed virtual double SortedSetDecrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetDecrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual double SortedSetIncrement(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual Task`1<double> SortedSetIncrementAsync(RedisKey key, RedisValue member, double value, CommandFlags flags);
    public sealed virtual long SortedSetIntersectionLength(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetIntersectionLengthAsync(RedisKey[] keys, long limit, CommandFlags flags);
    public sealed virtual long SortedSetLength(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthAsync(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue SortedSetRandomMember(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRandomMembers(RedisKey key, long count, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRandomMembersWithScores(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> SortedSetRandomMemberAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRandomMembersAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRandomMembersWithScoresAsync(RedisKey key, long count, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByRank(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual long SortedSetRangeAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByRankAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRangeAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Exclude exclude, Order order, long skip, Nullable`1<long> take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByRankWithScores(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByRankWithScoresAsync(RedisKey key, long start, long stop, Order order, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByScore(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetRangeByScoreWithScores(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetRangeByScoreWithScoresAsync(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Nullable`1<long> SortedSetRank(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<long>> SortedSetRankAsync(RedisKey key, RedisValue member, Order order, CommandFlags flags);
    public sealed virtual bool SortedSetRemove(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual long SortedSetRemove(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<bool> SortedSetRemoveAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByRank(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByRankAsync(RedisKey key, long start, long stop, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByScore(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByScoreAsync(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabase.SortedSetScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IAsyncEnumerable`1<SortedSetEntry> StackExchange.Redis.IDatabaseAsync.SortedSetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private CursorEnumerable`1<SortedSetEntry> SortedSetScanAsync(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual Nullable`1<double> SortedSetScore(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Nullable`1[] SortedSetScores(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<double>> SortedSetScoreAsync(RedisKey key, RedisValue member, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1[]> SortedSetScoresAsync(RedisKey key, RedisValue[] members, CommandFlags flags);
    public sealed virtual Nullable`1<SortedSetEntry> SortedSetPop(RedisKey key, Order order, CommandFlags flags);
    public sealed virtual Task`1<Nullable`1<SortedSetEntry>> SortedSetPopAsync(RedisKey key, Order order, CommandFlags flags);
    public sealed virtual SortedSetEntry[] SortedSetPop(RedisKey key, long count, Order order, CommandFlags flags);
    public sealed virtual SortedSetPopResult SortedSetPop(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetEntry[]> SortedSetPopAsync(RedisKey key, long count, Order order, CommandFlags flags);
    public sealed virtual Task`1<SortedSetPopResult> SortedSetPopAsync(RedisKey[] keys, long count, Order order, CommandFlags flags);
    public sealed virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public sealed virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    public sealed virtual long StreamAcknowledge(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<long> StreamAcknowledgeAsync(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual RedisValue StreamAdd(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, RedisValue streamField, RedisValue streamValue, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual RedisValue StreamAdd(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StreamAddAsync(RedisKey key, NameValueEntry[] streamPairs, Nullable`1<RedisValue> messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual StreamAutoClaimResult StreamAutoClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamAutoClaimResult> StreamAutoClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamAutoClaimIdsOnlyResult StreamAutoClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamAutoClaimIdsOnlyResult> StreamAutoClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamClaim(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamClaimAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual RedisValue[] StreamClaimIdsOnly(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StreamClaimIdsOnlyAsync(RedisKey key, RedisValue consumerGroup, RedisValue claimingConsumer, long minIdleTimeInMs, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual bool StreamConsumerGroupSetPosition(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamConsumerGroupSetPositionAsync(RedisKey key, RedisValue groupName, RedisValue position, CommandFlags flags);
    public sealed virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public sealed virtual bool StreamCreateConsumerGroup(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamCreateConsumerGroupAsync(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    public sealed virtual StreamConsumerInfo[] StreamConsumerInfo(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<StreamConsumerInfo[]> StreamConsumerInfoAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual StreamGroupInfo[] StreamGroupInfo(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<StreamGroupInfo[]> StreamGroupInfoAsync(RedisKey key, CommandFlags flags);
    public sealed virtual StreamInfo StreamInfo(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<StreamInfo> StreamInfoAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long StreamLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> StreamLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long StreamDelete(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual Task`1<long> StreamDeleteAsync(RedisKey key, RedisValue[] messageIds, CommandFlags flags);
    public sealed virtual long StreamDeleteConsumer(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public sealed virtual Task`1<long> StreamDeleteConsumerAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, CommandFlags flags);
    public sealed virtual bool StreamDeleteConsumerGroup(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<bool> StreamDeleteConsumerGroupAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual StreamPendingInfo StreamPending(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual Task`1<StreamPendingInfo> StreamPendingAsync(RedisKey key, RedisValue groupName, CommandFlags flags);
    public sealed virtual StreamPendingMessageInfo[] StreamPendingMessages(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public sealed virtual Task`1<StreamPendingMessageInfo[]> StreamPendingMessagesAsync(RedisKey key, RedisValue groupName, int count, RedisValue consumerName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamRange(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamRangeAsync(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamRead(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadAsync(RedisKey key, RedisValue position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual RedisStream[] StreamRead(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadAsync(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual StreamEntry[] StreamReadGroup(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, CommandFlags flags);
    public sealed virtual Task`1<StreamEntry[]> StreamReadGroupAsync(RedisKey key, RedisValue groupName, RedisValue consumerName, Nullable`1<RedisValue> position, Nullable`1<int> count, bool noAck, CommandFlags flags);
    public sealed virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual RedisStream[] StreamReadGroup(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, CommandFlags flags);
    public sealed virtual Task`1<RedisStream[]> StreamReadGroupAsync(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    public sealed virtual long StreamTrim(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual Task`1<long> StreamTrimAsync(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    public sealed virtual long StringAppend(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<long> StringAppendAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitCount(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitCountAsync(RedisKey key, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual long StringBitOperation(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitOperationAsync(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual long StringBitPosition(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<long> StringBitPositionAsync(RedisKey key, bool bit, long start, long end, StringIndexType indexType, CommandFlags flags);
    public sealed virtual long StringDecrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual double StringDecrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringDecrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<double> StringDecrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual RedisValue StringGet(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValue StringGetSetExpiry(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual RedisValue StringGetSetExpiry(RedisKey key, DateTime expiry, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetExpiryAsync(RedisKey key, DateTime expiry, CommandFlags flags);
    public sealed virtual RedisValue[] StringGet(RedisKey[] keys, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual Lease`1<byte> StringGetLease(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<Lease`1<byte>> StringGetLeaseAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> StringGetAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual bool StringGetBit(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual Task`1<bool> StringGetBitAsync(RedisKey key, long offset, CommandFlags flags);
    public sealed virtual RedisValue StringGetRange(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetRangeAsync(RedisKey key, long start, long end, CommandFlags flags);
    public sealed virtual RedisValue StringGetSet(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetSetAsync(RedisKey key, RedisValue value, CommandFlags flags);
    public sealed virtual RedisValue StringGetDelete(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringGetDeleteAsync(RedisKey key, CommandFlags flags);
    public sealed virtual RedisValueWithExpiry StringGetWithExpiry(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<RedisValueWithExpiry> StringGetWithExpiryAsync(RedisKey key, CommandFlags flags);
    public sealed virtual long StringIncrement(RedisKey key, long value, CommandFlags flags);
    public sealed virtual double StringIncrement(RedisKey key, double value, CommandFlags flags);
    public sealed virtual Task`1<long> StringIncrementAsync(RedisKey key, long value, CommandFlags flags);
    public sealed virtual Task`1<double> StringIncrementAsync(RedisKey key, double value, CommandFlags flags);
    public sealed virtual long StringLength(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> StringLengthAsync(RedisKey key, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual bool StringSet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual bool StringSet(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetAsync(KeyValuePair`2[] values, When when, CommandFlags flags);
    public sealed virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual RedisValue StringSetAndGet(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, When when, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetAndGetAsync(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    public sealed virtual bool StringSetBit(RedisKey key, long offset, bool bit, CommandFlags flags);
    public sealed virtual Task`1<bool> StringSetBitAsync(RedisKey key, long offset, bool value, CommandFlags flags);
    public sealed virtual RedisValue StringSetRange(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    public sealed virtual bool KeyTouch(RedisKey key, CommandFlags flags);
    public sealed virtual long KeyTouch(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<bool> KeyTouchAsync(RedisKey key, CommandFlags flags);
    public sealed virtual Task`1<long> KeyTouchAsync(RedisKey[] keys, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> StringSetRangeAsync(RedisKey key, long offset, RedisValue value, CommandFlags flags);
    private long GetMillisecondsUntil(DateTime when);
    private Message GetCopyMessage(RedisKey& sourceKey, RedisKey destinationKey, int destinationDatabase, bool replace, CommandFlags flags);
    private Message GetExpiryMessage(RedisKey& key, CommandFlags flags, Nullable`1<TimeSpan> expiry, ExpireWhen when, ServerEndPoint& server);
    private Message GetExpiryMessage(RedisKey& key, CommandFlags flags, Nullable`1<DateTime> expiry, ExpireWhen when, ServerEndPoint& server);
    private Message GetExpiryMessage(RedisKey& key, RedisCommand millisecondsCommand, RedisCommand secondsCommand, long milliseconds, ExpireWhen when, CommandFlags flags, ServerEndPoint& server);
    private Message GetListMultiPopMessage(RedisKey[] keys, RedisValue side, long count, CommandFlags flags);
    private Message GetSortedSetMultiPopMessage(RedisKey[] keys, Order order, long count, CommandFlags flags);
    private Message GetHashSetMessage(RedisKey key, HashEntry[] hashFields, CommandFlags flags);
    [NullableContextAttribute("2")]
private ITransaction GetLockExtendTransaction(RedisKey key, RedisValue value, TimeSpan expiry);
    [NullableContextAttribute("2")]
private ITransaction GetLockReleaseTransaction(RedisKey key, RedisValue value);
    private static RedisValue GetLexRange(RedisValue value, Exclude exclude, bool isStart);
    private Message GetMultiStreamReadGroupMessage(StreamPosition[] streamPositions, RedisValue groupName, RedisValue consumerName, Nullable`1<int> countPerStream, bool noAck, CommandFlags flags);
    private Message GetMultiStreamReadMessage(StreamPosition[] streamPositions, Nullable`1<int> countPerStream, CommandFlags flags);
    private static RedisValue GetRange(double value, Exclude exclude, bool isStart);
    private Message GetRestoreMessage(RedisKey key, Byte[] value, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    private Message GetSetIntersectionLengthMessage(RedisKey[] keys, long limit, CommandFlags flags);
    private Message GetSortedSetAddMessage(RedisKey key, RedisValue member, double score, SortedSetWhen when, bool change, CommandFlags flags);
    private Message GetSortedSetAddMessage(RedisKey key, SortedSetEntry[] values, SortedSetWhen when, bool change, CommandFlags flags);
    [NullableContextAttribute("2")]
private Message GetSortMessage(RedisKey destination, RedisKey key, long skip, long take, Order order, SortType sortType, RedisValue by, RedisValue[] get, CommandFlags flags, ServerEndPoint& server);
    private Message GetSortedSetCombineAndStoreCommandMessage(SetOperation operation, RedisKey destination, RedisKey[] keys, Double[] weights, Aggregate aggregate, CommandFlags flags);
    private Message GetSortedSetCombineCommandMessage(SetOperation operation, RedisKey[] keys, Double[] weights, Aggregate aggregate, bool withScores, CommandFlags flags);
    [NullableContextAttribute("0")]
private void AddWeightsAggregationAndScore(Span`1<RedisValue> values, Double[] weights, Aggregate aggregate, bool withScores);
    private Message GetSortedSetLengthMessage(RedisKey key, double min, double max, Exclude exclude, CommandFlags flags);
    private Message GetSortedSetIntersectionLengthMessage(RedisKey[] keys, long limit, CommandFlags flags);
    private Message GetSortedSetRangeByScoreMessage(RedisKey key, double start, double stop, Exclude exclude, Order order, long skip, long take, CommandFlags flags, bool withScores);
    private Message GetSortedSetRemoveRangeByScoreMessage(RedisKey key, double start, double stop, Exclude exclude, CommandFlags flags);
    private Message GetStreamAcknowledgeMessage(RedisKey key, RedisValue groupName, RedisValue messageId, CommandFlags flags);
    private Message GetStreamAcknowledgeMessage(RedisKey key, RedisValue groupName, RedisValue[] messageIds, CommandFlags flags);
    private Message GetStreamAddMessage(RedisKey key, RedisValue messageId, Nullable`1<int> maxLength, bool useApproximateMaxLength, NameValueEntry streamPair, CommandFlags flags);
    private Message GetStreamAddMessage(RedisKey key, RedisValue entryId, Nullable`1<int> maxLength, bool useApproximateMaxLength, NameValueEntry[] streamPairs, CommandFlags flags);
    private Message GetStreamAutoClaimMessage(RedisKey key, RedisValue consumerGroup, RedisValue assignToConsumer, long minIdleTimeInMs, RedisValue startAtId, Nullable`1<int> count, bool idsOnly, CommandFlags flags);
    private Message GetStreamClaimMessage(RedisKey key, RedisValue consumerGroup, RedisValue assignToConsumer, long minIdleTimeInMs, RedisValue[] messageIds, bool returnJustIds, CommandFlags flags);
    private Message GetStreamCreateConsumerGroupMessage(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> position, bool createStream, CommandFlags flags);
    private Message GetStreamPendingMessagesMessage(RedisKey key, RedisValue groupName, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, int count, RedisValue consumerName, CommandFlags flags);
    private Message GetStreamRangeMessage(RedisKey key, Nullable`1<RedisValue> minId, Nullable`1<RedisValue> maxId, Nullable`1<int> count, Order messageOrder, CommandFlags flags);
    private Message GetStreamReadGroupMessage(RedisKey key, RedisValue groupName, RedisValue consumerName, RedisValue afterId, Nullable`1<int> count, bool noAck, CommandFlags flags);
    private Message GetSingleStreamReadMessage(RedisKey key, RedisValue afterId, Nullable`1<int> count, CommandFlags flags);
    private Message GetStreamTrimMessage(RedisKey key, int maxLength, bool useApproximateMaxLength, CommandFlags flags);
    private Message GetStringBitOperationMessage(Bitwise operation, RedisKey destination, RedisKey[] keys, CommandFlags flags);
    private Message GetStringBitOperationMessage(Bitwise operation, RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags);
    private Message GetStringGetExMessage(RedisKey& key, Nullable`1<TimeSpan> expiry, CommandFlags flags);
    private Message GetStringGetExMessage(RedisKey& key, DateTime expiry, CommandFlags flags);
    private Message GetStringGetWithExpiryMessage(RedisKey key, CommandFlags flags, ResultProcessor`1& processor, ServerEndPoint& server);
    [NullableContextAttribute("2")]
private Message GetStringSetMessage(KeyValuePair`2[] values, When when, CommandFlags flags);
    private Message GetStringSetMessage(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    private Message GetStringSetAndGetMessage(RedisKey key, RedisValue value, Nullable`1<TimeSpan> expiry, bool keepTtl, When when, CommandFlags flags);
    [NullableContextAttribute("2")]
private Message IncrMessage(RedisKey key, long value, CommandFlags flags);
    private static RedisCommand SetOperationCommand(SetOperation operation, bool store);
    [NullableContextAttribute("2")]
private CursorEnumerable`1<T> TryScan(RedisKey key, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags, RedisCommand command, ResultProcessor`1<ScanResult<T>> processor, ServerEndPoint& server, bool noValues);
    private Message GetLexMessage(RedisCommand command, RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual long SortedSetLengthByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    private static void ReverseLimits(Order order, Exclude& exclude, RedisValue& start, RedisValue& stop);
    public sealed virtual RedisValue[] SortedSetRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual long SortedSetRemoveRangeByValue(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetLengthByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<RedisValue[]> SortedSetRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, Order order, long skip, long take, CommandFlags flags);
    public sealed virtual Task`1<long> SortedSetRemoveRangeByValueAsync(RedisKey key, RedisValue min, RedisValue max, Exclude exclude, CommandFlags flags);
    private static Message CreateListPositionMessage(int db, CommandFlags flags, RedisKey key, RedisValue element, long rank, long maxLen, Nullable`1<long> count);
    private static Message CreateSortedSetRangeStoreMessage(int db, CommandFlags flags, RedisKey sourceKey, RedisKey destinationKey, RedisValue start, RedisValue stop, SortedSetOrder sortedSetOrder, Order order, Exclude exclude, long skip, Nullable`1<long> take);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisErrorEventArgs : EventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<RedisErrorEventArgs> handler;
    private object sender;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public EndPoint EndPoint { get; }
    public string Message { get; }
    internal RedisErrorEventArgs(EventHandler`1<RedisErrorEventArgs> handler, object sender, EndPoint endpoint, string message);
    public RedisErrorEventArgs(object sender, EndPoint endpoint, string message);
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public string get_Message();
    private sealed virtual override void StackExchange.Redis.ICompletable.AppendStormLog(StringBuilder sb);
    private sealed virtual override bool StackExchange.Redis.ICompletable.TryComplete(bool isAsync);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisException : Exception {
    public RedisException(string message);
    public RedisException(string message, Exception innerException);
    protected RedisException(SerializationInfo info, StreamingContext ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisFeatures : ValueType {
    internal static Version v2_0_0;
    internal static Version v2_1_0;
    internal static Version v2_1_1;
    internal static Version v2_1_2;
    internal static Version v2_1_3;
    internal static Version v2_1_8;
    internal static Version v2_2_0;
    internal static Version v2_4_0;
    internal static Version v2_5_7;
    internal static Version v2_5_10;
    internal static Version v2_5_14;
    internal static Version v2_6_0;
    internal static Version v2_6_5;
    internal static Version v2_6_9;
    internal static Version v2_6_12;
    internal static Version v2_8_0;
    internal static Version v2_8_12;
    internal static Version v2_8_18;
    internal static Version v2_9_5;
    internal static Version v3_0_0;
    internal static Version v3_2_0;
    internal static Version v3_2_1;
    internal static Version v4_0_0;
    internal static Version v4_9_1;
    internal static Version v5_0_0;
    internal static Version v6_0_0;
    internal static Version v6_0_6;
    internal static Version v6_2_0;
    internal static Version v7_0_0_rc1;
    internal static Version v7_2_0_rc1;
    internal static Version v7_4_0_rc1;
    internal static Version v7_4_0_rc2;
    private Version version;
    private static PropertyInfo[] s_props;
    public bool BitwiseOperations { get; }
    public bool ClientName { get; }
    public bool ClientId { get; }
    public bool ExecAbort { get; }
    public bool ExpireOverwrite { get; }
    public bool GetDelete { get; }
    public bool HashStringLength { get; }
    public bool HashVaradicDelete { get; }
    public bool IncrementFloat { get; }
    public bool InfoSections { get; }
    public bool ListInsert { get; }
    public bool Memory { get; }
    public bool MillisecondExpiry { get; }
    public bool Module { get; }
    public bool MultipleRandom { get; }
    public bool Persist { get; }
    public bool PushIfNotExists { get; }
    internal bool ReadOnlySort { get; }
    public bool Scan { get; }
    public bool Scripting { get; }
    public bool SetAndGet { get; }
    public bool SetConditional { get; }
    public bool SetKeepTtl { get; }
    public bool SetNotExistsAndGet { get; }
    public bool SetVaradicAddRemove { get; }
    public bool SortedSetPop { get; }
    public bool SortedSetRangeStore { get; }
    public bool Streams { get; }
    public bool StringLength { get; }
    public bool StringSetRange { get; }
    public bool SwapDB { get; }
    public bool Time { get; }
    public bool Unlink { get; }
    public bool ScriptingDatabaseSafe { get; }
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use HyperLogLogCountReplicaSafe instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public bool HyperLogLogCountSlaveSafe { get; }
    public bool HyperLogLogCountReplicaSafe { get; }
    public bool Geo { get; }
    internal bool PingOnSubscriber { get; }
    public bool SetPopMultiple { get; }
    public bool KeyTouch { get; }
    public bool ReplicaCommands { get; }
    public bool PushMultiple { get; }
    public bool Resp3 { get; }
    public Version Version { get; }
    public RedisFeatures(Version version);
    private static RedisFeatures();
    public bool get_BitwiseOperations();
    public bool get_ClientName();
    public bool get_ClientId();
    public bool get_ExecAbort();
    public bool get_ExpireOverwrite();
    public bool get_GetDelete();
    public bool get_HashStringLength();
    public bool get_HashVaradicDelete();
    public bool get_IncrementFloat();
    public bool get_InfoSections();
    public bool get_ListInsert();
    public bool get_Memory();
    public bool get_MillisecondExpiry();
    public bool get_Module();
    public bool get_MultipleRandom();
    public bool get_Persist();
    public bool get_PushIfNotExists();
    internal bool get_ReadOnlySort();
    public bool get_Scan();
    public bool get_Scripting();
    public bool get_SetAndGet();
    public bool get_SetConditional();
    public bool get_SetKeepTtl();
    public bool get_SetNotExistsAndGet();
    public bool get_SetVaradicAddRemove();
    public bool get_SortedSetPop();
    public bool get_SortedSetRangeStore();
    public bool get_Streams();
    public bool get_StringLength();
    public bool get_StringSetRange();
    public bool get_SwapDB();
    public bool get_Time();
    public bool get_Unlink();
    public bool get_ScriptingDatabaseSafe();
    public bool get_HyperLogLogCountSlaveSafe();
    public bool get_HyperLogLogCountReplicaSafe();
    public bool get_Geo();
    internal bool get_PingOnSubscriber();
    public bool get_SetPopMultiple();
    public bool get_KeyTouch();
    public bool get_ReplicaCommands();
    public bool get_PushMultiple();
    public bool get_Resp3();
    public Version get_Version();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisFeatures other);
    public static bool op_Equality(RedisFeatures left, RedisFeatures right);
    public static bool op_Inequality(RedisFeatures left, RedisFeatures right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisKey : ValueType {
    [CompilerGeneratedAttribute]
private static RedisKey <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeyPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private object <KeyValue>k__BackingField;
    internal bool IsNull { get; }
    internal static RedisKey Null { get; }
    internal bool IsEmpty { get; }
    internal Byte[] KeyPrefix { get; }
    internal object KeyValue { get; }
    internal RedisKey(Byte[] keyPrefix, object keyValue);
    public RedisKey(string key);
    private static RedisKey();
    internal RedisKey AsPrefix();
    internal bool get_IsNull();
    [CompilerGeneratedAttribute]
internal static RedisKey get_Null();
    internal bool get_IsEmpty();
    [CompilerGeneratedAttribute]
internal Byte[] get_KeyPrefix();
    [CompilerGeneratedAttribute]
internal object get_KeyValue();
    public static bool op_Inequality(RedisKey x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Inequality(string x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Inequality(Byte[] x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Inequality(RedisKey x, string y);
    [NullableContextAttribute("1")]
public static bool op_Inequality(RedisKey x, Byte[] y);
    public static bool op_Equality(RedisKey x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Equality(string x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Equality(Byte[] x, RedisKey y);
    [NullableContextAttribute("1")]
public static bool op_Equality(RedisKey x, string y);
    [NullableContextAttribute("1")]
public static bool op_Equality(RedisKey x, Byte[] y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisKey other);
    private bool EqualsImpl(RedisKey& other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal RedisValue AsRedisValue();
    internal void AssertNotNull();
    public static RedisKey op_Implicit(string key);
    public static RedisKey op_Implicit(Byte[] key);
    public static Byte[] op_Implicit(RedisKey key);
    public static string op_Implicit(RedisKey key);
    [ObsoleteAttribute("Prefer WithPrefix")]
public static RedisKey op_Addition(RedisKey x, RedisKey y);
    internal static RedisKey WithPrefix(Byte[] prefix, RedisKey value);
    internal static Byte[] ConcatenateBytes(Byte[] a, object b, Byte[] c);
    public RedisKey Prepend(RedisKey prefix);
    public RedisKey Append(RedisKey suffix);
    internal bool TryGetSimpleBuffer(Byte[]& arr);
    internal int TotalLength();
    [NullableContextAttribute("0")]
internal int CopyTo(Span`1<byte> destination);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <EqualsImpl>g__CopyCompare|28_0(RedisKey& x, RedisKey& y, int length, Span`1<byte> span);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <op_Implicit>g__Get|36_0(Byte[] arr, int length);
}
internal static class StackExchange.Redis.RedisLiterals : object {
    public static RedisValue ACLCAT;
    public static RedisValue ADDR;
    public static RedisValue AFTER;
    public static RedisValue AGGREGATE;
    public static RedisValue ALPHA;
    public static RedisValue AND;
    public static RedisValue ANY;
    public static RedisValue ASC;
    public static RedisValue AUTH;
    public static RedisValue BEFORE;
    public static RedisValue BIT;
    public static RedisValue BY;
    public static RedisValue BYLEX;
    public static RedisValue BYSCORE;
    public static RedisValue BYTE;
    public static RedisValue CH;
    public static RedisValue CHANNELS;
    public static RedisValue COPY;
    public static RedisValue COUNT;
    public static RedisValue DB;
    public static RedisValue default;
    public static RedisValue DESC;
    public static RedisValue DOCTOR;
    public static RedisValue ENCODING;
    public static RedisValue EX;
    public static RedisValue EXAT;
    public static RedisValue EXISTS;
    public static RedisValue FIELDS;
    public static RedisValue FILTERBY;
    public static RedisValue FLUSH;
    public static RedisValue FREQ;
    public static RedisValue GET;
    public static RedisValue GETKEYS;
    public static RedisValue GETNAME;
    public static RedisValue GT;
    public static RedisValue HISTORY;
    public static RedisValue ID;
    public static RedisValue IDX;
    public static RedisValue IDLETIME;
    public static RedisValue KEEPTTL;
    public static RedisValue KILL;
    public static RedisValue LADDR;
    public static RedisValue LATEST;
    public static RedisValue LEFT;
    public static RedisValue LEN;
    public static RedisValue lib_name;
    public static RedisValue lib_ver;
    public static RedisValue LIMIT;
    public static RedisValue LIST;
    public static RedisValue LOAD;
    public static RedisValue LT;
    public static RedisValue MATCH;
    public static RedisValue MALLOC_STATS;
    public static RedisValue MAX;
    public static RedisValue MAXAGE;
    public static RedisValue MAXLEN;
    public static RedisValue MIN;
    public static RedisValue MINMATCHLEN;
    public static RedisValue MODULE;
    public static RedisValue NODES;
    public static RedisValue NOSAVE;
    public static RedisValue NOT;
    public static RedisValue NOVALUES;
    public static RedisValue NUMPAT;
    public static RedisValue NUMSUB;
    public static RedisValue NX;
    public static RedisValue OBJECT;
    public static RedisValue OR;
    public static RedisValue PATTERN;
    public static RedisValue PAUSE;
    public static RedisValue PERSIST;
    public static RedisValue PING;
    public static RedisValue PURGE;
    public static RedisValue PX;
    public static RedisValue PXAT;
    public static RedisValue RANK;
    public static RedisValue REFCOUNT;
    public static RedisValue REPLACE;
    public static RedisValue RESET;
    public static RedisValue RESETSTAT;
    public static RedisValue REV;
    public static RedisValue REWRITE;
    public static RedisValue RIGHT;
    public static RedisValue SAVE;
    public static RedisValue SEGFAULT;
    public static RedisValue SET;
    public static RedisValue SETINFO;
    public static RedisValue SETNAME;
    public static RedisValue SKIPME;
    public static RedisValue STATS;
    public static RedisValue STORE;
    public static RedisValue TYPE;
    public static RedisValue USERNAME;
    public static RedisValue WEIGHTS;
    public static RedisValue WITHMATCHLEN;
    public static RedisValue WITHSCORES;
    public static RedisValue WITHVALUES;
    public static RedisValue XOR;
    public static RedisValue XX;
    public static RedisValue MASTERS;
    public static RedisValue MASTER;
    public static RedisValue REPLICAS;
    public static RedisValue SLAVES;
    public static RedisValue GETMASTERADDRBYNAME;
    public static RedisValue FAILOVER;
    public static RedisValue SENTINELS;
    public static RedisValue MONITOR;
    public static RedisValue REMOVE;
    public static RedisValue connect;
    public static RedisValue connected;
    public static RedisValue connecting;
    public static RedisValue handshake;
    public static RedisValue none;
    public static RedisValue sync;
    public static RedisValue MinusSymbol;
    public static RedisValue PlusSymbol;
    public static RedisValue Wildcard;
    public static RedisValue BYBOX;
    public static RedisValue BYRADIUS;
    public static RedisValue FROMMEMBER;
    public static RedisValue FROMLONLAT;
    public static RedisValue STOREDIST;
    public static RedisValue WITHCOORD;
    public static RedisValue WITHDIST;
    public static RedisValue WITHHASH;
    public static RedisValue ft;
    public static RedisValue km;
    public static RedisValue m;
    public static RedisValue mi;
    public static RedisValue databases;
    public static RedisValue master;
    public static RedisValue no;
    public static RedisValue normal;
    public static RedisValue pubsub;
    public static RedisValue replica;
    public static RedisValue replica_read_only;
    public static RedisValue replication;
    public static RedisValue sentinel;
    public static RedisValue server;
    public static RedisValue slave;
    public static RedisValue slave_read_only;
    public static RedisValue timeout;
    public static RedisValue yes;
    private static RedisLiterals();
    internal static RedisValue Get(Bitwise operation);
}
public enum StackExchange.Redis.RedisProtocol : Enum {
    public int value__;
    public static RedisProtocol Resp2;
    public static RedisProtocol Resp3;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class StackExchange.Redis.RedisResult : object {
    private static RedisResult s_EmptyArray;
    private static RedisResult s_EmptySet;
    private static RedisResult s_EmptyMap;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static RedisResult <NullArray>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static RedisResult <NullSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultType <Resp3Type>k__BackingField;
    [NullableAttribute("1")]
internal static RedisResult NullArray { get; }
    [NullableAttribute("1")]
internal static RedisResult NullSingle { get; }
    public int Length { get; }
    [ObsoleteAttribute("Please use either Resp2Type (simplified) or Resp3Type (full)")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public ResultType Type { get; }
    public ResultType Resp3Type { get; }
    public ResultType Resp2Type { get; }
    internal ResultType Resp2NullType { get; }
    public bool IsNull { get; }
    [NullableAttribute("1")]
public RedisResult Item { get; }
    internal RedisResult(ResultType resultType);
    private static RedisResult();
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisValue value, Nullable`1<ResultType> resultType);
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisValue[] values);
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisValue[] values, ResultType resultType);
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisResult[] values);
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisResult[] values, ResultType resultType);
    [NullableContextAttribute("1")]
internal static RedisResult EmptyArray(ResultType type);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static RedisResult get_NullArray();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static RedisResult get_NullSingle();
    public virtual int get_Length();
    [NullableContextAttribute("1")]
public sealed virtual string ToString();
    public abstract virtual string ToString(String& type);
    internal static bool TryCreate(PhysicalConnection connection, RawResult& result, RedisResult& redisResult);
    public ResultType get_Type();
    [CompilerGeneratedAttribute]
public ResultType get_Resp3Type();
    public ResultType get_Resp2Type();
    internal virtual ResultType get_Resp2NullType();
    public abstract virtual bool get_IsNull();
    public static string op_Explicit(RedisResult result);
    public static Byte[] op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
public static double op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
public static long op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static ulong op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
public static int op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
public static bool op_Explicit(RedisResult result);
    public static RedisValue op_Explicit(RedisResult result);
    public static RedisKey op_Explicit(RedisResult result);
    public static Nullable`1<double> op_Explicit(RedisResult result);
    public static Nullable`1<long> op_Explicit(RedisResult result);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(RedisResult result);
    public static Nullable`1<int> op_Explicit(RedisResult result);
    public static Nullable`1<bool> op_Explicit(RedisResult result);
    public static String[] op_Explicit(RedisResult result);
    public static Byte[][] op_Explicit(RedisResult result);
    public static Double[] op_Explicit(RedisResult result);
    public static Int64[] op_Explicit(RedisResult result);
    [CLSCompliantAttribute("False")]
public static UInt64[] op_Explicit(RedisResult result);
    public static Int32[] op_Explicit(RedisResult result);
    public static Boolean[] op_Explicit(RedisResult result);
    public static RedisValue[] op_Explicit(RedisResult result);
    public static RedisKey[] op_Explicit(RedisResult result);
    public static RedisResult[] op_Explicit(RedisResult result);
    [NullableContextAttribute("1")]
public Dictionary`2<string, RedisResult> ToDictionary(IEqualityComparer`1<string> comparer);
    [NullableContextAttribute("1")]
public virtual RedisResult get_Item(int index);
    internal abstract virtual bool AsBoolean();
    internal abstract virtual Boolean[] AsBooleanArray();
    internal abstract virtual Byte[] AsByteArray();
    internal abstract virtual Byte[][] AsByteArrayArray();
    internal abstract virtual double AsDouble();
    internal abstract virtual Double[] AsDoubleArray();
    internal abstract virtual int AsInt32();
    internal abstract virtual Int32[] AsInt32Array();
    internal abstract virtual long AsInt64();
    internal abstract virtual ulong AsUInt64();
    internal abstract virtual Int64[] AsInt64Array();
    internal abstract virtual UInt64[] AsUInt64Array();
    internal abstract virtual Nullable`1<bool> AsNullableBoolean();
    internal abstract virtual Nullable`1<double> AsNullableDouble();
    internal abstract virtual Nullable`1<int> AsNullableInt32();
    internal abstract virtual Nullable`1<long> AsNullableInt64();
    internal abstract virtual Nullable`1<ulong> AsNullableUInt64();
    internal abstract virtual RedisKey AsRedisKey();
    internal abstract virtual RedisKey[] AsRedisKeyArray();
    internal abstract virtual RedisResult[] AsRedisResultArray();
    internal abstract virtual RedisValue AsRedisValue();
    internal abstract virtual RedisValue[] AsRedisValueArray();
    internal abstract virtual string AsString();
    internal abstract virtual String[] AsStringArray();
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisKey key);
    [NullableContextAttribute("1")]
public static RedisResult Create(RedisChannel channel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.RedisServer : RedisBase {
    private ServerEndPoint server;
    private int StackExchange.Redis.IServer.DatabaseCount { get; }
    [NullableAttribute("2")]
public ClusterConfiguration ClusterConfiguration { get; }
    public EndPoint EndPoint { get; }
    public RedisFeatures Features { get; }
    public bool IsConnected { get; }
    private bool StackExchange.Redis.IServer.IsSlave { get; }
    public bool IsReplica { get; }
    public RedisProtocol Protocol { get; }
    private bool StackExchange.Redis.IServer.AllowSlaveWrites { get; private set; }
    public bool AllowReplicaWrites { get; public set; }
    public ServerType ServerType { get; }
    public Version Version { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IGrouping`2[] InfoDefault { get; }
    internal RedisServer(ConnectionMultiplexer multiplexer, ServerEndPoint server, object asyncState);
    private sealed virtual override int StackExchange.Redis.IServer.get_DatabaseCount();
    [NullableContextAttribute("2")]
public sealed virtual ClusterConfiguration get_ClusterConfiguration();
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual RedisFeatures get_Features();
    public sealed virtual bool get_IsConnected();
    private sealed virtual override bool StackExchange.Redis.IServer.get_IsSlave();
    public sealed virtual bool get_IsReplica();
    public sealed virtual RedisProtocol get_Protocol();
    private sealed virtual override bool StackExchange.Redis.IServer.get_AllowSlaveWrites();
    private sealed virtual override void StackExchange.Redis.IServer.set_AllowSlaveWrites(bool value);
    public sealed virtual bool get_AllowReplicaWrites();
    public sealed virtual void set_AllowReplicaWrites(bool value);
    public sealed virtual ServerType get_ServerType();
    public sealed virtual Version get_Version();
    public sealed virtual void ClientKill(EndPoint endpoint, CommandFlags flags);
    public sealed virtual Task ClientKillAsync(EndPoint endpoint, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual long ClientKill(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public sealed virtual Task`1<long> ClientKillAsync(Nullable`1<long> id, Nullable`1<ClientType> clientType, EndPoint endpoint, bool skipMe, CommandFlags flags);
    public sealed virtual long ClientKill(ClientKillFilter filter, CommandFlags flags);
    public sealed virtual Task`1<long> ClientKillAsync(ClientKillFilter filter, CommandFlags flags);
    private Message GetClientKillMessage(EndPoint endpoint, Nullable`1<long> id, Nullable`1<ClientType> clientType, Nullable`1<bool> skipMe, CommandFlags flags);
    public sealed virtual ClientInfo[] ClientList(CommandFlags flags);
    public sealed virtual Task`1<ClientInfo[]> ClientListAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual ClusterConfiguration ClusterNodes(CommandFlags flags);
    public sealed virtual Task`1<ClusterConfiguration> ClusterNodesAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string ClusterNodesRaw(CommandFlags flags);
    public sealed virtual Task`1<string> ClusterNodesRawAsync(CommandFlags flags);
    public sealed virtual KeyValuePair`2[] ConfigGet(RedisValue pattern, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[]> ConfigGetAsync(RedisValue pattern, CommandFlags flags);
    public sealed virtual void ConfigResetStatistics(CommandFlags flags);
    public sealed virtual Task ConfigResetStatisticsAsync(CommandFlags flags);
    public sealed virtual void ConfigRewrite(CommandFlags flags);
    public sealed virtual Task ConfigRewriteAsync(CommandFlags flags);
    public sealed virtual void ConfigSet(RedisValue setting, RedisValue value, CommandFlags flags);
    public sealed virtual Task ConfigSetAsync(RedisValue setting, RedisValue value, CommandFlags flags);
    public sealed virtual long CommandCount(CommandFlags flags);
    public sealed virtual Task`1<long> CommandCountAsync(CommandFlags flags);
    public sealed virtual RedisKey[] CommandGetKeys(RedisValue[] command, CommandFlags flags);
    public sealed virtual Task`1<RedisKey[]> CommandGetKeysAsync(RedisValue[] command, CommandFlags flags);
    public sealed virtual String[] CommandList(Nullable`1<RedisValue> moduleName, Nullable`1<RedisValue> category, Nullable`1<RedisValue> pattern, CommandFlags flags);
    public sealed virtual Task`1<String[]> CommandListAsync(Nullable`1<RedisValue> moduleName, Nullable`1<RedisValue> category, Nullable`1<RedisValue> pattern, CommandFlags flags);
    private Message GetCommandListMessage(Nullable`1<RedisValue> moduleName, Nullable`1<RedisValue> category, Nullable`1<RedisValue> pattern, CommandFlags flags);
    private RedisValue[] AddValueToArray(RedisValue val, RedisValue[] arr);
    private RedisValue[] MakeArray(RedisValue[] redisValues);
    public sealed virtual long DatabaseSize(int database, CommandFlags flags);
    public sealed virtual Task`1<long> DatabaseSizeAsync(int database, CommandFlags flags);
    public sealed virtual RedisValue Echo(RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<RedisValue> EchoAsync(RedisValue message, CommandFlags flags);
    public sealed virtual void FlushAllDatabases(CommandFlags flags);
    public sealed virtual Task FlushAllDatabasesAsync(CommandFlags flags);
    public sealed virtual void FlushDatabase(int database, CommandFlags flags);
    public sealed virtual Task FlushDatabaseAsync(int database, CommandFlags flags);
    public sealed virtual ServerCounters GetCounters();
    private static IGrouping`2[] get_InfoDefault();
    public sealed virtual IGrouping`2[] Info(RedisValue section, CommandFlags flags);
    public sealed virtual Task`1<IGrouping`2[]> InfoAsync(RedisValue section, CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string InfoRaw(RedisValue section, CommandFlags flags);
    public sealed virtual Task`1<string> InfoRawAsync(RedisValue section, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisKey> StackExchange.Redis.IServer.Keys(int database, RedisValue pattern, int pageSize, CommandFlags flags);
    private sealed virtual override IEnumerable`1<RedisKey> StackExchange.Redis.IServer.Keys(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private sealed virtual override IAsyncEnumerable`1<RedisKey> StackExchange.Redis.IServer.KeysAsync(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    private CursorEnumerable`1<RedisKey> KeysAsync(int database, RedisValue pattern, int pageSize, long cursor, int pageOffset, CommandFlags flags);
    public sealed virtual DateTime LastSave(CommandFlags flags);
    public sealed virtual Task`1<DateTime> LastSaveAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual void MakeMaster(ReplicationChangeOptions options, TextWriter log);
    [AsyncStateMachineAttribute("StackExchange.Redis.RedisServer/<MakePrimaryAsync>d__80")]
public sealed virtual Task MakePrimaryAsync(ReplicationChangeOptions options, TextWriter log);
    public sealed virtual Role Role(CommandFlags flags);
    public sealed virtual Task`1<Role> RoleAsync(CommandFlags flags);
    public sealed virtual void Save(SaveType type, CommandFlags flags);
    public sealed virtual Task SaveAsync(SaveType type, CommandFlags flags);
    public sealed virtual bool ScriptExists(string script, CommandFlags flags);
    public sealed virtual bool ScriptExists(Byte[] sha1, CommandFlags flags);
    public sealed virtual Task`1<bool> ScriptExistsAsync(string script, CommandFlags flags);
    public sealed virtual Task`1<bool> ScriptExistsAsync(Byte[] sha1, CommandFlags flags);
    public sealed virtual void ScriptFlush(CommandFlags flags);
    public sealed virtual Task ScriptFlushAsync(CommandFlags flags);
    public sealed virtual Byte[] ScriptLoad(string script, CommandFlags flags);
    public sealed virtual Task`1<Byte[]> ScriptLoadAsync(string script, CommandFlags flags);
    public sealed virtual LoadedLuaScript ScriptLoad(LuaScript script, CommandFlags flags);
    public sealed virtual Task`1<LoadedLuaScript> ScriptLoadAsync(LuaScript script, CommandFlags flags);
    public sealed virtual void Shutdown(ShutdownMode shutdownMode, CommandFlags flags);
    public sealed virtual CommandTrace[] SlowlogGet(int count, CommandFlags flags);
    public sealed virtual Task`1<CommandTrace[]> SlowlogGetAsync(int count, CommandFlags flags);
    public sealed virtual void SlowlogReset(CommandFlags flags);
    public sealed virtual Task SlowlogResetAsync(CommandFlags flags);
    public RedisValue StringGet(int db, RedisKey key, CommandFlags flags);
    public Task`1<RedisValue> StringGetAsync(int db, RedisKey key, CommandFlags flags);
    public sealed virtual RedisChannel[] SubscriptionChannels(RedisChannel pattern, CommandFlags flags);
    public sealed virtual Task`1<RedisChannel[]> SubscriptionChannelsAsync(RedisChannel pattern, CommandFlags flags);
    public sealed virtual long SubscriptionPatternCount(CommandFlags flags);
    public sealed virtual Task`1<long> SubscriptionPatternCountAsync(CommandFlags flags);
    public sealed virtual long SubscriptionSubscriberCount(RedisChannel channel, CommandFlags flags);
    public sealed virtual Task`1<long> SubscriptionSubscriberCountAsync(RedisChannel channel, CommandFlags flags);
    public sealed virtual void SwapDatabases(int first, int second, CommandFlags flags);
    public sealed virtual Task SwapDatabasesAsync(int first, int second, CommandFlags flags);
    public sealed virtual DateTime Time(CommandFlags flags);
    public sealed virtual Task`1<DateTime> TimeAsync(CommandFlags flags);
    internal static Message CreateReplicaOfMessage(ServerEndPoint sendMessageTo, EndPoint primaryEndpoint, CommandFlags flags);
    [NullableContextAttribute("2")]
private Message GetTiebreakerRemovalMessage();
    [NullableContextAttribute("2")]
private Message GetConfigChangeMessage();
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, T defaultValue, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server, T defaultValue);
    internal virtual RedisFeatures GetFeatures(RedisKey& modreq(System.Runtime.InteropServices.InAttribute) key, CommandFlags flags, RedisCommand command, ServerEndPoint& server);
    private sealed virtual override void StackExchange.Redis.IServer.SlaveOf(EndPoint master, CommandFlags flags);
    public sealed virtual void ReplicaOf(EndPoint master, CommandFlags flags);
    private sealed virtual override Task StackExchange.Redis.IServer.SlaveOfAsync(EndPoint master, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.RedisServer/<ReplicaOfAsync>d__122")]
public sealed virtual Task ReplicaOfAsync(EndPoint master, CommandFlags flags);
    private static void FixFlags(Message message, ServerEndPoint server);
    private static Message GetSaveMessage(SaveType type, CommandFlags flags);
    private static ResultProcessor`1<bool> GetSaveResultProcessor(SaveType type);
    public sealed virtual EndPoint SentinelGetMasterAddressByName(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> SentinelGetMasterAddressByNameAsync(string serviceName, CommandFlags flags);
    public sealed virtual EndPoint[] SentinelGetSentinelAddresses(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<EndPoint[]> SentinelGetSentinelAddressesAsync(string serviceName, CommandFlags flags);
    public sealed virtual EndPoint[] SentinelGetReplicaAddresses(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<EndPoint[]> SentinelGetReplicaAddressesAsync(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[] SentinelMaster(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[]> SentinelMasterAsync(string serviceName, CommandFlags flags);
    public sealed virtual void SentinelFailover(string serviceName, CommandFlags flags);
    public sealed virtual Task SentinelFailoverAsync(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[][] SentinelMasters(CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[][]> SentinelMastersAsync(CommandFlags flags);
    private sealed virtual override KeyValuePair`2[][] StackExchange.Redis.IServer.SentinelSlaves(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[][] SentinelReplicas(string serviceName, CommandFlags flags);
    private sealed virtual override Task`1<KeyValuePair`2[][]> StackExchange.Redis.IServer.SentinelSlavesAsync(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[][]> SentinelReplicasAsync(string serviceName, CommandFlags flags);
    public sealed virtual KeyValuePair`2[][] SentinelSentinels(string serviceName, CommandFlags flags);
    public sealed virtual Task`1<KeyValuePair`2[][]> SentinelSentinelsAsync(string serviceName, CommandFlags flags);
    public sealed virtual RedisResult Execute(string command, Object[] args);
    public sealed virtual RedisResult Execute(string command, ICollection`1<object> args, CommandFlags flags);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, Object[] args);
    public sealed virtual Task`1<RedisResult> ExecuteAsync(string command, ICollection`1<object> args, CommandFlags flags);
    internal void SimulateConnectionFailure(SimulatedFailureType failureType);
    public sealed virtual Task`1<string> LatencyDoctorAsync(CommandFlags flags);
    public sealed virtual string LatencyDoctor(CommandFlags flags);
    private static Message LatencyResetCommand(String[] eventNames, CommandFlags flags);
    public sealed virtual Task`1<long> LatencyResetAsync(String[] eventNames, CommandFlags flags);
    public sealed virtual long LatencyReset(String[] eventNames, CommandFlags flags);
    public sealed virtual Task`1<LatencyHistoryEntry[]> LatencyHistoryAsync(string eventName, CommandFlags flags);
    public sealed virtual LatencyHistoryEntry[] LatencyHistory(string eventName, CommandFlags flags);
    public sealed virtual Task`1<LatencyLatestEntry[]> LatencyLatestAsync(CommandFlags flags);
    public sealed virtual LatencyLatestEntry[] LatencyLatest(CommandFlags flags);
    public sealed virtual Task`1<string> MemoryDoctorAsync(CommandFlags flags);
    public sealed virtual string MemoryDoctor(CommandFlags flags);
    public sealed virtual Task MemoryPurgeAsync(CommandFlags flags);
    public sealed virtual void MemoryPurge(CommandFlags flags);
    public sealed virtual Task`1<string> MemoryAllocatorStatsAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
public sealed virtual string MemoryAllocatorStats(CommandFlags flags);
    public sealed virtual Task`1<RedisResult> MemoryStatsAsync(CommandFlags flags);
    public sealed virtual RedisResult MemoryStats(CommandFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisServerException : RedisException {
    public RedisServerException(string message);
    private RedisServerException(SerializationInfo info, StreamingContext ctx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisStream : ValueType {
    [CompilerGeneratedAttribute]
private RedisKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamEntry[] <Entries>k__BackingField;
    public RedisKey Key { get; }
    public StreamEntry[] Entries { get; }
    internal RedisStream(RedisKey key, StreamEntry[] entries);
    [CompilerGeneratedAttribute]
public RedisKey get_Key();
    [CompilerGeneratedAttribute]
public StreamEntry[] get_Entries();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.RedisSubscriber : RedisBase {
    internal RedisSubscriber(ConnectionMultiplexer multiplexer, object asyncState);
    [NullableContextAttribute("2")]
public sealed virtual EndPoint IdentifyEndpoint(RedisChannel channel, CommandFlags flags);
    public sealed virtual Task`1<EndPoint> IdentifyEndpointAsync(RedisChannel channel, CommandFlags flags);
    public sealed virtual bool IsConnected(RedisChannel channel);
    public virtual TimeSpan Ping(CommandFlags flags);
    public virtual Task`1<TimeSpan> PingAsync(CommandFlags flags);
    private Message CreatePingMessage(CommandFlags flags);
    private static void ThrowIfNull(RedisChannel& channel);
    public sealed virtual long Publish(RedisChannel channel, RedisValue message, CommandFlags flags);
    public sealed virtual Task`1<long> PublishAsync(RedisChannel channel, RedisValue message, CommandFlags flags);
    private sealed virtual override void StackExchange.Redis.ISubscriber.Subscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    public sealed virtual ChannelMessageQueue Subscribe(RedisChannel channel, CommandFlags flags);
    [NullableContextAttribute("2")]
public bool Subscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, ChannelMessageQueue queue, CommandFlags flags);
    internal bool EnsureSubscribedToServer(Subscription sub, RedisChannel channel, CommandFlags flags, bool internalCall);
    private sealed virtual override Task StackExchange.Redis.ISubscriber.SubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    [AsyncStateMachineAttribute("StackExchange.Redis.RedisSubscriber/<SubscribeAsync>d__15")]
public sealed virtual Task`1<ChannelMessageQueue> SubscribeAsync(RedisChannel channel, CommandFlags flags);
    [NullableContextAttribute("2")]
public Task`1<bool> SubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, ChannelMessageQueue queue, CommandFlags flags);
    public Task`1<bool> EnsureSubscribedToServerAsync(Subscription sub, RedisChannel channel, CommandFlags flags, bool internalCall);
    [NullableContextAttribute("2")]
public sealed virtual EndPoint SubscribedEndpoint(RedisChannel channel);
    [NullableContextAttribute("2")]
private sealed virtual override void StackExchange.Redis.ISubscriber.Unsubscribe(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    [NullableContextAttribute("2")]
public bool Unsubscribe(RedisChannel& channel, Action`2<RedisChannel, RedisValue> handler, ChannelMessageQueue queue, CommandFlags flags);
    private bool UnsubscribeFromServer(Subscription sub, RedisChannel channel, CommandFlags flags, bool internalCall);
    private sealed virtual override Task StackExchange.Redis.ISubscriber.UnsubscribeAsync(RedisChannel channel, Action`2<RedisChannel, RedisValue> handler, CommandFlags flags);
    [NullableContextAttribute("2")]
public Task`1<bool> UnsubscribeAsync(RedisChannel& channel, Action`2<RedisChannel, RedisValue> handler, ChannelMessageQueue queue, CommandFlags flags);
    private Task`1<bool> UnsubscribeFromServerAsync(Subscription sub, RedisChannel channel, CommandFlags flags, object asyncState, bool internalCall);
    [NullableContextAttribute("2")]
private bool UnregisterSubscription(RedisChannel& channel, Action`2<RedisChannel, RedisValue> handler, ChannelMessageQueue queue, Subscription& sub);
    public sealed virtual void UnsubscribeAll(CommandFlags flags);
    public sealed virtual Task UnsubscribeAllAsync(CommandFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.RedisTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private CommandStatus <Commandstatus>k__BackingField;
    public CommandStatus Commandstatus { get; }
    public RedisTimeoutException(string message, CommandStatus commandStatus);
    private RedisTimeoutException(SerializationInfo info, StreamingContext ctx);
    [CompilerGeneratedAttribute]
public CommandStatus get_Commandstatus();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.RedisTransaction : RedisDatabase {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ConditionResult> _conditions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<QueuedMessage> _pending;
    private object SyncLock { get; }
    public RedisTransaction(RedisDatabase wrapped, object asyncState);
    private object get_SyncLock();
    public sealed virtual ConditionResult AddCondition(Condition condition);
    public sealed virtual void Execute();
    public sealed virtual bool Execute(CommandFlags flags);
    public sealed virtual Task`1<bool> ExecuteAsync(CommandFlags flags);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, T defaultValue, ServerEndPoint server);
    [NullableContextAttribute("2")]
internal virtual Task`1<T> ExecuteAsync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server);
    private void QueueMessage(Message message);
    [NullableContextAttribute("2")]
internal virtual T ExecuteSync(Message message, ResultProcessor`1<T> processor, ServerEndPoint server, T defaultValue);
    [NullableContextAttribute("2")]
private Message CreateMessage(CommandFlags flags, ResultProcessor`1& processor);
}
public enum StackExchange.Redis.RedisType : Enum {
    public int value__;
    public static RedisType None;
    public static RedisType String;
    public static RedisType List;
    public static RedisType Set;
    public static RedisType SortedSet;
    public static RedisType Hash;
    public static RedisType Stream;
    public static RedisType Unknown;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisValue : ValueType {
    [NullableAttribute("1")]
internal static RedisValue[] EmptyArray;
    private object _objectOrSentinel;
    [NullableAttribute("0")]
private ReadOnlyMemory`1<byte> _memory;
    private long _overlappedBits64;
    [NullableAttribute("1")]
private static object Sentinel_SignedInteger;
    [NullableAttribute("1")]
private static object Sentinel_UnsignedInteger;
    [NullableAttribute("1")]
private static object Sentinel_Raw;
    [NullableAttribute("1")]
private static object Sentinel_Double;
    [CompilerGeneratedAttribute]
private static RedisValue <EmptyString>k__BackingField;
    [NullableAttribute("1")]
private static object s_DoubleNAN;
    [NullableAttribute("1")]
private static object s_DoublePosInf;
    [NullableAttribute("1")]
private static object s_DoubleNegInf;
    [NullableAttribute("1")]
private static object s_EmptyString;
    [NullableAttribute("1")]
private static Object[] s_CommonInt32;
    [CompilerGeneratedAttribute]
private static RedisValue <Null>k__BackingField;
    private static FieldInfo s_origin;
    private static FieldInfo s_buffer;
    internal object DirectObject { get; }
    internal long DirectOverlappedBits64 { get; }
    public static RedisValue EmptyString { get; }
    public static RedisValue Null { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("2")]
public bool IsInteger { get; }
    public bool IsNull { get; }
    public bool IsNullOrEmpty { get; }
    public bool HasValue { get; }
    private double OverlappedValueDouble { get; }
    internal long OverlappedValueInt64 { get; }
    internal ulong OverlappedValueUInt64 { get; }
    internal StorageType Type { get; }
    [NullableContextAttribute("0")]
private RedisValue(long overlappedValue64, ReadOnlyMemory`1<byte> memory, object objectOrSentinel);
    [NullableContextAttribute("1")]
internal RedisValue(object obj, long overlappedBits);
    [NullableContextAttribute("1")]
public RedisValue(string value);
    private static RedisValue();
    internal object get_DirectObject();
    internal long get_DirectOverlappedBits64();
    public object Box();
    public static RedisValue Unbox(object value);
    [CompilerGeneratedAttribute]
public static RedisValue get_EmptyString();
    [CompilerGeneratedAttribute]
public static RedisValue get_Null();
    public bool get_IsInteger();
    public bool get_IsNull();
    public bool get_IsNullOrEmpty();
    public bool get_HasValue();
    public static bool op_Inequality(RedisValue x, RedisValue y);
    private double get_OverlappedValueDouble();
    internal long get_OverlappedValueInt64();
    internal ulong get_OverlappedValueUInt64();
    public static bool op_Equality(RedisValue x, RedisValue y);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RedisValue other);
    public virtual int GetHashCode();
    private static int GetHashCode(RedisValue x);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal static bool Equals(Byte[] x, Byte[] y);
    [NullableContextAttribute("0")]
internal static int GetHashCode(ReadOnlySpan`1<byte> span);
    internal void AssertNotNull();
    internal StorageType get_Type();
    public long Length();
    public sealed virtual int CompareTo(RedisValue other);
    private static int CompareTo(RedisValue x, RedisValue y);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    internal static RedisValue TryParse(object obj, Boolean& valid);
    public static RedisValue op_Implicit(int value);
    public static RedisValue op_Implicit(Nullable`1<int> value);
    public static RedisValue op_Implicit(long value);
    public static RedisValue op_Implicit(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public static RedisValue op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static RedisValue op_Implicit(Nullable`1<ulong> value);
    [CLSCompliantAttribute("False")]
public static RedisValue op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static RedisValue op_Implicit(Nullable`1<UInt32> value);
    public static RedisValue op_Implicit(double value);
    public static RedisValue op_Implicit(Nullable`1<double> value);
    [NullableContextAttribute("0")]
public static RedisValue op_Implicit(ReadOnlyMemory`1<byte> value);
    [NullableContextAttribute("0")]
public static RedisValue op_Implicit(Memory`1<byte> value);
    public static RedisValue op_Implicit(string value);
    public static RedisValue op_Implicit(Byte[] value);
    public static RedisValue op_Implicit(bool value);
    public static RedisValue op_Implicit(Nullable`1<bool> value);
    public static bool op_Explicit(RedisValue value);
    public static int op_Explicit(RedisValue value);
    public static long op_Explicit(RedisValue value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(RedisValue value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(RedisValue value);
    public static double op_Explicit(RedisValue value);
    public static decimal op_Explicit(RedisValue value);
    public static float op_Explicit(RedisValue value);
    [NullableContextAttribute("0")]
private static bool TryParseDouble(ReadOnlySpan`1<byte> blob, Double& value);
    public static Nullable`1<double> op_Explicit(RedisValue value);
    public static Nullable`1<float> op_Explicit(RedisValue value);
    public static Nullable`1<decimal> op_Explicit(RedisValue value);
    public static Nullable`1<long> op_Explicit(RedisValue value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(RedisValue value);
    public static Nullable`1<int> op_Explicit(RedisValue value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(RedisValue value);
    public static Nullable`1<bool> op_Explicit(RedisValue value);
    public static string op_Implicit(RedisValue value);
    [NullableContextAttribute("0")]
private static string ToHex(ReadOnlySpan`1<byte> src);
    public static Byte[] op_Implicit(RedisValue value);
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<byte> op_Implicit(RedisValue value);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    internal RedisValue Simplify();
    public bool TryParse(Int64& val);
    public bool TryParse(Int32& val);
    public bool TryParse(Double& val);
    [NullableContextAttribute("1")]
public static RedisValue CreateFrom(MemoryStream stream);
    [NullableContextAttribute("0")]
private static bool ReflectionTryGetBuffer(MemoryStream ms, ArraySegment`1& buffer);
    public bool StartsWith(RedisValue value);
    [NullableContextAttribute("0")]
private ReadOnlyMemory`1<byte> AsMemory(Byte[]& leased);
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.RedisValueWithExpiry : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Expiry>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <Value>k__BackingField;
    public Nullable`1<TimeSpan> Expiry { get; }
    public RedisValue Value { get; }
    public RedisValueWithExpiry(RedisValue value, Nullable`1<TimeSpan> expiry);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Expiry();
    [CompilerGeneratedAttribute]
public RedisValue get_Value();
}
[FlagsAttribute]
public enum StackExchange.Redis.ReplicationChangeOptions : Enum {
    public int value__;
    public static ReplicationChangeOptions None;
    public static ReplicationChangeOptions SetTiebreaker;
    public static ReplicationChangeOptions Broadcast;
    [ObsoleteAttribute("Starting with Redis version 5, Redis has moved to 'replica' terminology. Please use ReplicateToOtherEndpoints instead, this will be removed in 3.0.")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ReplicationChangeOptions EnslaveSubordinates;
    public static ReplicationChangeOptions ReplicateToOtherEndpoints;
    public static ReplicationChangeOptions All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class StackExchange.Redis.ResultProcessor : object {
    public static ResultProcessor`1<bool> Boolean;
    public static ResultProcessor`1<bool> DemandOK;
    public static ResultProcessor`1<bool> DemandPONG;
    public static ResultProcessor`1<bool> DemandZeroOrOne;
    public static ResultProcessor`1<bool> AutoConfigure;
    public static ResultProcessor`1<bool> TrackSubscriptions;
    public static ResultProcessor`1<bool> Tracer;
    public static ResultProcessor`1<bool> EstablishConnection;
    public static ResultProcessor`1<bool> BackgroundSaveStarted;
    public static ResultProcessor`1<bool> BackgroundSaveAOFStarted;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<Byte[]> ByteArray;
    public static ResultProcessor`1<Byte[]> ScriptLoad;
    public static ResultProcessor`1<ClusterConfiguration> ClusterNodes;
    public static ResultProcessor`1<EndPoint> ConnectionIdentity;
    public static ResultProcessor`1<DateTime> DateTime;
    public static ResultProcessor`1<Nullable`1<DateTime>> NullableDateTimeFromMilliseconds;
    public static ResultProcessor`1<Nullable`1<DateTime>> NullableDateTimeFromSeconds;
    public static ResultProcessor`1<double> Double;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<IGrouping`2[]> Info;
    public static MultiStreamProcessor MultiStream;
    public static ResultProcessor`1<long> Int64;
    public static ResultProcessor`1<long> PubSubNumSub;
    public static ResultProcessor`1<long> Int64DefaultNegativeOne;
    public static ResultProcessor`1<Nullable`1<double>> NullableDouble;
    public static ResultProcessor`1<Nullable`1[]> NullableDoubleArray;
    public static ResultProcessor`1<Nullable`1<long>> NullableInt64;
    public static ResultProcessor`1<ExpireResult[]> ExpireResultArray;
    public static ResultProcessor`1<PersistResult[]> PersistResultArray;
    public static ResultProcessor`1<RedisChannel[]> RedisChannelArrayLiteral;
    public static ResultProcessor`1<RedisKey> RedisKey;
    public static ResultProcessor`1<RedisKey[]> RedisKeyArray;
    public static ResultProcessor`1<RedisType> RedisType;
    public static ResultProcessor`1<RedisValue> RedisValue;
    public static ResultProcessor`1<Lease`1<byte>> Lease;
    public static ResultProcessor`1<RedisValue[]> RedisValueArray;
    public static ResultProcessor`1<Int64[]> Int64Array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<String[]> NullableStringArray;
    public static ResultProcessor`1<String[]> StringArray;
    public static ResultProcessor`1<Boolean[]> BooleanArray;
    public static ResultProcessor`1<Nullable`1[]> RedisGeoPositionArray;
    public static ResultProcessor`1<Nullable`1<GeoPosition>> RedisGeoPosition;
    public static ResultProcessor`1<TimeSpan> ResponseTimer;
    public static ResultProcessor`1<Role> Role;
    public static ResultProcessor`1<RedisResult> ScriptResult;
    public static SortedSetEntryProcessor SortedSetEntry;
    public static SortedSetEntryArrayProcessor SortedSetWithScores;
    public static SortedSetPopResultProcessor SortedSetPopResult;
    public static ListPopResultProcessor ListPopResult;
    public static SingleStreamProcessor SingleStream;
    public static SingleStreamProcessor SingleStreamWithNameSkip;
    public static StreamAutoClaimProcessor StreamAutoClaim;
    public static StreamAutoClaimIdsOnlyProcessor StreamAutoClaimIdsOnly;
    public static StreamConsumerInfoProcessor StreamConsumerInfo;
    public static StreamGroupInfoProcessor StreamGroupInfo;
    public static StreamInfoProcessor StreamInfo;
    public static StreamPendingInfoProcessor StreamPendingInfo;
    public static StreamPendingMessagesProcessor StreamPendingMessages;
    public static ResultProcessor`1<LCSMatchResult> LCSMatchResult;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<string> String;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<string> TieBreaker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<string> ClusterNodesRaw;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<EndPoint> SentinelPrimaryEndpoint;
    public static ResultProcessor`1<EndPoint[]> SentinelAddressesEndPoints;
    public static ResultProcessor`1<EndPoint[]> SentinelReplicaEndPoints;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<KeyValuePair`2[][]> SentinelArrayOfArrays;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResultProcessor`1<KeyValuePair`2[]> StringPairInterleaved;
    public static TimeSpanProcessor TimeSpanFromMilliseconds;
    public static TimeSpanProcessor TimeSpanFromSeconds;
    public static HashEntryArrayProcessor HashEntryArray;
    private static ResultProcessor();
    public static ResultProcessor`1<GeoRadiusResult[]> GeoRadiusArray(GeoRadiusOptions options);
    [NullableContextAttribute("2")]
public void ConnectionFail(Message message, ConnectionFailureType fail, Exception innerException, string annotation, ConnectionMultiplexer muxer);
    public static void ConnectionFail(Message message, ConnectionFailureType fail, string errorMessage);
    public static void ServerFail(Message message, string errorMessage);
    public static void SetException(Message message, Exception ex);
    public virtual bool SetResult(PhysicalConnection connection, Message message, RawResult& modreq(System.Runtime.InteropServices.InAttribute) result);
    protected abstract virtual bool SetResultCore(PhysicalConnection connection, Message message, RawResult& modreq(System.Runtime.InteropServices.InAttribute) result);
    private void UnexpectedResponse(Message message, RawResult& result);
}
internal abstract class StackExchange.Redis.ResultProcessor`1 : ResultProcessor {
    [NullableContextAttribute("1")]
protected static void SetResult(Message message, T value);
}
public enum StackExchange.Redis.ResultType : Enum {
    public byte value__;
    public static ResultType None;
    public static ResultType SimpleString;
    public static ResultType Error;
    public static ResultType Integer;
    public static ResultType BulkString;
    public static ResultType Array;
    [ObsoleteAttribute("Please use Array")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ResultType MultiBulk;
    public static ResultType Null;
    public static ResultType Boolean;
    public static ResultType Double;
    public static ResultType BigInteger;
    public static ResultType BlobError;
    public static ResultType VerbatimString;
    public static ResultType Map;
    public static ResultType Set;
    public static ResultType Attribute;
    public static ResultType Push;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ResultTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsError(ResultType value);
    [ExtensionAttribute]
public static ResultType ToResp2(ResultType value);
}
public enum StackExchange.Redis.RetransmissionReasonType : Enum {
    public int value__;
    public static RetransmissionReasonType None;
    public static RetransmissionReasonType Ask;
    public static RetransmissionReasonType Moved;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class StackExchange.Redis.Role : object {
    [CompilerGeneratedAttribute]
private static Unknown <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal static Unknown Null { get; }
    public string Value { get; }
    private Role(string role);
    private static Role();
    [CompilerGeneratedAttribute]
internal static Unknown get_Null();
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual string ToString();
}
public enum StackExchange.Redis.SaveType : Enum {
    public int value__;
    public static SaveType BackgroundRewriteAppendOnlyFile;
    public static SaveType BackgroundSave;
    [ObsoleteAttribute("Saving on the foreground can cause significant blocking; use with extreme caution")]
public static SaveType ForegroundSave;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.ScriptParameterMapper : object {
    private static Regex ParameterExtractor;
    private static Dictionary`2<Type, MethodInfo> _conversionOperators;
    private static HashSet`1<Type> ConvertableTypes;
    private static ScriptParameterMapper();
    private static String[] ExtractParameters(string script);
    private static string MakeOrdinalScriptWithoutKeys(string rawScript, String[] args);
    public static LuaScript PrepareScript(string script);
    public static bool IsValidParameterHash(Type t, LuaScript script, String& missingMember, String& badTypeMember);
    public static Func`3<object, Nullable`1<RedisKey>, ScriptParameters> GetParameterExtractor(Type t, LuaScript script);
    [CompilerGeneratedAttribute]
internal static Expression <GetParameterExtractor>g__GetMember|9_0(Expression root, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.ServerCounters : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Interactive>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionCounters <Subscription>k__BackingField;
    [NullableAttribute("2")]
public EndPoint EndPoint { get; }
    public ConnectionCounters Interactive { get; }
    public ConnectionCounters Other { get; }
    public ConnectionCounters Subscription { get; }
    public long TotalOutstanding { get; }
    [NullableContextAttribute("2")]
public ServerCounters(EndPoint endpoint);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Interactive();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Other();
    [CompilerGeneratedAttribute]
public ConnectionCounters get_Subscription();
    public long get_TotalOutstanding();
    public virtual string ToString();
    internal void Add(ServerCounters other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.ServerEndPoint : object {
    [NullableAttribute("2")]
internal ServerEndPoint modreq(System.Runtime.CompilerServices.IsVolatile) Primary;
    internal ServerEndPoint[] modreq(System.Runtime.CompilerServices.IsVolatile) Replicas;
    private static Regex nameSanitizer;
    private Hashtable knownScripts;
    private int databases;
    private int writeEverySeconds;
    [NullableAttribute("2")]
private PhysicalBridge interactive;
    [NullableAttribute("2")]
private PhysicalBridge subscription;
    private bool isDisposed;
    private bool replicaReadOnly;
    private bool isReplica;
    private bool allowReplicaWrites;
    private Nullable`1<bool> supportsDatabases;
    private Nullable`1<bool> supportsPrimaryWrites;
    private ServerType serverType;
    private UnselectableFlags modreq(System.Runtime.CompilerServices.IsVolatile) unselectableReasons;
    private Version version;
    [CompilerGeneratedAttribute]
private EndPoint <EndPoint>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ClusterConfiguration <ClusterConfiguration>k__BackingField;
    private List`1<TaskCompletionSource`1<string>> _pendingConnectionMonitors;
    [CompilerGeneratedAttribute]
private ConnectionMultiplexer <Multiplexer>k__BackingField;
    private int _nextReplicaOffset;
    [NullableAttribute("2")]
private string runId;
    [NullableAttribute("2")]
private EndPoint primaryEndPoint;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TieBreakerResult>k__BackingField;
    private int lastInfoReplicationCheckTicks;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) ConfigCheckSeconds;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Random r;
    private int _heartBeatActive;
    public EndPoint EndPoint { get; }
    [NullableAttribute("2")]
public ClusterConfiguration ClusterConfiguration { get; private set; }
    public bool SupportsDatabases { get; }
    public int Databases { get; public set; }
    public bool IsConnecting { get; }
    public bool IsConnected { get; }
    public bool IsSubscriberConnected { get; }
    public bool SupportsSubscriptions { get; }
    public bool SupportsPrimaryWrites { get; }
    [NullableAttribute("2")]
internal Exception LastException { get; }
    internal State InteractiveConnectionState { get; }
    internal State SubscriptionConnectionState { get; }
    public long OperationCount { get; }
    public bool RequiresReadMode { get; }
    public ServerType ServerType { get; public set; }
    public bool IsReplica { get; public set; }
    public bool ReplicaReadOnly { get; public set; }
    public bool AllowReplicaWrites { get; public set; }
    public Version Version { get; public set; }
    public Nullable`1<RedisProtocol> Protocol { get; }
    public int WriteEverySeconds { get; public set; }
    internal ConnectionMultiplexer Multiplexer { get; }
    [NullableAttribute("2")]
internal string RunId { get; internal set; }
    internal int LastInfoReplicationCheckSecondsAgo { get; }
    [NullableAttribute("2")]
public EndPoint PrimaryEndPoint { get; public set; }
    [NullableAttribute("2")]
internal string TieBreakerResult { get; internal set; }
    public ServerEndPoint(ConnectionMultiplexer multiplexer, EndPoint endpoint);
    private static ServerEndPoint();
    internal void ResetNonConnected();
    [CompilerGeneratedAttribute]
public EndPoint get_EndPoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ClusterConfiguration get_ClusterConfiguration();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ClusterConfiguration(ClusterConfiguration value);
    public bool get_SupportsDatabases();
    public int get_Databases();
    public void set_Databases(int value);
    public bool get_IsConnecting();
    public bool get_IsConnected();
    public bool get_IsSubscriberConnected();
    public bool KnowOrAssumeResp3();
    public bool get_SupportsSubscriptions();
    public bool get_SupportsPrimaryWrites();
    public Task`1<string> OnConnectedAsync(ILogger log, bool sendTracerIfConnected, bool autoConfigureIfConnected);
    [NullableContextAttribute("2")]
internal Exception get_LastException();
    internal State get_InteractiveConnectionState();
    internal State get_SubscriptionConnectionState();
    public long get_OperationCount();
    public bool get_RequiresReadMode();
    public ServerType get_ServerType();
    public void set_ServerType(ServerType value);
    public bool get_IsReplica();
    public void set_IsReplica(bool value);
    public bool get_ReplicaReadOnly();
    public void set_ReplicaReadOnly(bool value);
    public bool get_AllowReplicaWrites();
    public void set_AllowReplicaWrites(bool value);
    public Version get_Version();
    public void set_Version(Version value);
    public Nullable`1<RedisProtocol> get_Protocol();
    public int get_WriteEverySeconds();
    public void set_WriteEverySeconds(int value);
    [CompilerGeneratedAttribute]
internal ConnectionMultiplexer get_Multiplexer();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
public PhysicalBridge GetBridge(ConnectionType type, bool create, ILogger log);
    public PhysicalBridge GetBridge(Message message);
    [NullableContextAttribute("2")]
public PhysicalBridge GetBridge(RedisCommand command, bool create);
    public RedisFeatures GetFeatures();
    public void SetClusterConfiguration(ClusterConfiguration configuration);
    public void UpdateNodeRelations(ClusterConfiguration configuration);
    public void SetUnselectable(UnselectableFlags flags);
    public void ClearUnselectable(UnselectableFlags flags);
    public virtual string ToString();
    [ObsoleteAttribute("prefer async")]
public WriteResult TryWriteSync(Message message);
    [NullableContextAttribute("0")]
public ValueTask`1<WriteResult> TryWriteAsync(Message message);
    [NullableContextAttribute("2")]
internal void Activate(ConnectionType type, ILogger log);
    internal void AddScript(string script, Byte[] hash);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("StackExchange.Redis.ServerEndPoint/<AutoConfigureAsync>d__91")]
internal Task AutoConfigureAsync(PhysicalConnection connection, ILogger log);
    internal UInt32 NextReplicaOffset();
    internal Task Close(ConnectionType connectionType);
    internal void FlushScriptCache();
    [NullableContextAttribute("2")]
internal string get_RunId();
    [NullableContextAttribute("2")]
internal void set_RunId(string value);
    internal ServerCounters GetCounters();
    internal BridgeStatus GetBridgeStatus(ConnectionType connectionType);
    internal string GetProfile();
    internal Byte[] GetScriptHash(string script, RedisCommand command);
    internal string GetStormLog(Message message);
    internal Message GetTracerMessage(bool checkResponse);
    internal UnselectableFlags GetUnselectableFlags();
    internal bool IsSelectable(RedisCommand command, bool allowDisconnected);
    private void CompletePendingConnectionMonitors(string source);
    internal void OnDisconnected(PhysicalBridge bridge);
    internal Task OnEstablishingAsync(PhysicalConnection connection, ILogger log);
    internal void OnFullyEstablished(PhysicalConnection connection, string source);
    internal int get_LastInfoReplicationCheckSecondsAgo();
    [NullableContextAttribute("2")]
public EndPoint get_PrimaryEndPoint();
    [NullableContextAttribute("2")]
public void set_PrimaryEndPoint(EndPoint value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_TieBreakerResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_TieBreakerResult(string value);
    internal bool CheckInfoReplication();
    internal void ForceExponentialBackoffReplicationCheck();
    private void ResetExponentiallyReplicationCheck();
    internal void OnHeartbeat();
    internal Task`1<T> WriteDirectAsync(Message message, ResultProcessor`1<T> processor, PhysicalBridge bridge);
    internal void ReportNextFailure();
    internal Task`1<bool> SendTracerAsync(ILogger log);
    internal string Summary();
    internal ValueTask WriteDirectOrQueueFireAndForgetAsync(PhysicalConnection connection, Message message, ResultProcessor`1<T> processor);
    [NullableContextAttribute("2")]
private PhysicalBridge CreateBridge(ConnectionType type, ILogger log);
    [AsyncStateMachineAttribute("StackExchange.Redis.ServerEndPoint/<HandshakeAsync>d__136")]
private Task HandshakeAsync(PhysicalConnection connection, ILogger log);
    private void SetConfig(T& field, T value, string caller);
    internal static string ClientInfoSanitize(string value);
    private void ClearMemoized();
    internal void SimulateConnectionFailure(SimulatedFailureType failureType);
    internal bool HasPendingCallerFacingItems();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <UpdateNodeRelations>b__83_0(ClusterNode x);
    [AsyncStateMachineAttribute("StackExchange.Redis.ServerEndPoint/<<OnEstablishingAsync>g__OnEstablishingAsyncAwaited|110_0>d")]
[CompilerGeneratedAttribute]
internal static Task <OnEstablishingAsync>g__OnEstablishingAsyncAwaited|110_0(PhysicalConnection connection, Task handshake);
    [AsyncStateMachineAttribute("StackExchange.Redis.ServerEndPoint/<<WriteDirectAsync>g__Awaited|130_0>d`1")]
[CompilerGeneratedAttribute]
internal static Task`1<T> <WriteDirectAsync>g__Awaited|130_0(ServerEndPoint this, Message message, ValueTask`1<WriteResult> write, TaskCompletionSource`1<T> tcs);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("StackExchange.Redis.ServerEndPoint/<<WriteDirectOrQueueFireAndForgetAsync>g__Awaited|134_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask <WriteDirectOrQueueFireAndForgetAsync>g__Awaited|134_0(ValueTask`1<WriteResult> l_result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.ServerSelectionStrategy : object {
    public static int NoSlot;
    public static int MultipleSlots;
    private static int RedisClusterSlotCount;
    private static UInt16[] Crc16tab;
    private ConnectionMultiplexer multiplexer;
    private int anyStartOffset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ServerEndPoint[] map;
    [CompilerGeneratedAttribute]
private ServerType <ServerType>k__BackingField;
    public ServerType ServerType { get; public set; }
    internal static int TotalSlots { get; }
    public ServerSelectionStrategy(ConnectionMultiplexer multiplexer);
    private static ServerSelectionStrategy();
    [CompilerGeneratedAttribute]
public ServerType get_ServerType();
    [CompilerGeneratedAttribute]
public void set_ServerType(ServerType value);
    internal static int get_TotalSlots();
    public int HashSlot(RedisKey& key);
    public int HashSlot(RedisChannel& channel);
    [NullableContextAttribute("0")]
private static int GetClusterSlot(ReadOnlySpan`1<byte> blob);
    public ServerEndPoint Select(Message message, bool allowDisconnected);
    [NullableContextAttribute("2")]
public ServerEndPoint Select(RedisCommand command, RedisKey& key, CommandFlags flags, bool allowDisconnected);
    [NullableContextAttribute("2")]
public ServerEndPoint Select(RedisCommand command, RedisChannel& channel, CommandFlags flags, bool allowDisconnected);
    public bool TryResend(int hashSlot, Message message, EndPoint endpoint, bool isMoved);
    internal static int CombineSlot(int oldSlot, int newSlot);
    internal int CombineSlot(int oldSlot, RedisKey& key);
    internal int CountCoveredSlots();
    internal void UpdateClusterRange(int fromInclusive, int toInclusive, ServerEndPoint server);
    [NullableContextAttribute("0")]
private static int IndexOf(Byte* ptr, byte value, int start, int end);
    [NullableContextAttribute("2")]
private ServerEndPoint Any(RedisCommand command, CommandFlags flags, bool allowDisconnected);
    private static ServerEndPoint FindPrimary(ServerEndPoint endpoint, RedisCommand command);
    private static ServerEndPoint FindReplica(ServerEndPoint endpoint, RedisCommand command, bool allowDisconnected);
    private ServerEndPoint[] MapForMutation();
    [NullableContextAttribute("2")]
private ServerEndPoint Select(int slot, RedisCommand command, CommandFlags flags, bool allowDisconnected);
}
public enum StackExchange.Redis.ServerType : Enum {
    public int value__;
    public static ServerType Standalone;
    public static ServerType Sentinel;
    public static ServerType Cluster;
    public static ServerType Twemproxy;
    public static ServerType Envoyproxy;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.ServerTypeExtensions : object {
    [ExtensionAttribute]
internal static bool HasSinglePrimary(ServerType type);
    [ExtensionAttribute]
internal static bool SupportsAutoConfigure(ServerType type);
}
public enum StackExchange.Redis.SetOperation : Enum {
    public int value__;
    public static SetOperation Union;
    public static SetOperation Intersect;
    public static SetOperation Difference;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.SetOperationExtensions : object {
    [ExtensionAttribute]
internal static RedisCommand ToCommand(SetOperation operation, bool store);
}
public enum StackExchange.Redis.ShutdownMode : Enum {
    public int value__;
    public static ShutdownMode Default;
    public static ShutdownMode Never;
    public static ShutdownMode Always;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class StackExchange.Redis.SimpleResultBox : object {
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _exception;
    [NullableAttribute("1")]
internal static Exception CancelledException;
    private bool StackExchange.Redis.IResultBox.IsAsync { get; }
    private bool StackExchange.Redis.IResultBox.IsFaulted { get; }
    protected Exception Exception { get; protected set; }
    private static SimpleResultBox();
    private sealed virtual override bool StackExchange.Redis.IResultBox.get_IsAsync();
    private sealed virtual override bool StackExchange.Redis.IResultBox.get_IsFaulted();
    [NullableContextAttribute("1")]
private sealed virtual override void StackExchange.Redis.IResultBox.SetException(Exception exception);
    private sealed virtual override void StackExchange.Redis.IResultBox.Cancel();
    private sealed virtual override void StackExchange.Redis.IResultBox.ActivateContinuations();
    protected Exception get_Exception();
    protected void set_Exception(Exception value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.SimpleResultBox`1 : SimpleResultBox {
    [NullableAttribute("2")]
private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static SimpleResultBox`1<T> _perThreadInstance;
    public static IResultBox`1<T> Create();
    public static IResultBox`1<T> Get();
    private sealed virtual override void StackExchange.Redis.IResultBox<T>.SetResult(T value);
    [NullableContextAttribute("2")]
private sealed virtual override T StackExchange.Redis.IResultBox<T>.GetResult(Exception& ex, bool canRecycle);
}
[FlagsAttribute]
internal enum StackExchange.Redis.SimulatedFailureType : Enum {
    public int value__;
    public static SimulatedFailureType None;
    public static SimulatedFailureType InteractiveInbound;
    public static SimulatedFailureType InteractiveOutbound;
    public static SimulatedFailureType SubscriptionInbound;
    public static SimulatedFailureType SubscriptionOutbound;
    public static SimulatedFailureType AllInbound;
    public static SimulatedFailureType AllOutbound;
    public static SimulatedFailureType AllInteractive;
    public static SimulatedFailureType AllSubscription;
    public static SimulatedFailureType All;
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.SlotRange : ValueType {
    private short from;
    private short to;
    public int From { get; }
    public int To { get; }
    public SlotRange(int from, int to);
    private SlotRange(short from, short to);
    public int get_From();
    public int get_To();
    public static bool op_Inequality(SlotRange x, SlotRange y);
    public static bool op_Equality(SlotRange x, SlotRange y);
    [NullableContextAttribute("1")]
public static bool TryParse(string range, SlotRange& value);
    public sealed virtual int CompareTo(SlotRange other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SlotRange other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal bool Includes(int hashSlot);
    [NullableContextAttribute("1")]
private static bool TryParseInt16(string s, int offset, int count, Int16& value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable.CompareTo(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class StackExchange.Redis.SocketManager : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
private static SocketManager s_shared;
    [NullableAttribute("2")]
private static SocketManager s_threadPool;
    private static int DEFAULT_WORKERS;
    private static int MINIMUM_SEGMENT_SIZE;
    internal PipeOptions SendPipeOptions;
    internal PipeOptions ReceivePipeOptions;
    [CompilerGeneratedAttribute]
private PipeScheduler <Scheduler>k__BackingField;
    public string Name { get; }
    public static SocketManager Shared { get; }
    public static SocketManager ThreadPool { get; }
    internal PipeScheduler Scheduler { get; private set; }
    [NullableAttribute("2")]
internal DedicatedThreadPoolPipeScheduler SchedulerPool { get; }
    public SocketManager(string name);
    public SocketManager(string name, bool useHighPrioritySocketThreads);
    public SocketManager(string name, int workerCount, bool useHighPrioritySocketThreads);
    [NullableContextAttribute("2")]
public SocketManager(string name, int workerCount, SocketManagerOptions options);
    [CompilerGeneratedAttribute]
public string get_Name();
    private static SocketManagerOptions UseHighPrioritySocketThreads(bool value);
    public static SocketManager get_Shared();
    public static SocketManager get_ThreadPool();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal PipeScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
private void set_Scheduler(PipeScheduler value);
    [NullableContextAttribute("2")]
internal DedicatedThreadPoolPipeScheduler get_SchedulerPool();
    public sealed virtual void Dispose();
    private void DisposeRefs();
    protected virtual override void Finalize();
    internal static Socket CreateSocket(EndPoint endpoint);
    [NullableContextAttribute("2")]
internal string GetState();
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.SortedSetEntry : ValueType {
    internal RedisValue element;
    internal double score;
    public RedisValue Element { get; }
    public double Score { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Score", "False")]
public double Value { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use Element", "False")]
public RedisValue Key { get; }
    public SortedSetEntry(RedisValue element, double score);
    public RedisValue get_Element();
    public double get_Score();
    public double get_Value();
    public RedisValue get_Key();
    public static KeyValuePair`2<RedisValue, double> op_Implicit(SortedSetEntry value);
    public static SortedSetEntry op_Implicit(KeyValuePair`2<RedisValue, double> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortedSetEntry other);
    public sealed virtual int CompareTo(SortedSetEntry other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(SortedSetEntry x, SortedSetEntry y);
    public static bool op_Inequality(SortedSetEntry x, SortedSetEntry y);
}
public enum StackExchange.Redis.SortedSetOrder : Enum {
    public int value__;
    public static SortedSetOrder ByRank;
    public static SortedSetOrder ByScore;
    public static SortedSetOrder ByLex;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.SortedSetOrderByExtensions : object {
    [ExtensionAttribute]
internal static RedisValue GetLiteral(SortedSetOrder sortedSetOrder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.SortedSetPopResult : ValueType {
    [CompilerGeneratedAttribute]
private static SortedSetPopResult <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedSetEntry[] <Entries>k__BackingField;
    public static SortedSetPopResult Null { get; }
    public bool IsNull { get; }
    public RedisKey Key { get; }
    public SortedSetEntry[] Entries { get; }
    internal SortedSetPopResult(RedisKey key, SortedSetEntry[] entries);
    private static SortedSetPopResult();
    [CompilerGeneratedAttribute]
public static SortedSetPopResult get_Null();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
public RedisKey get_Key();
    [CompilerGeneratedAttribute]
public SortedSetEntry[] get_Entries();
}
[FlagsAttribute]
public enum StackExchange.Redis.SortedSetWhen : Enum {
    public int value__;
    public static SortedSetWhen Always;
    public static SortedSetWhen Exists;
    public static SortedSetWhen GreaterThan;
    public static SortedSetWhen LessThan;
    public static SortedSetWhen NotExists;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.SortedSetWhenExtensions : object {
    [ExtensionAttribute]
internal static UInt32 CountBits(SortedSetWhen when);
    internal static SortedSetWhen Parse(When when);
}
public enum StackExchange.Redis.SortType : Enum {
    public int value__;
    public static SortType Numeric;
    public static SortType Alphabetic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamAutoClaimIdsOnlyResult : ValueType {
    [CompilerGeneratedAttribute]
private static StreamAutoClaimIdsOnlyResult <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <NextStartId>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue[] <ClaimedIds>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue[] <DeletedIds>k__BackingField;
    public static StreamAutoClaimIdsOnlyResult Null { get; }
    public bool IsNull { get; }
    public RedisValue NextStartId { get; }
    public RedisValue[] ClaimedIds { get; }
    public RedisValue[] DeletedIds { get; }
    internal StreamAutoClaimIdsOnlyResult(RedisValue nextStartId, RedisValue[] claimedIds, RedisValue[] deletedIds);
    private static StreamAutoClaimIdsOnlyResult();
    [CompilerGeneratedAttribute]
public static StreamAutoClaimIdsOnlyResult get_Null();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
public RedisValue get_NextStartId();
    [CompilerGeneratedAttribute]
public RedisValue[] get_ClaimedIds();
    [CompilerGeneratedAttribute]
public RedisValue[] get_DeletedIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamAutoClaimResult : ValueType {
    [CompilerGeneratedAttribute]
private static StreamAutoClaimResult <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <NextStartId>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamEntry[] <ClaimedEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue[] <DeletedIds>k__BackingField;
    public static StreamAutoClaimResult Null { get; }
    public bool IsNull { get; }
    public RedisValue NextStartId { get; }
    public StreamEntry[] ClaimedEntries { get; }
    public RedisValue[] DeletedIds { get; }
    internal StreamAutoClaimResult(RedisValue nextStartId, StreamEntry[] claimedEntries, RedisValue[] deletedIds);
    private static StreamAutoClaimResult();
    [CompilerGeneratedAttribute]
public static StreamAutoClaimResult get_Null();
    public bool get_IsNull();
    [CompilerGeneratedAttribute]
public RedisValue get_NextStartId();
    [CompilerGeneratedAttribute]
public StreamEntry[] get_ClaimedEntries();
    [CompilerGeneratedAttribute]
public RedisValue[] get_DeletedIds();
}
internal static class StackExchange.Redis.StreamConstants : object {
    internal static RedisValue ApproximateMaxLen;
    internal static RedisValue AutoGeneratedId;
    internal static RedisValue NewMessages;
    internal static RedisValue AllMessages;
    internal static RedisValue ReadMinValue;
    internal static RedisValue ReadMaxValue;
    internal static RedisValue UndeliveredMessages;
    internal static RedisValue Consumers;
    internal static RedisValue Count;
    internal static RedisValue Create;
    internal static RedisValue DeleteConsumer;
    internal static RedisValue Destroy;
    internal static RedisValue Group;
    internal static RedisValue Groups;
    internal static RedisValue JustId;
    internal static RedisValue SetId;
    internal static RedisValue MaxLen;
    internal static RedisValue MkStream;
    internal static RedisValue NoAck;
    internal static RedisValue Stream;
    internal static RedisValue Streams;
    private static StreamConstants();
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamConsumer : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PendingMessageCount>k__BackingField;
    public RedisValue Name { get; }
    public int PendingMessageCount { get; }
    internal StreamConsumer(RedisValue name, int pendingMessageCount);
    [CompilerGeneratedAttribute]
public RedisValue get_Name();
    [CompilerGeneratedAttribute]
public int get_PendingMessageCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamConsumerInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PendingMessageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IdleTimeInMilliseconds>k__BackingField;
    public string Name { get; }
    public int PendingMessageCount { get; }
    public long IdleTimeInMilliseconds { get; }
    internal StreamConsumerInfo(string name, int pendingMessageCount, long idleTimeInMilliseconds);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_PendingMessageCount();
    [CompilerGeneratedAttribute]
public long get_IdleTimeInMilliseconds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class StackExchange.Redis.StreamEntry : ValueType {
    [CompilerGeneratedAttribute]
private static StreamEntry <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueEntry[] <Values>k__BackingField;
    public static StreamEntry Null { get; }
    public RedisValue Id { get; }
    public NameValueEntry[] Values { get; }
    public RedisValue Item { get; }
    public bool IsNull { get; }
    public StreamEntry(RedisValue id, NameValueEntry[] values);
    private static StreamEntry();
    [CompilerGeneratedAttribute]
public static StreamEntry get_Null();
    [CompilerGeneratedAttribute]
public RedisValue get_Id();
    [CompilerGeneratedAttribute]
public NameValueEntry[] get_Values();
    public RedisValue get_Item(RedisValue fieldName);
    public bool get_IsNull();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamGroupInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConsumerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PendingMessageCount>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LastDeliveredId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <EntriesRead>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Lag>k__BackingField;
    public string Name { get; }
    public int ConsumerCount { get; }
    public int PendingMessageCount { get; }
    [NullableAttribute("2")]
public string LastDeliveredId { get; }
    public Nullable`1<long> EntriesRead { get; }
    public Nullable`1<long> Lag { get; }
    internal StreamGroupInfo(string name, int consumerCount, int pendingMessageCount, string lastDeliveredId, Nullable`1<long> entriesRead, Nullable`1<long> lag);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_ConsumerCount();
    [CompilerGeneratedAttribute]
public int get_PendingMessageCount();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LastDeliveredId();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_EntriesRead();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Lag();
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RadixTreeKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RadixTreeNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConsumerGroupCount>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamEntry <FirstEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamEntry <LastEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <LastGeneratedId>k__BackingField;
    public int Length { get; }
    public int RadixTreeKeys { get; }
    public int RadixTreeNodes { get; }
    public int ConsumerGroupCount { get; }
    public StreamEntry FirstEntry { get; }
    public StreamEntry LastEntry { get; }
    public RedisValue LastGeneratedId { get; }
    internal StreamInfo(int length, int radixTreeKeys, int radixTreeNodes, int groups, StreamEntry firstEntry, StreamEntry lastEntry, RedisValue lastGeneratedId);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public int get_RadixTreeKeys();
    [CompilerGeneratedAttribute]
public int get_RadixTreeNodes();
    [CompilerGeneratedAttribute]
public int get_ConsumerGroupCount();
    [CompilerGeneratedAttribute]
public StreamEntry get_FirstEntry();
    [CompilerGeneratedAttribute]
public StreamEntry get_LastEntry();
    [CompilerGeneratedAttribute]
public RedisValue get_LastGeneratedId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamPendingInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <PendingMessageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <LowestPendingMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <HighestPendingMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamConsumer[] <Consumers>k__BackingField;
    public int PendingMessageCount { get; }
    public RedisValue LowestPendingMessageId { get; }
    public RedisValue HighestPendingMessageId { get; }
    public StreamConsumer[] Consumers { get; }
    internal StreamPendingInfo(int pendingMessageCount, RedisValue lowestId, RedisValue highestId, StreamConsumer[] consumers);
    [CompilerGeneratedAttribute]
public int get_PendingMessageCount();
    [CompilerGeneratedAttribute]
public RedisValue get_LowestPendingMessageId();
    [CompilerGeneratedAttribute]
public RedisValue get_HighestPendingMessageId();
    [CompilerGeneratedAttribute]
public StreamConsumer[] get_Consumers();
}
[IsReadOnlyAttribute]
public class StackExchange.Redis.StreamPendingMessageInfo : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <ConsumerName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IdleTimeInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeliveryCount>k__BackingField;
    public RedisValue MessageId { get; }
    public RedisValue ConsumerName { get; }
    public long IdleTimeInMilliseconds { get; }
    public int DeliveryCount { get; }
    internal StreamPendingMessageInfo(RedisValue messageId, RedisValue consumerName, long idleTimeInMs, int deliveryCount);
    [CompilerGeneratedAttribute]
public RedisValue get_MessageId();
    [CompilerGeneratedAttribute]
public RedisValue get_ConsumerName();
    [CompilerGeneratedAttribute]
public long get_IdleTimeInMilliseconds();
    [CompilerGeneratedAttribute]
public int get_DeliveryCount();
}
public class StackExchange.Redis.StreamPosition : ValueType {
    [CompilerGeneratedAttribute]
private RedisKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RedisValue <Position>k__BackingField;
    public static RedisValue Beginning { get; }
    public static RedisValue NewMessages { get; }
    public RedisKey Key { get; }
    public RedisValue Position { get; }
    public StreamPosition(RedisKey key, RedisValue position);
    public static RedisValue get_Beginning();
    public static RedisValue get_NewMessages();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RedisKey get_Key();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RedisValue get_Position();
    internal static RedisValue Resolve(RedisValue value, RedisCommand command);
}
public enum StackExchange.Redis.StringIndexType : Enum {
    public int value__;
    public static StringIndexType Byte;
    public static StringIndexType Bit;
}
[ExtensionAttribute]
internal static class StackExchange.Redis.StringIndexTypeExtensions : object {
    [ExtensionAttribute]
internal static RedisValue ToLiteral(StringIndexType indexType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StackExchange.Redis.StringSplits : object {
    public static Char[] Space;
    public static Char[] Comma;
    private static StringSplits();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class StackExchange.Redis.TaskExtensions : object {
    private static Action`1<Task> observeErrors;
    private static TaskExtensions();
    [ExtensionAttribute]
private static void ObverveErrors(Task task);
    [ExtensionAttribute]
internal static Task ObserveErrors(Task task);
    [ExtensionAttribute]
internal static Task`1<T> ObserveErrors(Task`1<T> task);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable ForAwait(Task task);
    [ExtensionAttribute]
internal static ConfiguredValueTaskAwaitable ForAwait(ValueTask& task);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable`1<T> ForAwait(Task`1<T> task);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ConfiguredValueTaskAwaitable`1<T> ForAwait(ValueTask`1& task);
    [ExtensionAttribute]
internal static void RedisFireAndForget(Task task);
    [AsyncStateMachineAttribute("StackExchange.Redis.TaskExtensions/<TimeoutAfter>d__9")]
[ExtensionAttribute]
internal static Task`1<bool> TimeoutAfter(Task task, int timeoutMs);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class StackExchange.Redis.TaskResultBox`1 : TaskCompletionSource`1<T> {
    [NullableAttribute("2")]
private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _exception;
    private T _value;
    private static WaitCallback s_ActivateContinuations;
    private bool StackExchange.Redis.IResultBox.IsAsync { get; }
    private bool StackExchange.Redis.IResultBox.IsFaulted { get; }
    [NullableContextAttribute("2")]
private TaskResultBox`1(object asyncState, TaskCreationOptions creationOptions);
    private static TaskResultBox`1();
    private sealed virtual override bool StackExchange.Redis.IResultBox.get_IsAsync();
    private sealed virtual override bool StackExchange.Redis.IResultBox.get_IsFaulted();
    private sealed virtual override void StackExchange.Redis.IResultBox.Cancel();
    private sealed virtual override void StackExchange.Redis.IResultBox.SetException(Exception ex);
    private sealed virtual override void StackExchange.Redis.IResultBox<T>.SetResult(T value);
    [NullableContextAttribute("2")]
private sealed virtual override T StackExchange.Redis.IResultBox<T>.GetResult(Exception& ex, bool unused);
    private sealed virtual override void StackExchange.Redis.IResultBox.ActivateContinuations();
    private void ActivateContinuationsImpl();
    public static IResultBox`1<T> Create(TaskCompletionSource`1& source, object asyncState);
}
internal static class StackExchange.Redis.TaskSource : object {
    [NullableContextAttribute("2")]
internal static TaskCompletionSource`1<T> Create(object asyncState, TaskCreationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class StackExchange.Redis.TextWriterLogger : object {
    [NullableAttribute("2")]
private TextWriter _writer;
    [NullableAttribute("2")]
private ILogger _wrapped;
    internal static Action`1<string> NullWriter;
    public TextWriterLogger(TextWriter writer, ILogger wrapped);
    private static TextWriterLogger();
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    [NullableContextAttribute("2")]
public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public void Release();
}
[ExtensionAttribute]
internal static class StackExchange.Redis.TextWriterLoggerExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ILogger With(ILogger logger, TextWriter writer);
}
[FlagsAttribute]
internal enum StackExchange.Redis.UnselectableFlags : Enum {
    public int value__;
    public static UnselectableFlags None;
    public static UnselectableFlags RedundantPrimary;
    public static UnselectableFlags DidNotRespond;
    public static UnselectableFlags ServerType;
}
internal static class StackExchange.Redis.Utils : object {
    [NullableAttribute("2")]
private static string _libVersion;
    [NullableContextAttribute("1")]
internal static string GetLibVersion();
}
internal class StackExchange.Redis.ValueStopwatch : ValueType {
    private static double TimestampToTicks;
    private long _startTimestamp;
    public bool IsActive { get; }
    public int ElapsedMilliseconds { get; }
    private ValueStopwatch(long startTimestamp);
    private static ValueStopwatch();
    public bool get_IsActive();
    public static ValueStopwatch StartNew();
    public int get_ElapsedMilliseconds();
    public TimeSpan GetElapsedTime();
}
public enum StackExchange.Redis.When : Enum {
    public int value__;
    public static When Always;
    public static When Exists;
    public static When NotExists;
}
internal enum StackExchange.Redis.WriteResult : Enum {
    public int value__;
    public static WriteResult Success;
    public static WriteResult NoConnectionAvailable;
    public static WriteResult TimeoutBeforeWrite;
    public static WriteResult WriteFailure;
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.141.978")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class VersionExtensions : object {
    private static long ComposeMajorMinor(Version version);
    private static long ComposeBuildRevision(Version version);
    [ExtensionAttribute]
internal static int GetNormalizedHashCode(Version value);
    [ExtensionAttribute]
internal static bool IsEqual(Version x, Version y);
    [ExtensionAttribute]
internal static bool IsAtLeast(Version x, Version y);
}
