[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ConfigurationServiceInstanceProviderServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddConfigurationDiscoveryClient(IServiceCollection services, IConfiguration configuration, ServiceLifetime serviceLifetime);
}
public class Steeltoe.Common.ApplicationInstanceInfo : AbstractOptions {
    public static string ApplicationRoot;
    public string SpringApplicationRoot;
    public string ServicesRoot;
    public string EurekaRoot;
    public string ConfigServerRoot;
    public string ConsulRoot;
    public string KubernetesRoot;
    public string ManagementRoot;
    protected IConfiguration configuration;
    [CompilerGeneratedAttribute]
private string <Instance_Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application_Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnvironmentName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstanceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Uris>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DiskLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileDescriptorLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceIP>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InternalIP>k__BackingField;
    public string DefaultAppName { get; }
    public string AppNameKey { get; }
    public string AppInstanceIdKey { get; }
    public string ConfigServerNameKey { get; }
    public string ConsulInstanceNameKey { get; }
    public string EurekaInstanceNameKey { get; }
    public string KubernetesNameKey { get; }
    public string ManagementNameKey { get; }
    public string PlatformNameKey { get; }
    protected string PlatformRoot { get; }
    public string Instance_Id { get; public set; }
    public string InstanceId { get; public set; }
    public string Application_Id { get; public set; }
    public string ApplicationId { get; public set; }
    public string Name { get; public set; }
    public string ApplicationName { get; }
    public string ApplicationVersion { get; public set; }
    public string EnvironmentName { get; public set; }
    public int InstanceIndex { get; public set; }
    public int Port { get; public set; }
    public IEnumerable`1<string> Uris { get; public set; }
    public string Version { get; public set; }
    public int DiskLimit { get; public set; }
    public int MemoryLimit { get; public set; }
    public int FileDescriptorLimit { get; public set; }
    public string InstanceIP { get; public set; }
    public string InternalIP { get; public set; }
    public ApplicationInstanceInfo(IConfiguration configuration);
    public ApplicationInstanceInfo(IConfiguration configuration, bool noPrefix);
    public ApplicationInstanceInfo(IConfiguration configuration, string configPrefix);
    private static ApplicationInstanceInfo();
    public string get_DefaultAppName();
    public string get_AppNameKey();
    public string get_AppInstanceIdKey();
    public string get_ConfigServerNameKey();
    public string get_ConsulInstanceNameKey();
    public string get_EurekaInstanceNameKey();
    public string get_KubernetesNameKey();
    public string get_ManagementNameKey();
    public string get_PlatformNameKey();
    protected virtual string get_PlatformRoot();
    protected void SecondChanceSetIdProperties(IConfiguration config);
    private static string BuildConfigString(string prefix, string key);
    [CompilerGeneratedAttribute]
public string get_Instance_Id();
    [CompilerGeneratedAttribute]
public void set_Instance_Id(string value);
    public virtual string get_InstanceId();
    public virtual void set_InstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_Application_Id();
    [CompilerGeneratedAttribute]
public void set_Application_Id(string value);
    public virtual string get_ApplicationId();
    public virtual void set_ApplicationId(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    public virtual string get_ApplicationName();
    public sealed virtual string ApplicationNameInContext(SteeltoeComponent steeltoeComponent, string additionalSearchPath);
    [CompilerGeneratedAttribute]
public virtual string get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public virtual void set_ApplicationVersion(string value);
    [CompilerGeneratedAttribute]
public virtual string get_EnvironmentName();
    [CompilerGeneratedAttribute]
public virtual void set_EnvironmentName(string value);
    [CompilerGeneratedAttribute]
public virtual int get_InstanceIndex();
    [CompilerGeneratedAttribute]
public virtual void set_InstanceIndex(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_Uris();
    [CompilerGeneratedAttribute]
public virtual void set_Uris(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public virtual int get_DiskLimit();
    [CompilerGeneratedAttribute]
public virtual void set_DiskLimit(int value);
    [CompilerGeneratedAttribute]
public virtual int get_MemoryLimit();
    [CompilerGeneratedAttribute]
public virtual void set_MemoryLimit(int value);
    [CompilerGeneratedAttribute]
public virtual int get_FileDescriptorLimit();
    [CompilerGeneratedAttribute]
public virtual void set_FileDescriptorLimit(int value);
    [CompilerGeneratedAttribute]
public virtual string get_InstanceIP();
    [CompilerGeneratedAttribute]
public virtual void set_InstanceIP(string value);
    [CompilerGeneratedAttribute]
public virtual string get_InternalIP();
    [CompilerGeneratedAttribute]
public virtual void set_InternalIP(string value);
}
public class Steeltoe.Common.Availability.ApplicationAvailability : object {
    public string LivenessKey;
    public string ReadinessKey;
    private Dictionary`2<string, IAvailabilityState> _availabilityStates;
    private ILogger`1<ApplicationAvailability> _logger;
    [CompilerGeneratedAttribute]
private EventHandler LivenessChanged;
    [CompilerGeneratedAttribute]
private EventHandler ReadinessChanged;
    public ApplicationAvailability(ILogger`1<ApplicationAvailability> logger);
    public IAvailabilityState GetLivenessState();
    [CompilerGeneratedAttribute]
public void add_LivenessChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LivenessChanged(EventHandler value);
    public IAvailabilityState GetReadinessState();
    [CompilerGeneratedAttribute]
public void add_ReadinessChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReadinessChanged(EventHandler value);
    public IAvailabilityState GetAvailabilityState(string availabilityType);
    public void SetAvailabilityState(string stateKey, IAvailabilityState newState, string caller);
}
public class Steeltoe.Common.Availability.AvailabilityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IAvailabilityState <NewState>k__BackingField;
    public IAvailabilityState NewState { get; }
    public AvailabilityEventArgs(IAvailabilityState availabilityState);
    [CompilerGeneratedAttribute]
public IAvailabilityState get_NewState();
}
public abstract class Steeltoe.Common.Availability.AvailabilityHealthContributor : object {
    private Dictionary`2<IAvailabilityState, HealthStatus> _stateMappings;
    private ILogger _logger;
    public string Id { get; }
    protected AvailabilityHealthContributor(Dictionary`2<IAvailabilityState, HealthStatus> stateMappings, ILogger logger);
    public virtual string get_Id();
    public sealed virtual HealthCheckResult Health();
    protected virtual IAvailabilityState GetState();
}
public class Steeltoe.Common.Availability.LivenessHealthContributor : AvailabilityHealthContributor {
    private ApplicationAvailability _availability;
    public string Id { get; }
    public LivenessHealthContributor(ApplicationAvailability availability);
    public virtual string get_Id();
    protected virtual IAvailabilityState GetState();
}
public class Steeltoe.Common.Availability.LivenessState : object {
    private string _value;
    public static LivenessState Correct;
    public static LivenessState Broken;
    private LivenessState(string value);
    private static LivenessState();
    public virtual string ToString();
}
public class Steeltoe.Common.Availability.ReadinessHealthContributor : AvailabilityHealthContributor {
    private ApplicationAvailability _availability;
    public string Id { get; }
    public ReadinessHealthContributor(ApplicationAvailability availability);
    public virtual string get_Id();
    protected virtual IAvailabilityState GetState();
}
public class Steeltoe.Common.Availability.ReadinessState : object {
    private string _value;
    public static ReadinessState AcceptingTraffic;
    public static ReadinessState RefusingTraffic;
    private ReadinessState(string value);
    private static ReadinessState();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Steeltoe.Common.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAddEx(ConcurrentDictionary`2<K, V> dict, K key, Func`2<K, V> factory);
}
public static class Steeltoe.Common.Configuration.ConfigurationValuesHelper : object {
    public static string GetSetting(string key, IConfiguration primary, IConfiguration secondary, IConfiguration resolve, string def);
    public static string GetSetting(string key, IConfiguration config, string defaultValue, String[] configPrefixes);
    public static string GetPreferredSetting(IConfiguration config, string defaultValue, String[] configKeys);
    public static int GetInt(string key, IConfiguration config, IConfiguration resolve, int def);
    public static double GetDouble(string key, IConfiguration config, IConfiguration resolve, double def);
    public static bool GetBoolean(string key, IConfiguration config, IConfiguration resolve, bool def);
    public static string GetString(string key, IConfiguration config, IConfiguration resolve, string def);
}
[ExtensionAttribute]
public static class Steeltoe.Common.Configuration.PropertyPlaceholderHelper : object {
    private static string PREFIX;
    private static string SUFFIX;
    private static string SIMPLE_PREFIX;
    private static string SEPARATOR;
    public static string ResolvePlaceholders(string property, IConfiguration config, ILogger logger);
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetResolvedConfigurationPlaceholders(IConfiguration config, ILogger logger, bool useEmptyStringIfNotFound);
    private static string ParseStringValue(string property, IConfiguration config, ISet`1<string> visitedPlaceHolders, ILogger logger, bool useEmptyStringIfNotFound);
    private static int FindEndIndex(StringBuilder property, int startIndex);
    private static bool SubstringMatch(StringBuilder str, int index, string substring);
    [ExtensionAttribute]
private static void Replace(StringBuilder builder, int start, int end, string str);
    [ExtensionAttribute]
private static int IndexOf(StringBuilder builder, string str, int start);
    [ExtensionAttribute]
private static string Substring(StringBuilder builder, int start, int end);
}
public abstract class Steeltoe.Common.Contexts.AbstractApplicationContext : object {
    private ConcurrentDictionary`2<string, object> _instances;
    [CompilerGeneratedAttribute]
private IConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceExpressionResolver <ServiceExpressionResolver>k__BackingField;
    public IConfiguration Configuration { get; private set; }
    public IServiceProvider ServiceProvider { get; private set; }
    public IServiceExpressionResolver ServiceExpressionResolver { get; public set; }
    protected AbstractApplicationContext(IServiceProvider serviceProvider, IConfiguration configuration, IEnumerable`1<NameToTypeMapping> nameToTypeMappings);
    [CompilerGeneratedAttribute]
public sealed virtual IConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(IConfiguration value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void set_ServiceProvider(IServiceProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceExpressionResolver get_ServiceExpressionResolver();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServiceExpressionResolver(IServiceExpressionResolver value);
    public sealed virtual bool ContainsService(string name);
    public sealed virtual bool ContainsService(string name, Type serviceType);
    public sealed virtual bool ContainsService(string name);
    public sealed virtual object GetService(string name);
    public sealed virtual object GetService(string name, Type serviceType);
    public sealed virtual T GetService(string name);
    public sealed virtual T GetService();
    public sealed virtual object GetService(Type serviceType);
    public IEnumerable`1<object> GetServices(Type serviceType);
    public sealed virtual IEnumerable`1<T> GetServices();
    public sealed virtual void Register(string name, object instance);
    public sealed virtual object Deregister(string name);
    public sealed virtual string ResolveEmbeddedValue(string value);
    public sealed virtual void Dispose();
    private object ResolveNamedService(string name, Type serviceType);
    private object FindNamedService(string name, Type serviceType);
}
public class Steeltoe.Common.Contexts.GenericApplicationContext : AbstractApplicationContext {
    public GenericApplicationContext(IServiceProvider serviceProvider, IConfiguration configuration, IEnumerable`1<NameToTypeMapping> nameToTypeMappings);
}
[ExtensionAttribute]
public static class Steeltoe.Common.Contexts.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddGenericApplicationContext(IServiceCollection services, Action`2<IServiceProvider, GenericApplicationContext> configure);
    [ExtensionAttribute]
public static IServiceCollection AddGenericApplicationContext(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection RegisterService(IServiceCollection services, string serviceName, Type implementationType);
}
public abstract class Steeltoe.Common.Converter.AbstractConverter`2 : AbstractGenericConditionalConverter {
    public virtual bool Matches(Type sourceType, Type targetType);
    public abstract virtual T Convert(S source);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public abstract class Steeltoe.Common.Converter.AbstractGenericConditionalConverter : AbstractGenericConverter {
    protected AbstractGenericConditionalConverter(ISet`1<ValueTuple`2<Type, Type>> convertableTypes);
    public abstract virtual bool Matches(Type sourceType, Type targetType);
}
public abstract class Steeltoe.Common.Converter.AbstractGenericConverter : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ISet`1<ValueTuple`2<Type, Type>> <ConvertibleTypes>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISet`1<ValueTuple`2<Type, Type>> ConvertibleTypes { get; }
    protected AbstractGenericConverter(ISet`1<ValueTuple`2<Type, Type>> convertableTypes);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<ValueTuple`2<Type, Type>> get_ConvertibleTypes();
    public abstract virtual object Convert(object source, Type sourceType, Type targetType);
}
public abstract class Steeltoe.Common.Converter.AbstractToCollectionConverter : AbstractGenericConditionalConverter {
    protected IConversionService _conversionService;
    protected AbstractToCollectionConverter(IConversionService conversionService);
    protected AbstractToCollectionConverter(ISet`1<ValueTuple`2<Type, Type>> convertableTypes, IConversionService conversionService);
}
public abstract class Steeltoe.Common.Converter.AbstractToNumberConverter : AbstractGenericConditionalConverter {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ISet`1<ValueTuple`2<Type, Type>> _convertableTypes;
    protected AbstractToNumberConverter(ISet`1<ValueTuple`2<Type, Type>> convertableTypes);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.ArrayToArrayConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public ArrayToArrayConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.ArrayToCollectionConverter : AbstractToCollectionConverter {
    public ArrayToCollectionConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.ArrayToObjectConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public ArrayToObjectConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.ArrayToStringConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public ArrayToStringConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.BooleanToStringConverter : ObjectToStringConverter`1<bool> {
}
public class Steeltoe.Common.Converter.CharacterToNumberConverter : AbstractToNumberConverter {
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.CharacterToStringConverter : ObjectToStringConverter`1<char> {
}
public class Steeltoe.Common.Converter.CollectionToArrayConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public CollectionToArrayConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.CollectionToCollectionConverter : AbstractToCollectionConverter {
    public CollectionToCollectionConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.CollectionToObjectConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public CollectionToObjectConverter(IConversionService conversionService, ISet`1<ValueTuple`2<Type, Type>> convertableTypes);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.CollectionToStringConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public CollectionToStringConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.ConversionException : Exception {
    public ConversionException(string message);
    public ConversionException(string message, Exception cause);
}
public class Steeltoe.Common.Converter.ConversionFailedException : ConversionException {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type SourceType { get; }
    public Type TargetType { get; }
    public object Value { get; }
    public ConversionFailedException(Type sourceType, Type targetType, object value, Exception cause);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public static class Steeltoe.Common.Converter.ConversionUtils : object {
    private static string DELIMITER;
    public static bool CanConvertElements(Type sourceElementType, Type targetElementType, IConversionService conversionService);
    public static Type GetElementType(Type sourceType);
    public static string ToString(IEnumerable collection, Type targetType, IConversionService conversionService);
    public static int Count(IEnumerable enumerable);
    public static Type GetNullableElementType(Type nullable);
    public static bool CanCreateCompatListFor(Type type);
    public static bool CanCreateCompatDictionaryFor(Type type);
    public static Type GetDictionaryKeyType(Type sourceType);
    public static Type GetDictionaryValueType(Type sourceType);
    public static bool ContainsPublicNoArgConstructor(Type collectionType);
    public static IList CreateCompatListFor(Type type);
    public static IDictionary CreateCompatDictionaryFor(Type type);
    public static ConstructorInfo GetConstructorIfAvailable(Type clazz, Type[] paramTypes);
    public static MethodInfo GetStaticMethod(Type clazz, string methodName, Type[] args);
    public static MethodInfo GetMethodIfAvailable(Type clazz, string methodName, Type[] paramTypes);
    internal static List`1<MethodInfo> FindMethodCandidatesByName(Type clazz, string methodName);
    internal static Type GetDictionaryKeyOrValueType(Type sourceType, int index);
    internal static Type MakeGenericListType(Type type);
    internal static Type MakeGenericDictionaryType(Type type);
}
public class Steeltoe.Common.Converter.ConverterNotFoundException : ConversionException {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public Type SourceType { get; }
    public Type TargetType { get; }
    public ConverterNotFoundException(Type sourceType, Type targetType);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
public Type get_TargetType();
}
public class Steeltoe.Common.Converter.DefaultConversionService : GenericConversionService {
    private static object _lock;
    private static DefaultConversionService modreq(System.Runtime.CompilerServices.IsVolatile) _sharedInstance;
    public static IConversionService Singleton { get; }
    private static DefaultConversionService();
    public static IConversionService get_Singleton();
    public static void AddDefaultConverters(IConverterRegistry converterRegistry);
    public static void AddCollectionConverters(IConverterRegistry converterRegistry);
    private static void AddScalarConverters(IConverterRegistry converterRegistry);
}
public class Steeltoe.Common.Converter.DictionaryToDictionaryConverter : AbstractToCollectionConverter {
    public DictionaryToDictionaryConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
    private bool CanConvertKey(Type sourceType, Type targetType);
    private bool CanConvertValue(Type sourceType, Type targetType);
    private object ConvertKey(object sourceKey, Type sourceType, Type targetType);
    private object ConvertValue(object sourceValue, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.EncodingToStringConverter : AbstractConverter`2<Encoding, string> {
    public virtual string Convert(Encoding source);
}
public class Steeltoe.Common.Converter.EnumToStringConverter : ObjectToStringConverter`1<Enum> {
}
public class Steeltoe.Common.Converter.FallbackObjectToStringConverter : AbstractConverter`2<object, string> {
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual string Convert(object source);
}
public class Steeltoe.Common.Converter.GenericConversionService : object {
    private static IGenericConverter NO_OP_CONVERTER;
    private static IGenericConverter NO_MATCH;
    private Converters _converters;
    private ConcurrentDictionary`2<ConverterCacheKey, IGenericConverter> _converterCache;
    private static GenericConversionService();
    public sealed virtual bool CanConvert(Type sourceType, Type targetType);
    public sealed virtual T Convert(object source);
    public sealed virtual object Convert(object source, Type sourceType, Type targetType);
    public sealed virtual bool CanBypassConvert(Type sourceType, Type targetType);
    public sealed virtual void AddConverter(IGenericConverter converter);
    protected virtual IGenericConverter GetConverter(Type sourceType, Type targetType);
    protected virtual IGenericConverter GetDefaultConverter(Type sourceType, Type targetType);
    private object HandleResult(Type sourceType, Type targetType, object result);
    private object HandleConverterNotFound(object source, Type sourceType, Type targetType);
    private void AssertNotPrimitiveTargetType(Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.GuidToStringConverter : ObjectToStringConverter`1<Guid> {
}
public class Steeltoe.Common.Converter.ListToDictionaryConverter : CollectionToObjectConverter {
    public ListToDictionaryConverter(IConversionService conversionService);
}
public class Steeltoe.Common.Converter.NumberToCharacterConverter : AbstractGenericConverter {
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.NumberToNumberConverter : AbstractToNumberConverter {
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.NumberToStringConverter : AbstractGenericConverter {
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.ObjectToArrayConverter : AbstractGenericConditionalConverter {
    private IConversionService _conversionService;
    public ObjectToArrayConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.ObjectToCollectionConverter : AbstractToCollectionConverter {
    public ObjectToCollectionConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.ObjectToNumberConverter : AbstractToNumberConverter {
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.ObjectToObjectConverter : AbstractGenericConditionalConverter {
    private static ConcurrentDictionary`2<Type, MemberInfo> _conversionMemberCache;
    private static ObjectToObjectConverter();
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    internal static bool HasConversionMethodOrConstructor(Type targetClass, Type sourceClass);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
    private static MemberInfo GetValidatedMember(Type targetClass, Type sourceClass);
    private static bool IsApplicable(MemberInfo member, Type sourceClass);
    private static MethodInfo DetermineToMethod(Type targetClass, Type sourceClass);
    private static MethodInfo DetermineFactoryMethod(Type targetClass, Type sourceClass);
    private static ConstructorInfo DetermineFactoryConstructor(Type targetClass, Type sourceClass);
}
public class Steeltoe.Common.Converter.ObjectToStringConverter`1 : AbstractConverter`2<T, string> {
    public virtual string Convert(T source);
}
public class Steeltoe.Common.Converter.StringToArrayConverter : AbstractGenericConditionalConverter {
    private Char[] _delimit;
    private IConversionService _conversionService;
    public StringToArrayConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.StringToBooleanConverter : AbstractGenericConditionalConverter {
    private static ISet`1<string> _trueValues;
    private static ISet`1<string> _falseValues;
    private static StringToBooleanConverter();
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.StringToCharacterConverter : AbstractGenericConditionalConverter {
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.StringToCollectionConverter : AbstractToCollectionConverter {
    private Char[] _delimit;
    public StringToCollectionConverter(IConversionService conversionService);
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Converter.StringToEncodingConverter : AbstractConverter`2<string, Encoding> {
    public virtual Encoding Convert(string source);
}
public class Steeltoe.Common.Converter.StringToEnumConverter : AbstractGenericConditionalConverter {
    public virtual bool Matches(Type sourceType, Type targetType);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.StringToGuidConverter : AbstractConverter`2<string, Guid> {
    public virtual Guid Convert(string source);
    public virtual object Convert(object source, Type sourceType, Type targetType);
}
public class Steeltoe.Common.Converter.StringToNumberConverter : AbstractToNumberConverter {
    public virtual object Convert(object source, Type sourceType, Type targetType);
    private static ISet`1<ValueTuple`2<Type, Type>> GetConvertiblePairs();
}
public class Steeltoe.Common.Discovery.ConfigurationServiceInstance : object {
    [CompilerGeneratedAttribute]
private string <ServiceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecure>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string ServiceId { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool IsSecure { get; public set; }
    public Uri Uri { get; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceId();
    [CompilerGeneratedAttribute]
public void set_ServiceId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSecure();
    [CompilerGeneratedAttribute]
public void set_IsSecure(bool value);
    public sealed virtual Uri get_Uri();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
}
public class Steeltoe.Common.Discovery.ConfigurationServiceInstanceProvider : object {
    private IOptionsMonitor`1<List`1<ConfigurationServiceInstance>> _serviceInstances;
    public string Description { get; }
    public IList`1<string> Services { get; }
    public ConfigurationServiceInstanceProvider(IOptionsMonitor`1<List`1<ConfigurationServiceInstance>> serviceInstances);
    public sealed virtual string get_Description();
    public sealed virtual IList`1<string> get_Services();
    public sealed virtual IList`1<IServiceInstance> GetInstances(string serviceId);
    internal IList`1<string> GetServices();
}
[ExtensionAttribute]
public static class Steeltoe.Common.Discovery.IServiceInstanceProviderExtensions : object {
    [AsyncStateMachineAttribute("Steeltoe.Common.Discovery.IServiceInstanceProviderExtensions/<GetInstancesWithCacheAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IList`1<IServiceInstance>> GetInstancesWithCacheAsync(IServiceInstanceProvider serviceInstanceProvider, string serviceId, IDistributedCache distributedCache, DistributedCacheEntryOptions cacheOptions, string serviceInstancesKeyPrefix);
    private static List`1<SerializableIServiceInstance> MapToSerializable(IList`1<IServiceInstance> instances);
    private static Byte[] SerializeForCache(object data);
    private static T DeserializeFromCache(Byte[] data);
}
public class Steeltoe.Common.Discovery.SerializableIServiceInstance : object {
    [CompilerGeneratedAttribute]
private string <ServiceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecure>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string ServiceId { get; public set; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool IsSecure { get; public set; }
    public Uri Uri { get; public set; }
    public IDictionary`2<string, string> Metadata { get; public set; }
    public SerializableIServiceInstance(IServiceInstance instance);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceId();
    [CompilerGeneratedAttribute]
public void set_ServiceId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSecure();
    [CompilerGeneratedAttribute]
public void set_IsSecure(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
}
[ExtensionAttribute]
public static class Steeltoe.Common.Extensions.UriExtensions : object {
    private static Char[] _uriSeparatorChar;
    private static UriExtensions();
    public static Dictionary`2<string, string> ParseQuerystring(string querystring);
    [ExtensionAttribute]
public static string ToMaskedString(Uri source);
    [ExtensionAttribute]
private static Uri ToMaskedUri(Uri source);
}
[ExtensionAttribute]
public static class Steeltoe.Common.IServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static void RegisterDefaultApplicationInstanceInfo(IServiceCollection serviceCollection);
    [ExtensionAttribute]
[ObsoleteAttribute("This method builds a temporary service provider and should not be used")]
public static IApplicationInstanceInfo GetApplicationInstanceInfo(IServiceCollection serviceCollection);
}
[ExtensionAttribute]
public static class Steeltoe.Common.IServiceProviderExtensions : object {
    [ExtensionAttribute]
public static IApplicationInstanceInfo GetApplicationInstanceInfo(IServiceProvider sp);
}
public class Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor : object {
    private ILogger _logger;
    private IApplicationContext _context;
    private List`1<ILifecycle> _lifecyclesServices;
    [CompilerGeneratedAttribute]
private int <TimeoutPerShutdownPhase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    public int TimeoutPerShutdownPhase { get; public set; }
    public bool IsRunning { get; public set; }
    public DefaultLifecycleProcessor(IApplicationContext context, ILogger logger);
    [CompilerGeneratedAttribute]
public int get_TimeoutPerShutdownPhase();
    [CompilerGeneratedAttribute]
public void set_TimeoutPerShutdownPhase(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRunning();
    [CompilerGeneratedAttribute]
public void set_IsRunning(bool value);
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<Start>d__12")]
public sealed virtual Task Start();
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<Stop>d__13")]
public sealed virtual Task Stop();
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<OnRefresh>d__14")]
public sealed virtual Task OnRefresh();
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<OnClose>d__15")]
public sealed virtual Task OnClose();
    public sealed virtual void Dispose();
    internal static int GetPhase(ILifecycle bean);
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<StartServices>d__18")]
private Task StartServices(bool autoStartupOnly);
    [AsyncStateMachineAttribute("Steeltoe.Common.Lifecycle.DefaultLifecycleProcessor/<StopServices>d__19")]
private Task StopServices();
    private void BuildServicesList();
}
public class Steeltoe.Common.Lifecycle.LifecycleException : Exception {
    public LifecycleException(string message);
    public LifecycleException(string message, Exception innerException);
}
public class Steeltoe.Common.LoadBalancer.RandomLoadBalancer : object {
    private static Random _random;
    private IServiceInstanceProvider _serviceInstanceProvider;
    private IDistributedCache _distributedCache;
    private DistributedCacheEntryOptions _cacheOptions;
    private ILogger _logger;
    public RandomLoadBalancer(IServiceInstanceProvider serviceInstanceProvider, IDistributedCache distributedCache, DistributedCacheEntryOptions cacheEntryOptions, ILogger logger);
    private static RandomLoadBalancer();
    [AsyncStateMachineAttribute("Steeltoe.Common.LoadBalancer.RandomLoadBalancer/<ResolveServiceInstanceAsync>d__6")]
public virtual Task`1<Uri> ResolveServiceInstanceAsync(Uri request);
    public virtual Task UpdateStatsAsync(Uri originalUri, Uri resolvedUri, TimeSpan responseTime, Exception exception);
}
public class Steeltoe.Common.LoadBalancer.RoundRobinLoadBalancer : object {
    public string IndexKeyPrefix;
    internal IServiceInstanceProvider ServiceInstanceProvider;
    internal IDistributedCache _distributedCache;
    internal ConcurrentDictionary`2<string, int> NextIndexForService;
    private DistributedCacheEntryOptions _cacheOptions;
    private ILogger _logger;
    public RoundRobinLoadBalancer(IServiceInstanceProvider serviceInstanceProvider, IDistributedCache distributedCache, DistributedCacheEntryOptions cacheEntryOptions, ILogger logger);
    [AsyncStateMachineAttribute("Steeltoe.Common.LoadBalancer.RoundRobinLoadBalancer/<ResolveServiceInstanceAsync>d__7")]
public virtual Task`1<Uri> ResolveServiceInstanceAsync(Uri request);
    public virtual Task UpdateStatsAsync(Uri originalUri, Uri resolvedUri, TimeSpan responseTime, Exception exception);
    [AsyncStateMachineAttribute("Steeltoe.Common.LoadBalancer.RoundRobinLoadBalancer/<GetOrInitNextIndex>d__9")]
private Task`1<int> GetOrInitNextIndex(string cacheKey, int initValue);
    [AsyncStateMachineAttribute("Steeltoe.Common.LoadBalancer.RoundRobinLoadBalancer/<SetNextIndex>d__10")]
private Task SetNextIndex(string cacheKey, int currentValue);
}
internal static class Steeltoe.Common.Logging.BootstrapLoggerFactory : object {
    [CompilerGeneratedAttribute]
private static IBoostrapLoggerFactory <Instance>k__BackingField;
    public static IBoostrapLoggerFactory Instance { get; }
    private static BootstrapLoggerFactory();
    [CompilerGeneratedAttribute]
public static IBoostrapLoggerFactory get_Instance();
}
public interface Steeltoe.Common.Logging.IBoostrapLoggerFactory {
    public abstract virtual void Update(IConfiguration value);
    public abstract virtual void Update(ILoggerFactory value);
}
internal class Steeltoe.Common.Logging.UpgradableBootstrapLoggerFactory : object {
    private Dictionary`2<string, BoostrapLoggerInst> _loggers;
    private ILoggerFactory _factoryInstance;
    private object _lock;
    private ILoggerFactory _innerFactory;
    private Action`2<ILoggingBuilder, IConfiguration> _bootstrapLoggingBuilder;
    public UpgradableBootstrapLoggerFactory(Action`2<ILoggingBuilder, IConfiguration> bootstrapLoggingBuilder);
    public sealed virtual void Update(IConfiguration value);
    public sealed virtual void Update(ILoggerFactory value);
    public sealed virtual void Dispose();
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    private static void DefaultConfigure(ILoggingBuilder builder, IConfiguration configuration);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(ILoggingBuilder builder);
}
public static class Steeltoe.Common.Net.DnsTools : object {
    public static string ResolveHostAddress(string hostName);
    public static string ResolveHostName();
}
public class Steeltoe.Common.Net.HostInfo : object {
    [CompilerGeneratedAttribute]
private string <Hostname>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Override>k__BackingField;
    public string Hostname { get; public set; }
    public string IpAddress { get; public set; }
    public bool Override { get; public set; }
    public HostInfo(string hostname);
    [CompilerGeneratedAttribute]
public string get_Hostname();
    [CompilerGeneratedAttribute]
public void set_Hostname(string value);
    [CompilerGeneratedAttribute]
public string get_IpAddress();
    [CompilerGeneratedAttribute]
public void set_IpAddress(string value);
    [CompilerGeneratedAttribute]
public bool get_Override();
    [CompilerGeneratedAttribute]
public void set_Override(bool value);
}
public class Steeltoe.Common.Net.InetOptions : object {
    public static string PREFIX;
    [CompilerGeneratedAttribute]
private string <DefaultHostname>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IgnoredInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOnlySiteLocalInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredNetworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipReverseDnsLookup>k__BackingField;
    public string DefaultHostname { get; public set; }
    public string DefaultIpAddress { get; public set; }
    public string IgnoredInterfaces { get; public set; }
    public bool UseOnlySiteLocalInterfaces { get; public set; }
    public string PreferredNetworks { get; public set; }
    public bool SkipReverseDnsLookup { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultHostname();
    [CompilerGeneratedAttribute]
public void set_DefaultHostname(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultIpAddress();
    [CompilerGeneratedAttribute]
public void set_DefaultIpAddress(string value);
    [CompilerGeneratedAttribute]
public string get_IgnoredInterfaces();
    [CompilerGeneratedAttribute]
public void set_IgnoredInterfaces(string value);
    [CompilerGeneratedAttribute]
public bool get_UseOnlySiteLocalInterfaces();
    [CompilerGeneratedAttribute]
public void set_UseOnlySiteLocalInterfaces(bool value);
    [CompilerGeneratedAttribute]
public string get_PreferredNetworks();
    [CompilerGeneratedAttribute]
public void set_PreferredNetworks(string value);
    [CompilerGeneratedAttribute]
public bool get_SkipReverseDnsLookup();
    [CompilerGeneratedAttribute]
public void set_SkipReverseDnsLookup(bool value);
    internal IEnumerable`1<string> GetIgnoredInterfaces();
    internal IEnumerable`1<string> GetPreferredNetworks();
}
public class Steeltoe.Common.Net.InetUtils : object {
    private InetOptions _options;
    private ILogger _logger;
    public InetUtils(InetOptions options, ILogger logger);
    public virtual HostInfo FindFirstNonLoopbackHostInfo();
    public IPAddress FindFirstNonLoopbackAddress();
    internal bool IsInet4Address(IPAddress address);
    internal bool IsLoopbackAddress(IPAddress address);
    internal bool IsPreferredAddress(IPAddress address);
    internal bool IgnoreInterface(string interfaceName);
    internal HostInfo ConvertAddress(IPAddress address);
    internal IPAddress ResolveHostAddress(string hostName);
    internal string ResolveHostName();
    internal string GetHostName();
    internal IPAddress GetHostAddress();
    internal bool IsSiteLocalAddress(IPAddress address);
}
public class Steeltoe.Common.Order.AbstractOrdered : object {
    public static int HIGHEST_PRECEDENCE;
    public static int LOWEST_PRECEDENCE;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; private set; }
    public AbstractOrdered(int order);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
}
public class Steeltoe.Common.Order.OrderComparer : object {
    [CompilerGeneratedAttribute]
private static OrderComparer <Instance>k__BackingField;
    public static OrderComparer Instance { get; }
    private static OrderComparer();
    [CompilerGeneratedAttribute]
public static OrderComparer get_Instance();
    public sealed virtual int Compare(IOrdered o1, IOrdered o2);
    protected int GetOrder(int i1, int i2);
    protected int GetOrder(IOrdered o1);
}
public static class Steeltoe.Common.Platform : object {
    public static string NET_FRAMEWORK;
    public static string NET_CORE;
    public static string VCAP_APPLICATION;
    public static string KUBERNETES_HOST;
    public static bool IsFullFramework { get; }
    public static bool IsNetCore { get; }
    public static bool IsLinux { get; }
    public static bool IsWindows { get; }
    public static bool IsOSX { get; }
    public static bool IsContainerized { get; }
    public static bool IsCloudFoundry { get; }
    public static bool IsKubernetes { get; }
    public static bool IsCloudHosted { get; }
    public static bool get_IsFullFramework();
    public static bool get_IsNetCore();
    public static bool get_IsLinux();
    public static bool get_IsWindows();
    public static bool get_IsOSX();
    public static bool get_IsContainerized();
    public static bool get_IsCloudFoundry();
    public static bool get_IsKubernetes();
    public static bool get_IsCloudHosted();
}
public static class Steeltoe.Common.Reflection.ReflectionHelpers : object {
    public static bool IsAssemblyLoaded(string assembly);
    public static Assembly FindAssembly(string name);
    public static IEnumerable`1<Assembly> FindAssemblies(Func`2<Assembly, bool> assemblyQuery);
    public static IEnumerable`1<Type> FindDescendantTypes(Func`2<Assembly, bool> assemblyQuery, Type baseType);
    public static IEnumerable`1<Type> FindTypeFromAssemblyAttribute();
    public static IEnumerable`1<Assembly> FindAssembliesWithAttribute();
    public static IEnumerable`1<Type> FindTypesWithAttribute(Assembly assembly);
    public static IEnumerable`1<Type> FindTypesWithAttributeFromAssemblyAttribute();
    public static IEnumerable`1<Type> FindAttributedTypesFromAssemblyAttribute();
    public static IEnumerable`1<Type> FindInterfacedTypesFromAssemblyAttribute();
    public static Type FindType(String[] assemblyNames, String[] typeNames);
    public static Type FindType(Assembly assembly, string typeName);
    public static Type FindTypeOrThrow(String[] assemblyNames, String[] typeNames, string typeName, string assemblyShortDescription);
    public static MethodInfo FindMethod(Type type, string methodName, Type[] parameters);
    public static object Invoke(MethodBase member, object instance, Object[] args);
    public static object CreateInstance(Type t, Object[] args);
    public static void TrySetProperty(object obj, string property, object value);
    private static void TryLoadAssembliesWithAttribute();
    private static List`1<string> AllRelevantPaths(String[] runtimeAssemblies, Type attributeType);
}
public class Steeltoe.Common.Retry.RetryContext : AbstractAttributeAccessor {
    private static string LAST_EXCEPTION;
    private static string RETRY_COUNT;
    private static string RETRY_PARENT;
    public Exception LastException { get; public set; }
    public int RetryCount { get; public set; }
    public IRetryContext Parent { get; public set; }
    public sealed virtual Exception get_LastException();
    public void set_LastException(Exception value);
    public sealed virtual int get_RetryCount();
    public void set_RetryCount(int value);
    public sealed virtual IRetryContext get_Parent();
    public void set_Parent(IRetryContext value);
    public virtual string ToString();
}
public class Steeltoe.Common.Retry.RetryException : Exception {
    public RetryException(string msg);
    public RetryException(string msg, Exception cause);
}
public static class Steeltoe.Common.Retry.RetrySynchronizationManager : object {
    private static AsyncLocal`1<IRetryContext> _context;
    private static RetrySynchronizationManager();
    public static IRetryContext GetContext();
    public static IRetryContext Register(IRetryContext context);
    public static IRetryContext Clear();
}
public abstract class Steeltoe.Common.Retry.RetryTemplate : object {
    protected List`1<IRetryListener> listeners;
    public void RegisterListener(IRetryListener listener);
    public abstract virtual T Execute(Func`2<IRetryContext, T> retryCallback);
    public abstract virtual T Execute(Func`2<IRetryContext, T> retryCallback, IRecoveryCallback`1<T> recoveryCallback);
    public abstract virtual void Execute(Action`1<IRetryContext> retryCallback);
    public abstract virtual void Execute(Action`1<IRetryContext> retryCallback, IRecoveryCallback recoveryCallback);
    public abstract virtual T Execute(Func`2<IRetryContext, T> retryCallback, Func`2<IRetryContext, T> recoveryCallback);
    public abstract virtual void Execute(Action`1<IRetryContext> retryCallback, Action`1<IRetryContext> recoveryCallback);
}
public class Steeltoe.Common.Retry.TerminatedRetryException : RetryException {
    public TerminatedRetryException(string msg, Exception cause);
    public TerminatedRetryException(string msg);
}
public static class Steeltoe.Common.SecurityUtilities : object {
    public static string SanitizeInput(string inputString);
}
public abstract class Steeltoe.Common.Transaction.AbstractPlatformTransactionManager : object {
    public static int SYNCHRONIZATION_ALWAYS;
    public static int SYNCHRONIZATION_ON_ACTUAL_TRANSACTION;
    public static int SYNCHRONIZATION_NEVER;
    protected ILogger _logger;
    private int _defaultTimeout;
    [CompilerGeneratedAttribute]
private int <TransactionSynchronization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NestedTransactionAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateExistingTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GlobalRollbackOnParticipationFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailEarlyOnGlobalRollbackOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RollbackOnCommitFailure>k__BackingField;
    public int TransactionSynchronization { get; public set; }
    public int DefaultTimeout { get; public set; }
    public bool NestedTransactionAllowed { get; public set; }
    public bool ValidateExistingTransaction { get; public set; }
    public bool GlobalRollbackOnParticipationFailure { get; public set; }
    public bool FailEarlyOnGlobalRollbackOnly { get; public set; }
    public bool RollbackOnCommitFailure { get; public set; }
    protected bool ShouldCommitOnGlobalRollbackOnly { get; }
    protected bool UseSavepointForNestedTransaction { get; }
    protected AbstractPlatformTransactionManager(ILogger logger);
    [CompilerGeneratedAttribute]
public virtual int get_TransactionSynchronization();
    [CompilerGeneratedAttribute]
public virtual void set_TransactionSynchronization(int value);
    public virtual int get_DefaultTimeout();
    public virtual void set_DefaultTimeout(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_NestedTransactionAllowed();
    [CompilerGeneratedAttribute]
public virtual void set_NestedTransactionAllowed(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_ValidateExistingTransaction();
    [CompilerGeneratedAttribute]
public virtual void set_ValidateExistingTransaction(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_GlobalRollbackOnParticipationFailure();
    [CompilerGeneratedAttribute]
public virtual void set_GlobalRollbackOnParticipationFailure(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_FailEarlyOnGlobalRollbackOnly();
    [CompilerGeneratedAttribute]
public virtual void set_FailEarlyOnGlobalRollbackOnly(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_RollbackOnCommitFailure();
    [CompilerGeneratedAttribute]
public virtual void set_RollbackOnCommitFailure(bool value);
    public virtual ITransactionStatus GetTransaction(ITransactionDefinition definition);
    public virtual void Commit(ITransactionStatus status);
    public virtual void Rollback(ITransactionStatus status);
    protected virtual DefaultTransactionStatus PrepareTransactionStatus(ITransactionDefinition definition, object transaction, bool newTransaction, bool newSynchronization, object suspendedResources);
    protected virtual DefaultTransactionStatus NewTransactionStatus(ITransactionDefinition definition, object transaction, bool newTransaction, bool newSynchronization, object suspendedResources);
    protected virtual void PrepareSynchronization(DefaultTransactionStatus status, ITransactionDefinition definition);
    protected virtual int DetermineTimeout(ITransactionDefinition definition);
    protected virtual SuspendedResourcesHolder Suspend(object transaction);
    protected virtual void Resume(object transaction, SuspendedResourcesHolder resourcesHolder);
    protected virtual void TriggerBeforeCommit(DefaultTransactionStatus status);
    protected virtual void TriggerBeforeCompletion(DefaultTransactionStatus status);
    protected virtual void InvokeAfterCompletion(List`1<ITransactionSynchronization> synchronizations, int completionStatus);
    protected abstract virtual object DoGetTransaction();
    protected virtual bool IsExistingTransaction(object transaction);
    protected abstract virtual void DoBegin(object transaction, ITransactionDefinition definition);
    protected virtual object DoSuspend(object transaction);
    protected virtual void DoResume(object transaction, object suspendedResources);
    protected virtual void PrepareForCommit(DefaultTransactionStatus status);
    protected virtual void DoSetRollbackOnly(DefaultTransactionStatus status);
    protected virtual void RegisterAfterCompletionWithExistingTransaction(object transaction, List`1<ITransactionSynchronization> synchronizations);
    protected virtual void DoCleanupAfterCompletion(object transaction);
    protected abstract virtual void DoCommit(DefaultTransactionStatus status);
    protected abstract virtual void DoRollback(DefaultTransactionStatus status);
    protected virtual bool get_ShouldCommitOnGlobalRollbackOnly();
    protected virtual bool get_UseSavepointForNestedTransaction();
    private void CleanupAfterCompletion(DefaultTransactionStatus status);
    private void TriggerAfterCommit(DefaultTransactionStatus status);
    private void TriggerAfterCompletion(DefaultTransactionStatus status, int completionStatus);
    private void DoRollbackOnCommitException(DefaultTransactionStatus status, Exception exception);
    private void ProcessRollback(DefaultTransactionStatus status, bool unexpected);
    private void ProcessCommit(DefaultTransactionStatus status);
    private void DoResumeSynchronization(List`1<ITransactionSynchronization> suspendedSynchronizations);
    private List`1<ITransactionSynchronization> DoSuspendSynchronization();
    private void ResumeAfterBeginException(object transaction, SuspendedResourcesHolder suspendedResources, Exception beginEx);
    private ITransactionStatus HandleExistingTransaction(ITransactionDefinition definition, object transaction);
}
public abstract class Steeltoe.Common.Transaction.AbstractTransactionDefinition : object {
    public static int PROPAGATION_REQUIRED;
    public static int PROPAGATION_SUPPORTS;
    public static int PROPAGATION_MANDATORY;
    public static int PROPAGATION_REQUIRES_NEW;
    public static int PROPAGATION_NOT_SUPPORTED;
    public static int PROPAGATION_NEVER;
    public static int PROPAGATION_NESTED;
    public static int ISOLATION_DEFAULT;
    public static int ISOLATION_READ_UNCOMMITTED;
    public static int ISOLATION_READ_COMMITTED;
    public static int ISOLATION_REPEATABLE_READ;
    public static int ISOLATION_SERIALIZABLE;
    public static int TIMEOUT_DEFAULT;
    [CompilerGeneratedAttribute]
private int <PropagationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static ITransactionDefinition WithDefaults { get; }
    public int PropagationBehavior { get; public set; }
    public int IsolationLevel { get; public set; }
    public int Timeout { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Name { get; public set; }
    public static ITransactionDefinition get_WithDefaults();
    [CompilerGeneratedAttribute]
public virtual int get_PropagationBehavior();
    [CompilerGeneratedAttribute]
public virtual void set_PropagationBehavior(int value);
    [CompilerGeneratedAttribute]
public virtual int get_IsolationLevel();
    [CompilerGeneratedAttribute]
public virtual void set_IsolationLevel(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Timeout();
    [CompilerGeneratedAttribute]
public virtual void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
}
public abstract class Steeltoe.Common.Transaction.AbstractTransactionOperations : object {
    public static ITransactionOperations WithoutTransaction();
    public abstract virtual T Execute(Func`2<ITransactionStatus, T> action);
    public virtual void ExecuteWithoutResult(Action`1<ITransactionStatus> action);
}
public abstract class Steeltoe.Common.Transaction.AbstractTransactionStatus : object {
    [CompilerGeneratedAttribute]
private bool <IsLocalRollbackOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobalRollbackOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Savepoint>k__BackingField;
    public bool IsNewTransaction { get; }
    public bool IsRollbackOnly { get; }
    public bool IsLocalRollbackOnly { get; public set; }
    public bool IsGlobalRollbackOnly { get; public set; }
    public bool IsCompleted { get; public set; }
    public object Savepoint { get; public set; }
    public bool HasSavepoint { get; }
    public abstract virtual bool get_IsNewTransaction();
    public virtual void SetRollbackOnly();
    public virtual bool get_IsRollbackOnly();
    [CompilerGeneratedAttribute]
public virtual bool get_IsLocalRollbackOnly();
    [CompilerGeneratedAttribute]
public virtual void set_IsLocalRollbackOnly(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsGlobalRollbackOnly();
    [CompilerGeneratedAttribute]
public virtual void set_IsGlobalRollbackOnly(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
public virtual void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public virtual object get_Savepoint();
    [CompilerGeneratedAttribute]
public virtual void set_Savepoint(object value);
    public virtual bool get_HasSavepoint();
    public virtual void CreateAndHoldSavepoint();
    public virtual void RollbackToHeldSavepoint();
    public virtual void ReleaseHeldSavepoint();
    public virtual object CreateSavepoint();
    public virtual void RollbackToSavepoint(object savepoint);
    public virtual void ReleaseSavepoint(object savepoint);
    public virtual void Flush();
    protected virtual ISavepointManager GetSavepointManager();
}
public abstract class Steeltoe.Common.Transaction.AbstractTransactionSynchronization : object {
    public static int STATUS_COMMITTED;
    public static int STATUS_ROLLED_BACK;
    public static int STATUS_UNKNOWN;
    public abstract virtual void AfterCommit();
    public abstract virtual void AfterCompletion(int status);
    public abstract virtual void BeforeCommit(bool readOnly);
    public abstract virtual void BeforeCompletion();
    public abstract virtual void Flush();
    public abstract virtual void Resume();
    public abstract virtual void Suspend();
}
public class Steeltoe.Common.Transaction.CannotCreateTransactionException : TransactionException {
    public CannotCreateTransactionException(string msg);
    public CannotCreateTransactionException(string msg, Exception cause);
}
public class Steeltoe.Common.Transaction.DefaultTransactionAttribute : DefaultTransactionDefinition {
    [CompilerGeneratedAttribute]
private string <Qualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Descriptor>k__BackingField;
    public string Qualifier { get; }
    public string Descriptor { get; }
    public DefaultTransactionAttribute(ITransactionAttribute other);
    public DefaultTransactionAttribute(int propagationBehavior);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Qualifier();
    [CompilerGeneratedAttribute]
public string get_Descriptor();
    public sealed virtual bool RollbackOn(Exception exception);
    protected StringBuilder GetAttributeDescription();
}
public class Steeltoe.Common.Transaction.DefaultTransactionDefinition : AbstractTransactionDefinition {
    public static string PREFIX_PROPAGATION;
    public static string PREFIX_ISOLATION;
    public static string PREFIX_TIMEOUT;
    public static string READ_ONLY_MARKER;
    [CompilerGeneratedAttribute]
private int <PropagationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int PropagationBehavior { get; public set; }
    public int IsolationLevel { get; public set; }
    public int Timeout { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Name { get; public set; }
    public DefaultTransactionDefinition(ITransactionDefinition other);
    public DefaultTransactionDefinition(int propagationBehavior);
    [CompilerGeneratedAttribute]
public virtual int get_PropagationBehavior();
    [CompilerGeneratedAttribute]
public virtual void set_PropagationBehavior(int value);
    [CompilerGeneratedAttribute]
public virtual int get_IsolationLevel();
    [CompilerGeneratedAttribute]
public virtual void set_IsolationLevel(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Timeout();
    [CompilerGeneratedAttribute]
public virtual void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected StringBuilder GetDefinitionDescription();
}
public class Steeltoe.Common.Transaction.DefaultTransactionStatus : AbstractTransactionStatus {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private object <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewSynchronization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SuspendedResources>k__BackingField;
    public object Transaction { get; }
    public bool HasTransaction { get; }
    public bool NewTransaction { get; }
    public bool IsNewSynchronization { get; }
    public bool IsReadOnly { get; }
    public object SuspendedResources { get; }
    public bool IsNewTransaction { get; }
    public bool IsTransactionSavepointManager { get; }
    public bool IsGlobalRollbackOnly { get; public set; }
    public DefaultTransactionStatus(object transaction, bool newTransaction, bool newSynchronization, bool readOnly, object suspendedResources, ILogger logger);
    [CompilerGeneratedAttribute]
public object get_Transaction();
    public bool get_HasTransaction();
    [CompilerGeneratedAttribute]
public bool get_NewTransaction();
    [CompilerGeneratedAttribute]
public bool get_IsNewSynchronization();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public object get_SuspendedResources();
    public virtual bool get_IsNewTransaction();
    public bool get_IsTransactionSavepointManager();
    public virtual void Flush();
    public virtual bool get_IsGlobalRollbackOnly();
    public virtual void set_IsGlobalRollbackOnly(bool value);
    protected virtual ISavepointManager GetSavepointManager();
}
public class Steeltoe.Common.Transaction.IllegalTransactionStateException : TransactionUsageException {
    public IllegalTransactionStateException(string msg);
    public IllegalTransactionStateException(string msg, Exception cause);
}
public class Steeltoe.Common.Transaction.InvalidIsolationLevelException : TransactionUsageException {
    public InvalidIsolationLevelException(string msg);
}
public class Steeltoe.Common.Transaction.InvalidTimeoutException : TransactionUsageException {
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    public int Timeout { get; }
    public InvalidTimeoutException(string msg, int timeout);
    [CompilerGeneratedAttribute]
public int get_Timeout();
}
public class Steeltoe.Common.Transaction.NestedTransactionNotSupportedException : CannotCreateTransactionException {
    public NestedTransactionNotSupportedException(string msg);
    public NestedTransactionNotSupportedException(string msg, Exception cause);
}
public abstract class Steeltoe.Common.Transaction.ResourceHolderSupport : object {
    private int _referenceCount;
    [CompilerGeneratedAttribute]
private bool <SynchronizedWithTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RollbackOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Deadline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVoid>k__BackingField;
    public bool SynchronizedWithTransaction { get; public set; }
    public bool RollbackOnly { get; public set; }
    public bool HasTimeout { get; }
    public Nullable`1<DateTime> Deadline { get; private set; }
    public bool IsOpen { get; }
    public bool IsVoid { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_SynchronizedWithTransaction();
    [CompilerGeneratedAttribute]
public void set_SynchronizedWithTransaction(bool value);
    [CompilerGeneratedAttribute]
public bool get_RollbackOnly();
    [CompilerGeneratedAttribute]
public void set_RollbackOnly(bool value);
    public bool get_HasTimeout();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Deadline();
    [CompilerGeneratedAttribute]
private void set_Deadline(Nullable`1<DateTime> value);
    public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVoid();
    [CompilerGeneratedAttribute]
private void set_IsVoid(bool value);
    public int GetTimetoLiveInSeconds();
    public long GetTimeToLiveInMillis();
    public void SetTimeoutInSeconds(int seconds);
    public void SetTimeoutInMillis(long milliSeconds);
    public void Requested();
    public void Released();
    public void Clear();
    public sealed virtual void Reset();
    public sealed virtual void Unbound();
    private void CheckTransactionTimeout(bool deadlineReached);
}
public class Steeltoe.Common.Transaction.ResourceHolderSynchronization`2 : object {
    private H _resourceHolder;
    private K _resourceKey;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _holderActive;
    public ResourceHolderSynchronization`2(H resourceHolder, K resourceKey);
    public virtual void Suspend();
    public virtual void Resume();
    public virtual void Flush();
    public virtual void BeforeCommit(bool readOnly);
    public virtual void BeforeCompletion();
    public virtual void AfterCommit();
    public virtual void AfterCompletion(int status);
    protected virtual bool ShouldUnbindAtCompletion();
    protected virtual bool ShouldReleaseBeforeCompletion();
    protected virtual bool ShouldReleaseAfterCompletion(H resourceHolder);
    protected virtual void FlushResource(H resourceHolder);
    protected virtual void ProcessResourceAfterCommit(H resourceHolder);
    protected virtual void ReleaseResource(H resourceHolder, K resourceKey);
    protected virtual void CleanupResource(H resourceHolder, K resourceKey, bool committed);
}
public class Steeltoe.Common.Transaction.SimpleTransactionStatus : AbstractTransactionStatus {
    [CompilerGeneratedAttribute]
private bool <IsNewTransaction>k__BackingField;
    public bool IsNewTransaction { get; }
    public SimpleTransactionStatus(bool newTransaction);
    [CompilerGeneratedAttribute]
public virtual bool get_IsNewTransaction();
}
internal class Steeltoe.Common.Transaction.StaticTransactionDefinition : AbstractTransactionDefinition {
    internal static StaticTransactionDefinition INSTANCE;
    private static StaticTransactionDefinition();
}
public abstract class Steeltoe.Common.Transaction.TransactionException : Exception {
    protected TransactionException(string msg);
    protected TransactionException(string msg, Exception cause);
}
public class Steeltoe.Common.Transaction.TransactionSuspensionNotSupportedException : CannotCreateTransactionException {
    public TransactionSuspensionNotSupportedException(string msg);
    public TransactionSuspensionNotSupportedException(string msg, Exception cause);
}
public static class Steeltoe.Common.Transaction.TransactionSynchronizationManager : object {
    private static AsyncLocal`1<Dictionary`2<object, object>> _resources;
    private static AsyncLocal`1<ISet`1<ITransactionSynchronization>> _synchronizations;
    private static AsyncLocal`1<bool> _actualTransactionActive;
    private static AsyncLocal`1<Nullable`1<int>> _currentTransactionIsolationLevel;
    private static AsyncLocal`1<string> _currentTransactionName;
    private static AsyncLocal`1<bool> _currentTransactionReadOnly;
    private static IDictionary`2<object, object> _emptyDict;
    private static List`1<ITransactionSynchronization> _emptyList;
    private static TransactionSynchronizationManager();
    public static IDictionary`2<object, object> GetResourceMap();
    public static bool HasResource(object key);
    public static object GetResource(object key, ILogger logger);
    public static void BindResource(object key, object value, ILogger logger);
    public static object UnbindResource(object key, ILogger logger);
    public static object UnbindResourceIfPossible(object key, ILogger logger);
    public static bool IsSynchronizationActive();
    public static void InitSynchronization(ILogger logger);
    public static void RegisterSynchronization(ITransactionSynchronization synchronization);
    public static List`1<ITransactionSynchronization> GetSynchronizations();
    public static void ClearSynchronization(ILogger logger);
    public static bool IsActualTransactionActive();
    public static void SetActualTransactionActive(bool active);
    public static Nullable`1<int> GetCurrentTransactionIsolationLevel();
    public static void SetCurrentTransactionIsolationLevel(Nullable`1<int> isolationLevel);
    public static void SetCurrentTransactionName(string name);
    public static string GetCurrentTransactionName();
    public static void SetCurrentTransactionReadOnly(bool readOnly);
    public static bool IsCurrentTransactionReadOnly();
    public static void Clear();
    private static object DoUnbindResource(object actualKey, ILogger logger);
    private static object DoGetResource(object actualKey);
}
public static class Steeltoe.Common.Transaction.TransactionSynchronizationUtils : object {
    public static void TriggerBeforeCommit(bool readOnly);
    public static void TriggerBeforeCompletion(ILogger logger);
    public static void TriggerAfterCommit();
    public static void InvokeAfterCommit(List`1<ITransactionSynchronization> synchronizations);
    public static void TriggerAfterCompletion(int completionStatus);
    public static void InvokeAfterCompletion(List`1<ITransactionSynchronization> synchronizations, int completionStatus, ILogger logger);
}
public class Steeltoe.Common.Transaction.TransactionSystemException : TransactionException {
    [CompilerGeneratedAttribute]
private Exception <ApplicationException>k__BackingField;
    public Exception ApplicationException { get; private set; }
    public Exception OriginalException { get; }
    public TransactionSystemException(string msg);
    public TransactionSystemException(string msg, Exception cause);
    [CompilerGeneratedAttribute]
public Exception get_ApplicationException();
    [CompilerGeneratedAttribute]
private void set_ApplicationException(Exception value);
    public Exception get_OriginalException();
    public void InitApplicationException(Exception exception);
    public bool Contains(Type exceptionType);
}
public class Steeltoe.Common.Transaction.TransactionTemplate : DefaultTransactionDefinition {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private IPlatformTransactionManager <TransactionManager>k__BackingField;
    public IPlatformTransactionManager TransactionManager { get; public set; }
    public TransactionTemplate(ILogger logger);
    public TransactionTemplate(IPlatformTransactionManager transactionManager, ILogger logger);
    public TransactionTemplate(IPlatformTransactionManager transactionManager, ITransactionDefinition transactionDefinition, ILogger logger);
    [CompilerGeneratedAttribute]
public IPlatformTransactionManager get_TransactionManager();
    [CompilerGeneratedAttribute]
public void set_TransactionManager(IPlatformTransactionManager value);
    public void Execute(Action`1<ITransactionStatus> action);
    public T Execute(Func`2<ITransactionStatus, T> action);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private void RollbackOnException(ITransactionStatus status, Exception ex);
}
public class Steeltoe.Common.Transaction.TransactionTimedOutException : TransactionException {
    public TransactionTimedOutException(string msg);
    public TransactionTimedOutException(string msg, Exception cause);
}
public class Steeltoe.Common.Transaction.TransactionUsageException : TransactionException {
    public TransactionUsageException(string msg);
    public TransactionUsageException(string msg, Exception cause);
}
public class Steeltoe.Common.Transaction.UnexpectedRollbackException : TransactionException {
    public UnexpectedRollbackException(string msg);
    public UnexpectedRollbackException(string msg, Exception cause);
}
internal class Steeltoe.Common.Transaction.WithoutTransactionOperations : object {
    public static WithoutTransactionOperations INSTANCE;
    private static WithoutTransactionOperations();
    public sealed virtual T Execute(Func`2<ITransactionStatus, T> action);
    public sealed virtual void ExecuteWithoutResult(Action`1<ITransactionStatus> action);
}
public abstract class Steeltoe.Common.Util.AbstractAttributeAccessor : object {
    private Dictionary`2<string, object> _attributes;
    public String[] AttributeNames { get; }
    public virtual void SetAttribute(string name, object value);
    public virtual object GetAttribute(string name);
    public virtual object RemoveAttribute(string name);
    public virtual bool HasAttribute(string name);
    public virtual String[] get_AttributeNames();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    protected virtual void CopyAttributesFrom(IAttributeAccessor source);
}
public class Steeltoe.Common.Util.AntPathMatcher : object {
    public static string DEFAULT_PATH_SEPARATOR;
    private static int CACHE_TURNOFF_THRESHOLD;
    private static Regex VARIABLE_PATTERN;
    private static Char[] WILDCARD_CHARS;
    private ConcurrentDictionary`2<string, String[]> _tokenizedPatternCache;
    private ConcurrentDictionary`2<string, AntPathStringMatcher> _stringMatcherCache;
    private string _pathSeparator;
    private PathSeparatorPatternCache _pathSeparatorPatternCache;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CachePatterns>k__BackingField;
    public string PathSeparator { get; public set; }
    public bool CaseSensitive { get; public set; }
    public bool TrimTokens { get; public set; }
    public Nullable`1<bool> CachePatterns { get; public set; }
    public AntPathMatcher(string pathSeparator);
    private static AntPathMatcher();
    public virtual string get_PathSeparator();
    public virtual void set_PathSeparator(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public virtual void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_TrimTokens();
    [CompilerGeneratedAttribute]
public virtual void set_TrimTokens(bool value);
    [CompilerGeneratedAttribute]
public virtual Nullable`1<bool> get_CachePatterns();
    [CompilerGeneratedAttribute]
public virtual void set_CachePatterns(Nullable`1<bool> value);
    public virtual bool IsPattern(string path);
    public virtual bool Match(string pattern, string path);
    public virtual bool MatchStart(string pattern, string path);
    public virtual string ExtractPathWithinPattern(string pattern, string path);
    public virtual IDictionary`2<string, string> ExtractUriTemplateVariables(string pattern, string path);
    public virtual string Combine(string pattern1, string pattern2);
    public virtual IComparer`1<string> GetPatternComparer(string path);
    protected virtual bool DoMatch(string pattern, string path, bool fullMatch, IDictionary`2<string, string> uriTemplateVariables);
    protected virtual String[] TokenizePattern(string pattern);
    protected virtual String[] TokenizePath(string path);
    protected virtual AntPathStringMatcher GetStringMatcher(string pattern);
    private string Concat(string path1, string path2);
    private bool MatchStrings(string pattern, string str, IDictionary`2<string, string> uriTemplateVariables);
    private bool IsPotentialMatch(string path, String[] pattDirs);
    private int SkipSegment(string path, int pos, string prefix);
    private int SkipSeparator(string path, int pos, string separator);
    private bool IsWildcardChar(char c);
    private void DeactivatePatternCache();
}
public static class Steeltoe.Common.Util.AttributeUtils : object {
    public static object GetValue(Attribute attribute, string propertyName);
    public static List`1<MethodInfo> FindMethodsWithAttribute(Type targetClass, Type attribute, BindingFlags flags);
}
public class Steeltoe.Common.Util.BinaryExceptionClassifier : SubclassClassifier`2<Exception, bool> {
    [CompilerGeneratedAttribute]
private bool <TraverseInnerExceptions>k__BackingField;
    public bool TraverseInnerExceptions { get; public set; }
    public BinaryExceptionClassifier(bool defaultValue);
    public BinaryExceptionClassifier(IList`1<Type> exceptionClasses, bool defaultValue);
    public BinaryExceptionClassifier(IList`1<Type> exceptionClasses);
    public BinaryExceptionClassifier(Dictionary`2<Type, bool> typeMap);
    public BinaryExceptionClassifier(Dictionary`2<Type, bool> typeMap, bool defaultValue);
    [CompilerGeneratedAttribute]
public bool get_TraverseInnerExceptions();
    [CompilerGeneratedAttribute]
public void set_TraverseInnerExceptions(bool value);
    public virtual bool Classify(Exception classifiable);
}
public static class Steeltoe.Common.Util.ClassUtils : object {
    public static Type GetGenericTypeDefinition(Type type);
    public static bool IsAssignableValue(Type type, object value);
    public static bool IsAssignable(Type lhsType, Type rhsType);
    public static MethodInfo GetInterfaceMethodIfPossible(MethodInfo method);
    public static string GetQualifiedMethodName(MethodInfo method);
    public static Type[] GetParameterTypes(MethodBase method);
    public static Object[][] GetParameterAttributes(MethodInfo method);
    public static Type DetermineCommonAncestor(Type clazz1, Type clazz2);
}
public class Steeltoe.Common.Util.DefaultIdGenerator : object {
    public sealed virtual string GenerateId();
}
public static class Steeltoe.Common.Util.EncodingUtils : object {
    public static Encoding Utf16;
    public static Encoding Utf16be;
    public static Encoding Utf7;
    public static Encoding Utf8;
    public static Encoding Utf32;
    public static Encoding Utf32be;
    private static EncodingUtils();
    public static Encoding GetDefaultEncoding();
    public static Encoding GetEncoding(string name);
    public static string GetEncoding(Encoding name);
}
public class Steeltoe.Common.Util.ExceptionDepthComparator : object {
    private Type _targetException;
    public ExceptionDepthComparator(Exception exception);
    public ExceptionDepthComparator(Type exceptionType);
    public sealed virtual int Compare(Type o1, Type o2);
    private int GetDepth(Type declaredException, Type exceptionToMatch, int depth);
}
public class Steeltoe.Common.Util.FixedBackOff : object {
    public static int STOP;
    public static int DEFAULT_INTERVAL;
    public static int UNLIMITED_ATTEMPTS;
    [CompilerGeneratedAttribute]
private int <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAttempts>k__BackingField;
    public int Interval { get; public set; }
    public int MaxAttempts { get; public set; }
    public FixedBackOff(int interval, int maxAttempts);
    [CompilerGeneratedAttribute]
public int get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(int value);
    [CompilerGeneratedAttribute]
public int get_MaxAttempts();
    [CompilerGeneratedAttribute]
public void set_MaxAttempts(int value);
    public sealed virtual IBackOffExecution Start();
}
public class Steeltoe.Common.Util.MethodInvoker : object {
    [CompilerGeneratedAttribute]
private Type <TargetClass>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodObject>k__BackingField;
    public Type TargetClass { get; public set; }
    public object TargetObject { get; private set; }
    public string TargetMethod { get; public set; }
    public string StaticMethod { get; public set; }
    public Object[] Arguments { get; private set; }
    public MethodInfo MethodObject { get; public set; }
    public bool IsPrepared { get; }
    [CompilerGeneratedAttribute]
public Type get_TargetClass();
    [CompilerGeneratedAttribute]
public void set_TargetClass(Type value);
    [CompilerGeneratedAttribute]
public object get_TargetObject();
    [CompilerGeneratedAttribute]
private void set_TargetObject(object value);
    [CompilerGeneratedAttribute]
public string get_TargetMethod();
    [CompilerGeneratedAttribute]
public void set_TargetMethod(string value);
    [CompilerGeneratedAttribute]
public string get_StaticMethod();
    [CompilerGeneratedAttribute]
public void set_StaticMethod(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(Object[] value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodObject();
    [CompilerGeneratedAttribute]
public void set_MethodObject(MethodInfo value);
    public bool get_IsPrepared();
    public static int GetTypeDifferenceWeight(Type[] paramTypes, Object[] args);
    public virtual void SetTargetObject(object target);
    public virtual void SetArguments(Object[] arguments);
    public virtual void Prepare();
    public object Invoke();
    public MethodInfo GetPreparedMethod();
    protected virtual MethodInfo FindMatchingMethod();
    protected virtual Type ResolveClassName(string className);
    private Type[] GetParameterTypes(MethodInfo candidate);
}
public class Steeltoe.Common.Util.MimeType : object {
    public static string WILDCARD_TYPE;
    private static string PARAM_CHARSET;
    private static BitArray TOKEN;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _tostringValue;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subtype>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    public bool IsWildcardType { get; }
    public bool IsWildcardSubtype { get; }
    public bool IsConcrete { get; }
    public string Type { get; }
    public string Subtype { get; }
    public Encoding Encoding { get; }
    public IDictionary`2<string, string> Parameters { get; }
    private static MimeType();
    public MimeType(string type);
    public MimeType(string type, string subtype);
    public MimeType(string type, string subtype, Encoding charset);
    public MimeType(MimeType other, Encoding charset);
    public MimeType(MimeType other, IDictionary`2<string, string> parameters);
    public MimeType(string type, string subtype, IDictionary`2<string, string> parameters);
    public static MimeType ToMimeType(string value);
    protected void CheckParameters(string attribute, string value);
    protected string Unquote(string s);
    public bool get_IsWildcardType();
    public bool get_IsWildcardSubtype();
    public bool get_IsConcrete();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Subtype();
    public Encoding get_Encoding();
    public string GetParameter(string name);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    public bool Includes(MimeType other);
    public bool IsCompatibleWith(MimeType other);
    public bool EqualsTypeAndSubtype(MimeType other);
    public bool IsPresentIn(ICollection`1<T> mimeTypes);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(MimeType other);
    internal void AppendTo(StringBuilder builder);
    private static IDictionary`2<string, string> AddCharsetParameter(Encoding charset, IDictionary`2<string, string> parameters);
    private bool IsQuotedstring(string s);
    private bool ParametersAreEqual(MimeType other);
    private void CheckToken(string token);
    private Encoding GetEncoding(string name);
    private void AppendTo(IDictionary`2<string, string> map, StringBuilder builder);
}
public static class Steeltoe.Common.Util.MimeTypeUtils : object {
    public static IComparer`1<MimeType> SPECIFICITY_COMPARATOR;
    public static MimeType ALL;
    public static string ALL_VALUE;
    public static MimeType APPLICATION_JSON;
    public static string APPLICATION_JSON_VALUE;
    public static MimeType APPLICATION_OCTET_STREAM;
    public static string APPLICATION_OCTET_STREAM_VALUE;
    public static MimeType APPLICATION_XML;
    public static string APPLICATION_XML_VALUE;
    public static MimeType IMAGE_GIF;
    public static string IMAGE_GIF_VALUE;
    public static MimeType IMAGE_JPEG;
    public static string IMAGE_JPEG_VALUE;
    public static MimeType IMAGE_PNG;
    public static string IMAGE_PNG_VALUE;
    public static MimeType TEXT_HTML;
    public static string TEXT_HTML_VALUE;
    public static MimeType TEXT_PLAIN;
    public static string TEXT_PLAIN_VALUE;
    public static MimeType TEXT_XML;
    public static string TEXT_XML_VALUE;
    private static ConcurrentDictionary`2<string, MimeType> _cachedMimeTypes;
    private static Char[] BOUNDARY_CHARS;
    private static Random modreq(System.Runtime.CompilerServices.IsVolatile) _random;
    private static object _lock;
    private static MimeTypeUtils();
    public static MimeType ParseMimeType(string mimeType);
    public static List`1<MimeType> ParseMimeTypes(string mimeTypes);
    public static List`1<string> Tokenize(string mimeTypes);
    public static string Tostring(ICollection`1<MimeType> mimeTypes);
    public static void SortBySpecificity(List`1<MimeType> mimeTypes);
    public static Char[] GenerateMultipartBoundary();
    public static string GenerateMultipartBoundaryString();
    private static MimeType ParseMimeTypeInternal(string mimeType);
    private static Random InitRandom();
}
public static class Steeltoe.Common.Util.ObjectUtils : object {
    private static int INITIAL_HASH;
    private static int MULTIPLIER;
    public static bool IsEmpty(Object[] array);
    public static bool NullSafeEquals(object o1, object o2);
    public static int NullSafeHashCode(object obj);
    internal static int ArrayHashCode(object o1);
    internal static bool ArrayEquals(object o1, object o2);
    internal static bool ArrayItemsEqual(T[] o1, T[] o2);
    internal static int ArrayItemsHashCode(T[] array);
}
public static class Steeltoe.Common.Util.PatternMatchUtils : object {
    public static bool SimpleMatch(string pattern, string str);
    public static bool SimpleMatch(String[] patterns, string str);
}
public class Steeltoe.Common.Util.SimpleRouteMatcher : object {
    [CompilerGeneratedAttribute]
private IPathMatcher <PathMatcher>k__BackingField;
    public IPathMatcher PathMatcher { get; }
    public SimpleRouteMatcher(IPathMatcher pathMatcher);
    [CompilerGeneratedAttribute]
public IPathMatcher get_PathMatcher();
    public sealed virtual IRoute ParseRoute(string route);
    public sealed virtual bool IsPattern(string route);
    public sealed virtual string Combine(string pattern1, string pattern2);
    public sealed virtual bool Match(string pattern, IRoute route);
    public sealed virtual IDictionary`2<string, string> MatchAndExtract(string pattern, IRoute route);
    public sealed virtual IComparer`1<string> GetPatternComparer(IRoute route);
}
public class Steeltoe.Common.Util.SubclassClassifier`2 : object {
    [CompilerGeneratedAttribute]
private C <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Type, C> <TypeMap>k__BackingField;
    public C DefaultValue { get; public set; }
    protected ConcurrentDictionary`2<Type, C> TypeMap { get; protected set; }
    public SubclassClassifier`2(C defaultValue);
    public SubclassClassifier`2(ConcurrentDictionary`2<Type, C> typeMap, C defaultValue);
    [CompilerGeneratedAttribute]
public C get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(C value);
    [CompilerGeneratedAttribute]
protected ConcurrentDictionary`2<Type, C> get_TypeMap();
    [CompilerGeneratedAttribute]
protected void set_TypeMap(ConcurrentDictionary`2<Type, C> value);
    public virtual C Classify(T classifiable);
}
