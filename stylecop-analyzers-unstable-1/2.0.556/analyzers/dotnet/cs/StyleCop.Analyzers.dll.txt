[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonArray/JsonArrayDebugView")]
internal class LightJson.JsonArray : object {
    private IList`1<JsonValue> items;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public JsonArray(JsonValue[] values);
    public int get_Count();
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public JsonArray Add(JsonValue value);
    public JsonArray Insert(int index, JsonValue value);
    public JsonArray Remove(int index);
    public JsonArray Clear();
    public bool Contains(JsonValue item);
    public int IndexOf(JsonValue item);
    public sealed virtual IEnumerator`1<JsonValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonObject/JsonObjectDebugView")]
internal class LightJson.JsonObject : object {
    private IDictionary`2<string, JsonValue> properties;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public int get_Count();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonObject Add(string key);
    public JsonObject Add(string key, JsonValue value);
    public bool Remove(string key);
    public JsonObject Clear();
    public JsonObject Rename(string oldKey, string newKey);
    public bool ContainsKey(string key);
    public bool Contains(JsonValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<JsonValue> System.Collections.Generic.IEnumerable<LightJson.JsonValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
[DebuggerTypeProxyAttribute("LightJson.JsonValue/JsonValueDebugView")]
internal class LightJson.JsonValue : ValueType {
    public static JsonValue Null;
    private JsonValueType type;
    private object reference;
    private double value;
    public JsonValueType Type { get; }
    public bool IsNull { get; }
    public bool IsBoolean { get; }
    public bool IsInteger { get; }
    public bool IsNumber { get; }
    public bool IsString { get; }
    public bool IsJsonObject { get; }
    public bool IsJsonArray { get; }
    public bool IsDateTime { get; }
    public bool AsBoolean { get; }
    public int AsInteger { get; }
    public double AsNumber { get; }
    public string AsString { get; }
    public JsonObject AsJsonObject { get; }
    public JsonArray AsJsonArray { get; }
    public Nullable`1<DateTime> AsDateTime { get; }
    public object AsObject { get; }
    public JsonValue Item { get; public set; }
    public JsonValue Item { get; public set; }
    public JsonValue(Nullable`1<bool> value);
    public JsonValue(Nullable`1<double> value);
    public JsonValue(string value);
    public JsonValue(JsonObject value);
    public JsonValue(JsonArray value);
    private JsonValue(JsonValueType type, double value, object reference);
    private static JsonValue();
    public JsonValueType get_Type();
    public bool get_IsNull();
    public bool get_IsBoolean();
    public bool get_IsInteger();
    public bool get_IsNumber();
    public bool get_IsString();
    public bool get_IsJsonObject();
    public bool get_IsJsonArray();
    public bool get_IsDateTime();
    public bool get_AsBoolean();
    public int get_AsInteger();
    public double get_AsNumber();
    public string get_AsString();
    public JsonObject get_AsJsonObject();
    public JsonArray get_AsJsonArray();
    public Nullable`1<DateTime> get_AsDateTime();
    public object get_AsObject();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public static JsonValue op_Implicit(Nullable`1<bool> value);
    public static JsonValue op_Implicit(Nullable`1<double> value);
    public static JsonValue op_Implicit(string value);
    public static JsonValue op_Implicit(JsonObject value);
    public static JsonValue op_Implicit(JsonArray value);
    public static JsonValue op_Implicit(Nullable`1<DateTime> value);
    public static int op_Explicit(JsonValue jsonValue);
    public static Nullable`1<int> op_Explicit(JsonValue jsonValue);
    public static bool op_Explicit(JsonValue jsonValue);
    public static Nullable`1<bool> op_Explicit(JsonValue jsonValue);
    public static double op_Explicit(JsonValue jsonValue);
    public static Nullable`1<double> op_Explicit(JsonValue jsonValue);
    public static string op_Explicit(JsonValue jsonValue);
    public static JsonObject op_Explicit(JsonValue jsonValue);
    public static JsonArray op_Explicit(JsonValue jsonValue);
    public static DateTime op_Explicit(JsonValue jsonValue);
    public static Nullable`1<DateTime> op_Explicit(JsonValue jsonValue);
    public static bool op_Equality(JsonValue a, JsonValue b);
    public static bool op_Inequality(JsonValue a, JsonValue b);
    public static JsonValue Parse(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum LightJson.JsonValueType : Enum {
    public byte value__;
    public static JsonValueType Null;
    public static JsonValueType Boolean;
    public static JsonValueType Number;
    public static JsonValueType String;
    public static JsonValueType Object;
    public static JsonValueType Array;
}
internal class LightJson.Serialization.JsonParseException : Exception {
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    public TextPosition Position { get; private set; }
    public ErrorType Type { get; private set; }
    public JsonParseException(ErrorType type, TextPosition position);
    public JsonParseException(string message, ErrorType type, TextPosition position);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(TextPosition value);
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ErrorType value);
    private static string GetDefaultMessage(ErrorType type);
}
internal class LightJson.Serialization.JsonReader : object {
    private TextScanner scanner;
    private JsonReader(TextReader reader);
    public static JsonValue Parse(TextReader reader);
    public static JsonValue Parse(string source);
    private string ReadJsonKey();
    private JsonValue ReadJsonValue();
    private JsonValue ReadNull();
    private JsonValue ReadBoolean();
    private void ReadDigits(StringBuilder builder);
    private JsonValue ReadNumber();
    private string ReadString();
    private int ReadHexDigit();
    private char ReadUnicodeLiteral();
    private JsonObject ReadObject();
    private JsonObject ReadObject(JsonObject jsonObject);
    private JsonArray ReadArray();
    private JsonArray ReadArray(JsonArray jsonArray);
    private JsonValue Parse();
}
internal class LightJson.Serialization.JsonSerializationException : Exception {
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    public ErrorType Type { get; }
    public JsonSerializationException(ErrorType type);
    public JsonSerializationException(string message, ErrorType type);
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    private static string GetDefaultMessage(ErrorType type);
}
internal class LightJson.Serialization.JsonWriter : object {
    private int indent;
    private bool isNewLine;
    private TextWriter writer;
    private HashSet`1<IEnumerable`1<JsonValue>> renderingCollections;
    [CompilerGeneratedAttribute]
private string <IndentString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpacingString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLineString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortObjects>k__BackingField;
    public string IndentString { get; public set; }
    public string SpacingString { get; public set; }
    public string NewLineString { get; public set; }
    public bool SortObjects { get; public set; }
    public JsonWriter(bool pretty);
    [CompilerGeneratedAttribute]
public string get_IndentString();
    [CompilerGeneratedAttribute]
public void set_IndentString(string value);
    [CompilerGeneratedAttribute]
public string get_SpacingString();
    [CompilerGeneratedAttribute]
public void set_SpacingString(string value);
    [CompilerGeneratedAttribute]
public string get_NewLineString();
    [CompilerGeneratedAttribute]
public void set_NewLineString(string value);
    [CompilerGeneratedAttribute]
public bool get_SortObjects();
    [CompilerGeneratedAttribute]
public void set_SortObjects(bool value);
    public string Serialize(JsonValue jsonValue);
    public sealed virtual void Dispose();
    private void Initialize();
    private void Write(string text);
    private void WriteEncodedJsonValue(JsonValue value);
    private void WriteEncodedString(string text);
    private void WriteIndentation();
    private void WriteSpacing();
    private void WriteLine();
    private void WriteLine(string line);
    private void AddRenderingCollection(IEnumerable`1<JsonValue> value);
    private void RemoveRenderingCollection(IEnumerable`1<JsonValue> value);
    private void Render(JsonValue value);
    private void Render(JsonArray value);
    private void Render(JsonObject value);
    private IEnumerator`1<KeyValuePair`2<string, JsonValue>> GetJsonObjectEnumerator(JsonObject jsonObject);
}
internal class LightJson.Serialization.TextPosition : ValueType {
    public long Column;
    public long Line;
}
internal class LightJson.Serialization.TextScanner : object {
    private TextReader reader;
    private TextPosition position;
    public TextPosition Position { get; }
    public TextScanner(TextReader reader);
    public TextPosition get_Position();
    public char Peek();
    public int Peek(bool throwAtEndOfFile);
    public char Read();
    public void SkipWhitespace();
    public void Assert(char next);
    public void Assert(string next);
    private void SkipComment();
    private void SkipLineComment();
    private void SkipBlockComment();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class StyleCop.Analyzers.AnalyzerCategory : object {
    internal static string DocumentationRules;
    internal static string LayoutRules;
    internal static string MaintainabilityRules;
    internal static string NamingRules;
    internal static string OrderingRules;
    internal static string ReadabilityRules;
    internal static string SpacingRules;
    internal static string SpecialRules;
}
internal static class StyleCop.Analyzers.AnalyzerConstants : object {
    [CompilerGeneratedAttribute]
private static bool <DisabledNoTests>k__BackingField;
    [ExcludeFromCodeCoverageAttribute]
internal static bool DisabledNoTests { get; }
    internal static bool DisabledAlternative { get; }
    internal static bool EnabledByDefault { get; }
    internal static bool DisabledByDefault { get; }
    private static AnalyzerConstants();
    [CompilerGeneratedAttribute]
internal static bool get_DisabledNoTests();
    internal static bool get_DisabledAlternative();
    internal static bool get_EnabledByDefault();
    internal static bool get_DisabledByDefault();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.AnalyzerExtensions : object {
    [ExtensionAttribute]
public static void RegisterSyntaxTreeAction(CompilationStartAnalysisContext context, Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> action);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(CompilationStartAnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, TLanguageKindEnum syntaxKind);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(CompilationStartAnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal enum StyleCop.Analyzers.DeserializationFailureBehavior : Enum {
    public int value__;
    public static DeserializationFailureBehavior ReturnDefaultSettings;
    public static DeserializationFailureBehavior ThrowException;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.DocumentationRules.DocumentationResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ConstructorDocumentationCodeFix { get; }
    public static string DestructorDocumentationCodeFix { get; }
    public static string DestructorStandardTextFirstPart { get; }
    public static string DestructorStandardTextSecondPart { get; }
    public static string InheritdocCodeFix { get; }
    public static string MethodDocumentationCodeFix { get; }
    public static string NonPrivateConstructorStandardTextFirstPart { get; }
    public static string NonPrivateConstructorStandardTextSecondPart { get; }
    public static string ParameterNotUsed { get; }
    public static string PrivateConstructorStandardTextFirstPart { get; }
    public static string PrivateConstructorStandardTextSecondPart { get; }
    public static string PropertySummaryStartTextCodeFix { get; }
    public static string SA1600Description { get; }
    public static string SA1600MessageFormat { get; }
    public static string SA1600Title { get; }
    public static string SA1601Description { get; }
    public static string SA1601MessageFormat { get; }
    public static string SA1601Title { get; }
    public static string SA1602Description { get; }
    public static string SA1602MessageFormat { get; }
    public static string SA1602Title { get; }
    public static string SA1603Description { get; }
    public static string SA1603MessageFormat { get; }
    public static string SA1603Title { get; }
    public static string SA1604Description { get; }
    public static string SA1604MessageFormat { get; }
    public static string SA1604Title { get; }
    public static string SA1605Description { get; }
    public static string SA1605MessageFormat { get; }
    public static string SA1605Title { get; }
    public static string SA1606Description { get; }
    public static string SA1606MessageFormat { get; }
    public static string SA1606Title { get; }
    public static string SA1607Description { get; }
    public static string SA1607MessageFormat { get; }
    public static string SA1607Title { get; }
    public static string SA1608Description { get; }
    public static string SA1608MessageFormat { get; }
    public static string SA1608Title { get; }
    public static string SA1609Description { get; }
    public static string SA1609MessageFormat { get; }
    public static string SA1609SA1610CodeFix { get; }
    public static string SA1609Title { get; }
    public static string SA1610Description { get; }
    public static string SA1610MessageFormat { get; }
    public static string SA1610Title { get; }
    public static string SA1611Description { get; }
    public static string SA1611MessageFormat { get; }
    public static string SA1611Title { get; }
    public static string SA1612Description { get; }
    public static string SA1612MissingParamForDocumentationMessageFormat { get; }
    public static string SA1612ParamWrongOrderMessageFormat { get; }
    public static string SA1612Title { get; }
    public static string SA1613Description { get; }
    public static string SA1613MessageFormat { get; }
    public static string SA1613Title { get; }
    public static string SA1614Description { get; }
    public static string SA1614MessageFormat { get; }
    public static string SA1614Title { get; }
    public static string SA1615Description { get; }
    public static string SA1615MessageFormat { get; }
    public static string SA1615SA1616CodeFix { get; }
    public static string SA1615Title { get; }
    public static string SA1616Description { get; }
    public static string SA1616MessageFormat { get; }
    public static string SA1616Title { get; }
    public static string SA1617CodeFix { get; }
    public static string SA1617Description { get; }
    public static string SA1617MessageFormat { get; }
    public static string SA1617Title { get; }
    public static string SA1618Description { get; }
    public static string SA1618MessageFormat { get; }
    public static string SA1618Title { get; }
    public static string SA1619Description { get; }
    public static string SA1619MessageFormat { get; }
    public static string SA1619Title { get; }
    public static string SA1620Description { get; }
    public static string SA1620MissingMessageFormat { get; }
    public static string SA1620Title { get; }
    public static string SA1620WrongOrderMessageFormat { get; }
    public static string SA1621Description { get; }
    public static string SA1621MessageFormat { get; }
    public static string SA1621Title { get; }
    public static string SA1622Description { get; }
    public static string SA1622MessageFormat { get; }
    public static string SA1622Title { get; }
    public static string SA1623Description { get; }
    public static string SA1623MessageFormat { get; }
    public static string SA1623Title { get; }
    public static string SA1624Description { get; }
    public static string SA1624MessageFormat { get; }
    public static string SA1624Title { get; }
    public static string SA1625Description { get; }
    public static string SA1625MessageFormat { get; }
    public static string SA1625Title { get; }
    public static string SA1626CodeFix { get; }
    public static string SA1626Description { get; }
    public static string SA1626MessageFormat { get; }
    public static string SA1626Title { get; }
    public static string SA1627Description { get; }
    public static string SA1627MessageFormat { get; }
    public static string SA1627Title { get; }
    public static string SA1628Description { get; }
    public static string SA1628MessageFormat { get; }
    public static string SA1628Title { get; }
    public static string SA1629CodeFix { get; }
    public static string SA1629Description { get; }
    public static string SA1629MessageFormat { get; }
    public static string SA1629Title { get; }
    public static string SA1630Description { get; }
    public static string SA1630MessageFormat { get; }
    public static string SA1630Title { get; }
    public static string SA1631Description { get; }
    public static string SA1631MessageFormat { get; }
    public static string SA1631Title { get; }
    public static string SA1632Description { get; }
    public static string SA1632MessageFormat { get; }
    public static string SA1632Title { get; }
    public static string SA1633CodeFix { get; }
    public static string SA1633Description { get; }
    public static string SA1633MessageFormatMalformed { get; }
    public static string SA1633MessageFormatMissing { get; }
    public static string SA1633Title { get; }
    public static string SA1634Description { get; }
    public static string SA1634MessageFormat { get; }
    public static string SA1634Title { get; }
    public static string SA1635Description { get; }
    public static string SA1635MessageFormat { get; }
    public static string SA1635Title { get; }
    public static string SA1636Description { get; }
    public static string SA1636MessageFormat { get; }
    public static string SA1636Title { get; }
    public static string SA1637Description { get; }
    public static string SA1637MessageFormat { get; }
    public static string SA1637Title { get; }
    public static string SA1638Description { get; }
    public static string SA1638MessageFormat { get; }
    public static string SA1638Title { get; }
    public static string SA1639Description { get; }
    public static string SA1639MessageFormat { get; }
    public static string SA1639Title { get; }
    public static string SA1640Description { get; }
    public static string SA1640MessageFormat { get; }
    public static string SA1640Title { get; }
    public static string SA1641Description { get; }
    public static string SA1641MessageFormat { get; }
    public static string SA1641Title { get; }
    public static string SA1642Description { get; }
    public static string SA1642MessageFormat { get; }
    public static string SA1642SA1643CodeFix { get; }
    public static string SA1642Title { get; }
    public static string SA1643Description { get; }
    public static string SA1643MessageFormat { get; }
    public static string SA1643Title { get; }
    public static string SA1644Description { get; }
    public static string SA1644MessageFormat { get; }
    public static string SA1644Title { get; }
    public static string SA1645Description { get; }
    public static string SA1645MessageFormat { get; }
    public static string SA1645Title { get; }
    public static string SA1646Description { get; }
    public static string SA1646MessageFormat { get; }
    public static string SA1646Title { get; }
    public static string SA1647Description { get; }
    public static string SA1647MessageFormat { get; }
    public static string SA1647Title { get; }
    public static string SA1648Description { get; }
    public static string SA1648MessageFormat { get; }
    public static string SA1648Title { get; }
    public static string SA1649CodeFix { get; }
    public static string SA1649Description { get; }
    public static string SA1649MessageFormat { get; }
    public static string SA1649Title { get; }
    public static string SA1650Description { get; }
    public static string SA1650MessageFormat { get; }
    public static string SA1650Title { get; }
    public static string SA1651CodeFix { get; }
    public static string SA1651Description { get; }
    public static string SA1651MessageFormat { get; }
    public static string SA1651Title { get; }
    public static string StartingTextGets { get; }
    public static string StartingTextGetsOrSets { get; }
    public static string StartingTextGetsOrSetsWhether { get; }
    public static string StartingTextGetsWhether { get; }
    public static string StartingTextReturns { get; }
    public static string StartingTextReturnsWhether { get; }
    public static string StartingTextSets { get; }
    public static string StartingTextSetsWhether { get; }
    public static string StaticConstructorStandardTextFirstPart { get; }
    public static string StaticConstructorStandardTextSecondPart { get; }
    public static string TaskReturnElementFirstPart { get; }
    public static string TaskReturnElementSecondPart { get; }
    public static string TypeTextClass { get; }
    public static string TypeTextStruct { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_ConstructorDocumentationCodeFix();
    public static string get_DestructorDocumentationCodeFix();
    public static string get_DestructorStandardTextFirstPart();
    public static string get_DestructorStandardTextSecondPart();
    public static string get_InheritdocCodeFix();
    public static string get_MethodDocumentationCodeFix();
    public static string get_NonPrivateConstructorStandardTextFirstPart();
    public static string get_NonPrivateConstructorStandardTextSecondPart();
    public static string get_ParameterNotUsed();
    public static string get_PrivateConstructorStandardTextFirstPart();
    public static string get_PrivateConstructorStandardTextSecondPart();
    public static string get_PropertySummaryStartTextCodeFix();
    public static string get_SA1600Description();
    public static string get_SA1600MessageFormat();
    public static string get_SA1600Title();
    public static string get_SA1601Description();
    public static string get_SA1601MessageFormat();
    public static string get_SA1601Title();
    public static string get_SA1602Description();
    public static string get_SA1602MessageFormat();
    public static string get_SA1602Title();
    public static string get_SA1603Description();
    public static string get_SA1603MessageFormat();
    public static string get_SA1603Title();
    public static string get_SA1604Description();
    public static string get_SA1604MessageFormat();
    public static string get_SA1604Title();
    public static string get_SA1605Description();
    public static string get_SA1605MessageFormat();
    public static string get_SA1605Title();
    public static string get_SA1606Description();
    public static string get_SA1606MessageFormat();
    public static string get_SA1606Title();
    public static string get_SA1607Description();
    public static string get_SA1607MessageFormat();
    public static string get_SA1607Title();
    public static string get_SA1608Description();
    public static string get_SA1608MessageFormat();
    public static string get_SA1608Title();
    public static string get_SA1609Description();
    public static string get_SA1609MessageFormat();
    public static string get_SA1609SA1610CodeFix();
    public static string get_SA1609Title();
    public static string get_SA1610Description();
    public static string get_SA1610MessageFormat();
    public static string get_SA1610Title();
    public static string get_SA1611Description();
    public static string get_SA1611MessageFormat();
    public static string get_SA1611Title();
    public static string get_SA1612Description();
    public static string get_SA1612MissingParamForDocumentationMessageFormat();
    public static string get_SA1612ParamWrongOrderMessageFormat();
    public static string get_SA1612Title();
    public static string get_SA1613Description();
    public static string get_SA1613MessageFormat();
    public static string get_SA1613Title();
    public static string get_SA1614Description();
    public static string get_SA1614MessageFormat();
    public static string get_SA1614Title();
    public static string get_SA1615Description();
    public static string get_SA1615MessageFormat();
    public static string get_SA1615SA1616CodeFix();
    public static string get_SA1615Title();
    public static string get_SA1616Description();
    public static string get_SA1616MessageFormat();
    public static string get_SA1616Title();
    public static string get_SA1617CodeFix();
    public static string get_SA1617Description();
    public static string get_SA1617MessageFormat();
    public static string get_SA1617Title();
    public static string get_SA1618Description();
    public static string get_SA1618MessageFormat();
    public static string get_SA1618Title();
    public static string get_SA1619Description();
    public static string get_SA1619MessageFormat();
    public static string get_SA1619Title();
    public static string get_SA1620Description();
    public static string get_SA1620MissingMessageFormat();
    public static string get_SA1620Title();
    public static string get_SA1620WrongOrderMessageFormat();
    public static string get_SA1621Description();
    public static string get_SA1621MessageFormat();
    public static string get_SA1621Title();
    public static string get_SA1622Description();
    public static string get_SA1622MessageFormat();
    public static string get_SA1622Title();
    public static string get_SA1623Description();
    public static string get_SA1623MessageFormat();
    public static string get_SA1623Title();
    public static string get_SA1624Description();
    public static string get_SA1624MessageFormat();
    public static string get_SA1624Title();
    public static string get_SA1625Description();
    public static string get_SA1625MessageFormat();
    public static string get_SA1625Title();
    public static string get_SA1626CodeFix();
    public static string get_SA1626Description();
    public static string get_SA1626MessageFormat();
    public static string get_SA1626Title();
    public static string get_SA1627Description();
    public static string get_SA1627MessageFormat();
    public static string get_SA1627Title();
    public static string get_SA1628Description();
    public static string get_SA1628MessageFormat();
    public static string get_SA1628Title();
    public static string get_SA1629CodeFix();
    public static string get_SA1629Description();
    public static string get_SA1629MessageFormat();
    public static string get_SA1629Title();
    public static string get_SA1630Description();
    public static string get_SA1630MessageFormat();
    public static string get_SA1630Title();
    public static string get_SA1631Description();
    public static string get_SA1631MessageFormat();
    public static string get_SA1631Title();
    public static string get_SA1632Description();
    public static string get_SA1632MessageFormat();
    public static string get_SA1632Title();
    public static string get_SA1633CodeFix();
    public static string get_SA1633Description();
    public static string get_SA1633MessageFormatMalformed();
    public static string get_SA1633MessageFormatMissing();
    public static string get_SA1633Title();
    public static string get_SA1634Description();
    public static string get_SA1634MessageFormat();
    public static string get_SA1634Title();
    public static string get_SA1635Description();
    public static string get_SA1635MessageFormat();
    public static string get_SA1635Title();
    public static string get_SA1636Description();
    public static string get_SA1636MessageFormat();
    public static string get_SA1636Title();
    public static string get_SA1637Description();
    public static string get_SA1637MessageFormat();
    public static string get_SA1637Title();
    public static string get_SA1638Description();
    public static string get_SA1638MessageFormat();
    public static string get_SA1638Title();
    public static string get_SA1639Description();
    public static string get_SA1639MessageFormat();
    public static string get_SA1639Title();
    public static string get_SA1640Description();
    public static string get_SA1640MessageFormat();
    public static string get_SA1640Title();
    public static string get_SA1641Description();
    public static string get_SA1641MessageFormat();
    public static string get_SA1641Title();
    public static string get_SA1642Description();
    public static string get_SA1642MessageFormat();
    public static string get_SA1642SA1643CodeFix();
    public static string get_SA1642Title();
    public static string get_SA1643Description();
    public static string get_SA1643MessageFormat();
    public static string get_SA1643Title();
    public static string get_SA1644Description();
    public static string get_SA1644MessageFormat();
    public static string get_SA1644Title();
    public static string get_SA1645Description();
    public static string get_SA1645MessageFormat();
    public static string get_SA1645Title();
    public static string get_SA1646Description();
    public static string get_SA1646MessageFormat();
    public static string get_SA1646Title();
    public static string get_SA1647Description();
    public static string get_SA1647MessageFormat();
    public static string get_SA1647Title();
    public static string get_SA1648Description();
    public static string get_SA1648MessageFormat();
    public static string get_SA1648Title();
    public static string get_SA1649CodeFix();
    public static string get_SA1649Description();
    public static string get_SA1649MessageFormat();
    public static string get_SA1649Title();
    public static string get_SA1650Description();
    public static string get_SA1650MessageFormat();
    public static string get_SA1650Title();
    public static string get_SA1651CodeFix();
    public static string get_SA1651Description();
    public static string get_SA1651MessageFormat();
    public static string get_SA1651Title();
    public static string get_StartingTextGets();
    public static string get_StartingTextGetsOrSets();
    public static string get_StartingTextGetsOrSetsWhether();
    public static string get_StartingTextGetsWhether();
    public static string get_StartingTextReturns();
    public static string get_StartingTextReturnsWhether();
    public static string get_StartingTextSets();
    public static string get_StartingTextSetsWhether();
    public static string get_StaticConstructorStandardTextFirstPart();
    public static string get_StaticConstructorStandardTextSecondPart();
    public static string get_TaskReturnElementFirstPart();
    public static string get_TaskReturnElementSecondPart();
    public static string get_TypeTextClass();
    public static string get_TypeTextStruct();
}
internal abstract class StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase : DiagnosticAnalyzer {
    private string matchElementName;
    private bool inheritDocSuppressesWarnings;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> constructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> delegateDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> indexerDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> operatorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> conversionOperatorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> baseTypeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> fieldDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> enumMemberDeclarationAction;
    protected ElementDocumentationBase(bool inheritDocSuppressesWarnings, string matchElementName);
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected abstract virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleOperatorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConversionOperatorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleFieldDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleEnumMemberDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, SyntaxNode node, Location[] locations);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(CompilationStartAnalysisContext context);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.ElementDocumentationSummaryBase : DiagnosticAnalyzer {
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> typeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> constructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> destructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> indexerDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> fieldDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> delegateDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> eventDeclarationAction;
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
    private void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDestructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleFieldDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleEventDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, Location[] locations);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers : DiagnosticAnalyzer {
    private static string SA1633Identifier;
    private static string SA1634Identifier;
    private static string SA1635Identifier;
    private static string SA1636Identifier;
    private static string SA1637Identifier;
    private static string SA1638Identifier;
    private static string SA1639Identifier;
    private static string SA1640Identifier;
    private static string SA1641Identifier;
    private static LocalizableString SA1633Title;
    private static LocalizableString SA1633MessageFormatMissing;
    private static LocalizableString SA1633MessageFormatMalformed;
    private static LocalizableString SA1633Description;
    private static string SA1633HelpLink;
    private static LocalizableString SA1634Title;
    private static LocalizableString SA1634MessageFormat;
    private static LocalizableString SA1634Description;
    private static string SA1634HelpLink;
    private static LocalizableString SA1635Title;
    private static LocalizableString SA1635MessageFormat;
    private static LocalizableString SA1635Description;
    private static string SA1635HelpLink;
    private static LocalizableString SA1636Title;
    private static LocalizableString SA1636MessageFormat;
    private static LocalizableString SA1636Description;
    private static string SA1636HelpLink;
    private static LocalizableString SA1637Title;
    private static LocalizableString SA1637MessageFormat;
    private static LocalizableString SA1637Description;
    private static string SA1637HelpLink;
    private static LocalizableString SA1638Title;
    private static LocalizableString SA1638MessageFormat;
    private static LocalizableString SA1638Description;
    private static string SA1638HelpLink;
    private static LocalizableString SA1639Title;
    private static LocalizableString SA1639MessageFormat;
    private static LocalizableString SA1639Description;
    private static string SA1639HelpLink;
    private static LocalizableString SA1640Title;
    private static LocalizableString SA1640MessageFormat;
    private static LocalizableString SA1640Description;
    private static string SA1640HelpLink;
    private static LocalizableString SA1641Title;
    private static LocalizableString SA1641MessageFormat;
    private static LocalizableString SA1641Description;
    private static string SA1641HelpLink;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1633DescriptorMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1633DescriptorMalformed>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1634Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1635Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1636Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1637Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1638Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1639Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1640Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1641Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1633DescriptorMissing { get; }
    public static DiagnosticDescriptor SA1633DescriptorMalformed { get; }
    public static DiagnosticDescriptor SA1634Descriptor { get; }
    public static DiagnosticDescriptor SA1635Descriptor { get; }
    public static DiagnosticDescriptor SA1636Descriptor { get; }
    public static DiagnosticDescriptor SA1637Descriptor { get; }
    public static DiagnosticDescriptor SA1638Descriptor { get; }
    public static DiagnosticDescriptor SA1639Descriptor { get; }
    public static DiagnosticDescriptor SA1640Descriptor { get; }
    public static DiagnosticDescriptor SA1641Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FileHeaderAnalyzers();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1633DescriptorMissing();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1633DescriptorMalformed();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1634Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1635Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1636Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1637Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1638Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1639Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1640Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1641Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.GenericTypeParameterDocumentationAnalyzer : DiagnosticAnalyzer {
    private static string SA1620DiagnosticId;
    private static LocalizableString SA1620Title;
    private static LocalizableString SA1620MissingMessageFormat;
    private static LocalizableString SA1620WrongOrderMessageFormat;
    private static LocalizableString SA1620Description;
    private static string SA1620HelpLink;
    private static string SA1621DiagnosticId;
    private static LocalizableString SA1621Title;
    private static LocalizableString SA1621MessageFormat;
    private static LocalizableString SA1621Description;
    private static string SA1621HelpLink;
    private static string SA1622DiagnosticId;
    private static LocalizableString SA1622Title;
    private static LocalizableString SA1622MessageFormat;
    private static LocalizableString SA1622Description;
    private static string SA1622HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1620MissingTypeParameterDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1620WrongOrderDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1621Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1622Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1620MissingTypeParameterDescriptor { get; }
    public static DiagnosticDescriptor SA1620WrongOrderDescriptor { get; }
    public static DiagnosticDescriptor SA1621Descriptor { get; }
    public static DiagnosticDescriptor SA1622Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParameterDocumentationAnalyzer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1620MissingTypeParameterDescriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1620WrongOrderDescriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1621Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1622Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context, SyntaxNode node, TypeParameterListSyntax typeParameterList);
    private static void HandleTypeParamElement(SyntaxNodeAnalysisContext context, string documentedParameterName, int index, TypeParameterListSyntax typeParameterList, Location locationToReport);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.PartialElementDocumentationSummaryBase : DiagnosticAnalyzer {
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> typeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool IsPartialMethodDefinition(SyntaxNode node);
    private void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, Location[] locations);
    private string ExpandDocumentation(Compilation compilation, DocumentationCommentTriviaSyntax documentCommentTrivia, XmlNodeSyntax includeTag);
    private void ExpandIncludeTag(Compilation compilation, StringBuilder sb, XmlNodeSyntax xmlNode);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_0(CompilationStartAnalysisContext context);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase : DiagnosticAnalyzer {
    internal static string NoCodeFixKey;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    protected string XmlTagToHandle { get; }
    protected abstract virtual string get_XmlTagToHandle();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, SyntaxNode node, Location location);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer : PropertyDocumentationBase {
    public static string ExpectedTextKey;
    public static string TextToRemoveKey;
    private static string SA1623DiagnosticId;
    private static string SA1624DiagnosticId;
    private static LocalizableString SA1623Title;
    private static LocalizableString SA1623MessageFormat;
    private static LocalizableString SA1623Description;
    private static string SA1623HelpLink;
    private static LocalizableString SA1624Title;
    private static LocalizableString SA1624MessageFormat;
    private static LocalizableString SA1624Description;
    private static string SA1624HelpLink;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1623Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1624Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1623Descriptor { get; }
    public static DiagnosticDescriptor SA1624Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static PropertySummaryDocumentationAnalyzer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1623Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1624Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
    private static void AnalyzeSummaryElement(SyntaxNodeAnalysisContext context, XmlNodeSyntax syntax, Location diagnosticLocation, PropertyDeclarationSyntax propertyDeclaration, string startingTextGets, string startingTextSets, string startingTextGetsOrSets, string startingTextReturns);
    private static void ReportSA1623(SyntaxNodeAnalysisContext context, Location diagnosticLocation, Builder<string, string> diagnosticProperties, string text, string expectedStartingText, string unexpectedStartingText1, string unexpectedStartingText2, string unexpectedStartingText3);
    private static void ReportSA1624(SyntaxNodeAnalysisContext context, Location diagnosticLocation, Builder<string, string> diagnosticProperties, string accessor, string expectedStartingText, string startingTextToRemove);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseTypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ConstructorDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DestructorDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> PropertyDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> IndexerDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> FieldDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EventDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EventFieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1600ElementsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public static bool NeedsComment(DocumentationSettings documentationSettings, SyntaxKind syntaxKind, SyntaxKind parentSyntaxKind, Accessibility declaredAccessibility, Accessibility effectiveAccessibility);
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseTypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseTypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1601PartialElementsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EnumMemberDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1602EnumerationItemsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1570.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1603DocumentationMustContainValidXml();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary : ElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1604ElementDocumentationMustHaveSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary : PartialElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1605PartialElementDocumentationMustHaveSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText : ElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1606ElementDocumentationMustHaveSummaryText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText : PartialElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1607PartialElementDocumentationMustHaveSummaryText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static string DefaultText;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1608ElementDocumentationMustNotHaveDefaultSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool IsDefaultText(string text);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue : PropertyDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static SA1609PropertyDocumentationMustHaveValue();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText : PropertyDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static SA1610PropertyDocumentationMustHaveValueText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1611ElementParametersMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static IEnumerable`1<ParameterSyntax> GetParameters(SyntaxNode node);
    private static void ReportMissingParameters(SyntaxNodeAnalysisContext context, IEnumerable`1<ParameterSyntax> parameterList, IEnumerable`1<string> documentationParameterNames);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MissingParamForDocumentationMessageFormat;
    private static LocalizableString ParamWrongOrderMessageFormat;
    private static DiagnosticDescriptor MissingParameterDescriptor;
    private static DiagnosticDescriptor OrderDescriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1612ElementParameterDocumentationMustMatchElementParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static IEnumerable`1<ParameterSyntax> GetParameters(SyntaxNode node);
    private static Nullable`1<SyntaxToken> GetIdentifier(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1613ElementParameterDocumentationMustDeclareParameterName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1614ElementParameterDocumentationMustHaveText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1615ElementReturnValueMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, TypeSyntax returnType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1616ElementReturnValueDocumentationMustHaveText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1617VoidReturnValueMustNotBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMember(SyntaxNodeAnalysisContext context, TypeSyntax returnValue);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1618GenericTypeParametersMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, TypeParameterListSyntax typeParameterList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1619GenericTypeParametersMustBeDocumentedPartialClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1625ElementDocumentationMustNotBeCopiedAndPasted();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool ShouldSkipElement(string element, string parameterNotUsed);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> SingleLineDocumentationTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSingleLineDocumentationTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> XmlElementAction;
    private static Action`1<SyntaxNodeAnalysisContext> XmlEmptyElementAction;
    private static ImmutableArray`1<string> ElementsToCheck;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1627DocumentationTextMustNotBeEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleXmlElement(SyntaxNodeAnalysisContext context);
    private static void HandleXmlEmptyElement(SyntaxNodeAnalysisContext context);
    private static void HandleIncludedDocumentation(SyntaxNodeAnalysisContext context, XmlEmptyElementSyntax elementSyntax, Location elementLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic has an unacceptable rate of false positives.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1628DocumentationTextMustBeginWithACapitalLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod : ElementDocumentationBase {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    internal static string ReplaceCharKey;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1629DocumentationTextMustEndWithAPeriod();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static void HandleSectionOrBlockXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, XmlElementSyntax xmlElement, bool startingWithFinalParagraph);
    private static bool IsMissingRequiredPeriod(string textWithoutTrailingWhitespace, bool startingWithFinalParagraph);
    [CompilerGeneratedAttribute]
internal static void <HandleSectionOrBlockXmlElement>g__SetReplaceChar|15_0(<>c__DisplayClass15_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1630DocumentationTextMustContainWhitespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1631DocumentationMustMeetCharacterPercentage();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1632DocumentationTextMustMeetMinimumCharacterLength();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText : StandardTextDiagnosticBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1642ConstructorSummaryDocumentationMustBeginWithStandardText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText : StandardTextDiagnosticBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DestructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1643DestructorSummaryDocumentationMustBeginWithStandardText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDestructor(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1644DocumentationHeadersMustNotContainBlankLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1589.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1645IncludedDocumentationFileDoesNotExist();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1589.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1646IncludedDocumentationXPathDoesNotExist();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1590.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1647IncludeNodeDoesNotContainValidFileAndPath();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> HandledTypeLikeDeclarationKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> MemberDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeLikeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MemberDeclarationAction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1648InheritDocMustBeUsedWithInheritingClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeLikeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMemberDeclaration(SyntaxNodeAnalysisContext context);
    private static bool HasMatchingSignature(ImmutableArray`1<IMethodSymbol> baseConstructorSymbols, IMethodSymbol constructorMethodSymbol);
    private static bool HasXmlCrefAttribute(XmlNodeSyntax inheritDocElement);
    private static bool HasXmlCrefAttribute(XElement inheritDocElement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string ExpectedFileNameKey;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1649FileNameMustMatchTypeName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic has an unacceptable rate of false positives.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1650ElementDocumentationMustBeSpelledCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> XmlElementAction;
    private static Action`1<SyntaxNodeAnalysisContext> XmlEmptyElementAction;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1651DoNotUsePlaceholderElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleXmlElement(SyntaxNodeAnalysisContext context);
    private static void HandleXmlEmptyElement(SyntaxNodeAnalysisContext context);
    private static void CheckTag(SyntaxNodeAnalysisContext context, string tagName);
    private static bool IncludedDocumentationContainsPlaceHolderTags(SyntaxNodeAnalysisContext context);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase : DiagnosticAnalyzer {
    internal static string NoCodeFixKey;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    private static StandardTextDiagnosticBase();
    protected static MatchResult HandleDeclaration(SyntaxNodeAnalysisContext context, string firstTextPart, string secondTextPart, DiagnosticDescriptor diagnosticDescriptor);
    private static bool SeeTagIsCorrect(SyntaxNodeAnalysisContext context, XmlEmptyElementSyntax classReferencePart, BaseMethodDeclarationSyntax constructorDeclarationSyntax);
    private static bool SeeTagIsCorrect(SyntaxNodeAnalysisContext context, XElement classReferencePart, BaseMethodDeclarationSyntax constructorDeclarationSyntax);
    private static bool TextPartsMatch(string firstText, string secondText, XmlTextSyntax firstTextPart, XmlTextSyntax secondTextPart);
    private static bool TextPartsMatch(string firstText, string secondText, XText firstTextPart, XText secondTextPart);
}
internal enum StyleCop.Analyzers.Helpers.AccessLevel : Enum {
    public int value__;
    public static AccessLevel NotSpecified;
    public static AccessLevel Private;
    public static AccessLevel PrivateProtected;
    public static AccessLevel Protected;
    public static AccessLevel ProtectedInternal;
    public static AccessLevel Internal;
    public static AccessLevel Public;
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.AccessLevelHelper : object {
    private static Dictionary`2<AccessLevel, string> AccessLevelNames;
    private static AccessLevelHelper();
    internal static AccessLevel GetAccessLevel(SyntaxTokenList modifiers);
    internal static string GetName(AccessLevel accessLevel);
    [ExtensionAttribute]
internal static Accessibility ToAccessibility(AccessLevel accessLevel);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseTypeDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseMethodDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BasePropertyDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(AccessorDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseFieldDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(EnumMemberDeclarationSyntax syntax);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(DelegateDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseTypeDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseMethodDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BasePropertyDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(AccessorDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseFieldDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(EnumMemberDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(DelegateDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static Accessibility CombineEffectiveAccessibility(Accessibility declaredAccessibility, Accessibility enclosingAccessibility);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DeclarationModifiersHelper : object {
    internal static SyntaxTokenList AddModifier(SyntaxTokenList modifiers, T& leadingTriviaNode, SyntaxKind modifierKeyword);
    internal static SyntaxTokenList AddModifier(SyntaxTokenList modifiers, SyntaxToken& leadingTriviaToken, SyntaxKind modifierKeyword);
    internal static SyntaxTokenList AddModifiers(SyntaxTokenList modifiers, SyntaxToken& leadingTriviaToken, IEnumerable`1<SyntaxKind> modifierKeywords);
    [ExtensionAttribute]
internal static SyntaxTokenList GetModifiers(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
internal static SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper : object {
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(CompilationStartAnalysisContext context, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(Compilation compilation, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(CompilationOptions compilationOptions, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static DocumentationMode GetDocumentationMode(SyntaxNodeAnalysisContext context);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DocumentationCommentExtensions : object {
    [ExtensionAttribute]
public static DocumentationCommentTriviaSyntax GetDocumentationCommentTriviaSyntax(SyntaxNode node);
    [ExtensionAttribute]
public static XmlNodeSyntax GetFirstXmlElement(SyntaxList`1<XmlNodeSyntax> content, string elementName);
    [IteratorStateMachineAttribute("StyleCop.Analyzers.Helpers.DocumentationCommentExtensions/<GetXmlElements>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<XmlNodeSyntax> GetXmlElements(SyntaxList`1<XmlNodeSyntax> content, string elementName);
    [ExtensionAttribute]
public static T ReplaceExteriorTrivia(T node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxList`1<XmlNodeSyntax> WithoutFirstAndLastNewlines(SyntaxList`1<XmlNodeSyntax> summaryContent);
    [ExtensionAttribute]
public static bool IsXmlNewLine(SyntaxToken node);
    [ExtensionAttribute]
public static bool IsXmlWhitespace(SyntaxToken node);
    [ExtensionAttribute]
public static T AdjustDocumentationCommentNewLineTrivia(T node);
    [ExtensionAttribute]
public static XmlNameSyntax GetName(XmlNodeSyntax element);
    private static SyntaxTrivia SelectExteriorTrivia(SyntaxTrivia rewrittenTrivia, SyntaxTrivia trivia, SyntaxTrivia triviaWithSpace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.ExpressionSyntaxHelpers : object {
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Helpers.FileHeader : object {
    private int fileHeaderStart;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyrightText>k__BackingField;
    internal static FileHeader MissingFileHeader { get; }
    internal bool IsMissing { get; private set; }
    internal string CopyrightText { get; }
    internal FileHeader(string copyrightText, int fileHeaderStart, int fileHeaderEnd);
    internal static FileHeader get_MissingFileHeader();
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
private void set_IsMissing(bool value);
    [CompilerGeneratedAttribute]
internal string get_CopyrightText();
    internal Location GetLocation(SyntaxTree syntaxTree);
}
internal static class StyleCop.Analyzers.Helpers.FileHeaderHelpers : object {
    internal static FileHeader ParseFileHeader(SyntaxNode root);
    internal static XmlFileHeader ParseXmlFileHeader(SyntaxNode root);
    private static string ProcessSingleLineCommentsHeader(SyntaxTriviaList triviaList, int startIndex, Int32& fileHeaderStart, Int32& fileHeaderEnd);
    private static string ProcessMultiLineCommentsHeader(SyntaxTrivia multiLineComment, Int32& fileHeaderStart, Int32& fileHeaderEnd);
}
internal static class StyleCop.Analyzers.Helpers.FileNameHelpers : object {
    internal static string GetFileNameAndSuffix(string path, String& suffix);
    internal static string GetConventionalFileName(MemberDeclarationSyntax declaration, FileNamingConvention convention);
    internal static string GetSimpleFileName(MemberDeclarationSyntax memberDeclaration);
    private static string GetMetadataFileName(TypeDeclarationSyntax typeDeclaration);
    private static string GetMetadataFileName(DelegateDeclarationSyntax delegateDeclaration);
    private static string GetStyleCopFileName(TypeDeclarationSyntax typeDeclaration);
    private static string GetStyleCopFileName(DelegateDeclarationSyntax delegateDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.Helpers.HelpersResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string FixAllOccurrencesOfDiagnostic { get; }
    public static string FixAllOccurrencesOfDiagnosticInScope { get; }
    public static string FixAllOccurrencesOfDiagnosticInSolution { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_FixAllOccurrencesOfDiagnostic();
    public static string get_FixAllOccurrencesOfDiagnosticInScope();
    public static string get_FixAllOccurrencesOfDiagnosticInSolution();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.KeyValuePairExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.LanguageFeatureHelpers : object {
    [ExtensionAttribute]
internal static bool SupportsTuples(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
internal static bool SupportsTuples(OperationAnalysisContext context);
    [ExtensionAttribute]
internal static bool SupportsInferredTupleElementNames(SyntaxNodeAnalysisContext context);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.LiteralExpressionHelpers : object {
    [ExtensionAttribute]
internal static string StripLiteralSuffix(LiteralExpressionSyntax literalExpressionSyntax);
    [ExtensionAttribute]
internal static LiteralExpressionSyntax WithLiteralSuffix(LiteralExpressionSyntax literalExpression, SyntaxKind syntaxKindKeyword);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.LocationHelpers : object {
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxToken token);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxNode node);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
internal static int GetLine(SyntaxToken token);
    [ExtensionAttribute]
internal static int GetLine(SyntaxNode node);
    [ExtensionAttribute]
internal static int GetLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxToken token);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxNode node);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool SpansMultipleLines(SyntaxNode node);
    [ExtensionAttribute]
internal static bool SpansMultipleLines(SyntaxTrivia trivia);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Helpers.MemberOrderHelper : ValueType {
    private static ImmutableArray`1<SyntaxKind> TypeMemberOrder;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private MemberDeclarationSyntax <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [NullableAttribute("1")]
internal MemberDeclarationSyntax Member { get; }
    internal int Priority { get; }
    internal MemberOrderHelper(MemberDeclarationSyntax member, ImmutableArray`1<OrderingTrait> elementOrder);
    private static MemberOrderHelper();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal MemberDeclarationSyntax get_Member();
    [CompilerGeneratedAttribute]
internal int get_Priority();
    [NullableContextAttribute("1")]
internal static AccessLevel GetAccessLevelForOrdering(SyntaxNode member, SyntaxTokenList modifiers);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.NamedTypeHelpers : object {
    internal static bool IsNativeMethodsClass(INamedTypeSymbol type);
    internal static bool IsNativeMethodsClass(ClassDeclarationSyntax syntax);
    internal static bool IsContainedInNativeMethodsClass(INamedTypeSymbol type);
    internal static bool IsContainedInNativeMethodsClass(SyntaxNode syntax);
    internal static string GetNameOrIdentifier(MemberDeclarationSyntax member);
    internal static Location GetNameOrIdentifierLocation(SyntaxNode member);
    internal static bool IsPartialDeclaration(MemberDeclarationSyntax declaration);
    internal static bool IsImplementingAnInterfaceMember(ISymbol memberSymbol);
    [ExtensionAttribute]
internal static INamedTypeSymbol TupleUnderlyingTypeOrSelf(INamedTypeSymbol tupleSymbol);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.NameSyntaxHelpers : object {
    private static string DotChar;
    [ExtensionAttribute]
internal static string ToNormalizedString(NameSyntax nameSyntax);
    [ExtensionAttribute]
internal static string ToUnaliasedString(NameSyntax nameSyntax);
    internal static int Compare(NameSyntax first, NameSyntax second);
    private static void BuildName(NameSyntax nameSyntax, StringBuilder builder, bool includeAlias);
}
internal class StyleCop.Analyzers.Helpers.ObjectPools.ObjectPool`1 : object {
    private Element[] items;
    private Func`1<T> factory;
    private T firstItem;
    internal ObjectPool`1(Func`1<T> factory);
    internal ObjectPool`1(Func`1<T> factory, int size);
    internal T Allocate();
    internal void Free(T obj);
    private T CreateInstance();
    private T AllocateSlow();
    private void FreeSlow(T obj);
}
internal class StyleCop.Analyzers.Helpers.ObjectPools.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> releaser;
    private ObjectPool`1<T> pool;
    private T pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    public sealed virtual void Dispose();
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.ObjectPools.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
internal static class StyleCop.Analyzers.Helpers.ObjectPools.SharedPools : object {
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
}
internal static class StyleCop.Analyzers.Helpers.ObjectPools.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
internal static class StyleCop.Analyzers.Helpers.Requires : object {
    public static void NotNull(T argument, string parameterName);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SpacingExtensions : object {
    [ExtensionAttribute]
public static bool IsMissingOrDefault(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithoutLeadingWhitespace(SyntaxToken token, bool removeEndOfLineTrivia);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutWhitespace(SyntaxTriviaList syntaxTriviaList, bool removeEndOfLineTrivia);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
}
internal static class StyleCop.Analyzers.Helpers.SpecializedTasks : object {
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    internal static Task CompletedTask { get; }
    private static SpecializedTasks();
    [CompilerGeneratedAttribute]
internal static Task get_CompletedTask();
}
internal static class StyleCop.Analyzers.Helpers.SpecialTypeHelper : object {
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> <PredefinedSpecialTypes>k__BackingField;
    private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> PredefinedSpecialTypes { get; }
    private static SpecialTypeHelper();
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> get_PredefinedSpecialTypes();
    public static bool IsPredefinedType(SpecialType specialType);
    public static bool TryGetPredefinedType(SpecialType specialType, PredefinedTypeSyntax& predefinedTypeSyntax);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SymbolNameHelpers : object {
    private static string GenericTypeParametersOpen;
    private static string GenericTypeParametersClose;
    private static string GenericSeparator;
    private static string TupleTypeOpen;
    private static string TupleTypeClose;
    private static string TupleElementSeparator;
    [ExtensionAttribute]
public static string ToQualifiedString(ISymbol symbol, NameSyntax name);
    [ExtensionAttribute]
public static string ToFullyQualifiedValueTupleDisplayString(INamedTypeSymbol tupleSymbol);
    private static bool AppendQualifiedSymbolName(StringBuilder builder, ISymbol symbol, TypeSyntax type);
    private static bool AppendNamedType(StringBuilder builder, INamedTypeSymbol namedTypeSymbol, TypeSyntax type);
    private static bool AppendTupleType(StringBuilder builder, INamedTypeSymbol namedTypeSymbol, TypeSyntax type);
    private static TypeSyntax GetElementSyntax(TypeSyntax typeSyntax);
    private static void AppendNullableSuffixIfNeeded(StringBuilder builder, TypeSyntax type);
}
internal static class StyleCop.Analyzers.Helpers.SyntaxKinds : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseNamespaceDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <TypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseFieldDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseMethodDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BasePropertyDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <AccessorDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <InitializerExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <DocumentationComment>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <ConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <LambdaExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <AnonymousFunctionExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <SimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseParameterList>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseArgumentList>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <IntegerLiteralKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <RealLiteralKeyword>k__BackingField;
    public static ImmutableArray`1<SyntaxKind> BaseNamespaceDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BaseTypeDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> TypeDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BaseFieldDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BaseMethodDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BasePropertyDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> AccessorDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> InitializerExpression { get; }
    public static ImmutableArray`1<SyntaxKind> DocumentationComment { get; }
    public static ImmutableArray`1<SyntaxKind> ConstructorInitializer { get; }
    public static ImmutableArray`1<SyntaxKind> LambdaExpression { get; }
    public static ImmutableArray`1<SyntaxKind> AnonymousFunctionExpression { get; }
    public static ImmutableArray`1<SyntaxKind> SimpleName { get; }
    public static ImmutableArray`1<SyntaxKind> BaseParameterList { get; }
    public static ImmutableArray`1<SyntaxKind> BaseArgumentList { get; }
    public static ImmutableArray`1<SyntaxKind> IntegerLiteralKeyword { get; }
    public static ImmutableArray`1<SyntaxKind> RealLiteralKeyword { get; }
    private static SyntaxKinds();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseNamespaceDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_TypeDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseFieldDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseMethodDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BasePropertyDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_AccessorDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_InitializerExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_DocumentationComment();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_ConstructorInitializer();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_LambdaExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_AnonymousFunctionExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_SimpleName();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseParameterList();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseArgumentList();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_IntegerLiteralKeyword();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_RealLiteralKeyword();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAnyLambda(SyntaxNode node);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__AnyTakesExpressionTree|0_0(SymbolInfo info, INamedTypeSymbol expressionType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__TakesExpressionTree|0_1(ISymbol symbol, INamedTypeSymbol expressionType);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SyntaxTreeHelpers : object {
    private static Tuple`2<WeakReference`1<Compilation>, ConcurrentDictionary`2<SyntaxTree, bool>> usingAliasCache;
    private static SyntaxTreeHelpers();
    [ExtensionAttribute]
public static ConcurrentDictionary`2<SyntaxTree, bool> GetOrCreateUsingAliasCache(Compilation compilation);
    [ExtensionAttribute]
public static bool IsWhitespaceOnly(SyntaxTree tree, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool ContainsUsingAlias(SyntaxTree tree, ConcurrentDictionary`2<SyntaxTree, bool> cache);
    private static bool ContainsUsingAliasNoCache(SyntaxTree tree);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TokenHelper : object {
    [ExtensionAttribute]
internal static bool IsFirstInLine(SyntaxToken token, bool allowNonWhitespaceTrivia);
    [ExtensionAttribute]
internal static bool IsInterpolatedUnaryExpression(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsLastInLine(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsPrecededByWhitespace(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsOnlyPrecededByWhitespaceInLine(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsFollowedByWhitespace(SyntaxToken token);
    [ExtensionAttribute]
internal static SyntaxTrivia GetPrecedingEndOfLineTrivia(SyntaxToken token);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TriviaHelper : object {
    internal static int IndexOfFirstNonWhitespaceTrivia(T triviaList, bool endOfLineIsWhitespace);
    internal static int IndexOfFirstNonBlankLineTrivia(T triviaList);
    internal static int IndexOfTrailingWhitespace(T triviaList, bool endOfLineIsWhitespace);
    [ExtensionAttribute]
internal static SyntaxTriviaList RemoveRange(SyntaxTriviaList list, int index, int count);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutDirectiveTrivia(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
internal static int LastIndexOf(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutTrailingWhitespace(SyntaxTriviaList triviaList, bool endOfLineIsWhitespace);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutLeadingWhitespace(SyntaxTriviaList triviaList, bool endOfLineIsWhitespace);
    internal static DualTriviaListHelper GetContainingTriviaList(SyntaxTrivia trivia, Int32& triviaIndex);
    internal static DualTriviaListHelper MergeTriviaLists(SyntaxTriviaList list1, SyntaxTriviaList list2);
    [ExtensionAttribute]
internal static bool IsPrecededByBlankLines(SyntaxToken token);
    [ExtensionAttribute]
internal static SyntaxToken WithoutLeadingBlankLines(SyntaxToken token);
    [ExtensionAttribute]
internal static bool HasBuiltinEndLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool ContainsBlankLines(IReadOnlyList`1<SyntaxTrivia> triviaList, bool startsOnNewLine);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutBlankLines(SyntaxTriviaList triviaList, bool startsOnNewLine);
    private static int BinarySearch(SyntaxTriviaList leadingTrivia, SyntaxTrivia trivia);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TypeSyntaxHelper : object {
    [ExtensionAttribute]
public static TypeSyntax GetContainingNotEnclosingType(TypeSyntax syntax);
    [ExtensionAttribute]
public static bool IsReturnType(TypeSyntax syntax);
    [ExtensionAttribute]
public static TypeSyntax StripRefFromType(TypeSyntax syntax);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers : object {
    private static string SystemUsingDirectiveIdentifier;
    [ExtensionAttribute]
internal static bool IsSystemUsingDirective(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static bool IsPrecededByPreprocessorDirective(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static bool HasNamespaceAliasQualifier(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static UsingGroup GetUsingGroupType(UsingDirectiveSyntax usingDirective, StyleCopSettings settings);
    [ExtensionAttribute]
internal static bool StartsWithAlias(UsingDirectiveSyntax usingDirective, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ExcludeGlobalKeyword(IdentifierNameSyntax token);
    private static Nullable`1<SyntaxToken> GetFirstIdentifierInUsingDirective(UsingDirectiveSyntax usingDirective);
}
internal enum StyleCop.Analyzers.Helpers.UsingGroup : Enum {
    public int value__;
    public static UsingGroup Unknown;
    public static UsingGroup System;
    public static UsingGroup Regular;
    public static UsingGroup Static;
    public static UsingGroup Alias;
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.XmlCommentHelper : object {
    internal static string SummaryXmlTag;
    internal static string ContentXmlTag;
    internal static string InheritdocXmlTag;
    internal static string ReturnsXmlTag;
    internal static string ValueXmlTag;
    internal static string CXmlTag;
    internal static string SeeXmlTag;
    internal static string CodeXmlTag;
    internal static string ListXmlTag;
    internal static string NoteXmlTag;
    internal static string ParaXmlTag;
    internal static string SeeAlsoXmlTag;
    internal static string ParamXmlTag;
    internal static string ParamRefXmlTag;
    internal static string TypeParamXmlTag;
    internal static string TypeParamRefXmlTag;
    internal static string RemarksXmlTag;
    internal static string ExampleXmlTag;
    internal static string PermissionXmlTag;
    internal static string ExceptionXmlTag;
    internal static string IncludeXmlTag;
    internal static string FileAttributeName;
    internal static string PathAttributeName;
    internal static string CrefArgumentName;
    internal static string NameArgumentName;
    internal static string PlaceholderTag;
    internal static bool IsConsideredEmpty(DocumentationCommentTriviaSyntax xmlComment);
    internal static bool IsConsideredEmpty(XmlNodeSyntax xmlSyntax, bool considerEmptyElements);
    internal static bool IsConsideredEmpty(XNode node);
    internal static XmlTextSyntax TryGetFirstTextElementWithContent(XmlNodeSyntax node);
    internal static XmlTextSyntax TryGetLastTextElementWithContent(XmlNodeSyntax node);
    internal static bool IsMissingOrEmpty(SyntaxTrivia commentTrivia);
    internal static bool HasDocumentation(SyntaxNode node);
    internal static string GetText(XmlNodeSyntax nodeSyntax, bool normalizeWhitespace);
    internal static string GetText(XmlTextSyntax textElement);
    internal static string GetText(XmlTextSyntax textElement, bool normalizeWhitespace);
    [ExtensionAttribute]
internal static bool AppendNormalize(StringBuilder builder, string text, bool normalizeWhitespace, Boolean& lastWhitespace);
    internal static T GetFirstAttributeOrDefault(XmlNodeSyntax nodeSyntax);
    [ExtensionAttribute]
internal static bool IsInlineElement(XmlNodeSyntax nodeSyntax);
    [ExtensionAttribute]
internal static bool IsBlockElement(XmlNodeSyntax nodeSyntax);
    private static bool IsInlineElement(string localName);
    private static bool IsBlockElement(string localName);
}
internal class StyleCop.Analyzers.Helpers.XmlFileHeader : object {
    private XElement headerXml;
    private int fileHeaderStart;
    private int fileHeaderEnd;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMalformed>k__BackingField;
    internal static XmlFileHeader MissingFileHeader { get; }
    internal static XmlFileHeader MalformedFileHeader { get; }
    internal bool IsMissing { get; private set; }
    internal bool IsMalformed { get; private set; }
    internal XmlFileHeader(XElement headerXml, int fileHeaderStart, int fileHeaderEnd);
    internal static XmlFileHeader get_MissingFileHeader();
    internal static XmlFileHeader get_MalformedFileHeader();
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
private void set_IsMissing(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMalformed();
    [CompilerGeneratedAttribute]
private void set_IsMalformed(bool value);
    internal XElement GetElement(string tagName);
    internal Location GetLocation(SyntaxTree syntaxTree);
    internal Location GetElementLocation(SyntaxTree syntaxTree, XElement element);
}
internal static class StyleCop.Analyzers.Helpers.XmlSyntaxFactory : object {
    public static DocumentationCommentTriviaSyntax DocumentationComment(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax MultiLineElement(string localName, string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax MultiLineElement(XmlNameSyntax name, string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax Element(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax Element(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax EmptyElement(string localName);
    public static SyntaxList`1<XmlNodeSyntax> List(XmlNodeSyntax[] nodes);
    public static XmlTextSyntax Text(string value);
    public static XmlTextSyntax Text(SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax TextAttribute(string name, string value);
    public static XmlTextAttributeSyntax TextAttribute(string name, SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax TextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlTextAttributeSyntax TextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlNameAttributeSyntax NameAttribute(string parameterName);
    public static XmlCrefAttributeSyntax CrefAttribute(CrefSyntax cref);
    public static XmlCrefAttributeSyntax CrefAttribute(CrefSyntax cref, SyntaxKind quoteKind);
    public static XmlTextSyntax NewLine(string text);
    public static SyntaxToken TextNewLine(string text);
    public static SyntaxToken TextNewLine(string text, bool continueComment);
    public static SyntaxToken TextLiteral(string value);
    public static SyntaxToken TextLiteral(string value, bool escapeQuotes);
    public static XmlElementSyntax SummaryElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax SummaryElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax RemarksElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax RemarksElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ReturnsElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax ReturnsElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ValueElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax ValueElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ExceptionElement(CrefSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax ExceptionElement(CrefSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ParaElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax ParaElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax ParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax TypeParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax TypeParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax ParamRefElement(string parameterName);
    public static XmlEmptyElementSyntax SeeElement(CrefSyntax cref);
    public static XmlEmptyElementSyntax SeeAlsoElement(CrefSyntax cref);
    public static XmlElementSyntax SeeAlsoElement(Uri linkAddress, SyntaxList`1<XmlNodeSyntax> linkText);
    public static XmlEmptyElementSyntax NullKeywordElement();
    public static XmlElementSyntax PlaceholderElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax PlaceholderElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax ThreadSafetyElement();
    public static XmlEmptyElementSyntax ThreadSafetyElement(bool static, bool instance);
    public static XmlEmptyElementSyntax PreliminaryElement();
    public static XmlElementSyntax TokenElement(string value);
    private static XmlEmptyElementSyntax KeywordElement(string keyword);
    private static SyntaxToken ReplaceBraceTokens(SyntaxToken originalToken, SyntaxToken rewrittenToken);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.XPathExtensions : object {
    private static Type XPathExtensionsType;
    private static XPathExtensions();
    [ExtensionAttribute]
internal static IEnumerable`1<XElement> XPathSelectElements(XNode node, string expression);
    private static Type GetTypeFromEither(string contractName, string desktopName);
    private static Type TryGetType(string assemblyQualifiedName);
    [ExtensionAttribute]
private static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    private static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
}
internal class StyleCop.Analyzers.InvalidSettingsException : Exception {
    internal InvalidSettingsException(string message);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.JsonHelper : object {
    [ExtensionAttribute]
internal static bool ToBooleanValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static int ToInt32Value(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static string ToStringValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static string ToStringValue(JsonValue jsonValue, string elementName);
    [ExtensionAttribute]
internal static TEnum ToEnumValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static TEnum ToEnumValue(JsonValue jsonValue, string elementName);
    [ExtensionAttribute]
internal static void AssertIsArray(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static void AssertIsObject(KeyValuePair`2<string, JsonValue> jsonValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.LayoutRules.LayoutResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string SA1500CodeFix { get; }
    public static string SA1500Description { get; }
    public static string SA1500MessageFormat { get; }
    public static string SA1500Title { get; }
    public static string SA1501CodeFix { get; }
    public static string SA1501CodeFixAll { get; }
    public static string SA1501Description { get; }
    public static string SA1501MessageFormat { get; }
    public static string SA1501Title { get; }
    public static string SA1502CodeFix { get; }
    public static string SA1502Description { get; }
    public static string SA1502MessageFormat { get; }
    public static string SA1502Title { get; }
    public static string SA1503CodeFix { get; }
    public static string SA1503Description { get; }
    public static string SA1503MessageFormat { get; }
    public static string SA1503Title { get; }
    public static string SA1504CodeFixMultipleLines { get; }
    public static string SA1504CodeFixSingleLine { get; }
    public static string SA1504Description { get; }
    public static string SA1504MessageFormat { get; }
    public static string SA1504Title { get; }
    public static string SA1505CodeFix { get; }
    public static string SA1505Description { get; }
    public static string SA1505MessageFormat { get; }
    public static string SA1505Title { get; }
    public static string SA1506CodeFix { get; }
    public static string SA1506Description { get; }
    public static string SA1506MessageFormat { get; }
    public static string SA1506Title { get; }
    public static string SA1507CodeFix { get; }
    public static string SA1507Description { get; }
    public static string SA1507MessageFormat { get; }
    public static string SA1507Title { get; }
    public static string SA1508CodeFix { get; }
    public static string SA1508Description { get; }
    public static string SA1508MessageFormat { get; }
    public static string SA1508Title { get; }
    public static string SA1509CodeFix { get; }
    public static string SA1509Description { get; }
    public static string SA1509MessageFormat { get; }
    public static string SA1509Title { get; }
    public static string SA1510CodeFix { get; }
    public static string SA1510Description { get; }
    public static string SA1510MessageFormat { get; }
    public static string SA1510Title { get; }
    public static string SA1511CodeFix { get; }
    public static string SA1511Description { get; }
    public static string SA1511MessageFormat { get; }
    public static string SA1511Title { get; }
    public static string SA1512CodeFix { get; }
    public static string SA1512Description { get; }
    public static string SA1512MessageFormat { get; }
    public static string SA1512Title { get; }
    public static string SA1513CodeFix { get; }
    public static string SA1513Description { get; }
    public static string SA1513MessageFormat { get; }
    public static string SA1513Title { get; }
    public static string SA1514CodeFix { get; }
    public static string SA1514Description { get; }
    public static string SA1514MessageFormat { get; }
    public static string SA1514Title { get; }
    public static string SA1515CodeFix { get; }
    public static string SA1515Description { get; }
    public static string SA1515MessageFormat { get; }
    public static string SA1515Title { get; }
    public static string SA1516CodeFixAll { get; }
    public static string SA1516CodeFixInsert { get; }
    public static string SA1516CodeFixRemove { get; }
    public static string SA1516Description { get; }
    public static string SA1516DescriptionOmit { get; }
    public static string SA1516DescriptionRequire { get; }
    public static string SA1516MessageFormat { get; }
    public static string SA1516MessageFormatOmit { get; }
    public static string SA1516MessageFormatRequire { get; }
    public static string SA1516Title { get; }
    public static string SA1517CodeFix { get; }
    public static string SA1517Description { get; }
    public static string SA1517MessageFormat { get; }
    public static string SA1517Title { get; }
    public static string SA1518CodeFix { get; }
    public static string SA1518DescriptionAllow { get; }
    public static string SA1518DescriptionOmit { get; }
    public static string SA1518DescriptionRequire { get; }
    public static string SA1518MessageFormatAllow { get; }
    public static string SA1518MessageFormatOmit { get; }
    public static string SA1518MessageFormatRequire { get; }
    public static string SA1518Title { get; }
    public static string SA1519Description { get; }
    public static string SA1519MessageFormat { get; }
    public static string SA1519Title { get; }
    public static string SA1520Description { get; }
    public static string SA1520MessageFormat { get; }
    public static string SA1520Title { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_SA1500CodeFix();
    public static string get_SA1500Description();
    public static string get_SA1500MessageFormat();
    public static string get_SA1500Title();
    public static string get_SA1501CodeFix();
    public static string get_SA1501CodeFixAll();
    public static string get_SA1501Description();
    public static string get_SA1501MessageFormat();
    public static string get_SA1501Title();
    public static string get_SA1502CodeFix();
    public static string get_SA1502Description();
    public static string get_SA1502MessageFormat();
    public static string get_SA1502Title();
    public static string get_SA1503CodeFix();
    public static string get_SA1503Description();
    public static string get_SA1503MessageFormat();
    public static string get_SA1503Title();
    public static string get_SA1504CodeFixMultipleLines();
    public static string get_SA1504CodeFixSingleLine();
    public static string get_SA1504Description();
    public static string get_SA1504MessageFormat();
    public static string get_SA1504Title();
    public static string get_SA1505CodeFix();
    public static string get_SA1505Description();
    public static string get_SA1505MessageFormat();
    public static string get_SA1505Title();
    public static string get_SA1506CodeFix();
    public static string get_SA1506Description();
    public static string get_SA1506MessageFormat();
    public static string get_SA1506Title();
    public static string get_SA1507CodeFix();
    public static string get_SA1507Description();
    public static string get_SA1507MessageFormat();
    public static string get_SA1507Title();
    public static string get_SA1508CodeFix();
    public static string get_SA1508Description();
    public static string get_SA1508MessageFormat();
    public static string get_SA1508Title();
    public static string get_SA1509CodeFix();
    public static string get_SA1509Description();
    public static string get_SA1509MessageFormat();
    public static string get_SA1509Title();
    public static string get_SA1510CodeFix();
    public static string get_SA1510Description();
    public static string get_SA1510MessageFormat();
    public static string get_SA1510Title();
    public static string get_SA1511CodeFix();
    public static string get_SA1511Description();
    public static string get_SA1511MessageFormat();
    public static string get_SA1511Title();
    public static string get_SA1512CodeFix();
    public static string get_SA1512Description();
    public static string get_SA1512MessageFormat();
    public static string get_SA1512Title();
    public static string get_SA1513CodeFix();
    public static string get_SA1513Description();
    public static string get_SA1513MessageFormat();
    public static string get_SA1513Title();
    public static string get_SA1514CodeFix();
    public static string get_SA1514Description();
    public static string get_SA1514MessageFormat();
    public static string get_SA1514Title();
    public static string get_SA1515CodeFix();
    public static string get_SA1515Description();
    public static string get_SA1515MessageFormat();
    public static string get_SA1515Title();
    public static string get_SA1516CodeFixAll();
    public static string get_SA1516CodeFixInsert();
    public static string get_SA1516CodeFixRemove();
    public static string get_SA1516Description();
    public static string get_SA1516DescriptionOmit();
    public static string get_SA1516DescriptionRequire();
    public static string get_SA1516MessageFormat();
    public static string get_SA1516MessageFormatOmit();
    public static string get_SA1516MessageFormatRequire();
    public static string get_SA1516Title();
    public static string get_SA1517CodeFix();
    public static string get_SA1517Description();
    public static string get_SA1517MessageFormat();
    public static string get_SA1517Title();
    public static string get_SA1518CodeFix();
    public static string get_SA1518DescriptionAllow();
    public static string get_SA1518DescriptionOmit();
    public static string get_SA1518DescriptionRequire();
    public static string get_SA1518MessageFormatAllow();
    public static string get_SA1518MessageFormatOmit();
    public static string get_SA1518MessageFormatRequire();
    public static string get_SA1518Title();
    public static string get_SA1519Description();
    public static string get_SA1519MessageFormat();
    public static string get_SA1519Title();
    public static string get_SA1520Description();
    public static string get_SA1520MessageFormat();
    public static string get_SA1520Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseTypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> AccessorListAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BlockAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> SwitchStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> InitializerExpressionAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> AnonymousObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1500BracesForMultiLineStatementsMustNotShareLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBlock(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckBraces(SyntaxNodeAnalysisContext context, StyleCopSettings settings, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
    private static bool InitializerExpressionSharesLine(InitializerExpressionSyntax node);
    private static void CheckBraceToken(SyntaxNodeAnalysisContext context, StyleCopSettings settings, SyntaxToken token, SyntaxToken openBraceToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string SuppressCodeFixKey;
    internal static string SuppressCodeFixValue;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableDictionary`2<string, string> SuppressCodeFixProperties;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1501StatementMustNotBeOnASingleLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
    private static bool IsSingleLineExpression(ExpressionSyntax containingExpression);
    private static bool IsPartOfStatement(BlockSyntax block);
    private static ExpressionSyntax GetContainingExpression(SyntaxNode node);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, Location location, bool reportAsHidden);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BasePropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1502ElementMustNotBeOnASingleLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBasePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckViolation(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> UsingStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1503BracesMustNotBeOmitted();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void HandleUsingStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1504AllAccessorsMustBeSingleLineOrMultiLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1505OpeningBracesMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOpenBrace(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken);
    private static int GetLine(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1507CodeMustNotContainMultipleBlankLinesInARow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void ReportDiagnosticIfNecessary(SyntaxTreeAnalysisContext context, SyntaxTriviaList leadingTrivia, int blankLineIndex, int blankLineEndIndex, int blankLineCount);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1508ClosingBracesMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCloseBrace(SyntaxNodeAnalysisContext context, SyntaxToken closeBraceToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1509OpeningBracesMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void AnalyzeOpenBrace(SyntaxTreeAnalysisContext context, SyntaxToken openBrace, SyntaxToken previousToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ElseStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> CatchClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> FinallyClauseAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleElseStatement(SyntaxNodeAnalysisContext context);
    private static void HandleCatchClause(SyntaxNodeAnalysisContext context);
    private static void HandleFinallyClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> DoStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1511WhileDoFooterMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDoStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1512SingleLineCommentsMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleSyntaxTreeAnalysis(SyntaxTreeAnalysisContext context, Compilation compilation);
    private static bool IsOnOwnLine(T triviaList, int triviaIndex);
    private static bool IsPartOfFileHeader(T triviaList, int triviaIndex);
    private static int GetTrailingBlankLineCount(T triviaList, Int32& triviaIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1513ClosingBraceMustBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1514ElementDocumentationHeaderMustBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
    private static Location GetDiagnosticLocation(SyntaxTrivia documentationHeader);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1515SingleLineCommentMustBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static bool IsOnOwnLine(T triviaList, int triviaIndex);
    private static bool IsPrecededBySingleLineCommentOnOwnLineOrDocumentation(T triviaList, int triviaIndex);
    private static bool IsPrecededByBlankLine(T triviaList, int triviaIndex);
    private static bool IsAtStartOfScope(SyntaxTrivia trivia);
    private static bool IsPrecededByDirectiveTrivia(T triviaList, int triviaIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string CodeFixActionKey;
    internal static string RemoveBlankLinesValue;
    internal static string InsertBlankLineValue;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static LocalizableString MessageFormatRequire;
    private static LocalizableString DescriptionRequire;
    private static LocalizableString MessageFormatOmit;
    private static LocalizableString DescriptionOmit;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> FileScopedNamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BasePropertyDeclarationAction;
    private static ImmutableDictionary`2<string, string> DiagnosticProperties;
    private static ImmutableDictionary`2<string, string> DiagnosticPropertiesRequire;
    private static ImmutableDictionary`2<string, string> DiagnosticPropertiesOmit;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorRequire>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorOmit>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor Descriptor { get; }
    public static DiagnosticDescriptor DescriptorRequire { get; }
    public static DiagnosticDescriptor DescriptorOmit { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1516ElementsMustBeSeparatedByBlankLine();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorRequire();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorOmit();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBasePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleFileScopedNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleUsings(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usings, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, SyntaxList`1<MemberDeclarationSyntax> members);
    private static bool IsMultiline(FieldDeclarationSyntax fieldDeclaration);
    private static bool IsMultiline(AccessorDeclarationSyntax accessorDeclaration);
    private static void ReportIfThereIsNoBlankLine(SyntaxNodeAnalysisContext context, SyntaxNode firstNode, SyntaxNode secondNode);
    private static Location GetDiagnosticLocation(SyntaxNode node);
    private static bool HasEmptyLine(IEnumerable`1<SyntaxTrivia> allTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1517CodeMustNotContainBlankLinesAtStartOfFile();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatAllow;
    private static LocalizableString DescriptionAllow;
    private static LocalizableString MessageFormatRequire;
    private static LocalizableString DescriptionRequire;
    private static LocalizableString MessageFormatOmit;
    private static LocalizableString DescriptionOmit;
    internal static DiagnosticDescriptor DescriptorAllow;
    internal static DiagnosticDescriptor DescriptorRequire;
    internal static DiagnosticDescriptor DescriptorOmit;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1518UseLineEndingsCorrectlyAtEndOfFile();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> DoStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> WhileStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForEachStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> LockStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> FixedStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> UsingStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1519BracesMustNotBeOmittedFromMultiLineChildStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void HandleDoStatement(SyntaxNodeAnalysisContext context);
    private static void HandleWhileStatement(SyntaxNodeAnalysisContext context);
    private static void HandleForStatement(SyntaxNodeAnalysisContext context);
    private static void HandleForEachStatement(SyntaxNodeAnalysisContext context);
    private static void HandleLockStatement(SyntaxNodeAnalysisContext context);
    private static void HandleFixedStatement(SyntaxNodeAnalysisContext context);
    private static void HandleUsingStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1520UseBracesConsistently();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.AccessorDeclarationSyntaxExtensions : object {
    private static Func`2<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`3<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax, AccessorDeclarationSyntax> WithExpressionBodyAccessor;
    private static AccessorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(AccessorDeclarationSyntax syntax);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.AnalyzerConfigOptionsProviderWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<object, object> GlobalOptionsAccessor;
    private static Func`3<object, SyntaxTree, object> GetOptionsSyntaxTreeAccessor;
    private static Func`3<object, AdditionalText, object> GetOptionsAdditionalTextAccessor;
    private object node;
    public AnalyzerConfigOptionsWrapper GlobalOptions { get; }
    private static AnalyzerConfigOptionsProviderWrapper();
    private AnalyzerConfigOptionsProviderWrapper(object node);
    public AnalyzerConfigOptionsWrapper get_GlobalOptions();
    public static AnalyzerConfigOptionsProviderWrapper FromObject(object node);
    public static bool IsInstance(object obj);
    public AnalyzerConfigOptionsWrapper GetOptions(SyntaxTree tree);
    public AnalyzerConfigOptionsWrapper GetOptions(AdditionalText textFile);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.AnalyzerConfigOptionsWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`1<StringComparer> KeyComparerAccessor;
    private static TryGetValueAccessor`3<object, string, string> TryGetValueAccessor;
    private object node;
    public static StringComparer KeyComparer { get; }
    private static AnalyzerConfigOptionsWrapper();
    private AnalyzerConfigOptionsWrapper(object node);
    public static StringComparer get_KeyComparer();
    public static AnalyzerConfigOptionsWrapper FromObject(object node);
    public static bool IsInstance(object obj);
    public bool TryGetValue(string key, String& value);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.AnalyzerOptionsExtensions : object {
    private static Func`2<AnalyzerOptions, object> AnalyzerConfigOptionsProviderAccessor;
    private static AnalyzerOptionsExtensions();
    [ExtensionAttribute]
public static AnalyzerConfigOptionsProviderWrapper AnalyzerConfigOptionsProvider(AnalyzerOptions options);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ArgumentSyntaxExtensions : object {
    private static Func`2<ArgumentSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<ArgumentSyntax, SyntaxToken, ArgumentSyntax> WithRefKindKeywordAccessor;
    private static ArgumentSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(ArgumentSyntax syntax);
    [ExtensionAttribute]
public static ArgumentSyntax WithRefKindKeyword(ArgumentSyntax syntax, SyntaxToken refKindKeyword);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.BaseExpressionColonSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> ColonTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithColonTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken ColonToken { get; }
    private static BaseExpressionColonSyntaxWrapper();
    private BaseExpressionColonSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_ColonToken();
    public static BaseExpressionColonSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(BaseExpressionColonSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseExpressionColonSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public BaseExpressionColonSyntaxWrapper WithColonToken(SyntaxToken colonToken);
    internal static BaseExpressionColonSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.BaseMethodDeclarationSyntaxExtensions : object {
    private static Func`2<BaseMethodDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static BaseMethodDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(BaseMethodDeclarationSyntax syntax);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.BaseNamespaceDeclarationSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<MemberDeclarationSyntax, SyntaxToken> NamespaceKeywordAccessor;
    private static Func`2<MemberDeclarationSyntax, NameSyntax> NameAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>> ExternsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>> UsingsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>> MembersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithNamespaceKeywordAccessor;
    private static Func`3<MemberDeclarationSyntax, NameSyntax, MemberDeclarationSyntax> WithNameAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>, MemberDeclarationSyntax> WithExternsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>, MemberDeclarationSyntax> WithUsingsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, MemberDeclarationSyntax> WithMembersAccessor;
    private MemberDeclarationSyntax node;
    public MemberDeclarationSyntax SyntaxNode { get; }
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    private static BaseNamespaceDeclarationSyntaxWrapper();
    private BaseNamespaceDeclarationSyntaxWrapper(MemberDeclarationSyntax node);
    public static BaseNamespaceDeclarationSyntaxWrapper op_Implicit(NamespaceDeclarationSyntax node);
    public sealed virtual MemberDeclarationSyntax get_SyntaxNode();
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public static BaseNamespaceDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static MemberDeclarationSyntax op_Implicit(BaseNamespaceDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseNamespaceDeclarationSyntaxWrapper WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public BaseNamespaceDeclarationSyntaxWrapper WithName(NameSyntax name);
    public BaseNamespaceDeclarationSyntaxWrapper WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public BaseNamespaceDeclarationSyntaxWrapper WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public BaseNamespaceDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    internal static BaseNamespaceDeclarationSyntaxWrapper FromUpcast(MemberDeclarationSyntax node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.BaseObjectCreationExpressionSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> NewKeywordAccessor;
    private static Func`2<ExpressionSyntax, ArgumentListSyntax> ArgumentListAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithNewKeywordAccessor;
    private static Func`3<ExpressionSyntax, ArgumentListSyntax, ExpressionSyntax> WithArgumentListAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken NewKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static BaseObjectCreationExpressionSyntaxWrapper();
    private BaseObjectCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public static BaseObjectCreationExpressionSyntaxWrapper op_Implicit(ObjectCreationExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_NewKeyword();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    public static BaseObjectCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(BaseObjectCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseObjectCreationExpressionSyntaxWrapper WithNewKeyword(SyntaxToken newKeyword);
    public BaseObjectCreationExpressionSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
    public BaseObjectCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
    internal static BaseObjectCreationExpressionSyntaxWrapper FromUpcast(ExpressionSyntax node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.BaseParameterSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>, CSharpSyntaxNode> WithAttributeListsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxTokenList, CSharpSyntaxNode> WithModifiersAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    private static BaseParameterSyntaxWrapper();
    private BaseParameterSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public static BaseParameterSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(BaseParameterSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BaseParameterSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public BaseParameterSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public BaseParameterSyntaxWrapper WithType(TypeSyntax type);
    internal static BaseParameterSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.BinaryPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> LeftAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> RightAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithLeftAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithRightAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public PatternSyntaxWrapper Left { get; }
    public SyntaxToken OperatorToken { get; }
    public PatternSyntaxWrapper Right { get; }
    private static BinaryPatternSyntaxWrapper();
    private BinaryPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public PatternSyntaxWrapper get_Left();
    public SyntaxToken get_OperatorToken();
    public PatternSyntaxWrapper get_Right();
    public static BinaryPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static BinaryPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static BinaryPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(BinaryPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public BinaryPatternSyntaxWrapper WithLeft(PatternSyntaxWrapper left);
    public BinaryPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public BinaryPatternSyntaxWrapper WithRight(PatternSyntaxWrapper right);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.CasePatternSwitchLabelSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> WhenClauseAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithKeywordAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithPatternAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithWhenClauseAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithColonTokenAccessor;
    private SwitchLabelSyntax node;
    public SwitchLabelSyntax SyntaxNode { get; }
    public SyntaxToken Keyword { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public WhenClauseSyntaxWrapper WhenClause { get; }
    public SyntaxToken ColonToken { get; }
    private static CasePatternSwitchLabelSyntaxWrapper();
    private CasePatternSwitchLabelSyntaxWrapper(SwitchLabelSyntax node);
    public sealed virtual SwitchLabelSyntax get_SyntaxNode();
    public SyntaxToken get_Keyword();
    public PatternSyntaxWrapper get_Pattern();
    public WhenClauseSyntaxWrapper get_WhenClause();
    public SyntaxToken get_ColonToken();
    public static CasePatternSwitchLabelSyntaxWrapper op_Explicit(SyntaxNode node);
    public static SwitchLabelSyntax op_Implicit(CasePatternSwitchLabelSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CasePatternSwitchLabelSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public CasePatternSwitchLabelSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public CasePatternSwitchLabelSyntaxWrapper WithWhenClause(WhenClauseSyntaxWrapper whenClause);
    public CasePatternSwitchLabelSyntaxWrapper WithColonToken(SyntaxToken colonToken);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ClassOrStructConstraintSyntaxExtensions : object {
    private static Func`2<ClassOrStructConstraintSyntax, SyntaxToken> QuestionTokenAccessor;
    private static Func`3<ClassOrStructConstraintSyntax, SyntaxToken, ClassOrStructConstraintSyntax> WithQuestionTokenAccessor;
    private static ClassOrStructConstraintSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken QuestionToken(ClassOrStructConstraintSyntax syntax);
    [ExtensionAttribute]
public static ClassOrStructConstraintSyntax WithQuestionToken(ClassOrStructConstraintSyntax syntax, SyntaxToken questionToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.CommonForEachStatementSyntaxWrapper : ValueType {
    internal static string FallbackWrappedTypeName;
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> ForEachKeywordAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> InKeywordAccessor;
    private static Func`2<StatementSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`2<StatementSyntax, StatementSyntax> StatementAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithForEachKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithOpenParenTokenAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithInKeywordAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithExpressionAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithCloseParenTokenAccessor;
    private static Func`3<StatementSyntax, StatementSyntax, StatementSyntax> WithStatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxToken AwaitKeyword { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static CommonForEachStatementSyntaxWrapper();
    private CommonForEachStatementSyntaxWrapper(StatementSyntax node);
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachStatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxToken get_AwaitKeyword();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static CommonForEachStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(CommonForEachStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CommonForEachStatementSyntaxWrapper WithAwaitKeyword(SyntaxToken awaitKeyword);
    public CommonForEachStatementSyntaxWrapper WithForEachKeyword(SyntaxToken forEachKeyword);
    public CommonForEachStatementSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public CommonForEachStatementSyntaxWrapper WithInKeyword(SyntaxToken inKeyword);
    public CommonForEachStatementSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public CommonForEachStatementSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
    public CommonForEachStatementSyntaxWrapper WithStatement(StatementSyntax statement);
    internal static CommonForEachStatementSyntaxWrapper FromUpcast(StatementSyntax node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ConstantPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    private static ConstantPatternSyntaxWrapper();
    private ConstantPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public static ConstantPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ConstantPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static ConstantPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ConstantPatternSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ConstructorDeclarationSyntaxExtensions : object {
    private static Func`3<ConstructorDeclarationSyntax, ArrowExpressionClauseSyntax, ConstructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static ConstructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.CrefParameterSyntaxExtensions : object {
    private static Func`2<CrefParameterSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<CrefParameterSyntax, SyntaxToken, CrefParameterSyntax> WithRefKindKeywordAccessor;
    private static CrefParameterSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(CrefParameterSyntax syntax);
    [ExtensionAttribute]
public static CrefParameterSyntax WithRefKindKeyword(CrefParameterSyntax syntax, SyntaxToken refKindKeyword);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.DeclarationExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, TypeSyntax> TypeAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<ExpressionSyntax, TypeSyntax, ExpressionSyntax> WithTypeAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithDesignationAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationExpressionSyntaxWrapper();
    private DeclarationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(DeclarationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationExpressionSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationExpressionSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.DeclarationPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationPatternSyntaxWrapper();
    private DeclarationPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static DeclarationPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static DeclarationPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationPatternSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.DefaultConstraintSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeParameterConstraintSyntax, SyntaxToken> DefaultKeywordAccessor;
    private static Func`3<TypeParameterConstraintSyntax, SyntaxToken, TypeParameterConstraintSyntax> WithDefaultKeywordAccessor;
    private TypeParameterConstraintSyntax node;
    public TypeParameterConstraintSyntax SyntaxNode { get; }
    public SyntaxToken DefaultKeyword { get; }
    private static DefaultConstraintSyntaxWrapper();
    private DefaultConstraintSyntaxWrapper(TypeParameterConstraintSyntax node);
    public sealed virtual TypeParameterConstraintSyntax get_SyntaxNode();
    public SyntaxToken get_DefaultKeyword();
    public static DefaultConstraintSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeParameterConstraintSyntax op_Implicit(DefaultConstraintSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DefaultConstraintSyntaxWrapper WithDefaultKeyword(SyntaxToken defaultKeyword);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.DestructorDeclarationSyntaxExtensions : object {
    private static Func`3<DestructorDeclarationSyntax, ArrowExpressionClauseSyntax, DestructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static DestructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static DestructorDeclarationSyntax WithExpressionBody(DestructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.DiscardDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> UnderscoreTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithUnderscoreTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken UnderscoreToken { get; }
    private static DiscardDesignationSyntaxWrapper();
    private DiscardDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_UnderscoreToken();
    public static DiscardDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static DiscardDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DiscardDesignationSyntaxWrapper WithUnderscoreToken(SyntaxToken underscoreToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.DiscardPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> UnderscoreTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithUnderscoreTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken UnderscoreToken { get; }
    private static DiscardPatternSyntaxWrapper();
    private DiscardPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_UnderscoreToken();
    public static DiscardPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static DiscardPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static DiscardPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DiscardPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DiscardPatternSyntaxWrapper WithUnderscoreToken(SyntaxToken underscoreToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ExpressionColonSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithColonTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken ColonToken { get; }
    private static ExpressionColonSyntaxWrapper();
    private ExpressionColonSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_ColonToken();
    public static ExpressionColonSyntaxWrapper op_Explicit(BaseExpressionColonSyntaxWrapper node);
    public static ExpressionColonSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseExpressionColonSyntaxWrapper op_Implicit(ExpressionColonSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ExpressionColonSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ExpressionColonSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public ExpressionColonSyntaxWrapper WithColonToken(SyntaxToken colonToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ExpressionOrPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static ExpressionOrPatternSyntaxWrapper();
    private ExpressionOrPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static ExpressionOrPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(ExpressionOrPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static ExpressionOrPatternSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FileScopedNamespaceDeclarationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<MemberDeclarationSyntax, SyntaxToken> SemicolonTokenAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, MemberDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxTokenList, MemberDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithNamespaceKeywordAccessor;
    private static Func`3<MemberDeclarationSyntax, NameSyntax, MemberDeclarationSyntax> WithNameAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxToken, MemberDeclarationSyntax> WithSemicolonTokenAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<ExternAliasDirectiveSyntax>, MemberDeclarationSyntax> WithExternsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<UsingDirectiveSyntax>, MemberDeclarationSyntax> WithUsingsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, MemberDeclarationSyntax> WithMembersAccessor;
    private MemberDeclarationSyntax node;
    public MemberDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxToken SemicolonToken { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    private static FileScopedNamespaceDeclarationSyntaxWrapper();
    private FileScopedNamespaceDeclarationSyntaxWrapper(MemberDeclarationSyntax node);
    public sealed virtual MemberDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxToken get_SemicolonToken();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public static FileScopedNamespaceDeclarationSyntaxWrapper op_Explicit(BaseNamespaceDeclarationSyntaxWrapper node);
    public static FileScopedNamespaceDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseNamespaceDeclarationSyntaxWrapper op_Implicit(FileScopedNamespaceDeclarationSyntaxWrapper wrapper);
    public static MemberDeclarationSyntax op_Implicit(FileScopedNamespaceDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithName(NameSyntax name);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public FileScopedNamespaceDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ForEachStatementSyntaxExtensions : object {
    private static Func`2<ForEachStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`3<ForEachStatementSyntax, SyntaxToken, ForEachStatementSyntax> WithAwaitKeywordAccessor;
    private static ForEachStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(ForEachStatementSyntax syntax);
    [ExtensionAttribute]
public static ForEachStatementSyntax WithAwaitKeyword(ForEachStatementSyntax syntax, SyntaxToken awaitKeyword);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ForEachVariableStatementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, ExpressionSyntax> VariableAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithForEachKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithOpenParenTokenAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithVariableAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithInKeywordAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithExpressionAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithCloseParenTokenAccessor;
    private static Func`3<StatementSyntax, StatementSyntax, StatementSyntax> WithStatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken AwaitKeyword { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Variable { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static ForEachVariableStatementSyntaxWrapper();
    private ForEachVariableStatementSyntaxWrapper(StatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_AwaitKeyword();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Variable();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(CommonForEachStatementSyntaxWrapper node);
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static StatementSyntax op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ForEachVariableStatementSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ForEachVariableStatementSyntaxWrapper WithAwaitKeyword(SyntaxToken awaitKeyword);
    public ForEachVariableStatementSyntaxWrapper WithForEachKeyword(SyntaxToken forEachKeyword);
    public ForEachVariableStatementSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ForEachVariableStatementSyntaxWrapper WithVariable(ExpressionSyntax variable);
    public ForEachVariableStatementSyntaxWrapper WithInKeyword(SyntaxToken inKeyword);
    public ForEachVariableStatementSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public ForEachVariableStatementSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
    public ForEachVariableStatementSyntaxWrapper WithStatement(StatementSyntax statement);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerCallingConventionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> ManagedOrUnmanagedKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> UnmanagedCallingConventionListAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithManagedOrUnmanagedKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithUnmanagedCallingConventionListAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken ManagedOrUnmanagedKeyword { get; }
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper UnmanagedCallingConventionList { get; }
    private static FunctionPointerCallingConventionSyntaxWrapper();
    private FunctionPointerCallingConventionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_ManagedOrUnmanagedKeyword();
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper get_UnmanagedCallingConventionList();
    public static FunctionPointerCallingConventionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerCallingConventionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerCallingConventionSyntaxWrapper WithManagedOrUnmanagedKeyword(SyntaxToken managedOrUnmanagedKeyword);
    public FunctionPointerCallingConventionSyntaxWrapper WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntaxWrapper unmanagedCallingConventionList);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerParameterListSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> LessThanTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper>> ParametersAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> GreaterThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithLessThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper>, CSharpSyntaxNode> WithParametersAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithGreaterThanTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> Parameters { get; }
    public SyntaxToken GreaterThanToken { get; }
    private static FunctionPointerParameterListSyntaxWrapper();
    private FunctionPointerParameterListSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> get_Parameters();
    public SyntaxToken get_GreaterThanToken();
    public static FunctionPointerParameterListSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerParameterListSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerParameterListSyntaxWrapper WithLessThanToken(SyntaxToken lessThanToken);
    public FunctionPointerParameterListSyntaxWrapper WithParameters(SeparatedSyntaxListWrapper`1<FunctionPointerParameterSyntaxWrapper> parameters);
    public FunctionPointerParameterListSyntaxWrapper WithGreaterThanToken(SyntaxToken greaterThanToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerParameterSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<CSharpSyntaxNode, SyntaxList`1<AttributeListSyntax>, CSharpSyntaxNode> WithAttributeListsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxTokenList, CSharpSyntaxNode> WithModifiersAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    private static FunctionPointerParameterSyntaxWrapper();
    private FunctionPointerParameterSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public static FunctionPointerParameterSyntaxWrapper op_Explicit(BaseParameterSyntaxWrapper node);
    public static FunctionPointerParameterSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseParameterSyntaxWrapper op_Implicit(FunctionPointerParameterSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerParameterSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerParameterSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FunctionPointerParameterSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public FunctionPointerParameterSyntaxWrapper WithType(TypeSyntax type);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> DelegateKeywordAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> AsteriskTokenAccessor;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> CallingConventionAccessor;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> ParameterListAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithDelegateKeywordAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithAsteriskTokenAccessor;
    private static Func`3<TypeSyntax, CSharpSyntaxNode, TypeSyntax> WithCallingConventionAccessor;
    private static Func`3<TypeSyntax, CSharpSyntaxNode, TypeSyntax> WithParameterListAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken DelegateKeyword { get; }
    public SyntaxToken AsteriskToken { get; }
    public FunctionPointerCallingConventionSyntaxWrapper CallingConvention { get; }
    public FunctionPointerParameterListSyntaxWrapper ParameterList { get; }
    private static FunctionPointerTypeSyntaxWrapper();
    private FunctionPointerTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_DelegateKeyword();
    public SyntaxToken get_AsteriskToken();
    public FunctionPointerCallingConventionSyntaxWrapper get_CallingConvention();
    public FunctionPointerParameterListSyntaxWrapper get_ParameterList();
    public static FunctionPointerTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(FunctionPointerTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerTypeSyntaxWrapper WithDelegateKeyword(SyntaxToken delegateKeyword);
    public FunctionPointerTypeSyntaxWrapper WithAsteriskToken(SyntaxToken asteriskToken);
    public FunctionPointerTypeSyntaxWrapper WithCallingConvention(FunctionPointerCallingConventionSyntaxWrapper callingConvention);
    public FunctionPointerTypeSyntaxWrapper WithParameterList(FunctionPointerParameterListSyntaxWrapper parameterList);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerUnmanagedCallingConventionListSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper>> CallingConventionsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenBracketTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper>, CSharpSyntaxNode> WithCallingConventionsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseBracketTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> CallingConventions { get; }
    public SyntaxToken CloseBracketToken { get; }
    private static FunctionPointerUnmanagedCallingConventionListSyntaxWrapper();
    private FunctionPointerUnmanagedCallingConventionListSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> get_CallingConventions();
    public SyntaxToken get_CloseBracketToken();
    public static FunctionPointerUnmanagedCallingConventionListSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerUnmanagedCallingConventionListSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithCallingConventions(SeparatedSyntaxListWrapper`1<FunctionPointerUnmanagedCallingConventionSyntaxWrapper> callingConventions);
    public FunctionPointerUnmanagedCallingConventionListSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.FunctionPointerUnmanagedCallingConventionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> NameAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithNameAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Name { get; }
    private static FunctionPointerUnmanagedCallingConventionSyntaxWrapper();
    private FunctionPointerUnmanagedCallingConventionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Name();
    public static FunctionPointerUnmanagedCallingConventionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(FunctionPointerUnmanagedCallingConventionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public FunctionPointerUnmanagedCallingConventionSyntaxWrapper WithName(SyntaxToken name);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IAddressOfOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ReferenceAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Reference { get; }
    private static IAddressOfOperationWrapper();
    private IAddressOfOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Reference();
    public static IAddressOfOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IAddressOfOperationWrapper wrapper);
    public static IAddressOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IAnonymousFunctionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    public IBlockOperationWrapper Body { get; }
    private static IAnonymousFunctionOperationWrapper();
    private IAnonymousFunctionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public IBlockOperationWrapper get_Body();
    public static IAnonymousFunctionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IAnonymousFunctionOperationWrapper wrapper);
    public static IAnonymousFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IAnonymousObjectCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> InitializersAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    private static IAnonymousObjectCreationOperationWrapper();
    private IAnonymousObjectCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Initializers();
    public static IAnonymousObjectCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IAnonymousObjectCreationOperationWrapper wrapper);
    public static IAnonymousObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IArgumentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object ArgumentKind { get; }
    public IParameterSymbol Parameter { get; }
    public IOperation Value { get; }
    public object InConversion { get; }
    public object OutConversion { get; }
    private static IArgumentOperationWrapper();
    private IArgumentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_ArgumentKind();
    public IParameterSymbol get_Parameter();
    public IOperation get_Value();
    public object get_InConversion();
    public object get_OutConversion();
    public static IArgumentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IArgumentOperationWrapper wrapper);
    public static IArgumentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IArrayCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DimensionSizesAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperationWrapper Initializer { get; }
    private static IArrayCreationOperationWrapper();
    private IArrayCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_DimensionSizes();
    public IArrayInitializerOperationWrapper get_Initializer();
    public static IArrayCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IArrayCreationOperationWrapper wrapper);
    public static IArrayCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IArrayElementReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ArrayReferenceAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IndicesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    private static IArrayElementReferenceOperationWrapper();
    private IArrayElementReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_ArrayReference();
    public ImmutableArray`1<IOperation> get_Indices();
    public static IArrayElementReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IArrayElementReferenceOperationWrapper wrapper);
    public static IArrayElementReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IArrayInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ElementValuesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> ElementValues { get; }
    private static IArrayInitializerOperationWrapper();
    private IArrayInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_ElementValues();
    public static IArrayInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IArrayInitializerOperationWrapper wrapper);
    public static IArrayInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static IAssignmentOperationWrapper();
    private IAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Target();
    public IOperation get_Value();
    public static IAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IAssignmentOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IAwaitOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static IAwaitOperationWrapper();
    private IAwaitOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static IAwaitOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IAwaitOperationWrapper wrapper);
    public static IAwaitOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IBinaryOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, bool> IsCompareTextAccessor;
    private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public bool IsCompareText { get; }
    public IMethodSymbol OperatorMethod { get; }
    private static IBinaryOperationWrapper();
    private IBinaryOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_OperatorKind();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public bool get_IsCompareText();
    public IMethodSymbol get_OperatorMethod();
    public static IBinaryOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IBinaryOperationWrapper wrapper);
    public static IBinaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IBinaryPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftPatternAccessor;
    private static Func`2<IOperation, IOperation> RightPatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object OperatorKind { get; }
    public IPatternOperationWrapper LeftPattern { get; }
    public IPatternOperationWrapper RightPattern { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IBinaryPatternOperationWrapper();
    private IBinaryPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_OperatorKind();
    public IPatternOperationWrapper get_LeftPattern();
    public IPatternOperationWrapper get_RightPattern();
    public static IBinaryPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IBinaryPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IBinaryPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IBinaryPatternOperationWrapper wrapper);
    public static IBinaryPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IBlockOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> OperationsAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Operations { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static IBlockOperationWrapper();
    private IBlockOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Operations();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static IBlockOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IBlockOperationWrapper wrapper);
    public static IBlockOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IBranchOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> TargetAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Target { get; }
    public object BranchKind { get; }
    private static IBranchOperationWrapper();
    private IBranchOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILabelSymbol get_Target();
    public object get_BranchKind();
    public static IBranchOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IBranchOperationWrapper wrapper);
    public static IBranchOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object CaseKind { get; }
    public ILabelSymbol Label { get; }
    private static ICaseClauseOperationWrapper();
    private ICaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_CaseKind();
    public ILabelSymbol get_Label();
    public static ICaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static ICaseClauseOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICatchClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExceptionDeclarationOrExpressionAccessor;
    private static Func`2<IOperation, ITypeSymbol> ExceptionTypeAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> FilterAccessor;
    private static Func`2<IOperation, IOperation> HandlerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ExceptionDeclarationOrExpression { get; }
    public ITypeSymbol ExceptionType { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Filter { get; }
    public IBlockOperationWrapper Handler { get; }
    private static ICatchClauseOperationWrapper();
    private ICatchClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_ExceptionDeclarationOrExpression();
    public ITypeSymbol get_ExceptionType();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Filter();
    public IBlockOperationWrapper get_Handler();
    public static ICatchClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICatchClauseOperationWrapper wrapper);
    public static ICatchClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICaughtExceptionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static ICaughtExceptionOperationWrapper();
    private ICaughtExceptionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static ICaughtExceptionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICaughtExceptionOperationWrapper wrapper);
    public static ICaughtExceptionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICoalesceAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ICoalesceAssignmentOperationWrapper();
    private ICoalesceAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static ICoalesceAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICoalesceAssignmentOperationWrapper wrapper);
    public IOperation get_Target();
    public IOperation get_Value();
    public static ICoalesceAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ICoalesceAssignmentOperationWrapper wrapper);
    public static ICoalesceAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICoalesceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, IOperation> WhenNullAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    public object ValueConversion { get; }
    private static ICoalesceOperationWrapper();
    private ICoalesceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public IOperation get_WhenNull();
    public object get_ValueConversion();
    public static ICoalesceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICoalesceOperationWrapper wrapper);
    public static ICoalesceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICollectionElementInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> AddMethodAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private static Func`2<IOperation, bool> IsDynamicAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol AddMethod { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public bool IsDynamic { get; }
    private static ICollectionElementInitializerOperationWrapper();
    private ICollectionElementInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_AddMethod();
    public ImmutableArray`1<IOperation> get_Arguments();
    public bool get_IsDynamic();
    public static ICollectionElementInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICollectionElementInitializerOperationWrapper wrapper);
    public static ICollectionElementInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ICompoundAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object InConversion { get; }
    public object OutConversion { get; }
    public object OperatorKind { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IMethodSymbol OperatorMethod { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ICompoundAssignmentOperationWrapper();
    private ICompoundAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_InConversion();
    public object get_OutConversion();
    public object get_OperatorKind();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public IMethodSymbol get_OperatorMethod();
    public static ICompoundAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ICompoundAssignmentOperationWrapper wrapper);
    public IOperation get_Target();
    public IOperation get_Value();
    public static ICompoundAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ICompoundAssignmentOperationWrapper wrapper);
    public static ICompoundAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConditionalAccessInstanceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IConditionalAccessInstanceOperationWrapper();
    private IConditionalAccessInstanceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IConditionalAccessInstanceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConditionalAccessInstanceOperationWrapper wrapper);
    public static IConditionalAccessInstanceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConditionalAccessOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, IOperation> WhenNotNullAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    private static IConditionalAccessOperationWrapper();
    private IConditionalAccessOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public IOperation get_WhenNotNull();
    public static IConditionalAccessOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConditionalAccessOperationWrapper wrapper);
    public static IConditionalAccessOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConditionalOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, IOperation> WhenTrueAccessor;
    private static Func`2<IOperation, IOperation> WhenFalseAccessor;
    private static Func`2<IOperation, bool> IsRefAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public bool IsRef { get; }
    private static IConditionalOperationWrapper();
    private IConditionalOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Condition();
    public IOperation get_WhenTrue();
    public IOperation get_WhenFalse();
    public bool get_IsRef();
    public static IConditionalOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConditionalOperationWrapper wrapper);
    public static IConditionalOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConstantPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IConstantPatternOperationWrapper();
    private IConstantPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public static IConstantPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConstantPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IConstantPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IConstantPatternOperationWrapper wrapper);
    public static IConstantPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConstructorBodyOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Initializer { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IConstructorBodyOperationWrapper();
    private IConstructorBodyOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Initializer();
    public static IConstructorBodyOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConstructorBodyOperationWrapper wrapper);
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IConstructorBodyOperationWrapper op_Explicit(IMethodBodyBaseOperationWrapper wrapper);
    public static IMethodBodyBaseOperationWrapper op_Implicit(IConstructorBodyOperationWrapper wrapper);
    public static IConstructorBodyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IConversionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    private static Func`2<IOperation, bool> IsTryCastAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    public IMethodSymbol OperatorMethod { get; }
    public object Conversion { get; }
    public bool IsTryCast { get; }
    public bool IsChecked { get; }
    private static IConversionOperationWrapper();
    private IConversionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operand();
    public IMethodSymbol get_OperatorMethod();
    public object get_Conversion();
    public bool get_IsTryCast();
    public bool get_IsChecked();
    public static IConversionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IConversionOperationWrapper wrapper);
    public static IConversionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDeclarationExpressionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExpressionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Expression { get; }
    private static IDeclarationExpressionOperationWrapper();
    private IDeclarationExpressionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Expression();
    public static IDeclarationExpressionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDeclarationExpressionOperationWrapper wrapper);
    public static IDeclarationExpressionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDeclarationPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    private static Func`2<IOperation, bool> MatchesNullAccessor;
    private static Func`2<IOperation, ISymbol> DeclaredSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol MatchedType { get; }
    public bool MatchesNull { get; }
    public ISymbol DeclaredSymbol { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IDeclarationPatternOperationWrapper();
    private IDeclarationPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_MatchedType();
    public bool get_MatchesNull();
    public ISymbol get_DeclaredSymbol();
    public static IDeclarationPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDeclarationPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IDeclarationPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IDeclarationPatternOperationWrapper wrapper);
    public static IDeclarationPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDeconstructionAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static IDeconstructionAssignmentOperationWrapper();
    private IDeconstructionAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IDeconstructionAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDeconstructionAssignmentOperationWrapper wrapper);
    public IOperation get_Target();
    public IOperation get_Value();
    public static IDeconstructionAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(IDeconstructionAssignmentOperationWrapper wrapper);
    public static IDeconstructionAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDefaultCaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object CaseKind { get; }
    public ILabelSymbol Label { get; }
    private static IDefaultCaseClauseOperationWrapper();
    private IDefaultCaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IDefaultCaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDefaultCaseClauseOperationWrapper wrapper);
    public object get_CaseKind();
    public ILabelSymbol get_Label();
    public static IDefaultCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IDefaultCaseClauseOperationWrapper wrapper);
    public static IDefaultCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDefaultValueOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IDefaultValueOperationWrapper();
    private IDefaultValueOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IDefaultValueOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDefaultValueOperationWrapper wrapper);
    public static IDefaultValueOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDelegateCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Target { get; }
    private static IDelegateCreationOperationWrapper();
    private IDelegateCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Target();
    public static IDelegateCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDelegateCreationOperationWrapper wrapper);
    public static IDelegateCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDiscardOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object DiscardSymbol { get; }
    private static IDiscardOperationWrapper();
    private IDiscardOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_DiscardSymbol();
    public static IDiscardOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDiscardOperationWrapper wrapper);
    public static IDiscardOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDiscardPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IDiscardPatternOperationWrapper();
    private IDiscardPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IDiscardPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDiscardPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IDiscardPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IDiscardPatternOperationWrapper wrapper);
    public static IDiscardPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDynamicIndexerAccessOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicIndexerAccessOperationWrapper();
    private IDynamicIndexerAccessOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicIndexerAccessOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDynamicIndexerAccessOperationWrapper wrapper);
    public static IDynamicIndexerAccessOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDynamicInvocationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicInvocationOperationWrapper();
    private IDynamicInvocationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicInvocationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDynamicInvocationOperationWrapper wrapper);
    public static IDynamicInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDynamicMemberReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, string> MemberNameAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ITypeSymbol>> TypeArgumentsAccessor;
    private static Func`2<IOperation, ITypeSymbol> ContainingTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public string MemberName { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ITypeSymbol ContainingType { get; }
    private static IDynamicMemberReferenceOperationWrapper();
    private IDynamicMemberReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Instance();
    public string get_MemberName();
    public ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public ITypeSymbol get_ContainingType();
    public static IDynamicMemberReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDynamicMemberReferenceOperationWrapper wrapper);
    public static IDynamicMemberReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IDynamicObjectCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IDynamicObjectCreationOperationWrapper();
    private IDynamicObjectCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IDynamicObjectCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IDynamicObjectCreationOperationWrapper wrapper);
    public static IDynamicObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IEmptyOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IEmptyOperationWrapper();
    private IEmptyOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IEmptyOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IEmptyOperationWrapper wrapper);
    public static IEmptyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IEndOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IEndOperationWrapper();
    private IEndOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IEndOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IEndOperationWrapper wrapper);
    public static IEndOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IEventAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> EventReferenceAccessor;
    private static Func`2<IOperation, IOperation> HandlerValueAccessor;
    private static Func`2<IOperation, bool> AddsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    public bool Adds { get; }
    private static IEventAssignmentOperationWrapper();
    private IEventAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_EventReference();
    public IOperation get_HandlerValue();
    public bool get_Adds();
    public static IEventAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IEventAssignmentOperationWrapper wrapper);
    public static IEventAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IEventReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IEventSymbol> EventAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IEventSymbol Event { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    private static IEventReferenceOperationWrapper();
    private IEventReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IEventSymbol get_Event();
    public static IEventReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IEventReferenceOperationWrapper wrapper);
    public IOperation get_Instance();
    public ISymbol get_Member();
    public static IEventReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IEventReferenceOperationWrapper wrapper);
    public static IEventReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IExpressionStatementOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static IExpressionStatementOperationWrapper();
    private IExpressionStatementOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static IExpressionStatementOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IExpressionStatementOperationWrapper wrapper);
    public static IExpressionStatementOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IFieldInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IFieldSymbol>> InitializedFieldsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IFieldSymbol> InitializedFields { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IFieldInitializerOperationWrapper();
    private IFieldInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IFieldSymbol> get_InitializedFields();
    public static IFieldInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IFieldInitializerOperationWrapper wrapper);
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IFieldInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IFieldInitializerOperationWrapper wrapper);
    public static IFieldInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IFieldReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IFieldSymbol> FieldAccessor;
    private static Func`2<IOperation, bool> IsDeclarationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IFieldSymbol Field { get; }
    public bool IsDeclaration { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    private static IFieldReferenceOperationWrapper();
    private IFieldReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IFieldSymbol get_Field();
    public bool get_IsDeclaration();
    public static IFieldReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IFieldReferenceOperationWrapper wrapper);
    public IOperation get_Instance();
    public ISymbol get_Member();
    public static IFieldReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IFieldReferenceOperationWrapper wrapper);
    public static IFieldReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.IFieldSymbolExtensions : object {
    private static Func`2<IFieldSymbol, IFieldSymbol> CorrespondingTupleFieldAccessor;
    private static IFieldSymbolExtensions();
    [ExtensionAttribute]
public static IFieldSymbol CorrespondingTupleField(IFieldSymbol symbol);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IFlowAnonymousFunctionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    private static IFlowAnonymousFunctionOperationWrapper();
    private IFlowAnonymousFunctionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public static IFlowAnonymousFunctionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IFlowAnonymousFunctionOperationWrapper wrapper);
    public static IFlowAnonymousFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IFlowCaptureOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object Id { get; }
    public IOperation Value { get; }
    private static IFlowCaptureOperationWrapper();
    private IFlowCaptureOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_Id();
    public IOperation get_Value();
    public static IFlowCaptureOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IFlowCaptureOperationWrapper wrapper);
    public static IFlowCaptureOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IFlowCaptureReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object Id { get; }
    private static IFlowCaptureReferenceOperationWrapper();
    private IFlowCaptureReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_Id();
    public static IFlowCaptureReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IFlowCaptureReferenceOperationWrapper wrapper);
    public static IFlowCaptureReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IForEachLoopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LoopControlVariableAccessor;
    private static Func`2<IOperation, IOperation> CollectionAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> NextVariablesAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public bool IsAsynchronous { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForEachLoopOperationWrapper();
    private IForEachLoopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_LoopControlVariable();
    public IOperation get_Collection();
    public ImmutableArray`1<IOperation> get_NextVariables();
    public bool get_IsAsynchronous();
    public static IForEachLoopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IForEachLoopOperationWrapper wrapper);
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForEachLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForEachLoopOperationWrapper wrapper);
    public static IForEachLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IForLoopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> BeforeAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> ConditionLocalsAccessor;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> AtLoopBottomAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Before { get; }
    public ImmutableArray`1<ILocalSymbol> ConditionLocals { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForLoopOperationWrapper();
    private IForLoopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Before();
    public ImmutableArray`1<ILocalSymbol> get_ConditionLocals();
    public IOperation get_Condition();
    public ImmutableArray`1<IOperation> get_AtLoopBottom();
    public static IForLoopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IForLoopOperationWrapper wrapper);
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForLoopOperationWrapper wrapper);
    public static IForLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IForToLoopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LoopControlVariableAccessor;
    private static Func`2<IOperation, IOperation> InitialValueAccessor;
    private static Func`2<IOperation, IOperation> LimitValueAccessor;
    private static Func`2<IOperation, IOperation> StepValueAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> NextVariablesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public bool IsChecked { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IForToLoopOperationWrapper();
    private IForToLoopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_LoopControlVariable();
    public IOperation get_InitialValue();
    public IOperation get_LimitValue();
    public IOperation get_StepValue();
    public bool get_IsChecked();
    public ImmutableArray`1<IOperation> get_NextVariables();
    public static IForToLoopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IForToLoopOperationWrapper wrapper);
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IForToLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IForToLoopOperationWrapper wrapper);
    public static IForToLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IIncrementOrDecrementOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, bool> IsPostfixAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public bool IsPostfix { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IOperation Target { get; }
    public IMethodSymbol OperatorMethod { get; }
    private static IIncrementOrDecrementOperationWrapper();
    private IIncrementOrDecrementOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public bool get_IsPostfix();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public IOperation get_Target();
    public IMethodSymbol get_OperatorMethod();
    public static IIncrementOrDecrementOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IIncrementOrDecrementOperationWrapper wrapper);
    public static IIncrementOrDecrementOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInstanceReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object ReferenceKind { get; }
    private static IInstanceReferenceOperationWrapper();
    private IInstanceReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_ReferenceKind();
    public static IInstanceReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInstanceReferenceOperationWrapper wrapper);
    public static IInstanceReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInterpolatedStringContentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IInterpolatedStringContentOperationWrapper();
    private IInterpolatedStringContentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IInterpolatedStringContentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IInterpolatedStringContentOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInterpolatedStringOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> PartsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Parts { get; }
    private static IInterpolatedStringOperationWrapper();
    private IInterpolatedStringOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Parts();
    public static IInterpolatedStringOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInterpolatedStringOperationWrapper wrapper);
    public static IInterpolatedStringOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInterpolatedStringTextOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> TextAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Text { get; }
    private static IInterpolatedStringTextOperationWrapper();
    private IInterpolatedStringTextOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Text();
    public static IInterpolatedStringTextOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInterpolatedStringTextOperationWrapper wrapper);
    public static IInterpolatedStringTextOperationWrapper op_Explicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper op_Implicit(IInterpolatedStringTextOperationWrapper wrapper);
    public static IInterpolatedStringTextOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInterpolationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExpressionAccessor;
    private static Func`2<IOperation, IOperation> AlignmentAccessor;
    private static Func`2<IOperation, IOperation> FormatStringAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    private static IInterpolationOperationWrapper();
    private IInterpolationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Expression();
    public IOperation get_Alignment();
    public IOperation get_FormatString();
    public static IInterpolationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInterpolationOperationWrapper wrapper);
    public static IInterpolationOperationWrapper op_Explicit(IInterpolatedStringContentOperationWrapper wrapper);
    public static IInterpolatedStringContentOperationWrapper op_Implicit(IInterpolationOperationWrapper wrapper);
    public static IInterpolationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInvalidOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IInvalidOperationWrapper();
    private IInvalidOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IInvalidOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInvalidOperationWrapper wrapper);
    public static IInvalidOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IInvocationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> TargetMethodAccessor;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, bool> IsVirtualAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol TargetMethod { get; }
    public IOperation Instance { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IInvocationOperationWrapper();
    private IInvocationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_TargetMethod();
    public IOperation get_Instance();
    public bool get_IsVirtual();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IInvocationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IInvocationOperationWrapper wrapper);
    public static IInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IIsNullOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    private static IIsNullOperationWrapper();
    private IIsNullOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operand();
    public static IIsNullOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IIsNullOperationWrapper wrapper);
    public static IIsNullOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IIsPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public IPatternOperationWrapper Pattern { get; }
    private static IIsPatternOperationWrapper();
    private IIsPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public IPatternOperationWrapper get_Pattern();
    public static IIsPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IIsPatternOperationWrapper wrapper);
    public static IIsPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IIsTypeOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueOperandAccessor;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private static Func`2<IOperation, bool> IsNegatedAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ValueOperand { get; }
    public ITypeSymbol TypeOperand { get; }
    public bool IsNegated { get; }
    private static IIsTypeOperationWrapper();
    private IIsTypeOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_ValueOperand();
    public ITypeSymbol get_TypeOperand();
    public bool get_IsNegated();
    public static IIsTypeOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IIsTypeOperationWrapper wrapper);
    public static IIsTypeOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILabeledOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Label { get; }
    public IOperation Operation { get; }
    private static ILabeledOperationWrapper();
    private ILabeledOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILabelSymbol get_Label();
    public IOperation get_Operation();
    public static ILabeledOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILabeledOperationWrapper wrapper);
    public static ILabeledOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILiteralOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static ILiteralOperationWrapper();
    private ILiteralOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static ILiteralOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILiteralOperationWrapper wrapper);
    public static ILiteralOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILocalFunctionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, IOperation> IgnoredBodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Symbol { get; }
    public IBlockOperationWrapper Body { get; }
    public IBlockOperationWrapper IgnoredBody { get; }
    private static ILocalFunctionOperationWrapper();
    private ILocalFunctionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_Symbol();
    public IBlockOperationWrapper get_Body();
    public IBlockOperationWrapper get_IgnoredBody();
    public static ILocalFunctionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILocalFunctionOperationWrapper wrapper);
    public static ILocalFunctionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILocalReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> LocalAccessor;
    private static Func`2<IOperation, bool> IsDeclarationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Local { get; }
    public bool IsDeclaration { get; }
    private static ILocalReferenceOperationWrapper();
    private ILocalReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILocalSymbol get_Local();
    public bool get_IsDeclaration();
    public static ILocalReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILocalReferenceOperationWrapper wrapper);
    public static ILocalReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILockOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LockedValueAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    private static ILockOperationWrapper();
    private ILockOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_LockedValue();
    public IOperation get_Body();
    public static ILockOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILockOperationWrapper wrapper);
    public static ILockOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ILoopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, ILabelSymbol> ContinueLabelAccessor;
    private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static ILoopOperationWrapper();
    private ILoopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static ILoopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static ILoopOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IMemberInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializedMemberAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static IMemberInitializerOperationWrapper();
    private IMemberInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_InitializedMember();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static IMemberInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IMemberInitializerOperationWrapper wrapper);
    public static IMemberInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IMemberReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InstanceAccessor;
    private static Func`2<IOperation, ISymbol> MemberAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    private static IMemberReferenceOperationWrapper();
    private IMemberReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Instance();
    public ISymbol get_Member();
    public static IMemberReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IMemberReferenceOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IMethodBodyBaseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BlockBodyAccessor;
    private static Func`2<IOperation, IOperation> ExpressionBodyAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IMethodBodyBaseOperationWrapper();
    private IMethodBodyBaseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IMethodBodyBaseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IMethodBodyBaseOperationWrapper wrapper);
    public static IMethodBodyBaseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IMethodBodyBaseOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IMethodBodyOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper BlockBody { get; }
    public IBlockOperationWrapper ExpressionBody { get; }
    private static IMethodBodyOperationWrapper();
    private IMethodBodyOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IMethodBodyOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IMethodBodyOperationWrapper wrapper);
    public IBlockOperationWrapper get_BlockBody();
    public IBlockOperationWrapper get_ExpressionBody();
    public static IMethodBodyOperationWrapper op_Explicit(IMethodBodyBaseOperationWrapper wrapper);
    public static IMethodBodyBaseOperationWrapper op_Implicit(IMethodBodyOperationWrapper wrapper);
    public static IMethodBodyOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IMethodReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> MethodAccessor;
    private static Func`2<IOperation, bool> IsVirtualAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Method { get; }
    public bool IsVirtual { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    private static IMethodReferenceOperationWrapper();
    private IMethodReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_Method();
    public bool get_IsVirtual();
    public static IMethodReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IMethodReferenceOperationWrapper wrapper);
    public IOperation get_Instance();
    public ISymbol get_Member();
    public static IMethodReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IMethodReferenceOperationWrapper wrapper);
    public static IMethodReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ImplicitObjectCreationExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithNewKeywordAccessor;
    private static Func`3<ExpressionSyntax, ArgumentListSyntax, ExpressionSyntax> WithArgumentListAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken NewKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static ImplicitObjectCreationExpressionSyntaxWrapper();
    private ImplicitObjectCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_NewKeyword();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    public static ImplicitObjectCreationExpressionSyntaxWrapper op_Explicit(BaseObjectCreationExpressionSyntaxWrapper node);
    public static ImplicitObjectCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseObjectCreationExpressionSyntaxWrapper op_Implicit(ImplicitObjectCreationExpressionSyntaxWrapper wrapper);
    public static ExpressionSyntax op_Implicit(ImplicitObjectCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithNewKeyword(SyntaxToken newKeyword);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
    public ImplicitObjectCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ImplicitStackAllocArrayCreationExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> StackAllocKeywordAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithStackAllocKeywordAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken StackAllocKeyword { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SyntaxToken CloseBracketToken { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper();
    private ImplicitStackAllocArrayCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper AddInitializerExpressions(ExpressionSyntax[] items);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_StackAllocKeyword();
    public SyntaxToken get_OpenBracketToken();
    public SyntaxToken get_CloseBracketToken();
    public InitializerExpressionSyntax get_Initializer();
    public static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ImplicitStackAllocArrayCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithStackAllocKeyword(SyntaxToken stackAllocKeyword);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.INamedTypeSymbolExtensions : object {
    private static Func`2<INamedTypeSymbol, INamedTypeSymbol> TupleUnderlyingTypeAccessor;
    private static Func`2<INamedTypeSymbol, ImmutableArray`1<IFieldSymbol>> TupleElementsAccessor;
    private static Func`2<INamedTypeSymbol, bool> IsSerializableAccessor;
    private static INamedTypeSymbolExtensions();
    [ExtensionAttribute]
public static INamedTypeSymbol TupleUnderlyingType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IFieldSymbol> TupleElements(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsSerializable(INamedTypeSymbol symbol);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.INameOfOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ArgumentAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Argument { get; }
    private static INameOfOperationWrapper();
    private INameOfOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Argument();
    public static INameOfOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(INameOfOperationWrapper wrapper);
    public static INameOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.INegatedPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPatternOperationWrapper Pattern { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static INegatedPatternOperationWrapper();
    private INegatedPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IPatternOperationWrapper get_Pattern();
    public static INegatedPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(INegatedPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static INegatedPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(INegatedPatternOperationWrapper wrapper);
    public static INegatedPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IObjectCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IMethodSymbol> ConstructorAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IMethodSymbol Constructor { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IObjectCreationOperationWrapper();
    private IObjectCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IMethodSymbol get_Constructor();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IObjectCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IObjectCreationOperationWrapper wrapper);
    public static IObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IObjectOrCollectionInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> InitializersAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    private static IObjectOrCollectionInitializerOperationWrapper();
    private IObjectOrCollectionInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Initializers();
    public static IObjectOrCollectionInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IObjectOrCollectionInitializerOperationWrapper wrapper);
    public static IObjectOrCollectionInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IOmittedArgumentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IOmittedArgumentOperationWrapper();
    private IOmittedArgumentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IOmittedArgumentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IOmittedArgumentOperationWrapper wrapper);
    public static IOmittedArgumentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Func`2<IOperation, IOperation> ParentAccessor;
    private static Func`2<IOperation, IEnumerable`1<IOperation>> ChildrenAccessor;
    private static Func`2<IOperation, string> LanguageAccessor;
    private static Func`2<IOperation, bool> IsImplicitAccessor;
    private static Func`2<IOperation, SemanticModel> SemanticModelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public IOperation Parent { get; }
    public OperationKind Kind { get; }
    public SyntaxNode Syntax { get; }
    public ITypeSymbol Type { get; }
    public Optional`1<object> ConstantValue { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public string Language { get; }
    public bool IsImplicit { get; }
    public SemanticModel SemanticModel { get; }
    private static IOperationWrapper();
    private IOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public IOperation get_Parent();
    public OperationKind get_Kind();
    public SyntaxNode get_Syntax();
    public ITypeSymbol get_Type();
    public Optional`1<object> get_ConstantValue();
    public IEnumerable`1<IOperation> get_Children();
    public string get_Language();
    public bool get_IsImplicit();
    public SemanticModel get_SemanticModel();
    public static IOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IParameterInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IParameterSymbol Parameter { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IParameterInitializerOperationWrapper();
    private IParameterInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IParameterSymbol get_Parameter();
    public static IParameterInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IParameterInitializerOperationWrapper wrapper);
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IParameterInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IParameterInitializerOperationWrapper wrapper);
    public static IParameterInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IParameterReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IParameterSymbol> ParameterAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IParameterSymbol Parameter { get; }
    private static IParameterReferenceOperationWrapper();
    private IParameterReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IParameterSymbol get_Parameter();
    public static IParameterReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IParameterReferenceOperationWrapper wrapper);
    public static IParameterReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IParenthesizedOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    private static IParenthesizedOperationWrapper();
    private IParenthesizedOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operand();
    public static IParenthesizedOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IParenthesizedOperationWrapper wrapper);
    public static IParenthesizedOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IPatternCaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILabelSymbol> LabelAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private static Func`2<IOperation, IOperation> GuardAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILabelSymbol Label { get; }
    public IPatternOperationWrapper Pattern { get; }
    public IOperation Guard { get; }
    public object CaseKind { get; }
    private static IPatternCaseClauseOperationWrapper();
    private IPatternCaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILabelSymbol get_Label();
    public IPatternOperationWrapper get_Pattern();
    public IOperation get_Guard();
    public static IPatternCaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IPatternCaseClauseOperationWrapper wrapper);
    public object get_CaseKind();
    public static IPatternCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IPatternCaseClauseOperationWrapper wrapper);
    public static IPatternCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> InputTypeAccessor;
    private static Func`2<IOperation, ITypeSymbol> NarrowedTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IPatternOperationWrapper();
    private IPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static IPatternOperationWrapper FromUpcast(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IPropertyInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IPropertySymbol>> InitializedPropertiesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IPropertySymbol> InitializedProperties { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IPropertyInitializerOperationWrapper();
    private IPropertyInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IPropertySymbol> get_InitializedProperties();
    public static IPropertyInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IPropertyInitializerOperationWrapper wrapper);
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IPropertyInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IPropertyInitializerOperationWrapper wrapper);
    public static IPropertyInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IPropertyReferenceOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IPropertySymbol> PropertyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPropertySymbol Property { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    private static IPropertyReferenceOperationWrapper();
    private IPropertyReferenceOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IPropertySymbol get_Property();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IPropertyReferenceOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IPropertyReferenceOperationWrapper wrapper);
    public IOperation get_Instance();
    public ISymbol get_Member();
    public static IPropertyReferenceOperationWrapper op_Explicit(IMemberReferenceOperationWrapper wrapper);
    public static IMemberReferenceOperationWrapper op_Implicit(IPropertyReferenceOperationWrapper wrapper);
    public static IPropertyReferenceOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IPropertySubpatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> MemberAccessor;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Member { get; }
    public IPatternOperationWrapper Pattern { get; }
    private static IPropertySubpatternOperationWrapper();
    private IPropertySubpatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Member();
    public IPatternOperationWrapper get_Pattern();
    public static IPropertySubpatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IPropertySubpatternOperationWrapper wrapper);
    public static IPropertySubpatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRaiseEventOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> EventReferenceAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IEventReferenceOperationWrapper EventReference { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    private static IRaiseEventOperationWrapper();
    private IRaiseEventOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IEventReferenceOperationWrapper get_EventReference();
    public ImmutableArray`1<IOperation> get_Arguments();
    public static IRaiseEventOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRaiseEventOperationWrapper wrapper);
    public static IRaiseEventOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRangeCaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> MinimumValueAccessor;
    private static Func`2<IOperation, IOperation> MaximumValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public object CaseKind { get; }
    public ILabelSymbol Label { get; }
    private static IRangeCaseClauseOperationWrapper();
    private IRangeCaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_MinimumValue();
    public IOperation get_MaximumValue();
    public static IRangeCaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRangeCaseClauseOperationWrapper wrapper);
    public object get_CaseKind();
    public ILabelSymbol get_Label();
    public static IRangeCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IRangeCaseClauseOperationWrapper wrapper);
    public static IRangeCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRangeOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, IMethodSymbol> MethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public bool IsLifted { get; }
    public IMethodSymbol Method { get; }
    private static IRangeOperationWrapper();
    private IRangeOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public bool get_IsLifted();
    public IMethodSymbol get_Method();
    public static IRangeOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRangeOperationWrapper wrapper);
    public static IRangeOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRecursivePatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    private static Func`2<IOperation, ISymbol> DeconstructSymbolAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeconstructionSubpatternsAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> PropertySubpatternsAccessor;
    private static Func`2<IOperation, ISymbol> DeclaredSymbolAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol MatchedType { get; }
    public ISymbol DeconstructSymbol { get; }
    public ImmutableArray`1<IOperation> DeconstructionSubpatterns { get; }
    public ImmutableArray`1<IOperation> PropertySubpatterns { get; }
    public ISymbol DeclaredSymbol { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IRecursivePatternOperationWrapper();
    private IRecursivePatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_MatchedType();
    public ISymbol get_DeconstructSymbol();
    public ImmutableArray`1<IOperation> get_DeconstructionSubpatterns();
    public ImmutableArray`1<IOperation> get_PropertySubpatterns();
    public ISymbol get_DeclaredSymbol();
    public static IRecursivePatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRecursivePatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IRecursivePatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IRecursivePatternOperationWrapper wrapper);
    public static IRecursivePatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IReDimClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DimensionSizesAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    private static IReDimClauseOperationWrapper();
    private IReDimClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operand();
    public ImmutableArray`1<IOperation> get_DimensionSizes();
    public static IReDimClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IReDimClauseOperationWrapper wrapper);
    public static IReDimClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IReDimOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ClausesAccessor;
    private static Func`2<IOperation, bool> PreserveAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Clauses { get; }
    public bool Preserve { get; }
    private static IReDimOperationWrapper();
    private IReDimOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Clauses();
    public bool get_Preserve();
    public static IReDimOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IReDimOperationWrapper wrapper);
    public static IReDimOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRelationalCaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public object Relation { get; }
    public object CaseKind { get; }
    public ILabelSymbol Label { get; }
    private static IRelationalCaseClauseOperationWrapper();
    private IRelationalCaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public object get_Relation();
    public static IRelationalCaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRelationalCaseClauseOperationWrapper wrapper);
    public object get_CaseKind();
    public ILabelSymbol get_Label();
    public static IRelationalCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(IRelationalCaseClauseOperationWrapper wrapper);
    public static IRelationalCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IRelationalPatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object OperatorKind { get; }
    public IOperation Value { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static IRelationalPatternOperationWrapper();
    private IRelationalPatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_OperatorKind();
    public IOperation get_Value();
    public static IRelationalPatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IRelationalPatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static IRelationalPatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(IRelationalPatternOperationWrapper wrapper);
    public static IRelationalPatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IReturnOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ReturnedValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation ReturnedValue { get; }
    private static IReturnOperationWrapper();
    private IReturnOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_ReturnedValue();
    public static IReturnOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IReturnOperationWrapper wrapper);
    public static IReturnOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISimpleAssignmentOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, bool> IsRefAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public bool IsRef { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    private static ISimpleAssignmentOperationWrapper();
    private ISimpleAssignmentOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public bool get_IsRef();
    public static ISimpleAssignmentOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISimpleAssignmentOperationWrapper wrapper);
    public IOperation get_Target();
    public IOperation get_Value();
    public static ISimpleAssignmentOperationWrapper op_Explicit(IAssignmentOperationWrapper wrapper);
    public static IAssignmentOperationWrapper op_Implicit(ISimpleAssignmentOperationWrapper wrapper);
    public static ISimpleAssignmentOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISingleValueCaseClauseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public object CaseKind { get; }
    public ILabelSymbol Label { get; }
    private static ISingleValueCaseClauseOperationWrapper();
    private ISingleValueCaseClauseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public static ISingleValueCaseClauseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISingleValueCaseClauseOperationWrapper wrapper);
    public object get_CaseKind();
    public ILabelSymbol get_Label();
    public static ISingleValueCaseClauseOperationWrapper op_Explicit(ICaseClauseOperationWrapper wrapper);
    public static ICaseClauseOperationWrapper op_Implicit(ISingleValueCaseClauseOperationWrapper wrapper);
    public static ISingleValueCaseClauseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISizeOfOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol TypeOperand { get; }
    private static ISizeOfOperationWrapper();
    private ISizeOfOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_TypeOperand();
    public static ISizeOfOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISizeOfOperationWrapper wrapper);
    public static ISizeOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IsPatternExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> IsKeywordAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithIsKeywordAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithPatternAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken IsKeyword { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static IsPatternExpressionSyntaxWrapper();
    private IsPatternExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_IsKeyword();
    public PatternSyntaxWrapper get_Pattern();
    public static IsPatternExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(IsPatternExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public IsPatternExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public IsPatternExpressionSyntaxWrapper WithIsKeyword(SyntaxToken isKeyword);
    public IsPatternExpressionSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IStaticLocalInitializationSemaphoreOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> LocalAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Local { get; }
    private static IStaticLocalInitializationSemaphoreOperationWrapper();
    private IStaticLocalInitializationSemaphoreOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILocalSymbol get_Local();
    public static IStaticLocalInitializationSemaphoreOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IStaticLocalInitializationSemaphoreOperationWrapper wrapper);
    public static IStaticLocalInitializationSemaphoreOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IStopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    private static IStopOperationWrapper();
    private IStopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IStopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IStopOperationWrapper wrapper);
    public static IStopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISwitchCaseOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ClausesAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Clauses { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static ISwitchCaseOperationWrapper();
    private ISwitchCaseOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Clauses();
    public ImmutableArray`1<IOperation> get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static ISwitchCaseOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISwitchCaseOperationWrapper wrapper);
    public static ISwitchCaseOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISwitchExpressionArmOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> PatternAccessor;
    private static Func`2<IOperation, IOperation> GuardAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IPatternOperationWrapper Pattern { get; }
    public IOperation Guard { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    private static ISwitchExpressionArmOperationWrapper();
    private ISwitchExpressionArmOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IPatternOperationWrapper get_Pattern();
    public IOperation get_Guard();
    public IOperation get_Value();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public static ISwitchExpressionArmOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISwitchExpressionArmOperationWrapper wrapper);
    public static ISwitchExpressionArmOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISwitchExpressionOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ArmsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<IOperation> Arms { get; }
    private static ISwitchExpressionOperationWrapper();
    private ISwitchExpressionOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Value();
    public ImmutableArray`1<IOperation> get_Arms();
    public static ISwitchExpressionOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISwitchExpressionOperationWrapper wrapper);
    public static ISwitchExpressionOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISwitchOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> CasesAccessor;
    private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<IOperation> Cases { get; }
    public ILabelSymbol ExitLabel { get; }
    private static ISwitchOperationWrapper();
    private ISwitchOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public ImmutableArray`1<IOperation> get_Cases();
    public ILabelSymbol get_ExitLabel();
    public static ISwitchOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISwitchOperationWrapper wrapper);
    public static ISwitchOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ISymbolInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, IOperation> ValueAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static ISymbolInitializerOperationWrapper();
    private ISymbolInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static ISymbolInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
    internal static ISymbolInitializerOperationWrapper FromUpcast(IOperation operation);
}
internal interface StyleCop.Analyzers.Lightup.ISyntaxWrapper`1 {
    public T SyntaxNode { get; }
    public abstract virtual T get_SyntaxNode();
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IThrowOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ExceptionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Exception { get; }
    private static IThrowOperationWrapper();
    private IThrowOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Exception();
    public static IThrowOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IThrowOperationWrapper wrapper);
    public static IThrowOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITranslatedQueryOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperationAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operation { get; }
    private static ITranslatedQueryOperationWrapper();
    private ITranslatedQueryOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operation();
    public static ITranslatedQueryOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITranslatedQueryOperationWrapper wrapper);
    public static ITranslatedQueryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITryOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> CatchesAccessor;
    private static Func`2<IOperation, IOperation> FinallyAccessor;
    private static Func`2<IOperation, ILabelSymbol> ExitLabelAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IBlockOperationWrapper Body { get; }
    public ImmutableArray`1<IOperation> Catches { get; }
    public IBlockOperationWrapper Finally { get; }
    public ILabelSymbol ExitLabel { get; }
    private static ITryOperationWrapper();
    private ITryOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IBlockOperationWrapper get_Body();
    public ImmutableArray`1<IOperation> get_Catches();
    public IBlockOperationWrapper get_Finally();
    public ILabelSymbol get_ExitLabel();
    public static ITryOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITryOperationWrapper wrapper);
    public static ITryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITupleBinaryOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> LeftOperandAccessor;
    private static Func`2<IOperation, IOperation> RightOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    private static ITupleBinaryOperationWrapper();
    private ITupleBinaryOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_OperatorKind();
    public IOperation get_LeftOperand();
    public IOperation get_RightOperand();
    public static ITupleBinaryOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITupleBinaryOperationWrapper wrapper);
    public static ITupleBinaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITupleOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> ElementsAccessor;
    private static Func`2<IOperation, ITypeSymbol> NaturalTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Elements { get; }
    public ITypeSymbol NaturalType { get; }
    private static ITupleOperationWrapper();
    private ITupleOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Elements();
    public ITypeSymbol get_NaturalType();
    public static ITupleOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITupleOperationWrapper wrapper);
    public static ITupleOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITypeOfOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> TypeOperandAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol TypeOperand { get; }
    private static ITypeOfOperationWrapper();
    private ITypeOfOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_TypeOperand();
    public static ITypeOfOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITypeOfOperationWrapper wrapper);
    public static ITypeOfOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITypeParameterObjectCreationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static ITypeParameterObjectCreationOperationWrapper();
    private ITypeParameterObjectCreationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static ITypeParameterObjectCreationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITypeParameterObjectCreationOperationWrapper wrapper);
    public static ITypeParameterObjectCreationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ITypeParameterSymbolExtensions : object {
    private static Func`2<ITypeParameterSymbol, bool> HasUnmanagedTypeConstraintAccessor;
    private static ITypeParameterSymbolExtensions();
    [ExtensionAttribute]
public static bool HasUnmanagedTypeConstraint(ITypeParameterSymbol symbol);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ITypePatternOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ITypeSymbol> MatchedTypeAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ITypeSymbol MatchedType { get; }
    public ITypeSymbol InputType { get; }
    public ITypeSymbol NarrowedType { get; }
    private static ITypePatternOperationWrapper();
    private ITypePatternOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ITypeSymbol get_MatchedType();
    public static ITypePatternOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(ITypePatternOperationWrapper wrapper);
    public ITypeSymbol get_InputType();
    public ITypeSymbol get_NarrowedType();
    public static ITypePatternOperationWrapper op_Explicit(IPatternOperationWrapper wrapper);
    public static IPatternOperationWrapper op_Implicit(ITypePatternOperationWrapper wrapper);
    public static ITypePatternOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ITypeSymbolExtensions : object {
    private static Func`2<ITypeSymbol, bool> IsTupleTypeAccessor;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static bool IsTupleType(ITypeSymbol symbol);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IUnaryOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, bool> IsLiftedAccessor;
    private static Func`2<IOperation, bool> IsCheckedAccessor;
    private static Func`2<IOperation, IMethodSymbol> OperatorMethodAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public object OperatorKind { get; }
    public IOperation Operand { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IMethodSymbol OperatorMethod { get; }
    private static IUnaryOperationWrapper();
    private IUnaryOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public object get_OperatorKind();
    public IOperation get_Operand();
    public bool get_IsLifted();
    public bool get_IsChecked();
    public IMethodSymbol get_OperatorMethod();
    public static IUnaryOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IUnaryOperationWrapper wrapper);
    public static IUnaryOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IUsingDeclarationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> DeclarationGroupAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IVariableDeclarationGroupOperationWrapper DeclarationGroup { get; }
    public bool IsAsynchronous { get; }
    private static IUsingDeclarationOperationWrapper();
    private IUsingDeclarationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IVariableDeclarationGroupOperationWrapper get_DeclarationGroup();
    public bool get_IsAsynchronous();
    public static IUsingDeclarationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IUsingDeclarationOperationWrapper wrapper);
    public static IUsingDeclarationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IUsingOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ResourcesAccessor;
    private static Func`2<IOperation, IOperation> BodyAccessor;
    private static Func`2<IOperation, ImmutableArray`1<ILocalSymbol>> LocalsAccessor;
    private static Func`2<IOperation, bool> IsAsynchronousAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Resources { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public bool IsAsynchronous { get; }
    private static IUsingOperationWrapper();
    private IUsingOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Resources();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public bool get_IsAsynchronous();
    public static IUsingOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IUsingOperationWrapper wrapper);
    public static IUsingOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IVariableDeclarationGroupOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeclarationsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Declarations { get; }
    private static IVariableDeclarationGroupOperationWrapper();
    private IVariableDeclarationGroupOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Declarations();
    public static IVariableDeclarationGroupOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IVariableDeclarationGroupOperationWrapper wrapper);
    public static IVariableDeclarationGroupOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IVariableDeclarationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> DeclaratorsAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IgnoredDimensionsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IOperation> Declarators { get; }
    public IVariableInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredDimensions { get; }
    private static IVariableDeclarationOperationWrapper();
    private IVariableDeclarationOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ImmutableArray`1<IOperation> get_Declarators();
    public IVariableInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_IgnoredDimensions();
    public static IVariableDeclarationOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IVariableDeclarationOperationWrapper wrapper);
    public static IVariableDeclarationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IVariableDeclaratorOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, ILocalSymbol> SymbolAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private static Func`2<IOperation, ImmutableArray`1<IOperation>> IgnoredArgumentsAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ILocalSymbol Symbol { get; }
    public IVariableInitializerOperationWrapper Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    private static IVariableDeclaratorOperationWrapper();
    private IVariableDeclaratorOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public ILocalSymbol get_Symbol();
    public IVariableInitializerOperationWrapper get_Initializer();
    public ImmutableArray`1<IOperation> get_IgnoredArguments();
    public static IVariableDeclaratorOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IVariableDeclaratorOperationWrapper wrapper);
    public static IVariableDeclaratorOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IVariableInitializerOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    private static IVariableInitializerOperationWrapper();
    private IVariableInitializerOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public static IVariableInitializerOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IVariableInitializerOperationWrapper wrapper);
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public IOperation get_Value();
    public static IVariableInitializerOperationWrapper op_Explicit(ISymbolInitializerOperationWrapper wrapper);
    public static ISymbolInitializerOperationWrapper op_Implicit(IVariableInitializerOperationWrapper wrapper);
    public static IVariableInitializerOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IWhileLoopOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> ConditionAccessor;
    private static Func`2<IOperation, bool> ConditionIsTopAccessor;
    private static Func`2<IOperation, bool> ConditionIsUntilAccessor;
    private static Func`2<IOperation, IOperation> IgnoredConditionAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Condition { get; }
    public bool ConditionIsTop { get; }
    public bool ConditionIsUntil { get; }
    public IOperation IgnoredCondition { get; }
    public object LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    private static IWhileLoopOperationWrapper();
    private IWhileLoopOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Condition();
    public bool get_ConditionIsTop();
    public bool get_ConditionIsUntil();
    public IOperation get_IgnoredCondition();
    public static IWhileLoopOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IWhileLoopOperationWrapper wrapper);
    public object get_LoopKind();
    public IOperation get_Body();
    public ImmutableArray`1<ILocalSymbol> get_Locals();
    public ILabelSymbol get_ContinueLabel();
    public ILabelSymbol get_ExitLabel();
    public static IWhileLoopOperationWrapper op_Explicit(ILoopOperationWrapper wrapper);
    public static ILoopOperationWrapper op_Implicit(IWhileLoopOperationWrapper wrapper);
    public static IWhileLoopOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.IWithOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<IOperation, IOperation> OperandAccessor;
    private static Func`2<IOperation, IMethodSymbol> CloneMethodAccessor;
    private static Func`2<IOperation, IOperation> InitializerAccessor;
    private IOperation operation;
    public IOperation WrappedOperation { get; }
    public ITypeSymbol Type { get; }
    public IOperation Operand { get; }
    public IMethodSymbol CloneMethod { get; }
    public IObjectOrCollectionInitializerOperationWrapper Initializer { get; }
    private static IWithOperationWrapper();
    private IWithOperationWrapper(IOperation operation);
    public IOperation get_WrappedOperation();
    public ITypeSymbol get_Type();
    public IOperation get_Operand();
    public IMethodSymbol get_CloneMethod();
    public IObjectOrCollectionInitializerOperationWrapper get_Initializer();
    public static IWithOperationWrapper op_Explicit(IOperationWrapper wrapper);
    public static IOperationWrapper op_Implicit(IWithOperationWrapper wrapper);
    public static IWithOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
internal static class StyleCop.Analyzers.Lightup.LanguageVersionEx : object {
    public static LanguageVersion Default;
    public static LanguageVersion CSharp7;
    public static LanguageVersion CSharp7_1;
    public static LanguageVersion CSharp7_2;
    public static LanguageVersion CSharp7_3;
    public static LanguageVersion CSharp8;
    public static LanguageVersion CSharp9;
    public static LanguageVersion CSharp10;
    public static LanguageVersion CSharp11;
    public static LanguageVersion CSharp12;
    public static LanguageVersion LatestMajor;
    public static LanguageVersion Preview;
    public static LanguageVersion Latest;
}
internal static class StyleCop.Analyzers.Lightup.LightupHelpers : object {
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<Type, bool>> SupportedObjectWrappers;
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<SyntaxKind, bool>> SupportedSyntaxWrappers;
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<OperationKind, bool>> SupportedOperationWrappers;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp7>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp71>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp72>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp73>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp8>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp9>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp10>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp11>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp12>k__BackingField;
    public static bool SupportsCSharp7 { get; }
    public static bool SupportsCSharp71 { get; }
    public static bool SupportsCSharp72 { get; }
    public static bool SupportsCSharp73 { get; }
    public static bool SupportsCSharp8 { get; }
    public static bool SupportsCSharp9 { get; }
    public static bool SupportsCSharp10 { get; }
    public static bool SupportsCSharp11 { get; }
    public static bool SupportsCSharp12 { get; }
    public static bool SupportsIOperation { get; }
    private static LightupHelpers();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp7();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp71();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp72();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp73();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp8();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp9();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp10();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp11();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp12();
    public static bool get_SupportsIOperation();
    internal static bool CanWrapObject(object obj, Type underlyingType);
    internal static bool CanWrapNode(SyntaxNode node, Type underlyingType);
    internal static bool CanWrapOperation(IOperation operation, Type underlyingType);
    internal static Func`2<TOperation, TProperty> CreateOperationPropertyAccessor(Type type, string propertyName);
    internal static Func`2<TOperation, ImmutableArray`1<IOperation>> CreateOperationListPropertyAccessor(Type type, string propertyName);
    internal static Func`1<TProperty> CreateStaticPropertyAccessor(Type type, string propertyName);
    internal static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, TArg, TProperty> CreateSyntaxPropertyAccessor(Type type, Type argumentType, string accessorMethodName);
    internal static TryGetValueAccessor`3<TSyntax, TKey, TValue> CreateTryGetValueAccessor(Type type, Type keyType, string methodName);
    internal static Func`2<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>> CreateSeparatedSyntaxListPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>, TSyntax> CreateSeparatedSyntaxListWithPropertyAccessor(Type type, string propertyName);
    private static bool ValidatePropertyType(Type returnType, Type actualType);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateOperationPropertyAccessor>g__FallbackAccessor|35_0(TOperation syntax);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOperation> <CreateOperationListPropertyAccessor>g__FallbackAccessor|36_0(TOperation syntax);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateStaticPropertyAccessor>g__FallbackAccessor|37_0();
    [CompilerGeneratedAttribute]
internal static TProperty <CreateSyntaxPropertyAccessor>g__FallbackAccessor|38_0(TSyntax syntax);
    [CompilerGeneratedAttribute]
internal static TProperty <CreateSyntaxPropertyAccessor>g__FallbackAccessor|39_0(TSyntax syntax, TArg argument);
    [CompilerGeneratedAttribute]
internal static bool <CreateTryGetValueAccessor>g__FallbackAccessor|40_0(TSyntax syntax, TKey key, TValue& value);
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxListWrapper`1<TProperty> <CreateSeparatedSyntaxListPropertyAccessor>g__FallbackAccessor|41_0(TSyntax syntax);
    [CompilerGeneratedAttribute]
internal static TSyntax <CreateSyntaxWithPropertyAccessor>g__FallbackAccessor|42_0(TSyntax syntax, TProperty newValue);
    [CompilerGeneratedAttribute]
internal static TSyntax <CreateSeparatedSyntaxListWithPropertyAccessor>g__FallbackAccessor|43_0(TSyntax syntax, SeparatedSyntaxListWrapper`1<TProperty> newValue);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.LineDirectivePositionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> LineAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CommaTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CharacterAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithLineAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCommaTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCharacterAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken Line { get; }
    public SyntaxToken CommaToken { get; }
    public SyntaxToken Character { get; }
    public SyntaxToken CloseParenToken { get; }
    private static LineDirectivePositionSyntaxWrapper();
    private LineDirectivePositionSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_Line();
    public SyntaxToken get_CommaToken();
    public SyntaxToken get_Character();
    public SyntaxToken get_CloseParenToken();
    public static LineDirectivePositionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(LineDirectivePositionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineDirectivePositionSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public LineDirectivePositionSyntaxWrapper WithLine(SyntaxToken line);
    public LineDirectivePositionSyntaxWrapper WithCommaToken(SyntaxToken commaToken);
    public LineDirectivePositionSyntaxWrapper WithCharacter(SyntaxToken character);
    public LineDirectivePositionSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.LineOrSpanDirectiveTriviaSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> LineKeywordAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> FileAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithLineKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithFileAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken LineKeyword { get; }
    public SyntaxToken File { get; }
    private static LineOrSpanDirectiveTriviaSyntaxWrapper();
    private LineOrSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_LineKeyword();
    public SyntaxToken get_File();
    public static LineOrSpanDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static DirectiveTriviaSyntax op_Implicit(LineOrSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineOrSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword);
    public LineOrSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file);
    internal static LineOrSpanDirectiveTriviaSyntaxWrapper FromUpcast(DirectiveTriviaSyntax node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.LineSpanDirectiveTriviaSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, CSharpSyntaxNode> StartAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> MinusTokenAccessor;
    private static Func`2<DirectiveTriviaSyntax, CSharpSyntaxNode> EndAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> CharacterOffsetAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithHashTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithLineKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, CSharpSyntaxNode, DirectiveTriviaSyntax> WithStartAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithMinusTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, CSharpSyntaxNode, DirectiveTriviaSyntax> WithEndAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithCharacterOffsetAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithFileAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithEndOfDirectiveTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, bool, DirectiveTriviaSyntax> WithIsActiveAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken HashToken { get; }
    public SyntaxToken LineKeyword { get; }
    public LineDirectivePositionSyntaxWrapper Start { get; }
    public SyntaxToken MinusToken { get; }
    public LineDirectivePositionSyntaxWrapper End { get; }
    public SyntaxToken CharacterOffset { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    private static LineSpanDirectiveTriviaSyntaxWrapper();
    private LineSpanDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_HashToken();
    public SyntaxToken get_LineKeyword();
    public LineDirectivePositionSyntaxWrapper get_Start();
    public SyntaxToken get_MinusToken();
    public LineDirectivePositionSyntaxWrapper get_End();
    public SyntaxToken get_CharacterOffset();
    public SyntaxToken get_File();
    public SyntaxToken get_EndOfDirectiveToken();
    public bool get_IsActive();
    public static LineSpanDirectiveTriviaSyntaxWrapper op_Explicit(LineOrSpanDirectiveTriviaSyntaxWrapper node);
    public static LineSpanDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static LineOrSpanDirectiveTriviaSyntaxWrapper op_Implicit(LineSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static DirectiveTriviaSyntax op_Implicit(LineSpanDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LineSpanDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithLineKeyword(SyntaxToken lineKeyword);
    public LineSpanDirectiveTriviaSyntaxWrapper WithStart(LineDirectivePositionSyntaxWrapper start);
    public LineSpanDirectiveTriviaSyntaxWrapper WithMinusToken(SyntaxToken minusToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithEnd(LineDirectivePositionSyntaxWrapper end);
    public LineSpanDirectiveTriviaSyntaxWrapper WithCharacterOffset(SyntaxToken characterOffset);
    public LineSpanDirectiveTriviaSyntaxWrapper WithFile(SyntaxToken file);
    public LineSpanDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public LineSpanDirectiveTriviaSyntaxWrapper WithIsActive(bool isActive);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.LocalDeclarationStatementSyntaxExtensions : object {
    private static Func`2<LocalDeclarationStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`2<LocalDeclarationStatementSyntax, SyntaxToken> UsingKeywordAccessor;
    private static Func`3<LocalDeclarationStatementSyntax, SyntaxToken, LocalDeclarationStatementSyntax> WithAwaitKeywordAccessor;
    private static Func`3<LocalDeclarationStatementSyntax, SyntaxToken, LocalDeclarationStatementSyntax> WithUsingKeywordAccessor;
    private static LocalDeclarationStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(LocalDeclarationStatementSyntax syntax);
    [ExtensionAttribute]
public static SyntaxToken UsingKeyword(LocalDeclarationStatementSyntax syntax);
    [ExtensionAttribute]
public static LocalDeclarationStatementSyntax WithAwaitKeyword(LocalDeclarationStatementSyntax syntax, SyntaxToken awaitKeyword);
    [ExtensionAttribute]
public static LocalDeclarationStatementSyntax WithUsingKeyword(LocalDeclarationStatementSyntax syntax, SyntaxToken usingKeyword);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.LocalFunctionStatementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<StatementSyntax, TypeSyntax> ReturnTypeAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> IdentifierAccessor;
    private static Func`2<StatementSyntax, TypeParameterListSyntax> TypeParameterListAccessor;
    private static Func`2<StatementSyntax, ParameterListSyntax> ParameterListAccessor;
    private static Func`2<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>> ConstraintClausesAccessor;
    private static Func`2<StatementSyntax, BlockSyntax> BodyAccessor;
    private static Func`2<StatementSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> SemicolonTokenAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxTokenList, StatementSyntax> WithModifiersAccessor;
    private static Func`3<StatementSyntax, TypeSyntax, StatementSyntax> WithReturnTypeAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithIdentifierAccessor;
    private static Func`3<StatementSyntax, TypeParameterListSyntax, StatementSyntax> WithTypeParameterListAccessor;
    private static Func`3<StatementSyntax, ParameterListSyntax, StatementSyntax> WithParameterListAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, StatementSyntax> WithConstraintClausesAccessor;
    private static Func`3<StatementSyntax, BlockSyntax, StatementSyntax> WithBodyAccessor;
    private static Func`3<StatementSyntax, ArrowExpressionClauseSyntax, StatementSyntax> WithExpressionBodyAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithSemicolonTokenAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    private static LocalFunctionStatementSyntaxWrapper();
    private LocalFunctionStatementSyntaxWrapper(StatementSyntax node);
    public LocalFunctionStatementSyntaxWrapper AddModifiers(SyntaxToken[] items);
    public LocalFunctionStatementSyntaxWrapper AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddParameterListParameters(ParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddBodyStatements(StatementSyntax[] items);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public SyntaxToken get_SemicolonToken();
    public static LocalFunctionStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(LocalFunctionStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LocalFunctionStatementSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public LocalFunctionStatementSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public LocalFunctionStatementSyntaxWrapper WithReturnType(TypeSyntax returnType);
    public LocalFunctionStatementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public LocalFunctionStatementSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public LocalFunctionStatementSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public LocalFunctionStatementSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public LocalFunctionStatementSyntaxWrapper WithBody(BlockSyntax body);
    public LocalFunctionStatementSyntaxWrapper WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public LocalFunctionStatementSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.MemberDeclarationSyntaxExtensions : object {
    private static Func`2<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`2<MemberDeclarationSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, MemberDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<MemberDeclarationSyntax, SyntaxTokenList, MemberDeclarationSyntax> WithModifiersAccessor;
    private static MemberDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> AttributeLists(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
public static SyntaxTokenList Modifiers(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithAttributeLists(MemberDeclarationSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static MemberDeclarationSyntax WithModifiers(MemberDeclarationSyntax syntax, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static MemberDeclarationSyntax AddAttributeLists(MemberDeclarationSyntax syntax, AttributeListSyntax[] items);
    [ExtensionAttribute]
public static MemberDeclarationSyntax AddModifiers(MemberDeclarationSyntax syntax, SyntaxToken[] items);
}
internal static class StyleCop.Analyzers.Lightup.MethodKindEx : object {
    public static MethodKind LocalFunction;
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.NullableDirectiveTriviaSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> NullableKeywordAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> SettingTokenAccessor;
    private static Func`2<DirectiveTriviaSyntax, SyntaxToken> TargetTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithHashTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithNullableKeywordAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithSettingTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithTargetTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, SyntaxToken, DirectiveTriviaSyntax> WithEndOfDirectiveTokenAccessor;
    private static Func`3<DirectiveTriviaSyntax, bool, DirectiveTriviaSyntax> WithIsActiveAccessor;
    private DirectiveTriviaSyntax node;
    public DirectiveTriviaSyntax SyntaxNode { get; }
    public SyntaxToken HashToken { get; }
    public SyntaxToken NullableKeyword { get; }
    public SyntaxToken SettingToken { get; }
    public SyntaxToken TargetToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    private static NullableDirectiveTriviaSyntaxWrapper();
    private NullableDirectiveTriviaSyntaxWrapper(DirectiveTriviaSyntax node);
    public sealed virtual DirectiveTriviaSyntax get_SyntaxNode();
    public SyntaxToken get_HashToken();
    public SyntaxToken get_NullableKeyword();
    public SyntaxToken get_SettingToken();
    public SyntaxToken get_TargetToken();
    public SyntaxToken get_EndOfDirectiveToken();
    public bool get_IsActive();
    public static NullableDirectiveTriviaSyntaxWrapper op_Explicit(SyntaxNode node);
    public static DirectiveTriviaSyntax op_Implicit(NullableDirectiveTriviaSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public NullableDirectiveTriviaSyntaxWrapper WithHashToken(SyntaxToken hashToken);
    public NullableDirectiveTriviaSyntaxWrapper WithNullableKeyword(SyntaxToken nullableKeyword);
    public NullableDirectiveTriviaSyntaxWrapper WithSettingToken(SyntaxToken settingToken);
    public NullableDirectiveTriviaSyntaxWrapper WithTargetToken(SyntaxToken targetToken);
    public NullableDirectiveTriviaSyntaxWrapper WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public NullableDirectiveTriviaSyntaxWrapper WithIsActive(bool isActive);
}
internal static class StyleCop.Analyzers.Lightup.OperationKindEx : object {
    public static OperationKind Invalid;
    public static OperationKind Block;
    public static OperationKind VariableDeclarationGroup;
    public static OperationKind Switch;
    public static OperationKind Loop;
    public static OperationKind Labeled;
    public static OperationKind Branch;
    public static OperationKind Empty;
    public static OperationKind Return;
    public static OperationKind YieldBreak;
    public static OperationKind Lock;
    public static OperationKind Try;
    public static OperationKind Using;
    public static OperationKind YieldReturn;
    public static OperationKind ExpressionStatement;
    public static OperationKind LocalFunction;
    public static OperationKind Stop;
    public static OperationKind End;
    public static OperationKind RaiseEvent;
    public static OperationKind Literal;
    public static OperationKind Conversion;
    public static OperationKind Invocation;
    public static OperationKind ArrayElementReference;
    public static OperationKind LocalReference;
    public static OperationKind ParameterReference;
    public static OperationKind FieldReference;
    public static OperationKind MethodReference;
    public static OperationKind PropertyReference;
    public static OperationKind EventReference;
    public static OperationKind Unary;
    public static OperationKind Binary;
    public static OperationKind Conditional;
    public static OperationKind Coalesce;
    public static OperationKind AnonymousFunction;
    public static OperationKind ObjectCreation;
    public static OperationKind TypeParameterObjectCreation;
    public static OperationKind ArrayCreation;
    public static OperationKind InstanceReference;
    public static OperationKind IsType;
    public static OperationKind Await;
    public static OperationKind SimpleAssignment;
    public static OperationKind CompoundAssignment;
    public static OperationKind Parenthesized;
    public static OperationKind EventAssignment;
    public static OperationKind ConditionalAccess;
    public static OperationKind ConditionalAccessInstance;
    public static OperationKind InterpolatedString;
    public static OperationKind AnonymousObjectCreation;
    public static OperationKind ObjectOrCollectionInitializer;
    public static OperationKind MemberInitializer;
    public static OperationKind CollectionElementInitializer;
    public static OperationKind NameOf;
    public static OperationKind Tuple;
    public static OperationKind DynamicObjectCreation;
    public static OperationKind DynamicMemberReference;
    public static OperationKind DynamicInvocation;
    public static OperationKind DynamicIndexerAccess;
    public static OperationKind TranslatedQuery;
    public static OperationKind DelegateCreation;
    public static OperationKind DefaultValue;
    public static OperationKind TypeOf;
    public static OperationKind SizeOf;
    public static OperationKind AddressOf;
    public static OperationKind IsPattern;
    public static OperationKind Increment;
    public static OperationKind Throw;
    public static OperationKind Decrement;
    public static OperationKind DeconstructionAssignment;
    public static OperationKind DeclarationExpression;
    public static OperationKind OmittedArgument;
    public static OperationKind FieldInitializer;
    public static OperationKind VariableInitializer;
    public static OperationKind PropertyInitializer;
    public static OperationKind ParameterInitializer;
    public static OperationKind ArrayInitializer;
    public static OperationKind VariableDeclarator;
    public static OperationKind VariableDeclaration;
    public static OperationKind Argument;
    public static OperationKind CatchClause;
    public static OperationKind SwitchCase;
    public static OperationKind CaseClause;
    public static OperationKind InterpolatedStringText;
    public static OperationKind Interpolation;
    public static OperationKind ConstantPattern;
    public static OperationKind DeclarationPattern;
    public static OperationKind TupleBinary;
    public static OperationKind MethodBody;
    public static OperationKind ConstructorBody;
    public static OperationKind Discard;
    public static OperationKind FlowCapture;
    public static OperationKind FlowCaptureReference;
    public static OperationKind IsNull;
    public static OperationKind CaughtException;
    public static OperationKind StaticLocalInitializationSemaphore;
    public static OperationKind FlowAnonymousFunction;
    public static OperationKind CoalesceAssignment;
    public static OperationKind Range;
    public static OperationKind ReDim;
    public static OperationKind ReDimClause;
    public static OperationKind RecursivePattern;
    public static OperationKind DiscardPattern;
    public static OperationKind SwitchExpression;
    public static OperationKind SwitchExpressionArm;
    public static OperationKind PropertySubpattern;
    public static OperationKind UsingDeclaration;
    public static OperationKind NegatedPattern;
    public static OperationKind BinaryPattern;
    public static OperationKind TypePattern;
    public static OperationKind RelationalPattern;
    public static OperationKind With;
}
internal static class StyleCop.Analyzers.Lightup.OperationWrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static OperationWrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ParenthesizedPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public SyntaxToken CloseParenToken { get; }
    private static ParenthesizedPatternSyntaxWrapper();
    private ParenthesizedPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public PatternSyntaxWrapper get_Pattern();
    public SyntaxToken get_CloseParenToken();
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static ParenthesizedPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ParenthesizedPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedPatternSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ParenthesizedPatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public ParenthesizedPatternSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ParenthesizedVariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>> VariablesAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>, CSharpSyntaxNode> WithVariablesAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> Variables { get; }
    public SyntaxToken CloseParenToken { get; }
    private static ParenthesizedVariableDesignationSyntaxWrapper();
    private ParenthesizedVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public ParenthesizedVariableDesignationSyntaxWrapper AddVariables(VariableDesignationSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> get_Variables();
    public SyntaxToken get_CloseParenToken();
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedVariableDesignationSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ParenthesizedVariableDesignationSyntaxWrapper WithVariables(SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> variables);
    public ParenthesizedVariableDesignationSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.PatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static PatternSyntaxWrapper();
    private PatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static PatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static PatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(PatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(PatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static PatternSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.PositionalPatternClauseSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>> SubpatternsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> WithSubpatternsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> Subpatterns { get; }
    public SyntaxToken CloseParenToken { get; }
    private static PositionalPatternClauseSyntaxWrapper();
    private PositionalPatternClauseSyntaxWrapper(CSharpSyntaxNode node);
    public PositionalPatternClauseSyntaxWrapper AddSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> get_Subpatterns();
    public SyntaxToken get_CloseParenToken();
    public static PositionalPatternClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(PositionalPatternClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PositionalPatternClauseSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public PositionalPatternClauseSyntaxWrapper WithSubpatterns(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public PositionalPatternClauseSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.PrimaryConstructorBaseTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<BaseTypeSyntax, ArgumentListSyntax> ArgumentListAccessor;
    private static Func`3<BaseTypeSyntax, TypeSyntax, BaseTypeSyntax> WithTypeAccessor;
    private static Func`3<BaseTypeSyntax, ArgumentListSyntax, BaseTypeSyntax> WithArgumentListAccessor;
    private BaseTypeSyntax node;
    public BaseTypeSyntax SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArgumentList { get; }
    private static PrimaryConstructorBaseTypeSyntaxWrapper();
    private PrimaryConstructorBaseTypeSyntaxWrapper(BaseTypeSyntax node);
    public sealed virtual BaseTypeSyntax get_SyntaxNode();
    public TypeSyntax get_Type();
    public ArgumentListSyntax get_ArgumentList();
    public static PrimaryConstructorBaseTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static BaseTypeSyntax op_Implicit(PrimaryConstructorBaseTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PrimaryConstructorBaseTypeSyntaxWrapper WithType(TypeSyntax type);
    public PrimaryConstructorBaseTypeSyntaxWrapper WithArgumentList(ArgumentListSyntax argumentList);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.PropertyPatternClauseSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenBraceTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>> SubpatternsAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseBraceTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenBraceTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> WithSubpatternsAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseBraceTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> Subpatterns { get; }
    public SyntaxToken CloseBraceToken { get; }
    private static PropertyPatternClauseSyntaxWrapper();
    private PropertyPatternClauseSyntaxWrapper(CSharpSyntaxNode node);
    public PropertyPatternClauseSyntaxWrapper AddSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> get_Subpatterns();
    public SyntaxToken get_CloseBraceToken();
    public static PropertyPatternClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(PropertyPatternClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public PropertyPatternClauseSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public PropertyPatternClauseSyntaxWrapper WithSubpatterns(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public PropertyPatternClauseSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RangeExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> LeftOperandAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> RightOperandAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithLeftOperandAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOperatorTokenAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithRightOperandAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax LeftOperand { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax RightOperand { get; }
    private static RangeExpressionSyntaxWrapper();
    private RangeExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_LeftOperand();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_RightOperand();
    public static RangeExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(RangeExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RangeExpressionSyntaxWrapper WithLeftOperand(ExpressionSyntax leftOperand);
    public RangeExpressionSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public RangeExpressionSyntaxWrapper WithRightOperand(ExpressionSyntax rightOperand);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RecordDeclarationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeDeclarationSyntax, SyntaxToken> ClassOrStructKeywordAccessor;
    private static Func`2<TypeDeclarationSyntax, ParameterListSyntax> ParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<AttributeListSyntax>, TypeDeclarationSyntax> WithAttributeListsAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxTokenList, TypeDeclarationSyntax> WithModifiersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithClassOrStructKeywordAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithIdentifierAccessor;
    private static Func`3<TypeDeclarationSyntax, TypeParameterListSyntax, TypeDeclarationSyntax> WithTypeParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, ParameterListSyntax, TypeDeclarationSyntax> WithParameterListAccessor;
    private static Func`3<TypeDeclarationSyntax, BaseListSyntax, TypeDeclarationSyntax> WithBaseListAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, TypeDeclarationSyntax> WithConstraintClausesAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxList`1<MemberDeclarationSyntax>, TypeDeclarationSyntax> WithMembersAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithCloseBraceTokenAccessor;
    private static Func`3<TypeDeclarationSyntax, SyntaxToken, TypeDeclarationSyntax> WithSemicolonTokenAccessor;
    private TypeDeclarationSyntax node;
    public TypeDeclarationSyntax SyntaxNode { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken ClassOrStructKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    private static RecordDeclarationSyntaxWrapper();
    private RecordDeclarationSyntaxWrapper(TypeDeclarationSyntax node);
    public sealed virtual TypeDeclarationSyntax get_SyntaxNode();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Keyword();
    public SyntaxToken get_ClassOrStructKeyword();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public BaseListSyntax get_BaseList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    public static RecordDeclarationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeDeclarationSyntax op_Implicit(RecordDeclarationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RecordDeclarationSyntaxWrapper WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public RecordDeclarationSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public RecordDeclarationSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public RecordDeclarationSyntaxWrapper WithClassOrStructKeyword(SyntaxToken classOrStructKeyword);
    public RecordDeclarationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public RecordDeclarationSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public RecordDeclarationSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public RecordDeclarationSyntaxWrapper WithBaseList(BaseListSyntax baseList);
    public RecordDeclarationSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public RecordDeclarationSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public RecordDeclarationSyntaxWrapper WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public RecordDeclarationSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
    public RecordDeclarationSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RecursivePatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PositionalPatternClauseAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PropertyPatternClauseAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPositionalPatternClauseAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPropertyPatternClauseAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public PositionalPatternClauseSyntaxWrapper PositionalPatternClause { get; }
    public PropertyPatternClauseSyntaxWrapper PropertyPatternClause { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static RecursivePatternSyntaxWrapper();
    private RecursivePatternSyntaxWrapper(CSharpSyntaxNode node);
    public RecursivePatternSyntaxWrapper AddPositionalPatternClauseSubpatterns(SubpatternSyntaxWrapper[] items);
    public RecursivePatternSyntaxWrapper AddPropertyPatternClauseSubpatterns(SubpatternSyntaxWrapper[] items);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public PositionalPatternClauseSyntaxWrapper get_PositionalPatternClause();
    public PropertyPatternClauseSyntaxWrapper get_PropertyPatternClause();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static RecursivePatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static RecursivePatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static RecursivePatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(RecursivePatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RecursivePatternSyntaxWrapper WithType(TypeSyntax type);
    public RecursivePatternSyntaxWrapper WithPositionalPatternClause(PositionalPatternClauseSyntaxWrapper positionalPatternClause);
    public RecursivePatternSyntaxWrapper WithPropertyPatternClause(PropertyPatternClauseSyntaxWrapper propertyPatternClause);
    public RecursivePatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RefExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithRefKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static RefExpressionSyntaxWrapper();
    private RefExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public ExpressionSyntax get_Expression();
    public static RefExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(RefExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefExpressionSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RefTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> ReadOnlyKeywordAccessor;
    private static Func`2<TypeSyntax, TypeSyntax> TypeAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithRefKeywordAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithReadOnlyKeywordAccessor;
    private static Func`3<TypeSyntax, TypeSyntax, TypeSyntax> WithTypeAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public SyntaxToken ReadOnlyKeyword { get; }
    public TypeSyntax Type { get; }
    private static RefTypeSyntaxWrapper();
    private RefTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public SyntaxToken get_ReadOnlyKeyword();
    public TypeSyntax get_Type();
    public static RefTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(RefTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefTypeSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefTypeSyntaxWrapper WithReadOnlyKeyword(SyntaxToken readOnlyKeyword);
    public RefTypeSyntaxWrapper WithType(TypeSyntax type);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.RelationalPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Expression { get; }
    private static RelationalPatternSyntaxWrapper();
    private RelationalPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Expression();
    public static RelationalPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static RelationalPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static RelationalPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(RelationalPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RelationalPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public RelationalPatternSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[DefaultMemberAttribute("Item")]
internal abstract class StyleCop.Analyzers.Lightup.SeparatedSyntaxListWrapper`1 : object {
    private static SyntaxWrapper`1<TNode> SyntaxWrapper;
    [CompilerGeneratedAttribute]
private static SeparatedSyntaxListWrapper`1<TNode> <UnsupportedEmpty>k__BackingField;
    public static SeparatedSyntaxListWrapper`1<TNode> UnsupportedEmpty { get; }
    public int Count { get; }
    public TextSpan FullSpan { get; }
    public int SeparatorCount { get; }
    public TextSpan Span { get; }
    [EditorBrowsableAttribute("1")]
public object UnderlyingList { get; }
    public TNode Item { get; }
    private static SeparatedSyntaxListWrapper`1();
    [CompilerGeneratedAttribute]
public static SeparatedSyntaxListWrapper`1<TNode> get_UnsupportedEmpty();
    public abstract virtual int get_Count();
    public abstract virtual TextSpan get_FullSpan();
    public abstract virtual int get_SeparatorCount();
    public abstract virtual TextSpan get_Span();
    public abstract virtual object get_UnderlyingList();
    public abstract virtual TNode get_Item(int index);
    public static bool op_Equality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public SeparatedSyntaxListWrapper`1<TNode> Add(TNode node);
    public SeparatedSyntaxListWrapper`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public abstract virtual bool Any();
    public abstract virtual bool Contains(TNode node);
    public sealed virtual bool Equals(SeparatedSyntaxListWrapper`1<TNode> other);
    public virtual bool Equals(object obj);
    public abstract virtual TNode First();
    public abstract virtual TNode FirstOrDefault();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual int GetHashCode();
    public abstract virtual SyntaxToken GetSeparator(int index);
    public abstract virtual IEnumerable`1<SyntaxToken> GetSeparators();
    public abstract virtual SyntaxNodeOrTokenList GetWithSeparators();
    public abstract virtual int IndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int IndexOf(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Insert(int index, TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    public abstract virtual TNode Last();
    public abstract virtual int LastIndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int LastIndexOf(TNode node);
    public abstract virtual TNode LastOrDefault();
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Remove(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> RemoveAt(int index);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
    public abstract virtual string ToFullString();
    public abstract virtual string ToString();
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.SingleVariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Identifier { get; }
    private static SingleVariableDesignationSyntaxWrapper();
    private SingleVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Identifier();
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SingleVariableDesignationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.StackAllocArrayCreationExpressionSyntaxExtensions : object {
    private static Func`2<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax, StackAllocArrayCreationExpressionSyntax> WithInitializerAccessor;
    private static StackAllocArrayCreationExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static InitializerExpressionSyntax Initializer(StackAllocArrayCreationExpressionSyntax syntax);
    [ExtensionAttribute]
public static StackAllocArrayCreationExpressionSyntax WithInitializer(StackAllocArrayCreationExpressionSyntax syntax, InitializerExpressionSyntax initializer);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.StatementSyntaxExtensions : object {
    private static Func`2<StatementSyntax, SyntaxList`1<AttributeListSyntax>> AttributeListsAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<AttributeListSyntax>, StatementSyntax> WithAttributeListsAccessor;
    private static StatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> AttributeLists(StatementSyntax syntax);
    [ExtensionAttribute]
public static StatementSyntax WithAttributeLists(StatementSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static StatementSyntax AddAttributeLists(StatementSyntax syntax, AttributeListSyntax[] items);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.SubpatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> ExpressionColonAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithExpressionColonAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public BaseExpressionColonSyntaxWrapper ExpressionColon { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static SubpatternSyntaxWrapper();
    private SubpatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public BaseExpressionColonSyntaxWrapper get_ExpressionColon();
    public PatternSyntaxWrapper get_Pattern();
    public static SubpatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(SubpatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SubpatternSyntaxWrapper WithExpressionColon(BaseExpressionColonSyntaxWrapper expressionColon);
    public SubpatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.SwitchExpressionArmSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> WhenClauseAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> EqualsGreaterThanTokenAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithWhenClauseAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithEqualsGreaterThanTokenAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public WhenClauseSyntaxWrapper WhenClause { get; }
    public SyntaxToken EqualsGreaterThanToken { get; }
    public ExpressionSyntax Expression { get; }
    private static SwitchExpressionArmSyntaxWrapper();
    private SwitchExpressionArmSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public PatternSyntaxWrapper get_Pattern();
    public WhenClauseSyntaxWrapper get_WhenClause();
    public SyntaxToken get_EqualsGreaterThanToken();
    public ExpressionSyntax get_Expression();
    public static SwitchExpressionArmSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(SwitchExpressionArmSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SwitchExpressionArmSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public SwitchExpressionArmSyntaxWrapper WithWhenClause(WhenClauseSyntaxWrapper whenClause);
    public SwitchExpressionArmSyntaxWrapper WithEqualsGreaterThanToken(SyntaxToken equalsGreaterThanToken);
    public SwitchExpressionArmSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.SwitchExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> GoverningExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> SwitchKeywordAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBraceTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper>> ArmsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBraceTokenAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithGoverningExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithSwitchKeywordAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBraceTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper>, ExpressionSyntax> WithArmsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBraceTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax GoverningExpression { get; }
    public SyntaxToken SwitchKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> Arms { get; }
    public SyntaxToken CloseBraceToken { get; }
    private static SwitchExpressionSyntaxWrapper();
    private SwitchExpressionSyntaxWrapper(ExpressionSyntax node);
    public SwitchExpressionSyntaxWrapper AddArms(SwitchExpressionArmSyntaxWrapper[] arms);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_GoverningExpression();
    public SyntaxToken get_SwitchKeyword();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> get_Arms();
    public SyntaxToken get_CloseBraceToken();
    public static SwitchExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(SwitchExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SwitchExpressionSyntaxWrapper WithGoverningExpression(ExpressionSyntax governingExpression);
    public SwitchExpressionSyntaxWrapper WithSwitchKeyword(SyntaxToken switchKeyword);
    public SwitchExpressionSyntaxWrapper WithOpenBraceToken(SyntaxToken openBraceToken);
    public SwitchExpressionSyntaxWrapper WithArms(SeparatedSyntaxListWrapper`1<SwitchExpressionArmSyntaxWrapper> arms);
    public SwitchExpressionSyntaxWrapper WithCloseBraceToken(SyntaxToken closeBraceToken);
}
internal static class StyleCop.Analyzers.Lightup.SymbolDisplayLocalOptionsEx : object {
    public static SymbolDisplayLocalOptions IncludeRef;
}
internal static class StyleCop.Analyzers.Lightup.SymbolDisplayMemberOptionsEx : object {
    public static SymbolDisplayMemberOptions IncludeRef;
}
internal static class StyleCop.Analyzers.Lightup.SymbolKindEx : object {
    public static SymbolKind Discard;
}
internal static class StyleCop.Analyzers.Lightup.SyntaxFactoryEx : object {
    private static Func`2<SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> PositionalPatternClauseAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, SyntaxToken, CSharpSyntaxNode> PositionalPatternClauseAccessor2;
    private static Func`2<SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, CSharpSyntaxNode> PropertyPatternClauseAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper>, SyntaxToken, CSharpSyntaxNode> PropertyPatternClauseAccessor2;
    private static Func`2<TypeSyntax, CSharpSyntaxNode> TupleElementAccessor1;
    private static Func`3<TypeSyntax, SyntaxToken, CSharpSyntaxNode> TupleElementAccessor2;
    private static Func`2<SeparatedSyntaxList`1<ArgumentSyntax>, ExpressionSyntax> TupleExpressionAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxList`1<ArgumentSyntax>, SyntaxToken, ExpressionSyntax> TupleExpressionAccessor2;
    private static Func`2<SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, TypeSyntax> TupleTypeAccessor1;
    private static Func`4<SyntaxToken, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, SyntaxToken, TypeSyntax> TupleTypeAccessor2;
    private static SyntaxFactoryEx();
    public static PositionalPatternClauseSyntaxWrapper PositionalPatternClause(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public static PositionalPatternClauseSyntaxWrapper PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns, SyntaxToken closeParenToken);
    public static PropertyPatternClauseSyntaxWrapper PropertyPatternClause(SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns);
    public static PropertyPatternClauseSyntaxWrapper PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxListWrapper`1<SubpatternSyntaxWrapper> subpatterns, SyntaxToken closeBraceToken);
    public static TupleElementSyntaxWrapper TupleElement(TypeSyntax type);
    public static TupleElementSyntaxWrapper TupleElement(TypeSyntax type, SyntaxToken identifier);
    public static TupleExpressionSyntaxWrapper TupleExpression(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public static TupleExpressionSyntaxWrapper TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static TupleTypeSyntaxWrapper TupleType(SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements);
    public static TupleTypeSyntaxWrapper TupleType(SyntaxToken openParenToken, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements, SyntaxToken closeParenToken);
    private static Func`2<T, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
    private static Func`3<T1, T2, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
    private static Func`4<T1, T2, T3, TResult> ThrowNotSupportedOnFallback(string typeName, string methodName);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.SyntaxFactsEx : object {
    private static Func`2<SyntaxNode, string> TryGetInferredMemberNameAccessor;
    private static Func`2<string, bool> IsReservedTupleElementNameAccessor;
    private static SyntaxFactsEx();
    [ExtensionAttribute]
public static string TryGetInferredMemberName(SyntaxNode syntax);
    public static bool IsReservedTupleElementName(string elementName);
    [CompilerGeneratedAttribute]
internal static string <.cctor>g__FallbackAccessor|2_0(SyntaxNode syntax);
}
internal static class StyleCop.Analyzers.Lightup.SyntaxKindEx : object {
    public static SyntaxKind DotDotToken;
    public static SyntaxKind QuestionQuestionEqualsToken;
    public static SyntaxKind OrKeyword;
    public static SyntaxKind AndKeyword;
    public static SyntaxKind NotKeyword;
    public static SyntaxKind InitKeyword;
    public static SyntaxKind ManagedKeyword;
    public static SyntaxKind UnmanagedKeyword;
    public static SyntaxKind RequiredKeyword;
    public static SyntaxKind FileKeyword;
    public static SyntaxKind NullableKeyword;
    public static SyntaxKind EnableKeyword;
    public static SyntaxKind WarningsKeyword;
    public static SyntaxKind AnnotationsKeyword;
    public static SyntaxKind VarKeyword;
    public static SyntaxKind UnderscoreToken;
    public static SyntaxKind ConflictMarkerTrivia;
    public static SyntaxKind IsPatternExpression;
    public static SyntaxKind RangeExpression;
    public static SyntaxKind ImplicitObjectCreationExpression;
    public static SyntaxKind CoalesceAssignmentExpression;
    public static SyntaxKind IndexExpression;
    public static SyntaxKind DefaultLiteralExpression;
    public static SyntaxKind LocalFunctionStatement;
    public static SyntaxKind FileScopedNamespaceDeclaration;
    public static SyntaxKind TupleType;
    public static SyntaxKind TupleElement;
    public static SyntaxKind TupleExpression;
    public static SyntaxKind SingleVariableDesignation;
    public static SyntaxKind ParenthesizedVariableDesignation;
    public static SyntaxKind ForEachVariableStatement;
    public static SyntaxKind DeclarationPattern;
    public static SyntaxKind ConstantPattern;
    public static SyntaxKind CasePatternSwitchLabel;
    public static SyntaxKind WhenClause;
    public static SyntaxKind DiscardDesignation;
    public static SyntaxKind RecursivePattern;
    public static SyntaxKind PropertyPatternClause;
    public static SyntaxKind Subpattern;
    public static SyntaxKind PositionalPatternClause;
    public static SyntaxKind DiscardPattern;
    public static SyntaxKind SwitchExpression;
    public static SyntaxKind SwitchExpressionArm;
    public static SyntaxKind VarPattern;
    public static SyntaxKind ParenthesizedPattern;
    public static SyntaxKind SlicePattern;
    public static SyntaxKind ListPattern;
    public static SyntaxKind DeclarationExpression;
    public static SyntaxKind RefExpression;
    public static SyntaxKind RefType;
    public static SyntaxKind ThrowExpression;
    public static SyntaxKind ImplicitStackAllocArrayCreationExpression;
    public static SyntaxKind SuppressNullableWarningExpression;
    public static SyntaxKind NullableDirectiveTrivia;
    public static SyntaxKind FunctionPointerType;
    public static SyntaxKind FunctionPointerParameter;
    public static SyntaxKind InitAccessorDeclaration;
    public static SyntaxKind WithExpression;
    public static SyntaxKind WithInitializerExpression;
    public static SyntaxKind RecordDeclaration;
    public static SyntaxKind FunctionPointerUnmanagedCallingConventionList;
    public static SyntaxKind RecordStructDeclaration;
    public static SyntaxKind CollectionExpression;
}
internal abstract class StyleCop.Analyzers.Lightup.SyntaxWrapper`1 : object {
    [CompilerGeneratedAttribute]
private static SyntaxWrapper`1<TNode> <Default>k__BackingField;
    public static SyntaxWrapper`1<TNode> Default { get; }
    private static SyntaxWrapper`1();
    [CompilerGeneratedAttribute]
public static SyntaxWrapper`1<TNode> get_Default();
    public abstract virtual TNode Wrap(SyntaxNode node);
    public abstract virtual SyntaxNode Unwrap(TNode node);
    private static SyntaxWrapper`1<TNode> FindDefaultSyntaxWrapper();
}
internal static class StyleCop.Analyzers.Lightup.SyntaxWrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static SyntaxWrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.ThrowExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> ThrowKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithThrowKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static ThrowExpressionSyntaxWrapper();
    private ThrowExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_ThrowKeyword();
    public ExpressionSyntax get_Expression();
    public static ThrowExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ThrowExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ThrowExpressionSyntaxWrapper WithThrowKeyword(SyntaxToken throwKeyword);
    public ThrowExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Lightup.TryGetValueAccessor`3 : MulticastDelegate {
    public TryGetValueAccessor`3(object object, IntPtr method);
    public virtual bool Invoke(T instance, TKey key, TValue& value);
    public virtual IAsyncResult BeginInvoke(T instance, TKey key, TValue& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(TValue& value, IAsyncResult result);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.TupleElementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    private static TupleElementSyntaxWrapper();
    private TupleElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public static TupleElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(TupleElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleElementSyntaxWrapper WithType(TypeSyntax type);
    public TupleElementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.TupleExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>> ArgumentsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>, ExpressionSyntax> WithArgumentsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseParenTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleExpressionSyntaxWrapper();
    private TupleExpressionSyntaxWrapper(ExpressionSyntax node);
    public TupleExpressionSyntaxWrapper AddArguments(ArgumentSyntax[] items);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    public static TupleExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(TupleExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleExpressionSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleExpressionSyntaxWrapper WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public TupleExpressionSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.TupleTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>> ElementsAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithOpenParenTokenAccessor;
    private static Func`3<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, TypeSyntax> WithElementsAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithCloseParenTokenAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> Elements { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleTypeSyntaxWrapper();
    private TupleTypeSyntaxWrapper(TypeSyntax node);
    public TupleTypeSyntaxWrapper AddElements(TupleElementSyntaxWrapper[] items);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> get_Elements();
    public SyntaxToken get_CloseParenToken();
    public static TupleTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(TupleTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleTypeSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleTypeSyntaxWrapper WithElements(SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements);
    public TupleTypeSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.TypePatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    private static TypePatternSyntaxWrapper();
    private TypePatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public static TypePatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static TypePatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static TypePatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(TypePatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TypePatternSyntaxWrapper WithType(TypeSyntax type);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.UnaryPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OperatorTokenAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOperatorTokenAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithPatternAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OperatorToken { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static UnaryPatternSyntaxWrapper();
    private UnaryPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OperatorToken();
    public PatternSyntaxWrapper get_Pattern();
    public static UnaryPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static UnaryPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static UnaryPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(UnaryPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public UnaryPatternSyntaxWrapper WithOperatorToken(SyntaxToken operatorToken);
    public UnaryPatternSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.UsingStatementSyntaxExtensions : object {
    private static Func`2<UsingStatementSyntax, SyntaxToken> AwaitKeywordAccessor;
    private static Func`3<UsingStatementSyntax, SyntaxToken, UsingStatementSyntax> WithAwaitKeywordAccessor;
    private static UsingStatementSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken AwaitKeyword(UsingStatementSyntax syntax);
    [ExtensionAttribute]
public static UsingStatementSyntax WithAwaitKeyword(UsingStatementSyntax syntax, SyntaxToken awaitKeyword);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.VariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static VariableDesignationSyntaxWrapper();
    private VariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static VariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(VariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static VariableDesignationSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.VarPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> VarKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithVarKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken VarKeyword { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static VarPatternSyntaxWrapper();
    private VarPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_VarKeyword();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static VarPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static VarPatternSyntaxWrapper op_Explicit(ExpressionOrPatternSyntaxWrapper node);
    public static VarPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static ExpressionOrPatternSyntaxWrapper op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(VarPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public VarPatternSyntaxWrapper WithVarKeyword(SyntaxToken varKeyword);
    public VarPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.WhenClauseSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> WhenKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ConditionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithWhenKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithConditionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken WhenKeyword { get; }
    public ExpressionSyntax Condition { get; }
    private static WhenClauseSyntaxWrapper();
    private WhenClauseSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_WhenKeyword();
    public ExpressionSyntax get_Condition();
    public static WhenClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(WhenClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public WhenClauseSyntaxWrapper WithWhenKeyword(SyntaxToken whenKeyword);
    public WhenClauseSyntaxWrapper WithCondition(ExpressionSyntax condition);
}
[IsReadOnlyAttribute]
internal class StyleCop.Analyzers.Lightup.WithExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> WithKeywordAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithWithKeywordAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken WithKeyword { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static WithExpressionSyntaxWrapper();
    private WithExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_WithKeyword();
    public InitializerExpressionSyntax get_Initializer();
    public static WithExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(WithExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public WithExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public WithExpressionSyntaxWrapper WithWithKeyword(SyntaxToken withKeyword);
    public WithExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
}
internal static class StyleCop.Analyzers.Lightup.WrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static WrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string SA1119CodeFix { get; }
    public static string SA1119Description { get; }
    public static string SA1119MessageFormat { get; }
    public static string SA1119Title { get; }
    public static string SA1400CodeFix { get; }
    public static string SA1400Description { get; }
    public static string SA1400MessageFormat { get; }
    public static string SA1400Title { get; }
    public static string SA1401Description { get; }
    public static string SA1401MessageFormat { get; }
    public static string SA1401Title { get; }
    public static string SA1402CodeFix { get; }
    public static string SA1402Description { get; }
    public static string SA1402MessageFormat { get; }
    public static string SA1402Title { get; }
    public static string SA1403Description { get; }
    public static string SA1403MessageFormat { get; }
    public static string SA1403Title { get; }
    public static string SA1404CodeFix { get; }
    public static string SA1404Description { get; }
    public static string SA1404MessageFormat { get; }
    public static string SA1404Title { get; }
    public static string SA1405Description { get; }
    public static string SA1405MessageFormat { get; }
    public static string SA1405Title { get; }
    public static string SA1406Description { get; }
    public static string SA1406MessageFormat { get; }
    public static string SA1406Title { get; }
    public static string SA1407Description { get; }
    public static string SA1407MessageFormat { get; }
    public static string SA1407SA1408CodeFix { get; }
    public static string SA1407Title { get; }
    public static string SA1408Description { get; }
    public static string SA1408MessageFormat { get; }
    public static string SA1408Title { get; }
    public static string SA1409Description { get; }
    public static string SA1409MessageFormat { get; }
    public static string SA1409Title { get; }
    public static string SA1410Description { get; }
    public static string SA1410MessageFormat { get; }
    public static string SA1410SA1411CodeFix { get; }
    public static string SA1410Title { get; }
    public static string SA1411Description { get; }
    public static string SA1411MessageFormat { get; }
    public static string SA1411Title { get; }
    public static string SA1412CodeFix { get; }
    public static string SA1412Description { get; }
    public static string SA1412MessageFormat { get; }
    public static string SA1412Title { get; }
    public static string SA1413CodeFix { get; }
    public static string SA1413Description { get; }
    public static string SA1413MessageFormat { get; }
    public static string SA1413Title { get; }
    public static string SA1414Description { get; }
    public static string SA1414MessageFormat { get; }
    public static string SA1414Title { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_SA1119CodeFix();
    public static string get_SA1119Description();
    public static string get_SA1119MessageFormat();
    public static string get_SA1119Title();
    public static string get_SA1400CodeFix();
    public static string get_SA1400Description();
    public static string get_SA1400MessageFormat();
    public static string get_SA1400Title();
    public static string get_SA1401Description();
    public static string get_SA1401MessageFormat();
    public static string get_SA1401Title();
    public static string get_SA1402CodeFix();
    public static string get_SA1402Description();
    public static string get_SA1402MessageFormat();
    public static string get_SA1402Title();
    public static string get_SA1403Description();
    public static string get_SA1403MessageFormat();
    public static string get_SA1403Title();
    public static string get_SA1404CodeFix();
    public static string get_SA1404Description();
    public static string get_SA1404MessageFormat();
    public static string get_SA1404Title();
    public static string get_SA1405Description();
    public static string get_SA1405MessageFormat();
    public static string get_SA1405Title();
    public static string get_SA1406Description();
    public static string get_SA1406MessageFormat();
    public static string get_SA1406Title();
    public static string get_SA1407Description();
    public static string get_SA1407MessageFormat();
    public static string get_SA1407SA1408CodeFix();
    public static string get_SA1407Title();
    public static string get_SA1408Description();
    public static string get_SA1408MessageFormat();
    public static string get_SA1408Title();
    public static string get_SA1409Description();
    public static string get_SA1409MessageFormat();
    public static string get_SA1409Title();
    public static string get_SA1410Description();
    public static string get_SA1410MessageFormat();
    public static string get_SA1410SA1411CodeFix();
    public static string get_SA1410Title();
    public static string get_SA1411Description();
    public static string get_SA1411MessageFormat();
    public static string get_SA1411Title();
    public static string get_SA1412CodeFix();
    public static string get_SA1412Description();
    public static string get_SA1412MessageFormat();
    public static string get_SA1412Title();
    public static string get_SA1413CodeFix();
    public static string get_SA1413Description();
    public static string get_SA1413MessageFormat();
    public static string get_SA1413Title();
    public static string get_SA1414Description();
    public static string get_SA1414MessageFormat();
    public static string get_SA1414Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static string ParenthesesDiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static DiagnosticDescriptor ParenthesisDescriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1119StatementMustNotUseUnnecessaryParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleParenthesizedExpression(SyntaxNodeAnalysisContext context);
    private static bool IsConditionalAccessInInterpolation(ExpressionSyntax node);
    private static bool IsSwitchOrWithExpressionWithRequiredParentheses(ParenthesizedExpressionSyntax node);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ParenthesizedExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseFieldDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1400AccessModifierMustBeDeclared();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckAccessModifiers(SyntaxNodeAnalysisContext context, SyntaxToken identifier, SyntaxTokenList modifiers, SyntaxNode declarationNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("The "Encapsulate Field" fix is provided by Visual Studio.")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SymbolAnalysisContext> AnalyzeFieldAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1401FieldsMustBePrivate();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleType : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1402FileMayOnlyContainASingleType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
    private static IEnumerable`1<MemberDeclarationSyntax> GetTopLevelTypeDeclarations(SyntaxNode root, StyleCopSettings settings);
    private static bool ContainsTopLevelTypeDeclarations(SyntaxNode node);
    private static bool IsRelevantType(SyntaxNode node, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1403FileMayOnlyContainASingleNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification : DiagnosticAnalyzer {
    public static string JustificationPlaceholder;
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1404CodeAnalysisSuppressionMustHaveJustification();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText : SystemDiagnosticsDebugDiagnosticBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1405DebugAssertMustProvideMessageText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("No message is available for Debug.Fail")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText : SystemDiagnosticsDebugDiagnosticBase {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1406DebugFailMustProvideMessageText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1407ArithmeticExpressionsMustDeclarePrecedence();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsSameFamily(SyntaxToken operatorToken1, SyntaxToken operatorToken2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1408ConditionalExpressionsMustDeclarePrecedence();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsSameFamily(SyntaxToken operatorToken1, SyntaxToken operatorToken2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic requires deep semantic analysis which is more suited to a usage-based analysis toolset as opposed to a style-based analysis toolset.")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1409RemoveUnnecessaryCode();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1410RemoveDelegateParenthesisWhenPossible();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool HasAmbiguousOverload(SyntaxNodeAnalysisContext context, AnonymousMethodExpressionSyntax anonymousMethodExpression, SyntaxNode methodCallSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8 : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    private static Byte[] Utf8Preamble;
    [CompilerGeneratedAttribute]
private static string <EncodingProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static string EncodingProperty { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1412StoreFilesAsUtf8();
    [CompilerGeneratedAttribute]
public static string get_EncodingProperty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static bool IsUtf8Preamble(Byte[] preamble);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleObjectInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAnonymousObjectInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> HandleEnumDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> HandleSwitchExpressionAction;
    private static ImmutableArray`1<SyntaxKind> ObjectInitializerKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1413UseTrailingCommasInMultiLineInitializers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate appropriate names.")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1414TupleTypesInSignaturesShouldHaveElementNames : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConversionOperatorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1414TupleTypesInSignaturesShouldHaveElementNames();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckParameterList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void CheckType(SyntaxNodeAnalysisContext context, TypeSyntax typeSyntax);
    private static void CheckTupleType(SyntaxNodeAnalysisContext context, TupleTypeSyntaxWrapper tupleTypeSyntax);
    private static void CheckGenericName(SyntaxNodeAnalysisContext context, GenericNameSyntax genericNameSyntax);
}
internal abstract class StyleCop.Analyzers.MaintainabilityRules.SystemDiagnosticsDebugDiagnosticBase : DiagnosticAnalyzer {
    protected internal static void HandleInvocationExpression(SyntaxNodeAnalysisContext context, string methodName, int parameterIndex, DiagnosticDescriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.NamingRules.NamingResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string RenameToCodeFix { get; }
    public static string SA1300Description { get; }
    public static string SA1300MessageFormat { get; }
    public static string SA1300Title { get; }
    public static string SA1301Description { get; }
    public static string SA1301MessageFormat { get; }
    public static string SA1301Title { get; }
    public static string SA1302CodeFix { get; }
    public static string SA1302Description { get; }
    public static string SA1302MessageFormat { get; }
    public static string SA1302Title { get; }
    public static string SA1303Description { get; }
    public static string SA1303MessageFormat { get; }
    public static string SA1303Title { get; }
    public static string SA1304Description { get; }
    public static string SA1304MessageFormat { get; }
    public static string SA1304Title { get; }
    public static string SA1305Description { get; }
    public static string SA1305MessageFormat { get; }
    public static string SA1305Title { get; }
    public static string SA1306Description { get; }
    public static string SA1306MessageFormat { get; }
    public static string SA1306Title { get; }
    public static string SA1307Description { get; }
    public static string SA1307MessageFormat { get; }
    public static string SA1307Title { get; }
    public static string SA1308Description { get; }
    public static string SA1308MessageFormat { get; }
    public static string SA1308Title { get; }
    public static string SA1309Description { get; }
    public static string SA1309MessageFormat { get; }
    public static string SA1309Title { get; }
    public static string SA1310Description { get; }
    public static string SA1310MessageFormat { get; }
    public static string SA1310Title { get; }
    public static string SA1311Description { get; }
    public static string SA1311MessageFormat { get; }
    public static string SA1311Title { get; }
    public static string SA1312Description { get; }
    public static string SA1312MessageFormat { get; }
    public static string SA1312Title { get; }
    public static string SA1313Description { get; }
    public static string SA1313MessageFormat { get; }
    public static string SA1313Title { get; }
    public static string SA1314CodeFix { get; }
    public static string SA1314Description { get; }
    public static string SA1314MessageFormat { get; }
    public static string SA1314Title { get; }
    public static string SA1316CodeFix { get; }
    public static string SA1316Description { get; }
    public static string SA1316MessageFormat { get; }
    public static string SA1316Title { get; }
    public static string SX1309Description { get; }
    public static string SX1309MessageFormat { get; }
    public static string SX1309SDescription { get; }
    public static string SX1309SMessageFormat { get; }
    public static string SX1309STitle { get; }
    public static string SX1309Title { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_RenameToCodeFix();
    public static string get_SA1300Description();
    public static string get_SA1300MessageFormat();
    public static string get_SA1300Title();
    public static string get_SA1301Description();
    public static string get_SA1301MessageFormat();
    public static string get_SA1301Title();
    public static string get_SA1302CodeFix();
    public static string get_SA1302Description();
    public static string get_SA1302MessageFormat();
    public static string get_SA1302Title();
    public static string get_SA1303Description();
    public static string get_SA1303MessageFormat();
    public static string get_SA1303Title();
    public static string get_SA1304Description();
    public static string get_SA1304MessageFormat();
    public static string get_SA1304Title();
    public static string get_SA1305Description();
    public static string get_SA1305MessageFormat();
    public static string get_SA1305Title();
    public static string get_SA1306Description();
    public static string get_SA1306MessageFormat();
    public static string get_SA1306Title();
    public static string get_SA1307Description();
    public static string get_SA1307MessageFormat();
    public static string get_SA1307Title();
    public static string get_SA1308Description();
    public static string get_SA1308MessageFormat();
    public static string get_SA1308Title();
    public static string get_SA1309Description();
    public static string get_SA1309MessageFormat();
    public static string get_SA1309Title();
    public static string get_SA1310Description();
    public static string get_SA1310MessageFormat();
    public static string get_SA1310Title();
    public static string get_SA1311Description();
    public static string get_SA1311MessageFormat();
    public static string get_SA1311Title();
    public static string get_SA1312Description();
    public static string get_SA1312MessageFormat();
    public static string get_SA1312Title();
    public static string get_SA1313Description();
    public static string get_SA1313MessageFormat();
    public static string get_SA1313Title();
    public static string get_SA1314CodeFix();
    public static string get_SA1314Description();
    public static string get_SA1314MessageFormat();
    public static string get_SA1314Title();
    public static string get_SA1316CodeFix();
    public static string get_SA1316Description();
    public static string get_SA1316MessageFormat();
    public static string get_SA1316Title();
    public static string get_SX1309Description();
    public static string get_SX1309MessageFormat();
    public static string get_SX1309SDescription();
    public static string get_SX1309SMessageFormat();
    public static string get_SX1309STitle();
    public static string get_SX1309Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ClassDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> RecordDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumMemberDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> StructDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventFieldDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParameterAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1300ElementMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckNamespaceNameSyntax(SyntaxNodeAnalysisContext context, NameSyntax nameSyntax, StyleCopSettings settings);
    private static void HandleClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumMemberDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleParameter(SyntaxNodeAnalysisContext context);
    private static void CheckElementNameToken(SyntaxNodeAnalysisContext context, SyntaxToken identifier, bool allowUnderscoreDigit);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This rule has no behavior by design.")]
[NoCodeFixAttribute("Don't fix what isn't broken.")]
internal class StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1301ElementMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InterfaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1302InterfaceNamesMustBeginWithI();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInterfaceDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SymbolAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1303ConstFieldNamesMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<string> CommonPrefixes;
    private static Regex HungarianRegex;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> VariableDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ParameterDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CatchDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> QueryContinuationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> FromClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> LetClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> JoinClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> JoinIntoClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ForEachStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> SingleVariableDesignationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1305FieldNamesMustNotUseHungarianNotation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1306FieldNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1307AccessibleFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1308VariableNamesMustNotBePrefixed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1309FieldNamesMustNotBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1310FieldNamesMustNotContainUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> VariableDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> CatchDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> QueryContinuationAction;
    private static Action`1<SyntaxNodeAnalysisContext> FromClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> LetClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> JoinClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> JoinIntoClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForEachStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> SingleVariableDesignationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1312VariableNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleCatchDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleQueryContinuation(SyntaxNodeAnalysisContext context);
    private static void HandleFromClause(SyntaxNodeAnalysisContext context);
    private static void HandleLetClause(SyntaxNodeAnalysisContext context);
    private static void HandleJoinClause(SyntaxNodeAnalysisContext context);
    private static void HandleJoinIntoClause(SyntaxNodeAnalysisContext context);
    private static void HandleForEachStatement(SyntaxNodeAnalysisContext context);
    private static void HandleSingleVariableDesignation(SyntaxNodeAnalysisContext context);
    private static void CheckIdentifier(SyntaxNodeAnalysisContext context, SyntaxToken identifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ParameterAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1313ParameterNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleParameter(SyntaxNodeAnalysisContext context);
    private static bool IsInLambda(ParameterSyntax syntax);
    private static bool NameMatchesAbstraction(ParameterSyntax syntax, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1314TypeParameterNamesMustBeginWithT : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1314TypeParameterNamesMustBeginWithT();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeParameter(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1316TupleElementNamesShouldUseCorrectCasing : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string ExpectedTupleElementNameKey;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TupleTypeAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TupleExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1316TupleElementNamesShouldUseCorrectCasing();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTupleTypeAction(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleTupleExpressionAction(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckTupleElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, TupleElementSyntaxWrapper tupleElement);
    private static void CheckName(SyntaxNodeAnalysisContext context, StyleCopSettings settings, string tupleElementName, Location location, bool prepareCodeFix);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1309FieldNamesMustBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1309SStaticFieldNamesMustBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[AttributeUsageAttribute("4")]
internal class StyleCop.Analyzers.NoCodeFixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public NoCodeFixAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
[AttributeUsageAttribute("4")]
internal class StyleCop.Analyzers.NoDiagnosticAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public NoDiagnosticAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
internal static class StyleCop.Analyzers.OrderingRules.ModifierOrderHelper : object {
    internal static ModifierType GetModifierType(SyntaxToken modifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.OrderingRules.OrderingResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ElementOrderCodeFix { get; }
    public static string ModifierOrderCodeFix { get; }
    public static string SA1200DescriptionInside { get; }
    public static string SA1200DescriptionOutside { get; }
    public static string SA1200MessageFormatInside { get; }
    public static string SA1200MessageFormatOutside { get; }
    public static string SA1200Title { get; }
    public static string SA1201Description { get; }
    public static string SA1201MessageFormat { get; }
    public static string SA1201Title { get; }
    public static string SA1202Description { get; }
    public static string SA1202MessageFormat { get; }
    public static string SA1202Title { get; }
    public static string SA1203Description { get; }
    public static string SA1203MessageFormat { get; }
    public static string SA1203Title { get; }
    public static string SA1204Description { get; }
    public static string SA1204MessageFormat { get; }
    public static string SA1204Title { get; }
    public static string SA1205CodeFix { get; }
    public static string SA1205Description { get; }
    public static string SA1205MessageFormat { get; }
    public static string SA1205Title { get; }
    public static string SA1206Description { get; }
    public static string SA1206MessageFormat { get; }
    public static string SA1206Title { get; }
    public static string SA1207CodeFix { get; }
    public static string SA1207Description { get; }
    public static string SA1207MessageFormat { get; }
    public static string SA1207Title { get; }
    public static string SA1208Description { get; }
    public static string SA1208MessageFormat { get; }
    public static string SA1208Title { get; }
    public static string SA1209Description { get; }
    public static string SA1209MessageFormat { get; }
    public static string SA1209Title { get; }
    public static string SA1210Description { get; }
    public static string SA1210MessageFormat { get; }
    public static string SA1210Title { get; }
    public static string SA1211Description { get; }
    public static string SA1211MessageFormat { get; }
    public static string SA1211Title { get; }
    public static string SA1212Description { get; }
    public static string SA1212MessageFormat { get; }
    public static string SA1212Title { get; }
    public static string SA1213CodeFix { get; }
    public static string SA1213Description { get; }
    public static string SA1213MessageFormat { get; }
    public static string SA1213Title { get; }
    public static string SA1214Description { get; }
    public static string SA1214MessageFormat { get; }
    public static string SA1214Title { get; }
    public static string SA1216Description { get; }
    public static string SA1216MessageFormat { get; }
    public static string SA1216Title { get; }
    public static string SA1217Description { get; }
    public static string SA1217MessageFormat { get; }
    public static string SA1217Title { get; }
    public static string UsingCodeFix { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_ElementOrderCodeFix();
    public static string get_ModifierOrderCodeFix();
    public static string get_SA1200DescriptionInside();
    public static string get_SA1200DescriptionOutside();
    public static string get_SA1200MessageFormatInside();
    public static string get_SA1200MessageFormatOutside();
    public static string get_SA1200Title();
    public static string get_SA1201Description();
    public static string get_SA1201MessageFormat();
    public static string get_SA1201Title();
    public static string get_SA1202Description();
    public static string get_SA1202MessageFormat();
    public static string get_SA1202Title();
    public static string get_SA1203Description();
    public static string get_SA1203MessageFormat();
    public static string get_SA1203Title();
    public static string get_SA1204Description();
    public static string get_SA1204MessageFormat();
    public static string get_SA1204Title();
    public static string get_SA1205CodeFix();
    public static string get_SA1205Description();
    public static string get_SA1205MessageFormat();
    public static string get_SA1205Title();
    public static string get_SA1206Description();
    public static string get_SA1206MessageFormat();
    public static string get_SA1206Title();
    public static string get_SA1207CodeFix();
    public static string get_SA1207Description();
    public static string get_SA1207MessageFormat();
    public static string get_SA1207Title();
    public static string get_SA1208Description();
    public static string get_SA1208MessageFormat();
    public static string get_SA1208Title();
    public static string get_SA1209Description();
    public static string get_SA1209MessageFormat();
    public static string get_SA1209Title();
    public static string get_SA1210Description();
    public static string get_SA1210MessageFormat();
    public static string get_SA1210Title();
    public static string get_SA1211Description();
    public static string get_SA1211MessageFormat();
    public static string get_SA1211Title();
    public static string get_SA1212Description();
    public static string get_SA1212MessageFormat();
    public static string get_SA1212Title();
    public static string get_SA1213CodeFix();
    public static string get_SA1213Description();
    public static string get_SA1213MessageFormat();
    public static string get_SA1213Title();
    public static string get_SA1214Description();
    public static string get_SA1214MessageFormat();
    public static string get_SA1214Title();
    public static string get_SA1216Description();
    public static string get_SA1216MessageFormat();
    public static string get_SA1216Title();
    public static string get_SA1217Description();
    public static string get_SA1217MessageFormat();
    public static string get_SA1217Title();
    public static string get_UsingCodeFix();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatInside;
    private static LocalizableString DescriptionInside;
    private static LocalizableString MessageFormatOutside;
    private static LocalizableString DescriptionOutside;
    internal static DiagnosticDescriptor DescriptorInside;
    internal static DiagnosticDescriptor DescriptorOutside;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1200UsingDirectivesMustBePlacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> OuterOrder;
    private static ImmutableArray`1<SyntaxKind> TypeMemberOrder;
    private static Dictionary`2<SyntaxKind, string> MemberNames;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1201ElementsMustAppearInTheCorrectOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int kindIndex, SyntaxList`1<MemberDeclarationSyntax> members, ImmutableArray`1<SyntaxKind> order);
    private static SyntaxKind GetSyntaxKindForOrdering(SyntaxKind syntaxKind);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableHashSet`1<SyntaxKind> MemberKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1202ElementsMustBeOrderedByAccess();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int accessibilityIndex, SyntaxList`1<MemberDeclarationSyntax> members);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1203ConstantsMustAppearBeforeFields();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1204StaticElementsMustAppearBeforeInstanceElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int staticIndex, SyntaxList`1<MemberDeclarationSyntax> members);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1205PartialElementsMustDeclareAccess();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1206DeclarationKeywordsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckModifiersOrderAndReportDiagnostics(SyntaxNodeAnalysisContext context, SyntaxTokenList modifiers);
    private static int CompareModifiersType(ModifierType first, ModifierType second);
    private static bool AccessOrStaticModifierNotFollowingOtherModifier(ModifierType current, ModifierType previous);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1207ProtectedMustComeBeforeInternal();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void ProcessUsingsAndReportDiagnostic(SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void ProcessUsingsAndReportDiagnostic(SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void ProcessUsings(SyntaxNodeAnalysisContext context, OrderingSettings orderingSettings, SyntaxList`1<UsingDirectiveSyntax> usings);
    private static void CheckIncorrectlyOrderedUsingsAndReportDiagnostic(SyntaxNodeAnalysisContext context, IEnumerable`1<UsingDirectiveSyntax> usings);
    private static bool IsAliasOrStaticUsingDirective(UsingDirectiveSyntax usingDirective);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleUsingDirectives(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1212PropertyAccessorsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeProperty(SyntaxNodeAnalysisContext context, BasePropertyDeclarationSyntax propertyDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1213EventAccessorsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckUsingDeclarations(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseNamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1217UsingStaticDirectivesMustBeOrderedAlphabetically();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckUsingDeclarations(SyntaxNodeAnalysisContext context, OrderingSettings orderingSettings, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.ReadabilityRules.ReadabilityResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string IndentationCodeFix { get; }
    public static string RemoveRegionCodeFix { get; }
    public static string SA1100CodeFix { get; }
    public static string SA1100Description { get; }
    public static string SA1100MessageFormat { get; }
    public static string SA1100Title { get; }
    public static string SA1101CodeFix { get; }
    public static string SA1101Description { get; }
    public static string SA1101MessageFormat { get; }
    public static string SA1101Title { get; }
    public static string SA1102CodeFix { get; }
    public static string SA1102Description { get; }
    public static string SA1102MessageFormat { get; }
    public static string SA1102Title { get; }
    public static string SA1103CodeFixMultipleLines { get; }
    public static string SA1103CodeFixSingleLine { get; }
    public static string SA1103Description { get; }
    public static string SA1103MessageFormat { get; }
    public static string SA1103Title { get; }
    public static string SA1104Description { get; }
    public static string SA1104MessageFormat { get; }
    public static string SA1104SA1105CodeFix { get; }
    public static string SA1104Title { get; }
    public static string SA1105Description { get; }
    public static string SA1105MessageFormat { get; }
    public static string SA1105Title { get; }
    public static string SA1106CodeFix { get; }
    public static string SA1106Description { get; }
    public static string SA1106MessageFormat { get; }
    public static string SA1106Title { get; }
    public static string SA1107CodeFix { get; }
    public static string SA1107Description { get; }
    public static string SA1107MessageFormat { get; }
    public static string SA1107Title { get; }
    public static string SA1108Description { get; }
    public static string SA1108MessageFormat { get; }
    public static string SA1108Title { get; }
    public static string SA1109Description { get; }
    public static string SA1109MessageFormat { get; }
    public static string SA1109Title { get; }
    public static string SA1110Description { get; }
    public static string SA1110MessageFormat { get; }
    public static string SA1110Title { get; }
    public static string SA1111Description { get; }
    public static string SA1111MessageFormat { get; }
    public static string SA1111Title { get; }
    public static string SA1112Description { get; }
    public static string SA1112MessageFormat { get; }
    public static string SA1112Title { get; }
    public static string SA1113Description { get; }
    public static string SA1113MessageFormat { get; }
    public static string SA1113Title { get; }
    public static string SA1114Description { get; }
    public static string SA1114MessageFormat { get; }
    public static string SA1114Title { get; }
    public static string SA1115Description { get; }
    public static string SA1115MessageFormat { get; }
    public static string SA1115Title { get; }
    public static string SA1116CodeFix { get; }
    public static string SA1116Description { get; }
    public static string SA1116MessageFormat { get; }
    public static string SA1116Title { get; }
    public static string SA1117Description { get; }
    public static string SA1117MessageFormat { get; }
    public static string SA1117Title { get; }
    public static string SA1118Description { get; }
    public static string SA1118MessageFormat { get; }
    public static string SA1118Title { get; }
    public static string SA1120CodeFix { get; }
    public static string SA1120Description { get; }
    public static string SA1120MessageFormat { get; }
    public static string SA1120Title { get; }
    public static string SA1121CodeFix { get; }
    public static string SA1121Description { get; }
    public static string SA1121MessageFormat { get; }
    public static string SA1121Title { get; }
    public static string SA1122CodeFix { get; }
    public static string SA1122Description { get; }
    public static string SA1122MessageFormat { get; }
    public static string SA1122Title { get; }
    public static string SA1123Description { get; }
    public static string SA1123MessageFormat { get; }
    public static string SA1123Title { get; }
    public static string SA1124Description { get; }
    public static string SA1124MessageFormat { get; }
    public static string SA1124Title { get; }
    public static string SA1125Description { get; }
    public static string SA1125MessageFormat { get; }
    public static string SA1125Title { get; }
    public static string SA1126Description { get; }
    public static string SA1126MessageFormat { get; }
    public static string SA1126Title { get; }
    public static string SA1127CodeFix { get; }
    public static string SA1127Description { get; }
    public static string SA1127MessageFormat { get; }
    public static string SA1127Title { get; }
    public static string SA1128CodeFix { get; }
    public static string SA1128Description { get; }
    public static string SA1128MessageFormat { get; }
    public static string SA1128Title { get; }
    public static string SA1129CodeFix { get; }
    public static string SA1129Description { get; }
    public static string SA1129MessageFormat { get; }
    public static string SA1129Title { get; }
    public static string SA1130CodeFix { get; }
    public static string SA1130Description { get; }
    public static string SA1130MessageFormat { get; }
    public static string SA1130Title { get; }
    public static string SA1131CodeFix { get; }
    public static string SA1131Description { get; }
    public static string SA1131MessageFormat { get; }
    public static string SA1131Title { get; }
    public static string SA1132CodeFix { get; }
    public static string SA1132Description { get; }
    public static string SA1132MessageFormat { get; }
    public static string SA1132Title { get; }
    public static string SA1133CodeFix { get; }
    public static string SA1133Description { get; }
    public static string SA1133MessageFormat { get; }
    public static string SA1133Title { get; }
    public static string SA1134CodeFix { get; }
    public static string SA1134Description { get; }
    public static string SA1134MessageFormat { get; }
    public static string SA1134Title { get; }
    public static string SA1135CodeFix { get; }
    public static string SA1135Description { get; }
    public static string SA1135MessageFormatNamespace { get; }
    public static string SA1135MessageFormatType { get; }
    public static string SA1135Title { get; }
    public static string SA1136CodeFix { get; }
    public static string SA1136Description { get; }
    public static string SA1136MessageFormat { get; }
    public static string SA1136Title { get; }
    public static string SA1137Description { get; }
    public static string SA1137MessageFormat { get; }
    public static string SA1137Title { get; }
    public static string SA1139CodeFix { get; }
    public static string SA1139Description { get; }
    public static string SA1139MessageFormat { get; }
    public static string SA1139Title { get; }
    public static string SA1141CodeFix { get; }
    public static string SA1141Description { get; }
    public static string SA1141MessageFormat { get; }
    public static string SA1141Title { get; }
    public static string SA1142CodeFix { get; }
    public static string SA1142Description { get; }
    public static string SA1142MessageFormat { get; }
    public static string SA1142Title { get; }
    public static string SX1101CodeFix { get; }
    public static string SX1101Description { get; }
    public static string SX1101MessageFormat { get; }
    public static string SX1101Title { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_IndentationCodeFix();
    public static string get_RemoveRegionCodeFix();
    public static string get_SA1100CodeFix();
    public static string get_SA1100Description();
    public static string get_SA1100MessageFormat();
    public static string get_SA1100Title();
    public static string get_SA1101CodeFix();
    public static string get_SA1101Description();
    public static string get_SA1101MessageFormat();
    public static string get_SA1101Title();
    public static string get_SA1102CodeFix();
    public static string get_SA1102Description();
    public static string get_SA1102MessageFormat();
    public static string get_SA1102Title();
    public static string get_SA1103CodeFixMultipleLines();
    public static string get_SA1103CodeFixSingleLine();
    public static string get_SA1103Description();
    public static string get_SA1103MessageFormat();
    public static string get_SA1103Title();
    public static string get_SA1104Description();
    public static string get_SA1104MessageFormat();
    public static string get_SA1104SA1105CodeFix();
    public static string get_SA1104Title();
    public static string get_SA1105Description();
    public static string get_SA1105MessageFormat();
    public static string get_SA1105Title();
    public static string get_SA1106CodeFix();
    public static string get_SA1106Description();
    public static string get_SA1106MessageFormat();
    public static string get_SA1106Title();
    public static string get_SA1107CodeFix();
    public static string get_SA1107Description();
    public static string get_SA1107MessageFormat();
    public static string get_SA1107Title();
    public static string get_SA1108Description();
    public static string get_SA1108MessageFormat();
    public static string get_SA1108Title();
    public static string get_SA1109Description();
    public static string get_SA1109MessageFormat();
    public static string get_SA1109Title();
    public static string get_SA1110Description();
    public static string get_SA1110MessageFormat();
    public static string get_SA1110Title();
    public static string get_SA1111Description();
    public static string get_SA1111MessageFormat();
    public static string get_SA1111Title();
    public static string get_SA1112Description();
    public static string get_SA1112MessageFormat();
    public static string get_SA1112Title();
    public static string get_SA1113Description();
    public static string get_SA1113MessageFormat();
    public static string get_SA1113Title();
    public static string get_SA1114Description();
    public static string get_SA1114MessageFormat();
    public static string get_SA1114Title();
    public static string get_SA1115Description();
    public static string get_SA1115MessageFormat();
    public static string get_SA1115Title();
    public static string get_SA1116CodeFix();
    public static string get_SA1116Description();
    public static string get_SA1116MessageFormat();
    public static string get_SA1116Title();
    public static string get_SA1117Description();
    public static string get_SA1117MessageFormat();
    public static string get_SA1117Title();
    public static string get_SA1118Description();
    public static string get_SA1118MessageFormat();
    public static string get_SA1118Title();
    public static string get_SA1120CodeFix();
    public static string get_SA1120Description();
    public static string get_SA1120MessageFormat();
    public static string get_SA1120Title();
    public static string get_SA1121CodeFix();
    public static string get_SA1121Description();
    public static string get_SA1121MessageFormat();
    public static string get_SA1121Title();
    public static string get_SA1122CodeFix();
    public static string get_SA1122Description();
    public static string get_SA1122MessageFormat();
    public static string get_SA1122Title();
    public static string get_SA1123Description();
    public static string get_SA1123MessageFormat();
    public static string get_SA1123Title();
    public static string get_SA1124Description();
    public static string get_SA1124MessageFormat();
    public static string get_SA1124Title();
    public static string get_SA1125Description();
    public static string get_SA1125MessageFormat();
    public static string get_SA1125Title();
    public static string get_SA1126Description();
    public static string get_SA1126MessageFormat();
    public static string get_SA1126Title();
    public static string get_SA1127CodeFix();
    public static string get_SA1127Description();
    public static string get_SA1127MessageFormat();
    public static string get_SA1127Title();
    public static string get_SA1128CodeFix();
    public static string get_SA1128Description();
    public static string get_SA1128MessageFormat();
    public static string get_SA1128Title();
    public static string get_SA1129CodeFix();
    public static string get_SA1129Description();
    public static string get_SA1129MessageFormat();
    public static string get_SA1129Title();
    public static string get_SA1130CodeFix();
    public static string get_SA1130Description();
    public static string get_SA1130MessageFormat();
    public static string get_SA1130Title();
    public static string get_SA1131CodeFix();
    public static string get_SA1131Description();
    public static string get_SA1131MessageFormat();
    public static string get_SA1131Title();
    public static string get_SA1132CodeFix();
    public static string get_SA1132Description();
    public static string get_SA1132MessageFormat();
    public static string get_SA1132Title();
    public static string get_SA1133CodeFix();
    public static string get_SA1133Description();
    public static string get_SA1133MessageFormat();
    public static string get_SA1133Title();
    public static string get_SA1134CodeFix();
    public static string get_SA1134Description();
    public static string get_SA1134MessageFormat();
    public static string get_SA1134Title();
    public static string get_SA1135CodeFix();
    public static string get_SA1135Description();
    public static string get_SA1135MessageFormatNamespace();
    public static string get_SA1135MessageFormatType();
    public static string get_SA1135Title();
    public static string get_SA1136CodeFix();
    public static string get_SA1136Description();
    public static string get_SA1136MessageFormat();
    public static string get_SA1136Title();
    public static string get_SA1137Description();
    public static string get_SA1137MessageFormat();
    public static string get_SA1137Title();
    public static string get_SA1139CodeFix();
    public static string get_SA1139Description();
    public static string get_SA1139MessageFormat();
    public static string get_SA1139Title();
    public static string get_SA1141CodeFix();
    public static string get_SA1141Description();
    public static string get_SA1141MessageFormat();
    public static string get_SA1141Title();
    public static string get_SA1142CodeFix();
    public static string get_SA1142Description();
    public static string get_SA1142MessageFormat();
    public static string get_SA1142Title();
    public static string get_SX1101CodeFix();
    public static string get_SX1101Description();
    public static string get_SX1101MessageFormat();
    public static string get_SX1101Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MemberAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SimpleNameAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1101PrefixLocalCallsWithThis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSimpleName(SyntaxNodeAnalysisContext context);
    private static void HandleIdentifierNameImpl(SyntaxNodeAnalysisContext context, SimpleNameSyntax nameExpression);
    private static bool HasThis(SyntaxNode node);
    private static bool IsPartOfConstructorInitializer(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> EmptyStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1106CodeMustNotContainEmptyStatements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEmptyStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1107CodeMustNotContainMultipleStatementsOnOneLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static bool IsLastTokenMissing(StatementSyntax previousStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static SyntaxKind[] SupportedKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1108BlockStatementsMustNotContainEmbeddedComments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void FindAllComments(SyntaxNodeAnalysisContext context, SyntaxToken previousToken, SyntaxToken openBraceToken);
    private static bool IsComment(SyntaxTrivia syntaxTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic is rarely-occurring specialization of SA1123; the latter is now preferred in all cases.")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1109BlockStatementsMustNotContainEmbeddedRegions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses : DiagnosticAnalyzer {
    private static string SA1102Identifier;
    private static string SA1103Identifier;
    private static string SA1104Identifier;
    private static string SA1105Identifier;
    private static LocalizableString SA1102Title;
    private static LocalizableString SA1102MessageFormat;
    private static LocalizableString SA1102Description;
    private static string SA1102HelpLink;
    private static LocalizableString SA1103Title;
    private static LocalizableString SA1103MessageFormat;
    private static LocalizableString SA1103Description;
    private static string SA1103HelpLink;
    private static LocalizableString SA1104Title;
    private static LocalizableString SA1104MessageFormat;
    private static LocalizableString SA1104Description;
    private static string SA1104HelpLink;
    private static LocalizableString SA1105Title;
    private static LocalizableString SA1105MessageFormat;
    private static LocalizableString SA1105Description;
    private static string SA1105HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> QueryExpressionAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1102Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1103Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1104Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1105Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1102Descriptor { get; }
    public static DiagnosticDescriptor SA1103Descriptor { get; }
    public static DiagnosticDescriptor SA1104Descriptor { get; }
    public static DiagnosticDescriptor SA1105Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA110xQueryClauses();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1102Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1103Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1104Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1105Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleQueryExpression(SyntaxNodeAnalysisContext context);
    private static void HandleQueryBody(QueryBodySyntax body, List`1<SyntaxToken> tokensToCheck);
    private static void HandleQueryClause(QueryClauseSyntax queryClause, List`1<SyntaxToken> tokensToCheck);
    private static void HandleSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup, List`1<SyntaxToken> tokensToCheck);
    private static void HandleContinuation(QueryContinuationSyntax continuation, List`1<SyntaxToken> tokensToCheck);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> OperatorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConversionOperatorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1110OpeningParenthesisMustBeOnDeclarationLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext obj);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static Nullable`1<SyntaxToken> GetIdentifier(ObjectCreationExpressionSyntax objectCreationExpressionSyntax);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void CheckIfLocationOfPreviousTokenAndOpenTokenAreTheSame(SyntaxNodeAnalysisContext context, SyntaxToken openToken, bool preserveLayout);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledMethodSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1111ClosingParenthesisMustBeOnLineOfLastParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void CheckIfLocationOfLastArgumentOrParameterAndCloseTokenAreTheSame(SyntaxNodeAnalysisContext context, CSharpSyntaxNode parameterOrArgument, SyntaxToken closeToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleParameterList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterListSyntax);
    private static void CheckIfLocationOfOpenAndCloseTokensAreTheSame(SyntaxNodeAnalysisContext context, SyntaxToken openToken, SyntaxToken closeToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1113CommaMustBeOnSameLineAsPreviousParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentListSyntax(SyntaxNodeAnalysisContext context, BaseArgumentListSyntax argumentList);
    private static void HandleBaseParameterListSyntax(SyntaxNodeAnalysisContext context, BaseParameterListSyntax parameterList);
    private static void CheckIfCommasAreAtTheSameLineAsThePreviousParameter(SyntaxNodeAnalysisContext context, SyntaxNodeOrTokenList nodeOrTokenList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1114ParameterListMustFollowDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRankSpecifiers(SyntaxNodeAnalysisContext context, ArrayCreationExpressionSyntax arrayCreation);
    private static void AnalyzeAttributeList(SyntaxNodeAnalysisContext context, AttributeListSyntax attributesList);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax argumentListSyntax);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, AttributeArgumentListSyntax argumentListSyntax);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentListSyntax);
    private static void AnalyzeBracketParametersList(SyntaxNodeAnalysisContext context, BracketedParameterListSyntax parameterListSyntax);
    private static void AnalyzeParametersList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterListSyntax);
    private static bool IsValidTrivia(SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitElementAccessAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1115ParameterMustFollowComma();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleImplicitElementAccess(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSyntaxList(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<TNode> syntaxList);
    private static bool IsValidTrivia(SyntaxTriviaList triviaList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitElementAccessAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1116SplitParametersMustStartOnLineAfterDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitElementAccess(SyntaxNodeAnalysisContext context);
    private static void HandleArgumentListSyntax(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentList);
    private static void HandleParameterListSyntax(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void HandleBracketedArgumentListSyntax(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax bracketedArgumentList);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken openParenOrBracketToken, SyntaxNode firstParameter, SyntaxNode secondParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1117ParametersMustBeOnSameLineOrSeparateLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArgumentListSyntax(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentList);
    private static void HandleParameterListSyntax(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void HandleBracketedArgumentListSyntax(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax bracketedArgumentList);
    private static void Analyze(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<T> arguments);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    private static SyntaxKind[] ArgumentExceptionSyntaxKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1118ParameterMustNotSpanMultipleLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentList(SyntaxNodeAnalysisContext context);
    private static bool CheckIfArgumentIsMultiline(CSharpSyntaxNode argument);
    private static bool IsArgumentOnExceptionList(ExpressionSyntax argumentExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1120CommentsMustContainText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleMultiLineComment(SyntaxTreeAnalysisContext context, SyntaxTrivia multiLineComment);
    private static void HandleSingleLineComment(SyntaxTreeAnalysisContext context, SyntaxTrivia singleLineComment);
    private static bool IsNullOrWhiteSpace(string value, int startIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1121UseBuiltInTypeAlias();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> StringLiteralExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1122UseStringEmptyForEmptyStrings();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static bool HasToBeConstant(LiteralExpressionSyntax literalExpression);
    private static ExpressionSyntax FindOutermostExpression(ExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> RegionDirectiveTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1123DoNotPlaceRegionsWithinElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    internal static bool IsCompletelyContainedInBody(RegionDirectiveTriviaSyntax regionSyntax);
    private static void HandleRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> RegionDirectiveTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1124DoNotUseRegions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Provided by Visual Studio")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> GenericNameAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1125UseShorthandForNullableTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleGenericName(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("Roslyn provides the ability to create well-defined rules for specific use cases, removing the need for this vaguely-worded diagnostic.")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1126PrefixCallsCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterConstraintClauseAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1127GenericTypeConstraintsMustBeOnOwnLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeParameterConstraintClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1128ConstructorInitializerMustBeOnOwnLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ConstructorDeclarationSyntax constructor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<OperationAnalysisContext> ObjectCreationOperationAction;
    private static Action`1<OperationAnalysisContext> TypeParameterObjectCreationOperationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1129DoNotUseDefaultValueTypeConstructor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleObjectCreationOperation(OperationAnalysisContext context);
    private static void HandleTypeParameterObjectCreationOperation(OperationAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static bool IsReferenceTypeParameter(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1130UseLambdaSyntax();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    internal static ParameterListSyntax GetDelegateParameterList(ISymbol symbol, int argumentIndex);
    internal static int FindParameterIndex(SymbolInfo originalSymbolInfo, ArgumentSyntax argumentSyntax, BaseArgumentListSyntax argumentListSyntax);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool HandleMethodInvocation(SemanticModel semanticModel, AnonymousMethodExpressionSyntax anonymousMethod, ArgumentSyntax argumentSyntax);
    private static ImmutableArray`1<ParameterSyntax> GetSyntaxParametersFromSymbolParameters(ImmutableArray`1<IParameterSymbol> symbolParameters);
    private static ParameterSyntax GetParameterSyntaxFromParameterSymbol(IParameterSymbol symbolParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1131UseReadableConditions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsLiteral(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseFieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1132DoNotCombineFields();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAttributeListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1133DoNotCombineAttributes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine : DiagnosticAnalyzer {
    public static string FixWithNewLineBeforeKey;
    public static string FixWithNewLineAfterKey;
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAttributeListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1134AttributesMustNotShareLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1135UsingDirectivesMustBeQualified : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatNamespace;
    private static LocalizableString MessageFormatType;
    private static LocalizableString Description;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNamespace { get; }
    public static DiagnosticDescriptor DescriptorType { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1135UsingDirectivesMustBeQualified();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNamespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleUsingDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckUsingDeclaration(SyntaxNodeAnalysisContext context, UsingDirectiveSyntax usingDirective);
    private static string UsingDirectiveSyntaxToCanonicalString(UsingDirectiveSyntax usingDirective);
    private static bool AppendCanonicalString(StringBuilder builder, TypeSyntax type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleEnumDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1136EnumValuesShouldBeOnSeparateLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1137ElementsShouldHaveTheSameIndentation : DiagnosticAnalyzer {
    public static string ExpectedIndentationKey;
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseNamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    private static Action`1<SyntaxNodeAnalysisContext> VariableDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseParameterListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> TupleTypeAction;
    private static Action`1<SyntaxNodeAnalysisContext> TupleExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1137ElementsShouldHaveTheSameIndentation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleBaseNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeParameterList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseParameterList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleTupleType(SyntaxNodeAnalysisContext context);
    private static void HandleTupleExpression(SyntaxNodeAnalysisContext context);
    private static void AddMembersAndAttributes(Builder<SyntaxNode> elements, SeparatedSyntaxList`1<T> members);
    private static void AddMembersAndAttributes(Builder<SyntaxNode> elements, SyntaxList`1<T> members);
    private static void AddMemberAndAttributes(Builder<SyntaxNode> elements, SyntaxNode member);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SyntaxList`1<T> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<T> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SeparatedSyntaxListWrapper`1<T> elements);
    private static void CheckBlocks(SyntaxNodeAnalysisContext context, ImmutableList`1<BlockSyntax> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, ImmutableList`1<T> elements);
    private static ImmutableList`1<T> CleanupElementsList(ImmutableList`1<T> elements);
    private static SyntaxToken GetFirstTokenForAnalysis(SyntaxNode node);
    private static void CheckBraces(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxToken token, SyntaxTrivia tokenLeadingTrivia, string indentation, string expectedIndentation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1139UseLiteralSuffixNotationInsteadOfCasting : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    private static Action`1<SyntaxNodeAnalysisContext> CastExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1139UseLiteralSuffixNotationInsteadOfCasting();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleCastExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1141UseTupleSyntax : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConversionOperatorAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LambdaExpressionAction;
    private static DiagnosticDescriptor Descriptor;
    private static SymbolDisplayFormat DisplayFormat;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1141UseTupleSyntax();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConversionOperator(SyntaxNodeAnalysisContext context);
    private static void HandleBasePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static void HandleDefaultExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleCastExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static void CheckParameterList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void CheckType(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, TypeSyntax typeSyntax, Location reportLocation);
    private static void CheckTupleType(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, TupleTypeSyntaxWrapper tupleTypeSyntax, Location reportLocation);
    private static void CheckGenericName(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, GenericNameSyntax genericNameSyntax, Location reportLocation);
    private static bool IsValueTupleWithLanguageRepresentation(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, ExpressionSyntax syntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1142ReferToTupleElementsByName : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static Action`1<OperationAnalysisContext> FieldReferenceOperationAction;
    private static Action`1<SyntaxNodeAnalysisContext> SimpleMemberAccessExpressionAction;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1142ReferToTupleElementsByName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldReferenceOperation(OperationAnalysisContext context);
    private static void HandleSimpleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static bool CheckFieldName(IFieldSymbol fieldSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ThisExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1101DoNotPrefixLocalMembersWithThis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleThisExpression(SyntaxNodeAnalysisContext context);
}
internal static class StyleCop.Analyzers.Settings.ObjectModel.AnalyzerConfigHelper : object {
    internal static Nullable`1<bool> TryGetBooleanValue(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key);
    internal static Nullable`1<int> TryGetInt32Value(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key);
    internal static string TryGetStringValue(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key, bool allowExplicitUnset);
    internal static string TryGetMultiLineStringValue(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key, bool allowExplicitUnset);
    internal static Nullable`1<KeyValuePair`2<string, string>> TryGetStringValueAndNotification(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key, bool allowExplicitUnset);
    internal static Nullable`1<ImmutableArray`1<string>> TryGetStringListValue(AnalyzerConfigOptionsWrapper analyzerConfigOptions, string key, bool allowExplicitUnset);
}
internal class StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings : object {
    internal static string DefaultCompanyName;
    internal static string DefaultCopyrightText;
    internal static string DefaultDocumentationCulture;
    internal static ImmutableArray`1<string> DefaultExcludeFromPunctuationCheck;
    private string companyName;
    private string copyrightText;
    private string headerDecoration;
    private ImmutableDictionary`2<string, string> variables;
    private bool xmlHeader;
    private bool documentExposedElements;
    private bool documentInternalElements;
    private bool documentPrivateElements;
    private bool documentInterfaces;
    private bool documentPrivateFields;
    private FileNamingConvention fileNamingConvention;
    private string documentationCulture;
    private CultureInfo documentationCultureInfo;
    private ImmutableArray`1<string> excludeFromPunctuationCheck;
    private string copyrightTextCache;
    public string CompanyName { get; }
    public string HeaderDecoration { get; }
    public ImmutableDictionary`2<string, string> Variables { get; }
    public bool XmlHeader { get; }
    public bool DocumentExposedElements { get; }
    public bool DocumentInternalElements { get; }
    public bool DocumentPrivateElements { get; }
    public bool DocumentInterfaces { get; }
    public bool DocumentPrivateFields { get; }
    public FileNamingConvention FileNamingConvention { get; }
    public string DocumentationCulture { get; }
    public ImmutableArray`1<string> ExcludeFromPunctuationCheck { get; }
    public CultureInfo DocumentationCultureInfo { get; }
    protected internal DocumentationSettings(JsonObject documentationSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    private static DocumentationSettings();
    public string get_CompanyName();
    public string get_HeaderDecoration();
    public ImmutableDictionary`2<string, string> get_Variables();
    public bool get_XmlHeader();
    public bool get_DocumentExposedElements();
    public bool get_DocumentInternalElements();
    public bool get_DocumentPrivateElements();
    public bool get_DocumentInterfaces();
    public bool get_DocumentPrivateFields();
    public FileNamingConvention get_FileNamingConvention();
    public string get_DocumentationCulture();
    public ImmutableArray`1<string> get_ExcludeFromPunctuationCheck();
    public CultureInfo get_DocumentationCultureInfo();
    public string GetCopyrightText(string fileName);
    private static bool IsValidVariableName(string name);
    private KeyValuePair`2<string, bool> BuildCopyrightText(string fileName);
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.FileNamingConvention : Enum {
    public int value__;
    public static FileNamingConvention StyleCop;
    public static FileNamingConvention Metadata;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings : object {
    private int indentationSize;
    private int tabSize;
    private bool useTabs;
    public int IndentationSize { get; }
    public int TabSize { get; }
    public bool UseTabs { get; }
    protected internal IndentationSettings(JsonObject indentationSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    public int get_IndentationSize();
    public int get_TabSize();
    public bool get_UseTabs();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings : object {
    private OptionSetting newlineAtEndOfFile;
    private bool allowConsecutiveUsings;
    private bool allowDoWhileOnClosingBrace;
    public OptionSetting NewlineAtEndOfFile { get; }
    public bool AllowConsecutiveUsings { get; }
    public bool AllowDoWhileOnClosingBrace { get; }
    protected internal LayoutSettings(JsonObject layoutSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    public OptionSetting get_NewlineAtEndOfFile();
    public bool get_AllowConsecutiveUsings();
    public bool get_AllowDoWhileOnClosingBrace();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.MaintainabilitySettings : object {
    private static ImmutableArray`1<TopLevelType> DefaultTopLevelTypes;
    private ImmutableArray`1<TopLevelType> topLevelTypes;
    public ImmutableArray`1<TopLevelType> TopLevelTypes { get; }
    protected internal MaintainabilitySettings(JsonObject maintainabilitySettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    private static MaintainabilitySettings();
    public ImmutableArray`1<TopLevelType> get_TopLevelTypes();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.NamingSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowCommonHungarianPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AllowedHungarianPrefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AllowedNamespaceComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInferredTupleElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private TupleElementNameCase <TupleElementNameCasing>k__BackingField;
    public bool AllowCommonHungarianPrefixes { get; }
    public ImmutableArray`1<string> AllowedHungarianPrefixes { get; }
    public ImmutableArray`1<string> AllowedNamespaceComponents { get; }
    public bool IncludeInferredTupleElementNames { get; }
    public TupleElementNameCase TupleElementNameCasing { get; }
    protected internal NamingSettings(JsonObject namingSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    [CompilerGeneratedAttribute]
public bool get_AllowCommonHungarianPrefixes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AllowedHungarianPrefixes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AllowedNamespaceComponents();
    [CompilerGeneratedAttribute]
public bool get_IncludeInferredTupleElementNames();
    [CompilerGeneratedAttribute]
public TupleElementNameCase get_TupleElementNameCasing();
    private static bool IsValidHungarianPrefix(string prefix);
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.OptionSetting : Enum {
    public int value__;
    public static OptionSetting Allow;
    public static OptionSetting Require;
    public static OptionSetting Omit;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings : object {
    private static ImmutableArray`1<OrderingTrait> DefaultElementOrder;
    private ImmutableArray`1<OrderingTrait> elementOrder;
    private bool systemUsingDirectivesFirst;
    private UsingDirectivesPlacement usingDirectivesPlacement;
    private OptionSetting blankLinesBetweenUsingGroups;
    public ImmutableArray`1<OrderingTrait> ElementOrder { get; }
    public bool SystemUsingDirectivesFirst { get; }
    public UsingDirectivesPlacement UsingDirectivesPlacement { get; }
    public OptionSetting BlankLinesBetweenUsingGroups { get; }
    protected internal OrderingSettings(JsonObject orderingSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    private static OrderingSettings();
    public ImmutableArray`1<OrderingTrait> get_ElementOrder();
    public bool get_SystemUsingDirectivesFirst();
    public UsingDirectivesPlacement get_UsingDirectivesPlacement();
    public OptionSetting get_BlankLinesBetweenUsingGroups();
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait : Enum {
    public int value__;
    public static OrderingTrait Kind;
    public static OrderingTrait Accessibility;
    public static OrderingTrait Constant;
    public static OrderingTrait Static;
    public static OrderingTrait Readonly;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.ReadabilitySettings : object {
    private bool allowBuiltInTypeAliases;
    public bool AllowBuiltInTypeAliases { get; }
    protected internal ReadabilitySettings(JsonObject readabilitySettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    public bool get_AllowBuiltInTypeAliases();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.SpacingSettings : object {
    protected internal SpacingSettings(JsonObject spacingSettingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
}
internal class StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings : object {
    private IndentationSettings indentation;
    private SpacingSettings spacingRules;
    private ReadabilitySettings readabilityRules;
    private OrderingSettings orderingRules;
    private NamingSettings namingRules;
    private MaintainabilitySettings maintainabilityRules;
    private LayoutSettings layoutRules;
    private DocumentationSettings documentationRules;
    public IndentationSettings Indentation { get; }
    public SpacingSettings SpacingRules { get; }
    public ReadabilitySettings ReadabilityRules { get; }
    public OrderingSettings OrderingRules { get; }
    public NamingSettings NamingRules { get; }
    public MaintainabilitySettings MaintainabilityRules { get; }
    public LayoutSettings LayoutRules { get; }
    public DocumentationSettings DocumentationRules { get; }
    protected internal StyleCopSettings(JsonObject settingsObject, AnalyzerConfigOptionsWrapper analyzerConfigOptions);
    public IndentationSettings get_Indentation();
    public SpacingSettings get_SpacingRules();
    public ReadabilitySettings get_ReadabilityRules();
    public OrderingSettings get_OrderingRules();
    public NamingSettings get_NamingRules();
    public MaintainabilitySettings get_MaintainabilityRules();
    public LayoutSettings get_LayoutRules();
    public DocumentationSettings get_DocumentationRules();
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.TopLevelType : Enum {
    public int value__;
    public static TopLevelType Class;
    public static TopLevelType Interface;
    public static TopLevelType Struct;
    public static TopLevelType Delegate;
    public static TopLevelType Enum;
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.TupleElementNameCase : Enum {
    public int value__;
    public static TupleElementNameCase CamelCase;
    public static TupleElementNameCase PascalCase;
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement : Enum {
    public int value__;
    public static UsingDirectivesPlacement InsideNamespace;
    public static UsingDirectivesPlacement OutsideNamespace;
    public static UsingDirectivesPlacement Preserve;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.Settings.SettingsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [NullableAttribute("1")]
public static ResourceManager ResourceManager { get; }
    public static CultureInfo Culture { get; public set; }
    [NullableAttribute("1")]
public static string SettingsFileCodeFix { get; }
    [NullableContextAttribute("1")]
public static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    [NullableContextAttribute("1")]
public static string get_SettingsFileCodeFix();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.SettingsHelper : object {
    internal static string SettingsFileName;
    internal static string AltSettingsFileName;
    [CompilerGeneratedAttribute]
private static SourceTextValueProvider`1<Lazy`1<JsonValue>> <JsonValueProvider>k__BackingField;
    private static SourceTextValueProvider`1<Lazy`1<JsonValue>> JsonValueProvider { get; }
    private static SettingsHelper();
    [CompilerGeneratedAttribute]
private static SourceTextValueProvider`1<Lazy`1<JsonValue>> get_JsonValueProvider();
    [ExtensionAttribute]
internal static SettingsFile GetStyleCopSettingsFile(CompilationStartAnalysisContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(SyntaxTreeAnalysisContext context, SettingsFile settingsFile);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(SyntaxTreeAnalysisContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(SyntaxNodeAnalysisContext context, SettingsFile settingsFile);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(AnalyzerOptions options, SyntaxTree tree, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(CompilationAnalysisContext context, SyntaxTree tree, DeserializationFailureBehavior failureBehavior, CancellationToken cancellationToken);
    internal static bool IsStyleCopSettingsFile(string path);
    private static StyleCopSettings GetSettings(AnalyzerOptions options, SyntaxTree tree, SettingsFile settingsFile, DeserializationFailureBehavior failureBehavior);
    private static StyleCopSettings CreateSettingsObjectFromFile(AnalyzerOptions options, SyntaxTree tree, SettingsFile settingsFile, DeserializationFailureBehavior failureBehavior);
    private static SettingsFile GetSettingsFile(AnalyzerOptions options, Func`2<SourceText, Lazy`1<JsonValue>> getJsonValue, CancellationToken cancellationToken);
    private static Lazy`1<JsonValue> ParseJson(SourceText text);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IdentifierNameAction;
    private static ReportDiagnosticCallback`1<SyntaxTreeAnalysisContext> ReportSyntaxTreeDiagnostic;
    private static ReportDiagnosticCallback`1<SyntaxNodeAnalysisContext> ReportSyntaxNodeDiagnostic;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1000KeywordsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIdentifierName(SyntaxNodeAnalysisContext context);
    private static void HandleRequiredSpaceToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleRequiredSpaceToken(SyntaxNodeAnalysisContext& context, SyntaxToken token);
    private static void HandleRequiredSpaceToken(ReportDiagnosticCallback`1<TContext> reportDiagnostic, TContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(SyntaxNodeAnalysisContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(ReportDiagnosticCallback`1<TContext> reportDiagnostic, TContext& context, SyntaxToken token);
    private static void HandleNewOrStackAllocKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleReturnKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleThrowKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1001CommasMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCommaToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1002SemicolonsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleSemicolonToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string CodeFixAction;
    internal static string InsertBeforeTag;
    internal static string RemoveBeforeTag;
    internal static string InsertAfterTag;
    internal static string RemoveAfterTag;
    internal static string RemoveEndOfLineTag;
    internal static string RemoveEndOfLineWithTrailingSpaceTag;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatNotFollowedByComment;
    private static LocalizableString MessageFormatPrecededByWhitespace;
    private static LocalizableString MessageFormatNotPrecededByWhitespace;
    private static LocalizableString MessageFormatFollowedByWhitespace;
    private static LocalizableString MessageFormatNotFollowedByWhitespace;
    private static LocalizableString MessageFormatNotAtEndOfLine;
    private static LocalizableString Description;
    private static ImmutableArray`1<SyntaxKind> BinaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> PrefixUnaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> PostfixUnaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> AssignmentExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConditionalExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterConstraintClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> PrefixUnaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> PostfixUnaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AssignmentExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> CastExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> EqualsValueClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> LambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrowExpressionClauseAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowedByComment>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorPrecededByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotPrecededByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorFollowedByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowedByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotAtEndOfLine>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNotFollowedByComment { get; }
    public static DiagnosticDescriptor DescriptorPrecededByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotPrecededByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorFollowedByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotFollowedByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotAtEndOfLine { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1003SymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowedByComment();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorPrecededByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotPrecededByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorFollowedByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowedByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotAtEndOfLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConditionalExpression(SyntaxNodeAnalysisContext context);
    private static void HandleTypeParameterConstraintClause(SyntaxNodeAnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandlePrefixUnaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandlePostfixUnaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void HandleCastExpression(SyntaxNodeAnalysisContext context);
    private static void HandleEqualsValueClause(SyntaxNodeAnalysisContext context);
    private static void HandleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrowExpressionClause(SyntaxNodeAnalysisContext context);
    private static void CheckToken(SyntaxNodeAnalysisContext context, SyntaxToken token, bool withLeadingWhitespace, bool allowAtEndOfLine, bool withTrailingWhitespace, string tokenText);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1004DocumentationLinesMustBeginWithSingleSpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleDocumentationCommentExteriorTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1005SingleLineCommentsMustBeginWithSingleSpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleSingleLineCommentTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia, bool isFirstSingleLineTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1006PreprocessorKeywordsMustNotBePrecededBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleHashToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1007OperatorKeywordMustBeFollowedBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleRequiredSpaceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessagePreceded;
    private static LocalizableString MessageNotFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotPreceded>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorPreceded>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowed>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNotPreceded { get; }
    public static DiagnosticDescriptor DescriptorPreceded { get; }
    public static DiagnosticDescriptor DescriptorNotFollowed { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1008OpeningParenthesisMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotPreceded();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorPreceded();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenParenToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessageNotFollowed;
    private static LocalizableString MessageFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorNotFollowed;
    internal static DiagnosticDescriptor DescriptorFollowed;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1009ClosingParenthesisMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseParenToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessageNotFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorNotFollowed;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1010OpeningSquareBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static bool IsPartOfIndexInitializer(SyntaxToken token);
    private static bool IsPartOfListPattern(SyntaxToken token);
    private static bool IsPartOfCollectionExpression(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1011ClosingSquareBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1012OpeningBracesMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBraceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1013ClosingBracesMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBraceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1014OpeningGenericBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleLessThanToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessageNotFollowed;
    private static LocalizableString MessageFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorNotFollowed;
    internal static DiagnosticDescriptor DescriptorFollowed;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1015ClosingGenericBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleGreaterThanToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static void AnalyzeWithTrailingOpenParen(SyntaxToken nextToken, Boolean& allowTrailingNoSpace, Boolean& allowTrailingSpace);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1016OpeningAttributeBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1017ClosingAttributeBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> NullableTypeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1018NullableTypeSymbolsMustNotBePrecededBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleNullableType(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessageNotFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorNotFollowed;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1019MemberAccessSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleDotToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static void HandleQuestionToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static void HandleMemberAccessSymbol(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleIncrementDecrementToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1021NegativeSignsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleMinusToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1022PositiveSignsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandlePlusToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessageNotFollowed;
    private static LocalizableString MessageFollowed;
    private static LocalizableString MessageNotAtBeginningOfLine;
    private static LocalizableString MessageNotAtEndOfLine;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorNotFollowed;
    internal static DiagnosticDescriptor DescriptorFollowed;
    internal static DiagnosticDescriptor DescriptorNotAtBeginningOfLine;
    internal static DiagnosticDescriptor DescriptorNotAtEndOfLine;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleAsteriskToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static LocalizableString MessageNotPreceded;
    private static LocalizableString MessagePreceded;
    private static LocalizableString MessageFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    internal static DiagnosticDescriptor DescriptorNotPreceded;
    internal static DiagnosticDescriptor DescriptorPreceded;
    internal static DiagnosticDescriptor DescriptorFollowed;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1024ColonsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleColonToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1025CodeMustNotContainMultipleWhitespaceInARow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleWhitespaceTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitStackAllocArrayCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleImplicitArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitStackAllocArrayCreationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string BehaviorKey;
    internal static string ConvertToTabsBehavior;
    internal static string ConvertToSpacesBehavior;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    private static ImmutableDictionary`2<string, string> ConvertToTabsProperties;
    private static ImmutableDictionary`2<string, string> ConvertToSpacesProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1027UseTabsCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
    private static void ReportIncorrectTabUsage(SyntaxTreeAnalysisContext context, IndentationSettings indentationSettings, ImmutableArray`1<TextSpan> excludedSpans);
    private static bool LocateExcludedSpans(SyntaxNode root, ImmutableArray`1& excludedSpans);
    private static void ReduceTextSpans(Builder<TextSpan> sortedTextSpans);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1028CodeMustNotContainTrailingWhitespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static TextSpan FindTrailingWhitespace(SourceText text, TextSpan within);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.SpacingRules.SpacingResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string SA1000Description { get; }
    public static string SA1000MessageFormat { get; }
    public static string SA1000Title { get; }
    public static string SA1001Description { get; }
    public static string SA1001MessageFormat { get; }
    public static string SA1001Title { get; }
    public static string SA1002Description { get; }
    public static string SA1002MessageFormat { get; }
    public static string SA1002Title { get; }
    public static string SA1003CodeFix { get; }
    public static string SA1003Description { get; }
    public static string SA1003MessageFormatFollowedByWhitespace { get; }
    public static string SA1003MessageFormatNotAtEndOfLine { get; }
    public static string SA1003MessageFormatNotFollowedByComment { get; }
    public static string SA1003MessageFormatNotFollowedByWhitespace { get; }
    public static string SA1003MessageFormatNotPrecededByWhitespace { get; }
    public static string SA1003MessageFormatPrecededByWhitespace { get; }
    public static string SA1003Title { get; }
    public static string SA1004CodeFix { get; }
    public static string SA1004Description { get; }
    public static string SA1004MessageFormat { get; }
    public static string SA1004Title { get; }
    public static string SA1005CodeFix { get; }
    public static string SA1005Description { get; }
    public static string SA1005MessageFormat { get; }
    public static string SA1005Title { get; }
    public static string SA1006Description { get; }
    public static string SA1006MessageFormat { get; }
    public static string SA1006Title { get; }
    public static string SA1007Description { get; }
    public static string SA1007MessageFormat { get; }
    public static string SA1007Title { get; }
    public static string SA1008CodeFix { get; }
    public static string SA1008Description { get; }
    public static string SA1008MessageNotFollowed { get; }
    public static string SA1008MessageNotPreceded { get; }
    public static string SA1008MessagePreceded { get; }
    public static string SA1008Title { get; }
    public static string SA1009Description { get; }
    public static string SA1009MessageFollowed { get; }
    public static string SA1009MessageNotFollowed { get; }
    public static string SA1009MessageNotPreceded { get; }
    public static string SA1009Title { get; }
    public static string SA1010Description { get; }
    public static string SA1010MessageNotFollowed { get; }
    public static string SA1010MessageNotPreceded { get; }
    public static string SA1010Title { get; }
    public static string SA1011Description { get; }
    public static string SA1011MessageFormat { get; }
    public static string SA1011Title { get; }
    public static string SA1012Description { get; }
    public static string SA1012MessageFormat { get; }
    public static string SA1012Title { get; }
    public static string SA1013Description { get; }
    public static string SA1013MessageFormat { get; }
    public static string SA1013Title { get; }
    public static string SA1014Description { get; }
    public static string SA1014MessageFormat { get; }
    public static string SA1014Title { get; }
    public static string SA1015Description { get; }
    public static string SA1015MessageFollowed { get; }
    public static string SA1015MessageNotFollowed { get; }
    public static string SA1015MessageNotPreceded { get; }
    public static string SA1015Title { get; }
    public static string SA1016Description { get; }
    public static string SA1016MessageFormat { get; }
    public static string SA1016Title { get; }
    public static string SA1017Description { get; }
    public static string SA1017MessageFormat { get; }
    public static string SA1017Title { get; }
    public static string SA1018CodeFix { get; }
    public static string SA1018Description { get; }
    public static string SA1018MessageFormat { get; }
    public static string SA1018Title { get; }
    public static string SA1019Description { get; }
    public static string SA1019MessageNotFollowed { get; }
    public static string SA1019MessageNotPreceded { get; }
    public static string SA1019Title { get; }
    public static string SA1020Description { get; }
    public static string SA1020MessageFormat { get; }
    public static string SA1020Title { get; }
    public static string SA1021Description { get; }
    public static string SA1021MessageFormat { get; }
    public static string SA1021Title { get; }
    public static string SA1022Description { get; }
    public static string SA1022MessageFormat { get; }
    public static string SA1022Title { get; }
    public static string SA1023Description { get; }
    public static string SA1023MessageFollowed { get; }
    public static string SA1023MessageNotAtBeginningOfLine { get; }
    public static string SA1023MessageNotAtEndOfLine { get; }
    public static string SA1023MessageNotFollowed { get; }
    public static string SA1023MessageNotPreceded { get; }
    public static string SA1023Title { get; }
    public static string SA1024Description { get; }
    public static string SA1024MessageFollowed { get; }
    public static string SA1024MessageNotPreceded { get; }
    public static string SA1024MessagePreceded { get; }
    public static string SA1024Title { get; }
    public static string SA1025CodeFix { get; }
    public static string SA1025Description { get; }
    public static string SA1025MessageFormat { get; }
    public static string SA1025Title { get; }
    public static string SA1026Description { get; }
    public static string SA1026MessageFormat { get; }
    public static string SA1026Title { get; }
    public static string SA1027CodeFix { get; }
    public static string SA1027Description { get; }
    public static string SA1027MessageFormat { get; }
    public static string SA1027Title { get; }
    public static string SA1028CodeFix { get; }
    public static string SA1028Description { get; }
    public static string SA1028MessageFormat { get; }
    public static string SA1028Title { get; }
    public static string TokenSpacingCodeFix { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_SA1000Description();
    public static string get_SA1000MessageFormat();
    public static string get_SA1000Title();
    public static string get_SA1001Description();
    public static string get_SA1001MessageFormat();
    public static string get_SA1001Title();
    public static string get_SA1002Description();
    public static string get_SA1002MessageFormat();
    public static string get_SA1002Title();
    public static string get_SA1003CodeFix();
    public static string get_SA1003Description();
    public static string get_SA1003MessageFormatFollowedByWhitespace();
    public static string get_SA1003MessageFormatNotAtEndOfLine();
    public static string get_SA1003MessageFormatNotFollowedByComment();
    public static string get_SA1003MessageFormatNotFollowedByWhitespace();
    public static string get_SA1003MessageFormatNotPrecededByWhitespace();
    public static string get_SA1003MessageFormatPrecededByWhitespace();
    public static string get_SA1003Title();
    public static string get_SA1004CodeFix();
    public static string get_SA1004Description();
    public static string get_SA1004MessageFormat();
    public static string get_SA1004Title();
    public static string get_SA1005CodeFix();
    public static string get_SA1005Description();
    public static string get_SA1005MessageFormat();
    public static string get_SA1005Title();
    public static string get_SA1006Description();
    public static string get_SA1006MessageFormat();
    public static string get_SA1006Title();
    public static string get_SA1007Description();
    public static string get_SA1007MessageFormat();
    public static string get_SA1007Title();
    public static string get_SA1008CodeFix();
    public static string get_SA1008Description();
    public static string get_SA1008MessageNotFollowed();
    public static string get_SA1008MessageNotPreceded();
    public static string get_SA1008MessagePreceded();
    public static string get_SA1008Title();
    public static string get_SA1009Description();
    public static string get_SA1009MessageFollowed();
    public static string get_SA1009MessageNotFollowed();
    public static string get_SA1009MessageNotPreceded();
    public static string get_SA1009Title();
    public static string get_SA1010Description();
    public static string get_SA1010MessageNotFollowed();
    public static string get_SA1010MessageNotPreceded();
    public static string get_SA1010Title();
    public static string get_SA1011Description();
    public static string get_SA1011MessageFormat();
    public static string get_SA1011Title();
    public static string get_SA1012Description();
    public static string get_SA1012MessageFormat();
    public static string get_SA1012Title();
    public static string get_SA1013Description();
    public static string get_SA1013MessageFormat();
    public static string get_SA1013Title();
    public static string get_SA1014Description();
    public static string get_SA1014MessageFormat();
    public static string get_SA1014Title();
    public static string get_SA1015Description();
    public static string get_SA1015MessageFollowed();
    public static string get_SA1015MessageNotFollowed();
    public static string get_SA1015MessageNotPreceded();
    public static string get_SA1015Title();
    public static string get_SA1016Description();
    public static string get_SA1016MessageFormat();
    public static string get_SA1016Title();
    public static string get_SA1017Description();
    public static string get_SA1017MessageFormat();
    public static string get_SA1017Title();
    public static string get_SA1018CodeFix();
    public static string get_SA1018Description();
    public static string get_SA1018MessageFormat();
    public static string get_SA1018Title();
    public static string get_SA1019Description();
    public static string get_SA1019MessageNotFollowed();
    public static string get_SA1019MessageNotPreceded();
    public static string get_SA1019Title();
    public static string get_SA1020Description();
    public static string get_SA1020MessageFormat();
    public static string get_SA1020Title();
    public static string get_SA1021Description();
    public static string get_SA1021MessageFormat();
    public static string get_SA1021Title();
    public static string get_SA1022Description();
    public static string get_SA1022MessageFormat();
    public static string get_SA1022Title();
    public static string get_SA1023Description();
    public static string get_SA1023MessageFollowed();
    public static string get_SA1023MessageNotAtBeginningOfLine();
    public static string get_SA1023MessageNotAtEndOfLine();
    public static string get_SA1023MessageNotFollowed();
    public static string get_SA1023MessageNotPreceded();
    public static string get_SA1023Title();
    public static string get_SA1024Description();
    public static string get_SA1024MessageFollowed();
    public static string get_SA1024MessageNotPreceded();
    public static string get_SA1024MessagePreceded();
    public static string get_SA1024Title();
    public static string get_SA1025CodeFix();
    public static string get_SA1025Description();
    public static string get_SA1025MessageFormat();
    public static string get_SA1025Title();
    public static string get_SA1026Description();
    public static string get_SA1026MessageFormat();
    public static string get_SA1026Title();
    public static string get_SA1027CodeFix();
    public static string get_SA1027Description();
    public static string get_SA1027MessageFormat();
    public static string get_SA1027Title();
    public static string get_SA1028CodeFix();
    public static string get_SA1028Description();
    public static string get_SA1028MessageFormat();
    public static string get_SA1028Title();
    public static string get_TokenSpacingCodeFix();
}
internal static class StyleCop.Analyzers.SpacingRules.TokenSpacingProperties : object {
    internal static string LocationKey;
    internal static string ActionKey;
    internal static string LayoutKey;
    internal static string LocationPreceding;
    internal static string LocationFollowing;
    internal static string ActionInsert;
    internal static string ActionRemove;
    internal static string ActionRemoveImmediate;
    internal static string LayoutPack;
    internal static string LayoutPreserve;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <InsertPreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemoveImmediatePreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemovePreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemovePrecedingPreserveLayout>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <InsertFollowing>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemoveFollowing>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemoveFollowingPreserveLayout>k__BackingField;
    internal static ImmutableDictionary`2<string, string> InsertPreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemoveImmediatePreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemovePreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemovePrecedingPreserveLayout { get; }
    internal static ImmutableDictionary`2<string, string> InsertFollowing { get; }
    internal static ImmutableDictionary`2<string, string> RemoveFollowing { get; }
    internal static ImmutableDictionary`2<string, string> RemoveFollowingPreserveLayout { get; }
    private static TokenSpacingProperties();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_InsertPreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemoveImmediatePreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemovePreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemovePrecedingPreserveLayout();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_InsertFollowing();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemoveFollowing();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemoveFollowingPreserveLayout();
}
[NoCodeFixAttribute("The necessary actions for this code fix are not supported by the analysis infrastructure.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA0001XmlCommentAnalysisDisabled();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[NoCodeFixAttribute("No automatic code fix is possible for general JSON syntax errors.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationAnalysisContext> CompilationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA0002InvalidSettingsFile();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilation(CompilationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StyleCop.Analyzers.SpecialRules.SpecialResources : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    public static ResourceManager ResourceManager { get; }
    [NullableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string SA0001Description { get; }
    public static string SA0001MessageFormat { get; }
    public static string SA0001Title { get; }
    public static string SA0002Description { get; }
    public static string SA0002MessageFormat { get; }
    public static string SA0002Title { get; }
    public static ResourceManager get_ResourceManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    [NullableContextAttribute("2")]
internal static string GetResourceString(string resourceKey, string defaultValue);
    public static string get_SA0001Description();
    public static string get_SA0001MessageFormat();
    public static string get_SA0001Title();
    public static string get_SA0002Description();
    public static string get_SA0002MessageFormat();
    public static string get_SA0002Title();
}
[AttributeUsageAttribute("2432")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[ExtensionAttribute]
internal static class System.Linq.SyntaxTriviaListEnumerable : object {
    [ExtensionAttribute]
internal static bool Contains(SyntaxTriviaList list, SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool Any(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
internal static bool All(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
internal static SyntaxTrivia LastOrDefault(SyntaxTriviaList list, SyntaxKind kind);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
