[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonArray/JsonArrayDebugView")]
internal class LightJson.JsonArray : object {
    private IList`1<JsonValue> items;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public JsonArray(JsonValue[] values);
    public int get_Count();
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public JsonArray Add(JsonValue value);
    public JsonArray Insert(int index, JsonValue value);
    public JsonArray Remove(int index);
    public JsonArray Clear();
    public bool Contains(JsonValue item);
    public int IndexOf(JsonValue item);
    public sealed virtual IEnumerator`1<JsonValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonObject/JsonObjectDebugView")]
internal class LightJson.JsonObject : object {
    private IDictionary`2<string, JsonValue> properties;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public int get_Count();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonObject Add(string key);
    public JsonObject Add(string key, JsonValue value);
    public bool Remove(string key);
    public JsonObject Clear();
    public JsonObject Rename(string oldKey, string newKey);
    public bool ContainsKey(string key);
    public bool Contains(JsonValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<JsonValue> System.Collections.Generic.IEnumerable<LightJson.JsonValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
[DebuggerTypeProxyAttribute("LightJson.JsonValue/JsonValueDebugView")]
internal class LightJson.JsonValue : ValueType {
    public static JsonValue Null;
    private JsonValueType type;
    private object reference;
    private double value;
    public JsonValueType Type { get; }
    public bool IsNull { get; }
    public bool IsBoolean { get; }
    public bool IsInteger { get; }
    public bool IsNumber { get; }
    public bool IsString { get; }
    public bool IsJsonObject { get; }
    public bool IsJsonArray { get; }
    public bool IsDateTime { get; }
    public bool AsBoolean { get; }
    public int AsInteger { get; }
    public double AsNumber { get; }
    public string AsString { get; }
    public JsonObject AsJsonObject { get; }
    public JsonArray AsJsonArray { get; }
    public Nullable`1<DateTime> AsDateTime { get; }
    public object AsObject { get; }
    public JsonValue Item { get; public set; }
    public JsonValue Item { get; public set; }
    public JsonValue(Nullable`1<bool> value);
    public JsonValue(Nullable`1<double> value);
    public JsonValue(string value);
    public JsonValue(JsonObject value);
    public JsonValue(JsonArray value);
    private JsonValue(JsonValueType type, double value, object reference);
    private static JsonValue();
    public JsonValueType get_Type();
    public bool get_IsNull();
    public bool get_IsBoolean();
    public bool get_IsInteger();
    public bool get_IsNumber();
    public bool get_IsString();
    public bool get_IsJsonObject();
    public bool get_IsJsonArray();
    public bool get_IsDateTime();
    public bool get_AsBoolean();
    public int get_AsInteger();
    public double get_AsNumber();
    public string get_AsString();
    public JsonObject get_AsJsonObject();
    public JsonArray get_AsJsonArray();
    public Nullable`1<DateTime> get_AsDateTime();
    public object get_AsObject();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public static JsonValue op_Implicit(Nullable`1<bool> value);
    public static JsonValue op_Implicit(Nullable`1<double> value);
    public static JsonValue op_Implicit(string value);
    public static JsonValue op_Implicit(JsonObject value);
    public static JsonValue op_Implicit(JsonArray value);
    public static JsonValue op_Implicit(Nullable`1<DateTime> value);
    public static int op_Explicit(JsonValue jsonValue);
    public static Nullable`1<int> op_Explicit(JsonValue jsonValue);
    public static bool op_Explicit(JsonValue jsonValue);
    public static Nullable`1<bool> op_Explicit(JsonValue jsonValue);
    public static double op_Explicit(JsonValue jsonValue);
    public static Nullable`1<double> op_Explicit(JsonValue jsonValue);
    public static string op_Explicit(JsonValue jsonValue);
    public static JsonObject op_Explicit(JsonValue jsonValue);
    public static JsonArray op_Explicit(JsonValue jsonValue);
    public static DateTime op_Explicit(JsonValue jsonValue);
    public static Nullable`1<DateTime> op_Explicit(JsonValue jsonValue);
    public static bool op_Equality(JsonValue a, JsonValue b);
    public static bool op_Inequality(JsonValue a, JsonValue b);
    public static JsonValue Parse(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum LightJson.JsonValueType : Enum {
    public byte value__;
    public static JsonValueType Null;
    public static JsonValueType Boolean;
    public static JsonValueType Number;
    public static JsonValueType String;
    public static JsonValueType Object;
    public static JsonValueType Array;
}
internal class LightJson.Serialization.JsonParseException : Exception {
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    public TextPosition Position { get; private set; }
    public ErrorType Type { get; private set; }
    public JsonParseException(ErrorType type, TextPosition position);
    public JsonParseException(string message, ErrorType type, TextPosition position);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(TextPosition value);
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ErrorType value);
    private static string GetDefaultMessage(ErrorType type);
}
internal class LightJson.Serialization.JsonReader : object {
    private TextScanner scanner;
    private JsonReader(TextReader reader);
    public static JsonValue Parse(TextReader reader);
    public static JsonValue Parse(string source);
    private string ReadJsonKey();
    private JsonValue ReadJsonValue();
    private JsonValue ReadNull();
    private JsonValue ReadBoolean();
    private void ReadDigits(StringBuilder builder);
    private JsonValue ReadNumber();
    private string ReadString();
    private int ReadHexDigit();
    private char ReadUnicodeLiteral();
    private JsonObject ReadObject();
    private JsonObject ReadObject(JsonObject jsonObject);
    private JsonArray ReadArray();
    private JsonArray ReadArray(JsonArray jsonArray);
    private JsonValue Parse();
}
internal class LightJson.Serialization.JsonSerializationException : Exception {
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    public ErrorType Type { get; }
    public JsonSerializationException(ErrorType type);
    public JsonSerializationException(string message, ErrorType type);
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    private static string GetDefaultMessage(ErrorType type);
}
internal class LightJson.Serialization.JsonWriter : object {
    private int indent;
    private bool isNewLine;
    private TextWriter writer;
    private HashSet`1<IEnumerable`1<JsonValue>> renderingCollections;
    [CompilerGeneratedAttribute]
private string <IndentString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpacingString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLineString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortObjects>k__BackingField;
    public string IndentString { get; public set; }
    public string SpacingString { get; public set; }
    public string NewLineString { get; public set; }
    public bool SortObjects { get; public set; }
    public JsonWriter(bool pretty);
    [CompilerGeneratedAttribute]
public string get_IndentString();
    [CompilerGeneratedAttribute]
public void set_IndentString(string value);
    [CompilerGeneratedAttribute]
public string get_SpacingString();
    [CompilerGeneratedAttribute]
public void set_SpacingString(string value);
    [CompilerGeneratedAttribute]
public string get_NewLineString();
    [CompilerGeneratedAttribute]
public void set_NewLineString(string value);
    [CompilerGeneratedAttribute]
public bool get_SortObjects();
    [CompilerGeneratedAttribute]
public void set_SortObjects(bool value);
    public string Serialize(JsonValue jsonValue);
    public sealed virtual void Dispose();
    private static bool IsValidNumber(double number);
    private void Initialize();
    private void Write(string text);
    private void WriteEncodedJsonValue(JsonValue value);
    private void WriteEncodedString(string text);
    private void WriteIndentation();
    private void WriteSpacing();
    private void WriteLine();
    private void WriteLine(string line);
    private void AddRenderingCollection(IEnumerable`1<JsonValue> value);
    private void RemoveRenderingCollection(IEnumerable`1<JsonValue> value);
    private void Render(JsonValue value);
    private void Render(JsonArray value);
    private void Render(JsonObject value);
    private IEnumerator`1<KeyValuePair`2<string, JsonValue>> GetJsonObjectEnumerator(JsonObject jsonObject);
}
internal class LightJson.Serialization.TextPosition : ValueType {
    public long Column;
    public long Line;
}
internal class LightJson.Serialization.TextScanner : object {
    private TextReader reader;
    private TextPosition position;
    public TextPosition Position { get; }
    public TextScanner(TextReader reader);
    public TextPosition get_Position();
    public char Peek();
    public int Peek(bool throwAtEndOfFile);
    public char Read();
    public void SkipWhitespace();
    public void Assert(char next);
    public void Assert(string next);
    private void SkipComment();
    private void SkipLineComment();
    private void SkipBlockComment();
}
internal static class StyleCop.Analyzers.AnalyzerCategory : object {
    internal static string DocumentationRules;
    internal static string LayoutRules;
    internal static string MaintainabilityRules;
    internal static string NamingRules;
    internal static string OrderingRules;
    internal static string ReadabilityRules;
    internal static string SpacingRules;
    internal static string SpecialRules;
}
internal static class StyleCop.Analyzers.AnalyzerConstants : object {
    [CompilerGeneratedAttribute]
private static bool <DisabledNoTests>k__BackingField;
    [ExcludeFromCodeCoverageAttribute]
internal static bool DisabledNoTests { get; }
    internal static bool DisabledAlternative { get; }
    internal static bool EnabledByDefault { get; }
    internal static bool DisabledByDefault { get; }
    private static AnalyzerConstants();
    [CompilerGeneratedAttribute]
internal static bool get_DisabledNoTests();
    internal static bool get_DisabledAlternative();
    internal static bool get_EnabledByDefault();
    internal static bool get_DisabledByDefault();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.AnalyzerExtensions : object {
    [ExtensionAttribute]
public static void RegisterSyntaxTreeAction(AnalysisContext context, Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> action);
    [ExtensionAttribute]
public static void RegisterSyntaxTreeAction(CompilationStartAnalysisContext context, Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> action);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(AnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, TLanguageKindEnum syntaxKind);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(AnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(CompilationStartAnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, TLanguageKindEnum syntaxKind);
    [ExtensionAttribute]
public static void RegisterSyntaxNodeAction(CompilationStartAnalysisContext context, Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal enum StyleCop.Analyzers.DeserializationFailureBehavior : Enum {
    public int value__;
    public static DeserializationFailureBehavior ReturnDefaultSettings;
    public static DeserializationFailureBehavior ThrowException;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.DocumentationRules.DocumentationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ConstructorDocumentationCodeFix { get; }
    internal static string DestructorDocumentationCodeFix { get; }
    internal static string DestructorStandardTextFirstPart { get; }
    internal static string DestructorStandardTextSecondPart { get; }
    internal static string InheritdocCodeFix { get; }
    internal static string MethodDocumentationCodeFix { get; }
    internal static string NonPrivateConstructorStandardTextFirstPart { get; }
    internal static string NonPrivateConstructorStandardTextSecondPart { get; }
    internal static string ParameterNotUsed { get; }
    internal static string PrivateConstructorStandardTextFirstPart { get; }
    internal static string PrivateConstructorStandardTextSecondPart { get; }
    internal static string PropertySummaryStartTextCodeFix { get; }
    internal static string SA1609SA1610CodeFix { get; }
    internal static string SA1611Description { get; }
    internal static string SA1611MessageFormat { get; }
    internal static string SA1611Title { get; }
    internal static string SA1615SA1616CodeFix { get; }
    internal static string SA1617CodeFix { get; }
    internal static string SA1620Description { get; }
    internal static string SA1620MissingMessageFormat { get; }
    internal static string SA1620Title { get; }
    internal static string SA1620WrongOrderMessageFormat { get; }
    internal static string SA1621Description { get; }
    internal static string SA1621MessageFormat { get; }
    internal static string SA1621Title { get; }
    internal static string SA1622Description { get; }
    internal static string SA1622MessageFormat { get; }
    internal static string SA1622Title { get; }
    internal static string SA1623Description { get; }
    internal static string SA1623MessageFormat { get; }
    internal static string SA1623Title { get; }
    internal static string SA1624Description { get; }
    internal static string SA1624MessageFormat { get; }
    internal static string SA1624Title { get; }
    internal static string SA1626CodeFix { get; }
    internal static string SA1627Description { get; }
    internal static string SA1627MessageFormat { get; }
    internal static string SA1627Title { get; }
    internal static string SA1629CodeFix { get; }
    internal static string SA1629Description { get; }
    internal static string SA1629MessageFormat { get; }
    internal static string SA1629Title { get; }
    internal static string SA1633CodeFix { get; }
    internal static string SA1633Description { get; }
    internal static string SA1633MessageFormatMalformed { get; }
    internal static string SA1633MessageFormatMissing { get; }
    internal static string SA1633Title { get; }
    internal static string SA1634Description { get; }
    internal static string SA1634MessageFormat { get; }
    internal static string SA1634Title { get; }
    internal static string SA1635Description { get; }
    internal static string SA1635MessageFormat { get; }
    internal static string SA1635Title { get; }
    internal static string SA1636Description { get; }
    internal static string SA1636MessageFormat { get; }
    internal static string SA1636Title { get; }
    internal static string SA1637Description { get; }
    internal static string SA1637MessageFormat { get; }
    internal static string SA1637Title { get; }
    internal static string SA1638Description { get; }
    internal static string SA1638MessageFormat { get; }
    internal static string SA1638Title { get; }
    internal static string SA1639Description { get; }
    internal static string SA1639MessageFormat { get; }
    internal static string SA1639Title { get; }
    internal static string SA1640Description { get; }
    internal static string SA1640MessageFormat { get; }
    internal static string SA1640Title { get; }
    internal static string SA1641Description { get; }
    internal static string SA1641MessageFormat { get; }
    internal static string SA1641Title { get; }
    internal static string SA1642SA1643CodeFix { get; }
    internal static string SA1648Description { get; }
    internal static string SA1648MessageFormat { get; }
    internal static string SA1648Title { get; }
    internal static string SA1649CodeFix { get; }
    internal static string SA1649Description { get; }
    internal static string SA1649MessageFormat { get; }
    internal static string SA1649Title { get; }
    internal static string SA1651CodeFix { get; }
    internal static string StartingTextGets { get; }
    internal static string StartingTextGetsOrSets { get; }
    internal static string StartingTextGetsOrSetsWhether { get; }
    internal static string StartingTextGetsWhether { get; }
    internal static string StartingTextSets { get; }
    internal static string StartingTextSetsWhether { get; }
    internal static string StaticConstructorStandardTextFirstPart { get; }
    internal static string StaticConstructorStandardTextSecondPart { get; }
    internal static string TaskReturnElementFirstPart { get; }
    internal static string TaskReturnElementSecondPart { get; }
    internal static string TypeTextClass { get; }
    internal static string TypeTextStruct { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ConstructorDocumentationCodeFix();
    internal static string get_DestructorDocumentationCodeFix();
    internal static string get_DestructorStandardTextFirstPart();
    internal static string get_DestructorStandardTextSecondPart();
    internal static string get_InheritdocCodeFix();
    internal static string get_MethodDocumentationCodeFix();
    internal static string get_NonPrivateConstructorStandardTextFirstPart();
    internal static string get_NonPrivateConstructorStandardTextSecondPart();
    internal static string get_ParameterNotUsed();
    internal static string get_PrivateConstructorStandardTextFirstPart();
    internal static string get_PrivateConstructorStandardTextSecondPart();
    internal static string get_PropertySummaryStartTextCodeFix();
    internal static string get_SA1609SA1610CodeFix();
    internal static string get_SA1611Description();
    internal static string get_SA1611MessageFormat();
    internal static string get_SA1611Title();
    internal static string get_SA1615SA1616CodeFix();
    internal static string get_SA1617CodeFix();
    internal static string get_SA1620Description();
    internal static string get_SA1620MissingMessageFormat();
    internal static string get_SA1620Title();
    internal static string get_SA1620WrongOrderMessageFormat();
    internal static string get_SA1621Description();
    internal static string get_SA1621MessageFormat();
    internal static string get_SA1621Title();
    internal static string get_SA1622Description();
    internal static string get_SA1622MessageFormat();
    internal static string get_SA1622Title();
    internal static string get_SA1623Description();
    internal static string get_SA1623MessageFormat();
    internal static string get_SA1623Title();
    internal static string get_SA1624Description();
    internal static string get_SA1624MessageFormat();
    internal static string get_SA1624Title();
    internal static string get_SA1626CodeFix();
    internal static string get_SA1627Description();
    internal static string get_SA1627MessageFormat();
    internal static string get_SA1627Title();
    internal static string get_SA1629CodeFix();
    internal static string get_SA1629Description();
    internal static string get_SA1629MessageFormat();
    internal static string get_SA1629Title();
    internal static string get_SA1633CodeFix();
    internal static string get_SA1633Description();
    internal static string get_SA1633MessageFormatMalformed();
    internal static string get_SA1633MessageFormatMissing();
    internal static string get_SA1633Title();
    internal static string get_SA1634Description();
    internal static string get_SA1634MessageFormat();
    internal static string get_SA1634Title();
    internal static string get_SA1635Description();
    internal static string get_SA1635MessageFormat();
    internal static string get_SA1635Title();
    internal static string get_SA1636Description();
    internal static string get_SA1636MessageFormat();
    internal static string get_SA1636Title();
    internal static string get_SA1637Description();
    internal static string get_SA1637MessageFormat();
    internal static string get_SA1637Title();
    internal static string get_SA1638Description();
    internal static string get_SA1638MessageFormat();
    internal static string get_SA1638Title();
    internal static string get_SA1639Description();
    internal static string get_SA1639MessageFormat();
    internal static string get_SA1639Title();
    internal static string get_SA1640Description();
    internal static string get_SA1640MessageFormat();
    internal static string get_SA1640Title();
    internal static string get_SA1641Description();
    internal static string get_SA1641MessageFormat();
    internal static string get_SA1641Title();
    internal static string get_SA1642SA1643CodeFix();
    internal static string get_SA1648Description();
    internal static string get_SA1648MessageFormat();
    internal static string get_SA1648Title();
    internal static string get_SA1649CodeFix();
    internal static string get_SA1649Description();
    internal static string get_SA1649MessageFormat();
    internal static string get_SA1649Title();
    internal static string get_SA1651CodeFix();
    internal static string get_StartingTextGets();
    internal static string get_StartingTextGetsOrSets();
    internal static string get_StartingTextGetsOrSetsWhether();
    internal static string get_StartingTextGetsWhether();
    internal static string get_StartingTextSets();
    internal static string get_StartingTextSetsWhether();
    internal static string get_StaticConstructorStandardTextFirstPart();
    internal static string get_StaticConstructorStandardTextSecondPart();
    internal static string get_TaskReturnElementFirstPart();
    internal static string get_TaskReturnElementSecondPart();
    internal static string get_TypeTextClass();
    internal static string get_TypeTextStruct();
}
internal abstract class StyleCop.Analyzers.DocumentationRules.ElementDocumentationBase : DiagnosticAnalyzer {
    private string matchElementName;
    private bool inheritDocSuppressesWarnings;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> constructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> delegateDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> indexerDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> operatorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> conversionOperatorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> baseTypeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> fieldDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    protected ElementDocumentationBase(bool inheritDocSuppressesWarnings, string matchElementName);
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected abstract virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleOperatorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConversionOperatorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleFieldDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, SyntaxNode node, Location[] locations);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.ElementDocumentationSummaryBase : DiagnosticAnalyzer {
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> typeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> constructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> destructorDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> indexerDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> fieldDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> delegateDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> eventDeclarationAction;
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
    private void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDestructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleFieldDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleEventDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, Location[] locations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.FileHeaderAnalyzers : DiagnosticAnalyzer {
    private static string SA1633Identifier;
    private static string SA1634Identifier;
    private static string SA1635Identifier;
    private static string SA1636Identifier;
    private static string SA1637Identifier;
    private static string SA1638Identifier;
    private static string SA1639Identifier;
    private static string SA1640Identifier;
    private static string SA1641Identifier;
    private static LocalizableString SA1633Title;
    private static LocalizableString SA1633MessageFormatMissing;
    private static LocalizableString SA1633MessageFormatMalformed;
    private static LocalizableString SA1633Description;
    private static string SA1633HelpLink;
    private static LocalizableString SA1634Title;
    private static LocalizableString SA1634MessageFormat;
    private static LocalizableString SA1634Description;
    private static string SA1634HelpLink;
    private static LocalizableString SA1635Title;
    private static LocalizableString SA1635MessageFormat;
    private static LocalizableString SA1635Description;
    private static string SA1635HelpLink;
    private static LocalizableString SA1636Title;
    private static LocalizableString SA1636MessageFormat;
    private static LocalizableString SA1636Description;
    private static string SA1636HelpLink;
    private static LocalizableString SA1637Title;
    private static LocalizableString SA1637MessageFormat;
    private static LocalizableString SA1637Description;
    private static string SA1637HelpLink;
    private static LocalizableString SA1638Title;
    private static LocalizableString SA1638MessageFormat;
    private static LocalizableString SA1638Description;
    private static string SA1638HelpLink;
    private static LocalizableString SA1639Title;
    private static LocalizableString SA1639MessageFormat;
    private static LocalizableString SA1639Description;
    private static string SA1639HelpLink;
    private static LocalizableString SA1640Title;
    private static LocalizableString SA1640MessageFormat;
    private static LocalizableString SA1640Description;
    private static string SA1640HelpLink;
    private static LocalizableString SA1641Title;
    private static LocalizableString SA1641MessageFormat;
    private static LocalizableString SA1641Description;
    private static string SA1641HelpLink;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1633DescriptorMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1633DescriptorMalformed>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1634Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1635Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1636Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1637Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1638Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1639Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1640Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1641Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1633DescriptorMissing { get; }
    public static DiagnosticDescriptor SA1633DescriptorMalformed { get; }
    public static DiagnosticDescriptor SA1634Descriptor { get; }
    public static DiagnosticDescriptor SA1635Descriptor { get; }
    public static DiagnosticDescriptor SA1636Descriptor { get; }
    public static DiagnosticDescriptor SA1637Descriptor { get; }
    public static DiagnosticDescriptor SA1638Descriptor { get; }
    public static DiagnosticDescriptor SA1639Descriptor { get; }
    public static DiagnosticDescriptor SA1640Descriptor { get; }
    public static DiagnosticDescriptor SA1641Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FileHeaderAnalyzers();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1633DescriptorMissing();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1633DescriptorMalformed();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1634Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1635Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1636Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1637Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1638Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1639Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1640Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1641Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.GenericTypeParameterDocumentationAnalyzer : DiagnosticAnalyzer {
    private static string SA1620DiagnosticId;
    private static LocalizableString SA1620Title;
    private static LocalizableString SA1620MissingMessageFormat;
    private static LocalizableString SA1620WrongOrderMessageFormat;
    private static LocalizableString SA1620Description;
    private static string SA1620HelpLink;
    private static string SA1621DiagnosticId;
    private static LocalizableString SA1621Title;
    private static LocalizableString SA1621MessageFormat;
    private static LocalizableString SA1621Description;
    private static string SA1621HelpLink;
    private static string SA1622DiagnosticId;
    private static LocalizableString SA1622Title;
    private static LocalizableString SA1622MessageFormat;
    private static LocalizableString SA1622Description;
    private static string SA1622HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1620MissingTypeParameterDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1620WrongOrderDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1621Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1622Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1620MissingTypeParameterDescriptor { get; }
    public static DiagnosticDescriptor SA1620WrongOrderDescriptor { get; }
    public static DiagnosticDescriptor SA1621Descriptor { get; }
    public static DiagnosticDescriptor SA1622Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GenericTypeParameterDocumentationAnalyzer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1620MissingTypeParameterDescriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1620WrongOrderDescriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1621Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1622Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context, SyntaxNode node, TypeParameterListSyntax typeParameterList);
    private static void HandleTypeParamElement(SyntaxNodeAnalysisContext context, string documentedParameterName, int index, TypeParameterListSyntax typeParameterList, Location locationToReport);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.PartialElementDocumentationSummaryBase : DiagnosticAnalyzer {
    private static XElement EmptyElement;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> typeDeclarationAction;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;
    private static PartialElementDocumentationSummaryBase();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool IsPartialMethodDefinition(SyntaxNode node);
    private void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, Location[] locations);
    private string ExpandDocumentation(Compilation compilation, DocumentationCommentTriviaSyntax documentCommentTrivia, XmlNodeSyntax includeTag);
    private void ExpandIncludeTag(Compilation compilation, StringBuilder sb, XmlNodeSyntax xmlNode);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.PropertyDocumentationBase : DiagnosticAnalyzer {
    internal static string NoCodeFixKey;
    private Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;
    protected string XmlTagToHandle { get; }
    protected abstract virtual string get_XmlTagToHandle();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
    private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, Location location);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.PropertySummaryDocumentationAnalyzer : PropertyDocumentationBase {
    public static string ExpectedTextKey;
    public static string TextToRemoveKey;
    private static string SA1623DiagnosticId;
    private static string SA1624DiagnosticId;
    private static LocalizableString SA1623Title;
    private static LocalizableString SA1623MessageFormat;
    private static LocalizableString SA1623Description;
    private static string SA1623HelpLink;
    private static LocalizableString SA1624Title;
    private static LocalizableString SA1624MessageFormat;
    private static LocalizableString SA1624Description;
    private static string SA1624HelpLink;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1623Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1624Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1623Descriptor { get; }
    public static DiagnosticDescriptor SA1624Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static PropertySummaryDocumentationAnalyzer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1623Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1624Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
    private static void AnalyzeSummaryElement(SyntaxNodeAnalysisContext context, XmlNodeSyntax syntax, Location diagnosticLocation, PropertyDeclarationSyntax propertyDeclaration, string startingTextGets, string startingTextSets, string startingTextGetsOrSets);
    private static void ReportSA1623(SyntaxNodeAnalysisContext context, Location diagnosticLocation, Builder<string, string> diagnosticProperties, string text, string expectedStartingText, string unexpectedStartingText1, string unexpectedStartingText2);
    private static void ReportSA1624(SyntaxNodeAnalysisContext context, Location diagnosticLocation, Builder<string, string> diagnosticProperties, string accessor, string expectedStartingText, string startingTextToRemove);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1600ElementsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseTypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseTypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ConstructorDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DestructorDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> PropertyDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> IndexerDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> FieldDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EventDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EventFieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1600ElementsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public static bool NeedsComment(DocumentationSettings documentationSettings, SyntaxKind syntaxKind, SyntaxKind parentSyntaxKind, Accessibility declaredAccessibility, Accessibility effectiveAccessibility);
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1601PartialElementsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseTypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> BaseTypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1601PartialElementsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1602EnumerationItemsMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> EnumMemberDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1602EnumerationItemsMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1570.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1603DocumentationMustContainValidXml : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1603DocumentationMustContainValidXml();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1604ElementDocumentationMustHaveSummary : ElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1604ElementDocumentationMustHaveSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1605PartialElementDocumentationMustHaveSummary : PartialElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1605PartialElementDocumentationMustHaveSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1606ElementDocumentationMustHaveSummaryText : ElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1606ElementDocumentationMustHaveSummaryText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1607PartialElementDocumentationMustHaveSummaryText : PartialElementDocumentationSummaryBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1607PartialElementDocumentationMustHaveSummaryText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1608ElementDocumentationMustNotHaveDefaultSummary : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static string DefaultText;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1608ElementDocumentationMustNotHaveDefaultSummary();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool IsDefaultText(string text);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1609PropertyDocumentationMustHaveValue : PropertyDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static SA1609PropertyDocumentationMustHaveValue();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1610PropertyDocumentationMustHaveValueText : PropertyDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string XmlTagToHandle { get; }
    private static SA1610PropertyDocumentationMustHaveValueText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual string get_XmlTagToHandle();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, XmlNodeSyntax syntax, XElement completeDocumentation, Location diagnosticLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1611ElementParametersMustBeDocumented : ElementDocumentationBase {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1611ElementParametersMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static IEnumerable`1<ParameterSyntax> GetParameters(SyntaxNode node);
    private static void ReportMissingParameters(SyntaxNodeAnalysisContext context, IEnumerable`1<ParameterSyntax> parameterList, IEnumerable`1<string> documentationParameterNames);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1612ElementParameterDocumentationMustMatchElementParameters : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string Description;
    private static string HelpLink;
    private static string MissingParamForDocumentationMessageFormat;
    private static string ParamWrongOrderMessageFormat;
    private static DiagnosticDescriptor MissingParameterDescriptor;
    private static DiagnosticDescriptor OrderDescriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1612ElementParameterDocumentationMustMatchElementParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static IEnumerable`1<ParameterSyntax> GetParameters(SyntaxNode node);
    private static Nullable`1<SyntaxToken> GetIdentifier(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1613ElementParameterDocumentationMustDeclareParameterName : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1613ElementParameterDocumentationMustDeclareParameterName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1614ElementParameterDocumentationMustHaveText : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1614ElementParameterDocumentationMustHaveText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1615ElementReturnValueMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1615ElementReturnValueMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, TypeSyntax returnType);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1616ElementReturnValueDocumentationMustHaveText : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1616ElementReturnValueDocumentationMustHaveText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1617VoidReturnValueMustNotBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1617VoidReturnValueMustNotBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMember(SyntaxNodeAnalysisContext context, TypeSyntax returnValue);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1618GenericTypeParametersMustBeDocumented : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> MethodDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> DelegateDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1618GenericTypeParametersMustBeDocumented();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, TypeParameterListSyntax typeParameterList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1619GenericTypeParametersMustBeDocumentedPartialClass : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1619GenericTypeParametersMustBeDocumentedPartialClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1625ElementDocumentationMustNotBeCopiedAndPasted : ElementDocumentationBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1625ElementDocumentationMustNotBeCopiedAndPasted();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static bool ShouldSkipElement(string element, string parameterNotUsed);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> SingleLineDocumentationTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1626SingleLineCommentsMustNotUseDocumentationStyleSlashes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSingleLineDocumentationTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1627DocumentationTextMustNotBeEmpty : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> XmlElementAction;
    private static Action`1<SyntaxNodeAnalysisContext> XmlEmptyElementAction;
    private static ImmutableArray`1<string> ElementsToCheck;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1627DocumentationTextMustNotBeEmpty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleXmlElement(SyntaxNodeAnalysisContext context);
    private static void HandleXmlEmptyElement(SyntaxNodeAnalysisContext context);
    private static void HandleIncludedDocumentation(SyntaxNodeAnalysisContext context, XmlEmptyElementSyntax elementSyntax, Location elementLocation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic has an unacceptable rate of false positives.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1628DocumentationTextMustBeginWithACapitalLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1628DocumentationTextMustBeginWithACapitalLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1629DocumentationTextMustEndWithAPeriod : ElementDocumentationBase {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1629DocumentationTextMustEndWithAPeriod();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void HandleXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, bool needsComment, IEnumerable`1<XmlNodeSyntax> syntaxList, Location[] diagnosticLocations);
    protected virtual void HandleCompleteDocumentation(SyntaxNodeAnalysisContext context, bool needsComment, XElement completeDocumentation, Location[] diagnosticLocations);
    private static void HandleSectionOrBlockXmlElement(SyntaxNodeAnalysisContext context, StyleCopSettings settings, XmlElementSyntax xmlElement, bool startingWithFinalParagraph);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1630DocumentationTextMustContainWhitespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1630DocumentationTextMustContainWhitespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1631DocumentationMustMeetCharacterPercentage : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1631DocumentationMustMeetCharacterPercentage();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic was determined to be too subjective and/or misleading to developers.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1632DocumentationTextMustMeetMinimumCharacterLength : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1632DocumentationTextMustMeetMinimumCharacterLength();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1642ConstructorSummaryDocumentationMustBeginWithStandardText : StandardTextDiagnosticBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1642ConstructorSummaryDocumentationMustBeginWithStandardText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1643DestructorSummaryDocumentationMustBeginWithStandardText : StandardTextDiagnosticBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> DestructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1643DestructorSummaryDocumentationMustBeginWithStandardText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDestructor(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1644DocumentationHeadersMustNotContainBlankLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1644DocumentationHeadersMustNotContainBlankLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1589.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1645IncludedDocumentationFileDoesNotExist : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1645IncludedDocumentationFileDoesNotExist();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1589.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1646IncludedDocumentationXPathDoesNotExist : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1646IncludedDocumentationXPathDoesNotExist();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This is already handled by the compiler with warning CS1590.")]
[NoCodeFixAttribute("Cannot generate documentation")]
internal class StyleCop.Analyzers.DocumentationRules.SA1647IncludeNodeDoesNotContainValidFileAndPath : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1647IncludeNodeDoesNotContainValidFileAndPath();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1648InheritDocMustBeUsedWithInheritingClass : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledTypeLikeDeclarationKinds;
    private static ImmutableArray`1<SyntaxKind> MemberDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeLikeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MemberDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1648InheritDocMustBeUsedWithInheritingClass();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeLikeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMemberDeclaration(SyntaxNodeAnalysisContext context);
    private static bool HasXmlCrefAttribute(XmlNodeSyntax inheritDocElement);
    private static bool HasXmlCrefAttribute(XElement inheritDocElement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1649FileNameMustMatchTypeName : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string ExpectedFileNameKey;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1649FileNameMustMatchTypeName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic has an unacceptable rate of false positives.")]
internal class StyleCop.Analyzers.DocumentationRules.SA1650ElementDocumentationMustBeSpelledCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1650ElementDocumentationMustBeSpelledCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.DocumentationRules.SA1651DoNotUsePlaceholderElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string NoCodeFixKey;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> XmlElementAction;
    private static Action`1<SyntaxNodeAnalysisContext> XmlEmptyElementAction;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1651DoNotUsePlaceholderElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleXmlElement(SyntaxNodeAnalysisContext context);
    private static void HandleXmlEmptyElement(SyntaxNodeAnalysisContext context);
    private static void CheckTag(SyntaxNodeAnalysisContext context, string tagName);
    private static bool IncludedDocumentationContainsPlaceHolderTags(SyntaxNodeAnalysisContext context);
}
internal abstract class StyleCop.Analyzers.DocumentationRules.StandardTextDiagnosticBase : DiagnosticAnalyzer {
    internal static string NoCodeFixKey;
    private static ImmutableDictionary`2<string, string> NoCodeFixProperties;
    private static StandardTextDiagnosticBase();
    protected static MatchResult HandleDeclaration(SyntaxNodeAnalysisContext context, string firstTextPart, string secondTextPart, DiagnosticDescriptor diagnosticDescriptor);
    private static bool SeeTagIsCorrect(SyntaxNodeAnalysisContext context, XmlEmptyElementSyntax classReferencePart, BaseMethodDeclarationSyntax constructorDeclarationSyntax);
    private static bool SeeTagIsCorrect(SyntaxNodeAnalysisContext context, XElement classReferencePart, BaseMethodDeclarationSyntax constructorDeclarationSyntax);
    private static bool TextPartsMatch(string firstText, string secondText, XmlTextSyntax firstTextPart, XmlTextSyntax secondTextPart);
    private static bool TextPartsMatch(string firstText, string secondText, XText firstTextPart, XText secondTextPart);
}
internal enum StyleCop.Analyzers.Helpers.AccessLevel : Enum {
    public int value__;
    public static AccessLevel NotSpecified;
    public static AccessLevel Private;
    public static AccessLevel PrivateProtected;
    public static AccessLevel Protected;
    public static AccessLevel ProtectedInternal;
    public static AccessLevel Internal;
    public static AccessLevel Public;
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.AccessLevelHelper : object {
    private static Dictionary`2<AccessLevel, string> AccessLevelNames;
    private static AccessLevelHelper();
    internal static AccessLevel GetAccessLevel(SyntaxTokenList modifiers);
    internal static string GetName(AccessLevel accessLevel);
    [ExtensionAttribute]
internal static Accessibility ToAccessibility(AccessLevel accessLevel);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseTypeDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseMethodDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BasePropertyDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(AccessorDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(BaseFieldDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(EnumMemberDeclarationSyntax syntax);
    [ExtensionAttribute]
internal static Accessibility GetDeclaredAccessibility(DelegateDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseTypeDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseMethodDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BasePropertyDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(AccessorDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(BaseFieldDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(EnumMemberDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Accessibility GetEffectiveAccessibility(DelegateDeclarationSyntax syntax, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static Accessibility CombineEffectiveAccessibility(Accessibility declaredAccessibility, Accessibility enclosingAccessibility);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DeclarationModifiersHelper : object {
    internal static SyntaxTokenList AddModifier(SyntaxTokenList modifiers, T& leadingTriviaNode, SyntaxKind modifierKeyword);
    internal static SyntaxTokenList AddModifier(SyntaxTokenList modifiers, SyntaxToken& leadingTriviaToken, SyntaxKind modifierKeyword);
    internal static SyntaxTokenList AddModifiers(SyntaxTokenList modifiers, SyntaxToken& leadingTriviaToken, IEnumerable`1<SyntaxKind> modifierKeywords);
    [ExtensionAttribute]
internal static SyntaxTokenList GetModifiers(MemberDeclarationSyntax syntax);
    [ExtensionAttribute]
internal static SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DiagnosticOptionsHelper : object {
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(CompilationStartAnalysisContext context, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(Compilation compilation, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsAnalyzerSuppressed(CompilationOptions compilationOptions, DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static DocumentationMode GetDocumentationMode(SyntaxNodeAnalysisContext context);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.DocumentationCommentExtensions : object {
    [ExtensionAttribute]
public static DocumentationCommentTriviaSyntax GetDocumentationCommentTriviaSyntax(SyntaxNode node);
    [ExtensionAttribute]
public static XmlNodeSyntax GetFirstXmlElement(SyntaxList`1<XmlNodeSyntax> content, string elementName);
    [IteratorStateMachineAttribute("StyleCop.Analyzers.Helpers.DocumentationCommentExtensions/<GetXmlElements>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<XmlNodeSyntax> GetXmlElements(SyntaxList`1<XmlNodeSyntax> content, string elementName);
    [ExtensionAttribute]
public static T ReplaceExteriorTrivia(T node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxList`1<XmlNodeSyntax> WithoutFirstAndLastNewlines(SyntaxList`1<XmlNodeSyntax> summaryContent);
    [ExtensionAttribute]
public static bool IsXmlNewLine(SyntaxToken node);
    [ExtensionAttribute]
public static bool IsXmlWhitespace(SyntaxToken node);
    [ExtensionAttribute]
public static T AdjustDocumentationCommentNewLineTrivia(T node);
    [ExtensionAttribute]
public static XmlNameSyntax GetName(XmlNodeSyntax element);
    private static SyntaxTrivia SelectExteriorTrivia(SyntaxTrivia rewrittenTrivia, SyntaxTrivia trivia, SyntaxTrivia triviaWithSpace);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.ExpressionSyntaxHelpers : object {
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Helpers.FileHeader : object {
    private int fileHeaderStart;
    private int fileHeaderEnd;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyrightText>k__BackingField;
    internal static FileHeader MissingFileHeader { get; }
    internal bool IsMissing { get; private set; }
    internal string CopyrightText { get; }
    internal FileHeader(string copyrightText, int fileHeaderStart, int fileHeaderEnd);
    internal static FileHeader get_MissingFileHeader();
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
private void set_IsMissing(bool value);
    [CompilerGeneratedAttribute]
internal string get_CopyrightText();
    internal Location GetLocation(SyntaxTree syntaxTree);
}
internal static class StyleCop.Analyzers.Helpers.FileHeaderHelpers : object {
    internal static FileHeader ParseFileHeader(SyntaxNode root);
    internal static XmlFileHeader ParseXmlFileHeader(SyntaxNode root);
    private static string ProcessSingleLineCommentsHeader(SyntaxTriviaList triviaList, int startIndex, Int32& fileHeaderStart, Int32& fileHeaderEnd);
    private static string ProcessMultiLineCommentsHeader(SyntaxTrivia multiLineComment, Int32& fileHeaderStart, Int32& fileHeaderEnd);
}
internal static class StyleCop.Analyzers.Helpers.FileNameHelpers : object {
    internal static string GetFileNameAndSuffix(string path, String& suffix);
    internal static string GetConventionalFileName(MemberDeclarationSyntax declaration, FileNamingConvention convention);
    internal static string GetSimpleFileName(MemberDeclarationSyntax memberDeclaration);
    private static string GetMetadataFileName(TypeDeclarationSyntax typeDeclaration);
    private static string GetStyleCopFileName(TypeDeclarationSyntax typeDeclaration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.Helpers.HelpersResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FixAllOccurrencesOfDiagnostic { get; }
    internal static string FixAllOccurrencesOfDiagnosticInScope { get; }
    internal static string FixAllOccurrencesOfDiagnosticInSolution { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FixAllOccurrencesOfDiagnostic();
    internal static string get_FixAllOccurrencesOfDiagnosticInScope();
    internal static string get_FixAllOccurrencesOfDiagnosticInSolution();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.LiteralExpressionHelpers : object {
    [ExtensionAttribute]
internal static string StripLiteralSuffix(LiteralExpressionSyntax literalExpressionSyntax);
    [ExtensionAttribute]
internal static LiteralExpressionSyntax WithLiteralSuffix(LiteralExpressionSyntax literalExpression, SyntaxKind syntaxKindKeyword);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.LocationHelpers : object {
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxToken token);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxNode node);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static FileLinePositionSpan GetLineSpan(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
internal static int GetLine(SyntaxToken token);
    [ExtensionAttribute]
internal static int GetLine(SyntaxNode node);
    [ExtensionAttribute]
internal static int GetLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxToken token);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxNode node);
    [ExtensionAttribute]
internal static int GetEndLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool SpansMultipleLines(SyntaxNode node);
    [ExtensionAttribute]
internal static bool SpansMultipleLines(SyntaxTrivia trivia);
}
internal class StyleCop.Analyzers.Helpers.MemberOrderHelper : ValueType {
    private static ImmutableArray`1<SyntaxKind> TypeMemberOrder;
    [CompilerGeneratedAttribute]
private MemberDeclarationSyntax <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    internal MemberDeclarationSyntax Member { get; }
    internal int Priority { get; }
    internal MemberOrderHelper(MemberDeclarationSyntax member, ImmutableArray`1<OrderingTrait> elementOrder);
    private static MemberOrderHelper();
    [CompilerGeneratedAttribute]
internal MemberDeclarationSyntax get_Member();
    [CompilerGeneratedAttribute]
internal int get_Priority();
    internal static AccessLevel GetAccessLevelForOrdering(SyntaxNode member, SyntaxTokenList modifiers);
}
internal static class StyleCop.Analyzers.Helpers.NamedTypeHelpers : object {
    internal static bool IsNativeMethodsClass(INamedTypeSymbol type);
    internal static bool IsNativeMethodsClass(ClassDeclarationSyntax syntax);
    internal static bool IsContainedInNativeMethodsClass(INamedTypeSymbol type);
    internal static bool IsContainedInNativeMethodsClass(SyntaxNode syntax);
    internal static string GetNameOrIdentifier(MemberDeclarationSyntax member);
    internal static Location GetNameOrIdentifierLocation(SyntaxNode member);
    internal static bool IsPartialDeclaration(MemberDeclarationSyntax declaration);
    internal static bool IsImplementingAnInterfaceMember(ISymbol memberSymbol);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.NameSyntaxHelpers : object {
    private static string DotChar;
    [ExtensionAttribute]
internal static string ToNormalizedString(NameSyntax nameSyntax);
    [ExtensionAttribute]
internal static string ToUnaliasedString(NameSyntax nameSyntax);
    internal static int Compare(NameSyntax first, NameSyntax second);
    private static void BuildName(NameSyntax nameSyntax, StringBuilder builder, bool includeAlias);
}
internal class StyleCop.Analyzers.Helpers.ObjectPools.ObjectPool`1 : object {
    private Element[] items;
    private Func`1<T> factory;
    private T firstItem;
    internal ObjectPool`1(Func`1<T> factory);
    internal ObjectPool`1(Func`1<T> factory, int size);
    internal T Allocate();
    internal void Free(T obj);
    private T CreateInstance();
    private T AllocateSlow();
    private void FreeSlow(T obj);
}
internal class StyleCop.Analyzers.Helpers.ObjectPools.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> releaser;
    private ObjectPool`1<T> pool;
    private T pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    public sealed virtual void Dispose();
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.ObjectPools.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
internal static class StyleCop.Analyzers.Helpers.ObjectPools.SharedPools : object {
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
}
internal static class StyleCop.Analyzers.Helpers.ObjectPools.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
internal static class StyleCop.Analyzers.Helpers.Requires : object {
    public static void NotNull(T argument, string parameterName);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SpacingExtensions : object {
    [ExtensionAttribute]
public static bool IsMissingOrDefault(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithoutLeadingWhitespace(SyntaxToken token, bool removeEndOfLineTrivia);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutWhitespace(SyntaxTriviaList syntaxTriviaList, bool removeEndOfLineTrivia);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
}
internal static class StyleCop.Analyzers.Helpers.SpecializedTasks : object {
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    internal static Task CompletedTask { get; }
    private static SpecializedTasks();
    [CompilerGeneratedAttribute]
internal static Task get_CompletedTask();
}
internal static class StyleCop.Analyzers.Helpers.SpecialTypeHelper : object {
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> <PredefinedSpecialTypes>k__BackingField;
    private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> PredefinedSpecialTypes { get; }
    private static SpecialTypeHelper();
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<SpecialType, PredefinedTypeSyntax> get_PredefinedSpecialTypes();
    public static bool IsPredefinedType(SpecialType specialType);
    public static bool TryGetPredefinedType(SpecialType specialType, PredefinedTypeSyntax& predefinedTypeSyntax);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SymbolNameHelpers : object {
    private static string GenericTypeParametersOpen;
    private static string GenericTypeParametersClose;
    private static string GenericSeparator;
    private static string TupleTypeOpen;
    private static string TupleTypeClose;
    private static string TupleElementSeparator;
    [ExtensionAttribute]
public static string ToQualifiedString(ISymbol symbol, NameSyntax name);
    private static bool AppendQualifiedSymbolName(StringBuilder builder, ISymbol symbol, TypeSyntax type);
}
internal static class StyleCop.Analyzers.Helpers.SyntaxKinds : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseTypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <TypeDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseFieldDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseMethodDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BasePropertyDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <AccessorDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <InitializerExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <DocumentationComment>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <ConstructorInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <LambdaExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <AnonymousFunctionExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <SimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseParameterList>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <BaseArgumentList>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <IntegerLiteralKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <RealLiteralKeyword>k__BackingField;
    public static ImmutableArray`1<SyntaxKind> BaseTypeDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> TypeDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BaseFieldDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BaseMethodDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> BasePropertyDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> AccessorDeclaration { get; }
    public static ImmutableArray`1<SyntaxKind> InitializerExpression { get; }
    public static ImmutableArray`1<SyntaxKind> DocumentationComment { get; }
    public static ImmutableArray`1<SyntaxKind> ConstructorInitializer { get; }
    public static ImmutableArray`1<SyntaxKind> LambdaExpression { get; }
    public static ImmutableArray`1<SyntaxKind> AnonymousFunctionExpression { get; }
    public static ImmutableArray`1<SyntaxKind> SimpleName { get; }
    public static ImmutableArray`1<SyntaxKind> BaseParameterList { get; }
    public static ImmutableArray`1<SyntaxKind> BaseArgumentList { get; }
    public static ImmutableArray`1<SyntaxKind> IntegerLiteralKeyword { get; }
    public static ImmutableArray`1<SyntaxKind> RealLiteralKeyword { get; }
    private static SyntaxKinds();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseTypeDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_TypeDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseFieldDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseMethodDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BasePropertyDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_AccessorDeclaration();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_InitializerExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_DocumentationComment();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_ConstructorInitializer();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_LambdaExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_AnonymousFunctionExpression();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_SimpleName();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseParameterList();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_BaseArgumentList();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_IntegerLiteralKeyword();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<SyntaxKind> get_RealLiteralKeyword();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.SyntaxTreeHelpers : object {
    private static Tuple`2<WeakReference`1<Compilation>, ConcurrentDictionary`2<SyntaxTree, bool>> usingAliasCache;
    private static SyntaxTreeHelpers();
    [ExtensionAttribute]
public static ConcurrentDictionary`2<SyntaxTree, bool> GetOrCreateUsingAliasCache(Compilation compilation);
    [ExtensionAttribute]
public static bool IsWhitespaceOnly(SyntaxTree tree, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool ContainsUsingAlias(SyntaxTree tree, ConcurrentDictionary`2<SyntaxTree, bool> cache);
    private static bool ContainsUsingAliasNoCache(SyntaxTree tree);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TokenHelper : object {
    [ExtensionAttribute]
internal static bool IsFirstInLine(SyntaxToken token, bool allowNonWhitespaceTrivia);
    [ExtensionAttribute]
internal static bool IsInterpolatedUnaryExpression(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsLastInLine(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsPrecededByWhitespace(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsOnlyPrecededByWhitespaceInLine(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsFollowedByWhitespace(SyntaxToken token);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TriviaHelper : object {
    internal static int IndexOfFirstNonWhitespaceTrivia(T triviaList, bool endOfLineIsWhitespace);
    internal static int IndexOfFirstNonBlankLineTrivia(T triviaList);
    internal static int IndexOfTrailingWhitespace(T triviaList, bool endOfLineIsWhitespace);
    [ExtensionAttribute]
internal static SyntaxTriviaList RemoveRange(SyntaxTriviaList list, int index, int count);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutDirectiveTrivia(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
internal static int LastIndexOf(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutTrailingWhitespace(SyntaxTriviaList triviaList, bool endOfLineIsWhitespace);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutLeadingWhitespace(SyntaxTriviaList triviaList, bool endOfLineIsWhitespace);
    internal static DualTriviaListHelper GetContainingTriviaList(SyntaxTrivia trivia, Int32& triviaIndex);
    internal static DualTriviaListHelper MergeTriviaLists(SyntaxTriviaList list1, SyntaxTriviaList list2);
    [ExtensionAttribute]
internal static bool IsPrecededByBlankLines(SyntaxToken token);
    [ExtensionAttribute]
internal static SyntaxToken WithoutLeadingBlankLines(SyntaxToken token);
    [ExtensionAttribute]
internal static bool HasBuiltinEndLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool ContainsBlankLines(IReadOnlyList`1<SyntaxTrivia> triviaList, bool startsOnNewLine);
    [ExtensionAttribute]
internal static SyntaxTriviaList WithoutBlankLines(SyntaxTriviaList triviaList, bool startsOnNewLine);
    private static int BinarySearch(SyntaxTriviaList leadingTrivia, SyntaxTrivia trivia);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.TypeSyntaxHelper : object {
    [ExtensionAttribute]
public static TypeSyntax GetContainingNotEnclosingType(TypeSyntax syntax);
    [ExtensionAttribute]
public static bool IsReturnType(TypeSyntax syntax);
    [ExtensionAttribute]
public static TypeSyntax StripRefFromType(TypeSyntax syntax);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.UsingDirectiveSyntaxHelpers : object {
    private static string SystemUsingDirectiveIdentifier;
    [ExtensionAttribute]
internal static bool IsSystemUsingDirective(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static bool IsPrecededByPreprocessorDirective(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static bool HasNamespaceAliasQualifier(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
internal static UsingGroup GetUsingGroupType(UsingDirectiveSyntax usingDirective, StyleCopSettings settings);
    [ExtensionAttribute]
internal static bool StartsWithAlias(UsingDirectiveSyntax usingDirective, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ExcludeGlobalKeyword(IdentifierNameSyntax token);
    private static Nullable`1<SyntaxToken> GetFirstIdentifierInUsingDirective(UsingDirectiveSyntax usingDirective);
}
internal enum StyleCop.Analyzers.Helpers.UsingGroup : Enum {
    public int value__;
    public static UsingGroup Unknown;
    public static UsingGroup System;
    public static UsingGroup Regular;
    public static UsingGroup Static;
    public static UsingGroup Alias;
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.XmlCommentHelper : object {
    internal static string SummaryXmlTag;
    internal static string ContentXmlTag;
    internal static string InheritdocXmlTag;
    internal static string ReturnsXmlTag;
    internal static string ValueXmlTag;
    internal static string CXmlTag;
    internal static string SeeXmlTag;
    internal static string CodeXmlTag;
    internal static string ListXmlTag;
    internal static string NoteXmlTag;
    internal static string ParaXmlTag;
    internal static string SeeAlsoXmlTag;
    internal static string ParamXmlTag;
    internal static string ParamRefXmlTag;
    internal static string TypeParamXmlTag;
    internal static string TypeParamRefXmlTag;
    internal static string RemarksXmlTag;
    internal static string ExampleXmlTag;
    internal static string PermissionXmlTag;
    internal static string ExceptionXmlTag;
    internal static string IncludeXmlTag;
    internal static string FileAttributeName;
    internal static string PathAttributeName;
    internal static string CrefArgumentName;
    internal static string NameArgumentName;
    internal static string PlaceholderTag;
    internal static bool IsConsideredEmpty(DocumentationCommentTriviaSyntax xmlComment);
    internal static bool IsConsideredEmpty(XmlNodeSyntax xmlSyntax, bool considerEmptyElements);
    internal static bool IsConsideredEmpty(XNode node);
    internal static XmlTextSyntax TryGetFirstTextElementWithContent(XmlNodeSyntax node);
    internal static bool IsMissingOrEmpty(SyntaxTrivia commentTrivia);
    internal static bool HasDocumentation(SyntaxNode node);
    internal static string GetText(XmlNodeSyntax nodeSyntax, bool normalizeWhitespace);
    internal static string GetText(XmlTextSyntax textElement);
    internal static string GetText(XmlTextSyntax textElement, bool normalizeWhitespace);
    internal static T GetFirstAttributeOrDefault(XmlNodeSyntax nodeSyntax);
    [ExtensionAttribute]
internal static bool IsInlineElement(XmlNodeSyntax nodeSyntax);
    [ExtensionAttribute]
internal static bool IsBlockElement(XmlNodeSyntax nodeSyntax);
    private static bool IsInlineElement(string localName);
    private static bool IsBlockElement(string localName);
}
internal class StyleCop.Analyzers.Helpers.XmlFileHeader : object {
    private XElement headerXml;
    private int fileHeaderStart;
    private int fileHeaderEnd;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMalformed>k__BackingField;
    internal static XmlFileHeader MissingFileHeader { get; }
    internal static XmlFileHeader MalformedFileHeader { get; }
    internal bool IsMissing { get; private set; }
    internal bool IsMalformed { get; private set; }
    internal XmlFileHeader(XElement headerXml, int fileHeaderStart, int fileHeaderEnd);
    internal static XmlFileHeader get_MissingFileHeader();
    internal static XmlFileHeader get_MalformedFileHeader();
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
private void set_IsMissing(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMalformed();
    [CompilerGeneratedAttribute]
private void set_IsMalformed(bool value);
    internal XElement GetElement(string tagName);
    internal Location GetLocation(SyntaxTree syntaxTree);
    internal Location GetElementLocation(SyntaxTree syntaxTree, XElement element);
}
internal static class StyleCop.Analyzers.Helpers.XmlSyntaxFactory : object {
    public static DocumentationCommentTriviaSyntax DocumentationComment(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax MultiLineElement(string localName, string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax MultiLineElement(XmlNameSyntax name, string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax Element(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax Element(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax EmptyElement(string localName);
    public static SyntaxList`1<XmlNodeSyntax> List(XmlNodeSyntax[] nodes);
    public static XmlTextSyntax Text(string value);
    public static XmlTextSyntax Text(SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax TextAttribute(string name, string value);
    public static XmlTextAttributeSyntax TextAttribute(string name, SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax TextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlTextAttributeSyntax TextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlNameAttributeSyntax NameAttribute(string parameterName);
    public static XmlCrefAttributeSyntax CrefAttribute(CrefSyntax cref);
    public static XmlCrefAttributeSyntax CrefAttribute(CrefSyntax cref, SyntaxKind quoteKind);
    public static XmlTextSyntax NewLine(string text);
    public static SyntaxToken TextNewLine(string text);
    public static SyntaxToken TextNewLine(string text, bool continueComment);
    public static SyntaxToken TextLiteral(string value);
    public static SyntaxToken TextLiteral(string value, bool escapeQuotes);
    public static XmlElementSyntax SummaryElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax SummaryElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax RemarksElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax RemarksElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ReturnsElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax ReturnsElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ValueElement(string newLineText, XmlNodeSyntax[] content);
    public static XmlElementSyntax ValueElement(string newLineText, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ExceptionElement(CrefSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax ExceptionElement(CrefSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ParaElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax ParaElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax ParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax ParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax TypeParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax TypeParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax ParamRefElement(string parameterName);
    public static XmlEmptyElementSyntax SeeElement(CrefSyntax cref);
    public static XmlEmptyElementSyntax SeeAlsoElement(CrefSyntax cref);
    public static XmlElementSyntax SeeAlsoElement(Uri linkAddress, SyntaxList`1<XmlNodeSyntax> linkText);
    public static XmlEmptyElementSyntax NullKeywordElement();
    public static XmlElementSyntax PlaceholderElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax PlaceholderElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax ThreadSafetyElement();
    public static XmlEmptyElementSyntax ThreadSafetyElement(bool static, bool instance);
    public static XmlEmptyElementSyntax PreliminaryElement();
    public static XmlElementSyntax TokenElement(string value);
    private static XmlEmptyElementSyntax KeywordElement(string keyword);
    private static SyntaxToken ReplaceBraceTokens(SyntaxToken originalToken, SyntaxToken rewrittenToken);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Helpers.XPathExtensions : object {
    private static Type XPathExtensionsType;
    private static XPathExtensions();
    [ExtensionAttribute]
internal static IEnumerable`1<XElement> XPathSelectElements(XNode node, string expression);
    private static Type GetTypeFromEither(string contractName, string desktopName);
    private static Type TryGetType(string assemblyQualifiedName);
    [ExtensionAttribute]
private static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    private static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
}
internal class StyleCop.Analyzers.InvalidSettingsException : Exception {
    internal InvalidSettingsException(string message);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.JsonHelper : object {
    [ExtensionAttribute]
internal static bool ToBooleanValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static int ToInt32Value(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static string ToStringValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static string ToStringValue(JsonValue jsonValue, string elementName);
    [ExtensionAttribute]
internal static TEnum ToEnumValue(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static TEnum ToEnumValue(JsonValue jsonValue, string elementName);
    [ExtensionAttribute]
internal static void AssertIsArray(KeyValuePair`2<string, JsonValue> jsonValue);
    [ExtensionAttribute]
internal static void AssertIsObject(KeyValuePair`2<string, JsonValue> jsonValue);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.LayoutRules.LayoutResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SA1500CodeFix { get; }
    internal static string SA1501CodeFix { get; }
    internal static string SA1501CodeFixAll { get; }
    internal static string SA1502CodeFix { get; }
    internal static string SA1502Description { get; }
    internal static string SA1502MessageFormat { get; }
    internal static string SA1502Title { get; }
    internal static string SA1503CodeFix { get; }
    internal static string SA1504CodeFixMultipleLines { get; }
    internal static string SA1504CodeFixSingleLine { get; }
    internal static string SA1505CodeFix { get; }
    internal static string SA1506CodeFix { get; }
    internal static string SA1507CodeFix { get; }
    internal static string SA1508CodeFix { get; }
    internal static string SA1509CodeFix { get; }
    internal static string SA1510CodeFix { get; }
    internal static string SA1511CodeFix { get; }
    internal static string SA1512CodeFix { get; }
    internal static string SA1513CodeFix { get; }
    internal static string SA1514CodeFix { get; }
    internal static string SA1515CodeFix { get; }
    internal static string SA1516CodeFixAll { get; }
    internal static string SA1516CodeFixInsert { get; }
    internal static string SA1516CodeFixRemove { get; }
    internal static string SA1516Description { get; }
    internal static string SA1516DescriptionOmit { get; }
    internal static string SA1516DescriptionRequire { get; }
    internal static string SA1516MessageFormat { get; }
    internal static string SA1516MessageFormatOmit { get; }
    internal static string SA1516MessageFormatRequire { get; }
    internal static string SA1516Title { get; }
    internal static string SA1517CodeFix { get; }
    internal static string SA1518CodeFix { get; }
    internal static string SA1518DescriptionAllow { get; }
    internal static string SA1518DescriptionOmit { get; }
    internal static string SA1518DescriptionRequire { get; }
    internal static string SA1518MessageFormatAllow { get; }
    internal static string SA1518MessageFormatOmit { get; }
    internal static string SA1518MessageFormatRequire { get; }
    internal static string SA1518Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SA1500CodeFix();
    internal static string get_SA1501CodeFix();
    internal static string get_SA1501CodeFixAll();
    internal static string get_SA1502CodeFix();
    internal static string get_SA1502Description();
    internal static string get_SA1502MessageFormat();
    internal static string get_SA1502Title();
    internal static string get_SA1503CodeFix();
    internal static string get_SA1504CodeFixMultipleLines();
    internal static string get_SA1504CodeFixSingleLine();
    internal static string get_SA1505CodeFix();
    internal static string get_SA1506CodeFix();
    internal static string get_SA1507CodeFix();
    internal static string get_SA1508CodeFix();
    internal static string get_SA1509CodeFix();
    internal static string get_SA1510CodeFix();
    internal static string get_SA1511CodeFix();
    internal static string get_SA1512CodeFix();
    internal static string get_SA1513CodeFix();
    internal static string get_SA1514CodeFix();
    internal static string get_SA1515CodeFix();
    internal static string get_SA1516CodeFixAll();
    internal static string get_SA1516CodeFixInsert();
    internal static string get_SA1516CodeFixRemove();
    internal static string get_SA1516Description();
    internal static string get_SA1516DescriptionOmit();
    internal static string get_SA1516DescriptionRequire();
    internal static string get_SA1516MessageFormat();
    internal static string get_SA1516MessageFormatOmit();
    internal static string get_SA1516MessageFormatRequire();
    internal static string get_SA1516Title();
    internal static string get_SA1517CodeFix();
    internal static string get_SA1518CodeFix();
    internal static string get_SA1518DescriptionAllow();
    internal static string get_SA1518DescriptionOmit();
    internal static string get_SA1518DescriptionRequire();
    internal static string get_SA1518MessageFormatAllow();
    internal static string get_SA1518MessageFormatOmit();
    internal static string get_SA1518MessageFormatRequire();
    internal static string get_SA1518Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1500BracesForMultiLineStatementsMustNotShareLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1500BracesForMultiLineStatementsMustNotShareLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void CheckBraces(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
    private static bool InitializerExpressionSharesLine(InitializerExpressionSyntax node);
    private static void CheckBraceToken(SyntaxNodeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1501StatementMustNotBeOnASingleLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string SuppressCodeFixKey;
    internal static string SuppressCodeFixValue;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableDictionary`2<string, string> SuppressCodeFixProperties;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1501StatementMustNotBeOnASingleLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, SyntaxNode node, StatementSyntax childStatement);
    private static bool IsSingleLineExpression(ExpressionSyntax containingExpression);
    private static bool IsPartOfStatement(BlockSyntax block);
    private static ExpressionSyntax GetContainingExpression(SyntaxNode node);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, Location location, bool reportAsHidden);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1502ElementMustNotBeOnASingleLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BasePropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1502ElementMustNotBeOnASingleLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBasePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckViolation(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1503BracesMustNotBeOmitted : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Descriptor;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> UsingStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1503BracesMustNotBeOmitted();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void HandleUsingStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1504AllAccessorsMustBeSingleLineOrMultiLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1504AllAccessorsMustBeSingleLineOrMultiLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1505OpeningBracesMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1505OpeningBracesMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOpenBrace(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken);
    private static int GetLine(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1506ElementDocumentationHeadersMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1507CodeMustNotContainMultipleBlankLinesInARow : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Descriptor;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1507CodeMustNotContainMultipleBlankLinesInARow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void ReportDiagnosticIfNecessary(SyntaxTreeAnalysisContext context, SyntaxTriviaList leadingTrivia, int blankLineIndex, int blankLineEndIndex, int blankLineCount);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1508ClosingBracesMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1508ClosingBracesMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCloseBrace(SyntaxNodeAnalysisContext context, SyntaxToken closeBraceToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1509OpeningBracesMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1509OpeningBracesMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void AnalyzeOpenBrace(SyntaxTreeAnalysisContext context, SyntaxToken openBrace, SyntaxToken previousToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ElseStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> CatchClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> FinallyClauseAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1510ChainedStatementBlocksMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleElseStatement(SyntaxNodeAnalysisContext context);
    private static void HandleCatchClause(SyntaxNodeAnalysisContext context);
    private static void HandleFinallyClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1511WhileDoFooterMustNotBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> DoStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1511WhileDoFooterMustNotBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDoStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1512SingleLineCommentsMustNotBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1512SingleLineCommentsMustNotBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleSyntaxTreeAnalysis(SyntaxTreeAnalysisContext context, Compilation compilation);
    private static bool IsOnOwnLine(T triviaList, int triviaIndex);
    private static bool IsPartOfFileHeader(T triviaList, int triviaIndex);
    private static int GetTrailingBlankLineCount(T triviaList, Int32& triviaIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1513ClosingBraceMustBeFollowedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1513ClosingBraceMustBeFollowedByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1514ElementDocumentationHeaderMustBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1514ElementDocumentationHeaderMustBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
    private static Location GetDiagnosticLocation(SyntaxTrivia documentationHeader);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1515SingleLineCommentMustBePrecededByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1515SingleLineCommentMustBePrecededByBlankLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static bool IsOnOwnLine(T triviaList, int triviaIndex);
    private static bool IsPrecededBySingleLineCommentOrDocumentation(T triviaList, int triviaIndex);
    private static bool IsPrecededByBlankLine(T triviaList, int triviaIndex);
    private static bool IsAtStartOfScope(SyntaxTrivia trivia);
    private static bool IsPrecededByDirectiveTrivia(T triviaList, int triviaIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1516ElementsMustBeSeparatedByBlankLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string CodeFixActionKey;
    internal static string RemoveBlankLinesValue;
    internal static string InsertBlankLineValue;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static LocalizableString MessageFormatRequire;
    private static LocalizableString DescriptionRequire;
    private static LocalizableString MessageFormatOmit;
    private static LocalizableString DescriptionOmit;
    private static string HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BasePropertyDeclarationAction;
    private static ImmutableDictionary`2<string, string> DiagnosticProperties;
    private static ImmutableDictionary`2<string, string> DiagnosticPropertiesRequire;
    private static ImmutableDictionary`2<string, string> DiagnosticPropertiesOmit;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorRequire>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorOmit>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor Descriptor { get; }
    public static DiagnosticDescriptor DescriptorRequire { get; }
    public static DiagnosticDescriptor DescriptorOmit { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1516ElementsMustBeSeparatedByBlankLine();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorRequire();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorOmit();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBasePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleUsings(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usings, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, SyntaxList`1<MemberDeclarationSyntax> members);
    private static bool IsMultiline(FieldDeclarationSyntax fieldDeclaration);
    private static bool IsMultiline(AccessorDeclarationSyntax accessorDeclaration);
    private static void ReportIfThereIsNoBlankLine(SyntaxNodeAnalysisContext context, SyntaxNode firstNode, SyntaxNode secondNode);
    private static Location GetDiagnosticLocation(SyntaxNode node);
    private static bool HasEmptyLine(IEnumerable`1<SyntaxTrivia> allTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1517CodeMustNotContainBlankLinesAtStartOfFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1517CodeMustNotContainBlankLinesAtStartOfFile();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1518UseLineEndingsCorrectlyAtEndOfFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatAllow;
    private static LocalizableString DescriptionAllow;
    private static LocalizableString MessageFormatRequire;
    private static LocalizableString DescriptionRequire;
    private static LocalizableString MessageFormatOmit;
    private static LocalizableString DescriptionOmit;
    private static string HelpLink;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorAllow>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorRequire>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorOmit>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorAllow { get; }
    public static DiagnosticDescriptor DescriptorRequire { get; }
    public static DiagnosticDescriptor DescriptorOmit { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1518UseLineEndingsCorrectlyAtEndOfFile();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorAllow();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorRequire();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorOmit();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1519BracesMustNotBeOmittedFromMultiLineChildStatement : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Descriptor;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> DoStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> WhileStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForEachStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> UsingStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1519BracesMustNotBeOmittedFromMultiLineChildStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void HandleDoStatement(SyntaxNodeAnalysisContext context);
    private static void HandleWhileStatement(SyntaxNodeAnalysisContext context);
    private static void HandleForStatement(SyntaxNodeAnalysisContext context);
    private static void HandleForEachStatement(SyntaxNodeAnalysisContext context);
    private static void HandleUsingStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.LayoutRules.SA1520UseBracesConsistently : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Descriptor;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> IfStatementAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1520UseBracesConsistently();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIfStatement(SyntaxNodeAnalysisContext context);
    private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.AccessorDeclarationSyntaxExtensions : object {
    private static Func`2<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`3<AccessorDeclarationSyntax, ArrowExpressionClauseSyntax, AccessorDeclarationSyntax> WithExpressionBodyAccessor;
    private static AccessorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(AccessorDeclarationSyntax syntax);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ArgumentSyntaxExtensions : object {
    private static Func`2<ArgumentSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<ArgumentSyntax, SyntaxToken, ArgumentSyntax> WithRefKindKeywordAccessor;
    private static ArgumentSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(ArgumentSyntax syntax);
    [ExtensionAttribute]
public static ArgumentSyntax WithRefKindKeyword(ArgumentSyntax syntax, SyntaxToken refKindKeyword);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.BaseMethodDeclarationSyntaxExtensions : object {
    private static Func`2<BaseMethodDeclarationSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static BaseMethodDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ArrowExpressionClauseSyntax ExpressionBody(BaseMethodDeclarationSyntax syntax);
}
internal class StyleCop.Analyzers.Lightup.CasePatternSwitchLabelSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`2<SwitchLabelSyntax, CSharpSyntaxNode> WhenClauseAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithKeywordAccessor;
    private static Func`3<SwitchLabelSyntax, SyntaxToken, SwitchLabelSyntax> WithColonTokenAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithPatternAccessor;
    private static Func`3<SwitchLabelSyntax, CSharpSyntaxNode, SwitchLabelSyntax> WithWhenClauseAccessor;
    private SwitchLabelSyntax node;
    public SwitchLabelSyntax SyntaxNode { get; }
    public PatternSyntaxWrapper Pattern { get; }
    public WhenClauseSyntaxWrapper WhenClause { get; }
    private static CasePatternSwitchLabelSyntaxWrapper();
    private CasePatternSwitchLabelSyntaxWrapper(SwitchLabelSyntax node);
    public sealed virtual SwitchLabelSyntax get_SyntaxNode();
    public PatternSyntaxWrapper get_Pattern();
    public WhenClauseSyntaxWrapper get_WhenClause();
    public static CasePatternSwitchLabelSyntaxWrapper op_Explicit(SyntaxNode node);
    public static SwitchLabelSyntax op_Implicit(CasePatternSwitchLabelSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public CasePatternSwitchLabelSyntaxWrapper WithKeyword(SyntaxToken keyword);
    public CasePatternSwitchLabelSyntaxWrapper WithColonToken(SyntaxToken colonToken);
    public CasePatternSwitchLabelSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
    public CasePatternSwitchLabelSyntaxWrapper WithWhenClause(WhenClauseSyntaxWrapper whenClause);
}
internal class StyleCop.Analyzers.Lightup.CommonForEachStatementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    internal static string FallbackWrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxToken> ForEachKeywordAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> InKeywordAccessor;
    private static Func`2<StatementSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`2<StatementSyntax, StatementSyntax> StatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static CommonForEachStatementSyntaxWrapper();
    private CommonForEachStatementSyntaxWrapper(StatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachStatementSyntax node);
    public static CommonForEachStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(CommonForEachStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static CommonForEachStatementSyntaxWrapper FromUpcast(StatementSyntax node);
}
internal class StyleCop.Analyzers.Lightup.ConstantPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithExpressionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    private static ConstantPatternSyntaxWrapper();
    private ConstantPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public static ConstantPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static ConstantPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ConstantPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ConstantPatternSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ConstructorDeclarationSyntaxExtensions : object {
    private static Func`3<ConstructorDeclarationSyntax, ArrowExpressionClauseSyntax, ConstructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static ConstructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.CrefParameterSyntaxExtensions : object {
    private static Func`2<CrefParameterSyntax, SyntaxToken> RefKindKeywordAccessor;
    private static Func`3<CrefParameterSyntax, SyntaxToken, CrefParameterSyntax> WithRefKindKeywordAccessor;
    private static CrefParameterSyntaxExtensions();
    [ExtensionAttribute]
public static SyntaxToken RefKindKeyword(CrefParameterSyntax syntax);
    [ExtensionAttribute]
public static CrefParameterSyntax WithRefKindKeyword(CrefParameterSyntax syntax, SyntaxToken refKindKeyword);
}
internal class StyleCop.Analyzers.Lightup.DeclarationExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, TypeSyntax> TypeAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<ExpressionSyntax, TypeSyntax, ExpressionSyntax> WithTypeAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithDesignationAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationExpressionSyntaxWrapper();
    private DeclarationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(DeclarationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationExpressionSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationExpressionSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
internal class StyleCop.Analyzers.Lightup.DeclarationPatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`2<CSharpSyntaxNode, CSharpSyntaxNode> DesignationAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private static Func`3<CSharpSyntaxNode, CSharpSyntaxNode, CSharpSyntaxNode> WithDesignationAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public TypeSyntax Type { get; }
    public VariableDesignationSyntaxWrapper Designation { get; }
    private static DeclarationPatternSyntaxWrapper();
    private DeclarationPatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public TypeSyntax get_Type();
    public VariableDesignationSyntaxWrapper get_Designation();
    public static DeclarationPatternSyntaxWrapper op_Explicit(PatternSyntaxWrapper node);
    public static DeclarationPatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static PatternSyntaxWrapper op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DeclarationPatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DeclarationPatternSyntaxWrapper WithType(TypeSyntax type);
    public DeclarationPatternSyntaxWrapper WithDesignation(VariableDesignationSyntaxWrapper designation);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.DestructorDeclarationSyntaxExtensions : object {
    private static Func`3<DestructorDeclarationSyntax, ArrowExpressionClauseSyntax, DestructorDeclarationSyntax> WithExpressionBodyAccessor;
    private static DestructorDeclarationSyntaxExtensions();
    [ExtensionAttribute]
public static DestructorDeclarationSyntax WithExpressionBody(DestructorDeclarationSyntax syntax, ArrowExpressionClauseSyntax expressionBody);
}
internal class StyleCop.Analyzers.Lightup.DiscardDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> UnderscoreTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithUnderscoreTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken UnderscoreToken { get; }
    private static DiscardDesignationSyntaxWrapper();
    private DiscardDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_UnderscoreToken();
    public static DiscardDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static DiscardDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(DiscardDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public DiscardDesignationSyntaxWrapper WithUnderscoreToken(SyntaxToken identifier);
}
internal class StyleCop.Analyzers.Lightup.ForEachVariableStatementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, ExpressionSyntax> VariableAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithForEachKeywordAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithOpenParenTokenAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithVariableAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithInKeywordAccessor;
    private static Func`3<StatementSyntax, ExpressionSyntax, StatementSyntax> WithExpressionAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithCloseParenTokenAccessor;
    private static Func`3<StatementSyntax, StatementSyntax, StatementSyntax> WithStatementAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Variable { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    private static ForEachVariableStatementSyntaxWrapper();
    private ForEachVariableStatementSyntaxWrapper(StatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Variable();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(CommonForEachStatementSyntaxWrapper node);
    public static ForEachVariableStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CommonForEachStatementSyntaxWrapper op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static StatementSyntax op_Implicit(ForEachVariableStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ForEachVariableStatementSyntaxWrapper WithForEachKeyword(SyntaxToken forEachKeyword);
    public ForEachVariableStatementSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public ForEachVariableStatementSyntaxWrapper WithVariable(ExpressionSyntax variable);
    public ForEachVariableStatementSyntaxWrapper WithInKeyword(SyntaxToken inKeyword);
    public ForEachVariableStatementSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public ForEachVariableStatementSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
    public ForEachVariableStatementSyntaxWrapper WithStatement(StatementSyntax statement);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.IFieldSymbolExtensions : object {
    private static Func`2<IFieldSymbol, IFieldSymbol> CorrespondingTupleFieldAccessor;
    private static IFieldSymbolExtensions();
    [ExtensionAttribute]
public static IFieldSymbol CorrespondingTupleField(IFieldSymbol symbol);
}
internal class StyleCop.Analyzers.Lightup.ImplicitStackAllocArrayCreationExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> StackAllocKeywordAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseBracketTokenAccessor;
    private static Func`2<ExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithStackAllocKeywordAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseBracketTokenAccessor;
    private static Func`3<ExpressionSyntax, InitializerExpressionSyntax, ExpressionSyntax> WithInitializerAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken StackAllocKeyword { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SyntaxToken CloseBracketToken { get; }
    public InitializerExpressionSyntax Initializer { get; }
    private static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper();
    private ImplicitStackAllocArrayCreationExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_StackAllocKeyword();
    public SyntaxToken get_OpenBracketToken();
    public SyntaxToken get_CloseBracketToken();
    public InitializerExpressionSyntax get_Initializer();
    public static ImplicitStackAllocArrayCreationExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ImplicitStackAllocArrayCreationExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithStackAllocKeyword(SyntaxToken stackAllocKeyword);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithOpenBracketToken(SyntaxToken openBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper WithInitializer(InitializerExpressionSyntax initializer);
    public ImplicitStackAllocArrayCreationExpressionSyntaxWrapper AddInitializerExpressions(ExpressionSyntax[] items);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.INamedTypeSymbolExtensions : object {
    private static Func`2<INamedTypeSymbol, INamedTypeSymbol> TupleUnderlyingTypeAccessor;
    private static Func`2<INamedTypeSymbol, ImmutableArray`1<IFieldSymbol>> TupleElementsAccessor;
    private static Func`2<INamedTypeSymbol, bool> IsSerializableAccessor;
    private static INamedTypeSymbolExtensions();
    [ExtensionAttribute]
public static INamedTypeSymbol TupleUnderlyingType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IFieldSymbol> TupleElements(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsSerializable(INamedTypeSymbol symbol);
}
internal class StyleCop.Analyzers.Lightup.IsPatternExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> IsKeywordAccessor;
    private static Func`2<ExpressionSyntax, CSharpSyntaxNode> PatternAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithIsKeywordAccessor;
    private static Func`3<ExpressionSyntax, CSharpSyntaxNode, ExpressionSyntax> WithPatternAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken IsKeyword { get; }
    public PatternSyntaxWrapper Pattern { get; }
    private static IsPatternExpressionSyntaxWrapper();
    private IsPatternExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_IsKeyword();
    public PatternSyntaxWrapper get_Pattern();
    public static IsPatternExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(IsPatternExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public IsPatternExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
    public IsPatternExpressionSyntaxWrapper WithIsKeyword(SyntaxToken isKeyword);
    public IsPatternExpressionSyntaxWrapper WithPattern(PatternSyntaxWrapper pattern);
}
internal interface StyleCop.Analyzers.Lightup.ISyntaxWrapper`1 {
    public T SyntaxNode { get; }
    public abstract virtual T get_SyntaxNode();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ITypeParameterSymbolExtensions : object {
    private static Func`2<ITypeParameterSymbol, bool> HasUnmanagedTypeConstraintAccessor;
    private static ITypeParameterSymbolExtensions();
    [ExtensionAttribute]
public static bool HasUnmanagedTypeConstraint(ITypeParameterSymbol symbol);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.ITypeSymbolExtensions : object {
    private static Func`2<ITypeSymbol, bool> IsTupleTypeAccessor;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static bool IsTupleType(ITypeSymbol symbol);
}
internal static class StyleCop.Analyzers.Lightup.LanguageVersionEx : object {
    public static LanguageVersion Default;
    public static LanguageVersion CSharp7;
    public static LanguageVersion CSharp7_1;
    public static LanguageVersion CSharp7_2;
    public static LanguageVersion CSharp7_3;
    public static LanguageVersion Latest;
}
internal static class StyleCop.Analyzers.Lightup.LightupHelpers : object {
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<SyntaxKind, bool>> SupportedWrappers;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp7>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp71>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp72>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SupportsCSharp73>k__BackingField;
    public static bool SupportsCSharp7 { get; }
    public static bool SupportsCSharp71 { get; }
    public static bool SupportsCSharp72 { get; }
    public static bool SupportsCSharp73 { get; }
    private static LightupHelpers();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp7();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp71();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp72();
    [CompilerGeneratedAttribute]
public static bool get_SupportsCSharp73();
    internal static bool CanWrapNode(SyntaxNode node, Type underlyingType);
    internal static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName);
    internal static Func`2<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>> CreateSeparatedSyntaxListPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName);
    internal static Func`3<TSyntax, SeparatedSyntaxListWrapper`1<TProperty>, TSyntax> CreateSeparatedSyntaxListWithPropertyAccessor(Type type, string propertyName);
    private static bool ValidatePropertyType(Type returnType, Type actualType);
}
internal class StyleCop.Analyzers.Lightup.LocalFunctionStatementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<StatementSyntax, SyntaxTokenList> ModifiersAccessor;
    private static Func`2<StatementSyntax, TypeSyntax> ReturnTypeAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> IdentifierAccessor;
    private static Func`2<StatementSyntax, TypeParameterListSyntax> TypeParameterListAccessor;
    private static Func`2<StatementSyntax, ParameterListSyntax> ParameterListAccessor;
    private static Func`2<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>> ConstraintClausesAccessor;
    private static Func`2<StatementSyntax, BlockSyntax> BodyAccessor;
    private static Func`2<StatementSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    private static Func`2<StatementSyntax, SyntaxToken> SemicolonTokenAccessor;
    private static Func`3<StatementSyntax, SyntaxTokenList, StatementSyntax> WithModifiersAccessor;
    private static Func`3<StatementSyntax, TypeSyntax, StatementSyntax> WithReturnTypeAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithIdentifierAccessor;
    private static Func`3<StatementSyntax, TypeParameterListSyntax, StatementSyntax> WithTypeParameterListAccessor;
    private static Func`3<StatementSyntax, ParameterListSyntax, StatementSyntax> WithParameterListAccessor;
    private static Func`3<StatementSyntax, SyntaxList`1<TypeParameterConstraintClauseSyntax>, StatementSyntax> WithConstraintClausesAccessor;
    private static Func`3<StatementSyntax, BlockSyntax, StatementSyntax> WithBodyAccessor;
    private static Func`3<StatementSyntax, ArrowExpressionClauseSyntax, StatementSyntax> WithExpressionBodyAccessor;
    private static Func`3<StatementSyntax, SyntaxToken, StatementSyntax> WithSemicolonTokenAccessor;
    private StatementSyntax node;
    public StatementSyntax SyntaxNode { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    private static LocalFunctionStatementSyntaxWrapper();
    private LocalFunctionStatementSyntaxWrapper(StatementSyntax node);
    public sealed virtual StatementSyntax get_SyntaxNode();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public SyntaxToken get_SemicolonToken();
    public static LocalFunctionStatementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static StatementSyntax op_Implicit(LocalFunctionStatementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public LocalFunctionStatementSyntaxWrapper WithModifiers(SyntaxTokenList modifiers);
    public LocalFunctionStatementSyntaxWrapper WithReturnType(TypeSyntax returnType);
    public LocalFunctionStatementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public LocalFunctionStatementSyntaxWrapper WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public LocalFunctionStatementSyntaxWrapper WithParameterList(ParameterListSyntax parameterList);
    public LocalFunctionStatementSyntaxWrapper WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public LocalFunctionStatementSyntaxWrapper WithBody(BlockSyntax body);
    public LocalFunctionStatementSyntaxWrapper WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public LocalFunctionStatementSyntaxWrapper WithSemicolonToken(SyntaxToken semicolonToken);
    public LocalFunctionStatementSyntaxWrapper AddModifiers(SyntaxToken[] items);
    public LocalFunctionStatementSyntaxWrapper AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddParameterListParameters(ParameterSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public LocalFunctionStatementSyntaxWrapper AddBodyStatements(StatementSyntax[] items);
}
internal static class StyleCop.Analyzers.Lightup.MethodKindEx : object {
    public static MethodKind LocalFunction;
}
internal class StyleCop.Analyzers.Lightup.ParenthesizedVariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>> VariablesAccessor;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithOpenParenTokenAccessor;
    private static Func`3<CSharpSyntaxNode, SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper>, CSharpSyntaxNode> WithVariablesAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithCloseParenTokenAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> Variables { get; }
    public SyntaxToken CloseParenToken { get; }
    private static ParenthesizedVariableDesignationSyntaxWrapper();
    private ParenthesizedVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> get_Variables();
    public SyntaxToken get_CloseParenToken();
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static ParenthesizedVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(ParenthesizedVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ParenthesizedVariableDesignationSyntaxWrapper AddVariables(VariableDesignationSyntaxWrapper[] items);
    public ParenthesizedVariableDesignationSyntaxWrapper WithOpenParenToken(SyntaxToken identifier);
    public ParenthesizedVariableDesignationSyntaxWrapper WithVariables(SeparatedSyntaxListWrapper`1<VariableDesignationSyntaxWrapper> variables);
    public ParenthesizedVariableDesignationSyntaxWrapper WithCloseParenToken(SyntaxToken identifier);
}
internal class StyleCop.Analyzers.Lightup.PatternSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static PatternSyntaxWrapper();
    private PatternSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static PatternSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(PatternSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static PatternSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
internal class StyleCop.Analyzers.Lightup.RefExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithRefKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static RefExpressionSyntaxWrapper();
    private RefExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public ExpressionSyntax get_Expression();
    public static RefExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(RefExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefExpressionSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Lightup.RefTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> RefKeywordAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> ReadOnlyKeywordAccessor;
    private static Func`2<TypeSyntax, TypeSyntax> TypeAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithRefKeywordAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithReadOnlyKeywordAccessor;
    private static Func`3<TypeSyntax, TypeSyntax, TypeSyntax> WithTypeAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken RefKeyword { get; }
    public SyntaxToken ReadOnlyKeyword { get; }
    public TypeSyntax Type { get; }
    private static RefTypeSyntaxWrapper();
    private RefTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_RefKeyword();
    public SyntaxToken get_ReadOnlyKeyword();
    public TypeSyntax get_Type();
    public static RefTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(RefTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public RefTypeSyntaxWrapper WithRefKeyword(SyntaxToken refKeyword);
    public RefTypeSyntaxWrapper WithReadOnlyKeyword(SyntaxToken readOnlyKeyword);
    public RefTypeSyntaxWrapper WithType(TypeSyntax type);
}
[DefaultMemberAttribute("Item")]
internal abstract class StyleCop.Analyzers.Lightup.SeparatedSyntaxListWrapper`1 : object {
    private static SyntaxWrapper`1<TNode> SyntaxWrapper;
    [CompilerGeneratedAttribute]
private static SeparatedSyntaxListWrapper`1<TNode> <UnsupportedEmpty>k__BackingField;
    public static SeparatedSyntaxListWrapper`1<TNode> UnsupportedEmpty { get; }
    public int Count { get; }
    public TextSpan FullSpan { get; }
    public int SeparatorCount { get; }
    public TextSpan Span { get; }
    [EditorBrowsableAttribute("1")]
public object UnderlyingList { get; }
    public TNode Item { get; }
    private static SeparatedSyntaxListWrapper`1();
    [CompilerGeneratedAttribute]
public static SeparatedSyntaxListWrapper`1<TNode> get_UnsupportedEmpty();
    public abstract virtual int get_Count();
    public abstract virtual TextSpan get_FullSpan();
    public abstract virtual int get_SeparatorCount();
    public abstract virtual TextSpan get_Span();
    public abstract virtual object get_UnderlyingList();
    public abstract virtual TNode get_Item(int index);
    public static bool op_Equality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxListWrapper`1<TNode> left, SeparatedSyntaxListWrapper`1<TNode> right);
    public SeparatedSyntaxListWrapper`1<TNode> Add(TNode node);
    public SeparatedSyntaxListWrapper`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public abstract virtual bool Any();
    public abstract virtual bool Contains(TNode node);
    public sealed virtual bool Equals(SeparatedSyntaxListWrapper`1<TNode> other);
    public virtual bool Equals(object obj);
    public abstract virtual TNode First();
    public abstract virtual TNode FirstOrDefault();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual int GetHashCode();
    public abstract virtual SyntaxToken GetSeparator(int index);
    public abstract virtual IEnumerable`1<SyntaxToken> GetSeparators();
    public abstract virtual SyntaxNodeOrTokenList GetWithSeparators();
    public abstract virtual int IndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int IndexOf(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Insert(int index, TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    public abstract virtual TNode Last();
    public abstract virtual int LastIndexOf(Func`2<TNode, bool> predicate);
    public abstract virtual int LastIndexOf(TNode node);
    public abstract virtual TNode LastOrDefault();
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Remove(TNode node);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> RemoveAt(int index);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    public abstract virtual SeparatedSyntaxListWrapper`1<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
    public abstract virtual string ToFullString();
    public abstract virtual string ToString();
}
internal class StyleCop.Analyzers.Lightup.SingleVariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Identifier { get; }
    private static SingleVariableDesignationSyntaxWrapper();
    private SingleVariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Identifier();
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(VariableDesignationSyntaxWrapper node);
    public static SingleVariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static VariableDesignationSyntaxWrapper op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static CSharpSyntaxNode op_Implicit(SingleVariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public SingleVariableDesignationSyntaxWrapper WithIdentifier(SyntaxToken identifier);
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.Lightup.StackAllocArrayCreationExpressionSyntaxExtensions : object {
    private static Func`2<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax> InitializerAccessor;
    private static Func`3<StackAllocArrayCreationExpressionSyntax, InitializerExpressionSyntax, StackAllocArrayCreationExpressionSyntax> WithInitializerAccessor;
    private static StackAllocArrayCreationExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static InitializerExpressionSyntax Initializer(StackAllocArrayCreationExpressionSyntax syntax);
    [ExtensionAttribute]
public static StackAllocArrayCreationExpressionSyntax WithInitializer(StackAllocArrayCreationExpressionSyntax syntax, InitializerExpressionSyntax initializer);
}
internal static class StyleCop.Analyzers.Lightup.SymbolDisplayLocalOptionsEx : object {
    public static SymbolDisplayLocalOptions IncludeRef;
}
internal static class StyleCop.Analyzers.Lightup.SymbolDisplayMemberOptionsEx : object {
    public static SymbolDisplayMemberOptions IncludeRef;
}
internal static class StyleCop.Analyzers.Lightup.SymbolKindEx : object {
    public static SymbolKind Discard;
}
internal static class StyleCop.Analyzers.Lightup.SyntaxKindEx : object {
    public static SyntaxKind UnderscoreToken;
    public static SyntaxKind ConflictMarkerTrivia;
    public static SyntaxKind IsPatternExpression;
    public static SyntaxKind DefaultLiteralExpression;
    public static SyntaxKind LocalFunctionStatement;
    public static SyntaxKind TupleType;
    public static SyntaxKind TupleElement;
    public static SyntaxKind TupleExpression;
    public static SyntaxKind SingleVariableDesignation;
    public static SyntaxKind ParenthesizedVariableDesignation;
    public static SyntaxKind ForEachVariableStatement;
    public static SyntaxKind DeclarationPattern;
    public static SyntaxKind ConstantPattern;
    public static SyntaxKind CasePatternSwitchLabel;
    public static SyntaxKind WhenClause;
    public static SyntaxKind DiscardDesignation;
    public static SyntaxKind DeclarationExpression;
    public static SyntaxKind RefExpression;
    public static SyntaxKind RefType;
    public static SyntaxKind ThrowExpression;
    public static SyntaxKind ImplicitStackAllocArrayCreationExpression;
}
internal abstract class StyleCop.Analyzers.Lightup.SyntaxWrapper`1 : object {
    [CompilerGeneratedAttribute]
private static SyntaxWrapper`1<TNode> <Default>k__BackingField;
    public static SyntaxWrapper`1<TNode> Default { get; }
    private static SyntaxWrapper`1();
    [CompilerGeneratedAttribute]
public static SyntaxWrapper`1<TNode> get_Default();
    public abstract virtual TNode Wrap(SyntaxNode node);
    public abstract virtual SyntaxNode Unwrap(TNode node);
    private static SyntaxWrapper`1<TNode> FindDefaultSyntaxWrapper();
}
internal class StyleCop.Analyzers.Lightup.ThrowExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> ThrowKeywordAccessor;
    private static Func`2<ExpressionSyntax, ExpressionSyntax> ExpressionAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithThrowKeywordAccessor;
    private static Func`3<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> WithExpressionAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    private static ThrowExpressionSyntaxWrapper();
    private ThrowExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_ThrowKeyword();
    public ExpressionSyntax get_Expression();
    public static ThrowExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(ThrowExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public ThrowExpressionSyntaxWrapper WithThrowKeyword(SyntaxToken throwKeyword);
    public ThrowExpressionSyntaxWrapper WithExpression(ExpressionSyntax expression);
}
internal class StyleCop.Analyzers.Lightup.TupleElementSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> IdentifierAccessor;
    private static Func`2<CSharpSyntaxNode, TypeSyntax> TypeAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithIdentifierAccessor;
    private static Func`3<CSharpSyntaxNode, TypeSyntax, CSharpSyntaxNode> WithTypeAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken Identifier { get; }
    public TypeSyntax Type { get; }
    private static TupleElementSyntaxWrapper();
    private TupleElementSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_Identifier();
    public TypeSyntax get_Type();
    public static TupleElementSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(TupleElementSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleElementSyntaxWrapper WithIdentifier(SyntaxToken identifier);
    public TupleElementSyntaxWrapper WithType(TypeSyntax type);
}
internal class StyleCop.Analyzers.Lightup.TupleExpressionSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<ExpressionSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>> ArgumentsAccessor;
    private static Func`2<ExpressionSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithOpenParenTokenAccessor;
    private static Func`3<ExpressionSyntax, SeparatedSyntaxList`1<ArgumentSyntax>, ExpressionSyntax> WithArgumentsAccessor;
    private static Func`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> WithCloseParenTokenAccessor;
    private ExpressionSyntax node;
    public ExpressionSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleExpressionSyntaxWrapper();
    private TupleExpressionSyntaxWrapper(ExpressionSyntax node);
    public sealed virtual ExpressionSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    public static TupleExpressionSyntaxWrapper op_Explicit(SyntaxNode node);
    public static ExpressionSyntax op_Implicit(TupleExpressionSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleExpressionSyntaxWrapper AddArguments(ArgumentSyntax[] items);
    public TupleExpressionSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleExpressionSyntaxWrapper WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public TupleExpressionSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
internal class StyleCop.Analyzers.Lightup.TupleTypeSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<TypeSyntax, SyntaxToken> OpenParenTokenAccessor;
    private static Func`2<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>> ElementsAccessor;
    private static Func`2<TypeSyntax, SyntaxToken> CloseParenTokenAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithOpenParenTokenAccessor;
    private static Func`3<TypeSyntax, SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper>, TypeSyntax> WithElementsAccessor;
    private static Func`3<TypeSyntax, SyntaxToken, TypeSyntax> WithCloseParenTokenAccessor;
    private TypeSyntax node;
    public TypeSyntax SyntaxNode { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> Elements { get; }
    public SyntaxToken CloseParenToken { get; }
    private static TupleTypeSyntaxWrapper();
    private TupleTypeSyntaxWrapper(TypeSyntax node);
    public sealed virtual TypeSyntax get_SyntaxNode();
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> get_Elements();
    public SyntaxToken get_CloseParenToken();
    public static TupleTypeSyntaxWrapper op_Explicit(SyntaxNode node);
    public static TypeSyntax op_Implicit(TupleTypeSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public TupleTypeSyntaxWrapper AddElements(TupleElementSyntaxWrapper[] items);
    public TupleTypeSyntaxWrapper WithOpenParenToken(SyntaxToken openParenToken);
    public TupleTypeSyntaxWrapper WithElements(SeparatedSyntaxListWrapper`1<TupleElementSyntaxWrapper> elements);
    public TupleTypeSyntaxWrapper WithCloseParenToken(SyntaxToken closeParenToken);
}
internal class StyleCop.Analyzers.Lightup.VariableDesignationSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    private static VariableDesignationSyntaxWrapper();
    private VariableDesignationSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public static VariableDesignationSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(VariableDesignationSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    internal static VariableDesignationSyntaxWrapper FromUpcast(CSharpSyntaxNode node);
}
internal class StyleCop.Analyzers.Lightup.WhenClauseSyntaxWrapper : ValueType {
    internal static string WrappedTypeName;
    private static Type WrappedType;
    private static Func`2<CSharpSyntaxNode, SyntaxToken> WhenKeywordAccessor;
    private static Func`2<CSharpSyntaxNode, ExpressionSyntax> ConditionAccessor;
    private static Func`3<CSharpSyntaxNode, SyntaxToken, CSharpSyntaxNode> WithWhenKeywordAccessor;
    private static Func`3<CSharpSyntaxNode, ExpressionSyntax, CSharpSyntaxNode> WithConditionAccessor;
    private CSharpSyntaxNode node;
    public CSharpSyntaxNode SyntaxNode { get; }
    public SyntaxToken WhenKeyword { get; }
    public ExpressionSyntax Condition { get; }
    private static WhenClauseSyntaxWrapper();
    private WhenClauseSyntaxWrapper(CSharpSyntaxNode node);
    public sealed virtual CSharpSyntaxNode get_SyntaxNode();
    public SyntaxToken get_WhenKeyword();
    public ExpressionSyntax get_Condition();
    public static WhenClauseSyntaxWrapper op_Explicit(SyntaxNode node);
    public static CSharpSyntaxNode op_Implicit(WhenClauseSyntaxWrapper wrapper);
    public static bool IsInstance(SyntaxNode node);
    public WhenClauseSyntaxWrapper WithWhenKeyword(SyntaxToken whenKeyword);
    public WhenClauseSyntaxWrapper WithCondition(ExpressionSyntax condition);
}
internal static class StyleCop.Analyzers.Lightup.WrapperHelper : object {
    private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static WrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.MaintainabilityRules.MaintainabilityResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SA1119CodeFix { get; }
    internal static string SA1400CodeFix { get; }
    internal static string SA1402CodeFix { get; }
    internal static string SA1404CodeFix { get; }
    internal static string SA1407SA1408CodeFix { get; }
    internal static string SA1410SA1411CodeFix { get; }
    internal static string SA1412CodeFix { get; }
    internal static string SA1413CodeFix { get; }
    internal static string SA1413Description { get; }
    internal static string SA1413MessageFormat { get; }
    internal static string SA1413Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SA1119CodeFix();
    internal static string get_SA1400CodeFix();
    internal static string get_SA1402CodeFix();
    internal static string get_SA1404CodeFix();
    internal static string get_SA1407SA1408CodeFix();
    internal static string get_SA1410SA1411CodeFix();
    internal static string get_SA1412CodeFix();
    internal static string get_SA1413CodeFix();
    internal static string get_SA1413Description();
    internal static string get_SA1413MessageFormat();
    internal static string get_SA1413Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1119StatementMustNotUseUnnecessaryParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static string ParenthesesDiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static DiagnosticDescriptor ParenthesisDescriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1119StatementMustNotUseUnnecessaryParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleParenthesizedExpression(SyntaxNodeAnalysisContext context);
    private static bool IsConditionalAccessInInterpolation(ExpressionSyntax node);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ParenthesizedExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1400AccessModifierMustBeDeclared : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseFieldDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1400AccessModifierMustBeDeclared();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckAccessModifiers(SyntaxNodeAnalysisContext context, SyntaxToken identifier, SyntaxTokenList modifiers, SyntaxNode declarationNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("The "Encapsulate Field" fix is provided by Visual Studio.")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1401FieldsMustBePrivate : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SymbolAnalysisContext> AnalyzeFieldAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1401FieldsMustBePrivate();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1402FileMayOnlyContainASingleType : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1402FileMayOnlyContainASingleType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
    private static IEnumerable`1<MemberDeclarationSyntax> GetTopLevelTypeDeclarations(SyntaxNode root, StyleCopSettings settings);
    private static bool ContainsTopLevelTypeDeclarations(SyntaxNode node);
    private static bool IsRelevantType(SyntaxNode node, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1403FileMayOnlyContainASingleNamespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1403FileMayOnlyContainASingleNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1404CodeAnalysisSuppressionMustHaveJustification : DiagnosticAnalyzer {
    public static string JustificationPlaceholder;
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1404CodeAnalysisSuppressionMustHaveJustification();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1405DebugAssertMustProvideMessageText : SystemDiagnosticsDebugDiagnosticBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1405DebugAssertMustProvideMessageText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("No message is available for Debug.Fail")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1406DebugFailMustProvideMessageText : SystemDiagnosticsDebugDiagnosticBase {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1406DebugFailMustProvideMessageText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1407ArithmeticExpressionsMustDeclarePrecedence : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1407ArithmeticExpressionsMustDeclarePrecedence();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsSameFamily(SyntaxToken operatorToken1, SyntaxToken operatorToken2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1408ConditionalExpressionsMustDeclarePrecedence : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1408ConditionalExpressionsMustDeclarePrecedence();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsSameFamily(SyntaxToken operatorToken1, SyntaxToken operatorToken2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic requires deep semantic analysis which is more suited to a usage-based analysis toolset as opposed to a style-based analysis toolset.")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1409RemoveUnnecessaryCode : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1409RemoveUnnecessaryCode();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1410RemoveDelegateParenthesisWhenPossible : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1410RemoveDelegateParenthesisWhenPossible();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool HasAmbiguousOverload(SyntaxNodeAnalysisContext context, AnonymousMethodExpressionSyntax anonymousMethodExpression, SyntaxNode methodCallSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1411AttributeConstructorMustNotUseUnnecessaryParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1412StoreFilesAsUtf8 : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    private static Byte[] utf8Preamble;
    [CompilerGeneratedAttribute]
private static string <EncodingProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static string EncodingProperty { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1412StoreFilesAsUtf8();
    [CompilerGeneratedAttribute]
public static string get_EncodingProperty();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static bool IsUtf8Preamble(Byte[] preamble);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.MaintainabilityRules.SA1413UseTrailingCommasInMultiLineInitializers : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleObjectInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAnonymousObjectInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> HandleEnumDeclarationAction;
    private static ImmutableArray`1<SyntaxKind> ObjectInitializerKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1413UseTrailingCommasInMultiLineInitializers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectInitializer(SyntaxNodeAnalysisContext context);
}
internal abstract class StyleCop.Analyzers.MaintainabilityRules.SystemDiagnosticsDebugDiagnosticBase : DiagnosticAnalyzer {
    protected internal static void HandleInvocationExpression(SyntaxNodeAnalysisContext context, string methodName, int parameterIndex, DiagnosticDescriptor descriptor);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.NamingRules.NamingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string RenameToCodeFix { get; }
    internal static string SA1302CodeFix { get; }
    internal static string SA1312Description { get; }
    internal static string SA1312MessageFormat { get; }
    internal static string SA1312Title { get; }
    internal static string SA1313Description { get; }
    internal static string SA1313MessageFormat { get; }
    internal static string SA1313Title { get; }
    internal static string SA1314CodeFix { get; }
    internal static string SA1314Description { get; }
    internal static string SA1314MessageFormat { get; }
    internal static string SA1314Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_RenameToCodeFix();
    internal static string get_SA1302CodeFix();
    internal static string get_SA1312Description();
    internal static string get_SA1312MessageFormat();
    internal static string get_SA1312Title();
    internal static string get_SA1313Description();
    internal static string get_SA1313MessageFormat();
    internal static string get_SA1313Title();
    internal static string get_SA1314CodeFix();
    internal static string get_SA1314Description();
    internal static string get_SA1314MessageFormat();
    internal static string get_SA1314Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1300ElementMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ClassDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumMemberDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> StructDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EventFieldDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1300ElementMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckNameSyntax(SyntaxNodeAnalysisContext context, NameSyntax nameSyntax);
    private static void HandleClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumMemberDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckElementNameToken(SyntaxNodeAnalysisContext context, SyntaxToken identifier, bool allowUnderscoreDigit);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This rule has no behavior by design.")]
[NoCodeFixAttribute("Don't fix what isn't broken.")]
internal class StyleCop.Analyzers.NamingRules.SA1301ElementMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1301ElementMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1302InterfaceNamesMustBeginWithI : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> InterfaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1302InterfaceNamesMustBeginWithI();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleInterfaceDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1303ConstFieldNamesMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SymbolAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1303ConstFieldNamesMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1304NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1305FieldNamesMustNotUseHungarianNotation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<string> CommonPrefixes;
    private static Regex HungarianRegex;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> VariableDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ParameterDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CatchDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> QueryContinuationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> FromClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> LetClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> JoinClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> JoinIntoClauseAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> ForEachStatementAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> SingleVariableDesignationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1305FieldNamesMustNotUseHungarianNotation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1306FieldNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1306FieldNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1307AccessibleFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    internal static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1307AccessibleFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1308VariableNamesMustNotBePrefixed : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1308VariableNamesMustNotBePrefixed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1309FieldNamesMustNotBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1309FieldNamesMustNotBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1310FieldNamesMustNotContainUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1310FieldNamesMustNotContainUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1311StaticReadonlyFieldsMustBeginWithUpperCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1312VariableNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> VariableDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> CatchDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> QueryContinuationAction;
    private static Action`1<SyntaxNodeAnalysisContext> FromClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> LetClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> JoinClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> JoinIntoClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> ForEachStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> SingleVariableDesignationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1312VariableNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleCatchDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleQueryContinuation(SyntaxNodeAnalysisContext context);
    private static void HandleFromClause(SyntaxNodeAnalysisContext context);
    private static void HandleLetClause(SyntaxNodeAnalysisContext context);
    private static void HandleJoinClause(SyntaxNodeAnalysisContext context);
    private static void HandleJoinIntoClause(SyntaxNodeAnalysisContext context);
    private static void HandleForEachStatement(SyntaxNodeAnalysisContext context);
    private static void HandleSingleVariableDesignation(SyntaxNodeAnalysisContext context);
    private static void CheckIdentifier(SyntaxNodeAnalysisContext context, SyntaxToken identifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1313ParameterNamesMustBeginWithLowerCaseLetter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ParameterAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1313ParameterNamesMustBeginWithLowerCaseLetter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleParameter(SyntaxNodeAnalysisContext context);
    private static bool IsInLambda(ParameterSyntax syntax);
    private static bool NameMatchesAbstraction(ParameterSyntax syntax, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SA1314TypeParameterNamesMustBeginWithT : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1314TypeParameterNamesMustBeginWithT();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeParameter(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SX1309FieldNamesMustBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1309FieldNamesMustBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.NamingRules.SX1309SStaticFieldNamesMustBeginWithUnderscore : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> FieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1309SStaticFieldNamesMustBeginWithUnderscore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[AttributeUsageAttribute("4")]
internal class StyleCop.Analyzers.NoCodeFixAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public NoCodeFixAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
[AttributeUsageAttribute("4")]
internal class StyleCop.Analyzers.NoDiagnosticAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public NoDiagnosticAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
internal static class StyleCop.Analyzers.OrderingRules.ModifierOrderHelper : object {
    internal static ModifierType GetModifierType(SyntaxToken modifier);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.OrderingRules.OrderingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ElementOrderCodeFix { get; }
    internal static string ModifierOrderCodeFix { get; }
    internal static string SA1201Description { get; }
    internal static string SA1201MessageFormat { get; }
    internal static string SA1201Title { get; }
    internal static string SA1202Description { get; }
    internal static string SA1202MessageFormat { get; }
    internal static string SA1202Title { get; }
    internal static string SA1203Description { get; }
    internal static string SA1203MessageFormat { get; }
    internal static string SA1203Title { get; }
    internal static string SA1204Description { get; }
    internal static string SA1204MessageFormat { get; }
    internal static string SA1204Title { get; }
    internal static string SA1205CodeFix { get; }
    internal static string SA1207CodeFix { get; }
    internal static string SA1213CodeFix { get; }
    internal static string SA1214Description { get; }
    internal static string SA1214MessageFormat { get; }
    internal static string SA1214Title { get; }
    internal static string UsingCodeFix { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ElementOrderCodeFix();
    internal static string get_ModifierOrderCodeFix();
    internal static string get_SA1201Description();
    internal static string get_SA1201MessageFormat();
    internal static string get_SA1201Title();
    internal static string get_SA1202Description();
    internal static string get_SA1202MessageFormat();
    internal static string get_SA1202Title();
    internal static string get_SA1203Description();
    internal static string get_SA1203MessageFormat();
    internal static string get_SA1203Title();
    internal static string get_SA1204Description();
    internal static string get_SA1204MessageFormat();
    internal static string get_SA1204Title();
    internal static string get_SA1205CodeFix();
    internal static string get_SA1207CodeFix();
    internal static string get_SA1213CodeFix();
    internal static string get_SA1214Description();
    internal static string get_SA1214MessageFormat();
    internal static string get_SA1214Title();
    internal static string get_UsingCodeFix();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1200UsingDirectivesMustBePlacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static DiagnosticDescriptor DescriptorInside;
    internal static DiagnosticDescriptor DescriptorOutside;
    private static string Title;
    private static string MessageFormatInside;
    private static string DescriptionInside;
    private static string HelpLink;
    private static string MessageFormatOutside;
    private static string DescriptionOutside;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1200UsingDirectivesMustBePlacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1201ElementsMustAppearInTheCorrectOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static ImmutableArray`1<SyntaxKind> OuterOrder;
    private static ImmutableArray`1<SyntaxKind> TypeMemberOrder;
    private static Dictionary`2<SyntaxKind, string> MemberNames;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1201ElementsMustAppearInTheCorrectOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int kindIndex, SyntaxList`1<MemberDeclarationSyntax> members, ImmutableArray`1<SyntaxKind> order);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1202ElementsMustBeOrderedByAccess : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static ImmutableHashSet`1<SyntaxKind> MemberKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1202ElementsMustBeOrderedByAccess();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int accessibilityIndex, SyntaxList`1<MemberDeclarationSyntax> members, AccessLevel defaultAccessLevel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1203ConstantsMustAppearBeforeFields : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1203ConstantsMustAppearBeforeFields();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1204StaticElementsMustAppearBeforeInstanceElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1204StaticElementsMustAppearBeforeInstanceElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleMemberList(SyntaxNodeAnalysisContext context, ImmutableArray`1<OrderingTrait> elementOrder, int staticIndex, SyntaxList`1<MemberDeclarationSyntax> members);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1205PartialElementsMustDeclareAccess : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1205PartialElementsMustDeclareAccess();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1206DeclarationKeywordsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1206DeclarationKeywordsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckModifiersOrderAndReportDiagnostics(SyntaxNodeAnalysisContext context, SyntaxTokenList modifiers);
    private static int CompareModifiersType(ModifierType first, ModifierType second);
    private static string GetModifierTypeText(ModifierType modifierType);
    private static bool AccessOrStaticModifierNotFollowingOtherModifier(ModifierType current, ModifierType previous);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1207ProtectedMustComeBeforeInternal : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> DeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1207ProtectedMustComeBeforeInternal();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1208SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void ProcessUsingsAndReportDiagnostic(SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1209UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void ProcessUsingsAndReportDiagnostic(SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1210UsingDirectivesMustBeOrderedAlphabeticallyByNamespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void ProcessUsings(SyntaxNodeAnalysisContext context, OrderingSettings orderingSettings, SyntaxList`1<UsingDirectiveSyntax> usings);
    private static void CheckIncorrectlyOrderedUsingsAndReportDiagnostic(SyntaxNodeAnalysisContext context, IEnumerable`1<UsingDirectiveSyntax> usings);
    private static bool IsAliasOrStaticUsingDirective(UsingDirectiveSyntax usingDirective);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1211UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleUsingDirectives(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1212PropertyAccessorsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> PropertyDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1212PropertyAccessorsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeProperty(SyntaxNodeAnalysisContext context, BasePropertyDeclarationSyntax propertyDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1213EventAccessorsMustFollowOrder : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> EventDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1213EventAccessorsMustFollowOrder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEventDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> TypeDeclarationKinds;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> TypeDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1214ReadonlyElementsMustAppearBeforeNonReadonlyElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1216UsingStaticDirectivesMustBePlacedAtTheCorrectLocation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckUsingDeclarations(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.OrderingRules.SA1217UsingStaticDirectivesMustBeOrderedAlphabetically : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> CompilationUnitAction;
    private static Action`2<SyntaxNodeAnalysisContext, StyleCopSettings> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1217UsingStaticDirectivesMustBeOrderedAlphabetically();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings);
    private static void CheckUsingDeclarations(SyntaxNodeAnalysisContext context, OrderingSettings orderingSettings, SyntaxList`1<UsingDirectiveSyntax> usingDirectives);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.ReadabilityRules.ReadabilityResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IndentationCodeFix { get; }
    internal static string RemoveRegionCodeFix { get; }
    internal static string SA1100CodeFix { get; }
    internal static string SA1100Description { get; }
    internal static string SA1100MessageFormat { get; }
    internal static string SA1100Title { get; }
    internal static string SA1101CodeFix { get; }
    internal static string SA1101Description { get; }
    internal static string SA1101MessageFormat { get; }
    internal static string SA1101Title { get; }
    internal static string SA1102CodeFix { get; }
    internal static string SA1102Description { get; }
    internal static string SA1102MessageFormat { get; }
    internal static string SA1102Title { get; }
    internal static string SA1103CodeFixMultipleLines { get; }
    internal static string SA1103CodeFixSingleLine { get; }
    internal static string SA1103Description { get; }
    internal static string SA1103MessageFormat { get; }
    internal static string SA1103Title { get; }
    internal static string SA1104Description { get; }
    internal static string SA1104MessageFormat { get; }
    internal static string SA1104SA1105CodeFix { get; }
    internal static string SA1104Title { get; }
    internal static string SA1105Description { get; }
    internal static string SA1105MessageFormat { get; }
    internal static string SA1105Title { get; }
    internal static string SA1106CodeFix { get; }
    internal static string SA1106Description { get; }
    internal static string SA1106MessageFormat { get; }
    internal static string SA1106Title { get; }
    internal static string SA1107CodeFix { get; }
    internal static string SA1107Description { get; }
    internal static string SA1107MessageFormat { get; }
    internal static string SA1107Title { get; }
    internal static string SA1108Description { get; }
    internal static string SA1108MessageFormat { get; }
    internal static string SA1108Title { get; }
    internal static string SA1109Description { get; }
    internal static string SA1109MessageFormat { get; }
    internal static string SA1109Title { get; }
    internal static string SA1110Description { get; }
    internal static string SA1110MessageFormat { get; }
    internal static string SA1110Title { get; }
    internal static string SA1111Description { get; }
    internal static string SA1111MessageFormat { get; }
    internal static string SA1111Title { get; }
    internal static string SA1112Description { get; }
    internal static string SA1112MessageFormat { get; }
    internal static string SA1112Title { get; }
    internal static string SA1113Description { get; }
    internal static string SA1113MessageFormat { get; }
    internal static string SA1113Title { get; }
    internal static string SA1114Description { get; }
    internal static string SA1114MessageFormat { get; }
    internal static string SA1114Title { get; }
    internal static string SA1115Description { get; }
    internal static string SA1115MessageFormat { get; }
    internal static string SA1115Title { get; }
    internal static string SA1116CodeFix { get; }
    internal static string SA1116Description { get; }
    internal static string SA1116MessageFormat { get; }
    internal static string SA1116Title { get; }
    internal static string SA1117Description { get; }
    internal static string SA1117MessageFormat { get; }
    internal static string SA1117Title { get; }
    internal static string SA1118Description { get; }
    internal static string SA1118MessageFormat { get; }
    internal static string SA1118Title { get; }
    internal static string SA1120CodeFix { get; }
    internal static string SA1120Description { get; }
    internal static string SA1120MessageFormat { get; }
    internal static string SA1120Title { get; }
    internal static string SA1121CodeFix { get; }
    internal static string SA1121Description { get; }
    internal static string SA1121MessageFormat { get; }
    internal static string SA1121Title { get; }
    internal static string SA1122CodeFix { get; }
    internal static string SA1122Description { get; }
    internal static string SA1122MessageFormat { get; }
    internal static string SA1122Title { get; }
    internal static string SA1123Description { get; }
    internal static string SA1123MessageFormat { get; }
    internal static string SA1123Title { get; }
    internal static string SA1124Description { get; }
    internal static string SA1124MessageFormat { get; }
    internal static string SA1124Title { get; }
    internal static string SA1125Description { get; }
    internal static string SA1125MessageFormat { get; }
    internal static string SA1125Title { get; }
    internal static string SA1126Description { get; }
    internal static string SA1126MessageFormat { get; }
    internal static string SA1126Title { get; }
    internal static string SA1127CodeFix { get; }
    internal static string SA1127Description { get; }
    internal static string SA1127MessageFormat { get; }
    internal static string SA1127Title { get; }
    internal static string SA1128CodeFix { get; }
    internal static string SA1128Description { get; }
    internal static string SA1128MessageFormat { get; }
    internal static string SA1128Title { get; }
    internal static string SA1129CodeFix { get; }
    internal static string SA1129Description { get; }
    internal static string SA1129MessageFormat { get; }
    internal static string SA1129Title { get; }
    internal static string SA1130CodeFix { get; }
    internal static string SA1130Description { get; }
    internal static string SA1130MessageFormat { get; }
    internal static string SA1130Title { get; }
    internal static string SA1131CodeFix { get; }
    internal static string SA1131Description { get; }
    internal static string SA1131MessageFormat { get; }
    internal static string SA1131Title { get; }
    internal static string SA1132CodeFix { get; }
    internal static string SA1132Description { get; }
    internal static string SA1132MessageFormat { get; }
    internal static string SA1132Title { get; }
    internal static string SA1133CodeFix { get; }
    internal static string SA1133Description { get; }
    internal static string SA1133MessageFormat { get; }
    internal static string SA1133Title { get; }
    internal static string SA1134CodeFix { get; }
    internal static string SA1134Description { get; }
    internal static string SA1134MessageFormat { get; }
    internal static string SA1134Title { get; }
    internal static string SA1135CodeFix { get; }
    internal static string SA1135Description { get; }
    internal static string SA1135MessageFormatNamespace { get; }
    internal static string SA1135MessageFormatType { get; }
    internal static string SA1135Title { get; }
    internal static string SA1136CodeFix { get; }
    internal static string SA1136Description { get; }
    internal static string SA1136MessageFormat { get; }
    internal static string SA1136Title { get; }
    internal static string SA1137Description { get; }
    internal static string SA1137MessageFormat { get; }
    internal static string SA1137Title { get; }
    internal static string SA1139CodeFix { get; }
    internal static string SA1139Description { get; }
    internal static string SA1139MessageFormat { get; }
    internal static string SA1139Title { get; }
    internal static string SX1101CodeFix { get; }
    internal static string SX1101Description { get; }
    internal static string SX1101MessageFormat { get; }
    internal static string SX1101Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IndentationCodeFix();
    internal static string get_RemoveRegionCodeFix();
    internal static string get_SA1100CodeFix();
    internal static string get_SA1100Description();
    internal static string get_SA1100MessageFormat();
    internal static string get_SA1100Title();
    internal static string get_SA1101CodeFix();
    internal static string get_SA1101Description();
    internal static string get_SA1101MessageFormat();
    internal static string get_SA1101Title();
    internal static string get_SA1102CodeFix();
    internal static string get_SA1102Description();
    internal static string get_SA1102MessageFormat();
    internal static string get_SA1102Title();
    internal static string get_SA1103CodeFixMultipleLines();
    internal static string get_SA1103CodeFixSingleLine();
    internal static string get_SA1103Description();
    internal static string get_SA1103MessageFormat();
    internal static string get_SA1103Title();
    internal static string get_SA1104Description();
    internal static string get_SA1104MessageFormat();
    internal static string get_SA1104SA1105CodeFix();
    internal static string get_SA1104Title();
    internal static string get_SA1105Description();
    internal static string get_SA1105MessageFormat();
    internal static string get_SA1105Title();
    internal static string get_SA1106CodeFix();
    internal static string get_SA1106Description();
    internal static string get_SA1106MessageFormat();
    internal static string get_SA1106Title();
    internal static string get_SA1107CodeFix();
    internal static string get_SA1107Description();
    internal static string get_SA1107MessageFormat();
    internal static string get_SA1107Title();
    internal static string get_SA1108Description();
    internal static string get_SA1108MessageFormat();
    internal static string get_SA1108Title();
    internal static string get_SA1109Description();
    internal static string get_SA1109MessageFormat();
    internal static string get_SA1109Title();
    internal static string get_SA1110Description();
    internal static string get_SA1110MessageFormat();
    internal static string get_SA1110Title();
    internal static string get_SA1111Description();
    internal static string get_SA1111MessageFormat();
    internal static string get_SA1111Title();
    internal static string get_SA1112Description();
    internal static string get_SA1112MessageFormat();
    internal static string get_SA1112Title();
    internal static string get_SA1113Description();
    internal static string get_SA1113MessageFormat();
    internal static string get_SA1113Title();
    internal static string get_SA1114Description();
    internal static string get_SA1114MessageFormat();
    internal static string get_SA1114Title();
    internal static string get_SA1115Description();
    internal static string get_SA1115MessageFormat();
    internal static string get_SA1115Title();
    internal static string get_SA1116CodeFix();
    internal static string get_SA1116Description();
    internal static string get_SA1116MessageFormat();
    internal static string get_SA1116Title();
    internal static string get_SA1117Description();
    internal static string get_SA1117MessageFormat();
    internal static string get_SA1117Title();
    internal static string get_SA1118Description();
    internal static string get_SA1118MessageFormat();
    internal static string get_SA1118Title();
    internal static string get_SA1120CodeFix();
    internal static string get_SA1120Description();
    internal static string get_SA1120MessageFormat();
    internal static string get_SA1120Title();
    internal static string get_SA1121CodeFix();
    internal static string get_SA1121Description();
    internal static string get_SA1121MessageFormat();
    internal static string get_SA1121Title();
    internal static string get_SA1122CodeFix();
    internal static string get_SA1122Description();
    internal static string get_SA1122MessageFormat();
    internal static string get_SA1122Title();
    internal static string get_SA1123Description();
    internal static string get_SA1123MessageFormat();
    internal static string get_SA1123Title();
    internal static string get_SA1124Description();
    internal static string get_SA1124MessageFormat();
    internal static string get_SA1124Title();
    internal static string get_SA1125Description();
    internal static string get_SA1125MessageFormat();
    internal static string get_SA1125Title();
    internal static string get_SA1126Description();
    internal static string get_SA1126MessageFormat();
    internal static string get_SA1126Title();
    internal static string get_SA1127CodeFix();
    internal static string get_SA1127Description();
    internal static string get_SA1127MessageFormat();
    internal static string get_SA1127Title();
    internal static string get_SA1128CodeFix();
    internal static string get_SA1128Description();
    internal static string get_SA1128MessageFormat();
    internal static string get_SA1128Title();
    internal static string get_SA1129CodeFix();
    internal static string get_SA1129Description();
    internal static string get_SA1129MessageFormat();
    internal static string get_SA1129Title();
    internal static string get_SA1130CodeFix();
    internal static string get_SA1130Description();
    internal static string get_SA1130MessageFormat();
    internal static string get_SA1130Title();
    internal static string get_SA1131CodeFix();
    internal static string get_SA1131Description();
    internal static string get_SA1131MessageFormat();
    internal static string get_SA1131Title();
    internal static string get_SA1132CodeFix();
    internal static string get_SA1132Description();
    internal static string get_SA1132MessageFormat();
    internal static string get_SA1132Title();
    internal static string get_SA1133CodeFix();
    internal static string get_SA1133Description();
    internal static string get_SA1133MessageFormat();
    internal static string get_SA1133Title();
    internal static string get_SA1134CodeFix();
    internal static string get_SA1134Description();
    internal static string get_SA1134MessageFormat();
    internal static string get_SA1134Title();
    internal static string get_SA1135CodeFix();
    internal static string get_SA1135Description();
    internal static string get_SA1135MessageFormatNamespace();
    internal static string get_SA1135MessageFormatType();
    internal static string get_SA1135Title();
    internal static string get_SA1136CodeFix();
    internal static string get_SA1136Description();
    internal static string get_SA1136MessageFormat();
    internal static string get_SA1136Title();
    internal static string get_SA1137Description();
    internal static string get_SA1137MessageFormat();
    internal static string get_SA1137Title();
    internal static string get_SA1139CodeFix();
    internal static string get_SA1139Description();
    internal static string get_SA1139MessageFormat();
    internal static string get_SA1139Title();
    internal static string get_SX1101CodeFix();
    internal static string get_SX1101Description();
    internal static string get_SX1101MessageFormat();
    internal static string get_SX1101Title();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1100DoNotPrefixCallsWithBaseUnlessLocalImplementationExists();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1101PrefixLocalCallsWithThis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MemberAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> SimpleNameAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1101PrefixLocalCallsWithThis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleSimpleName(SyntaxNodeAnalysisContext context);
    private static void HandleIdentifierNameImpl(SyntaxNodeAnalysisContext context, SimpleNameSyntax nameExpression);
    private static bool HasThis(SyntaxNode node);
    private static bool IsPartOfConstructorInitializer(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1106CodeMustNotContainEmptyStatements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> EmptyStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseTypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1106CodeMustNotContainEmptyStatements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEmptyStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1107CodeMustNotContainMultipleStatementsOnOneLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1107CodeMustNotContainMultipleStatementsOnOneLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static bool IsLastTokenMissing(StatementSyntax previousStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1108BlockStatementsMustNotContainEmbeddedComments : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static SyntaxKind[] SupportedKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1108BlockStatementsMustNotContainEmbeddedComments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void FindAllComments(SyntaxNodeAnalysisContext context, SyntaxToken previousToken, SyntaxToken openBraceToken);
    private static bool IsComment(SyntaxTrivia syntaxTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("This diagnostic is rarely-occurring specialization of SA1123; the latter is now preferred in all cases.")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1109BlockStatementsMustNotContainEmbeddedRegions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1109BlockStatementsMustNotContainEmbeddedRegions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA110xQueryClauses : DiagnosticAnalyzer {
    private static string SA1102Identifier;
    private static string SA1103Identifier;
    private static string SA1104Identifier;
    private static string SA1105Identifier;
    private static LocalizableString SA1102Title;
    private static LocalizableString SA1102MessageFormat;
    private static LocalizableString SA1102Description;
    private static string SA1102HelpLink;
    private static LocalizableString SA1103Title;
    private static LocalizableString SA1103MessageFormat;
    private static LocalizableString SA1103Description;
    private static string SA1103HelpLink;
    private static LocalizableString SA1104Title;
    private static LocalizableString SA1104MessageFormat;
    private static LocalizableString SA1104Description;
    private static string SA1104HelpLink;
    private static LocalizableString SA1105Title;
    private static LocalizableString SA1105MessageFormat;
    private static LocalizableString SA1105Description;
    private static string SA1105HelpLink;
    private static Action`1<SyntaxNodeAnalysisContext> QueryExpressionAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1102Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1103Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1104Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <SA1105Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor SA1102Descriptor { get; }
    public static DiagnosticDescriptor SA1103Descriptor { get; }
    public static DiagnosticDescriptor SA1104Descriptor { get; }
    public static DiagnosticDescriptor SA1105Descriptor { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA110xQueryClauses();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1102Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1103Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1104Descriptor();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_SA1105Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleQueryExpression(SyntaxNodeAnalysisContext context);
    private static void HandleQueryBody(QueryBodySyntax body, List`1<SyntaxToken> tokensToCheck);
    private static void HandleQueryClause(QueryClauseSyntax queryClause, List`1<SyntaxToken> tokensToCheck);
    private static void HandleSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup, List`1<SyntaxToken> tokensToCheck);
    private static void HandleContinuation(QueryContinuationSyntax continuation, List`1<SyntaxToken> tokensToCheck);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1110OpeningParenthesisMustBeOnDeclarationLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> OperatorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConversionOperatorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1110OpeningParenthesisMustBeOnDeclarationLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext obj);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static Nullable`1<SyntaxToken> GetIdentifier(ObjectCreationExpressionSyntax objectCreationExpressionSyntax);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void CheckIfLocationOfPreviousTokenAndOpenTokenAreTheSame(SyntaxNodeAnalysisContext context, SyntaxToken openToken, bool preserveLayout);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1111ClosingParenthesisMustBeOnLineOfLastParameter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledMethodSyntaxKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1111ClosingParenthesisMustBeOnLineOfLastParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void CheckIfLocationOfLastArgumentOrParameterAndCloseTokenAreTheSame(SyntaxNodeAnalysisContext context, CSharpSyntaxNode parameterOrArgument, SyntaxToken closeToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1112ClosingParenthesisMustBeOnLineOfOpeningParenthesis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleParameterList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterListSyntax);
    private static void CheckIfLocationOfOpenAndCloseTokensAreTheSame(SyntaxNodeAnalysisContext context, SyntaxToken openToken, SyntaxToken closeToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1113CommaMustBeOnSameLineAsPreviousParameter : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1113CommaMustBeOnSameLineAsPreviousParameter();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentListSyntax(SyntaxNodeAnalysisContext context, BaseArgumentListSyntax argumentList);
    private static void HandleBaseParameterListSyntax(SyntaxNodeAnalysisContext context, BaseParameterListSyntax parameterList);
    private static void CheckIfCommasAreAtTheSameLineAsThePreviousParameter(SyntaxNodeAnalysisContext context, SyntaxNodeOrTokenList nodeOrTokenList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1114ParameterListMustFollowDeclaration : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1114ParameterListMustFollowDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRankSpecifiers(SyntaxNodeAnalysisContext context, ArrayCreationExpressionSyntax arrayCreation);
    private static void AnalyzeAttributeList(SyntaxNodeAnalysisContext context, AttributeListSyntax attributesList);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax argumentListSyntax);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, AttributeArgumentListSyntax argumentListSyntax);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentListSyntax);
    private static void AnalyzeBracketParametersList(SyntaxNodeAnalysisContext context, BracketedParameterListSyntax parameterListSyntax);
    private static void AnalyzeParametersList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterListSyntax);
    private static bool IsValidTrivia(SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1115ParameterMustFollowComma : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitElementAccessAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1115ParameterMustFollowComma();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleImplicitElementAccess(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSyntaxList(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<TNode> syntaxList);
    private static bool IsValidTrivia(SyntaxTriviaList triviaList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1116SplitParametersMustStartOnLineAfterDeclaration : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitElementAccessAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1116SplitParametersMustStartOnLineAfterDeclaration();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitElementAccess(SyntaxNodeAnalysisContext context);
    private static void HandleArgumentListSyntax(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentList);
    private static void HandleParameterListSyntax(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void HandleBracketedArgumentListSyntax(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax bracketedArgumentList);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken openParenOrBracketToken, SyntaxNode firstParameter, SyntaxNode secondParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1117ParametersMustBeOnSameLineOrSeparateLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> BaseMethodDeclarationKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> LocalFunctionStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorInitializerAction;
    private static Action`1<SyntaxNodeAnalysisContext> DelegateDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> IndexerDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementAccessExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ElementBindingExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1117ParametersMustBeOnSameLineOrSeparateLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAttribute(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context);
    private static void HandleElementBindingExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArgumentListSyntax(SyntaxNodeAnalysisContext context, ArgumentListSyntax argumentList);
    private static void HandleParameterListSyntax(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList);
    private static void HandleBracketedArgumentListSyntax(SyntaxNodeAnalysisContext context, BracketedArgumentListSyntax bracketedArgumentList);
    private static void Analyze(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<ParameterSyntax> parameters);
    private static void Analyze(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1118ParameterMustNotSpanMultipleLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    private static SyntaxKind[] ArgumentExceptionSyntaxKinds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1118ParameterMustNotSpanMultipleLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentList(SyntaxNodeAnalysisContext context);
    private static bool CheckIfArgumentIsMultiline(CSharpSyntaxNode argument);
    private static bool IsArgumentOnExceptionList(ExpressionSyntax argumentExpresson);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1120CommentsMustContainText : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1120CommentsMustContainText();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleMultiLineComment(SyntaxTreeAnalysisContext context, SyntaxTrivia multiLineComment);
    private static void HandleSingleLineComment(SyntaxTreeAnalysisContext context, SyntaxTrivia singleLineComment);
    private static bool IsNullOrWhiteSpace(string value, int startIndex);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1121UseBuiltInTypeAlias : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1121UseBuiltInTypeAlias();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1122UseStringEmptyForEmptyStrings : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> StringLiteralExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1122UseStringEmptyForEmptyStrings();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static bool HasToBeConstant(LiteralExpressionSyntax literalExpression);
    private static ExpressionSyntax FindOutermostExpression(ExpressionSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1123DoNotPlaceRegionsWithinElements : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> RegionDirectiveTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1123DoNotPlaceRegionsWithinElements();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    internal static bool IsCompletelyContainedInBody(RegionDirectiveTriviaSyntax regionSyntax);
    private static void HandleRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1124DoNotUseRegions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> RegionDirectiveTriviaAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1124DoNotUseRegions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoCodeFixAttribute("Provided by Visual Studio")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1125UseShorthandForNullableTypes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> GenericNameAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1125UseShorthandForNullableTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleGenericName(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[NoDiagnosticAttribute("Roslyn provides the ability to create well-defined rules for specific use cases, removing the need for this vaguely-worded diagnostic.")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1126PrefixCallsCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1126PrefixCallsCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [ExcludeFromCodeCoverageAttribute]
public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1127GenericTypeConstraintsMustBeOnOwnLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterConstraintClauseAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1127GenericTypeConstraintsMustBeOnOwnLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleTypeParameterConstraintClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1128ConstructorInitializerMustBeOnOwnLine : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1128ConstructorInitializerMustBeOnOwnLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ConstructorDeclarationSyntax constructor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1129DoNotUseDefaultValueTypeConstructor : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1129DoNotUseDefaultValueTypeConstructor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static bool IsReferenceTypeParameter(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1130UseLambdaSyntax : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static ParameterListSyntax EmptyParameterList;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1130UseLambdaSyntax();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    internal static ParameterListSyntax GetDelegateParameterList(ISymbol symbol, int argumentIndex);
    private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool HandleMethodInvocation(SemanticModel semanticModel, AnonymousMethodExpressionSyntax anonymousMethod, ArgumentSyntax argumentSyntax);
    private static ImmutableArray`1<ParameterSyntax> GetSyntaxParametersFromSymbolParameters(ImmutableArray`1<IParameterSymbol> symbolParameters);
    private static ParameterSyntax GetParameterSyntaxFromParameterSymbol(IParameterSymbol symbolParameter);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1131UseReadableConditions : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static ImmutableArray`1<SyntaxKind> HandledBinaryExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1131UseReadableConditions();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsLiteral(ExpressionSyntax expression, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1132DoNotCombineFields : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> BaseFieldDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1132DoNotCombineFields();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleBaseFieldDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1133DoNotCombineAttributes : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAttributeListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1133DoNotCombineAttributes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1134AttributesMustNotShareLine : DiagnosticAnalyzer {
    public static string FixWithNewLineBeforeKey;
    public static string FixWithNewLineAfterKey;
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleAttributeListAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1134AttributesMustNotShareLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1135UsingDirectivesMustBeQualified : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormatNamespace;
    private static LocalizableString MessageFormatType;
    private static LocalizableString Description;
    private static string HelpLink;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNamespace { get; }
    public static DiagnosticDescriptor DescriptorType { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1135UsingDirectivesMustBeQualified();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNamespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleUsingDeclaration(SyntaxNodeAnalysisContext context);
    private static void CheckUsingDeclaration(SyntaxNodeAnalysisContext context, UsingDirectiveSyntax usingDirective);
    private static string UsingDirectiveSyntaxToCanonicalString(UsingDirectiveSyntax usingDirective);
    private static bool AppendCanonicalString(StringBuilder builder, TypeSyntax type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1136EnumValuesShouldBeOnSeparateLines : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> HandleEnumDeclarationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1136EnumValuesShouldBeOnSeparateLines();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1137ElementsShouldHaveTheSameIndentation : DiagnosticAnalyzer {
    public static string ExpectedIndentationKey;
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> CompilationUnitAction;
    private static Action`1<SyntaxNodeAnalysisContext> NamespaceDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> EnumDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> MethodDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> AccessorListAction;
    private static Action`1<SyntaxNodeAnalysisContext> VariableDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseParameterListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BaseArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeListAction;
    private static Action`1<SyntaxNodeAnalysisContext> AttributeArgumentListAction;
    private static Action`1<SyntaxNodeAnalysisContext> BlockAction;
    private static Action`1<SyntaxNodeAnalysisContext> SwitchStatementAction;
    private static Action`1<SyntaxNodeAnalysisContext> InitializerExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AnonymousObjectCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> TupleTypeAction;
    private static Action`1<SyntaxNodeAnalysisContext> TupleExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1137ElementsShouldHaveTheSameIndentation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void HandleNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleAccessorList(SyntaxNodeAnalysisContext context);
    private static void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleTypeParameterList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseParameterList(SyntaxNodeAnalysisContext context);
    private static void HandleBaseArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeList(SyntaxNodeAnalysisContext context);
    private static void HandleAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void HandleBlock(SyntaxNodeAnalysisContext context);
    private static void HandleSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void HandleInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleTupleType(SyntaxNodeAnalysisContext context);
    private static void HandleTupleExpression(SyntaxNodeAnalysisContext context);
    private static void AddMembersAndAttributes(Builder<SyntaxNode> elements, SeparatedSyntaxList`1<T> members);
    private static void AddMembersAndAttributes(Builder<SyntaxNode> elements, SyntaxList`1<T> members);
    private static void AddMemberAndAttributes(Builder<SyntaxNode> elements, SyntaxNode member);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SyntaxList`1<T> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<T> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, SeparatedSyntaxListWrapper`1<T> elements);
    private static void CheckBlocks(SyntaxNodeAnalysisContext context, ImmutableList`1<BlockSyntax> elements);
    private static void CheckElements(SyntaxNodeAnalysisContext context, ImmutableList`1<T> elements);
    private static ImmutableList`1<T> CleanupElementsList(ImmutableList`1<T> elements);
    private static SyntaxToken GetFirstTokenForAnalysis(SyntaxNode node);
    private static void CheckBraces(SyntaxNodeAnalysisContext context, SyntaxToken openBraceToken, SyntaxToken closeBraceToken);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxToken token, SyntaxTrivia tokenLeadingTrivia, string indentation, string expectedIndentation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SA1139UseLiteralSuffixNotationInsteadOfCasting : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    private static Action`1<SyntaxNodeAnalysisContext> CastExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1139UseLiteralSuffixNotationInsteadOfCasting();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
    private static void HandleCastExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.ReadabilityRules.SX1101DoNotPrefixLocalMembersWithThis : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ThisExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SX1101DoNotPrefixLocalMembersWithThis();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleThisExpression(SyntaxNodeAnalysisContext context);
}
internal class StyleCop.Analyzers.Settings.ObjectModel.DocumentationSettings : object {
    internal static string DefaultCompanyName;
    internal static string DefaultCopyrightText;
    internal static string DefaultDocumentationCulture;
    internal static ImmutableArray`1<string> DefaultExcludeFromPunctuationCheck;
    private string companyName;
    private string copyrightText;
    private string headerDecoration;
    private Builder<string, string> variables;
    private bool xmlHeader;
    private bool documentExposedElements;
    private bool documentInternalElements;
    private bool documentPrivateElements;
    private bool documentInterfaces;
    private bool documentPrivateFields;
    private FileNamingConvention fileNamingConvention;
    private string documentationCulture;
    private ImmutableArray`1<string> excludeFromPunctuationCheck;
    private string copyrightTextCache;
    public string CompanyName { get; }
    public string HeaderDecoration { get; }
    public ImmutableDictionary`2<string, string> Variables { get; }
    public bool XmlHeader { get; }
    public bool DocumentExposedElements { get; }
    public bool DocumentInternalElements { get; }
    public bool DocumentPrivateElements { get; }
    public bool DocumentInterfaces { get; }
    public bool DocumentPrivateFields { get; }
    public FileNamingConvention FileNamingConvention { get; }
    public string DocumentationCulture { get; }
    public ImmutableArray`1<string> ExcludeFromPunctuationCheck { get; }
    protected internal DocumentationSettings(JsonObject documentationSettingsObject);
    private static DocumentationSettings();
    public string get_CompanyName();
    public string get_HeaderDecoration();
    public ImmutableDictionary`2<string, string> get_Variables();
    public bool get_XmlHeader();
    public bool get_DocumentExposedElements();
    public bool get_DocumentInternalElements();
    public bool get_DocumentPrivateElements();
    public bool get_DocumentInterfaces();
    public bool get_DocumentPrivateFields();
    public FileNamingConvention get_FileNamingConvention();
    public string get_DocumentationCulture();
    public ImmutableArray`1<string> get_ExcludeFromPunctuationCheck();
    public string GetCopyrightText(string fileName);
    private KeyValuePair`2<string, bool> BuildCopyrightText(string fileName);
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.FileNamingConvention : Enum {
    public int value__;
    public static FileNamingConvention StyleCop;
    public static FileNamingConvention Metadata;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.IndentationSettings : object {
    private int indentationSize;
    private int tabSize;
    private bool useTabs;
    public int IndentationSize { get; }
    public int TabSize { get; }
    public bool UseTabs { get; }
    protected internal IndentationSettings(JsonObject indentationSettingsObject);
    public int get_IndentationSize();
    public int get_TabSize();
    public bool get_UseTabs();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.LayoutSettings : object {
    private OptionSetting newlineAtEndOfFile;
    private bool allowConsecutiveUsings;
    public OptionSetting NewlineAtEndOfFile { get; }
    public bool AllowConsecutiveUsings { get; }
    protected internal LayoutSettings(JsonObject layoutSettingsObject);
    public OptionSetting get_NewlineAtEndOfFile();
    public bool get_AllowConsecutiveUsings();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.MaintainabilitySettings : object {
    private static ImmutableArray`1<TopLevelType> DefaultTopLevelTypes;
    private Builder<TopLevelType> topLevelTypes;
    public ImmutableArray`1<TopLevelType> TopLevelTypes { get; }
    protected internal MaintainabilitySettings(JsonObject maintainabilitySettingsObject);
    private static MaintainabilitySettings();
    public ImmutableArray`1<TopLevelType> get_TopLevelTypes();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.NamingSettings : object {
    private bool allowCommonHungarianPrefixes;
    private Builder<string> allowedHungarianPrefixes;
    public bool AllowCommonHungarianPrefixes { get; }
    public ImmutableArray`1<string> AllowedHungarianPrefixes { get; }
    protected internal NamingSettings(JsonObject namingSettingsObject);
    public bool get_AllowCommonHungarianPrefixes();
    public ImmutableArray`1<string> get_AllowedHungarianPrefixes();
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.OptionSetting : Enum {
    public int value__;
    public static OptionSetting Allow;
    public static OptionSetting Require;
    public static OptionSetting Omit;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.OrderingSettings : object {
    private static ImmutableArray`1<OrderingTrait> DefaultElementOrder;
    private Builder<OrderingTrait> elementOrder;
    private bool systemUsingDirectivesFirst;
    private UsingDirectivesPlacement usingDirectivesPlacement;
    private OptionSetting blankLinesBetweenUsingGroups;
    public ImmutableArray`1<OrderingTrait> ElementOrder { get; }
    public bool SystemUsingDirectivesFirst { get; }
    public UsingDirectivesPlacement UsingDirectivesPlacement { get; }
    public OptionSetting BlankLinesBetweenUsingGroups { get; }
    protected internal OrderingSettings(JsonObject orderingSettingsObject);
    private static OrderingSettings();
    public ImmutableArray`1<OrderingTrait> get_ElementOrder();
    public bool get_SystemUsingDirectivesFirst();
    public UsingDirectivesPlacement get_UsingDirectivesPlacement();
    public OptionSetting get_BlankLinesBetweenUsingGroups();
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.OrderingTrait : Enum {
    public int value__;
    public static OrderingTrait Kind;
    public static OrderingTrait Accessibility;
    public static OrderingTrait Constant;
    public static OrderingTrait Static;
    public static OrderingTrait Readonly;
}
internal class StyleCop.Analyzers.Settings.ObjectModel.ReadabilitySettings : object {
    private bool allowBuiltInTypeAliases;
    public bool AllowBuiltInTypeAliases { get; }
    protected internal ReadabilitySettings(JsonObject readabilitySettingsObject);
    public bool get_AllowBuiltInTypeAliases();
}
internal class StyleCop.Analyzers.Settings.ObjectModel.SpacingSettings : object {
    protected internal SpacingSettings(JsonObject spacingSettingsObject);
}
internal class StyleCop.Analyzers.Settings.ObjectModel.StyleCopSettings : object {
    private IndentationSettings indentation;
    private SpacingSettings spacingRules;
    private ReadabilitySettings readabilityRules;
    private OrderingSettings orderingRules;
    private NamingSettings namingRules;
    private MaintainabilitySettings maintainabilityRules;
    private LayoutSettings layoutRules;
    private DocumentationSettings documentationRules;
    public IndentationSettings Indentation { get; }
    public SpacingSettings SpacingRules { get; }
    public ReadabilitySettings ReadabilityRules { get; }
    public OrderingSettings OrderingRules { get; }
    public NamingSettings NamingRules { get; }
    public MaintainabilitySettings MaintainabilityRules { get; }
    public LayoutSettings LayoutRules { get; }
    public DocumentationSettings DocumentationRules { get; }
    protected internal StyleCopSettings(JsonObject settingsObject);
    public IndentationSettings get_Indentation();
    public SpacingSettings get_SpacingRules();
    public ReadabilitySettings get_ReadabilityRules();
    public OrderingSettings get_OrderingRules();
    public NamingSettings get_NamingRules();
    public MaintainabilitySettings get_MaintainabilityRules();
    public LayoutSettings get_LayoutRules();
    public DocumentationSettings get_DocumentationRules();
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.TopLevelType : Enum {
    public int value__;
    public static TopLevelType Class;
    public static TopLevelType Interface;
    public static TopLevelType Struct;
    public static TopLevelType Delegate;
    public static TopLevelType Enum;
}
internal enum StyleCop.Analyzers.Settings.ObjectModel.UsingDirectivesPlacement : Enum {
    public int value__;
    public static UsingDirectivesPlacement InsideNamespace;
    public static UsingDirectivesPlacement OutsideNamespace;
    public static UsingDirectivesPlacement Preserve;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.Settings.SettingsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SettingsFileCodeFix { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SettingsFileCodeFix();
}
[ExtensionAttribute]
internal static class StyleCop.Analyzers.SettingsHelper : object {
    internal static string SettingsFileName;
    internal static string AltSettingsFileName;
    private static SourceTextValueProvider`1<StyleCopSettings> SettingsValueProvider;
    private static SettingsHelper();
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(SyntaxTreeAnalysisContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(AnalyzerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(AnalyzerOptions options, DeserializationFailureBehavior failureBehavior, CancellationToken cancellationToken);
    internal static bool IsStyleCopSettingsFile(string path);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(AnalysisContext context, AnalyzerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(AnalysisContext context, AnalyzerOptions options, DeserializationFailureBehavior failureBehavior, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(CompilationStartAnalysisContext context, AnalyzerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static StyleCopSettings GetStyleCopSettings(CompilationStartAnalysisContext context, AnalyzerOptions options, DeserializationFailureBehavior failureBehavior, CancellationToken cancellationToken);
    private static StyleCopSettings GetStyleCopSettings(string path, SourceText text, DeserializationFailureBehavior failureBehavior);
    [ExtensionAttribute]
private static SourceText TryGetStyleCopSettingsText(AnalyzerOptions options, CancellationToken cancellationToken, String& settingsFilePath);
    private static StyleCopSettings GetStyleCopSettings(ImmutableArray`1<AdditionalText> additionalFiles, DeserializationFailureBehavior failureBehavior, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1000KeywordsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    private static Action`1<SyntaxNodeAnalysisContext> InvocationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> IdentifierNameAction;
    private static ReportDiagnosticCallback`1<SyntaxTreeAnalysisContext> ReportSyntaxTreeDiagnostic;
    private static ReportDiagnosticCallback`1<SyntaxNodeAnalysisContext> ReportSyntaxNodeDiagnostic;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1000KeywordsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleIdentifierName(SyntaxNodeAnalysisContext context);
    private static void HandleRequiredSpaceToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleRequiredSpaceToken(SyntaxNodeAnalysisContext& context, SyntaxToken token);
    private static void HandleRequiredSpaceToken(ReportDiagnosticCallback`1<TContext> reportDiagnostic, TContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(SyntaxNodeAnalysisContext& context, SyntaxToken token);
    private static void HandleDisallowedSpaceToken(ReportDiagnosticCallback`1<TContext> reportDiagnostic, TContext& context, SyntaxToken token);
    private static void HandleNewOrStackAllocKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleReturnKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
    private static void HandleThrowKeywordToken(SyntaxTreeAnalysisContext& context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1001CommasMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1001CommasMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCommaToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1002SemicolonsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1002SemicolonsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleSemicolonToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1003SymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string CodeFixAction;
    internal static string InsertBeforeTag;
    internal static string RemoveBeforeTag;
    internal static string InsertAfterTag;
    internal static string RemoveAfterTag;
    internal static string RemoveEndOfLineTag;
    internal static string RemoveEndOfLineWithTrailingSpaceTag;
    private static string Title;
    private static string MessageFormatNotFollowedByComment;
    private static string MessageFormatPrecededByWhitespace;
    private static string MessageFormatNotPrecededByWhitespace;
    private static string MessageFormatFollowedByWhitespace;
    private static string MessageFormatNotFollowedByWhitespace;
    private static string MessageFormatNotAtEndOfLine;
    private static string Description;
    private static string HelpLink;
    private static ImmutableArray`1<SyntaxKind> BinaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> PrefixUnaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> PostfixUnaryExpressionKinds;
    private static ImmutableArray`1<SyntaxKind> AssignmentExpressionKinds;
    private static Action`1<SyntaxNodeAnalysisContext> ConstructorDeclarationAction;
    private static Action`1<SyntaxNodeAnalysisContext> ConditionalExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> TypeParameterConstraintClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> BinaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> PrefixUnaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> PostfixUnaryExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> AssignmentExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> CastExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> EqualsValueClauseAction;
    private static Action`1<SyntaxNodeAnalysisContext> LambdaExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ArrowExpressionClauseAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowedByComment>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorPrecededByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotPrecededByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorFollowedByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowedByWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotAtEndOfLine>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNotFollowedByComment { get; }
    public static DiagnosticDescriptor DescriptorPrecededByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotPrecededByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorFollowedByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotFollowedByWhitespace { get; }
    public static DiagnosticDescriptor DescriptorNotAtEndOfLine { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1003SymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowedByComment();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorPrecededByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotPrecededByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorFollowedByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowedByWhitespace();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotAtEndOfLine();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void HandleConditionalExpression(SyntaxNodeAnalysisContext context);
    private static void HandleTypeParameterConstraintClause(SyntaxNodeAnalysisContext context);
    private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandlePrefixUnaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandlePostfixUnaryExpression(SyntaxNodeAnalysisContext context);
    private static void HandleAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void HandleCastExpression(SyntaxNodeAnalysisContext context);
    private static void HandleEqualsValueClause(SyntaxNodeAnalysisContext context);
    private static void HandleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void HandleArrowExpressionClause(SyntaxNodeAnalysisContext context);
    private static void CheckToken(SyntaxNodeAnalysisContext context, SyntaxToken token, bool withLeadingWhitespace, bool allowAtEndOfLine, bool withTrailingWhitespace, string tokenText);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1004DocumentationLinesMustBeginWithSingleSpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1004DocumentationLinesMustBeginWithSingleSpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleDocumentationCommentExteriorTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1005SingleLineCommentsMustBeginWithSingleSpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1005SingleLineCommentsMustBeginWithSingleSpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleSingleLineCommentTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia, bool isFirstSingleLineTrivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1006PreprocessorKeywordsMustNotBePrecededBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1006PreprocessorKeywordsMustNotBePrecededBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleHashToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1007OperatorKeywordMustBeFollowedBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1007OperatorKeywordMustBeFollowedBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleRequiredSpaceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1008OpeningParenthesisMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string Description;
    private static string HelpLink;
    private static string MessageNotPreceded;
    private static string MessagePreceded;
    private static string MessageNotFollowed;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotPreceded>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorPreceded>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <DescriptorNotFollowed>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static DiagnosticDescriptor DescriptorNotPreceded { get; }
    public static DiagnosticDescriptor DescriptorPreceded { get; }
    public static DiagnosticDescriptor DescriptorNotFollowed { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1008OpeningParenthesisMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotPreceded();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorPreceded();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_DescriptorNotFollowed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenParenToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1009ClosingParenthesisMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1009ClosingParenthesisMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseParenToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1010OpeningSquareBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1010OpeningSquareBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static bool IsPartOfIndexInitializer(SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1011ClosingSquareBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1011ClosingSquareBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1012OpeningBracesMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1012OpeningBracesMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBraceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1013ClosingBracesMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1013ClosingBracesMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBraceToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1014OpeningGenericBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1014OpeningGenericBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleLessThanToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1015ClosingGenericBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1015ClosingGenericBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleGreaterThanToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1016OpeningAttributeBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1016OpeningAttributeBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleOpenBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1017ClosingAttributeBracketsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1017ClosingAttributeBracketsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleCloseBracketToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1018NullableTypeSymbolsMustNotBePrecededBySpace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> NullableTypeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1018NullableTypeSymbolsMustNotBePrecededBySpace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleNullableType(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1019MemberAccessSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1019MemberAccessSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleDotToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static void HandleQuestionToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
    private static void HandleMemberAccessSymbol(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1020IncrementDecrementSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleIncrementDecrementToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1021NegativeSignsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1021NegativeSignsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleMinusToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1022PositiveSignsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1022PositiveSignsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandlePlusToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1023DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleAsteriskToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1024ColonsMustBeSpacedCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string Title;
    private static string MessageFormat;
    private static string Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1024ColonsMustBeSpacedCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleColonToken(SyntaxTreeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1025CodeMustNotContainMultipleWhitespaceInARow : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1025CodeMustNotContainMultipleWhitespaceInARow();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static void HandleWhitespaceTrivia(SyntaxTreeAnalysisContext context, SyntaxTrivia trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitArrayCreationExpressionAction;
    private static Action`1<SyntaxNodeAnalysisContext> ImplicitStackAllocArrayCreationExpressionAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1026CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleImplicitArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void HandleImplicitStackAllocArrayCreationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1027UseTabsCorrectly : DiagnosticAnalyzer {
    public static string DiagnosticId;
    internal static string BehaviorKey;
    internal static string ConvertToTabsBehavior;
    internal static string ConvertToSpacesBehavior;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`2<SyntaxTreeAnalysisContext, StyleCopSettings> SyntaxTreeAction;
    private static ImmutableDictionary`2<string, string> ConvertToTabsProperties;
    private static ImmutableDictionary`2<string, string> ConvertToSpacesProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1027UseTabsCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context, StyleCopSettings settings);
    private static void ReportIncorrectTabUsage(SyntaxTreeAnalysisContext context, IndentationSettings indentationSettings, ImmutableArray`1<TextSpan> excludedSpans);
    private static bool LocateExcludedSpans(SyntaxNode root, ImmutableArray`1& excludedSpans);
    private static void ReduceTextSpans(Builder<TextSpan> sortedTextSpans);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpacingRules.SA1028CodeMustNotContainTrailingWhitespace : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static string HelpLink;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<SyntaxTreeAnalysisContext> SyntaxTreeAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA1028CodeMustNotContainTrailingWhitespace();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleSyntaxTree(SyntaxTreeAnalysisContext context);
    private static TextSpan FindTrailingWhitespace(SourceText text, TextSpan within);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.SpacingRules.SpacingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SA1003CodeFix { get; }
    internal static string SA1004CodeFix { get; }
    internal static string SA1004Description { get; }
    internal static string SA1004MessageFormat { get; }
    internal static string SA1004Title { get; }
    internal static string SA1005CodeFix { get; }
    internal static string SA1005Description { get; }
    internal static string SA1005MessageFormat { get; }
    internal static string SA1005Title { get; }
    internal static string SA1006Description { get; }
    internal static string SA1006MessageFormat { get; }
    internal static string SA1006Title { get; }
    internal static string SA1007Description { get; }
    internal static string SA1007MessageFormat { get; }
    internal static string SA1007Title { get; }
    internal static string SA1008CodeFix { get; }
    internal static string SA1016Description { get; }
    internal static string SA1016MessageFormat { get; }
    internal static string SA1016Title { get; }
    internal static string SA1017Description { get; }
    internal static string SA1017MessageFormat { get; }
    internal static string SA1017Title { get; }
    internal static string SA1018CodeFix { get; }
    internal static string SA1018Description { get; }
    internal static string SA1018MessageFormat { get; }
    internal static string SA1018Title { get; }
    internal static string SA1025CodeFix { get; }
    internal static string SA1025Description { get; }
    internal static string SA1025MessageFormat { get; }
    internal static string SA1025Title { get; }
    internal static string SA1026Description { get; }
    internal static string SA1026MessageFormat { get; }
    internal static string SA1026Title { get; }
    internal static string SA1027CodeFix { get; }
    internal static string SA1027Description { get; }
    internal static string SA1027MessageFormat { get; }
    internal static string SA1027Title { get; }
    internal static string SA1028CodeFix { get; }
    internal static string SA1028Description { get; }
    internal static string SA1028MessageFormat { get; }
    internal static string SA1028Title { get; }
    internal static string TokenSpacingCodeFix { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SA1003CodeFix();
    internal static string get_SA1004CodeFix();
    internal static string get_SA1004Description();
    internal static string get_SA1004MessageFormat();
    internal static string get_SA1004Title();
    internal static string get_SA1005CodeFix();
    internal static string get_SA1005Description();
    internal static string get_SA1005MessageFormat();
    internal static string get_SA1005Title();
    internal static string get_SA1006Description();
    internal static string get_SA1006MessageFormat();
    internal static string get_SA1006Title();
    internal static string get_SA1007Description();
    internal static string get_SA1007MessageFormat();
    internal static string get_SA1007Title();
    internal static string get_SA1008CodeFix();
    internal static string get_SA1016Description();
    internal static string get_SA1016MessageFormat();
    internal static string get_SA1016Title();
    internal static string get_SA1017Description();
    internal static string get_SA1017MessageFormat();
    internal static string get_SA1017Title();
    internal static string get_SA1018CodeFix();
    internal static string get_SA1018Description();
    internal static string get_SA1018MessageFormat();
    internal static string get_SA1018Title();
    internal static string get_SA1025CodeFix();
    internal static string get_SA1025Description();
    internal static string get_SA1025MessageFormat();
    internal static string get_SA1025Title();
    internal static string get_SA1026Description();
    internal static string get_SA1026MessageFormat();
    internal static string get_SA1026Title();
    internal static string get_SA1027CodeFix();
    internal static string get_SA1027Description();
    internal static string get_SA1027MessageFormat();
    internal static string get_SA1027Title();
    internal static string get_SA1028CodeFix();
    internal static string get_SA1028Description();
    internal static string get_SA1028MessageFormat();
    internal static string get_SA1028Title();
    internal static string get_TokenSpacingCodeFix();
}
internal static class StyleCop.Analyzers.SpacingRules.TokenSpacingProperties : object {
    internal static string LocationKey;
    internal static string ActionKey;
    internal static string LayoutKey;
    internal static string LocationPreceding;
    internal static string LocationFollowing;
    internal static string ActionInsert;
    internal static string ActionRemove;
    internal static string ActionRemoveImmediate;
    internal static string LayoutPack;
    internal static string LayoutPreserve;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <InsertPreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemoveImmediatePreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemovePreceding>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemovePrecedingPreserveLayout>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <InsertFollowing>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <RemoveFollowing>k__BackingField;
    internal static ImmutableDictionary`2<string, string> InsertPreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemoveImmediatePreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemovePreceding { get; }
    internal static ImmutableDictionary`2<string, string> RemovePrecedingPreserveLayout { get; }
    internal static ImmutableDictionary`2<string, string> InsertFollowing { get; }
    internal static ImmutableDictionary`2<string, string> RemoveFollowing { get; }
    private static TokenSpacingProperties();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_InsertPreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemoveImmediatePreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemovePreceding();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemovePrecedingPreserveLayout();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_InsertFollowing();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_RemoveFollowing();
}
[NoCodeFixAttribute("The necessary actions for this code fix are not supported by the analysis infrastructure.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpecialRules.SA0001XmlCommentAnalysisDisabled : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationStartAnalysisContext> CompilationStartAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA0001XmlCommentAnalysisDisabled();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilationStart(CompilationStartAnalysisContext context);
}
[NoCodeFixAttribute("No automatic code fix is possible for general JSON syntax errors.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class StyleCop.Analyzers.SpecialRules.SA0002InvalidSettingsFile : DiagnosticAnalyzer {
    public static string DiagnosticId;
    private static string HelpLink;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static LocalizableString Description;
    private static DiagnosticDescriptor Descriptor;
    private static Action`1<CompilationAnalysisContext> CompilationAction;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SA0002InvalidSettingsFile();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void HandleCompilation(CompilationAnalysisContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Analyzers.SpecialRules.SpecialResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SA0001Description { get; }
    internal static string SA0001MessageFormat { get; }
    internal static string SA0001Title { get; }
    internal static string SA0002Description { get; }
    internal static string SA0002MessageFormat { get; }
    internal static string SA0002Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SA0001Description();
    internal static string get_SA0001MessageFormat();
    internal static string get_SA0001Title();
    internal static string get_SA0002Description();
    internal static string get_SA0002MessageFormat();
    internal static string get_SA0002Title();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Linq.SyntaxTriviaListEnumerable : object {
    [ExtensionAttribute]
internal static bool Contains(SyntaxTriviaList list, SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool Any(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
internal static bool All(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
internal static SyntaxTrivia LastOrDefault(SyntaxTriviaList list, SyntaxKind kind);
}
internal class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
}
