public class StyleCop.AdapterConverterHandler`2 : MulticastDelegate {
    public AdapterConverterHandler`2(object object, IntPtr method);
    public virtual TAdapted Invoke(TOriginal item);
    public virtual IAsyncResult BeginInvoke(TOriginal item, AsyncCallback callback, object object);
    public virtual TAdapted EndInvoke(IAsyncResult result);
}
public class StyleCop.AddInPropertyCollection : PropertyCollection {
    private StyleCopAddIn addIn;
    public StyleCopAddIn AddIn { get; }
    internal AddInPropertyCollection(StyleCopAddIn addIn);
    public StyleCopAddIn get_AddIn();
    public virtual PropertyCollection Clone();
}
public class StyleCop.AddSettingsPagesEventArgs : EventArgs {
    private List`1<IPropertyControlPage> pages;
    private string settingsPath;
    public IEnumerable`1<IPropertyControlPage> Pages { get; }
    public string SettingsPath { get; }
    internal AddSettingsPagesEventArgs(string settingsPath);
    public IEnumerable`1<IPropertyControlPage> get_Pages();
    public string get_SettingsPath();
    public void Add(IPropertyControlPage page);
}
public static class StyleCop.AlertDialog : object {
    public static DialogResult Show(StyleCopCore core, Control parent, string message, string title, MessageBoxButtons buttons, MessageBoxIcon icon);
    private static DialogResult DisplayMessageBox(Control parent, string message, string title, MessageBoxButtons buttons, MessageBoxIcon icon);
    private static void SendToOutput(StyleCopCore core, string message, MessageBoxIcon icon);
}
internal class StyleCop.AnalyzersOptions : UserControl {
    private static string AnalyzerNode;
    private static string ParserNode;
    private static string RuleGroupNode;
    private static string RuleNode;
    private Dictionary`2<StyleCopAddIn, ICollection`1<BooleanProperty>> properties;
    private TreeView analyzeTree;
    private IContainer components;
    private TextBox description;
    private TreeView detailsTree;
    private bool dirty;
    private Button findRule;
    private TextBox findRuleId;
    private IButtonControl formAcceptButton;
    private Label label1;
    private Label label2;
    private Label label3;
    private Label label4;
    private ImageList nodeImages;
    private bool refreshing;
    private TableLayoutPanel tableLayoutPanel1;
    private TableLayoutPanel tableLayoutPanel2;
    private PropertyControl tabControl;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    protected virtual void Dispose(bool disposing);
    private static TreeNode FindMatchingRuleGroupNode(TreeNodeCollection nodes, string ruleGroup);
    private static void InsertIntoSortedTree(TreeNodeCollection nodes, TreeNode nodeToInsert);
    private static void SetBoldState(TreeNode item, bool bolded, TreeView tree);
    private void AdjustBoldState();
    private void AnalyzeTreeAfterCheck(object sender, TreeViewEventArgs e);
    private void AnalyzeTreeAfterSelect(object sender, TreeViewEventArgs e);
    private void AnalyzeTreeBeforeCollapse(object sender, TreeViewCancelEventArgs e);
    private void ApplyProperties(StyleCopAddIn addIn);
    private void ApplyRules(StyleCopAddIn addIn, TreeNode parentNode);
    private void CheckAllChildNodes(TreeNode node, bool checked);
    private void DetailsTreeAfterCheck(object sender, TreeViewEventArgs e);
    private void DetailsTreeAfterSelect(object sender, TreeViewEventArgs e);
    private void DetectBoldStateForDetails(TreeNode propertyNode);
    private bool DetectBoldStateForRule(TreeNode ruleNode);
    private void FillAnalyzerRules(SourceAnalyzer analyzer, TreeNode analyzerNode);
    private void FillAnalyzerTree();
    private void FillDetailsTree();
    private void FindRuleClick(object sender, EventArgs e);
    private void FindRuleIdGotFocus(object sender, EventArgs e);
    private void FindRuleIdKeyDown(object sender, KeyEventArgs e);
    private void FindRuleIdLostFocus(object sender, EventArgs e);
    private void InitializeComponent();
    private void InitializePropertyState(StyleCopAddIn addIn, BooleanProperty property);
    private void InitializeRuleCheckedState(Rule rule, TreeNode ruleNode);
    private TreeNode IterateAndFindRule(TreeNodeCollection nodes, string searchText, MatchRuleHandler matchHandler);
    private void SearchForRule(string searchText);
    private TreeNode SearchForRuleByCategories(string searchText);
    private void StoreAddinProperties(StyleCopAddIn addIn);
}
public class StyleCop.BooleanProperty : PropertyValue`1<bool> {
    public BooleanProperty(PropertyDescriptor`1<bool> propertyDescriptor, bool value);
    public BooleanProperty(IPropertyContainer propertyContainer, string propertyName, bool value);
    public virtual PropertyValue Clone();
}
internal class StyleCop.CacheOptions : UserControl {
    private IContainer components;
    private ComboBox cultureComboBox;
    private StringProperty cultureParentProperty;
    private PropertyDescriptor`1<string> culturePropertyDescriptor;
    private bool dirty;
    private CheckBox enableCache;
    private Label label1;
    private Label label2;
    private Label label3;
    private MaskedTextBox maxViolationCountMaskedTextBox;
    private IntProperty maxViolationCountParentProperty;
    private PropertyDescriptor`1<int> maxViolationCountPropertyDescriptor;
    private PropertyControl tabControl;
    private ToolTip toolTip;
    private BooleanProperty writeCacheParentProperty;
    private CheckBox violationsAsErrorsCheckBox;
    private PropertyDescriptor`1<bool> violationsAsErrorsPropertyDescriptor;
    private BooleanProperty violationsAsErrorsParentProperty;
    private TableLayoutPanel tableLayoutPanel1;
    private TableLayoutPanel tableLayoutPanel2;
    private Panel neededToMakeLastRowFill;
    private PropertyDescriptor`1<bool> writeCachePropertyDescriptor;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    public bool ValidatePage();
    protected virtual void Dispose(bool disposing);
    private static IEnumerable`1<CultureInfo> EnumSatelliteLanguages(string baseName);
    private static IEnumerable`1<CultureInfo> GetSatelliteLanguages(string baseName);
    private void CultureComboBoxSelectedIndexChanged(object sender, EventArgs e);
    private void EnableCacheCheckedChanged(object sender, EventArgs e);
    private void InitializeComponent();
    private void MaxViolationCountMaskedTextBoxKeyDown(object sender, KeyEventArgs e);
    private void MaxViolationCountTextBoxTextChanged(object sender, EventArgs e);
    private void SetBoldState();
    private void ViolationsAsErrorsCheckBoxCheckedChanged(object sender, EventArgs e);
}
public abstract class StyleCop.CodeDocument : object {
    private Dictionary`2<string, object> analyzerData;
    private SourceCode sourceCode;
    public ICodeElement DocumentContents { get; }
    public Settings Settings { get; }
    public SourceCode SourceCode { get; }
    internal Dictionary`2<string, object> AnalyzerData { get; }
    protected CodeDocument(SourceCode sourceCode);
    public abstract virtual ICodeElement get_DocumentContents();
    public Settings get_Settings();
    public SourceCode get_SourceCode();
    internal Dictionary`2<string, object> get_AnalyzerData();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class StyleCop.CodeFile : SourceCode {
    private string fileType;
    private string folder;
    private string name;
    private string path;
    public bool Exists { get; }
    public string Folder { get; }
    public string FullPathName { get; }
    public string Name { get; }
    public string Path { get; }
    public DateTime TimeStamp { get; }
    public string Type { get; }
    public CodeFile(string path, CodeProject project, SourceParser parser);
    public CodeFile(string path, CodeProject project, SourceParser parser, IEnumerable`1<Configuration> configurations);
    public virtual bool get_Exists();
    public string get_Folder();
    public string get_FullPathName();
    public virtual string get_Name();
    public virtual string get_Path();
    public virtual DateTime get_TimeStamp();
    public virtual string get_Type();
    public virtual TextReader Read();
}
public class StyleCop.CodeLocation : ValueType {
    public static CodeLocation Empty;
    private CodePoint endPoint;
    private CodePoint startPoint;
    public CodePoint EndPoint { get; }
    public int LineNumber { get; }
    public int LineSpan { get; }
    public CodePoint StartPoint { get; }
    public CodeLocation(int index, int endIndex, int indexOnLine, int endIndexOnLine, int lineNumber, int endLineNumber);
    private static CodeLocation();
    public CodePoint get_EndPoint();
    public int get_LineNumber();
    public int get_LineSpan();
    public CodePoint get_StartPoint();
    public static Nullable`1<CodeLocation> Join(Nullable`1<CodeLocation> location1, Nullable`1<CodeLocation> location2);
    public static CodeLocation Join(CodeLocation location1, Nullable`1<CodeLocation> location2);
    public static CodeLocation Join(CodeLocation location1, CodeLocation location2);
}
public class StyleCop.CodePoint : ValueType {
    private int index;
    private int indexOnLine;
    private int lineNumber;
    public int Index { get; }
    public int IndexOnLine { get; }
    public int LineNumber { get; }
    public CodePoint(int index, int indexOnLine, int lineNumber);
    public int get_Index();
    public int get_IndexOnLine();
    public int get_LineNumber();
    public static CodePoint Join(CodePoint point1, CodePoint point2);
}
public class StyleCop.CodeProject : object {
    private static string DefaultCulture;
    private static int DefaultMaxViolationCount;
    private Configuration configuration;
    private int key;
    private string location;
    private double targetFrameworkVersion;
    private List`1<SourceCode> sourceCodes;
    private CultureInfo culture;
    private Dictionary`2<string, string> deprecatedWords;
    private ICollection`1<string> dictionaryFolders;
    private Nullable`1<int> maxViolationCount;
    private ICollection`1<string> recognizedWords;
    private Settings settings;
    private bool settingsLoaded;
    private Nullable`1<bool> writeCache;
    private Nullable`1<bool> violationsAsErrors;
    public Configuration Configuration { get; }
    public CultureInfo Culture { get; }
    public IDictionary`2<string, string> DeprecatedWords { get; }
    public ICollection`1<string> DictionaryFolders { get; }
    public int Key { get; }
    public string Location { get; }
    public double TargetFrameworkVersion { get; }
    public int MaxViolationCount { get; }
    public ICollection`1<string> RecognizedWords { get; }
    public Settings Settings { get; public set; }
    public bool SettingsLoaded { get; public set; }
    public IList`1<SourceCode> SourceCodeInstances { get; }
    public bool WriteCache { get; }
    public bool ViolationsAsErrors { get; }
    public CodeProject(int key, string location, Configuration configuration, double frameworkVersion);
    public Configuration get_Configuration();
    public virtual CultureInfo get_Culture();
    public virtual IDictionary`2<string, string> get_DeprecatedWords();
    public virtual ICollection`1<string> get_DictionaryFolders();
    public int get_Key();
    public string get_Location();
    public double get_TargetFrameworkVersion();
    public virtual int get_MaxViolationCount();
    public virtual ICollection`1<string> get_RecognizedWords();
    public Settings get_Settings();
    public void set_Settings(Settings value);
    public bool get_SettingsLoaded();
    public void set_SettingsLoaded(bool value);
    public IList`1<SourceCode> get_SourceCodeInstances();
    public virtual bool get_WriteCache();
    public bool get_ViolationsAsErrors();
    internal virtual void AddSourceCode(SourceCode sourceCode);
}
public class StyleCop.CodeReader : object {
    private static int CharacterBlockSize;
    private TextReader code;
    private int bufferLength;
    private Char[] charBuffer;
    private int position;
    public CodeReader(TextReader code);
    public char Peek();
    public char Peek(int index);
    public char PeekNonWhitespace(int index);
    public char ReadNext();
    public Char[] ReadNext(int count);
    public string ReadString(int count);
    private bool LoadBuffer(int count);
}
public class StyleCop.CollectionProperty : PropertyValue {
    private List`1<string> collection;
    public bool Aggregate { get; }
    public int Count { get; }
    public bool HasDefaultValue { get; }
    public bool IsDefault { get; }
    public ICollection`1<string> Values { get; }
    public CollectionProperty(CollectionPropertyDescriptor propertyDescriptor);
    public CollectionProperty(CollectionPropertyDescriptor propertyDescriptor, IEnumerable`1<string> innerCollection);
    public CollectionProperty(IPropertyContainer propertyContainer, string propertyName);
    public CollectionProperty(IPropertyContainer propertyContainer, string propertyName, IEnumerable`1<string> innerCollection);
    public bool get_Aggregate();
    public sealed virtual int get_Count();
    public virtual bool get_HasDefaultValue();
    public virtual bool get_IsDefault();
    public ICollection`1<string> get_Values();
    public sealed virtual void Add(string item);
    public sealed virtual void Clear();
    public virtual PropertyValue Clone();
    public sealed virtual bool Contains(string item);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public virtual bool OverridesProperty(PropertyValue parentProperty);
    public sealed virtual bool Remove(string item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool OverridesPropertyCollection(ICollection`1<string> localValues, ICollection`1<string> parentValues, bool aggregate);
}
public class StyleCop.CollectionPropertyDescriptor : PropertyDescriptor {
    private bool aggregate;
    public bool Aggregate { get; }
    internal CollectionPropertyDescriptor(string propertyName, string friendlyName, string description, bool merge, bool aggregate);
    public bool get_Aggregate();
}
public class StyleCop.Configuration : object {
    private Dictionary`2<string, string> conditionalCompilationDefinitions;
    public ICollection`1<string> Flags { get; }
    public Configuration(String[] conditionalCompilationDefinitions);
    public ICollection`1<string> get_Flags();
    public bool Contains(string definition);
    public string GetValue(string definition);
}
internal class StyleCop.CoreParser : SourceParser {
    public virtual bool ParseFile(SourceCode sourceCode, int passNumber, CodeDocument& document);
}
internal class StyleCop.Countdown : object {
    private static object LockObject;
    private int countdownValue;
    public int CurrentCount { get; }
    public Countdown(int initialCount);
    private static Countdown();
    public int get_CurrentCount();
    public void AddCount(int signalCount);
    public void Signal();
    public void Signal(int signalCount);
    public void Wait();
}
[AttributeUsageAttribute("10464")]
public class StyleCop.Diagnostics.SensitiveDataAttribute : Attribute {
}
[DebuggerStepThroughAttribute]
public class StyleCop.Diagnostics.StyleCopSwitch : Switch {
    [CompilerGeneratedAttribute]
private bool <TraceError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceInOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceSensitiveData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceThreadName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceVerbose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceWarning>k__BackingField;
    public int Level { get; public set; }
    public bool TraceError { get; private set; }
    public bool TraceInOut { get; private set; }
    public bool TraceInfo { get; private set; }
    public bool TraceSensitiveData { get; private set; }
    public bool TraceThreadId { get; private set; }
    public bool TraceThreadName { get; private set; }
    public bool TraceVerbose { get; private set; }
    public bool TraceWarning { get; private set; }
    public StyleCopSwitch(string displayName, string description);
    public StyleCopSwitch(string displayName, string description, TraceTypes level);
    public StyleCopSwitch(string displayName, string description, int level);
    public int get_Level();
    public void set_Level(int value);
    [CompilerGeneratedAttribute]
public bool get_TraceError();
    [CompilerGeneratedAttribute]
private void set_TraceError(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceInOut();
    [CompilerGeneratedAttribute]
private void set_TraceInOut(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceInfo();
    [CompilerGeneratedAttribute]
private void set_TraceInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceSensitiveData();
    [CompilerGeneratedAttribute]
private void set_TraceSensitiveData(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceThreadId();
    [CompilerGeneratedAttribute]
private void set_TraceThreadId(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceThreadName();
    [CompilerGeneratedAttribute]
private void set_TraceThreadName(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceVerbose();
    [CompilerGeneratedAttribute]
private void set_TraceVerbose(bool value);
    [CompilerGeneratedAttribute]
public bool get_TraceWarning();
    [CompilerGeneratedAttribute]
private void set_TraceWarning(bool value);
    protected virtual void OnSwitchSettingChanged();
}
[DebuggerStepThroughAttribute]
public static class StyleCop.Diagnostics.StyleCopTrace : object {
    [CompilerGeneratedAttribute]
private static StyleCopSwitch <Switch>k__BackingField;
    public static StyleCopSwitch Switch { get; private set; }
    private static StyleCopTrace();
    [CompilerGeneratedAttribute]
public static StyleCopSwitch get_Switch();
    [CompilerGeneratedAttribute]
private static void set_Switch(StyleCopSwitch value);
    public static void Error(string message);
    public static void Error(string format, Object[] args);
    public static void Error(Exception exception);
    public static void In(Object[] parameters);
    public static void Info(string message);
    public static void Info(string format, Object[] args);
    public static void Out();
    public static object Out(object returnValue);
    public static T Out(T returnValue);
    public static void Verbose(string message);
    public static void Verbose(string format, Object[] args);
    public static void Warning(string message);
    public static void Warning(Exception exception);
    public static void Warning(string format, Object[] args);
    private static long GetPrivateBytes();
}
[FlagsAttribute]
public enum StyleCop.Diagnostics.TraceTypes : Enum {
    public int value__;
    public static TraceTypes None;
    public static TraceTypes InOut;
    public static TraceTypes Error;
    public static TraceTypes Warning;
    public static TraceTypes Info;
    public static TraceTypes SensitiveData;
    public static TraceTypes IncludeThreadName;
    public static TraceTypes IncludeThreadId;
    public static TraceTypes Verbose;
}
internal class StyleCop.DocumentAnalysisStatus : object {
    private bool complete;
    private CodeDocument document;
    private bool initialized;
    public bool Complete { get; public set; }
    public CodeDocument Document { get; public set; }
    public bool Initialized { get; public set; }
    public bool get_Complete();
    public void set_Complete(bool value);
    public CodeDocument get_Document();
    public void set_Document(CodeDocument value);
    public bool get_Initialized();
    public void set_Initialized(bool value);
}
public class StyleCop.EnumerableAdapter`2 : object {
    private AdapterConverterHandler`2<TOriginal, TAdapted> converter;
    private IEnumerable`1<TOriginal> innerEnumerable;
    public IEnumerable`1<TOriginal> InnerEnumerable { get; }
    public EnumerableAdapter`2(IEnumerable`1<TOriginal> enumerable, AdapterConverterHandler`2<TOriginal, TAdapted> converter);
    public IEnumerable`1<TOriginal> get_InnerEnumerable();
    private sealed virtual override IEnumerator`1<TAdapted> System.Collections.Generic.IEnumerable<TAdapted>.GetEnumerator();
    private TAdapted Convert(TOriginal item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class StyleCop.FileBasedEnvironment : StyleCopEnvironment {
    private Dictionary`2<string, List`1<SourceParser>> fileTypes;
    private string defaultSettingsFilePath;
    public bool SupportsLinkedSettings { get; }
    public bool SupportsResultsCache { get; }
    public virtual bool get_SupportsLinkedSettings();
    public virtual bool get_SupportsResultsCache();
    public virtual void AddParser(SourceParser parser);
    public virtual bool AddSourceCode(CodeProject project, string path, object context);
    public virtual string GetDefaultSettingsPath();
    public virtual string GetParentSettingsPath(string settingsPath);
    public ICollection`1<SourceParser> GetParsersForFileType(string fileType);
    public virtual Settings GetProjectSettings(CodeProject project, bool merge, Exception& exception);
    public virtual Settings GetSettings(string settingsPath, bool merge, Exception& exception);
    public virtual WritableSettings GetWritableSettings(string settingsPath, Exception& exception);
    public virtual XmlDocument LoadResultsCache(string location);
    public virtual void RemoveAnalysisResults(string location);
    public virtual bool SaveAnalysisResults(string location, XmlDocument analysisResults, Exception& exception);
    public virtual void SaveResultsCache(string location, XmlDocument resultsCache);
    public virtual bool SaveSettings(WritableSettings settings, Exception& exception);
    protected virtual CodeFile CreateCodeFile(string path, CodeProject project, SourceParser parser, object context);
    private static string GetResultsCachePath(string location);
    private WritableSettings CreateSettingsDocument(string path, Exception& exception);
    private Settings LoadSettingsDocument(string settingsFilePath, bool readOnly, Exception& exception);
}
internal class StyleCop.GlobalSettingsFileOptions : UserControl {
    private Container components;
    private Button browse;
    private bool dirty;
    private bool disableLinking;
    private Button editLinkedSettingsFile;
    private Button editParentSettingsFile;
    private Label label1;
    private TextBox linkedFilePath;
    private Label locationLabel;
    private RadioButton mergeWithLinkedFile;
    private RadioButton mergeWithParents;
    private RadioButton noMerge;
    private TableLayoutPanel tableLayoutPanel1;
    private PropertyControl tabControl;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    protected virtual void Dispose(bool disposing);
    private static string ConvertBackslashes(string path);
    private void BrowseClick(object sender, EventArgs e);
    private void EditLinkedSettingsFileClicked(object sender, EventArgs e);
    private void EditParentSettings(string settingsFile);
    private void EditParentSettingsFileClicked(object sender, EventArgs e);
    private void EnableDisable();
    private void InitializeComponent();
    private void LinkedFilePathTextChanged(object sender, EventArgs e);
    private void MergeWithLinkedFileCheckedChanged(object sender, EventArgs e);
    private void MergeWithParentsCheckedChanged(object sender, EventArgs e);
    private void NoMergeCheckedChanged(object sender, EventArgs e);
}
public interface StyleCop.ICodeElement {
    public IEnumerable`1<ICodeElement> ChildCodeElements { get; }
    public CodeDocument Document { get; }
    public string FullyQualifiedName { get; }
    public int LineNumber { get; }
    public ICollection`1<Violation> Violations { get; }
    public abstract virtual IEnumerable`1<ICodeElement> get_ChildCodeElements();
    public abstract virtual CodeDocument get_Document();
    public abstract virtual string get_FullyQualifiedName();
    public abstract virtual int get_LineNumber();
    public abstract virtual ICollection`1<Violation> get_Violations();
    public abstract virtual bool AddViolation(Violation violation);
    public abstract virtual void ClearAnalyzerTags();
}
public interface StyleCop.INodeList`1 {
    public Node`1<T> First { get; }
    public Node`1<T> Last { get; }
    public abstract virtual Node`1<T> get_First();
    public abstract virtual Node`1<T> get_Last();
    public abstract virtual IEnumerable`1<T> ForwardIterator();
    public abstract virtual IEnumerable`1<T> ForwardIterator(Node`1<T> start);
    public abstract virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator();
    public abstract virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator(Node`1<T> start);
    public abstract virtual bool OutOfBounds(Node`1<T> node);
    public abstract virtual IEnumerable`1<T> ReverseIterator();
    public abstract virtual IEnumerable`1<T> ReverseIterator(Node`1<T> start);
    public abstract virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator();
    public abstract virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator(Node`1<T> start);
}
public class StyleCop.IntProperty : PropertyValue`1<int> {
    public IntProperty(PropertyDescriptor`1<int> propertyDescriptor, int value);
    public IntProperty(IPropertyContainer propertyContainer, string propertyName, int value);
    public virtual PropertyValue Clone();
}
public interface StyleCop.IPropertyContainer {
    public PropertyDescriptorCollection PropertyDescriptors { get; }
    public abstract virtual PropertyDescriptorCollection get_PropertyDescriptors();
}
internal interface StyleCop.IPropertyControlHost {
    public abstract virtual void Cancel();
    public abstract virtual void Dirty(bool isDirty);
}
public interface StyleCop.IPropertyControlPage {
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public abstract virtual bool get_Dirty();
    public abstract virtual void set_Dirty(bool value);
    public abstract virtual string get_TabName();
    public abstract virtual void Activate(bool activated);
    public abstract virtual bool Apply();
    public abstract virtual void Initialize(PropertyControl propertyControl);
    public abstract virtual void PostApply(bool wasDirty);
    public abstract virtual bool PreApply();
    public abstract virtual void RefreshSettingsOverrideState();
}
public class StyleCop.ItemList`1 : object {
    private MasterList`1<T> masterList;
    private Node`1<T> firstItem;
    private Node`1<T> lastItem;
    public Node`1<T> First { get; protected set; }
    public Node`1<T> Last { get; protected set; }
    public MasterList`1<T> MasterList { get; }
    public ItemList`1(MasterList`1<T> masterList);
    public ItemList`1(MasterList`1<T> masterList, Node`1<T> firstItem, Node`1<T> lastItem);
    public sealed virtual Node`1<T> get_First();
    protected void set_First(Node`1<T> value);
    public sealed virtual Node`1<T> get_Last();
    protected void set_Last(Node`1<T> value);
    public MasterList`1<T> get_MasterList();
    public virtual ItemList`1<T> Clone();
    public sealed virtual IEnumerable`1<T> ForwardIterator();
    public sealed virtual IEnumerable`1<T> ForwardIterator(Node`1<T> start);
    public sealed virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator();
    public sealed virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator(Node`1<T> start);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool OutOfBounds(Node`1<T> node);
    public sealed virtual IEnumerable`1<T> ReverseIterator();
    public sealed virtual IEnumerable`1<T> ReverseIterator(Node`1<T> start);
    public sealed virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator();
    public sealed virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator(Node`1<T> start);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private bool IsAfterLast(Node`1<T> node);
    private bool IsBeforeFirst(Node`1<T> node);
}
public class StyleCop.LegacyEnumeratorAdapter`1 : object {
    private IEnumerator innerEnumerator;
    public IEnumerator InnerEnumerator { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public LegacyEnumeratorAdapter`1(IEnumerator enumerator);
    public IEnumerator get_InnerEnumerator();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class StyleCop.LinkedItemList`1 : object {
    private int count;
    private Node`1<T> head;
    private Node`1<T> tail;
    [CompilerGeneratedAttribute]
private EventHandler NodeIndexesReset;
    public int Count { get; }
    public Node`1<T> First { get; }
    public bool IsReadOnly { get; }
    public Node`1<T> Last { get; }
    internal LinkedItemList`1(ICollection`1<T> items);
    internal LinkedItemList`1(ICollection`1<Node`1<T>> nodes);
    [CompilerGeneratedAttribute]
public void add_NodeIndexesReset(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NodeIndexesReset(EventHandler value);
    public sealed virtual int get_Count();
    public Node`1<T> get_First();
    public sealed virtual bool get_IsReadOnly();
    public Node`1<T> get_Last();
    public sealed virtual void Add(T item);
    public void Add(Node`1<T> node);
    public ICollection`1<Node`1<T>> AddRange(IEnumerable`1<T> items);
    public void AddRange(IEnumerable`1<Node`1<T>> nodes);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public bool Contains(Node`1<T> node);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public IEnumerable`1<T> ForwardIterator();
    public IEnumerable`1<T> ForwardIterator(Node`1<T> start);
    public IEnumerable`1<Node`1<T>> ForwardNodeIterator();
    public IEnumerable`1<Node`1<T>> ForwardNodeIterator(Node`1<T> start);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public Node`1<T> InsertAfter(T item, Node`1<T> nodeToInsertAfter);
    public Node`1<T> InsertBefore(T item, Node`1<T> nodeToInsertBefore);
    public Node`1<T> InsertFirst(T item);
    public Node`1<T> InsertLast(T item);
    public sealed virtual bool Remove(T item);
    public bool Remove(Node`1<T> node);
    public void RemoveRange(Node`1<T> start, Node`1<T> end);
    public Node`1<T> Replace(Node`1<T> node, T newItem);
    public void Replace(Node`1<T> node, Node`1<T> newNode);
    public IEnumerable`1<T> ReverseIterator();
    public IEnumerable`1<T> ReverseIterator(Node`1<T> start);
    public IEnumerable`1<Node`1<T>> ReverseNodeIterator();
    public IEnumerable`1<Node`1<T>> ReverseNodeIterator(Node`1<T> start);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void OnNodeIndexesReset(EventArgs e);
    private Node`1<T> InsertAfter(Node`1<T> node, Node`1<T> nodeToInsertAfter);
    private Node`1<T> InsertBefore(Node`1<T> node, Node`1<T> nodeToInsertBefore);
    private void ResetNodeIndexes();
}
internal static class StyleCop.LinkedItemListEnumerators`1 : object {
}
public class StyleCop.MasterList`1 : object {
    public static MasterList`1<T> Empty;
    private LinkedItemList`1<T> list;
    private bool readOnly;
    [CompilerGeneratedAttribute]
private EventHandler NodeIndexesReset;
    public MasterList`1<T> AsReadOnly { get; }
    public int Count { get; }
    public Node`1<T> First { get; }
    public bool IsReadOnly { get; }
    public Node`1<T> Last { get; }
    internal MasterList`1<T> AsReadWrite { get; }
    internal LinkedItemList`1<T> InnerList { get; }
    public MasterList`1(ICollection`1<T> items);
    private MasterList`1(bool readOnly);
    private MasterList`1(LinkedItemList`1<T> innerList, bool readOnly);
    private static MasterList`1();
    [CompilerGeneratedAttribute]
public void add_NodeIndexesReset(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NodeIndexesReset(EventHandler value);
    public MasterList`1<T> get_AsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Node`1<T> get_First();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual Node`1<T> get_Last();
    internal MasterList`1<T> get_AsReadWrite();
    internal LinkedItemList`1<T> get_InnerList();
    public virtual void Add(T item);
    public virtual void AddRange(IEnumerable`1<T> items);
    public virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerable`1<T> ForwardIterator();
    public sealed virtual IEnumerable`1<T> ForwardIterator(Node`1<T> start);
    public sealed virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator();
    public sealed virtual IEnumerable`1<Node`1<T>> ForwardNodeIterator(Node`1<T> start);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public virtual Node`1<T> InsertAfter(T item, Node`1<T> nodeToInsertAfter);
    public virtual Node`1<T> InsertBefore(T item, Node`1<T> nodeToInsertBefore);
    public virtual Node`1<T> InsertFirst(T item);
    public virtual Node`1<T> InsertLast(T item);
    public sealed virtual bool OutOfBounds(Node`1<T> node);
    public virtual bool Remove(T item);
    public virtual bool Remove(Node`1<T> node);
    public virtual void RemoveRange(Node`1<T> startNode, Node`1<T> endNode);
    public virtual Node`1<T> Replace(Node`1<T> node, T newItem);
    public sealed virtual IEnumerable`1<T> ReverseIterator();
    public sealed virtual IEnumerable`1<T> ReverseIterator(Node`1<T> start);
    public sealed virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator();
    public sealed virtual IEnumerable`1<Node`1<T>> ReverseNodeIterator(Node`1<T> start);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void OnNodeIndexesReset(EventArgs e);
    private void ListNodeIndexesReset(object sender, EventArgs e);
}
public static class StyleCop.NativeMethods : object {
    internal static int GetUserNameEx(EXTENDED_NAME_FORMAT nameFormat, StringBuilder userName, UInt32& userNameSize);
}
public class StyleCop.Node`1 : object {
    private T item;
    private LinkedItemList`1<T> containingList;
    private NodeIndex index;
    private Node`1<T> next;
    private Node`1<T> previous;
    public NodeIndex Index { get; }
    public Node`1<T> Next { get; internal set; }
    public Node`1<T> Previous { get; internal set; }
    public T Value { get; }
    internal LinkedItemList`1<T> ContainingList { get; internal set; }
    internal Node`1(T item);
    public NodeIndex get_Index();
    public Node`1<T> get_Next();
    internal void set_Next(Node`1<T> value);
    public Node`1<T> get_Previous();
    internal void set_Previous(Node`1<T> value);
    public T get_Value();
    internal LinkedItemList`1<T> get_ContainingList();
    internal void set_ContainingList(LinkedItemList`1<T> value);
    public bool NodesInSameList(Node`1<T> node);
    internal bool CreateIndex();
}
public class StyleCop.NodeIndex : ValueType {
    internal static int Spacer;
    private int bigValue;
    private short smallValue;
    public static int Compare(NodeIndex index1, NodeIndex index2);
    public static bool op_Equality(NodeIndex index1, NodeIndex index2);
    public static bool op_GreaterThan(NodeIndex index1, NodeIndex index2);
    public static bool op_GreaterThanOrEqual(NodeIndex index1, NodeIndex index2);
    public static bool op_Inequality(NodeIndex index1, NodeIndex index2);
    public static bool op_LessThan(NodeIndex index1, NodeIndex index2);
    public static bool op_LessThanOrEqual(NodeIndex index1, NodeIndex index2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static bool CreateAfter(NodeIndex before, NodeIndex& index);
    internal static bool CreateBefore(NodeIndex after, NodeIndex& index);
    internal static bool CreateBetween(NodeIndex before, NodeIndex after, NodeIndex& index);
    internal static bool CreateFirst(NodeIndex& index);
    internal void Set(int newBigValue);
    private static bool Create(int previousBigValue, short previousSmallValue, int nextBigValue, short nextSmallValue, NodeIndex& index);
    private static bool CreateBigValue(int previous, int next, Int32& bigValue);
    private static bool CreateSmallValue(short previous, short next, Int16& smallValue);
}
public class StyleCop.ObjectBasedEnvironment : StyleCopEnvironment {
    private Dictionary`2<string, List`1<SourceParser>> fileTypes;
    private ProjectSettingsFactory settingsFactory;
    private SourceCodeFactory sourceCodeFactory;
    private string defaultSettingsFilePath;
    public bool SupportsLinkedSettings { get; }
    public bool SupportsResultsCache { get; }
    public ObjectBasedEnvironment(SourceCodeFactory sourceCodeFactory, ProjectSettingsFactory settingsFactory);
    public virtual bool get_SupportsLinkedSettings();
    public virtual bool get_SupportsResultsCache();
    public virtual void AddParser(SourceParser parser);
    public virtual bool AddSourceCode(CodeProject project, string path, object context);
    public virtual string GetDefaultSettingsPath();
    public virtual string GetParentSettingsPath(string settingsPath);
    public ICollection`1<SourceParser> GetParsersForFileType(string fileType);
    public virtual Settings GetProjectSettings(CodeProject project, bool merge, Exception& exception);
    public virtual Settings GetSettings(string settingsPath, bool merge, Exception& exception);
    public virtual WritableSettings GetWritableSettings(string settingsPath, Exception& exception);
    public virtual XmlDocument LoadResultsCache(string location);
    public virtual void RemoveAnalysisResults(string location);
    public virtual bool SaveAnalysisResults(string location, XmlDocument analysisResults, Exception& exception);
    public virtual void SaveResultsCache(string location, XmlDocument resultsCache);
    public virtual bool SaveSettings(WritableSettings settings, Exception& exception);
    private Settings LoadSettingsDocument(string settingsFilePath, bool readOnly, Exception& exception);
}
public class StyleCop.OutputEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private MessageImportance <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public MessageImportance Importance { get; private set; }
    public string Output { get; private set; }
    public OutputEventArgs(string text);
    public OutputEventArgs(string text, MessageImportance importance);
    [CompilerGeneratedAttribute]
public MessageImportance get_Importance();
    [CompilerGeneratedAttribute]
private void set_Importance(MessageImportance value);
    [CompilerGeneratedAttribute]
public string get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(string value);
}
public class StyleCop.Param : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool test, string parameterName, string exceptionMessage);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThan(int number, int minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThan(long number, long minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThan(short number, short minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThan(double number, double minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThan(float number, float minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualTo(int number, int minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualTo(long number, long minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualTo(short number, short minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualTo(double number, double minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualTo(float number, float minimum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualToZero(int number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualToZero(long number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualToZero(short number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualToZero(double number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanOrEqualToZero(float number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanZero(int number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanZero(long number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanZero(short number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanZero(double number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertGreaterThanZero(float number, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThan(int number, int maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThan(long number, long maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThan(short number, short maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThan(double number, double maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThan(float number, float maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThanOrEqualTo(int number, int maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThanOrEqualTo(long number, long maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThanOrEqualTo(short number, short maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThanOrEqualTo(double number, double maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertLessThanOrEqualTo(float number, float maximum, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(object parameter, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(object parameter, string parameterName, string exceptionMessage);
    [ConditionalAttribute("DEBUG")]
public static void AssertValidCollection(ICollection parameter, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValidIndex(bool test, string parameterName, string exceptionMessage);
    [ConditionalAttribute("DEBUG")]
public static void AssertValidString(string parameter, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValueBetween(int number, int low, int high, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValueBetween(long number, long low, long high, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValueBetween(short number, short low, short high, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValueBetween(double number, double low, double high, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValueBetween(float number, float low, float high, string parameterName);
    [ConditionalAttribute("DEBUG")]
public static void Ignore(Object[] values);
    public static void Require(bool test, string parameterName, ParamErrorTextHandler errorTextHandler);
    public static void Require(bool test, string parameterName, string exceptionMessage);
    public static void RequireGreaterThan(int number, int minimum, string parameterName);
    public static void RequireGreaterThan(long number, long minimum, string parameterName);
    public static void RequireGreaterThan(short number, short minimum, string parameterName);
    public static void RequireGreaterThan(double number, double minimum, string parameterName);
    public static void RequireGreaterThan(float number, float minimum, string parameterName);
    public static void RequireGreaterThanOrEqualTo(int number, int minimum, string parameterName);
    public static void RequireGreaterThanOrEqualTo(long number, long minimum, string parameterName);
    public static void RequireGreaterThanOrEqualTo(short number, short minimum, string parameterName);
    public static void RequireGreaterThanOrEqualTo(double number, double minimum, string parameterName);
    public static void RequireGreaterThanOrEqualTo(float number, float minimum, string parameterName);
    public static void RequireGreaterThanOrEqualToZero(int number, string parameterName);
    public static void RequireGreaterThanOrEqualToZero(long number, string parameterName);
    public static void RequireGreaterThanOrEqualToZero(short number, string parameterName);
    public static void RequireGreaterThanOrEqualToZero(double number, string parameterName);
    public static void RequireGreaterThanOrEqualToZero(float number, string parameterName);
    public static void RequireGreaterThanZero(int number, string parameterName);
    public static void RequireGreaterThanZero(long number, string parameterName);
    public static void RequireGreaterThanZero(short number, string parameterName);
    public static void RequireGreaterThanZero(double number, string parameterName);
    public static void RequireGreaterThanZero(float number, string parameterName);
    public static void RequireLessThan(int number, int maximum, string parameterName);
    public static void RequireLessThan(long number, long maximum, string parameterName);
    public static void RequireLessThan(short number, short maximum, string parameterName);
    public static void RequireLessThan(double number, double maximum, string parameterName);
    public static void RequireLessThan(float number, float maximum, string parameterName);
    public static void RequireLessThanOrEqualTo(int number, int maximum, string parameterName);
    public static void RequireLessThanOrEqualTo(long number, long maximum, string parameterName);
    public static void RequireLessThanOrEqualTo(short number, short maximum, string parameterName);
    public static void RequireLessThanOrEqualTo(double number, double maximum, string parameterName);
    public static void RequireLessThanOrEqualTo(float number, float maximum, string parameterName);
    public static void RequireNotNull(object parameter, string parameterName);
    public static void RequireNotNull(object parameter, string parameterName, ParamErrorTextHandler errorTextHandler);
    public static void RequireNotNull(object parameter, string parameterName, string exceptionMessage);
    public static void RequireValidCollection(ICollection parameter, string parameterName);
    public static void RequireValidIndex(bool test, string parameterName, string exceptionMessage);
    public static void RequireValidIndex(bool test, string parameterName, ParamErrorTextHandler errorTextHandler);
    public static void RequireValidString(string parameter, string parameterName);
    public static void RequireValueBetween(int number, int low, int high, string parameterName);
    public static void RequireValueBetween(long number, long low, long high, string parameterName);
    public static void RequireValueBetween(short number, short low, short high, string parameterName);
    public static void RequireValueBetween(double number, double low, double high, string parameterName);
    public static void RequireValueBetween(float number, float low, float high, string parameterName);
}
public class StyleCop.ParamErrorTextHandler : MulticastDelegate {
    public ParamErrorTextHandler(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class StyleCop.ProjectSettingsFactory : MulticastDelegate {
    public ProjectSettingsFactory(object object, IntPtr method);
    public virtual Settings Invoke(string path, bool readOnly);
    public virtual IAsyncResult BeginInvoke(string path, bool readOnly, AsyncCallback callback, object object);
    public virtual Settings EndInvoke(IAsyncResult result);
}
internal class StyleCop.ProjectStatus : object {
    private bool ignoreResultsCache;
    public bool IgnoreResultsCache { get; public set; }
    public bool get_IgnoreResultsCache();
    public void set_IgnoreResultsCache(bool value);
}
[DefaultMemberAttribute("Item")]
public class StyleCop.PropertyCollection : object {
    private Dictionary`2<string, PropertyValue> properties;
    private bool readOnly;
    public int Count { get; }
    public bool IsReadOnly { get; internal set; }
    public ICollection`1<PropertyValue> Properties { get; }
    public PropertyValue Item { get; public set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    public ICollection`1<PropertyValue> get_Properties();
    public PropertyValue get_Item(string propertyName);
    public void set_Item(string propertyName, PropertyValue value);
    public sealed virtual void Add(PropertyValue property);
    public sealed virtual void Clear();
    public virtual PropertyCollection Clone();
    public sealed virtual bool Contains(PropertyValue property);
    public bool Contains(string propertyName);
    public sealed virtual void CopyTo(PropertyValue[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<PropertyValue> GetEnumerator();
    public PropertyValue GetProperty(string propertyName);
    public sealed virtual bool Remove(PropertyValue property);
    public bool Remove(string propertyName);
    public void SetProperty(PropertyValue property);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class StyleCop.PropertyControl : TabControl {
    private Object[] context;
    private StyleCopCore core;
    private bool dirty;
    private IPropertyControlHost host;
    private WritableSettings localSettings;
    private Settings mergedSettings;
    private IList`1<IPropertyControlPage> pageInterfaces;
    private UserControl[] pages;
    private Settings parentSettings;
    private SettingsComparer settingsComparer;
    private TabPage[] tabPages;
    public IPropertyControlPage ActivePage { get; }
    public IList`1<object> Context { get; }
    public StyleCopCore Core { get; }
    public bool IsDirty { get; }
    public WritableSettings LocalSettings { get; }
    public Settings MergedSettings { get; }
    public IList`1<IPropertyControlPage> Pages { get; }
    public Settings ParentSettings { get; }
    public SettingsComparer SettingsComparer { get; }
    public IPropertyControlPage get_ActivePage();
    public IList`1<object> get_Context();
    public StyleCopCore get_Core();
    public bool get_IsDirty();
    public WritableSettings get_LocalSettings();
    public Settings get_MergedSettings();
    public IList`1<IPropertyControlPage> get_Pages();
    public Settings get_ParentSettings();
    public SettingsComparer get_SettingsComparer();
    public void Cancel();
    public void DirtyChanged();
    public void RefreshMergedSettings();
    internal PropertyControlSaveResult Apply(Boolean& dirtyPages);
    internal void Initialize(IPropertyControlHost hostInstance, IList`1<IPropertyControlPage> propertyPages, WritableSettings settings, StyleCopCore coreInstance, Object[] contextItem);
    private void InitializeComponent();
    private void OnSizeChanged(object sender, EventArgs e);
    private void SizePage(int index);
}
internal enum StyleCop.PropertyControlSaveResult : Enum {
    public int value__;
    public static PropertyControlSaveResult Success;
    public static PropertyControlSaveResult PageAbort;
    public static PropertyControlSaveResult SaveError;
}
public abstract class StyleCop.PropertyDescriptor : object {
    private string description;
    private bool displaySettings;
    private string friendlyName;
    private bool merge;
    private string propertyName;
    private PropertyType propertyType;
    public string Description { get; }
    public bool DisplaySettings { get; }
    public string FriendlyName { get; }
    public bool Merge { get; }
    public string PropertyName { get; }
    public PropertyType PropertyType { get; }
    protected PropertyDescriptor(string propertyName, PropertyType propertyType, string friendlyName, string description, bool merge, bool displaySettings);
    public string get_Description();
    public bool get_DisplaySettings();
    public string get_FriendlyName();
    public bool get_Merge();
    public string get_PropertyName();
    public PropertyType get_PropertyType();
}
public class StyleCop.PropertyDescriptor`1 : PropertyDescriptor {
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    public T DefaultValue { get; internal set; }
    internal PropertyDescriptor`1(string propertyName, PropertyType propertyType, string friendlyName, string description, bool merge, bool displaySettings, T defaultValue);
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    [CompilerGeneratedAttribute]
internal void set_DefaultValue(T value);
}
[DefaultMemberAttribute("Item")]
public class StyleCop.PropertyDescriptorCollection : object {
    private Dictionary`2<string, PropertyDescriptor> propertyDescriptors;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<PropertyDescriptor> PropertyDescriptors { get; }
    public ICollection`1<string> PropertyNames { get; }
    public PropertyDescriptor Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public ICollection`1<PropertyDescriptor> get_PropertyDescriptors();
    public ICollection`1<string> get_PropertyNames();
    public PropertyDescriptor get_Item(string propertyName);
    public sealed virtual void Add(PropertyDescriptor property);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PropertyDescriptor item);
    public bool Contains(string propertyName);
    public sealed virtual void CopyTo(PropertyDescriptor[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<PropertyDescriptor> GetEnumerator();
    public PropertyDescriptor GetPropertyDescriptor(string propertyName);
    public sealed virtual bool Remove(PropertyDescriptor property);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void AddPropertyDescriptor(PropertyDescriptor descriptor);
    internal void InitializeFromXml(XmlNode propertiesNode);
    private static string ExtractDescription(XmlNode propertyNode);
    private static bool ExtractDisplaySettings(XmlNode propertyNode);
    private static string ExtractFriendlyName(XmlNode propertyNode);
    private static bool ExtractMerge(XmlNode propertyNode);
    private static string ExtractPropertyName(XmlNode propertyNode);
    private void AddBooleanPropertyDescriptor(XmlNode propertyNode);
    private void AddCollectionPropertyDescriptor(XmlNode propertyNode);
    private void AddIntPropertyDescriptor(XmlNode propertyNode);
    private void AddStringPropertyDescriptor(XmlNode propertyNode);
}
internal class StyleCop.PropertyDialog : Form {
    private Object[] context;
    private StyleCopCore core;
    private Help helpCallback;
    private string id;
    private IList`1<IPropertyControlPage> pages;
    private WritableSettings settingsFile;
    private bool settingsChanged;
    private IContainer components;
    private Button ok;
    private Button cancel;
    private Button apply;
    private Button help;
    private PropertyControl properties;
    private TableLayoutPanel layoutPanel;
    public bool SettingsChanged { get; }
    public PropertyDialog(IList`1<IPropertyControlPage> pages, WritableSettings settingsFile, string id, StyleCopCore core, Help helpCallback, Object[] context);
    public bool get_SettingsChanged();
    public sealed virtual void Cancel();
    public sealed virtual void Dirty(bool isDirty);
    protected virtual void OnClosing(CancelEventArgs e);
    protected virtual void OnLoad(EventArgs e);
    private void MoveButton(Button source, Button dest);
    private void ApplyClick(object sender, EventArgs e);
    private void CancelClick(object sender, EventArgs e);
    private void HelpClick(object sender, EventArgs e);
    private void OkClick(object sender, EventArgs e);
    protected virtual void Dispose(bool disposing);
    private void InitializeComponent();
}
public enum StyleCop.PropertyType : Enum {
    public int value__;
    public static PropertyType String;
    public static PropertyType Boolean;
    public static PropertyType Int;
    public static PropertyType Collection;
}
public abstract class StyleCop.PropertyValue : object {
    private PropertyDescriptor propertyDescriptor;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public string Description { get; }
    public string FriendlyName { get; }
    public bool HasDefaultValue { get; }
    public bool IsDefault { get; }
    public bool IsReadOnly { get; internal set; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public string PropertyName { get; }
    public PropertyType PropertyType { get; }
    protected PropertyValue(PropertyDescriptor propertyDescriptor);
    protected PropertyValue(IPropertyContainer propertyContainer, string propertyName);
    public string get_Description();
    public string get_FriendlyName();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsDefault();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal virtual void set_IsReadOnly(bool value);
    public PropertyDescriptor get_PropertyDescriptor();
    public string get_PropertyName();
    public PropertyType get_PropertyType();
    public abstract virtual PropertyValue Clone();
    public abstract virtual bool OverridesProperty(PropertyValue parentProperty);
}
public abstract class StyleCop.PropertyValue`1 : PropertyValue {
    private T value;
    public T DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsDefault { get; }
    public T Value { get; public set; }
    protected PropertyValue`1(PropertyDescriptor`1<T> propertyDescriptor, T value);
    protected PropertyValue`1(IPropertyContainer propertyContainer, string propertyName, T value);
    public T get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool get_IsDefault();
    public T get_Value();
    public void set_Value(T value);
    public virtual PropertyValue Clone();
    public virtual bool OverridesProperty(PropertyValue parentProperty);
}
public class StyleCop.RegistryUtils : object {
    private static string StyleCopSubKey;
    private RegistryKey currentUserRoot;
    private RegistryKey localMachineRoot;
    public RegistryKey CurrentUserRoot { get; }
    public RegistryKey LocalMachineRoot { get; }
    protected virtual override void Finalize();
    public RegistryKey get_CurrentUserRoot();
    public RegistryKey get_LocalMachineRoot();
    public static string LocalMachineGetValue(string keyName, string valueName);
    public object CUGetValue(string name);
    public bool CUSetValue(string name, object value);
    public object LMGetValue(string name);
    public bool RestoreWindowPosition(string name, Form form, object location, object size);
    public bool SaveWindowPosition(string name, Point location, Size size, FormWindowState state);
    public bool SaveWindowPositionByForm(string name, Form form);
    private static PathInfo CreatePath(RegistryKey root, string name);
    private static PathInfo GetPath(RegistryKey root, string name);
    private static object GetValue(RegistryKey root, string name);
    private static bool SetValue(RegistryKey root, string name, object value);
}
internal class StyleCop.ResultsCache : object {
    internal static string Version;
    private static string TimestampFormat;
    private StyleCopCore core;
    private Dictionary`2<string, XmlDocument> documentHash;
    public ResultsCache(StyleCopCore core);
    public void Flush();
    public string LoadProject(CodeProject project);
    public bool LoadResults(SourceCode sourceCode, SourceParser parser, DateTime writeTime, DateTime settingsTimestamp);
    public bool SaveDocumentResults(CodeDocument document, SourceParser parser, DateTime settingsTimeStamp);
    public bool SaveProject(CodeProject project);
    private static bool IsNodeUpToDate(XmlNode node, DateTime timestamp);
    private static bool IsNodeUpToDate(XmlNode node, int hashCode);
    private void AddHashCodeToXml(XmlDocument xml, XmlNode xmlNode, string nodeName, int hashCode);
    private void AddTimestampToXml(XmlDocument xml, XmlNode xmlNode, string nodeName, DateTime timestamp);
    private XmlDocument OpenCacheProject(CodeProject project, XmlNode& projectNode);
    private XmlDocument OpenResultsCache(SourceCode sourceCode, SourceParser parser, XmlNode& item);
}
public class StyleCop.Rule : object {
    private bool canDisable;
    private string checkId;
    private string context;
    private string description;
    private bool enabledByDefault;
    private string name;
    private string namespace;
    private int namespaceID;
    private string ruleGroup;
    private int uniqueID;
    private bool warning;
    public bool CanDisable { get; }
    public string CheckId { get; }
    public string Context { get; }
    public string Description { get; }
    public bool EnabledByDefault { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string RuleGroup { get; }
    public int UniqueRuleId { get; }
    public int UniqueRuleNamespaceId { get; }
    public bool Warning { get; }
    internal Rule(string name, string namespace, string checkId, string context, bool warning);
    internal Rule(string name, string namespace, string checkId, string context, bool warning, string description, string ruleGroup, bool enabledByDefault, bool canDisable);
    public bool get_CanDisable();
    public string get_CheckId();
    public string get_Context();
    public string get_Description();
    public bool get_EnabledByDefault();
    public string get_Name();
    public string get_Namespace();
    public string get_RuleGroup();
    public int get_UniqueRuleId();
    public int get_UniqueRuleNamespaceId();
    public bool get_Warning();
    public static int GenerateUniqueId(string namespace, string checkId, string name);
    public virtual int GetHashCode();
    private static int GenerateUniqueRuleID(string namespace, string checkID, string name);
    private static int GenerateUniqueRuleNamespaceID(string namespace);
}
internal enum StyleCop.Rules : Enum {
    public int value__;
    public static Rules ExceptionOccurred;
}
public class StyleCop.Settings : object {
    public static string AlternateFileName;
    public static string DefaultFileName;
    private Dictionary`2<string, AddInPropertyCollection> analyzerSettings;
    private XmlDocument contents;
    private StyleCopCore core;
    private ReaderWriterLock enabledRulesLock;
    private PropertyCollection globalSettings;
    private string location;
    private Dictionary`2<string, AddInPropertyCollection> parserSettings;
    private List`1<SourceFileListSettings> sourceFileLists;
    private bool defaultSettings;
    private Dictionary`2<StyleCopAddIn, Dictionary`2<string, Rule>> enabledRules;
    [CompilerGeneratedAttribute]
private DateTime <WriteTime>k__BackingField;
    public ICollection`1<AddInPropertyCollection> AnalyzerSettings { get; }
    public XmlDocument Contents { get; }
    public IEnumerable`1<SourceAnalyzer> EnabledAnalyzers { get; }
    public PropertyCollection GlobalSettings { get; }
    public bool Loaded { get; }
    public string Location { get; }
    public ICollection`1<AddInPropertyCollection> ParserSettings { get; }
    public bool RulesEnabledByDefault { get; }
    public ICollection`1<SourceFileListSettings> SourceFileLists { get; }
    public DateTime WriteTime { get; internal set; }
    internal StyleCopCore Core { get; }
    internal bool DefaultSettings { get; internal set; }
    protected Dictionary`2<string, AddInPropertyCollection> AnalyzerDictionary { get; }
    protected Dictionary`2<string, AddInPropertyCollection> ParserDictionary { get; }
    public Settings(StyleCopCore core, string location);
    public Settings(StyleCopCore core, string location, XmlDocument contents, DateTime writeTime);
    internal Settings(StyleCopCore core);
    public ICollection`1<AddInPropertyCollection> get_AnalyzerSettings();
    public XmlDocument get_Contents();
    public IEnumerable`1<SourceAnalyzer> get_EnabledAnalyzers();
    public PropertyCollection get_GlobalSettings();
    public bool get_Loaded();
    public string get_Location();
    public ICollection`1<AddInPropertyCollection> get_ParserSettings();
    public bool get_RulesEnabledByDefault();
    public ICollection`1<SourceFileListSettings> get_SourceFileLists();
    [CompilerGeneratedAttribute]
public DateTime get_WriteTime();
    [CompilerGeneratedAttribute]
internal void set_WriteTime(DateTime value);
    internal StyleCopCore get_Core();
    internal bool get_DefaultSettings();
    internal void set_DefaultSettings(bool value);
    protected Dictionary`2<string, AddInPropertyCollection> get_AnalyzerDictionary();
    protected Dictionary`2<string, AddInPropertyCollection> get_ParserDictionary();
    public PropertyValue GetAddInSetting(StyleCopAddIn addIn, string propertyName);
    public AddInPropertyCollection GetAddInSettings(StyleCopAddIn addIn);
    public Settings GetCustomSettingsForFile(string fileName);
    public bool IsRuleEnabled(SourceAnalyzer analyzer, string ruleName);
    internal void AddSourceFileList(SourceFileListSettings sourceFileList);
    internal void ClearAddInSettingInternal(StyleCopAddIn addIn, string propertyName);
    internal void SetAddInSettingInternal(StyleCopAddIn addIn, PropertyValue property);
    internal void SetAddInSettings(AddInPropertyCollection properties);
    private Dictionary`2<string, AddInPropertyCollection> GetPropertyCollectionDictionary(StyleCopAddIn addIn);
    private void InitializeEnabledRules();
    private void LoadSettingsDocument();
}
public class StyleCop.SettingsComparer : object {
    private Settings localSettings;
    private Settings parentSettings;
    public Settings LocalSettings { get; }
    public Settings ParentSettings { get; }
    public SettingsComparer(Settings localSettings, Settings parentSettings);
    public Settings get_LocalSettings();
    public Settings get_ParentSettings();
    public static bool IsSettingOverwritten(PropertyValue localProperty, PropertyValue parentProperty);
    public bool IsAddInSettingOverwritten(StyleCopAddIn addIn, string propertyName, PropertyValue localProperty);
    public bool IsGlobalSettingOverwritten(string propertyName, PropertyValue localProperty);
    public bool IsGlobalSettingOverwritten(string propertyName);
    public bool IsParserSettingOverwritten(StyleCopAddIn addIn, string propertyName);
}
public class StyleCop.SettingsMerger : object {
    internal static string LinkedSettingsProperty;
    internal static string MergeSettingsFilesProperty;
    internal static string MergeStyleLinked;
    internal static string MergeStyleNone;
    internal static string MergeStyleParent;
    private StyleCopEnvironment environment;
    private Settings localSettings;
    public Settings MergedSettings { get; }
    public Settings ParentMergedSettings { get; }
    public SettingsMerger(Settings localSettings, StyleCopEnvironment environment);
    public Settings get_MergedSettings();
    public Settings get_ParentMergedSettings();
    internal static void MergePropertyCollections(PropertyCollection originalPropertyCollection, PropertyCollection overridingPropertyCollection, PropertyCollection mergedPropertyCollection);
    private static string DetermineMergeType(Settings settings, StyleCopEnvironment environment);
    private static void MergeCollectionProperties(PropertyCollection mergedPropertyCollection, PropertyValue originalProperty, PropertyValue overridingProperty);
    private static Settings MergeSettings(Settings originalSettings, Settings overridingSettings);
    private Settings FindMergedSettingsThroughLinkedSettings(Settings originalSettings, bool mergeOriginal);
    private Settings FindMergedSettingsThroughParentPaths(Settings originalSettings, bool mergeOriginal);
}
public abstract class StyleCop.SourceAnalyzer : StyleCopAddIn {
    private string parserId;
    private SourceParser parser;
    public bool Cancel { get; }
    public SourceParser Parser { get; }
    public string ParserId { get; }
    public bool get_Cancel();
    public SourceParser get_Parser();
    public string get_ParserId();
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DelayAnalysis(CodeDocument document, int passNumber);
    public virtual bool DoAnalysis(CodeDocument document);
    public virtual int GetDependantFilesHashCode(CultureInfo culture);
    public virtual bool IsRuleEnabled(CodeDocument document, string ruleName);
    public virtual bool IsRuleSuppressed(ICodeElement element, string ruleCheckId, string ruleName, string ruleNamespace);
    public virtual void PostAnalyze();
    public virtual void PreAnalyze();
    internal void SetParser(SourceParser item);
    protected object GetDocumentData(CodeDocument document);
    protected virtual void ImportInitializationXml(XmlDocument document, bool topmostType, bool isKnownAssembly);
    protected void Log(StyleCopLogLevel level, string output);
    protected void SetDocumentData(CodeDocument document, object data);
}
[AttributeUsageAttribute("4")]
public class StyleCop.SourceAnalyzerAttribute : StyleCopAddInAttribute {
    private Type parserType;
    public Type ParserType { get; }
    public SourceAnalyzerAttribute(Type parserType);
    public SourceAnalyzerAttribute(Type parserType, string analyzerXmlId);
    public Type get_ParserType();
}
public abstract class StyleCop.SourceCode : object {
    private IEnumerable`1<Configuration> configurations;
    private SourceParser parser;
    private CodeProject project;
    private Dictionary`2<int, Violation> violations;
    private Settings settings;
    public IEnumerable`1<Configuration> Configurations { get; }
    public bool Exists { get; }
    public string Name { get; }
    public SourceParser Parser { get; }
    public string Path { get; }
    public CodeProject Project { get; }
    public Settings Settings { get; public set; }
    public DateTime TimeStamp { get; }
    public string Type { get; }
    public ICollection`1<Violation> Violations { get; }
    protected SourceCode(CodeProject project, SourceParser parser);
    protected SourceCode(CodeProject project, SourceParser parser, IEnumerable`1<Configuration> configurations);
    public IEnumerable`1<Configuration> get_Configurations();
    public abstract virtual bool get_Exists();
    public abstract virtual string get_Name();
    public SourceParser get_Parser();
    public abstract virtual string get_Path();
    public CodeProject get_Project();
    public Settings get_Settings();
    public void set_Settings(Settings value);
    public abstract virtual DateTime get_TimeStamp();
    public abstract virtual string get_Type();
    public ICollection`1<Violation> get_Violations();
    public abstract virtual TextReader Read();
    internal bool AddViolation(Violation violation);
}
public class StyleCop.SourceCodeFactory : MulticastDelegate {
    public SourceCodeFactory(object object, IntPtr method);
    public virtual SourceCode Invoke(string path, CodeProject project, SourceParser parser, object context);
    public virtual IAsyncResult BeginInvoke(string path, CodeProject project, SourceParser parser, object context, AsyncCallback callback, object object);
    public virtual SourceCode EndInvoke(IAsyncResult result);
}
public class StyleCop.SourceFileListSettings : object {
    private Dictionary`2<string, string> files;
    [CompilerGeneratedAttribute]
private Settings <Settings>k__BackingField;
    public Settings Settings { get; internal set; }
    public IEnumerable`1<string> SourceFiles { get; }
    internal SourceFileListSettings(Settings settings);
    [CompilerGeneratedAttribute]
public Settings get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(Settings value);
    public IEnumerable`1<string> get_SourceFiles();
    public bool ContainsFile(string fileName);
    internal void AddFile(string fileName);
}
public abstract class StyleCop.SourceParser : StyleCopAddIn {
    private List`1<SourceAnalyzer> analyzers;
    private List`1<string> fileTypes;
    public ICollection`1<SourceAnalyzer> Analyzers { get; }
    public ICollection`1<string> FileTypes { get; }
    public ICollection`1<SourceAnalyzer> get_Analyzers();
    public ICollection`1<string> get_FileTypes();
    public void AddGlobalViolation(int line, string ruleName, Object[] values);
    public void AddGlobalViolation(int line, Enum ruleName, Object[] values);
    public void AddViolation(SourceCode sourceCode, int line, string ruleName, Object[] values);
    public void AddViolation(SourceCode sourceCode, int line, Enum ruleName, Object[] values);
    public void AddViolation(Violation violation);
    public abstract virtual bool ParseFile(SourceCode sourceCode, int passNumber, CodeDocument& document);
    public virtual void PostParse();
    public virtual void PreParse();
    public virtual bool SkipAnalysisForDocument(SourceCode sourceCode);
    internal static void ClearAnalyzerTags(CodeDocument document);
    internal static void ExportViolations(CodeDocument document, XmlDocument violationsDocument, XmlNode parentNode);
    internal bool ImportViolations(SourceCode sourceCode, XmlNode parentNode);
    protected virtual void ImportInitializationXml(XmlDocument document, bool topmostType, bool isKnownAssembly);
    protected void Log(StyleCopLogLevel level, string output);
    private static void ExportElementViolations(ICodeElement element, XmlDocument violationsDocument, XmlNode parentNode);
    private static void ExportViolation(Violation violation, XmlDocument violationsDocument, XmlNode parentNode);
}
[AttributeUsageAttribute("4")]
public class StyleCop.SourceParserAttribute : StyleCopAddInAttribute {
    public SourceParserAttribute(string parserXmlId);
}
public class StyleCop.Spelling.NamingService : object {
    private static Dictionary`2<string, NamingService> ServiceCache;
    private static object ServiceCacheLock;
    private static NamingService defaultNamingService;
    private CultureInfo culture;
    private IDictionary`2<string, string> alternatesForDeprecatedWords;
    private IDictionary`2<string, string> casingExceptions;
    private IDictionary`2<string, string> compoundAlternatesForDiscreteWords;
    private int customDictionaryHashCode;
    private ICollection`1<string> dictionaryFolders;
    private IDictionary`2<string, string> discreteWordExceptions;
    private SpellChecker spellChecker;
    public static NamingService DefaultNamingService { get; }
    public CultureInfo Culture { get; }
    public ICollection`1<string> DictionaryFolders { get; }
    public bool SupportsSpelling { get; }
    internal bool IsEnglishCulture { get; }
    private NamingService(CultureInfo culture);
    private static NamingService();
    public static NamingService get_DefaultNamingService();
    public CultureInfo get_Culture();
    public ICollection`1<string> get_DictionaryFolders();
    public bool get_SupportsSpelling();
    internal bool get_IsEnglishCulture();
    public static void ClearCachedServices();
    public static NamingService GetNamingService(CultureInfo culture);
    public void AddDeprecatedWords(IDictionary`2<string, string> deprecatedWords);
    public void AddDictionaryFolder(string path);
    public WordSpelling CheckSpelling(string word);
    public sealed virtual void Dispose();
    public string GetCompoundAlternateForDiscreteWord(string word);
    public int GetDependantFilesHashCode();
    public string GetDiscreteAlternateForCompoundWord(string word1, string word2);
    public string GetPreferredAlternateForDeprecatedWord(string word);
    public bool IsCasingException(string word);
    internal static CultureInfo TryParseCulture(string cultureName);
    internal bool IsAlwaysMisspelledWord(string word);
    internal bool IsIgnoredWord(string word);
    protected virtual void Dispose(bool disposing);
    private static bool ContainsNonLetter(string word);
    private static void FileChanged(object source, FileSystemEventArgs e);
    private static bool IsAllUpperCase(string word);
    private static bool IsMixedCase(string word);
    private static void LoadWordsFromXml(IDictionary`2<string, string> list, XmlDocument document, string xPathQuery, string attributeName);
    private static void OnRenamed(object source, RenamedEventArgs e);
    private void AddFileWatcher(string path);
    private void AddWordsToCollection(ICollection`1<string> collection, IEnumerable`1<string> wordsToAdd);
    private void AddWordsToSpellChecker(IDictionary`2<string, string> ignoredWords, IDictionary`2<string, string> alwaysMisspelledWords);
    private IDictionary`2<string, string> CreateCaseInsensitiveDictionary();
    private IDictionary`2<string, string> CreateDictionary();
    private void InitCustomDictionaries();
    private void LoadCustomDic(string fileName);
    private void LoadCustomDictionaryXml(string fileName);
    private void ScanAndLoadDictionaries(string directory);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class StyleCop.Spelling.NullIfNotFoundDictionary`2 : object {
    private Dictionary`2<TKey, TValue> dictionary;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public NullIfNotFoundDictionary`2(int capacity);
    public NullIfNotFoundDictionary`2(IEqualityComparer`1<TKey> comparer);
    public NullIfNotFoundDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public NullIfNotFoundDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public NullIfNotFoundDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public bool Contains(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class StyleCop.Spelling.SpellChecker : object {
    internal static int MaximumTextLength;
    private static Language[] Languages;
    private static TextInfo UsaTextInfo;
    private static Dictionary`2<string, Language> languageTable;
    private CultureInfo culture;
    private int dependantFilesHashCode;
    private WordCollection alwaysMisspelledWords;
    private WordCollection ignoredWords;
    private Speller speller;
    private Dictionary`2<string, WordSpelling> wordSpellingCache;
    public WordCollection AlwaysMisspelledWords { get; }
    public WordCollection IgnoredWords { get; }
    private bool IsDisposed { get; }
    private SpellChecker(CultureInfo culture, Language language);
    private static SpellChecker();
    public WordCollection get_AlwaysMisspelledWords();
    public WordCollection get_IgnoredWords();
    private bool get_IsDisposed();
    public static SpellChecker FromCulture(CultureInfo culture);
    public WordSpelling Check(string text);
    public sealed virtual void Dispose();
    public int GetDependantFilesHashCode();
    private static Dictionary`2<string, Language> BuildLanguageTable();
    private void OnIgnoredWordsChanged(object sender, CollectionChangeEventArgs e);
}
internal class StyleCop.Spelling.WordCollection : object {
    private Dictionary`2<string, object> words;
    [CompilerGeneratedAttribute]
private CollectionChangeEventHandler CollectionChanged;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.String>.IsReadOnly { get; }
    public WordCollection(IEqualityComparer`1<string> comparer);
    [CompilerGeneratedAttribute]
public void add_CollectionChanged(CollectionChangeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CollectionChanged(CollectionChangeEventHandler value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.String>.get_IsReadOnly();
    public sealed virtual void Add(string item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string item);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static bool IsValidWordLength(string item);
    protected virtual void OnCollectionChanged(CollectionChangeEventArgs e);
    private static void CheckWord(string item);
}
public class StyleCop.Spelling.WordParser : object {
    private static char NullChar;
    private StringBuilder buffer;
    private string text;
    private WordParserOptions wordParserOptions;
    private ICollection`1<string> recognizedWords;
    private int index;
    private string peekedWord;
    private char prefixChar;
    private bool SkipMnemonics { get; }
    private bool SplitCompoundWords { get; }
    public WordParser(string text, WordParserOptions options, ICollection`1<string> recognizedWords);
    internal WordParser(string text, WordParserOptions options, ICollection`1<string> recognizedWords, char prefixChar);
    private bool get_SkipMnemonics();
    private bool get_SplitCompoundWords();
    public string NextWord();
    public string PeekWord();
    private static bool IsDigit(char c);
    private static bool IsHexDigit(char c);
    private static bool IsIntraWordPunctuation(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsLetterWithoutCase(char c);
    private static bool IsLower(char c);
    private static bool IsUpper(char c);
    private bool IsIgnored(char c);
    private string NextWordCore();
    private void ParseAllCaps();
    private void ParseHex();
    private void ParseInteger();
    private void ParseLatex();
    private void ParseLowercase();
    private bool ParseNext();
    private void ParseNumeric();
    private void ParseUppercase();
    private string PeekWholeWord();
    private void ParseWholeWord();
    private void ParseWithoutCase();
    private char Peek();
    private char Peek(int lookAhead);
    private void Read();
    private void Skip();
    private bool TryParsePrefix();
    private bool TryParseWord(char c);
    private void Unread();
}
[FlagsAttribute]
public enum StyleCop.Spelling.WordParserOptions : Enum {
    public int value__;
    public static WordParserOptions None;
    public static WordParserOptions IgnoreMnemonicsIndicators;
    public static WordParserOptions SplitCompoundWords;
}
public enum StyleCop.Spelling.WordSpelling : Enum {
    public int value__;
    public static WordSpelling SpelledCorrectly;
    public static WordSpelling Unrecognized;
    public static WordSpelling CasedIncorrectly;
}
internal class StyleCop.SpellingTab : UserControl {
    private static string DeprecatedWordsPropertyName;
    private static string DictionaryFoldersPropertyName;
    private static string RecognizedWordsPropertyName;
    private TextBox addAlternateWordTextBox;
    private Button addDeprecatedWordButton;
    private TextBox addDeprecatedWordTextBox;
    private Button addFolderButton;
    private TextBox addFolderTextBox;
    private Button addRecognizedWordButton;
    private TextBox addRecognizedWordTextBox;
    private ColumnHeader deprecatedWordsColumnHeader;
    private ListView deprecatedWordsListView;
    private ColumnHeader dictionaryFoldersColumnHeader;
    private bool dirty;
    private ListView foldersListView;
    private IButtonControl formAcceptButton;
    private GroupBox groupBox2;
    private GroupBox groupBox3;
    private Label label1;
    private Label label10;
    private Label label2;
    private Label label3;
    private Label label4;
    private Label label5;
    private Label label6;
    private Label label7;
    private Label label8;
    private Label label9;
    private ColumnHeader recognizedWordsColumnHeader;
    private ListView recognizedWordsListView;
    private Button removeDeprecatedWordButton;
    private Button removeFolderButton;
    private Button removeRecognizedWordButton;
    private TableLayoutPanel tableLayoutPanel1;
    private Label label12;
    private TableLayoutPanel tableLayoutPanel2;
    private GroupBox groupBox1;
    private TableLayoutPanel tableLayoutPanel3;
    private Label label11;
    private TableLayoutPanel tableLayoutPanel4;
    private TableLayoutPanel tableLayoutPanel5;
    private Label label13;
    private PropertyControl tabControl;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    private void InitializeColumns();
    private void AddDeprecatedWordButtonClick(object sender, EventArgs e);
    private void AddDeprecatedWordKeyDown(object sender, KeyEventArgs e);
    private void AddDictionaryFolderKeyDown(object sender, KeyEventArgs e);
    private void AddFolderButtonClick(object sender, EventArgs e);
    private void AddParentSettingsValues();
    private void AddRecognizedWordButtonClick(object sender, EventArgs e);
    private void AddRecognizedWordKeyDown(object sender, KeyEventArgs e);
    private void AddWordGotFocus(object sender, EventArgs e);
    private void AddWordLostFocus(object sender, EventArgs e);
    private void DeprecatedWordListKeyDown(object sender, KeyEventArgs e);
    private void DeprecatedWordsListViewSizeChanged(object sender, EventArgs e);
    private void DictionaryFoldersKeyDown(object sender, KeyEventArgs e);
    private void DictionaryFoldersListViewSizeChanged(object sender, EventArgs e);
    private void EnableDisableRemoveButtons();
    private void InitializeComponent();
    private void RecognizedWordListKeyDown(object sender, KeyEventArgs e);
    private void RecognizedWordsListViewSizeChanged(object sender, EventArgs e);
    private void RemoveDeprecatedWordButtonClick(object sender, EventArgs e);
    private void RemoveFolderButtonClick(object sender, EventArgs e);
    private void RemoveRecognizedWordButtonClick(object sender, EventArgs e);
    private void SetBoldState(ListViewItem item, ListView listView);
    private void WordListItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e);
}
public class StyleCop.StringProperty : PropertyValue`1<string> {
    public StringProperty(PropertyDescriptor`1<string> propertyDescriptor, string value);
    public StringProperty(IPropertyContainer propertyContainer, string propertyName, string value);
    public virtual PropertyValue Clone();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AlertDialogWithOptionsInNonUIState { get; }
    internal static string AllFiles { get; }
    internal static string AnalysisErrorOccurred { get; }
    internal static string AnalyzersTab { get; }
    internal static string BothItemsMustBeNullOrNonNull { get; }
    internal static string CacheTab { get; }
    internal static string CannotBeNull { get; }
    internal static string CannotDisplaySettingsInNonUIMode { get; }
    internal static string CannotLoadSettingsFilePath { get; }
    internal static string CollectionCannotBeEmptyOrNull { get; }
    internal static string ComparingDifferentPropertyTypes { get; }
    internal static string CouldNotSaveSettingsFile { get; }
    internal static string CouldNotSaveViolationsFile { get; }
    internal static string CouldNotSaveViolationsFileWithException { get; }
    internal static string DisabledByDefaultAttributeDeprecatedForAddIns { get; }
    internal static string EditDefaultSettingsWarning { get; }
    internal static string EmptySettingsFilePath { get; }
    internal static string EnterValidDeprecatedWord { get; }
    internal static string EnterValidFolder { get; }
    internal static string EnterValidWord { get; }
    internal static string ErrorTag { get; }
    internal static string ExceptionWhileLoadingAddins { get; }
    internal static string GlobalSettingsFile { get; }
    internal static string InternalError { get; }
    internal static string InvalidAddInXmlDocument { get; }
    internal static string InvalidWindowLocationInputString { get; }
    internal static string LocalSettingsNotOpenedOrCreated { get; }
    internal static string MissingAddInDescription { get; }
    internal static string MissingNameAttributeOnRootNode { get; }
    internal static string MustBeBetween { get; }
    internal static string MustBeGreaterThan { get; }
    internal static string MustBeGreaterThanOrEqualTo { get; }
    internal static string MustBeGreaterThanOrEqualToZero { get; }
    internal static string MustBeGreaterThanZero { get; }
    internal static string MustBeLessThan { get; }
    internal static string MustBeLessThanOrEqualTo { get; }
    internal static string NodeAlreadyInCollection { get; }
    internal static string NoLinkedSettingsFile { get; }
    internal static string NoParentSettingsFile { get; }
    internal static string NoViolationsEncountered { get; }
    internal static string ProjectSettingsFileNotLoadedOrCreated { get; }
    internal static string PropertyControlAlreadyInitialized { get; }
    internal static string PropertyDescriptionNotSet { get; }
    internal static string PropertyDescriptorDoesNotExist { get; }
    internal static string PropertyDescriptorHasNoDefaultValue { get; }
    internal static string PropertyFriendlyNameNotSet { get; }
    internal static string PropertyHasNoDescription { get; }
    internal static string PropertyHasNoFriendlyName { get; }
    internal static string PropertyHasNoName { get; }
    internal static string ReadOnlyCollection { get; }
    internal static string ReadOnlyProperty { get; }
    internal static string RootNodeMustBeSourceParser { get; }
    internal static string RuleCheckIdInvalid { get; }
    internal static string RuleDisabledByDefaultAndNotCanDisable { get; }
    internal static string RuleDoesNotExist { get; }
    internal static string RuleGroupHasNoNameAttribute { get; }
    internal static string RuleHasNoCheckIdAttribute { get; }
    internal static string RuleHasNoContextElement { get; }
    internal static string RuleHasNoNameAttribute { get; }
    internal static string RuleNameInvalid { get; }
    internal static string RuleWithSameNameExists { get; }
    internal static string SettingsDialogTitleDefault { get; }
    internal static string SettingsDialogTitleFormat { get; }
    internal static string SettingsDialogTitleLocal { get; }
    internal static string SettingsFileHasNotBeenLoaded { get; }
    internal static string SettingsFileMatchPaths { get; }
    internal static string SettingsFiles { get; }
    internal static string SettingsFilesTab { get; }
    internal static string SourceAnalyzerAttributeMissing { get; }
    internal static string SourceAnalyzerRootNodeIsIncorrect { get; }
    internal static string SourceCodeFactoryReturnsNull { get; }
    internal static string SourceCodeTypePropertyNotSet { get; }
    internal static string SpellingTab { get; }
    internal static string StringCannotBeEmptyOrNull { get; }
    internal static string StyleCopUnableToLoad { get; }
    internal static string SyntaxErrorInFile { get; }
    internal static string SyntaxErrorInFileWithMessage { get; }
    internal static string Title { get; }
    internal static string UnknownAssemblyUsingDefaultCheckIdPrefix { get; }
    internal static string ViolationFormatter { get; }
    internal static string ViolationsEncountered { get; }
    internal static string WarningTag { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AlertDialogWithOptionsInNonUIState();
    internal static string get_AllFiles();
    internal static string get_AnalysisErrorOccurred();
    internal static string get_AnalyzersTab();
    internal static string get_BothItemsMustBeNullOrNonNull();
    internal static string get_CacheTab();
    internal static string get_CannotBeNull();
    internal static string get_CannotDisplaySettingsInNonUIMode();
    internal static string get_CannotLoadSettingsFilePath();
    internal static string get_CollectionCannotBeEmptyOrNull();
    internal static string get_ComparingDifferentPropertyTypes();
    internal static string get_CouldNotSaveSettingsFile();
    internal static string get_CouldNotSaveViolationsFile();
    internal static string get_CouldNotSaveViolationsFileWithException();
    internal static string get_DisabledByDefaultAttributeDeprecatedForAddIns();
    internal static string get_EditDefaultSettingsWarning();
    internal static string get_EmptySettingsFilePath();
    internal static string get_EnterValidDeprecatedWord();
    internal static string get_EnterValidFolder();
    internal static string get_EnterValidWord();
    internal static string get_ErrorTag();
    internal static string get_ExceptionWhileLoadingAddins();
    internal static string get_GlobalSettingsFile();
    internal static string get_InternalError();
    internal static string get_InvalidAddInXmlDocument();
    internal static string get_InvalidWindowLocationInputString();
    internal static string get_LocalSettingsNotOpenedOrCreated();
    internal static string get_MissingAddInDescription();
    internal static string get_MissingNameAttributeOnRootNode();
    internal static string get_MustBeBetween();
    internal static string get_MustBeGreaterThan();
    internal static string get_MustBeGreaterThanOrEqualTo();
    internal static string get_MustBeGreaterThanOrEqualToZero();
    internal static string get_MustBeGreaterThanZero();
    internal static string get_MustBeLessThan();
    internal static string get_MustBeLessThanOrEqualTo();
    internal static string get_NodeAlreadyInCollection();
    internal static string get_NoLinkedSettingsFile();
    internal static string get_NoParentSettingsFile();
    internal static string get_NoViolationsEncountered();
    internal static string get_ProjectSettingsFileNotLoadedOrCreated();
    internal static string get_PropertyControlAlreadyInitialized();
    internal static string get_PropertyDescriptionNotSet();
    internal static string get_PropertyDescriptorDoesNotExist();
    internal static string get_PropertyDescriptorHasNoDefaultValue();
    internal static string get_PropertyFriendlyNameNotSet();
    internal static string get_PropertyHasNoDescription();
    internal static string get_PropertyHasNoFriendlyName();
    internal static string get_PropertyHasNoName();
    internal static string get_ReadOnlyCollection();
    internal static string get_ReadOnlyProperty();
    internal static string get_RootNodeMustBeSourceParser();
    internal static string get_RuleCheckIdInvalid();
    internal static string get_RuleDisabledByDefaultAndNotCanDisable();
    internal static string get_RuleDoesNotExist();
    internal static string get_RuleGroupHasNoNameAttribute();
    internal static string get_RuleHasNoCheckIdAttribute();
    internal static string get_RuleHasNoContextElement();
    internal static string get_RuleHasNoNameAttribute();
    internal static string get_RuleNameInvalid();
    internal static string get_RuleWithSameNameExists();
    internal static string get_SettingsDialogTitleDefault();
    internal static string get_SettingsDialogTitleFormat();
    internal static string get_SettingsDialogTitleLocal();
    internal static string get_SettingsFileHasNotBeenLoaded();
    internal static string get_SettingsFileMatchPaths();
    internal static string get_SettingsFiles();
    internal static string get_SettingsFilesTab();
    internal static string get_SourceAnalyzerAttributeMissing();
    internal static string get_SourceAnalyzerRootNodeIsIncorrect();
    internal static string get_SourceCodeFactoryReturnsNull();
    internal static string get_SourceCodeTypePropertyNotSet();
    internal static string get_SpellingTab();
    internal static string get_StringCannotBeEmptyOrNull();
    internal static string get_StyleCopUnableToLoad();
    internal static string get_SyntaxErrorInFile();
    internal static string get_SyntaxErrorInFileWithMessage();
    internal static string get_Title();
    internal static string get_UnknownAssemblyUsingDefaultCheckIdPrefix();
    internal static string get_ViolationFormatter();
    internal static string get_ViolationsEncountered();
    internal static string get_WarningTag();
}
[StyleCopAddInAttribute]
public abstract class StyleCop.StyleCopAddIn : object {
    private static string DefaultCheckIdPrefix;
    private static DateTime lastWriteTime;
    private static bool lastWriteTimeInitialized;
    private string id;
    private PropertyDescriptorCollection propertyDescriptors;
    private Dictionary`2<string, Rule> rules;
    private StyleCopCore core;
    private string description;
    private string name;
    public StyleCopCore Core { get; }
    public string Description { get; }
    public string Id { get; }
    public string Name { get; }
    public PropertyDescriptorCollection PropertyDescriptors { get; }
    public ICollection`1<IPropertyControlPage> SettingsPages { get; }
    public DateTime TimeStamp { get; }
    internal IEnumerable`1<Rule> AddInRules { get; }
    public StyleCopCore get_Core();
    public string get_Description();
    public string get_Id();
    public string get_Name();
    public virtual PropertyDescriptorCollection get_PropertyDescriptors();
    public virtual ICollection`1<IPropertyControlPage> get_SettingsPages();
    public DateTime get_TimeStamp();
    internal IEnumerable`1<Rule> get_AddInRules();
    public void AddViolation(ICodeElement element, string ruleName, Object[] values);
    public void AddViolation(ICodeElement element, Enum ruleName, Object[] values);
    public void AddViolation(ICodeElement element, CodeLocation location, string ruleName, Object[] values);
    public void AddViolation(ICodeElement element, int line, string ruleName, Object[] values);
    public void AddViolation(ICodeElement element, CodeLocation location, Enum ruleName, Object[] values);
    public void AddViolation(ICodeElement element, int line, Enum ruleName, Object[] values);
    public void ClearSetting(WritableSettings settings, string propertyName);
    public Rule GetRule(string ruleName);
    public PropertyValue GetRuleSetting(Settings settings, string ruleName, string propertyName);
    public PropertyValue GetSetting(Settings settings, string propertyName);
    public virtual void InitializeAddIn();
    public virtual bool IsRuleEnabled(CodeDocument document, string ruleName);
    public virtual bool IsRuleSuppressed(ICodeElement element, string ruleCheckId, string ruleName, string ruleNamespace);
    public void SetSetting(WritableSettings settings, PropertyValue property);
    public virtual void SolutionClosing();
    public virtual void SolutionOpened();
    internal static string GetIdFromAddInType(Type addInType);
    internal void Initialize(StyleCopCore styleCopCore, XmlDocument initializationXml, bool topMostType, bool isKnownAssembly);
    protected virtual void ImportInitializationXml(XmlDocument document, bool topmostType, bool isKnownAssembly);
    private static string TrimXmlContent(string content);
    private void AddRulesFromXml(XmlNode rulesNode, string ruleGroup, bool isKnownAssembly);
}
[AttributeUsageAttribute("4")]
public class StyleCop.StyleCopAddInAttribute : Attribute {
    private string addInXmlId;
    public string AddInXmlId { get; }
    public StyleCopAddInAttribute(string addInXmlId);
    public string get_AddInXmlId();
}
public class StyleCop.StyleCopConsole : StyleCopRunner {
    private string outputFile;
    private string settingsPath;
    public StyleCopConsole(string settings, bool writeResultsCache, string outputFile, ICollection`1<string> addInPaths, bool loadFromDefaultPath);
    public StyleCopConsole(string settings, bool writeResultsCache, string outputFile, ICollection`1<string> addInPaths, bool loadFromDefaultPath, object hostTag);
    public bool Start(IList`1<CodeProject> projects, bool fullAnalyze);
    private void LoadSettingsFiles(IList`1<CodeProject> projects);
}
public class StyleCop.StyleCopCore : object {
    internal static string ProjectSettingsPropertyPageIdProperty;
    private static DateTime lastWriteTime;
    private static bool lastWriteTimeInitialized;
    private string versionNumberMajorMinor;
    private string versionNumberFull;
    private bool analyzing;
    private bool cancel;
    private bool writeResultsCache;
    private bool displayUI;
    private Dictionary`2<string, SourceParser> parsers;
    private Dictionary`2<string, SourceAnalyzer> analyzers;
    private StyleCopEnvironment environment;
    private RegistryUtils registry;
    private CoreParser coreParser;
    private object hostTag;
    [CompilerGeneratedAttribute]
private EventHandler`1<ViolationEventArgs> ViolationEncountered;
    [CompilerGeneratedAttribute]
private EventHandler`1<OutputEventArgs> OutputGenerated;
    [CompilerGeneratedAttribute]
private EventHandler ProjectSettingsChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddSettingsPagesEventArgs> AddSettingsPages;
    public static PlatformID PlatformID { get; }
    public bool Analyzing { get; }
    public bool Cancel { get; public set; }
    public DateTime TimeStamp { get; }
    public bool WriteResultsCache { get; public set; }
    public bool DisplayUI { get; public set; }
    public ICollection`1<SourceParser> Parsers { get; }
    public StyleCopEnvironment Environment { get; }
    public RegistryUtils Registry { get; }
    public PropertyDescriptorCollection PropertyDescriptors { get; }
    public object HostTag { get; }
    internal CoreParser CoreViolations { get; }
    private string VersionNumberMajorMinor { get; }
    private string VersionNumberFull { get; }
    public StyleCopCore(StyleCopEnvironment environment);
    public StyleCopCore(StyleCopEnvironment environment, object hostTag);
    [CompilerGeneratedAttribute]
public void add_ViolationEncountered(EventHandler`1<ViolationEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ViolationEncountered(EventHandler`1<ViolationEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OutputGenerated(EventHandler`1<OutputEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OutputGenerated(EventHandler`1<OutputEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProjectSettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProjectSettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_AddSettingsPages(EventHandler`1<AddSettingsPagesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AddSettingsPages(EventHandler`1<AddSettingsPagesEventArgs> value);
    public static PlatformID get_PlatformID();
    public bool get_Analyzing();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DateTime get_TimeStamp();
    public bool get_WriteResultsCache();
    public void set_WriteResultsCache(bool value);
    public bool get_DisplayUI();
    public void set_DisplayUI(bool value);
    public ICollection`1<SourceParser> get_Parsers();
    public StyleCopEnvironment get_Environment();
    public RegistryUtils get_Registry();
    public sealed virtual PropertyDescriptorCollection get_PropertyDescriptors();
    public object get_HostTag();
    internal CoreParser get_CoreViolations();
    private string get_VersionNumberMajorMinor();
    private string get_VersionNumberFull();
    public static XmlDocument LoadAddInResourceXml(Type addInType, string resourceId);
    public void Initialize(ICollection`1<string> addInPaths, bool loadFromDefaultPath);
    public void Analyze(IList`1<CodeProject> projects);
    public void Analyze(IList`1<CodeProject> projects, string settingsFilePath);
    public void FullAnalyze(IList`1<CodeProject> projects);
    public void FullAnalyze(IList`1<CodeProject> projects, string settingsFilePath);
    public bool ShowSettings(string settingsFilePath);
    public SourceAnalyzer GetAnalyzer(string analyzerId);
    public SourceParser GetParser(string parserId);
    public StyleCopAddIn GetAddIn(string addInId);
    internal static List`1<IPropertyControlPage> GetSettingsPages(StyleCopCore core);
    internal static string CleanPath(string path);
    internal void AddViolation(SourceCode sourceCode, Violation violation);
    internal void AddViolation(ICodeElement element, Violation violation);
    internal void AddViolation(ICodeElement element, Rule type, CodeLocation location, Object[] values);
    internal void AddViolation(ICodeElement element, Rule type, int line, Object[] values);
    internal void AddViolation(SourceCode sourceCode, Rule type, int line, Object[] values);
    internal void SignalOutput(string output);
    internal void SignalOutput(MessageImportance importance, string output);
    internal bool ShowSettings(string settingsPath, string id);
    internal bool ShowProjectSettings(string settingsPath, IList`1<IPropertyControlPage> pages, string id);
    internal bool ShowProjectSettings(WritableSettings settings, IList`1<IPropertyControlPage> pages, string id);
    private static bool CompareCachedConfiguration(Configuration configuration, string flagList);
    private static void InitializeProjectForAnalysis(CodeProject project, Data data, ResultsCache cache);
    private static Type GetNextAddInAttributeType(Type addInType, Type attributeType, Object& attribute);
    private static bool ComparePublicKeys(Byte[] key1, Byte[] key2);
    private void OnViolationEncountered(ViolationEventArgs e);
    private void OnOutputGenerated(OutputEventArgs e);
    private void OnProjectSettingsChanged(EventArgs e);
    private void OnAddSettingsPages(AddSettingsPagesEventArgs e);
    private void LoadAddins(string path, Byte[] publicKey);
    private StyleCopAddIn InitializeAddIn(Type addInType, bool isKnownAssembly);
    private void Analyze(IList`1<CodeProject> projects, bool ignoreCache, string settingsPath);
    private bool RunWorkerThreads(Data data, int count);
}
public abstract class StyleCop.StyleCopEnvironment : object {
    [CompilerGeneratedAttribute]
private StyleCopCore <Core>k__BackingField;
    public StyleCopCore Core { get; internal set; }
    public bool SupportsLinkedSettings { get; }
    public bool SupportsResultsCache { get; }
    [CompilerGeneratedAttribute]
public StyleCopCore get_Core();
    [CompilerGeneratedAttribute]
internal void set_Core(StyleCopCore value);
    public abstract virtual bool get_SupportsLinkedSettings();
    public abstract virtual bool get_SupportsResultsCache();
    public abstract virtual void AddParser(SourceParser parser);
    public abstract virtual bool AddSourceCode(CodeProject project, string path, object context);
    public abstract virtual string GetDefaultSettingsPath();
    public abstract virtual string GetParentSettingsPath(string settingsPath);
    public abstract virtual Settings GetProjectSettings(CodeProject project, bool merge, Exception& exception);
    public Settings GetProjectSettings(CodeProject project, bool merge);
    public abstract virtual Settings GetSettings(string settingsPath, bool merge, Exception& exception);
    public Settings GetSettings(string settingsPath, bool merge);
    public abstract virtual WritableSettings GetWritableSettings(string settingsPath, Exception& exception);
    public WritableSettings GetWritableSettings(string settingsPath);
    public abstract virtual XmlDocument LoadResultsCache(string location);
    public abstract virtual void RemoveAnalysisResults(string location);
    public abstract virtual bool SaveAnalysisResults(string location, XmlDocument analysisResults, Exception& exception);
    public abstract virtual void SaveResultsCache(string location, XmlDocument resultsCache);
    public abstract virtual bool SaveSettings(WritableSettings settings, Exception& exception);
    public bool SaveSettings(WritableSettings settings);
}
public class StyleCop.StyleCopException : Exception {
    public StyleCopException(string message);
    public StyleCopException(string message, Exception innerException);
    private StyleCopException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum StyleCop.StyleCopLogLevel : Enum {
    public int value__;
    public static StyleCopLogLevel None;
    public static StyleCopLogLevel Low;
    public static StyleCopLogLevel Medium;
    public static StyleCopLogLevel High;
}
public class StyleCop.StyleCopObjectConsole : StyleCopRunner {
    private Settings defaultSettings;
    public StyleCopObjectConsole(ObjectBasedEnvironment environment, Settings defaultSettings, ICollection`1<string> addInPaths, bool loadFromDefaultPath);
    public StyleCopObjectConsole(ObjectBasedEnvironment environment, Settings defaultSettings, ICollection`1<string> addInPaths, bool loadFromDefaultPath, object hostTag);
    public bool Start(IList`1<CodeProject> projects);
    protected virtual Settings GetSettingsForProject(CodeProject project);
    private void LoadSettings(IList`1<CodeProject> projects);
}
public abstract class StyleCop.StyleCopRunner : object {
    private bool captureViolations;
    private StyleCopCore core;
    private int violationCount;
    private XmlDocument violations;
    [CompilerGeneratedAttribute]
private EventHandler`1<OutputEventArgs> OutputGenerated;
    [CompilerGeneratedAttribute]
private EventHandler`1<ViolationEventArgs> ViolationEncountered;
    public StyleCopCore Core { get; protected set; }
    protected bool CaptureViolations { get; protected set; }
    protected int ViolationCount { get; }
    protected XmlDocument Violations { get; }
    [CompilerGeneratedAttribute]
public void add_OutputGenerated(EventHandler`1<OutputEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OutputGenerated(EventHandler`1<OutputEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ViolationEncountered(EventHandler`1<ViolationEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ViolationEncountered(EventHandler`1<ViolationEventArgs> value);
    public StyleCopCore get_Core();
    protected void set_Core(StyleCopCore value);
    protected bool get_CaptureViolations();
    protected void set_CaptureViolations(bool value);
    protected int get_ViolationCount();
    protected XmlDocument get_Violations();
    protected void OnOutputGenerated(OutputEventArgs e);
    protected void OnViolationEncountered(ViolationEventArgs e);
    protected void Reset();
    private static string CreateSafeSectionName(string originalName);
    private void CoreOutputGenerated(object sender, OutputEventArgs e);
    private void CoreViolationEncountered(object sender, ViolationEventArgs e);
}
public class StyleCop.StyleCopTask : Task {
    private static int DefaultViolationLimit;
    private static string MSBuildErrorCode;
    private static string MSBuildSubCategory;
    private ITaskItem[] inputAdditionalAddinPaths;
    private bool inputCacheResults;
    private String[] inputDefineConstants;
    private bool inputForceFullAnalysis;
    private ITaskItem inputOverrideSettingsFile;
    private ITaskItem inputProjectFullPath;
    private ITaskItem[] inputSourceFiles;
    private bool inputTreatErrorsAsWarnings;
    private ITaskItem maxViolationCount;
    private ITaskItem outputFile;
    private bool succeeded;
    private int violationCount;
    private int violationLimit;
    public ITaskItem[] AdditionalAddinPaths { get; public set; }
    public bool CacheResults { get; public set; }
    public String[] DefineConstants { get; public set; }
    public bool ForceFullAnalysis { get; public set; }
    public ITaskItem MaxViolationCount { get; public set; }
    public ITaskItem OutputFile { get; public set; }
    public ITaskItem OverrideSettingsFile { get; public set; }
    public ITaskItem ProjectFullPath { get; public set; }
    public ITaskItem[] SourceFiles { get; public set; }
    public bool TreatErrorsAsWarnings { get; public set; }
    [OutputAttribute]
public int ViolationCount { get; }
    public ITaskItem[] get_AdditionalAddinPaths();
    public void set_AdditionalAddinPaths(ITaskItem[] value);
    public bool get_CacheResults();
    public void set_CacheResults(bool value);
    public String[] get_DefineConstants();
    public void set_DefineConstants(String[] value);
    public bool get_ForceFullAnalysis();
    public void set_ForceFullAnalysis(bool value);
    public ITaskItem get_MaxViolationCount();
    public void set_MaxViolationCount(ITaskItem value);
    public ITaskItem get_OutputFile();
    public void set_OutputFile(ITaskItem value);
    public ITaskItem get_OverrideSettingsFile();
    public void set_OverrideSettingsFile(ITaskItem value);
    public ITaskItem get_ProjectFullPath();
    public void set_ProjectFullPath(ITaskItem value);
    public ITaskItem[] get_SourceFiles();
    public void set_SourceFiles(ITaskItem[] value);
    public bool get_TreatErrorsAsWarnings();
    public void set_TreatErrorsAsWarnings(bool value);
    public int get_ViolationCount();
    public virtual bool Execute();
    private void OnOutputGenerated(object sender, OutputEventArgs e);
    private void OnViolationEncountered(object sender, ViolationEventArgs e);
}
internal class StyleCop.StyleCopThread : object {
    private Data data;
    private bool complete;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ThreadCompleted;
    public bool Complete { get; }
    public StyleCopThread(Data data);
    [CompilerGeneratedAttribute]
public void add_ThreadCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ThreadCompleted(EventHandler`1<EventArgs> value);
    public bool get_Complete();
    public void DoWork(object sender);
    private static string FormatExceptionMessage(Exception ex);
    private static string GetRelativeFileName(SourceCode sourceCode);
    private static string GetSignalOutputGetText(SourceCode sourceCode);
    private bool LoadSourceCodeFromResultsCache(SourceCode sourceCode);
    private void ParseAndAnalyzeDocument(SourceCode sourceCode, DocumentAnalysisStatus documentStatus);
    private void RunAnalyzers(CodeDocument document, SourceParser parser, IEnumerable`1<SourceAnalyzer> analyzers);
    private bool TestAndRunAnalyzers(CodeDocument document, SourceParser parser, IEnumerable`1<SourceAnalyzer> analyzers, int passNumber);
}
public class StyleCop.StyleCopWebClient : WebClient {
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    public int Timeout { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(int value);
    protected virtual WebRequest GetWebRequest(Uri address);
}
public class StyleCop.SyntaxException : Exception {
    private int lineNumber;
    private SourceCode sourceCode;
    public int LineNumber { get; }
    public SourceCode SourceCode { get; }
    public SyntaxException(SourceCode sourceCode, int lineNumber);
    public SyntaxException(SourceCode sourceCode, int lineNumber, string message);
    public SyntaxException(SourceCode sourceCode, int lineNumber, Exception innerException);
    public SyntaxException(SourceCode sourceCode, int lineNumber, string message, Exception innerException);
    private SyntaxException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public int get_LineNumber();
    public SourceCode get_SourceCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class StyleCop.UnixNativeMethods : object {
    internal static string GetUnixKernelName();
    private static void UnixKernelName(UnixNameStruct& unixKernelStruct);
}
public class StyleCop.Utils : object {
    public static bool DetectIfByteArrayIsUtf8(IList`1<byte> buffer, int length);
    public static T GetAssemblyAttribute(Assembly assembly);
    public static string GetDisplayUserName();
    public static Encoding GetFileEncoding(string path);
    public static bool InputMatchesRegExPattern(string input, IEnumerable`1<string> patterns);
    public static string MakeAbsolutePath(string rootFolder, string relativePath);
    public static string ReplaceTokenVariables(string value, FileInfo file);
}
public static class StyleCop.V101Settings : object {
    public static string DefaultFileName;
    internal static void Load(XmlDocument document, Settings settings);
    private static void AddBooleanProperty(string propertyName, bool value, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void AddOrUpdateLegacyBooleanProperty(string ruleName, bool value, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void EnableDisableAnalyzerRules(XmlNode disabledAnalyzersNode, Settings settings, bool enabled);
    private static void LoadAnalyzeDesignerFilesSetting(Settings settings, string nodeText);
    private static void LoadAnalyzerSetting(Settings settings, string analyzerId, string propertyName, string nodeText);
    private static void LoadLegacyAnalyzerSetting(Settings settings, string analyzerId, string propertyName, string nodeText);
    private static void LoadValidPrefixes(XmlNode validPrefixesNode, Settings settings);
    private static string MapAnalyzerId(string analyzerId);
    private static ICollection`1<string> MapAnalyzerToRules(string analyzerId);
}
internal static class StyleCop.V102Settings : object {
    public static void ChangeAnalyzerSettingName(XmlDocument document, string analyzerName, string legacyPropertyName, string newPropertyName);
    public static void Load(XmlDocument document, Settings settings);
    private static void AddBooleanProperty(string propertyName, bool value, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void AddOrUpdateLegacyBooleanProperty(string ruleName, bool value, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadAnalyzerSettings(XmlDocument document, Settings settings);
    private static void LoadBooleanProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors, string legacyAnalyzerId);
    private static void LoadCollectionProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadIntProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadParserSettings(XmlDocument document, Settings settings);
    private static void LoadPropertyCollection(XmlNode propertyCollectionNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors, string legacyAnalyzerId);
    private static void LoadRulesSettings(XmlNode addInNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadStringProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static string MapAnalyzerId(string analyzerId);
    private static ICollection`1<string> MapAnalyzerToRules(string analyzerId);
}
internal static class StyleCop.V103Settings : object {
    public static void Load(XmlDocument document, Settings settings);
    public static void MoveRuleToNewAnalyzer(XmlDocument document, string legacyAnalyzerName, string newAnalyzerName, string ruleName);
}
internal static class StyleCop.V104Settings : object {
    public static void Load(XmlDocument document, Settings settings);
    public static void Load(XmlNode documentRoot, Settings settings);
    private static string ConvertLegacyAddInName(string addInName);
    private static PropertyType DeterminePropertyNodeType(string propertyType);
    private static void LoadAnalyzerSettings(XmlNode documentRoot, Settings settings);
    private static void LoadBooleanProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadCollectionProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadFileLists(XmlNode documentRoot, Settings settings);
    private static void LoadIntProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadParserSettings(XmlNode documentRoot, Settings settings);
    private static void LoadPropertyCollection(XmlNode propertyCollectionNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors, string ruleName);
    private static void LoadRulesSettings(XmlNode addInNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadStringProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
}
internal static class StyleCop.V105Settings : object {
    public static void Load(XmlDocument document, Settings settings);
    public static void Load(XmlNode documentRoot, Settings settings);
    private static string ConvertLegacyAddInName(string addInName);
    private static PropertyType DeterminePropertyNodeType(string propertyType);
    private static void LoadAnalyzerSettings(XmlNode documentRoot, Settings settings);
    private static void LoadBooleanProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadCollectionProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadFileLists(XmlNode documentRoot, Settings settings);
    private static void LoadIntProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadParserSettings(XmlNode documentRoot, Settings settings);
    private static void LoadPropertyCollection(XmlNode propertyCollectionNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors, string ruleName);
    private static void LoadRulesSettings(XmlNode addInNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
    private static void LoadStringProperty(string propertyName, XmlNode propertyNode, PropertyCollection properties, PropertyDescriptorCollection propertyDescriptors);
}
public class StyleCop.Violation : object {
    private ICodeElement element;
    private int line;
    private Nullable`1<CodeLocation> location;
    private string message;
    private Rule rule;
    private SourceCode sourceCode;
    private int key;
    public ICodeElement Element { get; }
    public int Key { get; }
    public int Line { get; }
    public Nullable`1<CodeLocation> Location { get; }
    public string Message { get; }
    public Rule Rule { get; }
    public SourceCode SourceCode { get; }
    internal Violation(Rule rule, ICodeElement element, CodeLocation location, string message);
    internal Violation(Rule rule, ICodeElement element, int line, string message);
    internal Violation(Rule rule, SourceCode sourceCode, CodeLocation location, string message);
    internal Violation(Rule rule, SourceCode sourceCode, int line, string message);
    public ICodeElement get_Element();
    public int get_Key();
    public int get_Line();
    public Nullable`1<CodeLocation> get_Location();
    public string get_Message();
    public Rule get_Rule();
    public SourceCode get_SourceCode();
    private void UpdateKey();
}
public class StyleCop.ViolationEventArgs : EventArgs {
    private Violation violation;
    public ICodeElement Element { get; }
    public int LineNumber { get; }
    public Nullable`1<CodeLocation> Location { get; }
    public string Message { get; }
    public SourceCode SourceCode { get; }
    public Violation Violation { get; }
    public bool Warning { get; }
    internal ViolationEventArgs(Violation violation);
    public ICodeElement get_Element();
    public int get_LineNumber();
    public Nullable`1<CodeLocation> get_Location();
    public string get_Message();
    public SourceCode get_SourceCode();
    public Violation get_Violation();
    public bool get_Warning();
}
public class StyleCop.WritableSettings : Settings {
    private static string CurrentSettingsVersion;
    public WritableSettings(StyleCopCore core, string location, XmlDocument contents, DateTime writeTime);
    public static XmlDocument NewDocument();
    public void ClearAddInSetting(StyleCopAddIn addIn, string propertyName);
    public void SetAddInSetting(StyleCopAddIn addIn, PropertyValue property);
    public XmlDocument WriteSettingsToDocument(StyleCopEnvironment environment);
    private static bool SaveBooleanProperty(XmlNode rootNode, BooleanProperty property, string propertyName);
    private static bool SaveCollectionProperty(XmlNode rootNode, CollectionProperty property, string propertyName);
    private static bool SaveIntProperty(XmlNode rootNode, IntProperty property, string propertyName);
    private static bool SavePropertyCollection(XmlNode rootNode, string nodeName, PropertyCollection properties, PropertyCollection parentProperties, bool aggregate, string nodeNameAttribute);
    private static bool SavePropertyValue(XmlNode rootCollectionNode, PropertyValue property, string propertyName);
    private static bool SaveRuleProperty(XmlNode rootNode, PropertyValue property, string ruleName, string propertyName);
    private static bool SaveStringProperty(XmlNode rootNode, StringProperty property, string propertyName);
    private void SaveSettingsIntoXmlDocument(XmlDocument document, StyleCopEnvironment environment, XmlElement rootElement, Settings settingsToSave);
}
[ExtensionAttribute]
public static class System.Reflection.ParameterInfoExtensions : object {
    [ExtensionAttribute]
public static bool HasCustomAttribute(ParameterInfo parameterInfo, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsByRefOrOut(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool IsByRefOutOrReturnValue(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool IsInOrByRef(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool IsReturnValue(ParameterInfo parameterInfo);
}
[ExtensionAttribute]
public static class System.StringExtensions : object {
    [ExtensionAttribute]
public static string Capitalize(string s);
    [ExtensionAttribute]
public static string FormatWith(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
    [ExtensionAttribute]
public static bool HasValue(string s);
    [ExtensionAttribute]
public static bool IsMatch(string s, string regex);
    [ExtensionAttribute]
public static bool IsMatch(string s, string regex, RegexOptions options);
    [ExtensionAttribute]
public static string JoinWith(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static string SubstringAfter(string s, char c);
    [ExtensionAttribute]
public static string SubstringAfter(string s, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string SubstringAfterLast(string s, char c);
    [ExtensionAttribute]
public static string SubstringBefore(string s, char c);
    [ExtensionAttribute]
public static string SubstringBefore(string s, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string SubstringBeforeLast(string s, char c);
    [ExtensionAttribute]
public static string SubstringBeforeLast(string s, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string Truncate(string s, int length);
}
[ExtensionAttribute]
public static class System.TypeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetAssignableToTypes(Type type);
    [ExtensionAttribute]
public static Type GetGenericParameterDefinition(Type parameterType);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetTypeHierarchy(Type type);
    [ExtensionAttribute]
public static bool HasCustomAttribute(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsInteger(Type type);
    [ExtensionAttribute]
public static bool IsNullableT(Type type);
    [ExtensionAttribute]
public static bool IsSignedInteger(Type type);
    [ExtensionAttribute]
public static bool IsUnsignedInteger(Type type);
    [ExtensionAttribute]
public static bool MeetsGenericParameterConstraints(Type type, Type parameterType);
    [ExtensionAttribute]
public static Type RemoveByRefModifier(Type type);
    [ExtensionAttribute]
private static bool MeetsGenericParameterConstraint(Type type, Type constraintType);
}
