[CompilationMappingAttribute]
public static class String : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equals(string a, string b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equalsCaseInsensitive(string a, string b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equalsOrdinalCI(string str1, string str2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equalsConstantTime(string str1, string str2);
    public static string toLowerInvariant(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replace(string find, string replacement, string str);
    public static bool isEmpty(string s);
    public static string trim(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimc(char toTrim, string s);
    public static string trimStart(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> split(char c, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] splita(char c, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool startsWith(string substring, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contains(string substring, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string substring(int index, string s);
}
[CompilationMappingAttribute]
public static class Suave.Authentication : object {
    public static string UserNameKey { get; }
    public static string SessionAuthCookie { get; }
    public static string StateStoreType { get; }
    public static int SessionIdLength { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> deauthenticate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_UserNameKey();
    internal static Tuple`3<string, string, string> parseAuthenticationToken(string token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> authenticateBasicAsync(FSharpFunc`2<Tuple`2<string, string>, FSharpAsync`1<bool>> f, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> protectedPart);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<bool> func2@1(bool arg00);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> authenticateBasic(FSharpFunc`2<Tuple`2<string, string>, bool> f, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> protectedPart);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_SessionAuthCookie();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_StateStoreType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_SessionIdLength();
    internal static string parseData(string textBlob);
    internal static string generateData(HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> authenticate(CookieLife relativeExpiry, bool secure, FSharpFunc`2<Unit, FSharpChoice`2<Byte[], FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> missingCookie, FSharpFunc`2<SecretboxDecryptionError, FSharpChoice`2<Byte[], FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> decryptionFailure, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> fSuccess);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> func1@1-16(SecretboxDecryptionError x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> authenticateWithLogin(CookieLife relativeExpiry, string loginPage, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> fSuccess);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> authenticated(CookieLife relativeExpiry, bool secure);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_deauthenticate();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> deauthenticateWithLogin(string loginPage);
}
[CompilationMappingAttribute]
public static class Suave.Aux : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SelectResult split(ReadOnlySequence`1<byte> bufferSequence, int index, FSharpFunc`2<ReadOnlyMemory`1<byte>, FSharpFunc`2<int, SelectResult>> select);
}
[CompilationMappingAttribute]
public class Suave.BinaryFormatterSerialiser : object {
    private virtual override Byte[] Suave.CookieSerialiser.serialise(FSharpMap`2<string, object> m);
    private virtual override FSharpMap`2<string, object> Suave.CookieSerialiser.deserialise(Byte[] data);
}
[CompilationMappingAttribute]
public static class Suave.ByteConstants : object {
    [CompilationMappingAttribute]
public static Byte[] defaultContentTypeHeaderBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] serverHeaderBytes { get; }
    [CompilationMappingAttribute]
internal static string s@13 { get; }
    [CompilationMappingAttribute]
public static Byte[] contentEncodingBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] contentLengthBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] EOL { get; }
    [CompilationMappingAttribute]
public static Byte[] EOLEOL { get; }
    [CompilationMappingAttribute]
public static Byte[] httpVersionBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] spaceBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] dateBytes { get; }
    [CompilationMappingAttribute]
public static Byte[] colonBytes { get; }
    public static Byte[] get_defaultContentTypeHeaderBytes();
    public static Byte[] get_serverHeaderBytes();
    internal static string get_s@13();
    public static Byte[] get_contentEncodingBytes();
    public static Byte[] get_contentLengthBytes();
    public static Byte[] get_EOL();
    public static Byte[] get_EOLEOL();
    public static Byte[] get_httpVersionBytes();
    public static Byte[] get_spaceBytes();
    public static Byte[] get_dateBytes();
    public static Byte[] get_colonBytes();
}
[CompilationMappingAttribute]
public static class Suave.Compression : object {
    public static int MIN_BYTES_TO_COMPRESS { get; }
    public static int MAX_BYTES_TO_COMPRESS { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_MIN_BYTES_TO_COMPRESS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_MAX_BYTES_TO_COMPRESS();
    public static FSharpOption`1<Tuple`2<Algorithm, FSharpFunc`2<Byte[], Byte[]>>> loadEncoder(string s);
    public static FSharpOption`1<Tuple`2<Algorithm, FSharpFunc`2<Byte[], Byte[]>>> getEncoder(HttpRequest request);
    public static FSharpOption`1<Algorithm> parseEncoder(HttpRequest request);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Tuple`2<FSharpOption`1<Algorithm>, Byte[]>, Error>> transform(Byte[] content, HttpContext ctx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ValueTask compensation@1-1(FileStream resource, Unit unitVar0);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ValueTask compensation@1-2(GZipStream resource, Unit unitVar0);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ValueTask compensation@1-3(DeflateStream resource, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, a>> compress(Algorithm encoding, string path, Stream fs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<string, Error>> compressFile(Algorithm n, Stream stream, string compressionFolder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Tuple`2<FSharpOption`1<Algorithm>, Stream>, Error>> transformStream(string key, Stream stream, FSharpFunc`2<string, DateTime> getLast, bool compression, string compressionFolder, HttpContext ctx);
}
[CompilationMappingAttribute]
public class Suave.ConnectionFacade : object {
    internal FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart;
    internal HttpRuntime runtime;
    internal Logger logger;
    internal ConcurrentPool`1<ConnectionFacade> connectionPool;
    internal Connection connection;
    internal CancellationToken cancellationToken;
    internal HttpOutput httpOutput;
    internal HttpReader reader;
    internal List`1<HttpUpload> files;
    internal List`1<Tuple`2<string, string>> multiPartFields;
    internal Byte[] _rawForm;
    internal Connection Connection@;
    internal HttpRuntime Runtime@;
    public Connection Connection { get; public set; }
    public HttpRuntime Runtime { get; public set; }
    public ConnectionFacade(Connection connection, HttpRuntime runtime, Logger logger, ConcurrentPool`1<ConnectionFacade> connectionPool, CancellationToken cancellationToken, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Connection get_Connection();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_Connection(Connection v);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public HttpRuntime get_Runtime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_Runtime(HttpRuntime v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<Unit, Error>> parsePostData(int maxContentLength, FSharpChoice`2<string, b> contentLengthHeader, FSharpChoice`2<string, c> contentTypeHeader);
    public Task`1<FSharpResult`2<FSharpOption`1<HttpRequest>, Error>> processRequest();
    public Task`1<FSharpResult`2<bool, a>> exitHttpLoopWithError(Error err);
    public Task`1<FSharpResult`2<bool, Error>> loop();
    public void shutdown();
    public Task`1<FSharpRef`1<FSharpResult`2<Unit, Error>>> requestLoop();
    public Task`1<Unit> accept(SocketBinding binding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Task`1<FSharpResult`2<FSharpOption`1<HttpUpload>, Error>> readFilePart(string boundary, Dictionary`2<string, string> headerParams, string fieldName, string contentType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Task`1<FSharpResult`2<Unit, Error>> parseMultipartMixed(string fieldName, string boundary);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Task`1<FSharpResult`2<Unit, Error>> parseMultipart(string boundary);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Task`1<FSharpResult`2<Byte[], Error>> getRawPostData(int contentLength);
}
[CompilationMappingAttribute]
internal static class Suave.ContentRange : object {
    internal static Tuple`2<long, FSharpOption`1<long>> parseContentRange(string input);
    internal static FSharpOption`1<Tuple`2<long, FSharpOption`1<long>>> |ContentRange|_|(HttpContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Stream, long, long, HttpStatus> getFileStream(HttpContext ctx, string path);
}
[CompilationMappingAttribute]
public static class Suave.Control : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> CLOSE { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_CLOSE();
}
[CompilationMappingAttribute]
public static class Suave.Cookie : object {
    public static FSharpList`1<HttpCookie> parseCookies(string cookieString);
    internal static FSharpOption`1<SameSite> parseSameSite@43(string str);
    public static HttpCookie parseResultCookie(string cookieString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<string, HttpCookie> HttpRequest.get_cookies(HttpRequest );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<string, HttpCookie> HttpResult.get_cookies(HttpResult );
    internal static HttpCookie clientCookieFrom(HttpCookie httpCookie);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<HttpCookie, HttpCookie> slidingExpiry(CookieLife relativeExpiry, HttpCookie httpCookie);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setCookie(HttpCookie cookie);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unsetCookie(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setPair(HttpCookie httpCookie, HttpCookie clientCookie);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unsetPair(string httpCookieName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<HttpCookie, HttpCookie> generateCookies(Byte[] serverKey, string cookieName, CookieLife relativeExpiry, bool secure, Byte[] plainData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<Tuple`2<HttpCookie, Byte[]>, CookieError> readCookies(Byte[] key, string cookieName, FSharpMap`2<string, HttpCookie> cookies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> refreshCookies(CookieLife expiry, HttpCookie cookie);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> updateCookies(CookiesState csctx, FSharpFunc`2<FSharpOption`1<Byte[]>, Byte[]> fPlainText);
    internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setCookies@244(CookiesState csctx, Byte[] plainText);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> cookieState(CookiesState csctx, FSharpFunc`2<Unit, FSharpChoice`2<Byte[], FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> noCookie, FSharpFunc`2<SecretboxDecryptionError, FSharpChoice`2<Byte[], FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> decryptionFailure, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> fSuccess);
}
[CompilationMappingAttribute]
public interface Suave.CookieSerialiser {
    public abstract virtual Byte[] serialise(FSharpMap`2<string, object> );
    public abstract virtual FSharpMap`2<string, object> deserialise(Byte[] );
}
[CompilationMappingAttribute]
public static class Suave.CORS : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Origin;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlRequestMethod;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlRequestHeaders;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlAllowOrigin;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlAllowMethods;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlAllowHeaders;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlAllowCredentials;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlExposeHeaders;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AccessControlMaxAge;
    [CompilationMappingAttribute]
public static CORSConfig defaultCORSConfig { get; }
    private static CORS();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAllowedOrigin(CORSConfig config, string value);
    internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setMaxAgeHeader(CORSConfig config);
    internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setAllowCredentialsHeader(CORSConfig config);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setAllowMethodsHeader(CORSConfig config, string value);
    internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setExposeHeadersHeader(CORSConfig config);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<FSharpOption`1<HttpContext>> cors$cont@974(CORSConfig config, HttpContext ctx, HttpRequest req, FSharpChoice`2<string, string> matchValue, Unit unitVar);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> cors(CORSConfig config);
    public static CORSConfig get_defaultCORSConfig();
}
[CompilationMappingAttribute]
public static class Suave.Embedded : object {
    [CompilationMappingAttribute]
internal static Assembly defaultSourceAssembly { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browseDefaultAsssembly { get; }
    internal static Assembly get_defaultSourceAssembly();
    internal static FSharpFunc`2<b, DateTime> getLm@685-1(Assembly source);
    internal static FSharpFunc`2<Tuple`2<Connection, a>, Task`1<FSharpResult`2<Unit, Error>>> writeResource@683(Assembly source, bool compression, HttpContext ctx, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> sendResource(Assembly source, string resourceName, bool compression);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> sendResourceFromDefaultAssembly(string resourceName, bool compression);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> resource(Assembly source, string name);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> resourceFromDefaultAssembly(string name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> f@69-2(Assembly source, HttpContext ctx);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browse(Assembly source);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_browseDefaultAsssembly();
}
[CompilationMappingAttribute]
public static class Suave.EventSource : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string ES_EOL;
    [CompilationMappingAttribute]
internal static Memory`1<byte> ES_EOL_S { get; }
    private static EventSource();
    internal static Memory`1<byte> get_ES_EOL_S();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> asyncWrite(Connection out, string data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> op_LessLessDot(Connection out, string data);
    public static Task`1<FSharpResult`2<Unit, Error>> dispatch(Connection out);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> comment(Connection out, string cmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> eventType(Connection out, string eventType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> data(Connection out, string data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> esId(Connection out, string lastEventId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> retry(Connection out, UInt32 retry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> send(Connection out, Message msg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Task`1<FSharpResult`2<b, Error>> handShakeAux(FSharpFunc`2<Connection, a> f, Connection out, c _arg1);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> handShake(FSharpFunc`2<Connection, Task`1<FSharpResult`2<Unit, Error>>> fCont);
}
[CompilationMappingAttribute]
public static class Suave.Files : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browseHome { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> dirHome { get; }
    internal static Tuple`2<FSharpFunc`2<Tuple`2<Connection, a>, Task`1<FSharpResult`2<Unit, Error>>>, HttpStatus> writeFile@554(bool compression, HttpContext ctx, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> sendFile(string fileName, bool compression);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> file(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string resolvePath(string rootPath, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browseFile(string rootPath, string fileName);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browseFileHome(string fileName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> f@69(string rootPath, HttpContext ctx);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> browse(string rootPath);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_browseHome();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> f@69-1(HttpContext ctx);
    internal static string filesize@634(FileSystemInfo x);
    internal static void buildLine@643(StringBuilder result, FileSystemInfo x);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> dir(string rootPath);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_dirHome();
}
[CompilationMappingAttribute]
public static class Suave.Filters : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> isSecure { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> GET { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> POST { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> DELETE { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> PUT { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> HEAD { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> CONNECT { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> PATCH { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> TRACE { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> OPTIONS { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> path(string pathAfterDomain);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathCi(string pathAfterDomain);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathStarts(string pathAfterDomainSubstr);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathStartsCi(string pathAfterDomainSubstr);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> method(HttpMethod method);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_isSecure();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> hasFlag(string flag);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathRegex(string pathAfterDomainRegex);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> host(string hostname);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> serverHost(string hostname);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> clientHost(string hostname);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_GET();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_POST();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_DELETE();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_PUT();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_HEAD();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_CONNECT();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_PATCH();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_TRACE();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_OPTIONS();
    internal static string getUserName(HttpContext ctx);
    public static string logFormat(HttpContext ctx);
    public static Tuple`2<string, FSharpMap`2<string, object>> logFormatStructured(HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> logWithLevel(LogLevel level, Logger logger, FSharpFunc`2<HttpContext, string> messageFun);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> logWithLevelStructured(LogLevel level, Logger logger, FSharpFunc`2<HttpContext, Tuple`2<string, FSharpMap`2<string, object>>> messageFun);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> logStructured(Logger logger, FSharpFunc`2<HttpContext, Tuple`2<string, FSharpMap`2<string, object>>> messageFun);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> log(Logger logger, FSharpFunc`2<HttpContext, string> messageFun);
    internal static FSharpOption`1<t> scan@414(PrintfFormat`5<a, b, c, d, t> pf, string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathScan(PrintfFormat`5<a, b, c, d, t> pf, FSharpFunc`2<t, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>> h);
    internal static FSharpOption`1<t> scan@430-1(PrintfFormat`5<a, b, c, d, t> format, string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> pathScanCi(PrintfFormat`5<a, b, c, d, t> format, FSharpFunc`2<t, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>> handler);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<FSharpOption`1<HttpContext>> catchHandler@1-3(HttpContext ctx, Exception _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> timeoutWebPart(TimeSpan timeout, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> child);
}
[CompilationMappingAttribute]
public static class Suave.Globals : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<Unit, DateTimeOffset> utcNow { get; public set; }
    [CompilationMappingAttribute]
internal static FSharpRef`1<long> numberOfClients { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Tuple`2<string, DateTime>> compressedFilesMap { get; }
    [CompilationMappingAttribute]
public static string SuaveVersion { get; }
    public static string ServerHeader { get; }
    public static FSharpFunc`2<Unit, DateTimeOffset> get_utcNow();
    public static void set_utcNow(FSharpFunc`2<Unit, DateTimeOffset> value);
    internal static FSharpRef`1<long> get_numberOfClients();
    internal static ConcurrentDictionary`2<string, Tuple`2<string, DateTime>> get_compressedFilesMap();
    public static string get_SuaveVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_ServerHeader();
}
[CompilationMappingAttribute]
public static class Suave.Headers : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpOption`1<CultureInfo>> parseCultureInfo { get; }
    [CompilationMappingAttribute]
internal static HashSet`1<string> cultureNames@26 { get; }
    [CompilationMappingAttribute]
internal static CultureInfo[] arg@1-1 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<CultureInfo, string> mapping@29 { get; }
    [CompilationMappingAttribute]
internal static CultureInfo[] source@29 { get; }
    internal static string toLower(string s);
    public static FSharpOption`1<DateTime> parseDateTime(string s);
    public static FSharpOption`1<decimal> parseDecimal(string s);
    public static FSharpFunc`2<string, FSharpOption`1<CultureInfo>> get_parseCultureInfo();
    internal static HashSet`1<string> get_cultureNames@26();
    internal static CultureInfo[] get_arg@1-1();
    internal static FSharpFunc`2<CultureInfo, string> get_mapping@29();
    internal static CultureInfo[] get_source@29();
    internal static bool isValidCulture@31(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getFirstHeader(string name, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> getHeader(string name, HttpContext ctx);
    public static IDictionary`2<string, IEnumerable`1<string>> getHeaders(HttpContext ctx);
    public static IEnumerable`1<string> getSplitValues(IEnumerable`1<string> headers);
    public static IEnumerable`1<Tuple`2<string, decimal>> getWeightedValues(IEnumerable`1<string> splitValues);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<FSharpList`1<string>, string> getAll(FSharpList`1<Tuple`2<string, string>> target, string key);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Http : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int CompareTo$cont@214(HttpCookie this, HttpCookie obj, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int CompareTo$cont@214-1(IComparer comp, HttpCookie this, HttpCookie objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int GetHashCode$cont@214(IEqualityComparer comp, HttpCookie this, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool Equals$cont@214(HttpCookie this, object obj, IEqualityComparer comp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a request(FSharpFunc`2<HttpRequest, FSharpFunc`2<HttpContext, a>> apply, HttpContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a context(FSharpFunc`2<HttpContext, FSharpFunc`2<HttpContext, a>> apply, HttpContext context);
}
[CompilationMappingAttribute]
public class Suave.HttpOutput : object {
    internal HttpRuntime runtime;
    internal Connection connection;
    internal HttpContext freshContext;
    public HttpOutput(Connection connection, HttpRuntime runtime);
    public Task`1<FSharpResult`2<Unit, Error>> writeContentType(FSharpList`1<Tuple`2<string, string>> headers);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<Unit, Error>> writeContentLengthHeader(Byte[] content, HttpContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<Unit, Error>> writeHeaders(FSharpList`1<string> exclusions, IEnumerable`1<Tuple`2<string, string>> headers);
    public Task`1<FSharpResult`2<Unit, Error>> writePreamble(HttpResult response);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpFunc`2<HttpContent, Task`1<FSharpResult`2<Unit, Error>>> writeContent(bool writePreamble, HttpContext context);
    public FSharpAsync`1<FSharpOption`1<HttpContext>> executeTask(FSharpAsync`1<FSharpOption`1<HttpContext>> task);
    public Task`1<FSharpResult`2<Unit, Error>> writeResponse(HttpContext newCtx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<bool, Error>> run(HttpRequest request, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webPart);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Suave.HttpReader : object {
    internal TcpTransport transport;
    internal Pipe pipe;
    internal Byte[] lineBuffer;
    internal CancellationToken cancellationToken;
    internal bool running;
    public HttpReader(TcpTransport transport, Byte[] lineBuffer, Pipe pipe, CancellationToken cancellationToken);
    public void stop();
    public Task`1<FSharpResult`2<Unit, Error>> readMoreData();
    public Task`1<ReadResult> getData();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<ScanResult, Error>> scanMarker(Byte[] marker, FSharpFunc`2<ReadOnlyMemory`1<byte>, FSharpFunc`2<int, SelectResult>> select);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<int, Error>> readUntilPattern(Byte[] marker, FSharpFunc`2<ReadOnlyMemory`1<byte>, FSharpFunc`2<int, SelectResult>> select);
    public Task`1<ScanResult> skip(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<ScanResult> read(int n, FSharpFunc`2<ReadOnlyMemory`1<byte>, FSharpFunc`2<int, SelectResult>> select);
    public Task`1<FSharpResult`2<string, Error>> readLine();
    public Task`1<FSharpResult`2<FSharpList`1<Tuple`2<string, string>>, Error>> readHeaders();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Task`1<FSharpResult`2<Unit, Error>> readPostData(int bytes, FSharpFunc`2<ReadOnlyMemory`1<byte>, FSharpFunc`2<int, Unit>> select);
    public Task`1<FSharpRef`1<FSharpResult`2<Unit, Error>>> readLoop();
}
[CompilationMappingAttribute]
public static class Suave.Intermediate : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> CONTINUE { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> SWITCHING_PROTO { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_CONTINUE();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_SWITCHING_PROTO();
}
[CompilationMappingAttribute]
public static class Suave.Json : object {
    public static Byte[] toJson(T o);
    public static T fromJson(Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> mapJsonWith(FSharpFunc`2<Byte[], TIn> deserializer, FSharpFunc`2<TOut, Byte[]> serializer, FSharpFunc`2<TIn, TOut> f);
    public static FSharpFunc`2<FSharpFunc`2<T1, T2>, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>> mapJson();
}
[CompilationMappingAttribute]
public class Suave.Logging.CombiningTarget : object {
    internal FSharpList`1<Logger> otherLoggers;
    internal String[] name@773;
    public CombiningTarget(String[] name, FSharpList`1<Logger> otherLoggers);
    private virtual override String[] Suave.Logging.Logger.get_name();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override FSharpAsync`1<Unit> Suave.Logging.Logger.logWithAck(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void Suave.Logging.Logger.log(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
}
[CompilationMappingAttribute]
public static class Suave.Logging.DateTime : object {
    public static long timestamp(DateTime dt);
    public static long ticksUTC(long epoch);
}
[CompilationMappingAttribute]
public static class Suave.Logging.DateTimeOffset : object {
    public static long timestamp(DateTimeOffset dt);
    public static long ticksUTC(long epoch);
}
[CompilationMappingAttribute]
internal static class Suave.Logging.Formatting : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static void foundProp$cont@486(LiterateOptions options, List`1<Tuple`2<string, LiterateToken>> themedParts, List`1<string> matchedFields, Property prop, FSharpOption`1<object> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpSet`1<string>, FSharpList`1<Tuple`2<string, LiterateToken>>> literateFormatValue(LiterateOptions options, FSharpMap`2<string, object> fields, PointValue _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpSet`1<string>, string> formatValue(FSharpMap`2<string, object> fields, PointValue pv);
    internal static FSharpList`1<Tuple`2<string, LiterateToken>> go@523-7(StringReader exnLines, FSharpList`1<Tuple`2<string, LiterateToken>> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, LiterateToken>> literateExceptionColouriser(LiterateOptions options, Exception ex);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, LiterateToken>> literateColouriseExceptions(LiterateOptions context, Message message);
    internal static LiterateToken getLogLevelToken(LogLevel _arg1);
    internal static Tuple`2<string, LiterateToken> formatLocalTime@567(LiterateOptions options, long utcTicks);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, LiterateToken>> literateDefaultTokeniser(LiterateOptions options, Message message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void literateDefaultColourWriter(a sem, FSharpList`1<Tuple`2<string, ConsoleColor>> parts);
    internal static string formatLevel@602(LogLevel level);
    internal static string formatExn@611(FSharpMap`2<string, object> fields);
    internal static string formatFields@618(FSharpSet`1<string> ignored, FSharpMap`2<string, object> fields);
    internal static string defaultFormatter(Message message);
}
[CompilationMappingAttribute]
internal static class Suave.Logging.FsMtParser : object {
    internal static void go@462-6(string template, FSharpFunc`2<string, Unit> foundTextF, FSharpFunc`2<Property, Unit> foundPropF, int tlen, int start);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void parseParts(string template, FSharpFunc`2<string, Unit> foundTextF, FSharpFunc`2<Property, Unit> foundPropF);
}
[CompilationMappingAttribute]
public static class Suave.Logging.Global : object {
    [CompilationMappingAttribute]
internal static object consoleSemaphore { get; }
    [CompilationMappingAttribute]
public static LoggingConfig defaultConfig { get; }
    [CompilationMappingAttribute]
internal static FSharpRef`1<Tuple`2<LoggingConfig, UInt32>> config { get; }
    internal static object get_consoleSemaphore();
    public static LoggingConfig get_defaultConfig();
    internal static FSharpRef`1<Tuple`2<LoggingConfig, UInt32>> get_config();
    internal static Flyweight getStaticLogger(String[] name);
    public static long timestamp();
    internal static object semaphore();
    internal static a lockSem(FSharpFunc`2<Unit, a> fn);
    public static void initialise(LoggingConfig cfg);
    public static void initialiseIfDefault(LoggingConfig cfg);
}
[CompilationMappingAttribute]
public static class Suave.Logging.Literals : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string FieldExnKey;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string FieldErrorsKey;
    public static UInt32 FacadeVersion { get; }
    public static string FacadeLanguage { get; }
    private static Literals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static UInt32 get_FacadeVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_FacadeLanguage();
}
[CompilationMappingAttribute]
public static class Suave.Logging.Literate : object {
}
[CompilationMappingAttribute]
public class Suave.Logging.LiterateConsoleTarget : object {
    internal String[] name@716;
    internal LogLevel minLevel;
    internal LiterateOptions options@718;
    internal FSharpFunc`2<LiterateOptions, FSharpFunc`2<Message, FSharpList`1<Tuple`2<string, LiterateToken>>>> tokenise;
    internal FSharpFunc`2<FSharpList`1<Tuple`2<string, ConsoleColor>>, Unit> colourWriter;
    public LiterateConsoleTarget(String[] name, LogLevel minLevel, FSharpOption`1<LiterateOptions> options, FSharpOption`1<FSharpFunc`2<LiterateOptions, FSharpFunc`2<Message, FSharpList`1<Tuple`2<string, LiterateToken>>>>> literateTokeniser, FSharpOption`1<FSharpFunc`2<object, FSharpFunc`2<FSharpList`1<Tuple`2<string, ConsoleColor>>, Unit>>> outputWriter, FSharpOption`1<object> consoleSemaphore);
    public LiterateConsoleTarget(String[] name, LogLevel minLevel, string outputTemplate, FSharpOption`1<LiterateOptions> options, FSharpOption`1<FSharpFunc`2<object, FSharpFunc`2<FSharpList`1<Tuple`2<string, ConsoleColor>>, Unit>>> outputWriter, FSharpOption`1<object> consoleSemaphore);
    private virtual override String[] Suave.Logging.Logger.get_name();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override FSharpAsync`1<Unit> Suave.Logging.Logger.logWithAck(LogLevel level, FSharpFunc`2<LogLevel, Message> msgFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void Suave.Logging.Logger.log(LogLevel level, FSharpFunc`2<LogLevel, Message> msgFactory);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Tuple`2<string, ConsoleColor>> colouriseThenNewLine(Message message);
}
[CompilationMappingAttribute]
internal static class Suave.Logging.LiterateFormatting : object {
    internal static IEnumerable`1<TemplateToken> parseTemplate(string template);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static IEnumerable`1<Tuple`2<string, LiterateToken>> tokeniserForOutputTemplate$cont@700(LiterateOptions options, Message message, TemplateToken token, Unit unitVar);
    internal static FSharpFunc`2<LiterateOptions, FSharpFunc`2<Message, FSharpList`1<Tuple`2<string, LiterateToken>>>> tokeniserForOutputTemplate(string template);
}
[CompilationMappingAttribute]
public static class Suave.Logging.Log : object {
    public static Logger create(string name);
    public static Logger createHiera(String[] name);
}
[CompilationMappingAttribute]
public interface Suave.Logging.Logger {
    public String[] name { get; }
    public abstract virtual String[] get_name();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual FSharpAsync`1<Unit> logWithAck(LogLevel , FSharpFunc`2<LogLevel, Message> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void log(LogLevel , FSharpFunc`2<LogLevel, Message> );
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Logging.LoggerEx : object {
    [ConditionalAttribute("DEBUG")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.verbose(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [ConditionalAttribute("DEBUG")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.debug(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.info(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.warn(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.error(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.fatal(Logger x, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Logger.logSimple(Logger x, Message message);
}
[CompilationMappingAttribute]
public class Suave.Logging.LoggingConfig : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Unit, long> timestamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<String[], Logger> getLogger@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal object consoleSemaphore@;
    [CompilationMappingAttribute]
public FSharpFunc`2<Unit, long> timestamp { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<String[], Logger> getLogger { get; }
    [CompilationMappingAttribute]
public object consoleSemaphore { get; }
    public LoggingConfig(FSharpFunc`2<Unit, long> timestamp, FSharpFunc`2<String[], Logger> getLogger, object consoleSemaphore);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<Unit, long> get_timestamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<String[], Logger> get_getLogger();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public object get_consoleSemaphore();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Suave.Logging.LogLevel : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Verbose;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Debug;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Info;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Warn;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Error;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LogLevel _unique_Fatal;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Verbose { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVerbose { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Debug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDebug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Info { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Warn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LogLevel Fatal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFatal { get; }
    private static LogLevel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LogLevel(int _tag);
    [CompilationMappingAttribute]
public static LogLevel get_Verbose();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVerbose();
    [CompilationMappingAttribute]
public static LogLevel get_Debug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDebug();
    [CompilationMappingAttribute]
public static LogLevel get_Info();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfo();
    [CompilationMappingAttribute]
public static LogLevel get_Warn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarn();
    [CompilationMappingAttribute]
public static LogLevel get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilationMappingAttribute]
public static LogLevel get_Fatal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFatal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    public virtual string ToString();
    public static LogLevel ofString(string str);
    public int toInt();
    public static LogLevel ofInt(int i);
    public static bool op_LessThan(IComparable`1<LogLevel> a, LogLevel b);
    public static bool op_LessThanOrEqual(IComparable`1<LogLevel> a, LogLevel b);
    public static bool op_GreaterThan(IComparable`1<LogLevel> a, LogLevel b);
    public static bool op_GreaterThanOrEqual(IComparable`1<LogLevel> a, LogLevel b);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    private virtual override int System.IComparable<Suave.Logging.LogLevel>.CompareTo(LogLevel other);
    private virtual override int System.IComparable.CompareTo(object other);
    private virtual override bool System.IEquatable<Suave.Logging.LogLevel>.Equals(LogLevel other);
}
[CompilationMappingAttribute]
public class Suave.Logging.Message : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal PointValue value@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, object> fields@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal long timestamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal LogLevel level@;
    [CompilationMappingAttribute]
public String[] name { get; }
    [CompilationMappingAttribute]
public PointValue value { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<string, object> fields { get; }
    [CompilationMappingAttribute]
public long timestamp { get; }
    [CompilationMappingAttribute]
public LogLevel level { get; }
    public long utcTicks { get; }
    public Unit README { get; }
    public Message(String[] name, PointValue value, FSharpMap`2<string, object> fields, long timestamp, LogLevel level);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PointValue get_value();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<string, object> get_fields();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public long get_timestamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public LogLevel get_level();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public long get_utcTicks();
    public void get_README();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(Message obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Suave.Logging.MessageModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message event(LogLevel level, string template);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message eventX(string template, LogLevel level);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message gauge(long value, string units);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setName(String[] name, Message x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setNameEnding(string ending, Message x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setSingleName(string name, Message x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setField(string key, object value, Message x);
    public static FSharpFunc`2<string, FSharpFunc`2<a, FSharpFunc`2<Message, Message>>> setFieldValue();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setTimestamp(long ts, Message x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message setLevel(LogLevel level, Message x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Message addExn(a ex, Message x);
}
[CompilationMappingAttribute]
public class Suave.Logging.OutputWindowTarget : object {
    internal String[] name@759;
    internal LogLevel minLevel;
    public OutputWindowTarget(String[] name, LogLevel minLevel, FSharpOption`1<FSharpFunc`2<Message, string>> formatter);
    private virtual override String[] Suave.Logging.Logger.get_name();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void Suave.Logging.Logger.log(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override FSharpAsync`1<Unit> Suave.Logging.Logger.logWithAck(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void log@761(Message msg);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Suave.Logging.PointValue : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGauge { get; }
    [CompilationMappingAttribute]
public static PointValue NewEvent(string _template);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute]
public static PointValue NewGauge(long _value, string _units);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGauge();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(PointValue obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(PointValue obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Suave.Logging.Targets : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Logger create(LogLevel level, String[] name);
}
[CompilationMappingAttribute]
public class Suave.Logging.TextWriterTarget : object {
    internal TextWriter writer;
    internal String[] name@746;
    internal LogLevel minLevel;
    internal FSharpFunc`2<Message, string> formatter@747;
    public TextWriterTarget(String[] name, LogLevel minLevel, TextWriter writer, FSharpOption`1<FSharpFunc`2<Message, string>> formatter);
    private virtual override String[] Suave.Logging.Logger.get_name();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void Suave.Logging.Logger.log(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override FSharpAsync`1<Unit> Suave.Logging.Logger.logWithAck(LogLevel level, FSharpFunc`2<LogLevel, Message> messageFactory);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void log@748(Message msg);
}
[CompilationMappingAttribute]
public class Suave.Logging.TraceHeader : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ulong traceId@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ulong reqId@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ulong> reqParentId@;
    [CompilationMappingAttribute]
public ulong traceId { get; }
    [CompilationMappingAttribute]
public ulong reqId { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<ulong> reqParentId { get; }
    public static TraceHeader empty { get; }
    public TraceHeader(ulong traceId, ulong reqId, FSharpOption`1<ulong> reqParentId);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ulong get_traceId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ulong get_reqId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<ulong> get_reqParentId();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(TraceHeader obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static TraceHeader get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TraceHeader create(FSharpOption`1<ulong> traceId, FSharpOption`1<ulong> spanParentId);
    public static TraceHeader parseTraceHeaders(FSharpList`1<Tuple`2<string, string>> headers);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(TraceHeader obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Suave.Model : object {
    [CompilationMappingAttribute]
public static ChoiceBuilder binding { get; }
    public static ChoiceBuilder get_binding();
}
[CompilationMappingAttribute]
internal static class Suave.Native : object {
    internal static int SOL_SOCKET_OSX { get; }
    internal static int SO_REUSEADDR_OSX { get; }
    internal static int SOL_SOCKET_LINUX { get; }
    internal static int SO_REUSEADDR_LINUX { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_SOL_SOCKET_OSX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_SO_REUSEADDR_OSX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_SOL_SOCKET_LINUX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_SO_REUSEADDR_LINUX();
    internal static int setsockopt(IntPtr socket, int level, int option_name, IntPtr option_value, UInt32 option_len);
}
[CompilationMappingAttribute]
public static class Suave.Operators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<b>> op_GreaterGreaterEquals(FSharpAsync`1<FSharpOption`1<a>> a, FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<b>>> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<c>>> op_GreaterEqualsGreater(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<b>>> a, FSharpFunc`2<b, FSharpAsync`1<FSharpOption`1<c>>> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> op_LessBarGreater(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> a, FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpOption`1<b>> op_AtAt(FSharpFunc`2<a, FSharpOption`1<b>> a, FSharpFunc`2<a, FSharpOption`1<b>> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<a, c> op_BarAt(FSharpChoice`2<a, b> c, c errorMsg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<a, b> op_BarBarAt(FSharpOption`1<a> opt, b errorMsg);
}
[CompilationMappingAttribute]
public static class Suave.Proxy : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> op_Dynamic(IEnumerable`1<Tuple`2<string, a>> headers, string name);
    internal static Task`1<FSharpResult`2<Unit, Error>> writeContentLengthHeader@28-11(FSharpList`1<Tuple`2<string, string>> headers, Connection conn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HttpContext httpWebResponseToHttpContext(HttpContext ctx, HttpWebResponse response);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<FSharpOption`1<HttpContext>> catchHandler@1-5(HttpContext ctx, string remappedAddress, Exception _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> proxy(Uri newHost, HttpContext ctx);
}
[CompilationMappingAttribute]
public static class Suave.Redirection : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> not_modified { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> NOT_MODIFIED { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> moved_permanently(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> MOVED_PERMANENTLY(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> found(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> FOUND(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> redirect(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> see_other(string location);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_not_modified();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_NOT_MODIFIED();
}
[CompilationMappingAttribute]
public static class Suave.RequestErrors : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> challenge { get; }
    [CompilationMappingAttribute]
internal static string body@211 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> request_timeout { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> bad_request(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> BAD_REQUEST(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unauthorized(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> UNAUTHORIZED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_challenge();
    internal static string get_body@211();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> forbidden(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> FORBIDDEN(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> not_found(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> NOT_FOUND(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> method_not_allowed(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> METHOD_NOT_ALLOWED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> not_acceptable(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> NOT_ACCEPTABLE(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_request_timeout();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> conflict(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> CONFLICT(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> gone(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> GONE(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unsupported_media_type(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> UNSUPPORTED_MEDIA_TYPE(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unprocessable_entity(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> UNPROCESSABLE_ENTITY(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> precondition_required(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> PRECONDITION_REQUIRED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> too_many_requests(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> TOO_MANY_REQUESTS(string body);
}
[CompilationMappingAttribute]
public static class Suave.Response : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> response(HttpCode statusCode, Byte[] content);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Runtime : object {
    public static FSharpChoice`2<IPAddress, Unit> IPAddress.tryParseC.Static(string ip);
}
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Suave.ScanResult : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _found;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Error item;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScanResult NeedMore { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNeedMore { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFound { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int found { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Error Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScanResult(int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScanResult(int _found, int _tag, byte );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScanResult(Error item, int _tag, sbyte );
    [CompilationMappingAttribute]
public static ScanResult get_NeedMore();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNeedMore();
    [CompilationMappingAttribute]
public static ScanResult NewFound(int _found);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFound();
    [CompilationMappingAttribute]
public static ScanResult NewError(Error item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_found();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Error get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(ScanResult obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(ScanResult obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Suave.SelectResult : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Error _error;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsContinue { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Error error { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SelectResult(Error _error, int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SelectResult(int item, int _tag, byte );
    [CompilationMappingAttribute]
public static SelectResult NewFailWith(Error _error);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailWith();
    [CompilationMappingAttribute]
public static SelectResult NewContinue(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsContinue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Error get_error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(SelectResult obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(SelectResult obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Suave.ServerErrors : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> INVALID_HTTP_VERSION { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> internal_error(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> INTERNAL_ERROR(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> not_implemented(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> NOT_IMPLEMENTED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> bad_gateway(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> BAD_GATEWAY(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> service_unavailable(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> SERVICE_UNAVAILABLE(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> gateway_timeout(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> GATEWAY_TIMEOUT(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> invalid_http_version(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_INVALID_HTTP_VERSION();
}
[CompilationMappingAttribute]
internal static class Suave.ServeResource : object {
    internal static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> sendIt@480(string key, FSharpFunc`2<string, DateTimeOffset> getLast, FSharpFunc`2<string, FSharpFunc`2<bool, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> send, string name, bool compression);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<FSharpOption`1<HttpContext>> resource$cont@487(string key, FSharpFunc`2<string, DateTimeOffset> getLast, FSharpFunc`2<string, string> getExtension, FSharpFunc`2<string, FSharpFunc`2<bool, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> send, HttpContext ctx, FSharpFunc`2<string, Unit> log, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpOption`1<HttpContext>> resource(string key, FSharpFunc`2<string, bool> exists, FSharpFunc`2<string, DateTimeOffset> getLast, FSharpFunc`2<string, string> getExtension, FSharpFunc`2<string, FSharpFunc`2<bool, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> send, HttpContext ctx);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Sockets.AsyncSocket : object {
    [CompilationMappingAttribute]
internal static Memory`1<byte> zeroCharMemory { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> transferStreamWithBuffer(ArraySegment`1<byte> buf, Connection toStream, Stream from);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> transferStream(Connection toStream, Stream from);
    internal static Memory`1<byte> get_zeroCharMemory();
    internal static Task`1<FSharpResult`2<Unit, Error>> doBlock@51(Stream from, ArraySegment`1<byte> buf, Connection conn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> transferStreamChunked(Connection conn, Stream from);
}
[CompilationMappingAttribute]
public class Suave.Sockets.ConcurrentPool`1 : object {
    internal ConcurrentBag`1<T> objects;
    internal Func`1<T> objectGenerator;
    public Func`1<T> ObjectGenerator { get; public set; }
    public T Pop();
    public void Push(T item);
    public Func`1<T> get_ObjectGenerator();
    public void set_ObjectGenerator(Func`1<T> value);
}
[CompilationMappingAttribute]
public class Suave.Sockets.Connection : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
public SocketBinding socketBinding@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcpTransport transport@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal HttpReader reader@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Pipe pipe@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Byte[] lineBuffer@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
public int lineBufferCount@;
    [CompilationMappingAttribute]
public SocketBinding socketBinding { get; public set; }
    [CompilationMappingAttribute]
public TcpTransport transport { get; }
    [CompilationMappingAttribute]
public HttpReader reader { get; }
    [CompilationMappingAttribute]
public Pipe pipe { get; }
    [CompilationMappingAttribute]
public Byte[] lineBuffer { get; }
    [CompilationMappingAttribute]
public int lineBufferCount { get; public set; }
    public IPAddress ipAddr { get; }
    public ushort port { get; }
    public Connection(SocketBinding socketBinding, TcpTransport transport, HttpReader reader, Pipe pipe, Byte[] lineBuffer, int lineBufferCount);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SocketBinding get_socketBinding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TcpTransport get_transport();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public HttpReader get_reader();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Pipe get_pipe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Byte[] get_lineBuffer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_lineBufferCount();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_socketBinding(SocketBinding value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_lineBufferCount(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public IPAddress get_ipAddr();
    public ushort get_port();
    public Task`1<FSharpResult`2<Unit, Error>> flush();
    public Task`1<FSharpResult`2<Unit, Error>> asyncWrite(string str);
    public Task`1<FSharpResult`2<Unit, Error>> asyncWriteLn(string s);
    public Task`1<FSharpResult`2<Unit, Error>> asyncWriteBytes(Byte[] b);
    public Task`1<FSharpResult`2<Unit, Error>> asyncWriteBufferedBytes(Byte[] b);
    public Task`1<FSharpResult`2<Unit, Error>> asyncWriteBufferedArrayBytes(Byte[][] xxs);
    public Task`1<FSharpResult`2<Unit, Error>> writeChunk(Byte[] chunk);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(Connection obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Suave.Sockets.ConnectionModule : object {
    [CompilationMappingAttribute]
public static Connection empty { get; }
    public static Connection get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<int, a>> receive(Connection cn, Memory`1<byte> buf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, a>> send(Connection cn, Memory`1<byte> buf);
}
[CompilationMappingAttribute]
public class Suave.Sockets.Control.SocketMonad : object {
    public Task`1<FSharpResult`2<a, Error>> Return(a x);
    public Task`1<FSharpResult`2<Unit, Error>> Zero();
    public Task`1<FSharpResult`2<a, Error>> ReturnFrom(Task`1<FSharpResult`2<a, Error>> x);
    public Task`1<FSharpResult`2<a, Error>> Delay(FSharpFunc`2<Unit, Task`1<FSharpResult`2<a, Error>>> f);
    public Task`1<FSharpResult`2<b, Error>> Bind(Task`1<FSharpResult`2<a, Error>> x, FSharpFunc`2<a, Task`1<FSharpResult`2<b, Error>>> f);
    public Task`1<FSharpResult`2<g, Error>> Combine(Task`1<FSharpResult`2<Unit, Error>> v, Task`1<FSharpResult`2<g, Error>> f);
    public Task`1<FSharpResult`2<Unit, Error>> While(FSharpFunc`2<Unit, bool> guard, Task`1<FSharpResult`2<Unit, Error>> body);
    public Task`1<e> TryWith(Task`1<e> body, FSharpFunc`2<Exception, f> handler);
    public Task`1<d> TryFinally(Task`1<d> body, FSharpFunc`2<Unit, Unit> compensation);
    public Task`1<c> Using(a disposable, FSharpFunc`2<a, b> body);
    public Task`1<FSharpResult`2<Unit, Error>> For(IEnumerable`1<a> sequence, FSharpFunc`2<a, Task`1<FSharpResult`2<Unit, Error>>> body);
}
[AutoOpenAttribute]
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Suave.Sockets.Control.SocketMonadModule : object {
    [CompilationMappingAttribute]
public static SocketMonad socket { get; }
    public static SocketMonad get_socket();
}
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Suave.Sockets.Error : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SocketError _error;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2<FSharpOption`1<int>, string> _dataError;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSocketError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInputDataError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConnectionError { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SocketError error { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<FSharpOption`1<int>, string> dataError { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Error(SocketError _error, int _tag, bool );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Error(Tuple`2<FSharpOption`1<int>, string> _dataError, int _tag, byte );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Error(string item, int _tag, sbyte );
    [CompilationMappingAttribute]
public static Error NewSocketError(SocketError _error);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSocketError();
    [CompilationMappingAttribute]
public static Error NewInputDataError(Tuple`2<FSharpOption`1<int>, string> _dataError);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInputDataError();
    [CompilationMappingAttribute]
public static Error NewConnectionError(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConnectionError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SocketError get_error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<FSharpOption`1<int>, string> get_dataError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(Error obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(Error obj);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Suave.Sockets.SocketOpModule : object {
    public static Task`1<FSharpResult`2<T, Error>> mreturn(T x);
    public static Task`1<FSharpResult`2<a, Error>> abort(Error x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<a, Error>> orInputError(FSharpOption`1<int> errorMsg_0, string errorMsg_1, FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<a, Error>> orInputErrorf(FSharpFunc`2<string, Tuple`2<FSharpOption`1<int>, string>> fErrorMsg, FSharpResult`2<a, string> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<b, Error>> bind(FSharpFunc`2<a, Task`1<FSharpResult`2<b, Error>>> fCont, Task`1<FSharpResult`2<a, Error>> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<a, Error>> bindError(FSharpFunc`2<Error, Task`1<FSharpResult`2<a, Error>>> fCont, Task`1<FSharpResult`2<a, Error>> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<b, Error>> map(FSharpFunc`2<a, b> f, Task`1<FSharpResult`2<a, Error>> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<a, Error>> mapError(FSharpFunc`2<Error, Error> f, Task`1<FSharpResult`2<a, Error>> value);
    public static Task`1<FSharpResult`2<a, Error>> ofAsync(FSharpAsync`1<a> a);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute]
public class Suave.Sockets.TcpTransport : object {
    internal Socket listenSocket;
    internal CancellationToken cancellationToken;
    [DefaultValueAttribute]
public Socket acceptSocket;
    public TcpTransport(Socket listenSocket, CancellationToken cancellationToken);
    public Task`1<FSharpResult`2<SocketBinding, c>> accept();
    public Task`1<FSharpResult`2<int, b>> read(Memory`1<byte> buf);
    public Task`1<FSharpResult`2<Unit, a>> write(Memory`1<byte> buf);
    public void shutdown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void shutdownSocket(Socket acceptSocket);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SocketBinding remoteBinding(Socket socket);
}
[CompilationMappingAttribute]
public static class Suave.Sscanf : object {
    [CompilationMappingAttribute]
public static IDictionary`2<char, FSharpFunc`2<string, object>> parsers { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, long> func1@1-3 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, string> func1@1-4 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, string> func1@1-5 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, long> func1@1-6 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, string> func1@1-7 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, string> func1@1-8 { get; }
    [CompilationMappingAttribute]
public static String[] separators { get; }
    [CompilationMappingAttribute]
internal static ICollection`1<char> arg@1 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string check(FSharpFunc`2<string, bool> f, string x);
    internal static decimal parseDecimal(string x);
    public static IDictionary`2<char, FSharpFunc`2<string, object>> get_parsers();
    internal static FSharpFunc`2<string, long> get_func1@1-3();
    internal static FSharpFunc`2<string, string> get_func1@1-4();
    internal static FSharpFunc`2<string, string> get_func1@1-5();
    internal static FSharpFunc`2<string, long> get_func1@1-6();
    internal static FSharpFunc`2<string, string> get_func1@1-7();
    internal static FSharpFunc`2<string, string> get_func1@1-8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-9(string value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-10(string value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-11(string value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-12(string value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-13(string value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double func1@1-14(string value);
    public static String[] get_separators();
    internal static ICollection`1<char> get_arg@1();
    public static FSharpList`1<char> getFormatters(FSharpList`1<char> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object coerce(object o, Type v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static t sscanf(PrintfFormat`5<a, b, c, d, t> pf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static t sscanfci(PrintfFormat`5<a, b, c, d, t> pf, string s);
}
[CompilationMappingAttribute]
public static class Suave.State : object {
}
[CompilationMappingAttribute]
public static class Suave.Stream : object {
    internal static FSharpFunc`2<Tuple`2<Connection, a>, Task`1<FSharpResult`2<Unit, Error>>> write@14-5(FSharpAsync`1<Stream> makeStream, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> okStream(FSharpAsync`1<Stream> makeStream, HttpContext ctx);
    internal static FSharpFunc`2<Tuple`2<Connection, a>, Task`1<FSharpResult`2<Unit, Error>>> write@41-20(FSharpAsync`1<Stream> makeStream, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> okStreamChunked(FSharpAsync`1<Stream> makeStream, HttpContext ctx);
}
[CompilationMappingAttribute]
public class Suave.SuaveConfig : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<HttpBinding> bindings@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Byte[] serverKey@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Exception, FSharpFunc`2<string, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> errorHandler@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TimeSpan listenTimeout@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal CancellationToken cancellationToken@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int bufferSize@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int maxOps@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, FSharpOption`1<MimeType>> mimeTypesMap@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> homeFolder@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> compressedFilesFolder@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Logger logger@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal CookieSerialiser cookieSerialiser@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool hideHeader@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int maxContentLength@;
    [CompilationMappingAttribute]
public FSharpList`1<HttpBinding> bindings { get; }
    [CompilationMappingAttribute]
public Byte[] serverKey { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<Exception, FSharpFunc`2<string, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> errorHandler { get; }
    [CompilationMappingAttribute]
public TimeSpan listenTimeout { get; }
    [CompilationMappingAttribute]
public CancellationToken cancellationToken { get; }
    [CompilationMappingAttribute]
public int bufferSize { get; }
    [CompilationMappingAttribute]
public int maxOps { get; }
    [CompilationMappingAttribute]
public FSharpFunc`2<string, FSharpOption`1<MimeType>> mimeTypesMap { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> homeFolder { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> compressedFilesFolder { get; }
    [CompilationMappingAttribute]
public Logger logger { get; }
    [CompilationMappingAttribute]
public CookieSerialiser cookieSerialiser { get; }
    [CompilationMappingAttribute]
public bool hideHeader { get; }
    [CompilationMappingAttribute]
public int maxContentLength { get; }
    public SuaveConfig(FSharpList`1<HttpBinding> bindings, Byte[] serverKey, FSharpFunc`2<Exception, FSharpFunc`2<string, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> errorHandler, TimeSpan listenTimeout, CancellationToken cancellationToken, int bufferSize, int maxOps, FSharpFunc`2<string, FSharpOption`1<MimeType>> mimeTypesMap, FSharpOption`1<string> homeFolder, FSharpOption`1<string> compressedFilesFolder, Logger logger, CookieSerialiser cookieSerialiser, bool hideHeader, int maxContentLength);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<HttpBinding> get_bindings();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Byte[] get_serverKey();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<Exception, FSharpFunc`2<string, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> get_errorHandler();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TimeSpan get_listenTimeout();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public CancellationToken get_cancellationToken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_bufferSize();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_maxOps();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<string, FSharpOption`1<MimeType>> get_mimeTypesMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_homeFolder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_compressedFilesFolder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Logger get_logger();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public CookieSerialiser get_cookieSerialiser();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_hideHeader();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_maxContentLength();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public SuaveConfig withBindings(FSharpList`1<HttpBinding> v);
    public SuaveConfig withServerKey(Byte[] v);
    public SuaveConfig withErrorHandler(FSharpFunc`2<Exception, FSharpFunc`2<string, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>>>> v);
    public SuaveConfig withListenTimeout(TimeSpan v);
    public SuaveConfig withCancellationToken(CancellationToken v);
    public SuaveConfig withBufferSize(int v);
    public SuaveConfig withMaxOps(int v);
    public SuaveConfig withMimeTypesMap(FSharpFunc`2<string, FSharpOption`1<MimeType>> v);
    public SuaveConfig withHomeFolder(FSharpOption`1<string> v);
    public SuaveConfig withCompressedFilesFolder(FSharpOption`1<string> v);
    public SuaveConfig withLogger(Logger v);
    public SuaveConfig withHiddenHeader(bool v);
    public SuaveConfig withMaxContentLength(int v);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Suave.SuaveConfigModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpBinding, HttpRuntime> toRuntime(SuaveConfig config, string contentFolder, string compressionFolder);
    public static HttpBinding firstBinding(SuaveConfig cfg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Uri firstBindingUri(SuaveConfig cfg, string path, string query);
}
[CompilationMappingAttribute]
public static class Suave.Successful : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> no_content { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> NO_CONTENT { get; }
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> ok(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> OK(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> created(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> CREATED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> accepted(Byte[] bytes);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> ACCEPTED(string body);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_no_content();
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> get_NO_CONTENT();
}
[CompilationMappingAttribute]
public static class Suave.Tcp : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int MaxBacklog;
    [CompilationMappingAttribute]
internal static Logger logger { get; }
    private static Tcp();
    internal static Logger get_logger();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stopTcp(a reason, Socket socket);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TcpTransport createTransport(Socket listenSocket, CancellationToken cancellationToken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HttpReader createReader(TcpTransport transport, Byte[] lineBuffer, Pipe pipe, CancellationToken cancellationToken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Connection createConnection(Socket listenSocket, CancellationToken cancellationToken, int bufferSize);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ConnectionFacade createConnectionFacade(ConcurrentPool`1<ConnectionFacade> connectionPool, Socket listenSocket, HttpRuntime runtime, CancellationToken cancellationToken, int bufferSize, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ConcurrentPool`1<ConnectionFacade> createPools(Socket listenSocket, int maxOps, HttpRuntime runtime, CancellationToken cancellationToken, int bufferSize, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart);
    internal static Task`1<Unit> aFewTimes(FSharpFunc`2<Unit, Unit> f);
    internal static void aFewTimesDeterministic(FSharpFunc`2<Unit, Unit> f);
    public static void enableRebinding(Socket listenSocket);
    internal static SocketBinding remoteBinding@162(Socket socket);
    internal static void continuation@168(CancellationToken cancellationToken, ConnectionFacade connection, Task`1<Socket> vt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task runServer(int maxConcurrentOps, int bufferSize, SocketBinding binding, HttpRuntime runtime, CancellationToken cancellationToken, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart, StartedData startData, AsyncResultCell`1<StartedData> acceptingConnections);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpAsync`1<FSharpOption`1<StartedData>>, Task> startTcpIpServerAsync(SocketBinding binding, FSharpFunc`2<StartedData, FSharpFunc`2<AsyncResultCell`1<StartedData>, Task>> runServer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpAsync`1<FSharpOption`1<StartedData>>, Task> startTcpIpServer(SocketBinding binding, FSharpFunc`2<StartedData, FSharpFunc`2<AsyncResultCell`1<StartedData>, Task>> runServer);
}
[CompilationMappingAttribute]
public static class Suave.TcpServerFactory : object {
    [CompilationMappingAttribute]
public static DefaultTcpServerFactory tcpServerFactory { get; }
    public static DefaultTcpServerFactory get_tcpServerFactory();
}
[CompilationMappingAttribute]
public static class Suave.TransferEncoding : object {
    internal static FSharpFunc`2<Tuple`2<Connection, a>, Task`1<FSharpResult`2<Unit, Error>>> task@827(FSharpFunc`2<Connection, Task`1<FSharpResult`2<Unit, Error>>> asyncWriteChunks);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> chunked(FSharpFunc`2<Connection, Task`1<FSharpResult`2<Unit, Error>>> asyncWriteChunks);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Suave.Utils.ASCII : object {
    public static Byte[] bytes(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int bytesToBuffer(string s, Byte[] buff, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string toStringAtOffset(Byte[] buff, int index, int count);
    public static string toString(Byte[] b);
    public static string encodeBase64(string s);
    public static string decodeBase64(string s);
}
[CompilationMappingAttribute]
public static class Suave.Utils.Async : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task`1<T> t, FSharpFunc`2<T, FSharpAsync`1<R>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task t, FSharpFunc`2<Unit, FSharpAsync`1<R>> f);
    public static FSharpFunc`2<a, FSharpAsync`1<a>> result();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<b> map(FSharpFunc`2<a, b> f, FSharpAsync`1<a> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<b> bind(FSharpFunc`2<a, FSharpAsync`1<b>> f, FSharpAsync`1<a> xAsync);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<FSharpOption`1<a>> catchHandler@1(Exception _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<a>> withTimeout(int timeoutMillis, FSharpAsync`1<a> operation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<b> apply(FSharpAsync`1<FSharpFunc`2<a, b>> fAsync, FSharpAsync`1<a> xAsync);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<c> lift2(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, FSharpAsync`1<a> x, FSharpAsync`1<b> y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<d> lift3(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> f, FSharpAsync`1<a> x, FSharpAsync`1<b> y, FSharpAsync`1<c> z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<e> lift4(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, e>>>> f, FSharpAsync`1<a> x, FSharpAsync`1<b> y, FSharpAsync`1<c> z, FSharpAsync`1<d> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<f> lift5(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, f>>>>> f, FSharpAsync`1<a> x, FSharpAsync`1<b> y, FSharpAsync`1<c> z, FSharpAsync`1<d> a, FSharpAsync`1<e> b);
}
[CompilationMappingAttribute]
public static class Suave.Utils.AsyncExtensions : object {
    internal static FSharpFunc`2<d, Unit> invokeOnce'@20(FSharpRef`1<int> counter, FSharpFunc`2<d, Unit> f);
    internal static Tuple`3<FSharpFunc`2<a, Unit>, FSharpFunc`2<b, Unit>, FSharpFunc`2<c, Unit>> invokeOnce(FSharpFunc`2<a, Unit> a, FSharpFunc`2<b, Unit> b, FSharpFunc`2<c, Unit> c);
    internal static FSharpFunc`2<Tuple`3<FSharpFunc`2<T, Unit>, FSharpFunc`2<Exception, Unit>, FSharpFunc`2<a, Unit>>, Unit> callback@30(TimeSpan timeout, FSharpAsync`1<T> computation);
    public static FSharpAsync`1<T> Async.WithTimeout.Static(TimeSpan timeout, FSharpAsync`1<T> computation);
    public static FSharpAsync`1<a> Async.AsyncRaise.Static(Exception e);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-1(Exception _arg5);
    internal static FSharpAsync`1<Unit> rewrapAsyncExn@55(FSharpAsync`1<Unit> it);
    public static FSharpAsync`1<Unit> Async.AwaitTask.Static(Task t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task`1<T> t, FSharpFunc`2<T, FSharpAsync`1<R>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task t, FSharpFunc`2<Unit, FSharpAsync`1<R>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, ValueTask t, FSharpFunc`2<Unit, FSharpAsync`1<R>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, ValueTask`1<T> t, FSharpFunc`2<T, FSharpAsync`1<R>> f);
    internal static void routine@84(AsyncCallback callback, TaskCompletionSource`1<TResult> tcs, Task`1<TResult> t);
    public static IAsyncResult Task`1.ToIAsyncResult.Static(Task`1<TResult> task, AsyncCallback callback, object state);
}
[CompilationMappingAttribute]
public class Suave.Utils.AsyncResultCell`1 : object {
    internal TaskCompletionSource`1<T> source;
    public bool complete(T result);
    public FSharpAsync`1<FSharpOption`1<T>> awaitResult(FSharpOption`1<TimeSpan> timeout);
}
[CompilationMappingAttribute]
internal static class Suave.Utils.Bytes : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string eol;
    [CompilationMappingAttribute]
internal static Tuple`2<FSharpFunc`2<Byte[], string>, FSharpFunc`2<string, Byte[]>> cookieEncoding { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<char, char>> repls@11 { get; }
    [CompilationMappingAttribute]
internal static Byte[] EOL { get; }
    [CompilationMappingAttribute]
internal static ArraySegment`1<byte> eolArraySegment { get; }
    [CompilationMappingAttribute]
internal static Memory`1<byte> eolMemory { get; }
    private static Bytes();
    internal static Tuple`2<FSharpFunc`2<Byte[], string>, FSharpFunc`2<string, Byte[]>> get_cookieEncoding();
    internal static FSharpList`1<Tuple`2<char, char>> get_repls@11();
    internal static Byte[] get_EOL();
    internal static ArraySegment`1<byte> get_eolArraySegment();
    internal static Memory`1<byte> get_eolMemory();
    internal static Int32[] initNext(a[] p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<long> _kmpW(Byte[] p, Int32[] next, long m, ReadOnlySequence`1<byte> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<long> kmpW(Byte[] p, ReadOnlySequence`1<byte> xs);
}
[CompilationMappingAttribute]
public static class Suave.Utils.Choice : object {
    public static FSharpChoice`2<a, b> create(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, Unit> bindUnit(FSharpFunc`2<a, FSharpChoice`2<b, Unit>> f, FSharpChoice`2<a, c> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, a> ofOption(a onMissing, FSharpOption`1<b> _arg1);
    public static FSharpOption`1<a> toOption(FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a orDefault(a onMissing, FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void iter(FSharpFunc`2<a, Unit> f, FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<a, string> parser(FSharpFunc`2<string, Tuple`2<bool, a>> parse, string err, string original);
    public static FSharpChoice`2<b, a> createSnd(a v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, c> map(FSharpFunc`2<a, b> f, FSharpChoice`2<a, c> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<c, b> mapSnd(FSharpFunc`2<a, b> f, FSharpChoice`2<c, a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<c, d> map2(FSharpFunc`2<a, c> f1, FSharpFunc`2<b, d> f2, FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, c> bind(FSharpFunc`2<a, FSharpChoice`2<b, c>> f, FSharpChoice`2<a, c> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<c, b> bindSnd(FSharpFunc`2<a, FSharpChoice`2<c, b>> f, FSharpChoice`2<c, a> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b fold(FSharpFunc`2<a, b> f, FSharpFunc`2<c, b> g, FSharpChoice`2<a, c> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, c> apply(FSharpChoice`2<FSharpFunc`2<a, b>, c> f, FSharpChoice`2<a, c> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<c, b> applySnd(FSharpChoice`2<FSharpFunc`2<a, b>, b> f, FSharpChoice`2<c, a> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<c, d> lift2(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, FSharpChoice`2<a, d> v1, FSharpChoice`2<b, d> v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<d, e> lift3(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> f, FSharpChoice`2<a, e> v1, FSharpChoice`2<b, e> v2, FSharpChoice`2<c, e> v3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<e, f> lift4(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, e>>>> f, FSharpChoice`2<a, f> v1, FSharpChoice`2<b, f> v2, FSharpChoice`2<c, f> v3, FSharpChoice`2<d, f> v4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<f, g> lift5(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, f>>>>> f, FSharpChoice`2<a, g> v1, FSharpChoice`2<b, g> v2, FSharpChoice`2<c, g> v3, FSharpChoice`2<d, g> v4, FSharpChoice`2<e, g> v5);
    public static FSharpChoice`2<a, b> ofResult(FSharpResult`2<a, b> _arg1);
    public static FSharpResult`2<a, b> toResult(FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<a, b> inject(FSharpFunc`2<a, Unit> f, FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, a> injectSnd(FSharpFunc`2<a, Unit> f, FSharpChoice`2<b, a> _arg1);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Utils.Collections : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<TValue, string> IDictionary`2.TryLookup(IDictionary`2<TKey, TValue> dict, TKey key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> getFirst(FSharpList`1<Tuple`2<string, string>> target, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> getFirstCaseInsensitive(FSharpList`1<Tuple`2<string, string>> target, string key);
    [ObsoleteAttribute("Use getFirstCaseInsensitive with an i")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> getFirstCaseInsensitve(FSharpList`1<Tuple`2<string, string>> target, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> getFirstOpt(FSharpList`1<Tuple`2<string, FSharpOption`1<string>>> target, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<b> tryGetChoice1(FSharpFunc`2<a, FSharpChoice`2<b, c>> f, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> op_PercentPercent(FSharpList`1<Tuple`2<string, string>> target, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, string> op_HatHat(FSharpList`1<Tuple`2<string, FSharpOption`1<string>>> target, string key);
}
[CompilationMappingAttribute]
public static class Suave.Utils.Compression : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<Byte[], Byte[]> gzipEncode { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Byte[], Byte[]> gzipDecode { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Byte[], Byte[]> deflateEncode { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Byte[], Byte[]> deflateDecode { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encode(FSharpFunc`2<Tuple`2<Stream, CompressionMode>, Stream> createStream, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] decode(FSharpFunc`2<Tuple`2<Stream, CompressionMode>, Stream> createStream, Byte[] bytes);
    internal static Stream gzip(Stream s, CompressionMode m);
    internal static Stream deflate(Stream s, CompressionMode m);
    public static FSharpFunc`2<Byte[], Byte[]> get_gzipEncode();
    public static FSharpFunc`2<Byte[], Byte[]> get_gzipDecode();
    public static FSharpFunc`2<Byte[], Byte[]> get_deflateEncode();
    public static FSharpFunc`2<Byte[], Byte[]> get_deflateDecode();
}
[CompilationMappingAttribute]
public static class Suave.Utils.Crypto : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string HMACAlgorithm;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static ushort HMACLength;
    public static ushort KeySize { get; }
    [CompilationMappingAttribute]
public static ushort KeyLength { get; }
    public static ushort BlockSize { get; }
    [CompilationMappingAttribute]
public static ushort IVLength { get; }
    [CompilationMappingAttribute]
public static RandomNumberGenerator cryptRandom { get; }
    private static Crypto();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] hmacAtOffset(Byte[] key, int offset, int count, Byte[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] hmacOfBytes(Byte[] key, Byte[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] hmacOfText(Byte[] key, IEnumerable`1<string> data);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static ushort get_KeySize();
    public static ushort get_KeyLength();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static ushort get_BlockSize();
    public static ushort get_IVLength();
    public static RandomNumberGenerator get_cryptRandom();
    public static Byte[] randomize(Byte[] bytes);
    public static Byte[] generateKey(ushort keyLength);
    public static Byte[] generateStdKey();
    public static Byte[] generateIV(ushort ivLength);
    public static Byte[] generateStdIV();
    public static Tuple`2<Byte[], Byte[]> generateKeys();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Aes secretboxInit(Byte[] key, Byte[] iv);
    internal static Byte[] createCipherText@102(Aes aes, Byte[] msg, Byte[] key, Byte[] iv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<Byte[], SecretboxEncryptionError> secretbox(Byte[] key, Byte[] msg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<Byte[], SecretboxEncryptionError> secretboxOfText(Byte[] key, string msg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equalsConstantTime(Byte[] bits, Byte[] bobs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpChoice`2<Byte[], SecretboxDecryptionError> secretboxOpen$cont@150(Byte[] key, Byte[] cipherText, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<Byte[], SecretboxDecryptionError> secretboxOpen(Byte[] key, Byte[] cipherText);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<string, SecretboxDecryptionError> secretboxOpenAsString(Byte[] keyText, Byte[] cipherText);
}
[CompilationMappingAttribute]
public static class Suave.Utils.CultureInfoCache : object {
    [CompilationMappingAttribute]
public static FSharpList`1<string> allCulturesList { get; }
    public static FSharpList`1<string> get_allCulturesList();
}
[CompilationMappingAttribute]
internal class Suave.Utils.OpenMemoryStream : OpenStream {
    internal Byte[] ToArray();
    internal Byte[] GetBuffer();
    internal void WriteTo(Stream other);
}
[CompilationMappingAttribute]
internal class Suave.Utils.OpenStream : Stream {
    internal MemoryStream stream@10;
    internal MemoryStream stream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public int WriteTimeout { get; public set; }
    public OpenStream(MemoryStream stream);
    internal MemoryStream get_stream();
    internal void Dispose();
    internal void RealDispose();
    public virtual void Close();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult ar);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual Task CopyToAsync(Stream other, int bufferSize, CancellationToken ct);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken ct);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken ct);
    public virtual int ReadByte();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int t);
    public virtual long Seek(long offset, SeekOrigin dir);
    public virtual void SetLength(long l);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long p);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken ct);
    public virtual void WriteByte(byte b);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int t);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute]
public static class Suave.Utils.Option : object {
    public static FSharpOption`1<a> create(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<b> apply(FSharpOption`1<FSharpFunc`2<a, b>> f, FSharpOption`1<a> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<c> lift2(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, FSharpOption`1<a> v1, FSharpOption`1<b> v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<d> lift3(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> f, FSharpOption`1<a> v1, FSharpOption`1<b> v2, FSharpOption`1<c> v3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<e> lift4(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, e>>>> f, FSharpOption`1<a> v1, FSharpOption`1<b> v2, FSharpOption`1<c> v3, FSharpOption`1<d> v4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<f> lift5(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, FSharpFunc`2<d, FSharpFunc`2<e, f>>>>> f, FSharpOption`1<a> v1, FSharpOption`1<b> v2, FSharpOption`1<c> v3, FSharpOption`1<d> v4, FSharpOption`1<e> v5);
    public static FSharpOption`1<a> ofChoice(FSharpChoice`2<a, b> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpChoice`2<b, a> toChoice(FSharpFunc`2<Unit, a> case2, FSharpOption`1<b> _arg1);
    public static FSharpOption`1<a> ofNullable(a nullable);
    public static Nullable`1<a> toNullable(FSharpOption`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a orDefault(FSharpFunc`2<Unit, a> x, FSharpOption`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> inject(FSharpFunc`2<a, Unit> f, FSharpOption`1<a> _arg1);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Suave.Utils.Parse : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<int, string>> int32 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<UInt32, string>> uint32 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<long, string>> int64 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<ulong, string>> uint64 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<Uri, string>> uri { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<DateTime, string>> dateTime { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<DateTimeOffset, string>> dateTimeOffset { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, FSharpChoice`2<decimal, string>> decimal { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<T, string> parseUsing(FSharpFunc`2<string, Tuple`2<bool, T>> f, string s);
    public static FSharpFunc`2<string, FSharpChoice`2<int, string>> get_int32();
    public static FSharpFunc`2<string, FSharpChoice`2<UInt32, string>> get_uint32();
    public static FSharpFunc`2<string, FSharpChoice`2<long, string>> get_int64();
    public static FSharpFunc`2<string, FSharpChoice`2<ulong, string>> get_uint64();
    public static FSharpFunc`2<string, FSharpChoice`2<Uri, string>> get_uri();
    public static FSharpFunc`2<string, FSharpChoice`2<DateTime, string>> get_dateTime();
    public static FSharpFunc`2<string, FSharpChoice`2<DateTimeOffset, string>> get_dateTimeOffset();
    public static FSharpFunc`2<string, FSharpChoice`2<decimal, string>> get_decimal();
}
[CompilationMappingAttribute]
internal static class Suave.Utils.Parsing : object {
    internal static bool isLocalAddress(string ip);
    internal static Tuple`2<string, FSharpOption`1<string>> parseArr@21(String[] d);
    internal static FSharpList`1<Tuple`2<string, FSharpOption`1<string>>> parseData(string s);
    internal static FSharpChoice`2<Tuple`4<string, string, string, string>, string> parseUrl(string line);
    internal static Dictionary`2<string, string> parseKVPairs(String[] arr);
    internal static Dictionary`2<string, string> headerParams(string header);
    internal static string parseBoundary(string contentType);
}
[CompilationMappingAttribute]
public class Suave.Utils.RangedStream : Stream {
    internal Stream stream;
    internal long start;
    internal FSharpOption`1<bool> disposeInner;
    internal long endPosition;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public RangedStream(Stream stream, long start, FSharpOption`1<long> limit, FSharpOption`1<bool> disposeInner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal long maxRead(long count);
}
[CompilationMappingAttribute]
public static class Suave.Utils.ThreadSafeRandom : object {
    [CompilationMappingAttribute]
internal static FSharpRef`1<int> seed { get; }
    [CompilationMappingAttribute]
internal static ThreadLocal`1<Random> rnd { get; }
    internal static FSharpRef`1<int> get_seed();
    internal static ThreadLocal`1<Random> get_rnd();
    public static void nextBytes(Byte[] buffer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int next(int minInclusive, int maxExclusive);
    public static ulong nextUInt64();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.Web : object {
    [CompilationMappingAttribute]
public static SuaveConfig defaultConfig { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> defaultErrorHandler(Exception ex, string msg, HttpContext ctx);
    internal static string resolveDirectory@40(FSharpOption`1<string> homeDirectory);
    internal static Tuple`2<FSharpAsync`1<FSharpOption`1<StartedData>>, Task> startWebWorker@56(SuaveConfig config, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart, HttpRuntime runtime);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpAsync`1<FSharpOption`1[]>, Task> startWebServerAsync(SuaveConfig config, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void startWebServer(SuaveConfig config, FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> webpart);
    public static SuaveConfig get_defaultConfig();
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Suave.WebPart : object {
    [CompilationMappingAttribute]
public static AsyncOptionBuilder asyncOption { get; }
    public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> succeed();
    public static FSharpAsync`1<FSharpOption`1<a>> fail();
    public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> never();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<b>> bind(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<b>>> f, FSharpAsync`1<FSharpOption`1<a>> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<c>> compose(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<b>>> first, FSharpFunc`2<b, FSharpAsync`1<FSharpOption`1<c>>> second, a x);
    public static AsyncOptionBuilder get_asyncOption();
    public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> choose(FSharpList`1<FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>>> options);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> inject(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> postOp, FSharpList`1<Tuple`2<FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>>, FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>>>> pairs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static u warbler(FSharpFunc`2<t, FSharpFunc`2<t, u>> f, t a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static t cnst(t x, u _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static V cond(FSharpChoice`2<T, ?> item, FSharpFunc`2<T, FSharpFunc`2<U, V>> f, FSharpFunc`2<U, V> g, U a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> tryThen(FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> first, FSharpFunc`2<a, FSharpAsync`1<FSharpOption`1<a>>> second);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<b> concatenate(FSharpFunc`2<a, FSharpOption`1<b>> first, FSharpFunc`2<a, FSharpOption`1<b>> second, a x);
}
[CompilationMappingAttribute]
public static class Suave.WebSocket : object {
    public static string magicGUID { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_magicGUID();
    internal static Byte[] sha1(string x);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> handShakeResponse(string handShakeToken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> handShakeWithSubprotocolResponse(string subprotocol, string handShakeToken);
    public static Opcode toOpcode(byte _arg1);
    public static byte fromOpcode(Opcode _arg1);
    internal static FrameHeader exctractHeader(Byte[] arr);
    internal static Byte[] bytesToNetworkOrder(Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Unit, Error>> writeFrame(Connection connection, Frame f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Frame frame(Opcode opcode, Memory`1<byte> data, bool fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Byte[], Error>> readBytes(Connection connection, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpResult`2<Memory`1<byte>, Error>> readBytesIntoByteSegment(FSharpFunc`2<int, Memory`1<byte>> retrieveByteSegment, Connection connection, int n);
    public static void fork(FSharpFunc`2<object, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Task`1<FSharpResult`2<Unit, Error>> handShakeAux(FSharpOption`1<string> webSocketProtocol, string webSocketKey, FSharpFunc`2<WebSocket, FSharpFunc`2<HttpContext, a>> continuation, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<string>> chooseSubprotocol(string subprotocol, String[] requestSubprotocols, HttpContext ctx);
    public static bool validateConnectionHeader(FSharpChoice`2<string, string> header);
    public static FSharpChoice`2<string, FSharpAsync`1<FSharpOption`1<HttpContext>>> validateHandShake(HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> handShakeWithSubprotocol(FSharpFunc`2<String[], FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<string>>>> choose, FSharpFunc`2<WebSocket, FSharpFunc`2<HttpContext, Task`1<FSharpResult`2<Unit, Error>>>> continuation, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<FSharpOption`1<HttpContext>> handShakeTask(FSharpFunc`2<WebSocket, FSharpFunc`2<HttpContext, Task`1<FSharpResult`2<Unit, Error>>>> continuation, HttpContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<HttpContext>> handShake(FSharpFunc`2<WebSocket, FSharpFunc`2<HttpContext, Task`1<FSharpResult`2<Unit, Error>>>> continuation, HttpContext ctx);
}
[CompilationMappingAttribute]
public static class Suave.Writers : object {
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setStatus(HttpCode status);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setHeader(string key, string value);
    internal static FSharpList`1<Tuple`2<string, string>> iter@43(string key, string value, HttpContext ctx, FSharpList`1<Tuple`2<string, string>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setHeaderValue(string key, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> addHeader(string key, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setUserData(string key, T value);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> unsetUserData(string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<MimeType> createMimeType(string name, bool compression);
    public static FSharpOption`1<MimeType> defaultMimeTypesMap(string ext);
    public static FSharpFunc`2<HttpContext, FSharpAsync`1<FSharpOption`1<HttpContext>>> setMimeType(string mimeType);
}
[CompilationMappingAttribute]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyDescription;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyMetadata_Commit;
}
